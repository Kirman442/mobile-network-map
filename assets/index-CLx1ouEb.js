import { _ as pS, r as mS } from "./parquet-wasm-BZNSEor2.js";
let Xv;
let __tla = (async ()=>{
    (function() {
        const e = document.createElement("link").relList;
        if (e && e.supports && e.supports("modulepreload")) return;
        for (const r of document.querySelectorAll('link[rel="modulepreload"]'))i(r);
        new MutationObserver((r)=>{
            for (const a of r)if (a.type === "childList") for (const l of a.addedNodes)l.tagName === "LINK" && l.rel === "modulepreload" && i(l);
        }).observe(document, {
            childList: !0,
            subtree: !0
        });
        function t(r) {
            const a = {};
            return r.integrity && (a.integrity = r.integrity), r.referrerPolicy && (a.referrerPolicy = r.referrerPolicy), r.crossOrigin === "use-credentials" ? a.credentials = "include" : r.crossOrigin === "anonymous" ? a.credentials = "omit" : a.credentials = "same-origin", a;
        }
        function i(r) {
            if (r.ep) return;
            r.ep = !0;
            const a = t(r);
            fetch(r.href, a);
        }
    })();
    Xv = function(n) {
        return n && n.__esModule && Object.prototype.hasOwnProperty.call(n, "default") ? n.default : n;
    };
    var Sh = {
        exports: {}
    }, eo = {};
    var $y;
    function _S() {
        if ($y) return eo;
        $y = 1;
        var n = Symbol.for("react.transitional.element"), e = Symbol.for("react.fragment");
        function t(i, r, a) {
            var l = null;
            if (a !== void 0 && (l = "" + a), r.key !== void 0 && (l = "" + r.key), "key" in r) {
                a = {};
                for(var u in r)u !== "key" && (a[u] = r[u]);
            } else a = r;
            return r = a.ref, {
                $$typeof: n,
                type: i,
                key: l,
                ref: r !== void 0 ? r : null,
                props: a
            };
        }
        return eo.Fragment = e, eo.jsx = t, eo.jsxs = t, eo;
    }
    var Xy;
    function yS() {
        return Xy || (Xy = 1, Sh.exports = _S()), Sh.exports;
    }
    var be = yS(), Ah = {
        exports: {}
    }, Se = {};
    var Yy;
    function bS() {
        if (Yy) return Se;
        Yy = 1;
        var n = Symbol.for("react.transitional.element"), e = Symbol.for("react.portal"), t = Symbol.for("react.fragment"), i = Symbol.for("react.strict_mode"), r = Symbol.for("react.profiler"), a = Symbol.for("react.consumer"), l = Symbol.for("react.context"), u = Symbol.for("react.forward_ref"), h = Symbol.for("react.suspense"), d = Symbol.for("react.memo"), p = Symbol.for("react.lazy"), _ = Symbol.iterator;
        function y(R) {
            return R === null || typeof R != "object" ? null : (R = _ && R[_] || R["@@iterator"], typeof R == "function" ? R : null);
        }
        var v = {
            isMounted: function() {
                return !1;
            },
            enqueueForceUpdate: function() {},
            enqueueReplaceState: function() {},
            enqueueSetState: function() {}
        }, S = Object.assign, E = {};
        function M(R, G, oe) {
            this.props = R, this.context = G, this.refs = E, this.updater = oe || v;
        }
        M.prototype.isReactComponent = {}, M.prototype.setState = function(R, G) {
            if (typeof R != "object" && typeof R != "function" && R != null) throw Error("takes an object of state variables to update or a function which returns an object of state variables.");
            this.updater.enqueueSetState(this, R, G, "setState");
        }, M.prototype.forceUpdate = function(R) {
            this.updater.enqueueForceUpdate(this, R, "forceUpdate");
        };
        function B() {}
        B.prototype = M.prototype;
        function H(R, G, oe) {
            this.props = R, this.context = G, this.refs = E, this.updater = oe || v;
        }
        var O = H.prototype = new B;
        O.constructor = H, S(O, M.prototype), O.isPureReactComponent = !0;
        var U = Array.isArray, L = {
            H: null,
            A: null,
            T: null,
            S: null,
            V: null
        }, Z = Object.prototype.hasOwnProperty;
        function se(R, G, oe, re, de, Ne) {
            return oe = Ne.ref, {
                $$typeof: n,
                type: R,
                key: G,
                ref: oe !== void 0 ? oe : null,
                props: Ne
            };
        }
        function ae(R, G) {
            return se(R.type, G, void 0, void 0, void 0, R.props);
        }
        function te(R) {
            return typeof R == "object" && R !== null && R.$$typeof === n;
        }
        function fe(R) {
            var G = {
                "=": "=0",
                ":": "=2"
            };
            return "$" + R.replace(/[=:]/g, function(oe) {
                return G[oe];
            });
        }
        var ne = /\/+/g;
        function ve(R, G) {
            return typeof R == "object" && R !== null && R.key != null ? fe("" + R.key) : G.toString(36);
        }
        function Te() {}
        function ue(R) {
            switch(R.status){
                case "fulfilled":
                    return R.value;
                case "rejected":
                    throw R.reason;
                default:
                    switch(typeof R.status == "string" ? R.then(Te, Te) : (R.status = "pending", R.then(function(G) {
                        R.status === "pending" && (R.status = "fulfilled", R.value = G);
                    }, function(G) {
                        R.status === "pending" && (R.status = "rejected", R.reason = G);
                    })), R.status){
                        case "fulfilled":
                            return R.value;
                        case "rejected":
                            throw R.reason;
                    }
            }
            throw R;
        }
        function Ie(R, G, oe, re, de) {
            var Ne = typeof R;
            (Ne === "undefined" || Ne === "boolean") && (R = null);
            var _e = !1;
            if (R === null) _e = !0;
            else switch(Ne){
                case "bigint":
                case "string":
                case "number":
                    _e = !0;
                    break;
                case "object":
                    switch(R.$$typeof){
                        case n:
                        case e:
                            _e = !0;
                            break;
                        case p:
                            return _e = R._init, Ie(_e(R._payload), G, oe, re, de);
                    }
            }
            if (_e) return de = de(R), _e = re === "" ? "." + ve(R, 0) : re, U(de) ? (oe = "", _e != null && (oe = _e.replace(ne, "$&/") + "/"), Ie(de, G, oe, "", function(Re) {
                return Re;
            })) : de != null && (te(de) && (de = ae(de, oe + (de.key == null || R && R.key === de.key ? "" : ("" + de.key).replace(ne, "$&/") + "/") + _e)), G.push(de)), 1;
            _e = 0;
            var Pt = re === "" ? "." : re + ":";
            if (U(R)) for(var Ze = 0; Ze < R.length; Ze++)re = R[Ze], Ne = Pt + ve(re, Ze), _e += Ie(re, G, oe, Ne, de);
            else if (Ze = y(R), typeof Ze == "function") for(R = Ze.call(R), Ze = 0; !(re = R.next()).done;)re = re.value, Ne = Pt + ve(re, Ze++), _e += Ie(re, G, oe, Ne, de);
            else if (Ne === "object") {
                if (typeof R.then == "function") return Ie(ue(R), G, oe, re, de);
                throw G = String(R), Error("Objects are not valid as a React child (found: " + (G === "[object Object]" ? "object with keys {" + Object.keys(R).join(", ") + "}" : G) + "). If you meant to render a collection of children, use an array instead.");
            }
            return _e;
        }
        function $(R, G, oe) {
            if (R == null) return R;
            var re = [], de = 0;
            return Ie(R, re, "", "", function(Ne) {
                return G.call(oe, Ne, de++);
            }), re;
        }
        function ee(R) {
            if (R._status === -1) {
                var G = R._result;
                G = G(), G.then(function(oe) {
                    (R._status === 0 || R._status === -1) && (R._status = 1, R._result = oe);
                }, function(oe) {
                    (R._status === 0 || R._status === -1) && (R._status = 2, R._result = oe);
                }), R._status === -1 && (R._status = 0, R._result = G);
            }
            if (R._status === 1) return R._result.default;
            throw R._result;
        }
        var ce = typeof reportError == "function" ? reportError : function(R) {
            if (typeof window == "object" && typeof window.ErrorEvent == "function") {
                var G = new window.ErrorEvent("error", {
                    bubbles: !0,
                    cancelable: !0,
                    message: typeof R == "object" && R !== null && typeof R.message == "string" ? String(R.message) : String(R),
                    error: R
                });
                if (!window.dispatchEvent(G)) return;
            } else if (typeof process == "object" && typeof process.emit == "function") {
                process.emit("uncaughtException", R);
                return;
            }
            console.error(R);
        };
        function Ae() {}
        return Se.Children = {
            map: $,
            forEach: function(R, G, oe) {
                $(R, function() {
                    G.apply(this, arguments);
                }, oe);
            },
            count: function(R) {
                var G = 0;
                return $(R, function() {
                    G++;
                }), G;
            },
            toArray: function(R) {
                return $(R, function(G) {
                    return G;
                }) || [];
            },
            only: function(R) {
                if (!te(R)) throw Error("React.Children.only expected to receive a single React element child.");
                return R;
            }
        }, Se.Component = M, Se.Fragment = t, Se.Profiler = r, Se.PureComponent = H, Se.StrictMode = i, Se.Suspense = h, Se.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE = L, Se.__COMPILER_RUNTIME = {
            __proto__: null,
            c: function(R) {
                return L.H.useMemoCache(R);
            }
        }, Se.cache = function(R) {
            return function() {
                return R.apply(null, arguments);
            };
        }, Se.cloneElement = function(R, G, oe) {
            if (R == null) throw Error("The argument must be a React element, but you passed " + R + ".");
            var re = S({}, R.props), de = R.key, Ne = void 0;
            if (G != null) for(_e in G.ref !== void 0 && (Ne = void 0), G.key !== void 0 && (de = "" + G.key), G)!Z.call(G, _e) || _e === "key" || _e === "__self" || _e === "__source" || _e === "ref" && G.ref === void 0 || (re[_e] = G[_e]);
            var _e = arguments.length - 2;
            if (_e === 1) re.children = oe;
            else if (1 < _e) {
                for(var Pt = Array(_e), Ze = 0; Ze < _e; Ze++)Pt[Ze] = arguments[Ze + 2];
                re.children = Pt;
            }
            return se(R.type, de, void 0, void 0, Ne, re);
        }, Se.createContext = function(R) {
            return R = {
                $$typeof: l,
                _currentValue: R,
                _currentValue2: R,
                _threadCount: 0,
                Provider: null,
                Consumer: null
            }, R.Provider = R, R.Consumer = {
                $$typeof: a,
                _context: R
            }, R;
        }, Se.createElement = function(R, G, oe) {
            var re, de = {}, Ne = null;
            if (G != null) for(re in G.key !== void 0 && (Ne = "" + G.key), G)Z.call(G, re) && re !== "key" && re !== "__self" && re !== "__source" && (de[re] = G[re]);
            var _e = arguments.length - 2;
            if (_e === 1) de.children = oe;
            else if (1 < _e) {
                for(var Pt = Array(_e), Ze = 0; Ze < _e; Ze++)Pt[Ze] = arguments[Ze + 2];
                de.children = Pt;
            }
            if (R && R.defaultProps) for(re in _e = R.defaultProps, _e)de[re] === void 0 && (de[re] = _e[re]);
            return se(R, Ne, void 0, void 0, null, de);
        }, Se.createRef = function() {
            return {
                current: null
            };
        }, Se.forwardRef = function(R) {
            return {
                $$typeof: u,
                render: R
            };
        }, Se.isValidElement = te, Se.lazy = function(R) {
            return {
                $$typeof: p,
                _payload: {
                    _status: -1,
                    _result: R
                },
                _init: ee
            };
        }, Se.memo = function(R, G) {
            return {
                $$typeof: d,
                type: R,
                compare: G === void 0 ? null : G
            };
        }, Se.startTransition = function(R) {
            var G = L.T, oe = {};
            L.T = oe;
            try {
                var re = R(), de = L.S;
                de !== null && de(oe, re), typeof re == "object" && re !== null && typeof re.then == "function" && re.then(Ae, ce);
            } catch (Ne) {
                ce(Ne);
            } finally{
                L.T = G;
            }
        }, Se.unstable_useCacheRefresh = function() {
            return L.H.useCacheRefresh();
        }, Se.use = function(R) {
            return L.H.use(R);
        }, Se.useActionState = function(R, G, oe) {
            return L.H.useActionState(R, G, oe);
        }, Se.useCallback = function(R, G) {
            return L.H.useCallback(R, G);
        }, Se.useContext = function(R) {
            return L.H.useContext(R);
        }, Se.useDebugValue = function() {}, Se.useDeferredValue = function(R, G) {
            return L.H.useDeferredValue(R, G);
        }, Se.useEffect = function(R, G, oe) {
            var re = L.H;
            if (typeof oe == "function") throw Error("useEffect CRUD overload is not enabled in this build of React.");
            return re.useEffect(R, G);
        }, Se.useId = function() {
            return L.H.useId();
        }, Se.useImperativeHandle = function(R, G, oe) {
            return L.H.useImperativeHandle(R, G, oe);
        }, Se.useInsertionEffect = function(R, G) {
            return L.H.useInsertionEffect(R, G);
        }, Se.useLayoutEffect = function(R, G) {
            return L.H.useLayoutEffect(R, G);
        }, Se.useMemo = function(R, G) {
            return L.H.useMemo(R, G);
        }, Se.useOptimistic = function(R, G) {
            return L.H.useOptimistic(R, G);
        }, Se.useReducer = function(R, G, oe) {
            return L.H.useReducer(R, G, oe);
        }, Se.useRef = function(R) {
            return L.H.useRef(R);
        }, Se.useState = function(R) {
            return L.H.useState(R);
        }, Se.useSyncExternalStore = function(R, G, oe) {
            return L.H.useSyncExternalStore(R, G, oe);
        }, Se.useTransition = function() {
            return L.H.useTransition();
        }, Se.version = "19.1.0", Se;
    }
    var qy;
    function ng() {
        return qy || (qy = 1, Ah.exports = bS()), Ah.exports;
    }
    var Q = ng(), wh = {
        exports: {}
    }, to = {}, Eh = {
        exports: {}
    }, Rh = {};
    var Ky;
    function vS() {
        return Ky || (Ky = 1, function(n) {
            function e($, ee) {
                var ce = $.length;
                $.push(ee);
                e: for(; 0 < ce;){
                    var Ae = ce - 1 >>> 1, R = $[Ae];
                    if (0 < r(R, ee)) $[Ae] = ee, $[ce] = R, ce = Ae;
                    else break e;
                }
            }
            function t($) {
                return $.length === 0 ? null : $[0];
            }
            function i($) {
                if ($.length === 0) return null;
                var ee = $[0], ce = $.pop();
                if (ce !== ee) {
                    $[0] = ce;
                    e: for(var Ae = 0, R = $.length, G = R >>> 1; Ae < G;){
                        var oe = 2 * (Ae + 1) - 1, re = $[oe], de = oe + 1, Ne = $[de];
                        if (0 > r(re, ce)) de < R && 0 > r(Ne, re) ? ($[Ae] = Ne, $[de] = ce, Ae = de) : ($[Ae] = re, $[oe] = ce, Ae = oe);
                        else if (de < R && 0 > r(Ne, ce)) $[Ae] = Ne, $[de] = ce, Ae = de;
                        else break e;
                    }
                }
                return ee;
            }
            function r($, ee) {
                var ce = $.sortIndex - ee.sortIndex;
                return ce !== 0 ? ce : $.id - ee.id;
            }
            if (n.unstable_now = void 0, typeof performance == "object" && typeof performance.now == "function") {
                var a = performance;
                n.unstable_now = function() {
                    return a.now();
                };
            } else {
                var l = Date, u = l.now();
                n.unstable_now = function() {
                    return l.now() - u;
                };
            }
            var h = [], d = [], p = 1, _ = null, y = 3, v = !1, S = !1, E = !1, M = !1, B = typeof setTimeout == "function" ? setTimeout : null, H = typeof clearTimeout == "function" ? clearTimeout : null, O = typeof setImmediate < "u" ? setImmediate : null;
            function U($) {
                for(var ee = t(d); ee !== null;){
                    if (ee.callback === null) i(d);
                    else if (ee.startTime <= $) i(d), ee.sortIndex = ee.expirationTime, e(h, ee);
                    else break;
                    ee = t(d);
                }
            }
            function L($) {
                if (E = !1, U($), !S) if (t(h) !== null) S = !0, Z || (Z = !0, ve());
                else {
                    var ee = t(d);
                    ee !== null && Ie(L, ee.startTime - $);
                }
            }
            var Z = !1, se = -1, ae = 5, te = -1;
            function fe() {
                return M ? !0 : !(n.unstable_now() - te < ae);
            }
            function ne() {
                if (M = !1, Z) {
                    var $ = n.unstable_now();
                    te = $;
                    var ee = !0;
                    try {
                        e: {
                            S = !1, E && (E = !1, H(se), se = -1), v = !0;
                            var ce = y;
                            try {
                                t: {
                                    for(U($), _ = t(h); _ !== null && !(_.expirationTime > $ && fe());){
                                        var Ae = _.callback;
                                        if (typeof Ae == "function") {
                                            _.callback = null, y = _.priorityLevel;
                                            var R = Ae(_.expirationTime <= $);
                                            if ($ = n.unstable_now(), typeof R == "function") {
                                                _.callback = R, U($), ee = !0;
                                                break t;
                                            }
                                            _ === t(h) && i(h), U($);
                                        } else i(h);
                                        _ = t(h);
                                    }
                                    if (_ !== null) ee = !0;
                                    else {
                                        var G = t(d);
                                        G !== null && Ie(L, G.startTime - $), ee = !1;
                                    }
                                }
                                break e;
                            } finally{
                                _ = null, y = ce, v = !1;
                            }
                            ee = void 0;
                        }
                    } finally{
                        ee ? ve() : Z = !1;
                    }
                }
            }
            var ve;
            if (typeof O == "function") ve = function() {
                O(ne);
            };
            else if (typeof MessageChannel < "u") {
                var Te = new MessageChannel, ue = Te.port2;
                Te.port1.onmessage = ne, ve = function() {
                    ue.postMessage(null);
                };
            } else ve = function() {
                B(ne, 0);
            };
            function Ie($, ee) {
                se = B(function() {
                    $(n.unstable_now());
                }, ee);
            }
            n.unstable_IdlePriority = 5, n.unstable_ImmediatePriority = 1, n.unstable_LowPriority = 4, n.unstable_NormalPriority = 3, n.unstable_Profiling = null, n.unstable_UserBlockingPriority = 2, n.unstable_cancelCallback = function($) {
                $.callback = null;
            }, n.unstable_forceFrameRate = function($) {
                0 > $ || 125 < $ ? console.error("forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported") : ae = 0 < $ ? Math.floor(1e3 / $) : 5;
            }, n.unstable_getCurrentPriorityLevel = function() {
                return y;
            }, n.unstable_next = function($) {
                switch(y){
                    case 1:
                    case 2:
                    case 3:
                        var ee = 3;
                        break;
                    default:
                        ee = y;
                }
                var ce = y;
                y = ee;
                try {
                    return $();
                } finally{
                    y = ce;
                }
            }, n.unstable_requestPaint = function() {
                M = !0;
            }, n.unstable_runWithPriority = function($, ee) {
                switch($){
                    case 1:
                    case 2:
                    case 3:
                    case 4:
                    case 5:
                        break;
                    default:
                        $ = 3;
                }
                var ce = y;
                y = $;
                try {
                    return ee();
                } finally{
                    y = ce;
                }
            }, n.unstable_scheduleCallback = function($, ee, ce) {
                var Ae = n.unstable_now();
                switch(typeof ce == "object" && ce !== null ? (ce = ce.delay, ce = typeof ce == "number" && 0 < ce ? Ae + ce : Ae) : ce = Ae, $){
                    case 1:
                        var R = -1;
                        break;
                    case 2:
                        R = 250;
                        break;
                    case 5:
                        R = 1073741823;
                        break;
                    case 4:
                        R = 1e4;
                        break;
                    default:
                        R = 5e3;
                }
                return R = ce + R, $ = {
                    id: p++,
                    callback: ee,
                    priorityLevel: $,
                    startTime: ce,
                    expirationTime: R,
                    sortIndex: -1
                }, ce > Ae ? ($.sortIndex = ce, e(d, $), t(h) === null && $ === t(d) && (E ? (H(se), se = -1) : E = !0, Ie(L, ce - Ae))) : ($.sortIndex = R, e(h, $), S || v || (S = !0, Z || (Z = !0, ve()))), $;
            }, n.unstable_shouldYield = fe, n.unstable_wrapCallback = function($) {
                var ee = y;
                return function() {
                    var ce = y;
                    y = ee;
                    try {
                        return $.apply(this, arguments);
                    } finally{
                        y = ce;
                    }
                };
            };
        }(Rh)), Rh;
    }
    var Zy;
    function TS() {
        return Zy || (Zy = 1, Eh.exports = vS()), Eh.exports;
    }
    var Ch = {
        exports: {}
    }, Rt = {};
    var Qy;
    function xS() {
        if (Qy) return Rt;
        Qy = 1;
        var n = ng();
        function e(h) {
            var d = "https://react.dev/errors/" + h;
            if (1 < arguments.length) {
                d += "?args[]=" + encodeURIComponent(arguments[1]);
                for(var p = 2; p < arguments.length; p++)d += "&args[]=" + encodeURIComponent(arguments[p]);
            }
            return "Minified React error #" + h + "; visit " + d + " for the full message or use the non-minified dev environment for full errors and additional helpful warnings.";
        }
        function t() {}
        var i = {
            d: {
                f: t,
                r: function() {
                    throw Error(e(522));
                },
                D: t,
                C: t,
                L: t,
                m: t,
                X: t,
                S: t,
                M: t
            },
            p: 0,
            findDOMNode: null
        }, r = Symbol.for("react.portal");
        function a(h, d, p) {
            var _ = 3 < arguments.length && arguments[3] !== void 0 ? arguments[3] : null;
            return {
                $$typeof: r,
                key: _ == null ? null : "" + _,
                children: h,
                containerInfo: d,
                implementation: p
            };
        }
        var l = n.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE;
        function u(h, d) {
            if (h === "font") return "";
            if (typeof d == "string") return d === "use-credentials" ? d : "";
        }
        return Rt.__DOM_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE = i, Rt.createPortal = function(h, d) {
            var p = 2 < arguments.length && arguments[2] !== void 0 ? arguments[2] : null;
            if (!d || d.nodeType !== 1 && d.nodeType !== 9 && d.nodeType !== 11) throw Error(e(299));
            return a(h, d, null, p);
        }, Rt.flushSync = function(h) {
            var d = l.T, p = i.p;
            try {
                if (l.T = null, i.p = 2, h) return h();
            } finally{
                l.T = d, i.p = p, i.d.f();
            }
        }, Rt.preconnect = function(h, d) {
            typeof h == "string" && (d ? (d = d.crossOrigin, d = typeof d == "string" ? d === "use-credentials" ? d : "" : void 0) : d = null, i.d.C(h, d));
        }, Rt.prefetchDNS = function(h) {
            typeof h == "string" && i.d.D(h);
        }, Rt.preinit = function(h, d) {
            if (typeof h == "string" && d && typeof d.as == "string") {
                var p = d.as, _ = u(p, d.crossOrigin), y = typeof d.integrity == "string" ? d.integrity : void 0, v = typeof d.fetchPriority == "string" ? d.fetchPriority : void 0;
                p === "style" ? i.d.S(h, typeof d.precedence == "string" ? d.precedence : void 0, {
                    crossOrigin: _,
                    integrity: y,
                    fetchPriority: v
                }) : p === "script" && i.d.X(h, {
                    crossOrigin: _,
                    integrity: y,
                    fetchPriority: v,
                    nonce: typeof d.nonce == "string" ? d.nonce : void 0
                });
            }
        }, Rt.preinitModule = function(h, d) {
            if (typeof h == "string") if (typeof d == "object" && d !== null) {
                if (d.as == null || d.as === "script") {
                    var p = u(d.as, d.crossOrigin);
                    i.d.M(h, {
                        crossOrigin: p,
                        integrity: typeof d.integrity == "string" ? d.integrity : void 0,
                        nonce: typeof d.nonce == "string" ? d.nonce : void 0
                    });
                }
            } else d == null && i.d.M(h);
        }, Rt.preload = function(h, d) {
            if (typeof h == "string" && typeof d == "object" && d !== null && typeof d.as == "string") {
                var p = d.as, _ = u(p, d.crossOrigin);
                i.d.L(h, p, {
                    crossOrigin: _,
                    integrity: typeof d.integrity == "string" ? d.integrity : void 0,
                    nonce: typeof d.nonce == "string" ? d.nonce : void 0,
                    type: typeof d.type == "string" ? d.type : void 0,
                    fetchPriority: typeof d.fetchPriority == "string" ? d.fetchPriority : void 0,
                    referrerPolicy: typeof d.referrerPolicy == "string" ? d.referrerPolicy : void 0,
                    imageSrcSet: typeof d.imageSrcSet == "string" ? d.imageSrcSet : void 0,
                    imageSizes: typeof d.imageSizes == "string" ? d.imageSizes : void 0,
                    media: typeof d.media == "string" ? d.media : void 0
                });
            }
        }, Rt.preloadModule = function(h, d) {
            if (typeof h == "string") if (d) {
                var p = u(d.as, d.crossOrigin);
                i.d.m(h, {
                    as: typeof d.as == "string" && d.as !== "script" ? d.as : void 0,
                    crossOrigin: p,
                    integrity: typeof d.integrity == "string" ? d.integrity : void 0
                });
            } else i.d.m(h);
        }, Rt.requestFormReset = function(h) {
            i.d.r(h);
        }, Rt.unstable_batchedUpdates = function(h, d) {
            return h(d);
        }, Rt.useFormState = function(h, d, p) {
            return l.H.useFormState(h, d, p);
        }, Rt.useFormStatus = function() {
            return l.H.useHostTransitionStatus();
        }, Rt.version = "19.1.0", Rt;
    }
    var Gy;
    function Yv() {
        if (Gy) return Ch.exports;
        Gy = 1;
        function n() {
            if (!(typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ > "u" || typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE != "function")) try {
                __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(n);
            } catch (e) {
                console.error(e);
            }
        }
        return n(), Ch.exports = xS(), Ch.exports;
    }
    var Jy;
    function SS() {
        if (Jy) return to;
        Jy = 1;
        var n = TS(), e = ng(), t = Yv();
        function i(s) {
            var o = "https://react.dev/errors/" + s;
            if (1 < arguments.length) {
                o += "?args[]=" + encodeURIComponent(arguments[1]);
                for(var c = 2; c < arguments.length; c++)o += "&args[]=" + encodeURIComponent(arguments[c]);
            }
            return "Minified React error #" + s + "; visit " + o + " for the full message or use the non-minified dev environment for full errors and additional helpful warnings.";
        }
        function r(s) {
            return !(!s || s.nodeType !== 1 && s.nodeType !== 9 && s.nodeType !== 11);
        }
        function a(s) {
            var o = s, c = s;
            if (s.alternate) for(; o.return;)o = o.return;
            else {
                s = o;
                do o = s, (o.flags & 4098) !== 0 && (c = o.return), s = o.return;
                while (s);
            }
            return o.tag === 3 ? c : null;
        }
        function l(s) {
            if (s.tag === 13) {
                var o = s.memoizedState;
                if (o === null && (s = s.alternate, s !== null && (o = s.memoizedState)), o !== null) return o.dehydrated;
            }
            return null;
        }
        function u(s) {
            if (a(s) !== s) throw Error(i(188));
        }
        function h(s) {
            var o = s.alternate;
            if (!o) {
                if (o = a(s), o === null) throw Error(i(188));
                return o !== s ? null : s;
            }
            for(var c = s, f = o;;){
                var g = c.return;
                if (g === null) break;
                var m = g.alternate;
                if (m === null) {
                    if (f = g.return, f !== null) {
                        c = f;
                        continue;
                    }
                    break;
                }
                if (g.child === m.child) {
                    for(m = g.child; m;){
                        if (m === c) return u(g), s;
                        if (m === f) return u(g), o;
                        m = m.sibling;
                    }
                    throw Error(i(188));
                }
                if (c.return !== f.return) c = g, f = m;
                else {
                    for(var b = !1, T = g.child; T;){
                        if (T === c) {
                            b = !0, c = g, f = m;
                            break;
                        }
                        if (T === f) {
                            b = !0, f = g, c = m;
                            break;
                        }
                        T = T.sibling;
                    }
                    if (!b) {
                        for(T = m.child; T;){
                            if (T === c) {
                                b = !0, c = m, f = g;
                                break;
                            }
                            if (T === f) {
                                b = !0, f = m, c = g;
                                break;
                            }
                            T = T.sibling;
                        }
                        if (!b) throw Error(i(189));
                    }
                }
                if (c.alternate !== f) throw Error(i(190));
            }
            if (c.tag !== 3) throw Error(i(188));
            return c.stateNode.current === c ? s : o;
        }
        function d(s) {
            var o = s.tag;
            if (o === 5 || o === 26 || o === 27 || o === 6) return s;
            for(s = s.child; s !== null;){
                if (o = d(s), o !== null) return o;
                s = s.sibling;
            }
            return null;
        }
        var p = Object.assign, _ = Symbol.for("react.element"), y = Symbol.for("react.transitional.element"), v = Symbol.for("react.portal"), S = Symbol.for("react.fragment"), E = Symbol.for("react.strict_mode"), M = Symbol.for("react.profiler"), B = Symbol.for("react.provider"), H = Symbol.for("react.consumer"), O = Symbol.for("react.context"), U = Symbol.for("react.forward_ref"), L = Symbol.for("react.suspense"), Z = Symbol.for("react.suspense_list"), se = Symbol.for("react.memo"), ae = Symbol.for("react.lazy"), te = Symbol.for("react.activity"), fe = Symbol.for("react.memo_cache_sentinel"), ne = Symbol.iterator;
        function ve(s) {
            return s === null || typeof s != "object" ? null : (s = ne && s[ne] || s["@@iterator"], typeof s == "function" ? s : null);
        }
        var Te = Symbol.for("react.client.reference");
        function ue(s) {
            if (s == null) return null;
            if (typeof s == "function") return s.$$typeof === Te ? null : s.displayName || s.name || null;
            if (typeof s == "string") return s;
            switch(s){
                case S:
                    return "Fragment";
                case M:
                    return "Profiler";
                case E:
                    return "StrictMode";
                case L:
                    return "Suspense";
                case Z:
                    return "SuspenseList";
                case te:
                    return "Activity";
            }
            if (typeof s == "object") switch(s.$$typeof){
                case v:
                    return "Portal";
                case O:
                    return (s.displayName || "Context") + ".Provider";
                case H:
                    return (s._context.displayName || "Context") + ".Consumer";
                case U:
                    var o = s.render;
                    return s = s.displayName, s || (s = o.displayName || o.name || "", s = s !== "" ? "ForwardRef(" + s + ")" : "ForwardRef"), s;
                case se:
                    return o = s.displayName || null, o !== null ? o : ue(s.type) || "Memo";
                case ae:
                    o = s._payload, s = s._init;
                    try {
                        return ue(s(o));
                    } catch  {}
            }
            return null;
        }
        var Ie = Array.isArray, $ = e.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE, ee = t.__DOM_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE, ce = {
            pending: !1,
            data: null,
            method: null,
            action: null
        }, Ae = [], R = -1;
        function G(s) {
            return {
                current: s
            };
        }
        function oe(s) {
            0 > R || (s.current = Ae[R], Ae[R] = null, R--);
        }
        function re(s, o) {
            R++, Ae[R] = s.current, s.current = o;
        }
        var de = G(null), Ne = G(null), _e = G(null), Pt = G(null);
        function Ze(s, o) {
            switch(re(_e, o), re(Ne, s), re(de, null), o.nodeType){
                case 9:
                case 11:
                    s = (s = o.documentElement) && (s = s.namespaceURI) ? by(s) : 0;
                    break;
                default:
                    if (s = o.tagName, o = o.namespaceURI) o = by(o), s = vy(o, s);
                    else switch(s){
                        case "svg":
                            s = 1;
                            break;
                        case "math":
                            s = 2;
                            break;
                        default:
                            s = 0;
                    }
            }
            oe(de), re(de, s);
        }
        function Re() {
            oe(de), oe(Ne), oe(_e);
        }
        function Pe(s) {
            s.memoizedState !== null && re(Pt, s);
            var o = de.current, c = vy(o, s.type);
            o !== c && (re(Ne, s), re(de, c));
        }
        function qe(s) {
            Ne.current === s && (oe(de), oe(Ne)), Pt.current === s && (oe(Pt), Ka._currentValue = ce);
        }
        var Wt = Object.prototype.hasOwnProperty, Mn = n.unstable_scheduleCallback, $t = n.unstable_cancelCallback, Lr = n.unstable_shouldYield, On = n.unstable_requestPaint, Dt = n.unstable_now, Fr = n.unstable_getCurrentPriorityLevel, Ji = n.unstable_ImmediatePriority, ep = n.unstable_UserBlockingPriority, Uo = n.unstable_NormalPriority, Z1 = n.unstable_LowPriority, tp = n.unstable_IdlePriority, Q1 = n.log, G1 = n.unstable_setDisableYieldValue, ia = null, Xt = null;
        function pi(s) {
            if (typeof Q1 == "function" && G1(s), Xt && typeof Xt.setStrictMode == "function") try {
                Xt.setStrictMode(ia, s);
            } catch  {}
        }
        var Yt = Math.clz32 ? Math.clz32 : t2, J1 = Math.log, e2 = Math.LN2;
        function t2(s) {
            return s >>>= 0, s === 0 ? 32 : 31 - (J1(s) / e2 | 0) | 0;
        }
        var Bo = 256, Lo = 4194304;
        function er(s) {
            var o = s & 42;
            if (o !== 0) return o;
            switch(s & -s){
                case 1:
                    return 1;
                case 2:
                    return 2;
                case 4:
                    return 4;
                case 8:
                    return 8;
                case 16:
                    return 16;
                case 32:
                    return 32;
                case 64:
                    return 64;
                case 128:
                    return 128;
                case 256:
                case 512:
                case 1024:
                case 2048:
                case 4096:
                case 8192:
                case 16384:
                case 32768:
                case 65536:
                case 131072:
                case 262144:
                case 524288:
                case 1048576:
                case 2097152:
                    return s & 4194048;
                case 4194304:
                case 8388608:
                case 16777216:
                case 33554432:
                    return s & 62914560;
                case 67108864:
                    return 67108864;
                case 134217728:
                    return 134217728;
                case 268435456:
                    return 268435456;
                case 536870912:
                    return 536870912;
                case 1073741824:
                    return 0;
                default:
                    return s;
            }
        }
        function Fo(s, o, c) {
            var f = s.pendingLanes;
            if (f === 0) return 0;
            var g = 0, m = s.suspendedLanes, b = s.pingedLanes;
            s = s.warmLanes;
            var T = f & 134217727;
            return T !== 0 ? (f = T & ~m, f !== 0 ? g = er(f) : (b &= T, b !== 0 ? g = er(b) : c || (c = T & ~s, c !== 0 && (g = er(c))))) : (T = f & ~m, T !== 0 ? g = er(T) : b !== 0 ? g = er(b) : c || (c = f & ~s, c !== 0 && (g = er(c)))), g === 0 ? 0 : o !== 0 && o !== g && (o & m) === 0 && (m = g & -g, c = o & -o, m >= c || m === 32 && (c & 4194048) !== 0) ? o : g;
        }
        function ra(s, o) {
            return (s.pendingLanes & ~(s.suspendedLanes & ~s.pingedLanes) & o) === 0;
        }
        function n2(s, o) {
            switch(s){
                case 1:
                case 2:
                case 4:
                case 8:
                case 64:
                    return o + 250;
                case 16:
                case 32:
                case 128:
                case 256:
                case 512:
                case 1024:
                case 2048:
                case 4096:
                case 8192:
                case 16384:
                case 32768:
                case 65536:
                case 131072:
                case 262144:
                case 524288:
                case 1048576:
                case 2097152:
                    return o + 5e3;
                case 4194304:
                case 8388608:
                case 16777216:
                case 33554432:
                    return -1;
                case 67108864:
                case 134217728:
                case 268435456:
                case 536870912:
                case 1073741824:
                    return -1;
                default:
                    return -1;
            }
        }
        function np() {
            var s = Bo;
            return Bo <<= 1, (Bo & 4194048) === 0 && (Bo = 256), s;
        }
        function ip() {
            var s = Lo;
            return Lo <<= 1, (Lo & 62914560) === 0 && (Lo = 4194304), s;
        }
        function fu(s) {
            for(var o = [], c = 0; 31 > c; c++)o.push(s);
            return o;
        }
        function sa(s, o) {
            s.pendingLanes |= o, o !== 268435456 && (s.suspendedLanes = 0, s.pingedLanes = 0, s.warmLanes = 0);
        }
        function i2(s, o, c, f, g, m) {
            var b = s.pendingLanes;
            s.pendingLanes = c, s.suspendedLanes = 0, s.pingedLanes = 0, s.warmLanes = 0, s.expiredLanes &= c, s.entangledLanes &= c, s.errorRecoveryDisabledLanes &= c, s.shellSuspendCounter = 0;
            var T = s.entanglements, w = s.expirationTimes, V = s.hiddenUpdates;
            for(c = b & ~c; 0 < c;){
                var X = 31 - Yt(c), K = 1 << X;
                T[X] = 0, w[X] = -1;
                var j = V[X];
                if (j !== null) for(V[X] = null, X = 0; X < j.length; X++){
                    var W = j[X];
                    W !== null && (W.lane &= -536870913);
                }
                c &= ~K;
            }
            f !== 0 && rp(s, f, 0), m !== 0 && g === 0 && s.tag !== 0 && (s.suspendedLanes |= m & ~(b & ~o));
        }
        function rp(s, o, c) {
            s.pendingLanes |= o, s.suspendedLanes &= ~o;
            var f = 31 - Yt(o);
            s.entangledLanes |= o, s.entanglements[f] = s.entanglements[f] | 1073741824 | c & 4194090;
        }
        function sp(s, o) {
            var c = s.entangledLanes |= o;
            for(s = s.entanglements; c;){
                var f = 31 - Yt(c), g = 1 << f;
                g & o | s[f] & o && (s[f] |= o), c &= ~g;
            }
        }
        function hu(s) {
            switch(s){
                case 2:
                    s = 1;
                    break;
                case 8:
                    s = 4;
                    break;
                case 32:
                    s = 16;
                    break;
                case 256:
                case 512:
                case 1024:
                case 2048:
                case 4096:
                case 8192:
                case 16384:
                case 32768:
                case 65536:
                case 131072:
                case 262144:
                case 524288:
                case 1048576:
                case 2097152:
                case 4194304:
                case 8388608:
                case 16777216:
                case 33554432:
                    s = 128;
                    break;
                case 268435456:
                    s = 134217728;
                    break;
                default:
                    s = 0;
            }
            return s;
        }
        function du(s) {
            return s &= -s, 2 < s ? 8 < s ? (s & 134217727) !== 0 ? 32 : 268435456 : 8 : 2;
        }
        function ap() {
            var s = ee.p;
            return s !== 0 ? s : (s = window.event, s === void 0 ? 32 : Fy(s.type));
        }
        function r2(s, o) {
            var c = ee.p;
            try {
                return ee.p = s, o();
            } finally{
                ee.p = c;
            }
        }
        var mi = Math.random().toString(36).slice(2), wt = "__reactFiber$" + mi, Bt = "__reactProps$" + mi, zr = "__reactContainer$" + mi, gu = "__reactEvents$" + mi, s2 = "__reactListeners$" + mi, a2 = "__reactHandles$" + mi, op = "__reactResources$" + mi, aa = "__reactMarker$" + mi;
        function pu(s) {
            delete s[wt], delete s[Bt], delete s[gu], delete s[s2], delete s[a2];
        }
        function Vr(s) {
            var o = s[wt];
            if (o) return o;
            for(var c = s.parentNode; c;){
                if (o = c[zr] || c[wt]) {
                    if (c = o.alternate, o.child !== null || c !== null && c.child !== null) for(s = Ay(s); s !== null;){
                        if (c = s[wt]) return c;
                        s = Ay(s);
                    }
                    return o;
                }
                s = c, c = s.parentNode;
            }
            return null;
        }
        function Hr(s) {
            if (s = s[wt] || s[zr]) {
                var o = s.tag;
                if (o === 5 || o === 6 || o === 13 || o === 26 || o === 27 || o === 3) return s;
            }
            return null;
        }
        function oa(s) {
            var o = s.tag;
            if (o === 5 || o === 26 || o === 27 || o === 6) return s.stateNode;
            throw Error(i(33));
        }
        function jr(s) {
            var o = s[op];
            return o || (o = s[op] = {
                hoistableStyles: new Map,
                hoistableScripts: new Map
            }), o;
        }
        function _t(s) {
            s[aa] = !0;
        }
        var lp = new Set, cp = {};
        function tr(s, o) {
            Wr(s, o), Wr(s + "Capture", o);
        }
        function Wr(s, o) {
            for(cp[s] = o, s = 0; s < o.length; s++)lp.add(o[s]);
        }
        var o2 = RegExp("^[:A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD][:A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD\\-.0-9\\u00B7\\u0300-\\u036F\\u203F-\\u2040]*$"), up = {}, fp = {};
        function l2(s) {
            return Wt.call(fp, s) ? !0 : Wt.call(up, s) ? !1 : o2.test(s) ? fp[s] = !0 : (up[s] = !0, !1);
        }
        function zo(s, o, c) {
            if (l2(o)) if (c === null) s.removeAttribute(o);
            else {
                switch(typeof c){
                    case "undefined":
                    case "function":
                    case "symbol":
                        s.removeAttribute(o);
                        return;
                    case "boolean":
                        var f = o.toLowerCase().slice(0, 5);
                        if (f !== "data-" && f !== "aria-") {
                            s.removeAttribute(o);
                            return;
                        }
                }
                s.setAttribute(o, "" + c);
            }
        }
        function Vo(s, o, c) {
            if (c === null) s.removeAttribute(o);
            else {
                switch(typeof c){
                    case "undefined":
                    case "function":
                    case "symbol":
                    case "boolean":
                        s.removeAttribute(o);
                        return;
                }
                s.setAttribute(o, "" + c);
            }
        }
        function Yn(s, o, c, f) {
            if (f === null) s.removeAttribute(c);
            else {
                switch(typeof f){
                    case "undefined":
                    case "function":
                    case "symbol":
                    case "boolean":
                        s.removeAttribute(c);
                        return;
                }
                s.setAttributeNS(o, c, "" + f);
            }
        }
        var mu, hp;
        function $r(s) {
            if (mu === void 0) try {
                throw Error();
            } catch (c) {
                var o = c.stack.trim().match(/\n( *(at )?)/);
                mu = o && o[1] || "", hp = -1 < c.stack.indexOf(`
    at`) ? " (<anonymous>)" : -1 < c.stack.indexOf("@") ? "@unknown:0:0" : "";
            }
            return `
` + mu + s + hp;
        }
        var _u = !1;
        function yu(s, o) {
            if (!s || _u) return "";
            _u = !0;
            var c = Error.prepareStackTrace;
            Error.prepareStackTrace = void 0;
            try {
                var f = {
                    DetermineComponentFrameRoot: function() {
                        try {
                            if (o) {
                                var K = function() {
                                    throw Error();
                                };
                                if (Object.defineProperty(K.prototype, "props", {
                                    set: function() {
                                        throw Error();
                                    }
                                }), typeof Reflect == "object" && Reflect.construct) {
                                    try {
                                        Reflect.construct(K, []);
                                    } catch (W) {
                                        var j = W;
                                    }
                                    Reflect.construct(s, [], K);
                                } else {
                                    try {
                                        K.call();
                                    } catch (W) {
                                        j = W;
                                    }
                                    s.call(K.prototype);
                                }
                            } else {
                                try {
                                    throw Error();
                                } catch (W) {
                                    j = W;
                                }
                                (K = s()) && typeof K.catch == "function" && K.catch(function() {});
                            }
                        } catch (W) {
                            if (W && j && typeof W.stack == "string") return [
                                W.stack,
                                j.stack
                            ];
                        }
                        return [
                            null,
                            null
                        ];
                    }
                };
                f.DetermineComponentFrameRoot.displayName = "DetermineComponentFrameRoot";
                var g = Object.getOwnPropertyDescriptor(f.DetermineComponentFrameRoot, "name");
                g && g.configurable && Object.defineProperty(f.DetermineComponentFrameRoot, "name", {
                    value: "DetermineComponentFrameRoot"
                });
                var m = f.DetermineComponentFrameRoot(), b = m[0], T = m[1];
                if (b && T) {
                    var w = b.split(`
`), V = T.split(`
`);
                    for(g = f = 0; f < w.length && !w[f].includes("DetermineComponentFrameRoot");)f++;
                    for(; g < V.length && !V[g].includes("DetermineComponentFrameRoot");)g++;
                    if (f === w.length || g === V.length) for(f = w.length - 1, g = V.length - 1; 1 <= f && 0 <= g && w[f] !== V[g];)g--;
                    for(; 1 <= f && 0 <= g; f--, g--)if (w[f] !== V[g]) {
                        if (f !== 1 || g !== 1) do if (f--, g--, 0 > g || w[f] !== V[g]) {
                            var X = `
` + w[f].replace(" at new ", " at ");
                            return s.displayName && X.includes("<anonymous>") && (X = X.replace("<anonymous>", s.displayName)), X;
                        }
                        while (1 <= f && 0 <= g);
                        break;
                    }
                }
            } finally{
                _u = !1, Error.prepareStackTrace = c;
            }
            return (c = s ? s.displayName || s.name : "") ? $r(c) : "";
        }
        function c2(s) {
            switch(s.tag){
                case 26:
                case 27:
                case 5:
                    return $r(s.type);
                case 16:
                    return $r("Lazy");
                case 13:
                    return $r("Suspense");
                case 19:
                    return $r("SuspenseList");
                case 0:
                case 15:
                    return yu(s.type, !1);
                case 11:
                    return yu(s.type.render, !1);
                case 1:
                    return yu(s.type, !0);
                case 31:
                    return $r("Activity");
                default:
                    return "";
            }
        }
        function dp(s) {
            try {
                var o = "";
                do o += c2(s), s = s.return;
                while (s);
                return o;
            } catch (c) {
                return `
Error generating stack: ` + c.message + `
` + c.stack;
            }
        }
        function an(s) {
            switch(typeof s){
                case "bigint":
                case "boolean":
                case "number":
                case "string":
                case "undefined":
                    return s;
                case "object":
                    return s;
                default:
                    return "";
            }
        }
        function gp(s) {
            var o = s.type;
            return (s = s.nodeName) && s.toLowerCase() === "input" && (o === "checkbox" || o === "radio");
        }
        function u2(s) {
            var o = gp(s) ? "checked" : "value", c = Object.getOwnPropertyDescriptor(s.constructor.prototype, o), f = "" + s[o];
            if (!s.hasOwnProperty(o) && typeof c < "u" && typeof c.get == "function" && typeof c.set == "function") {
                var g = c.get, m = c.set;
                return Object.defineProperty(s, o, {
                    configurable: !0,
                    get: function() {
                        return g.call(this);
                    },
                    set: function(b) {
                        f = "" + b, m.call(this, b);
                    }
                }), Object.defineProperty(s, o, {
                    enumerable: c.enumerable
                }), {
                    getValue: function() {
                        return f;
                    },
                    setValue: function(b) {
                        f = "" + b;
                    },
                    stopTracking: function() {
                        s._valueTracker = null, delete s[o];
                    }
                };
            }
        }
        function Ho(s) {
            s._valueTracker || (s._valueTracker = u2(s));
        }
        function pp(s) {
            if (!s) return !1;
            var o = s._valueTracker;
            if (!o) return !0;
            var c = o.getValue(), f = "";
            return s && (f = gp(s) ? s.checked ? "true" : "false" : s.value), s = f, s !== c ? (o.setValue(s), !0) : !1;
        }
        function jo(s) {
            if (s = s || (typeof document < "u" ? document : void 0), typeof s > "u") return null;
            try {
                return s.activeElement || s.body;
            } catch  {
                return s.body;
            }
        }
        var f2 = /[\n"\\]/g;
        function on(s) {
            return s.replace(f2, function(o) {
                return "\\" + o.charCodeAt(0).toString(16) + " ";
            });
        }
        function bu(s, o, c, f, g, m, b, T) {
            s.name = "", b != null && typeof b != "function" && typeof b != "symbol" && typeof b != "boolean" ? s.type = b : s.removeAttribute("type"), o != null ? b === "number" ? (o === 0 && s.value === "" || s.value != o) && (s.value = "" + an(o)) : s.value !== "" + an(o) && (s.value = "" + an(o)) : b !== "submit" && b !== "reset" || s.removeAttribute("value"), o != null ? vu(s, b, an(o)) : c != null ? vu(s, b, an(c)) : f != null && s.removeAttribute("value"), g == null && m != null && (s.defaultChecked = !!m), g != null && (s.checked = g && typeof g != "function" && typeof g != "symbol"), T != null && typeof T != "function" && typeof T != "symbol" && typeof T != "boolean" ? s.name = "" + an(T) : s.removeAttribute("name");
        }
        function mp(s, o, c, f, g, m, b, T) {
            if (m != null && typeof m != "function" && typeof m != "symbol" && typeof m != "boolean" && (s.type = m), o != null || c != null) {
                if (!(m !== "submit" && m !== "reset" || o != null)) return;
                c = c != null ? "" + an(c) : "", o = o != null ? "" + an(o) : c, T || o === s.value || (s.value = o), s.defaultValue = o;
            }
            f = f ?? g, f = typeof f != "function" && typeof f != "symbol" && !!f, s.checked = T ? s.checked : !!f, s.defaultChecked = !!f, b != null && typeof b != "function" && typeof b != "symbol" && typeof b != "boolean" && (s.name = b);
        }
        function vu(s, o, c) {
            o === "number" && jo(s.ownerDocument) === s || s.defaultValue === "" + c || (s.defaultValue = "" + c);
        }
        function Xr(s, o, c, f) {
            if (s = s.options, o) {
                o = {};
                for(var g = 0; g < c.length; g++)o["$" + c[g]] = !0;
                for(c = 0; c < s.length; c++)g = o.hasOwnProperty("$" + s[c].value), s[c].selected !== g && (s[c].selected = g), g && f && (s[c].defaultSelected = !0);
            } else {
                for(c = "" + an(c), o = null, g = 0; g < s.length; g++){
                    if (s[g].value === c) {
                        s[g].selected = !0, f && (s[g].defaultSelected = !0);
                        return;
                    }
                    o !== null || s[g].disabled || (o = s[g]);
                }
                o !== null && (o.selected = !0);
            }
        }
        function _p(s, o, c) {
            if (o != null && (o = "" + an(o), o !== s.value && (s.value = o), c == null)) {
                s.defaultValue !== o && (s.defaultValue = o);
                return;
            }
            s.defaultValue = c != null ? "" + an(c) : "";
        }
        function yp(s, o, c, f) {
            if (o == null) {
                if (f != null) {
                    if (c != null) throw Error(i(92));
                    if (Ie(f)) {
                        if (1 < f.length) throw Error(i(93));
                        f = f[0];
                    }
                    c = f;
                }
                c == null && (c = ""), o = c;
            }
            c = an(o), s.defaultValue = c, f = s.textContent, f === c && f !== "" && f !== null && (s.value = f);
        }
        function Yr(s, o) {
            if (o) {
                var c = s.firstChild;
                if (c && c === s.lastChild && c.nodeType === 3) {
                    c.nodeValue = o;
                    return;
                }
            }
            s.textContent = o;
        }
        var h2 = new Set("animationIterationCount aspectRatio borderImageOutset borderImageSlice borderImageWidth boxFlex boxFlexGroup boxOrdinalGroup columnCount columns flex flexGrow flexPositive flexShrink flexNegative flexOrder gridArea gridRow gridRowEnd gridRowSpan gridRowStart gridColumn gridColumnEnd gridColumnSpan gridColumnStart fontWeight lineClamp lineHeight opacity order orphans scale tabSize widows zIndex zoom fillOpacity floodOpacity stopOpacity strokeDasharray strokeDashoffset strokeMiterlimit strokeOpacity strokeWidth MozAnimationIterationCount MozBoxFlex MozBoxFlexGroup MozLineClamp msAnimationIterationCount msFlex msZoom msFlexGrow msFlexNegative msFlexOrder msFlexPositive msFlexShrink msGridColumn msGridColumnSpan msGridRow msGridRowSpan WebkitAnimationIterationCount WebkitBoxFlex WebKitBoxFlexGroup WebkitBoxOrdinalGroup WebkitColumnCount WebkitColumns WebkitFlex WebkitFlexGrow WebkitFlexPositive WebkitFlexShrink WebkitLineClamp".split(" "));
        function bp(s, o, c) {
            var f = o.indexOf("--") === 0;
            c == null || typeof c == "boolean" || c === "" ? f ? s.setProperty(o, "") : o === "float" ? s.cssFloat = "" : s[o] = "" : f ? s.setProperty(o, c) : typeof c != "number" || c === 0 || h2.has(o) ? o === "float" ? s.cssFloat = c : s[o] = ("" + c).trim() : s[o] = c + "px";
        }
        function vp(s, o, c) {
            if (o != null && typeof o != "object") throw Error(i(62));
            if (s = s.style, c != null) {
                for(var f in c)!c.hasOwnProperty(f) || o != null && o.hasOwnProperty(f) || (f.indexOf("--") === 0 ? s.setProperty(f, "") : f === "float" ? s.cssFloat = "" : s[f] = "");
                for(var g in o)f = o[g], o.hasOwnProperty(g) && c[g] !== f && bp(s, g, f);
            } else for(var m in o)o.hasOwnProperty(m) && bp(s, m, o[m]);
        }
        function Tu(s) {
            if (s.indexOf("-") === -1) return !1;
            switch(s){
                case "annotation-xml":
                case "color-profile":
                case "font-face":
                case "font-face-src":
                case "font-face-uri":
                case "font-face-format":
                case "font-face-name":
                case "missing-glyph":
                    return !1;
                default:
                    return !0;
            }
        }
        var d2 = new Map([
            [
                "acceptCharset",
                "accept-charset"
            ],
            [
                "htmlFor",
                "for"
            ],
            [
                "httpEquiv",
                "http-equiv"
            ],
            [
                "crossOrigin",
                "crossorigin"
            ],
            [
                "accentHeight",
                "accent-height"
            ],
            [
                "alignmentBaseline",
                "alignment-baseline"
            ],
            [
                "arabicForm",
                "arabic-form"
            ],
            [
                "baselineShift",
                "baseline-shift"
            ],
            [
                "capHeight",
                "cap-height"
            ],
            [
                "clipPath",
                "clip-path"
            ],
            [
                "clipRule",
                "clip-rule"
            ],
            [
                "colorInterpolation",
                "color-interpolation"
            ],
            [
                "colorInterpolationFilters",
                "color-interpolation-filters"
            ],
            [
                "colorProfile",
                "color-profile"
            ],
            [
                "colorRendering",
                "color-rendering"
            ],
            [
                "dominantBaseline",
                "dominant-baseline"
            ],
            [
                "enableBackground",
                "enable-background"
            ],
            [
                "fillOpacity",
                "fill-opacity"
            ],
            [
                "fillRule",
                "fill-rule"
            ],
            [
                "floodColor",
                "flood-color"
            ],
            [
                "floodOpacity",
                "flood-opacity"
            ],
            [
                "fontFamily",
                "font-family"
            ],
            [
                "fontSize",
                "font-size"
            ],
            [
                "fontSizeAdjust",
                "font-size-adjust"
            ],
            [
                "fontStretch",
                "font-stretch"
            ],
            [
                "fontStyle",
                "font-style"
            ],
            [
                "fontVariant",
                "font-variant"
            ],
            [
                "fontWeight",
                "font-weight"
            ],
            [
                "glyphName",
                "glyph-name"
            ],
            [
                "glyphOrientationHorizontal",
                "glyph-orientation-horizontal"
            ],
            [
                "glyphOrientationVertical",
                "glyph-orientation-vertical"
            ],
            [
                "horizAdvX",
                "horiz-adv-x"
            ],
            [
                "horizOriginX",
                "horiz-origin-x"
            ],
            [
                "imageRendering",
                "image-rendering"
            ],
            [
                "letterSpacing",
                "letter-spacing"
            ],
            [
                "lightingColor",
                "lighting-color"
            ],
            [
                "markerEnd",
                "marker-end"
            ],
            [
                "markerMid",
                "marker-mid"
            ],
            [
                "markerStart",
                "marker-start"
            ],
            [
                "overlinePosition",
                "overline-position"
            ],
            [
                "overlineThickness",
                "overline-thickness"
            ],
            [
                "paintOrder",
                "paint-order"
            ],
            [
                "panose-1",
                "panose-1"
            ],
            [
                "pointerEvents",
                "pointer-events"
            ],
            [
                "renderingIntent",
                "rendering-intent"
            ],
            [
                "shapeRendering",
                "shape-rendering"
            ],
            [
                "stopColor",
                "stop-color"
            ],
            [
                "stopOpacity",
                "stop-opacity"
            ],
            [
                "strikethroughPosition",
                "strikethrough-position"
            ],
            [
                "strikethroughThickness",
                "strikethrough-thickness"
            ],
            [
                "strokeDasharray",
                "stroke-dasharray"
            ],
            [
                "strokeDashoffset",
                "stroke-dashoffset"
            ],
            [
                "strokeLinecap",
                "stroke-linecap"
            ],
            [
                "strokeLinejoin",
                "stroke-linejoin"
            ],
            [
                "strokeMiterlimit",
                "stroke-miterlimit"
            ],
            [
                "strokeOpacity",
                "stroke-opacity"
            ],
            [
                "strokeWidth",
                "stroke-width"
            ],
            [
                "textAnchor",
                "text-anchor"
            ],
            [
                "textDecoration",
                "text-decoration"
            ],
            [
                "textRendering",
                "text-rendering"
            ],
            [
                "transformOrigin",
                "transform-origin"
            ],
            [
                "underlinePosition",
                "underline-position"
            ],
            [
                "underlineThickness",
                "underline-thickness"
            ],
            [
                "unicodeBidi",
                "unicode-bidi"
            ],
            [
                "unicodeRange",
                "unicode-range"
            ],
            [
                "unitsPerEm",
                "units-per-em"
            ],
            [
                "vAlphabetic",
                "v-alphabetic"
            ],
            [
                "vHanging",
                "v-hanging"
            ],
            [
                "vIdeographic",
                "v-ideographic"
            ],
            [
                "vMathematical",
                "v-mathematical"
            ],
            [
                "vectorEffect",
                "vector-effect"
            ],
            [
                "vertAdvY",
                "vert-adv-y"
            ],
            [
                "vertOriginX",
                "vert-origin-x"
            ],
            [
                "vertOriginY",
                "vert-origin-y"
            ],
            [
                "wordSpacing",
                "word-spacing"
            ],
            [
                "writingMode",
                "writing-mode"
            ],
            [
                "xmlnsXlink",
                "xmlns:xlink"
            ],
            [
                "xHeight",
                "x-height"
            ]
        ]), g2 = /^[\u0000-\u001F ]*j[\r\n\t]*a[\r\n\t]*v[\r\n\t]*a[\r\n\t]*s[\r\n\t]*c[\r\n\t]*r[\r\n\t]*i[\r\n\t]*p[\r\n\t]*t[\r\n\t]*:/i;
        function Wo(s) {
            return g2.test("" + s) ? "javascript:throw new Error('React has blocked a javascript: URL as a security precaution.')" : s;
        }
        var xu = null;
        function Su(s) {
            return s = s.target || s.srcElement || window, s.correspondingUseElement && (s = s.correspondingUseElement), s.nodeType === 3 ? s.parentNode : s;
        }
        var qr = null, Kr = null;
        function Tp(s) {
            var o = Hr(s);
            if (o && (s = o.stateNode)) {
                var c = s[Bt] || null;
                e: switch(s = o.stateNode, o.type){
                    case "input":
                        if (bu(s, c.value, c.defaultValue, c.defaultValue, c.checked, c.defaultChecked, c.type, c.name), o = c.name, c.type === "radio" && o != null) {
                            for(c = s; c.parentNode;)c = c.parentNode;
                            for(c = c.querySelectorAll('input[name="' + on("" + o) + '"][type="radio"]'), o = 0; o < c.length; o++){
                                var f = c[o];
                                if (f !== s && f.form === s.form) {
                                    var g = f[Bt] || null;
                                    if (!g) throw Error(i(90));
                                    bu(f, g.value, g.defaultValue, g.defaultValue, g.checked, g.defaultChecked, g.type, g.name);
                                }
                            }
                            for(o = 0; o < c.length; o++)f = c[o], f.form === s.form && pp(f);
                        }
                        break e;
                    case "textarea":
                        _p(s, c.value, c.defaultValue);
                        break e;
                    case "select":
                        o = c.value, o != null && Xr(s, !!c.multiple, o, !1);
                }
            }
        }
        var Au = !1;
        function xp(s, o, c) {
            if (Au) return s(o, c);
            Au = !0;
            try {
                var f = s(o);
                return f;
            } finally{
                if (Au = !1, (qr !== null || Kr !== null) && (Ml(), qr && (o = qr, s = Kr, Kr = qr = null, Tp(o), s))) for(o = 0; o < s.length; o++)Tp(s[o]);
            }
        }
        function la(s, o) {
            var c = s.stateNode;
            if (c === null) return null;
            var f = c[Bt] || null;
            if (f === null) return null;
            c = f[o];
            e: switch(o){
                case "onClick":
                case "onClickCapture":
                case "onDoubleClick":
                case "onDoubleClickCapture":
                case "onMouseDown":
                case "onMouseDownCapture":
                case "onMouseMove":
                case "onMouseMoveCapture":
                case "onMouseUp":
                case "onMouseUpCapture":
                case "onMouseEnter":
                    (f = !f.disabled) || (s = s.type, f = !(s === "button" || s === "input" || s === "select" || s === "textarea")), s = !f;
                    break e;
                default:
                    s = !1;
            }
            if (s) return null;
            if (c && typeof c != "function") throw Error(i(231, o, typeof c));
            return c;
        }
        var qn = !(typeof window > "u" || typeof window.document > "u" || typeof window.document.createElement > "u"), wu = !1;
        if (qn) try {
            var ca = {};
            Object.defineProperty(ca, "passive", {
                get: function() {
                    wu = !0;
                }
            }), window.addEventListener("test", ca, ca), window.removeEventListener("test", ca, ca);
        } catch  {
            wu = !1;
        }
        var _i = null, Eu = null, $o = null;
        function Sp() {
            if ($o) return $o;
            var s, o = Eu, c = o.length, f, g = "value" in _i ? _i.value : _i.textContent, m = g.length;
            for(s = 0; s < c && o[s] === g[s]; s++);
            var b = c - s;
            for(f = 1; f <= b && o[c - f] === g[m - f]; f++);
            return $o = g.slice(s, 1 < f ? 1 - f : void 0);
        }
        function Xo(s) {
            var o = s.keyCode;
            return "charCode" in s ? (s = s.charCode, s === 0 && o === 13 && (s = 13)) : s = o, s === 10 && (s = 13), 32 <= s || s === 13 ? s : 0;
        }
        function Yo() {
            return !0;
        }
        function Ap() {
            return !1;
        }
        function Lt(s) {
            function o(c, f, g, m, b) {
                this._reactName = c, this._targetInst = g, this.type = f, this.nativeEvent = m, this.target = b, this.currentTarget = null;
                for(var T in s)s.hasOwnProperty(T) && (c = s[T], this[T] = c ? c(m) : m[T]);
                return this.isDefaultPrevented = (m.defaultPrevented != null ? m.defaultPrevented : m.returnValue === !1) ? Yo : Ap, this.isPropagationStopped = Ap, this;
            }
            return p(o.prototype, {
                preventDefault: function() {
                    this.defaultPrevented = !0;
                    var c = this.nativeEvent;
                    c && (c.preventDefault ? c.preventDefault() : typeof c.returnValue != "unknown" && (c.returnValue = !1), this.isDefaultPrevented = Yo);
                },
                stopPropagation: function() {
                    var c = this.nativeEvent;
                    c && (c.stopPropagation ? c.stopPropagation() : typeof c.cancelBubble != "unknown" && (c.cancelBubble = !0), this.isPropagationStopped = Yo);
                },
                persist: function() {},
                isPersistent: Yo
            }), o;
        }
        var nr = {
            eventPhase: 0,
            bubbles: 0,
            cancelable: 0,
            timeStamp: function(s) {
                return s.timeStamp || Date.now();
            },
            defaultPrevented: 0,
            isTrusted: 0
        }, qo = Lt(nr), ua = p({}, nr, {
            view: 0,
            detail: 0
        }), p2 = Lt(ua), Ru, Cu, fa, Ko = p({}, ua, {
            screenX: 0,
            screenY: 0,
            clientX: 0,
            clientY: 0,
            pageX: 0,
            pageY: 0,
            ctrlKey: 0,
            shiftKey: 0,
            altKey: 0,
            metaKey: 0,
            getModifierState: Ou,
            button: 0,
            buttons: 0,
            relatedTarget: function(s) {
                return s.relatedTarget === void 0 ? s.fromElement === s.srcElement ? s.toElement : s.fromElement : s.relatedTarget;
            },
            movementX: function(s) {
                return "movementX" in s ? s.movementX : (s !== fa && (fa && s.type === "mousemove" ? (Ru = s.screenX - fa.screenX, Cu = s.screenY - fa.screenY) : Cu = Ru = 0, fa = s), Ru);
            },
            movementY: function(s) {
                return "movementY" in s ? s.movementY : Cu;
            }
        }), wp = Lt(Ko), m2 = p({}, Ko, {
            dataTransfer: 0
        }), _2 = Lt(m2), y2 = p({}, ua, {
            relatedTarget: 0
        }), Mu = Lt(y2), b2 = p({}, nr, {
            animationName: 0,
            elapsedTime: 0,
            pseudoElement: 0
        }), v2 = Lt(b2), T2 = p({}, nr, {
            clipboardData: function(s) {
                return "clipboardData" in s ? s.clipboardData : window.clipboardData;
            }
        }), x2 = Lt(T2), S2 = p({}, nr, {
            data: 0
        }), Ep = Lt(S2), A2 = {
            Esc: "Escape",
            Spacebar: " ",
            Left: "ArrowLeft",
            Up: "ArrowUp",
            Right: "ArrowRight",
            Down: "ArrowDown",
            Del: "Delete",
            Win: "OS",
            Menu: "ContextMenu",
            Apps: "ContextMenu",
            Scroll: "ScrollLock",
            MozPrintableKey: "Unidentified"
        }, w2 = {
            8: "Backspace",
            9: "Tab",
            12: "Clear",
            13: "Enter",
            16: "Shift",
            17: "Control",
            18: "Alt",
            19: "Pause",
            20: "CapsLock",
            27: "Escape",
            32: " ",
            33: "PageUp",
            34: "PageDown",
            35: "End",
            36: "Home",
            37: "ArrowLeft",
            38: "ArrowUp",
            39: "ArrowRight",
            40: "ArrowDown",
            45: "Insert",
            46: "Delete",
            112: "F1",
            113: "F2",
            114: "F3",
            115: "F4",
            116: "F5",
            117: "F6",
            118: "F7",
            119: "F8",
            120: "F9",
            121: "F10",
            122: "F11",
            123: "F12",
            144: "NumLock",
            145: "ScrollLock",
            224: "Meta"
        }, E2 = {
            Alt: "altKey",
            Control: "ctrlKey",
            Meta: "metaKey",
            Shift: "shiftKey"
        };
        function R2(s) {
            var o = this.nativeEvent;
            return o.getModifierState ? o.getModifierState(s) : (s = E2[s]) ? !!o[s] : !1;
        }
        function Ou() {
            return R2;
        }
        var C2 = p({}, ua, {
            key: function(s) {
                if (s.key) {
                    var o = A2[s.key] || s.key;
                    if (o !== "Unidentified") return o;
                }
                return s.type === "keypress" ? (s = Xo(s), s === 13 ? "Enter" : String.fromCharCode(s)) : s.type === "keydown" || s.type === "keyup" ? w2[s.keyCode] || "Unidentified" : "";
            },
            code: 0,
            location: 0,
            ctrlKey: 0,
            shiftKey: 0,
            altKey: 0,
            metaKey: 0,
            repeat: 0,
            locale: 0,
            getModifierState: Ou,
            charCode: function(s) {
                return s.type === "keypress" ? Xo(s) : 0;
            },
            keyCode: function(s) {
                return s.type === "keydown" || s.type === "keyup" ? s.keyCode : 0;
            },
            which: function(s) {
                return s.type === "keypress" ? Xo(s) : s.type === "keydown" || s.type === "keyup" ? s.keyCode : 0;
            }
        }), M2 = Lt(C2), O2 = p({}, Ko, {
            pointerId: 0,
            width: 0,
            height: 0,
            pressure: 0,
            tangentialPressure: 0,
            tiltX: 0,
            tiltY: 0,
            twist: 0,
            pointerType: 0,
            isPrimary: 0
        }), Rp = Lt(O2), I2 = p({}, ua, {
            touches: 0,
            targetTouches: 0,
            changedTouches: 0,
            altKey: 0,
            metaKey: 0,
            ctrlKey: 0,
            shiftKey: 0,
            getModifierState: Ou
        }), N2 = Lt(I2), P2 = p({}, nr, {
            propertyName: 0,
            elapsedTime: 0,
            pseudoElement: 0
        }), D2 = Lt(P2), k2 = p({}, Ko, {
            deltaX: function(s) {
                return "deltaX" in s ? s.deltaX : "wheelDeltaX" in s ? -s.wheelDeltaX : 0;
            },
            deltaY: function(s) {
                return "deltaY" in s ? s.deltaY : "wheelDeltaY" in s ? -s.wheelDeltaY : "wheelDelta" in s ? -s.wheelDelta : 0;
            },
            deltaZ: 0,
            deltaMode: 0
        }), U2 = Lt(k2), B2 = p({}, nr, {
            newState: 0,
            oldState: 0
        }), L2 = Lt(B2), F2 = [
            9,
            13,
            27,
            32
        ], Iu = qn && "CompositionEvent" in window, ha = null;
        qn && "documentMode" in document && (ha = document.documentMode);
        var z2 = qn && "TextEvent" in window && !ha, Cp = qn && (!Iu || ha && 8 < ha && 11 >= ha), Mp = " ", Op = !1;
        function Ip(s, o) {
            switch(s){
                case "keyup":
                    return F2.indexOf(o.keyCode) !== -1;
                case "keydown":
                    return o.keyCode !== 229;
                case "keypress":
                case "mousedown":
                case "focusout":
                    return !0;
                default:
                    return !1;
            }
        }
        function Np(s) {
            return s = s.detail, typeof s == "object" && "data" in s ? s.data : null;
        }
        var Zr = !1;
        function V2(s, o) {
            switch(s){
                case "compositionend":
                    return Np(o);
                case "keypress":
                    return o.which !== 32 ? null : (Op = !0, Mp);
                case "textInput":
                    return s = o.data, s === Mp && Op ? null : s;
                default:
                    return null;
            }
        }
        function H2(s, o) {
            if (Zr) return s === "compositionend" || !Iu && Ip(s, o) ? (s = Sp(), $o = Eu = _i = null, Zr = !1, s) : null;
            switch(s){
                case "paste":
                    return null;
                case "keypress":
                    if (!(o.ctrlKey || o.altKey || o.metaKey) || o.ctrlKey && o.altKey) {
                        if (o.char && 1 < o.char.length) return o.char;
                        if (o.which) return String.fromCharCode(o.which);
                    }
                    return null;
                case "compositionend":
                    return Cp && o.locale !== "ko" ? null : o.data;
                default:
                    return null;
            }
        }
        var j2 = {
            color: !0,
            date: !0,
            datetime: !0,
            "datetime-local": !0,
            email: !0,
            month: !0,
            number: !0,
            password: !0,
            range: !0,
            search: !0,
            tel: !0,
            text: !0,
            time: !0,
            url: !0,
            week: !0
        };
        function Pp(s) {
            var o = s && s.nodeName && s.nodeName.toLowerCase();
            return o === "input" ? !!j2[s.type] : o === "textarea";
        }
        function Dp(s, o, c, f) {
            qr ? Kr ? Kr.push(f) : Kr = [
                f
            ] : qr = f, o = kl(o, "onChange"), 0 < o.length && (c = new qo("onChange", "change", null, c, f), s.push({
                event: c,
                listeners: o
            }));
        }
        var da = null, ga = null;
        function W2(s) {
            gy(s, 0);
        }
        function Zo(s) {
            var o = oa(s);
            if (pp(o)) return s;
        }
        function kp(s, o) {
            if (s === "change") return o;
        }
        var Up = !1;
        if (qn) {
            var Nu;
            if (qn) {
                var Pu = "oninput" in document;
                if (!Pu) {
                    var Bp = document.createElement("div");
                    Bp.setAttribute("oninput", "return;"), Pu = typeof Bp.oninput == "function";
                }
                Nu = Pu;
            } else Nu = !1;
            Up = Nu && (!document.documentMode || 9 < document.documentMode);
        }
        function Lp() {
            da && (da.detachEvent("onpropertychange", Fp), ga = da = null);
        }
        function Fp(s) {
            if (s.propertyName === "value" && Zo(ga)) {
                var o = [];
                Dp(o, ga, s, Su(s)), xp(W2, o);
            }
        }
        function $2(s, o, c) {
            s === "focusin" ? (Lp(), da = o, ga = c, da.attachEvent("onpropertychange", Fp)) : s === "focusout" && Lp();
        }
        function X2(s) {
            if (s === "selectionchange" || s === "keyup" || s === "keydown") return Zo(ga);
        }
        function Y2(s, o) {
            if (s === "click") return Zo(o);
        }
        function q2(s, o) {
            if (s === "input" || s === "change") return Zo(o);
        }
        function K2(s, o) {
            return s === o && (s !== 0 || 1 / s === 1 / o) || s !== s && o !== o;
        }
        var qt = typeof Object.is == "function" ? Object.is : K2;
        function pa(s, o) {
            if (qt(s, o)) return !0;
            if (typeof s != "object" || s === null || typeof o != "object" || o === null) return !1;
            var c = Object.keys(s), f = Object.keys(o);
            if (c.length !== f.length) return !1;
            for(f = 0; f < c.length; f++){
                var g = c[f];
                if (!Wt.call(o, g) || !qt(s[g], o[g])) return !1;
            }
            return !0;
        }
        function zp(s) {
            for(; s && s.firstChild;)s = s.firstChild;
            return s;
        }
        function Vp(s, o) {
            var c = zp(s);
            s = 0;
            for(var f; c;){
                if (c.nodeType === 3) {
                    if (f = s + c.textContent.length, s <= o && f >= o) return {
                        node: c,
                        offset: o - s
                    };
                    s = f;
                }
                e: {
                    for(; c;){
                        if (c.nextSibling) {
                            c = c.nextSibling;
                            break e;
                        }
                        c = c.parentNode;
                    }
                    c = void 0;
                }
                c = zp(c);
            }
        }
        function Hp(s, o) {
            return s && o ? s === o ? !0 : s && s.nodeType === 3 ? !1 : o && o.nodeType === 3 ? Hp(s, o.parentNode) : "contains" in s ? s.contains(o) : s.compareDocumentPosition ? !!(s.compareDocumentPosition(o) & 16) : !1 : !1;
        }
        function jp(s) {
            s = s != null && s.ownerDocument != null && s.ownerDocument.defaultView != null ? s.ownerDocument.defaultView : window;
            for(var o = jo(s.document); o instanceof s.HTMLIFrameElement;){
                try {
                    var c = typeof o.contentWindow.location.href == "string";
                } catch  {
                    c = !1;
                }
                if (c) s = o.contentWindow;
                else break;
                o = jo(s.document);
            }
            return o;
        }
        function Du(s) {
            var o = s && s.nodeName && s.nodeName.toLowerCase();
            return o && (o === "input" && (s.type === "text" || s.type === "search" || s.type === "tel" || s.type === "url" || s.type === "password") || o === "textarea" || s.contentEditable === "true");
        }
        var Z2 = qn && "documentMode" in document && 11 >= document.documentMode, Qr = null, ku = null, ma = null, Uu = !1;
        function Wp(s, o, c) {
            var f = c.window === c ? c.document : c.nodeType === 9 ? c : c.ownerDocument;
            Uu || Qr == null || Qr !== jo(f) || (f = Qr, "selectionStart" in f && Du(f) ? f = {
                start: f.selectionStart,
                end: f.selectionEnd
            } : (f = (f.ownerDocument && f.ownerDocument.defaultView || window).getSelection(), f = {
                anchorNode: f.anchorNode,
                anchorOffset: f.anchorOffset,
                focusNode: f.focusNode,
                focusOffset: f.focusOffset
            }), ma && pa(ma, f) || (ma = f, f = kl(ku, "onSelect"), 0 < f.length && (o = new qo("onSelect", "select", null, o, c), s.push({
                event: o,
                listeners: f
            }), o.target = Qr)));
        }
        function ir(s, o) {
            var c = {};
            return c[s.toLowerCase()] = o.toLowerCase(), c["Webkit" + s] = "webkit" + o, c["Moz" + s] = "moz" + o, c;
        }
        var Gr = {
            animationend: ir("Animation", "AnimationEnd"),
            animationiteration: ir("Animation", "AnimationIteration"),
            animationstart: ir("Animation", "AnimationStart"),
            transitionrun: ir("Transition", "TransitionRun"),
            transitionstart: ir("Transition", "TransitionStart"),
            transitioncancel: ir("Transition", "TransitionCancel"),
            transitionend: ir("Transition", "TransitionEnd")
        }, Bu = {}, $p = {};
        qn && ($p = document.createElement("div").style, "AnimationEvent" in window || (delete Gr.animationend.animation, delete Gr.animationiteration.animation, delete Gr.animationstart.animation), "TransitionEvent" in window || delete Gr.transitionend.transition);
        function rr(s) {
            if (Bu[s]) return Bu[s];
            if (!Gr[s]) return s;
            var o = Gr[s], c;
            for(c in o)if (o.hasOwnProperty(c) && c in $p) return Bu[s] = o[c];
            return s;
        }
        var Xp = rr("animationend"), Yp = rr("animationiteration"), qp = rr("animationstart"), Q2 = rr("transitionrun"), G2 = rr("transitionstart"), J2 = rr("transitioncancel"), Kp = rr("transitionend"), Zp = new Map, Lu = "abort auxClick beforeToggle cancel canPlay canPlayThrough click close contextMenu copy cut drag dragEnd dragEnter dragExit dragLeave dragOver dragStart drop durationChange emptied encrypted ended error gotPointerCapture input invalid keyDown keyPress keyUp load loadedData loadedMetadata loadStart lostPointerCapture mouseDown mouseMove mouseOut mouseOver mouseUp paste pause play playing pointerCancel pointerDown pointerMove pointerOut pointerOver pointerUp progress rateChange reset resize seeked seeking stalled submit suspend timeUpdate touchCancel touchEnd touchStart volumeChange scroll toggle touchMove waiting wheel".split(" ");
        Lu.push("scrollEnd");
        function xn(s, o) {
            Zp.set(s, o), tr(o, [
                s
            ]);
        }
        var Qp = new WeakMap;
        function ln(s, o) {
            if (typeof s == "object" && s !== null) {
                var c = Qp.get(s);
                return c !== void 0 ? c : (o = {
                    value: s,
                    source: o,
                    stack: dp(o)
                }, Qp.set(s, o), o);
            }
            return {
                value: s,
                source: o,
                stack: dp(o)
            };
        }
        var cn = [], Jr = 0, Fu = 0;
        function Qo() {
            for(var s = Jr, o = Fu = Jr = 0; o < s;){
                var c = cn[o];
                cn[o++] = null;
                var f = cn[o];
                cn[o++] = null;
                var g = cn[o];
                cn[o++] = null;
                var m = cn[o];
                if (cn[o++] = null, f !== null && g !== null) {
                    var b = f.pending;
                    b === null ? g.next = g : (g.next = b.next, b.next = g), f.pending = g;
                }
                m !== 0 && Gp(c, g, m);
            }
        }
        function Go(s, o, c, f) {
            cn[Jr++] = s, cn[Jr++] = o, cn[Jr++] = c, cn[Jr++] = f, Fu |= f, s.lanes |= f, s = s.alternate, s !== null && (s.lanes |= f);
        }
        function zu(s, o, c, f) {
            return Go(s, o, c, f), Jo(s);
        }
        function es(s, o) {
            return Go(s, null, null, o), Jo(s);
        }
        function Gp(s, o, c) {
            s.lanes |= c;
            var f = s.alternate;
            f !== null && (f.lanes |= c);
            for(var g = !1, m = s.return; m !== null;)m.childLanes |= c, f = m.alternate, f !== null && (f.childLanes |= c), m.tag === 22 && (s = m.stateNode, s === null || s._visibility & 1 || (g = !0)), s = m, m = m.return;
            return s.tag === 3 ? (m = s.stateNode, g && o !== null && (g = 31 - Yt(c), s = m.hiddenUpdates, f = s[g], f === null ? s[g] = [
                o
            ] : f.push(o), o.lane = c | 536870912), m) : null;
        }
        function Jo(s) {
            if (50 < Va) throw Va = 0, Yf = null, Error(i(185));
            for(var o = s.return; o !== null;)s = o, o = s.return;
            return s.tag === 3 ? s.stateNode : null;
        }
        var ts = {};
        function ex(s, o, c, f) {
            this.tag = s, this.key = c, this.sibling = this.child = this.return = this.stateNode = this.type = this.elementType = null, this.index = 0, this.refCleanup = this.ref = null, this.pendingProps = o, this.dependencies = this.memoizedState = this.updateQueue = this.memoizedProps = null, this.mode = f, this.subtreeFlags = this.flags = 0, this.deletions = null, this.childLanes = this.lanes = 0, this.alternate = null;
        }
        function Kt(s, o, c, f) {
            return new ex(s, o, c, f);
        }
        function Vu(s) {
            return s = s.prototype, !(!s || !s.isReactComponent);
        }
        function Kn(s, o) {
            var c = s.alternate;
            return c === null ? (c = Kt(s.tag, o, s.key, s.mode), c.elementType = s.elementType, c.type = s.type, c.stateNode = s.stateNode, c.alternate = s, s.alternate = c) : (c.pendingProps = o, c.type = s.type, c.flags = 0, c.subtreeFlags = 0, c.deletions = null), c.flags = s.flags & 65011712, c.childLanes = s.childLanes, c.lanes = s.lanes, c.child = s.child, c.memoizedProps = s.memoizedProps, c.memoizedState = s.memoizedState, c.updateQueue = s.updateQueue, o = s.dependencies, c.dependencies = o === null ? null : {
                lanes: o.lanes,
                firstContext: o.firstContext
            }, c.sibling = s.sibling, c.index = s.index, c.ref = s.ref, c.refCleanup = s.refCleanup, c;
        }
        function Jp(s, o) {
            s.flags &= 65011714;
            var c = s.alternate;
            return c === null ? (s.childLanes = 0, s.lanes = o, s.child = null, s.subtreeFlags = 0, s.memoizedProps = null, s.memoizedState = null, s.updateQueue = null, s.dependencies = null, s.stateNode = null) : (s.childLanes = c.childLanes, s.lanes = c.lanes, s.child = c.child, s.subtreeFlags = 0, s.deletions = null, s.memoizedProps = c.memoizedProps, s.memoizedState = c.memoizedState, s.updateQueue = c.updateQueue, s.type = c.type, o = c.dependencies, s.dependencies = o === null ? null : {
                lanes: o.lanes,
                firstContext: o.firstContext
            }), s;
        }
        function el(s, o, c, f, g, m) {
            var b = 0;
            if (f = s, typeof s == "function") Vu(s) && (b = 1);
            else if (typeof s == "string") b = nS(s, c, de.current) ? 26 : s === "html" || s === "head" || s === "body" ? 27 : 5;
            else e: switch(s){
                case te:
                    return s = Kt(31, c, o, g), s.elementType = te, s.lanes = m, s;
                case S:
                    return sr(c.children, g, m, o);
                case E:
                    b = 8, g |= 24;
                    break;
                case M:
                    return s = Kt(12, c, o, g | 2), s.elementType = M, s.lanes = m, s;
                case L:
                    return s = Kt(13, c, o, g), s.elementType = L, s.lanes = m, s;
                case Z:
                    return s = Kt(19, c, o, g), s.elementType = Z, s.lanes = m, s;
                default:
                    if (typeof s == "object" && s !== null) switch(s.$$typeof){
                        case B:
                        case O:
                            b = 10;
                            break e;
                        case H:
                            b = 9;
                            break e;
                        case U:
                            b = 11;
                            break e;
                        case se:
                            b = 14;
                            break e;
                        case ae:
                            b = 16, f = null;
                            break e;
                    }
                    b = 29, c = Error(i(130, s === null ? "null" : typeof s, "")), f = null;
            }
            return o = Kt(b, c, o, g), o.elementType = s, o.type = f, o.lanes = m, o;
        }
        function sr(s, o, c, f) {
            return s = Kt(7, s, f, o), s.lanes = c, s;
        }
        function Hu(s, o, c) {
            return s = Kt(6, s, null, o), s.lanes = c, s;
        }
        function ju(s, o, c) {
            return o = Kt(4, s.children !== null ? s.children : [], s.key, o), o.lanes = c, o.stateNode = {
                containerInfo: s.containerInfo,
                pendingChildren: null,
                implementation: s.implementation
            }, o;
        }
        var ns = [], is = 0, tl = null, nl = 0, un = [], fn = 0, ar = null, Zn = 1, Qn = "";
        function or(s, o) {
            ns[is++] = nl, ns[is++] = tl, tl = s, nl = o;
        }
        function em(s, o, c) {
            un[fn++] = Zn, un[fn++] = Qn, un[fn++] = ar, ar = s;
            var f = Zn;
            s = Qn;
            var g = 32 - Yt(f) - 1;
            f &= ~(1 << g), c += 1;
            var m = 32 - Yt(o) + g;
            if (30 < m) {
                var b = g - g % 5;
                m = (f & (1 << b) - 1).toString(32), f >>= b, g -= b, Zn = 1 << 32 - Yt(o) + g | c << g | f, Qn = m + s;
            } else Zn = 1 << m | c << g | f, Qn = s;
        }
        function Wu(s) {
            s.return !== null && (or(s, 1), em(s, 1, 0));
        }
        function $u(s) {
            for(; s === tl;)tl = ns[--is], ns[is] = null, nl = ns[--is], ns[is] = null;
            for(; s === ar;)ar = un[--fn], un[fn] = null, Qn = un[--fn], un[fn] = null, Zn = un[--fn], un[fn] = null;
        }
        var kt = null, nt = null, Ue = !1, lr = null, In = !1, Xu = Error(i(519));
        function cr(s) {
            var o = Error(i(418, ""));
            throw ba(ln(o, s)), Xu;
        }
        function tm(s) {
            var o = s.stateNode, c = s.type, f = s.memoizedProps;
            switch(o[wt] = s, o[Bt] = f, c){
                case "dialog":
                    Me("cancel", o), Me("close", o);
                    break;
                case "iframe":
                case "object":
                case "embed":
                    Me("load", o);
                    break;
                case "video":
                case "audio":
                    for(c = 0; c < ja.length; c++)Me(ja[c], o);
                    break;
                case "source":
                    Me("error", o);
                    break;
                case "img":
                case "image":
                case "link":
                    Me("error", o), Me("load", o);
                    break;
                case "details":
                    Me("toggle", o);
                    break;
                case "input":
                    Me("invalid", o), mp(o, f.value, f.defaultValue, f.checked, f.defaultChecked, f.type, f.name, !0), Ho(o);
                    break;
                case "select":
                    Me("invalid", o);
                    break;
                case "textarea":
                    Me("invalid", o), yp(o, f.value, f.defaultValue, f.children), Ho(o);
            }
            c = f.children, typeof c != "string" && typeof c != "number" && typeof c != "bigint" || o.textContent === "" + c || f.suppressHydrationWarning === !0 || yy(o.textContent, c) ? (f.popover != null && (Me("beforetoggle", o), Me("toggle", o)), f.onScroll != null && Me("scroll", o), f.onScrollEnd != null && Me("scrollend", o), f.onClick != null && (o.onclick = Ul), o = !0) : o = !1, o || cr(s);
        }
        function nm(s) {
            for(kt = s.return; kt;)switch(kt.tag){
                case 5:
                case 13:
                    In = !1;
                    return;
                case 27:
                case 3:
                    In = !0;
                    return;
                default:
                    kt = kt.return;
            }
        }
        function _a(s) {
            if (s !== kt) return !1;
            if (!Ue) return nm(s), Ue = !0, !1;
            var o = s.tag, c;
            if ((c = o !== 3 && o !== 27) && ((c = o === 5) && (c = s.type, c = !(c !== "form" && c !== "button") || ch(s.type, s.memoizedProps)), c = !c), c && nt && cr(s), nm(s), o === 13) {
                if (s = s.memoizedState, s = s !== null ? s.dehydrated : null, !s) throw Error(i(317));
                e: {
                    for(s = s.nextSibling, o = 0; s;){
                        if (s.nodeType === 8) if (c = s.data, c === "/$") {
                            if (o === 0) {
                                nt = An(s.nextSibling);
                                break e;
                            }
                            o--;
                        } else c !== "$" && c !== "$!" && c !== "$?" || o++;
                        s = s.nextSibling;
                    }
                    nt = null;
                }
            } else o === 27 ? (o = nt, Pi(s.type) ? (s = dh, dh = null, nt = s) : nt = o) : nt = kt ? An(s.stateNode.nextSibling) : null;
            return !0;
        }
        function ya() {
            nt = kt = null, Ue = !1;
        }
        function im() {
            var s = lr;
            return s !== null && (Vt === null ? Vt = s : Vt.push.apply(Vt, s), lr = null), s;
        }
        function ba(s) {
            lr === null ? lr = [
                s
            ] : lr.push(s);
        }
        var Yu = G(null), ur = null, Gn = null;
        function yi(s, o, c) {
            re(Yu, o._currentValue), o._currentValue = c;
        }
        function Jn(s) {
            s._currentValue = Yu.current, oe(Yu);
        }
        function qu(s, o, c) {
            for(; s !== null;){
                var f = s.alternate;
                if ((s.childLanes & o) !== o ? (s.childLanes |= o, f !== null && (f.childLanes |= o)) : f !== null && (f.childLanes & o) !== o && (f.childLanes |= o), s === c) break;
                s = s.return;
            }
        }
        function Ku(s, o, c, f) {
            var g = s.child;
            for(g !== null && (g.return = s); g !== null;){
                var m = g.dependencies;
                if (m !== null) {
                    var b = g.child;
                    m = m.firstContext;
                    e: for(; m !== null;){
                        var T = m;
                        m = g;
                        for(var w = 0; w < o.length; w++)if (T.context === o[w]) {
                            m.lanes |= c, T = m.alternate, T !== null && (T.lanes |= c), qu(m.return, c, s), f || (b = null);
                            break e;
                        }
                        m = T.next;
                    }
                } else if (g.tag === 18) {
                    if (b = g.return, b === null) throw Error(i(341));
                    b.lanes |= c, m = b.alternate, m !== null && (m.lanes |= c), qu(b, c, s), b = null;
                } else b = g.child;
                if (b !== null) b.return = g;
                else for(b = g; b !== null;){
                    if (b === s) {
                        b = null;
                        break;
                    }
                    if (g = b.sibling, g !== null) {
                        g.return = b.return, b = g;
                        break;
                    }
                    b = b.return;
                }
                g = b;
            }
        }
        function va(s, o, c, f) {
            s = null;
            for(var g = o, m = !1; g !== null;){
                if (!m) {
                    if ((g.flags & 524288) !== 0) m = !0;
                    else if ((g.flags & 262144) !== 0) break;
                }
                if (g.tag === 10) {
                    var b = g.alternate;
                    if (b === null) throw Error(i(387));
                    if (b = b.memoizedProps, b !== null) {
                        var T = g.type;
                        qt(g.pendingProps.value, b.value) || (s !== null ? s.push(T) : s = [
                            T
                        ]);
                    }
                } else if (g === Pt.current) {
                    if (b = g.alternate, b === null) throw Error(i(387));
                    b.memoizedState.memoizedState !== g.memoizedState.memoizedState && (s !== null ? s.push(Ka) : s = [
                        Ka
                    ]);
                }
                g = g.return;
            }
            s !== null && Ku(o, s, c, f), o.flags |= 262144;
        }
        function il(s) {
            for(s = s.firstContext; s !== null;){
                if (!qt(s.context._currentValue, s.memoizedValue)) return !0;
                s = s.next;
            }
            return !1;
        }
        function fr(s) {
            ur = s, Gn = null, s = s.dependencies, s !== null && (s.firstContext = null);
        }
        function Et(s) {
            return rm(ur, s);
        }
        function rl(s, o) {
            return ur === null && fr(s), rm(s, o);
        }
        function rm(s, o) {
            var c = o._currentValue;
            if (o = {
                context: o,
                memoizedValue: c,
                next: null
            }, Gn === null) {
                if (s === null) throw Error(i(308));
                Gn = o, s.dependencies = {
                    lanes: 0,
                    firstContext: o
                }, s.flags |= 524288;
            } else Gn = Gn.next = o;
            return c;
        }
        var tx = typeof AbortController < "u" ? AbortController : function() {
            var s = [], o = this.signal = {
                aborted: !1,
                addEventListener: function(c, f) {
                    s.push(f);
                }
            };
            this.abort = function() {
                o.aborted = !0, s.forEach(function(c) {
                    return c();
                });
            };
        }, nx = n.unstable_scheduleCallback, ix = n.unstable_NormalPriority, dt = {
            $$typeof: O,
            Consumer: null,
            Provider: null,
            _currentValue: null,
            _currentValue2: null,
            _threadCount: 0
        };
        function Zu() {
            return {
                controller: new tx,
                data: new Map,
                refCount: 0
            };
        }
        function Ta(s) {
            s.refCount--, s.refCount === 0 && nx(ix, function() {
                s.controller.abort();
            });
        }
        var xa = null, Qu = 0, rs = 0, ss = null;
        function rx(s, o) {
            if (xa === null) {
                var c = xa = [];
                Qu = 0, rs = eh(), ss = {
                    status: "pending",
                    value: void 0,
                    then: function(f) {
                        c.push(f);
                    }
                };
            }
            return Qu++, o.then(sm, sm), o;
        }
        function sm() {
            if (--Qu === 0 && xa !== null) {
                ss !== null && (ss.status = "fulfilled");
                var s = xa;
                xa = null, rs = 0, ss = null;
                for(var o = 0; o < s.length; o++)(0, s[o])();
            }
        }
        function sx(s, o) {
            var c = [], f = {
                status: "pending",
                value: null,
                reason: null,
                then: function(g) {
                    c.push(g);
                }
            };
            return s.then(function() {
                f.status = "fulfilled", f.value = o;
                for(var g = 0; g < c.length; g++)(0, c[g])(o);
            }, function(g) {
                for(f.status = "rejected", f.reason = g, g = 0; g < c.length; g++)(0, c[g])(void 0);
            }), f;
        }
        var am = $.S;
        $.S = function(s, o) {
            typeof o == "object" && o !== null && typeof o.then == "function" && rx(s, o), am !== null && am(s, o);
        };
        var hr = G(null);
        function Gu() {
            var s = hr.current;
            return s !== null ? s : Qe.pooledCache;
        }
        function sl(s, o) {
            o === null ? re(hr, hr.current) : re(hr, o.pool);
        }
        function om() {
            var s = Gu();
            return s === null ? null : {
                parent: dt._currentValue,
                pool: s
            };
        }
        var Sa = Error(i(460)), lm = Error(i(474)), al = Error(i(542)), Ju = {
            then: function() {}
        };
        function cm(s) {
            return s = s.status, s === "fulfilled" || s === "rejected";
        }
        function ol() {}
        function um(s, o, c) {
            switch(c = s[c], c === void 0 ? s.push(o) : c !== o && (o.then(ol, ol), o = c), o.status){
                case "fulfilled":
                    return o.value;
                case "rejected":
                    throw s = o.reason, hm(s), s;
                default:
                    if (typeof o.status == "string") o.then(ol, ol);
                    else {
                        if (s = Qe, s !== null && 100 < s.shellSuspendCounter) throw Error(i(482));
                        s = o, s.status = "pending", s.then(function(f) {
                            if (o.status === "pending") {
                                var g = o;
                                g.status = "fulfilled", g.value = f;
                            }
                        }, function(f) {
                            if (o.status === "pending") {
                                var g = o;
                                g.status = "rejected", g.reason = f;
                            }
                        });
                    }
                    switch(o.status){
                        case "fulfilled":
                            return o.value;
                        case "rejected":
                            throw s = o.reason, hm(s), s;
                    }
                    throw Aa = o, Sa;
            }
        }
        var Aa = null;
        function fm() {
            if (Aa === null) throw Error(i(459));
            var s = Aa;
            return Aa = null, s;
        }
        function hm(s) {
            if (s === Sa || s === al) throw Error(i(483));
        }
        var bi = !1;
        function ef(s) {
            s.updateQueue = {
                baseState: s.memoizedState,
                firstBaseUpdate: null,
                lastBaseUpdate: null,
                shared: {
                    pending: null,
                    lanes: 0,
                    hiddenCallbacks: null
                },
                callbacks: null
            };
        }
        function tf(s, o) {
            s = s.updateQueue, o.updateQueue === s && (o.updateQueue = {
                baseState: s.baseState,
                firstBaseUpdate: s.firstBaseUpdate,
                lastBaseUpdate: s.lastBaseUpdate,
                shared: s.shared,
                callbacks: null
            });
        }
        function vi(s) {
            return {
                lane: s,
                tag: 0,
                payload: null,
                callback: null,
                next: null
            };
        }
        function Ti(s, o, c) {
            var f = s.updateQueue;
            if (f === null) return null;
            if (f = f.shared, (ze & 2) !== 0) {
                var g = f.pending;
                return g === null ? o.next = o : (o.next = g.next, g.next = o), f.pending = o, o = Jo(s), Gp(s, null, c), o;
            }
            return Go(s, f, o, c), Jo(s);
        }
        function wa(s, o, c) {
            if (o = o.updateQueue, o !== null && (o = o.shared, (c & 4194048) !== 0)) {
                var f = o.lanes;
                f &= s.pendingLanes, c |= f, o.lanes = c, sp(s, c);
            }
        }
        function nf(s, o) {
            var c = s.updateQueue, f = s.alternate;
            if (f !== null && (f = f.updateQueue, c === f)) {
                var g = null, m = null;
                if (c = c.firstBaseUpdate, c !== null) {
                    do {
                        var b = {
                            lane: c.lane,
                            tag: c.tag,
                            payload: c.payload,
                            callback: null,
                            next: null
                        };
                        m === null ? g = m = b : m = m.next = b, c = c.next;
                    }while (c !== null);
                    m === null ? g = m = o : m = m.next = o;
                } else g = m = o;
                c = {
                    baseState: f.baseState,
                    firstBaseUpdate: g,
                    lastBaseUpdate: m,
                    shared: f.shared,
                    callbacks: f.callbacks
                }, s.updateQueue = c;
                return;
            }
            s = c.lastBaseUpdate, s === null ? c.firstBaseUpdate = o : s.next = o, c.lastBaseUpdate = o;
        }
        var rf = !1;
        function Ea() {
            if (rf) {
                var s = ss;
                if (s !== null) throw s;
            }
        }
        function Ra(s, o, c, f) {
            rf = !1;
            var g = s.updateQueue;
            bi = !1;
            var m = g.firstBaseUpdate, b = g.lastBaseUpdate, T = g.shared.pending;
            if (T !== null) {
                g.shared.pending = null;
                var w = T, V = w.next;
                w.next = null, b === null ? m = V : b.next = V, b = w;
                var X = s.alternate;
                X !== null && (X = X.updateQueue, T = X.lastBaseUpdate, T !== b && (T === null ? X.firstBaseUpdate = V : T.next = V, X.lastBaseUpdate = w));
            }
            if (m !== null) {
                var K = g.baseState;
                b = 0, X = V = w = null, T = m;
                do {
                    var j = T.lane & -536870913, W = j !== T.lane;
                    if (W ? (De & j) === j : (f & j) === j) {
                        j !== 0 && j === rs && (rf = !0), X !== null && (X = X.next = {
                            lane: 0,
                            tag: T.tag,
                            payload: T.payload,
                            callback: null,
                            next: null
                        });
                        e: {
                            var ye = s, ge = T;
                            j = o;
                            var We = c;
                            switch(ge.tag){
                                case 1:
                                    if (ye = ge.payload, typeof ye == "function") {
                                        K = ye.call(We, K, j);
                                        break e;
                                    }
                                    K = ye;
                                    break e;
                                case 3:
                                    ye.flags = ye.flags & -65537 | 128;
                                case 0:
                                    if (ye = ge.payload, j = typeof ye == "function" ? ye.call(We, K, j) : ye, j == null) break e;
                                    K = p({}, K, j);
                                    break e;
                                case 2:
                                    bi = !0;
                            }
                        }
                        j = T.callback, j !== null && (s.flags |= 64, W && (s.flags |= 8192), W = g.callbacks, W === null ? g.callbacks = [
                            j
                        ] : W.push(j));
                    } else W = {
                        lane: j,
                        tag: T.tag,
                        payload: T.payload,
                        callback: T.callback,
                        next: null
                    }, X === null ? (V = X = W, w = K) : X = X.next = W, b |= j;
                    if (T = T.next, T === null) {
                        if (T = g.shared.pending, T === null) break;
                        W = T, T = W.next, W.next = null, g.lastBaseUpdate = W, g.shared.pending = null;
                    }
                }while (!0);
                X === null && (w = K), g.baseState = w, g.firstBaseUpdate = V, g.lastBaseUpdate = X, m === null && (g.shared.lanes = 0), Mi |= b, s.lanes = b, s.memoizedState = K;
            }
        }
        function dm(s, o) {
            if (typeof s != "function") throw Error(i(191, s));
            s.call(o);
        }
        function gm(s, o) {
            var c = s.callbacks;
            if (c !== null) for(s.callbacks = null, s = 0; s < c.length; s++)dm(c[s], o);
        }
        var as = G(null), ll = G(0);
        function pm(s, o) {
            s = ai, re(ll, s), re(as, o), ai = s | o.baseLanes;
        }
        function sf() {
            re(ll, ai), re(as, as.current);
        }
        function af() {
            ai = ll.current, oe(as), oe(ll);
        }
        var xi = 0, we = null, He = null, lt = null, cl = !1, os = !1, dr = !1, ul = 0, Ca = 0, ls = null, ax = 0;
        function at() {
            throw Error(i(321));
        }
        function of(s, o) {
            if (o === null) return !1;
            for(var c = 0; c < o.length && c < s.length; c++)if (!qt(s[c], o[c])) return !1;
            return !0;
        }
        function lf(s, o, c, f, g, m) {
            return xi = m, we = o, o.memoizedState = null, o.updateQueue = null, o.lanes = 0, $.H = s === null || s.memoizedState === null ? Gm : Jm, dr = !1, m = c(f, g), dr = !1, os && (m = _m(o, c, f, g)), mm(s), m;
        }
        function mm(s) {
            $.H = ml;
            var o = He !== null && He.next !== null;
            if (xi = 0, lt = He = we = null, cl = !1, Ca = 0, ls = null, o) throw Error(i(300));
            s === null || yt || (s = s.dependencies, s !== null && il(s) && (yt = !0));
        }
        function _m(s, o, c, f) {
            we = s;
            var g = 0;
            do {
                if (os && (ls = null), Ca = 0, os = !1, 25 <= g) throw Error(i(301));
                if (g += 1, lt = He = null, s.updateQueue != null) {
                    var m = s.updateQueue;
                    m.lastEffect = null, m.events = null, m.stores = null, m.memoCache != null && (m.memoCache.index = 0);
                }
                $.H = dx, m = o(c, f);
            }while (os);
            return m;
        }
        function ox() {
            var s = $.H, o = s.useState()[0];
            return o = typeof o.then == "function" ? Ma(o) : o, s = s.useState()[0], (He !== null ? He.memoizedState : null) !== s && (we.flags |= 1024), o;
        }
        function cf() {
            var s = ul !== 0;
            return ul = 0, s;
        }
        function uf(s, o, c) {
            o.updateQueue = s.updateQueue, o.flags &= -2053, s.lanes &= ~c;
        }
        function ff(s) {
            if (cl) {
                for(s = s.memoizedState; s !== null;){
                    var o = s.queue;
                    o !== null && (o.pending = null), s = s.next;
                }
                cl = !1;
            }
            xi = 0, lt = He = we = null, os = !1, Ca = ul = 0, ls = null;
        }
        function Ft() {
            var s = {
                memoizedState: null,
                baseState: null,
                baseQueue: null,
                queue: null,
                next: null
            };
            return lt === null ? we.memoizedState = lt = s : lt = lt.next = s, lt;
        }
        function ct() {
            if (He === null) {
                var s = we.alternate;
                s = s !== null ? s.memoizedState : null;
            } else s = He.next;
            var o = lt === null ? we.memoizedState : lt.next;
            if (o !== null) lt = o, He = s;
            else {
                if (s === null) throw we.alternate === null ? Error(i(467)) : Error(i(310));
                He = s, s = {
                    memoizedState: He.memoizedState,
                    baseState: He.baseState,
                    baseQueue: He.baseQueue,
                    queue: He.queue,
                    next: null
                }, lt === null ? we.memoizedState = lt = s : lt = lt.next = s;
            }
            return lt;
        }
        function hf() {
            return {
                lastEffect: null,
                events: null,
                stores: null,
                memoCache: null
            };
        }
        function Ma(s) {
            var o = Ca;
            return Ca += 1, ls === null && (ls = []), s = um(ls, s, o), o = we, (lt === null ? o.memoizedState : lt.next) === null && (o = o.alternate, $.H = o === null || o.memoizedState === null ? Gm : Jm), s;
        }
        function fl(s) {
            if (s !== null && typeof s == "object") {
                if (typeof s.then == "function") return Ma(s);
                if (s.$$typeof === O) return Et(s);
            }
            throw Error(i(438, String(s)));
        }
        function df(s) {
            var o = null, c = we.updateQueue;
            if (c !== null && (o = c.memoCache), o == null) {
                var f = we.alternate;
                f !== null && (f = f.updateQueue, f !== null && (f = f.memoCache, f != null && (o = {
                    data: f.data.map(function(g) {
                        return g.slice();
                    }),
                    index: 0
                })));
            }
            if (o == null && (o = {
                data: [],
                index: 0
            }), c === null && (c = hf(), we.updateQueue = c), c.memoCache = o, c = o.data[o.index], c === void 0) for(c = o.data[o.index] = Array(s), f = 0; f < s; f++)c[f] = fe;
            return o.index++, c;
        }
        function ei(s, o) {
            return typeof o == "function" ? o(s) : o;
        }
        function hl(s) {
            var o = ct();
            return gf(o, He, s);
        }
        function gf(s, o, c) {
            var f = s.queue;
            if (f === null) throw Error(i(311));
            f.lastRenderedReducer = c;
            var g = s.baseQueue, m = f.pending;
            if (m !== null) {
                if (g !== null) {
                    var b = g.next;
                    g.next = m.next, m.next = b;
                }
                o.baseQueue = g = m, f.pending = null;
            }
            if (m = s.baseState, g === null) s.memoizedState = m;
            else {
                o = g.next;
                var T = b = null, w = null, V = o, X = !1;
                do {
                    var K = V.lane & -536870913;
                    if (K !== V.lane ? (De & K) === K : (xi & K) === K) {
                        var j = V.revertLane;
                        if (j === 0) w !== null && (w = w.next = {
                            lane: 0,
                            revertLane: 0,
                            action: V.action,
                            hasEagerState: V.hasEagerState,
                            eagerState: V.eagerState,
                            next: null
                        }), K === rs && (X = !0);
                        else if ((xi & j) === j) {
                            V = V.next, j === rs && (X = !0);
                            continue;
                        } else K = {
                            lane: 0,
                            revertLane: V.revertLane,
                            action: V.action,
                            hasEagerState: V.hasEagerState,
                            eagerState: V.eagerState,
                            next: null
                        }, w === null ? (T = w = K, b = m) : w = w.next = K, we.lanes |= j, Mi |= j;
                        K = V.action, dr && c(m, K), m = V.hasEagerState ? V.eagerState : c(m, K);
                    } else j = {
                        lane: K,
                        revertLane: V.revertLane,
                        action: V.action,
                        hasEagerState: V.hasEagerState,
                        eagerState: V.eagerState,
                        next: null
                    }, w === null ? (T = w = j, b = m) : w = w.next = j, we.lanes |= K, Mi |= K;
                    V = V.next;
                }while (V !== null && V !== o);
                if (w === null ? b = m : w.next = T, !qt(m, s.memoizedState) && (yt = !0, X && (c = ss, c !== null))) throw c;
                s.memoizedState = m, s.baseState = b, s.baseQueue = w, f.lastRenderedState = m;
            }
            return g === null && (f.lanes = 0), [
                s.memoizedState,
                f.dispatch
            ];
        }
        function pf(s) {
            var o = ct(), c = o.queue;
            if (c === null) throw Error(i(311));
            c.lastRenderedReducer = s;
            var f = c.dispatch, g = c.pending, m = o.memoizedState;
            if (g !== null) {
                c.pending = null;
                var b = g = g.next;
                do m = s(m, b.action), b = b.next;
                while (b !== g);
                qt(m, o.memoizedState) || (yt = !0), o.memoizedState = m, o.baseQueue === null && (o.baseState = m), c.lastRenderedState = m;
            }
            return [
                m,
                f
            ];
        }
        function ym(s, o, c) {
            var f = we, g = ct(), m = Ue;
            if (m) {
                if (c === void 0) throw Error(i(407));
                c = c();
            } else c = o();
            var b = !qt((He || g).memoizedState, c);
            b && (g.memoizedState = c, yt = !0), g = g.queue;
            var T = Tm.bind(null, f, g, s);
            if (Oa(2048, 8, T, [
                s
            ]), g.getSnapshot !== o || b || lt !== null && lt.memoizedState.tag & 1) {
                if (f.flags |= 2048, cs(9, dl(), vm.bind(null, f, g, c, o), null), Qe === null) throw Error(i(349));
                m || (xi & 124) !== 0 || bm(f, o, c);
            }
            return c;
        }
        function bm(s, o, c) {
            s.flags |= 16384, s = {
                getSnapshot: o,
                value: c
            }, o = we.updateQueue, o === null ? (o = hf(), we.updateQueue = o, o.stores = [
                s
            ]) : (c = o.stores, c === null ? o.stores = [
                s
            ] : c.push(s));
        }
        function vm(s, o, c, f) {
            o.value = c, o.getSnapshot = f, xm(o) && Sm(s);
        }
        function Tm(s, o, c) {
            return c(function() {
                xm(o) && Sm(s);
            });
        }
        function xm(s) {
            var o = s.getSnapshot;
            s = s.value;
            try {
                var c = o();
                return !qt(s, c);
            } catch  {
                return !0;
            }
        }
        function Sm(s) {
            var o = es(s, 2);
            o !== null && en(o, s, 2);
        }
        function mf(s) {
            var o = Ft();
            if (typeof s == "function") {
                var c = s;
                if (s = c(), dr) {
                    pi(!0);
                    try {
                        c();
                    } finally{
                        pi(!1);
                    }
                }
            }
            return o.memoizedState = o.baseState = s, o.queue = {
                pending: null,
                lanes: 0,
                dispatch: null,
                lastRenderedReducer: ei,
                lastRenderedState: s
            }, o;
        }
        function Am(s, o, c, f) {
            return s.baseState = c, gf(s, He, typeof f == "function" ? f : ei);
        }
        function lx(s, o, c, f, g) {
            if (pl(s)) throw Error(i(485));
            if (s = o.action, s !== null) {
                var m = {
                    payload: g,
                    action: s,
                    next: null,
                    isTransition: !0,
                    status: "pending",
                    value: null,
                    reason: null,
                    listeners: [],
                    then: function(b) {
                        m.listeners.push(b);
                    }
                };
                $.T !== null ? c(!0) : m.isTransition = !1, f(m), c = o.pending, c === null ? (m.next = o.pending = m, wm(o, m)) : (m.next = c.next, o.pending = c.next = m);
            }
        }
        function wm(s, o) {
            var c = o.action, f = o.payload, g = s.state;
            if (o.isTransition) {
                var m = $.T, b = {};
                $.T = b;
                try {
                    var T = c(g, f), w = $.S;
                    w !== null && w(b, T), Em(s, o, T);
                } catch (V) {
                    _f(s, o, V);
                } finally{
                    $.T = m;
                }
            } else try {
                m = c(g, f), Em(s, o, m);
            } catch (V) {
                _f(s, o, V);
            }
        }
        function Em(s, o, c) {
            c !== null && typeof c == "object" && typeof c.then == "function" ? c.then(function(f) {
                Rm(s, o, f);
            }, function(f) {
                return _f(s, o, f);
            }) : Rm(s, o, c);
        }
        function Rm(s, o, c) {
            o.status = "fulfilled", o.value = c, Cm(o), s.state = c, o = s.pending, o !== null && (c = o.next, c === o ? s.pending = null : (c = c.next, o.next = c, wm(s, c)));
        }
        function _f(s, o, c) {
            var f = s.pending;
            if (s.pending = null, f !== null) {
                f = f.next;
                do o.status = "rejected", o.reason = c, Cm(o), o = o.next;
                while (o !== f);
            }
            s.action = null;
        }
        function Cm(s) {
            s = s.listeners;
            for(var o = 0; o < s.length; o++)(0, s[o])();
        }
        function Mm(s, o) {
            return o;
        }
        function Om(s, o) {
            if (Ue) {
                var c = Qe.formState;
                if (c !== null) {
                    e: {
                        var f = we;
                        if (Ue) {
                            if (nt) {
                                t: {
                                    for(var g = nt, m = In; g.nodeType !== 8;){
                                        if (!m) {
                                            g = null;
                                            break t;
                                        }
                                        if (g = An(g.nextSibling), g === null) {
                                            g = null;
                                            break t;
                                        }
                                    }
                                    m = g.data, g = m === "F!" || m === "F" ? g : null;
                                }
                                if (g) {
                                    nt = An(g.nextSibling), f = g.data === "F!";
                                    break e;
                                }
                            }
                            cr(f);
                        }
                        f = !1;
                    }
                    f && (o = c[0]);
                }
            }
            return c = Ft(), c.memoizedState = c.baseState = o, f = {
                pending: null,
                lanes: 0,
                dispatch: null,
                lastRenderedReducer: Mm,
                lastRenderedState: o
            }, c.queue = f, c = Km.bind(null, we, f), f.dispatch = c, f = mf(!1), m = xf.bind(null, we, !1, f.queue), f = Ft(), g = {
                state: o,
                dispatch: null,
                action: s,
                pending: null
            }, f.queue = g, c = lx.bind(null, we, g, m, c), g.dispatch = c, f.memoizedState = s, [
                o,
                c,
                !1
            ];
        }
        function Im(s) {
            var o = ct();
            return Nm(o, He, s);
        }
        function Nm(s, o, c) {
            if (o = gf(s, o, Mm)[0], s = hl(ei)[0], typeof o == "object" && o !== null && typeof o.then == "function") try {
                var f = Ma(o);
            } catch (b) {
                throw b === Sa ? al : b;
            }
            else f = o;
            o = ct();
            var g = o.queue, m = g.dispatch;
            return c !== o.memoizedState && (we.flags |= 2048, cs(9, dl(), cx.bind(null, g, c), null)), [
                f,
                m,
                s
            ];
        }
        function cx(s, o) {
            s.action = o;
        }
        function Pm(s) {
            var o = ct(), c = He;
            if (c !== null) return Nm(o, c, s);
            ct(), o = o.memoizedState, c = ct();
            var f = c.queue.dispatch;
            return c.memoizedState = s, [
                o,
                f,
                !1
            ];
        }
        function cs(s, o, c, f) {
            return s = {
                tag: s,
                create: c,
                deps: f,
                inst: o,
                next: null
            }, o = we.updateQueue, o === null && (o = hf(), we.updateQueue = o), c = o.lastEffect, c === null ? o.lastEffect = s.next = s : (f = c.next, c.next = s, s.next = f, o.lastEffect = s), s;
        }
        function dl() {
            return {
                destroy: void 0,
                resource: void 0
            };
        }
        function Dm() {
            return ct().memoizedState;
        }
        function gl(s, o, c, f) {
            var g = Ft();
            f = f === void 0 ? null : f, we.flags |= s, g.memoizedState = cs(1 | o, dl(), c, f);
        }
        function Oa(s, o, c, f) {
            var g = ct();
            f = f === void 0 ? null : f;
            var m = g.memoizedState.inst;
            He !== null && f !== null && of(f, He.memoizedState.deps) ? g.memoizedState = cs(o, m, c, f) : (we.flags |= s, g.memoizedState = cs(1 | o, m, c, f));
        }
        function km(s, o) {
            gl(8390656, 8, s, o);
        }
        function Um(s, o) {
            Oa(2048, 8, s, o);
        }
        function Bm(s, o) {
            return Oa(4, 2, s, o);
        }
        function Lm(s, o) {
            return Oa(4, 4, s, o);
        }
        function Fm(s, o) {
            if (typeof o == "function") {
                s = s();
                var c = o(s);
                return function() {
                    typeof c == "function" ? c() : o(null);
                };
            }
            if (o != null) return s = s(), o.current = s, function() {
                o.current = null;
            };
        }
        function zm(s, o, c) {
            c = c != null ? c.concat([
                s
            ]) : null, Oa(4, 4, Fm.bind(null, o, s), c);
        }
        function yf() {}
        function Vm(s, o) {
            var c = ct();
            o = o === void 0 ? null : o;
            var f = c.memoizedState;
            return o !== null && of(o, f[1]) ? f[0] : (c.memoizedState = [
                s,
                o
            ], s);
        }
        function Hm(s, o) {
            var c = ct();
            o = o === void 0 ? null : o;
            var f = c.memoizedState;
            if (o !== null && of(o, f[1])) return f[0];
            if (f = s(), dr) {
                pi(!0);
                try {
                    s();
                } finally{
                    pi(!1);
                }
            }
            return c.memoizedState = [
                f,
                o
            ], f;
        }
        function bf(s, o, c) {
            return c === void 0 || (xi & 1073741824) !== 0 ? s.memoizedState = o : (s.memoizedState = c, s = $_(), we.lanes |= s, Mi |= s, c);
        }
        function jm(s, o, c, f) {
            return qt(c, o) ? c : as.current !== null ? (s = bf(s, c, f), qt(s, o) || (yt = !0), s) : (xi & 42) === 0 ? (yt = !0, s.memoizedState = c) : (s = $_(), we.lanes |= s, Mi |= s, o);
        }
        function Wm(s, o, c, f, g) {
            var m = ee.p;
            ee.p = m !== 0 && 8 > m ? m : 8;
            var b = $.T, T = {};
            $.T = T, xf(s, !1, o, c);
            try {
                var w = g(), V = $.S;
                if (V !== null && V(T, w), w !== null && typeof w == "object" && typeof w.then == "function") {
                    var X = sx(w, f);
                    Ia(s, o, X, Jt(s));
                } else Ia(s, o, f, Jt(s));
            } catch (K) {
                Ia(s, o, {
                    then: function() {},
                    status: "rejected",
                    reason: K
                }, Jt());
            } finally{
                ee.p = m, $.T = b;
            }
        }
        function ux() {}
        function vf(s, o, c, f) {
            if (s.tag !== 5) throw Error(i(476));
            var g = $m(s).queue;
            Wm(s, g, o, ce, c === null ? ux : function() {
                return Xm(s), c(f);
            });
        }
        function $m(s) {
            var o = s.memoizedState;
            if (o !== null) return o;
            o = {
                memoizedState: ce,
                baseState: ce,
                baseQueue: null,
                queue: {
                    pending: null,
                    lanes: 0,
                    dispatch: null,
                    lastRenderedReducer: ei,
                    lastRenderedState: ce
                },
                next: null
            };
            var c = {};
            return o.next = {
                memoizedState: c,
                baseState: c,
                baseQueue: null,
                queue: {
                    pending: null,
                    lanes: 0,
                    dispatch: null,
                    lastRenderedReducer: ei,
                    lastRenderedState: c
                },
                next: null
            }, s.memoizedState = o, s = s.alternate, s !== null && (s.memoizedState = o), o;
        }
        function Xm(s) {
            var o = $m(s).next.queue;
            Ia(s, o, {}, Jt());
        }
        function Tf() {
            return Et(Ka);
        }
        function Ym() {
            return ct().memoizedState;
        }
        function qm() {
            return ct().memoizedState;
        }
        function fx(s) {
            for(var o = s.return; o !== null;){
                switch(o.tag){
                    case 24:
                    case 3:
                        var c = Jt();
                        s = vi(c);
                        var f = Ti(o, s, c);
                        f !== null && (en(f, o, c), wa(f, o, c)), o = {
                            cache: Zu()
                        }, s.payload = o;
                        return;
                }
                o = o.return;
            }
        }
        function hx(s, o, c) {
            var f = Jt();
            c = {
                lane: f,
                revertLane: 0,
                action: c,
                hasEagerState: !1,
                eagerState: null,
                next: null
            }, pl(s) ? Zm(o, c) : (c = zu(s, o, c, f), c !== null && (en(c, s, f), Qm(c, o, f)));
        }
        function Km(s, o, c) {
            var f = Jt();
            Ia(s, o, c, f);
        }
        function Ia(s, o, c, f) {
            var g = {
                lane: f,
                revertLane: 0,
                action: c,
                hasEagerState: !1,
                eagerState: null,
                next: null
            };
            if (pl(s)) Zm(o, g);
            else {
                var m = s.alternate;
                if (s.lanes === 0 && (m === null || m.lanes === 0) && (m = o.lastRenderedReducer, m !== null)) try {
                    var b = o.lastRenderedState, T = m(b, c);
                    if (g.hasEagerState = !0, g.eagerState = T, qt(T, b)) return Go(s, o, g, 0), Qe === null && Qo(), !1;
                } catch  {} finally{}
                if (c = zu(s, o, g, f), c !== null) return en(c, s, f), Qm(c, o, f), !0;
            }
            return !1;
        }
        function xf(s, o, c, f) {
            if (f = {
                lane: 2,
                revertLane: eh(),
                action: f,
                hasEagerState: !1,
                eagerState: null,
                next: null
            }, pl(s)) {
                if (o) throw Error(i(479));
            } else o = zu(s, c, f, 2), o !== null && en(o, s, 2);
        }
        function pl(s) {
            var o = s.alternate;
            return s === we || o !== null && o === we;
        }
        function Zm(s, o) {
            os = cl = !0;
            var c = s.pending;
            c === null ? o.next = o : (o.next = c.next, c.next = o), s.pending = o;
        }
        function Qm(s, o, c) {
            if ((c & 4194048) !== 0) {
                var f = o.lanes;
                f &= s.pendingLanes, c |= f, o.lanes = c, sp(s, c);
            }
        }
        var ml = {
            readContext: Et,
            use: fl,
            useCallback: at,
            useContext: at,
            useEffect: at,
            useImperativeHandle: at,
            useLayoutEffect: at,
            useInsertionEffect: at,
            useMemo: at,
            useReducer: at,
            useRef: at,
            useState: at,
            useDebugValue: at,
            useDeferredValue: at,
            useTransition: at,
            useSyncExternalStore: at,
            useId: at,
            useHostTransitionStatus: at,
            useFormState: at,
            useActionState: at,
            useOptimistic: at,
            useMemoCache: at,
            useCacheRefresh: at
        }, Gm = {
            readContext: Et,
            use: fl,
            useCallback: function(s, o) {
                return Ft().memoizedState = [
                    s,
                    o === void 0 ? null : o
                ], s;
            },
            useContext: Et,
            useEffect: km,
            useImperativeHandle: function(s, o, c) {
                c = c != null ? c.concat([
                    s
                ]) : null, gl(4194308, 4, Fm.bind(null, o, s), c);
            },
            useLayoutEffect: function(s, o) {
                return gl(4194308, 4, s, o);
            },
            useInsertionEffect: function(s, o) {
                gl(4, 2, s, o);
            },
            useMemo: function(s, o) {
                var c = Ft();
                o = o === void 0 ? null : o;
                var f = s();
                if (dr) {
                    pi(!0);
                    try {
                        s();
                    } finally{
                        pi(!1);
                    }
                }
                return c.memoizedState = [
                    f,
                    o
                ], f;
            },
            useReducer: function(s, o, c) {
                var f = Ft();
                if (c !== void 0) {
                    var g = c(o);
                    if (dr) {
                        pi(!0);
                        try {
                            c(o);
                        } finally{
                            pi(!1);
                        }
                    }
                } else g = o;
                return f.memoizedState = f.baseState = g, s = {
                    pending: null,
                    lanes: 0,
                    dispatch: null,
                    lastRenderedReducer: s,
                    lastRenderedState: g
                }, f.queue = s, s = s.dispatch = hx.bind(null, we, s), [
                    f.memoizedState,
                    s
                ];
            },
            useRef: function(s) {
                var o = Ft();
                return s = {
                    current: s
                }, o.memoizedState = s;
            },
            useState: function(s) {
                s = mf(s);
                var o = s.queue, c = Km.bind(null, we, o);
                return o.dispatch = c, [
                    s.memoizedState,
                    c
                ];
            },
            useDebugValue: yf,
            useDeferredValue: function(s, o) {
                var c = Ft();
                return bf(c, s, o);
            },
            useTransition: function() {
                var s = mf(!1);
                return s = Wm.bind(null, we, s.queue, !0, !1), Ft().memoizedState = s, [
                    !1,
                    s
                ];
            },
            useSyncExternalStore: function(s, o, c) {
                var f = we, g = Ft();
                if (Ue) {
                    if (c === void 0) throw Error(i(407));
                    c = c();
                } else {
                    if (c = o(), Qe === null) throw Error(i(349));
                    (De & 124) !== 0 || bm(f, o, c);
                }
                g.memoizedState = c;
                var m = {
                    value: c,
                    getSnapshot: o
                };
                return g.queue = m, km(Tm.bind(null, f, m, s), [
                    s
                ]), f.flags |= 2048, cs(9, dl(), vm.bind(null, f, m, c, o), null), c;
            },
            useId: function() {
                var s = Ft(), o = Qe.identifierPrefix;
                if (Ue) {
                    var c = Qn, f = Zn;
                    c = (f & ~(1 << 32 - Yt(f) - 1)).toString(32) + c, o = "" + o + "R" + c, c = ul++, 0 < c && (o += "H" + c.toString(32)), o += "";
                } else c = ax++, o = "" + o + "r" + c.toString(32) + "";
                return s.memoizedState = o;
            },
            useHostTransitionStatus: Tf,
            useFormState: Om,
            useActionState: Om,
            useOptimistic: function(s) {
                var o = Ft();
                o.memoizedState = o.baseState = s;
                var c = {
                    pending: null,
                    lanes: 0,
                    dispatch: null,
                    lastRenderedReducer: null,
                    lastRenderedState: null
                };
                return o.queue = c, o = xf.bind(null, we, !0, c), c.dispatch = o, [
                    s,
                    o
                ];
            },
            useMemoCache: df,
            useCacheRefresh: function() {
                return Ft().memoizedState = fx.bind(null, we);
            }
        }, Jm = {
            readContext: Et,
            use: fl,
            useCallback: Vm,
            useContext: Et,
            useEffect: Um,
            useImperativeHandle: zm,
            useInsertionEffect: Bm,
            useLayoutEffect: Lm,
            useMemo: Hm,
            useReducer: hl,
            useRef: Dm,
            useState: function() {
                return hl(ei);
            },
            useDebugValue: yf,
            useDeferredValue: function(s, o) {
                var c = ct();
                return jm(c, He.memoizedState, s, o);
            },
            useTransition: function() {
                var s = hl(ei)[0], o = ct().memoizedState;
                return [
                    typeof s == "boolean" ? s : Ma(s),
                    o
                ];
            },
            useSyncExternalStore: ym,
            useId: Ym,
            useHostTransitionStatus: Tf,
            useFormState: Im,
            useActionState: Im,
            useOptimistic: function(s, o) {
                var c = ct();
                return Am(c, He, s, o);
            },
            useMemoCache: df,
            useCacheRefresh: qm
        }, dx = {
            readContext: Et,
            use: fl,
            useCallback: Vm,
            useContext: Et,
            useEffect: Um,
            useImperativeHandle: zm,
            useInsertionEffect: Bm,
            useLayoutEffect: Lm,
            useMemo: Hm,
            useReducer: pf,
            useRef: Dm,
            useState: function() {
                return pf(ei);
            },
            useDebugValue: yf,
            useDeferredValue: function(s, o) {
                var c = ct();
                return He === null ? bf(c, s, o) : jm(c, He.memoizedState, s, o);
            },
            useTransition: function() {
                var s = pf(ei)[0], o = ct().memoizedState;
                return [
                    typeof s == "boolean" ? s : Ma(s),
                    o
                ];
            },
            useSyncExternalStore: ym,
            useId: Ym,
            useHostTransitionStatus: Tf,
            useFormState: Pm,
            useActionState: Pm,
            useOptimistic: function(s, o) {
                var c = ct();
                return He !== null ? Am(c, He, s, o) : (c.baseState = s, [
                    s,
                    c.queue.dispatch
                ]);
            },
            useMemoCache: df,
            useCacheRefresh: qm
        }, us = null, Na = 0;
        function _l(s) {
            var o = Na;
            return Na += 1, us === null && (us = []), um(us, s, o);
        }
        function Pa(s, o) {
            o = o.props.ref, s.ref = o !== void 0 ? o : null;
        }
        function yl(s, o) {
            throw o.$$typeof === _ ? Error(i(525)) : (s = Object.prototype.toString.call(o), Error(i(31, s === "[object Object]" ? "object with keys {" + Object.keys(o).join(", ") + "}" : s)));
        }
        function e_(s) {
            var o = s._init;
            return o(s._payload);
        }
        function t_(s) {
            function o(D, C) {
                if (s) {
                    var z = D.deletions;
                    z === null ? (D.deletions = [
                        C
                    ], D.flags |= 16) : z.push(C);
                }
            }
            function c(D, C) {
                if (!s) return null;
                for(; C !== null;)o(D, C), C = C.sibling;
                return null;
            }
            function f(D) {
                for(var C = new Map; D !== null;)D.key !== null ? C.set(D.key, D) : C.set(D.index, D), D = D.sibling;
                return C;
            }
            function g(D, C) {
                return D = Kn(D, C), D.index = 0, D.sibling = null, D;
            }
            function m(D, C, z) {
                return D.index = z, s ? (z = D.alternate, z !== null ? (z = z.index, z < C ? (D.flags |= 67108866, C) : z) : (D.flags |= 67108866, C)) : (D.flags |= 1048576, C);
            }
            function b(D) {
                return s && D.alternate === null && (D.flags |= 67108866), D;
            }
            function T(D, C, z, Y) {
                return C === null || C.tag !== 6 ? (C = Hu(z, D.mode, Y), C.return = D, C) : (C = g(C, z), C.return = D, C);
            }
            function w(D, C, z, Y) {
                var le = z.type;
                return le === S ? X(D, C, z.props.children, Y, z.key) : C !== null && (C.elementType === le || typeof le == "object" && le !== null && le.$$typeof === ae && e_(le) === C.type) ? (C = g(C, z.props), Pa(C, z), C.return = D, C) : (C = el(z.type, z.key, z.props, null, D.mode, Y), Pa(C, z), C.return = D, C);
            }
            function V(D, C, z, Y) {
                return C === null || C.tag !== 4 || C.stateNode.containerInfo !== z.containerInfo || C.stateNode.implementation !== z.implementation ? (C = ju(z, D.mode, Y), C.return = D, C) : (C = g(C, z.children || []), C.return = D, C);
            }
            function X(D, C, z, Y, le) {
                return C === null || C.tag !== 7 ? (C = sr(z, D.mode, Y, le), C.return = D, C) : (C = g(C, z), C.return = D, C);
            }
            function K(D, C, z) {
                if (typeof C == "string" && C !== "" || typeof C == "number" || typeof C == "bigint") return C = Hu("" + C, D.mode, z), C.return = D, C;
                if (typeof C == "object" && C !== null) {
                    switch(C.$$typeof){
                        case y:
                            return z = el(C.type, C.key, C.props, null, D.mode, z), Pa(z, C), z.return = D, z;
                        case v:
                            return C = ju(C, D.mode, z), C.return = D, C;
                        case ae:
                            var Y = C._init;
                            return C = Y(C._payload), K(D, C, z);
                    }
                    if (Ie(C) || ve(C)) return C = sr(C, D.mode, z, null), C.return = D, C;
                    if (typeof C.then == "function") return K(D, _l(C), z);
                    if (C.$$typeof === O) return K(D, rl(D, C), z);
                    yl(D, C);
                }
                return null;
            }
            function j(D, C, z, Y) {
                var le = C !== null ? C.key : null;
                if (typeof z == "string" && z !== "" || typeof z == "number" || typeof z == "bigint") return le !== null ? null : T(D, C, "" + z, Y);
                if (typeof z == "object" && z !== null) {
                    switch(z.$$typeof){
                        case y:
                            return z.key === le ? w(D, C, z, Y) : null;
                        case v:
                            return z.key === le ? V(D, C, z, Y) : null;
                        case ae:
                            return le = z._init, z = le(z._payload), j(D, C, z, Y);
                    }
                    if (Ie(z) || ve(z)) return le !== null ? null : X(D, C, z, Y, null);
                    if (typeof z.then == "function") return j(D, C, _l(z), Y);
                    if (z.$$typeof === O) return j(D, C, rl(D, z), Y);
                    yl(D, z);
                }
                return null;
            }
            function W(D, C, z, Y, le) {
                if (typeof Y == "string" && Y !== "" || typeof Y == "number" || typeof Y == "bigint") return D = D.get(z) || null, T(C, D, "" + Y, le);
                if (typeof Y == "object" && Y !== null) {
                    switch(Y.$$typeof){
                        case y:
                            return D = D.get(Y.key === null ? z : Y.key) || null, w(C, D, Y, le);
                        case v:
                            return D = D.get(Y.key === null ? z : Y.key) || null, V(C, D, Y, le);
                        case ae:
                            var Ee = Y._init;
                            return Y = Ee(Y._payload), W(D, C, z, Y, le);
                    }
                    if (Ie(Y) || ve(Y)) return D = D.get(z) || null, X(C, D, Y, le, null);
                    if (typeof Y.then == "function") return W(D, C, z, _l(Y), le);
                    if (Y.$$typeof === O) return W(D, C, z, rl(C, Y), le);
                    yl(C, Y);
                }
                return null;
            }
            function ye(D, C, z, Y) {
                for(var le = null, Ee = null, he = C, pe = C = 0, vt = null; he !== null && pe < z.length; pe++){
                    he.index > pe ? (vt = he, he = null) : vt = he.sibling;
                    var ke = j(D, he, z[pe], Y);
                    if (ke === null) {
                        he === null && (he = vt);
                        break;
                    }
                    s && he && ke.alternate === null && o(D, he), C = m(ke, C, pe), Ee === null ? le = ke : Ee.sibling = ke, Ee = ke, he = vt;
                }
                if (pe === z.length) return c(D, he), Ue && or(D, pe), le;
                if (he === null) {
                    for(; pe < z.length; pe++)he = K(D, z[pe], Y), he !== null && (C = m(he, C, pe), Ee === null ? le = he : Ee.sibling = he, Ee = he);
                    return Ue && or(D, pe), le;
                }
                for(he = f(he); pe < z.length; pe++)vt = W(he, D, pe, z[pe], Y), vt !== null && (s && vt.alternate !== null && he.delete(vt.key === null ? pe : vt.key), C = m(vt, C, pe), Ee === null ? le = vt : Ee.sibling = vt, Ee = vt);
                return s && he.forEach(function(Li) {
                    return o(D, Li);
                }), Ue && or(D, pe), le;
            }
            function ge(D, C, z, Y) {
                if (z == null) throw Error(i(151));
                for(var le = null, Ee = null, he = C, pe = C = 0, vt = null, ke = z.next(); he !== null && !ke.done; pe++, ke = z.next()){
                    he.index > pe ? (vt = he, he = null) : vt = he.sibling;
                    var Li = j(D, he, ke.value, Y);
                    if (Li === null) {
                        he === null && (he = vt);
                        break;
                    }
                    s && he && Li.alternate === null && o(D, he), C = m(Li, C, pe), Ee === null ? le = Li : Ee.sibling = Li, Ee = Li, he = vt;
                }
                if (ke.done) return c(D, he), Ue && or(D, pe), le;
                if (he === null) {
                    for(; !ke.done; pe++, ke = z.next())ke = K(D, ke.value, Y), ke !== null && (C = m(ke, C, pe), Ee === null ? le = ke : Ee.sibling = ke, Ee = ke);
                    return Ue && or(D, pe), le;
                }
                for(he = f(he); !ke.done; pe++, ke = z.next())ke = W(he, D, pe, ke.value, Y), ke !== null && (s && ke.alternate !== null && he.delete(ke.key === null ? pe : ke.key), C = m(ke, C, pe), Ee === null ? le = ke : Ee.sibling = ke, Ee = ke);
                return s && he.forEach(function(gS) {
                    return o(D, gS);
                }), Ue && or(D, pe), le;
            }
            function We(D, C, z, Y) {
                if (typeof z == "object" && z !== null && z.type === S && z.key === null && (z = z.props.children), typeof z == "object" && z !== null) {
                    switch(z.$$typeof){
                        case y:
                            e: {
                                for(var le = z.key; C !== null;){
                                    if (C.key === le) {
                                        if (le = z.type, le === S) {
                                            if (C.tag === 7) {
                                                c(D, C.sibling), Y = g(C, z.props.children), Y.return = D, D = Y;
                                                break e;
                                            }
                                        } else if (C.elementType === le || typeof le == "object" && le !== null && le.$$typeof === ae && e_(le) === C.type) {
                                            c(D, C.sibling), Y = g(C, z.props), Pa(Y, z), Y.return = D, D = Y;
                                            break e;
                                        }
                                        c(D, C);
                                        break;
                                    } else o(D, C);
                                    C = C.sibling;
                                }
                                z.type === S ? (Y = sr(z.props.children, D.mode, Y, z.key), Y.return = D, D = Y) : (Y = el(z.type, z.key, z.props, null, D.mode, Y), Pa(Y, z), Y.return = D, D = Y);
                            }
                            return b(D);
                        case v:
                            e: {
                                for(le = z.key; C !== null;){
                                    if (C.key === le) if (C.tag === 4 && C.stateNode.containerInfo === z.containerInfo && C.stateNode.implementation === z.implementation) {
                                        c(D, C.sibling), Y = g(C, z.children || []), Y.return = D, D = Y;
                                        break e;
                                    } else {
                                        c(D, C);
                                        break;
                                    }
                                    else o(D, C);
                                    C = C.sibling;
                                }
                                Y = ju(z, D.mode, Y), Y.return = D, D = Y;
                            }
                            return b(D);
                        case ae:
                            return le = z._init, z = le(z._payload), We(D, C, z, Y);
                    }
                    if (Ie(z)) return ye(D, C, z, Y);
                    if (ve(z)) {
                        if (le = ve(z), typeof le != "function") throw Error(i(150));
                        return z = le.call(z), ge(D, C, z, Y);
                    }
                    if (typeof z.then == "function") return We(D, C, _l(z), Y);
                    if (z.$$typeof === O) return We(D, C, rl(D, z), Y);
                    yl(D, z);
                }
                return typeof z == "string" && z !== "" || typeof z == "number" || typeof z == "bigint" ? (z = "" + z, C !== null && C.tag === 6 ? (c(D, C.sibling), Y = g(C, z), Y.return = D, D = Y) : (c(D, C), Y = Hu(z, D.mode, Y), Y.return = D, D = Y), b(D)) : c(D, C);
            }
            return function(D, C, z, Y) {
                try {
                    Na = 0;
                    var le = We(D, C, z, Y);
                    return us = null, le;
                } catch (he) {
                    if (he === Sa || he === al) throw he;
                    var Ee = Kt(29, he, null, D.mode);
                    return Ee.lanes = Y, Ee.return = D, Ee;
                } finally{}
            };
        }
        var fs = t_(!0), n_ = t_(!1), hn = G(null), Nn = null;
        function Si(s) {
            var o = s.alternate;
            re(gt, gt.current & 1), re(hn, s), Nn === null && (o === null || as.current !== null || o.memoizedState !== null) && (Nn = s);
        }
        function i_(s) {
            if (s.tag === 22) {
                if (re(gt, gt.current), re(hn, s), Nn === null) {
                    var o = s.alternate;
                    o !== null && o.memoizedState !== null && (Nn = s);
                }
            } else Ai();
        }
        function Ai() {
            re(gt, gt.current), re(hn, hn.current);
        }
        function ti(s) {
            oe(hn), Nn === s && (Nn = null), oe(gt);
        }
        var gt = G(0);
        function bl(s) {
            for(var o = s; o !== null;){
                if (o.tag === 13) {
                    var c = o.memoizedState;
                    if (c !== null && (c = c.dehydrated, c === null || c.data === "$?" || hh(c))) return o;
                } else if (o.tag === 19 && o.memoizedProps.revealOrder !== void 0) {
                    if ((o.flags & 128) !== 0) return o;
                } else if (o.child !== null) {
                    o.child.return = o, o = o.child;
                    continue;
                }
                if (o === s) break;
                for(; o.sibling === null;){
                    if (o.return === null || o.return === s) return null;
                    o = o.return;
                }
                o.sibling.return = o.return, o = o.sibling;
            }
            return null;
        }
        function Sf(s, o, c, f) {
            o = s.memoizedState, c = c(f, o), c = c == null ? o : p({}, o, c), s.memoizedState = c, s.lanes === 0 && (s.updateQueue.baseState = c);
        }
        var Af = {
            enqueueSetState: function(s, o, c) {
                s = s._reactInternals;
                var f = Jt(), g = vi(f);
                g.payload = o, c != null && (g.callback = c), o = Ti(s, g, f), o !== null && (en(o, s, f), wa(o, s, f));
            },
            enqueueReplaceState: function(s, o, c) {
                s = s._reactInternals;
                var f = Jt(), g = vi(f);
                g.tag = 1, g.payload = o, c != null && (g.callback = c), o = Ti(s, g, f), o !== null && (en(o, s, f), wa(o, s, f));
            },
            enqueueForceUpdate: function(s, o) {
                s = s._reactInternals;
                var c = Jt(), f = vi(c);
                f.tag = 2, o != null && (f.callback = o), o = Ti(s, f, c), o !== null && (en(o, s, c), wa(o, s, c));
            }
        };
        function r_(s, o, c, f, g, m, b) {
            return s = s.stateNode, typeof s.shouldComponentUpdate == "function" ? s.shouldComponentUpdate(f, m, b) : o.prototype && o.prototype.isPureReactComponent ? !pa(c, f) || !pa(g, m) : !0;
        }
        function s_(s, o, c, f) {
            s = o.state, typeof o.componentWillReceiveProps == "function" && o.componentWillReceiveProps(c, f), typeof o.UNSAFE_componentWillReceiveProps == "function" && o.UNSAFE_componentWillReceiveProps(c, f), o.state !== s && Af.enqueueReplaceState(o, o.state, null);
        }
        function gr(s, o) {
            var c = o;
            if ("ref" in o) {
                c = {};
                for(var f in o)f !== "ref" && (c[f] = o[f]);
            }
            if (s = s.defaultProps) {
                c === o && (c = p({}, c));
                for(var g in s)c[g] === void 0 && (c[g] = s[g]);
            }
            return c;
        }
        var vl = typeof reportError == "function" ? reportError : function(s) {
            if (typeof window == "object" && typeof window.ErrorEvent == "function") {
                var o = new window.ErrorEvent("error", {
                    bubbles: !0,
                    cancelable: !0,
                    message: typeof s == "object" && s !== null && typeof s.message == "string" ? String(s.message) : String(s),
                    error: s
                });
                if (!window.dispatchEvent(o)) return;
            } else if (typeof process == "object" && typeof process.emit == "function") {
                process.emit("uncaughtException", s);
                return;
            }
            console.error(s);
        };
        function a_(s) {
            vl(s);
        }
        function o_(s) {
            console.error(s);
        }
        function l_(s) {
            vl(s);
        }
        function Tl(s, o) {
            try {
                var c = s.onUncaughtError;
                c(o.value, {
                    componentStack: o.stack
                });
            } catch (f) {
                setTimeout(function() {
                    throw f;
                });
            }
        }
        function c_(s, o, c) {
            try {
                var f = s.onCaughtError;
                f(c.value, {
                    componentStack: c.stack,
                    errorBoundary: o.tag === 1 ? o.stateNode : null
                });
            } catch (g) {
                setTimeout(function() {
                    throw g;
                });
            }
        }
        function wf(s, o, c) {
            return c = vi(c), c.tag = 3, c.payload = {
                element: null
            }, c.callback = function() {
                Tl(s, o);
            }, c;
        }
        function u_(s) {
            return s = vi(s), s.tag = 3, s;
        }
        function f_(s, o, c, f) {
            var g = c.type.getDerivedStateFromError;
            if (typeof g == "function") {
                var m = f.value;
                s.payload = function() {
                    return g(m);
                }, s.callback = function() {
                    c_(o, c, f);
                };
            }
            var b = c.stateNode;
            b !== null && typeof b.componentDidCatch == "function" && (s.callback = function() {
                c_(o, c, f), typeof g != "function" && (Oi === null ? Oi = new Set([
                    this
                ]) : Oi.add(this));
                var T = f.stack;
                this.componentDidCatch(f.value, {
                    componentStack: T !== null ? T : ""
                });
            });
        }
        function gx(s, o, c, f, g) {
            if (c.flags |= 32768, f !== null && typeof f == "object" && typeof f.then == "function") {
                if (o = c.alternate, o !== null && va(o, c, g, !0), c = hn.current, c !== null) {
                    switch(c.tag){
                        case 13:
                            return Nn === null ? Kf() : c.alternate === null && it === 0 && (it = 3), c.flags &= -257, c.flags |= 65536, c.lanes = g, f === Ju ? c.flags |= 16384 : (o = c.updateQueue, o === null ? c.updateQueue = new Set([
                                f
                            ]) : o.add(f), Qf(s, f, g)), !1;
                        case 22:
                            return c.flags |= 65536, f === Ju ? c.flags |= 16384 : (o = c.updateQueue, o === null ? (o = {
                                transitions: null,
                                markerInstances: null,
                                retryQueue: new Set([
                                    f
                                ])
                            }, c.updateQueue = o) : (c = o.retryQueue, c === null ? o.retryQueue = new Set([
                                f
                            ]) : c.add(f)), Qf(s, f, g)), !1;
                    }
                    throw Error(i(435, c.tag));
                }
                return Qf(s, f, g), Kf(), !1;
            }
            if (Ue) return o = hn.current, o !== null ? ((o.flags & 65536) === 0 && (o.flags |= 256), o.flags |= 65536, o.lanes = g, f !== Xu && (s = Error(i(422), {
                cause: f
            }), ba(ln(s, c)))) : (f !== Xu && (o = Error(i(423), {
                cause: f
            }), ba(ln(o, c))), s = s.current.alternate, s.flags |= 65536, g &= -g, s.lanes |= g, f = ln(f, c), g = wf(s.stateNode, f, g), nf(s, g), it !== 4 && (it = 2)), !1;
            var m = Error(i(520), {
                cause: f
            });
            if (m = ln(m, c), za === null ? za = [
                m
            ] : za.push(m), it !== 4 && (it = 2), o === null) return !0;
            f = ln(f, c), c = o;
            do {
                switch(c.tag){
                    case 3:
                        return c.flags |= 65536, s = g & -g, c.lanes |= s, s = wf(c.stateNode, f, s), nf(c, s), !1;
                    case 1:
                        if (o = c.type, m = c.stateNode, (c.flags & 128) === 0 && (typeof o.getDerivedStateFromError == "function" || m !== null && typeof m.componentDidCatch == "function" && (Oi === null || !Oi.has(m)))) return c.flags |= 65536, g &= -g, c.lanes |= g, g = u_(g), f_(g, s, c, f), nf(c, g), !1;
                }
                c = c.return;
            }while (c !== null);
            return !1;
        }
        var h_ = Error(i(461)), yt = !1;
        function xt(s, o, c, f) {
            o.child = s === null ? n_(o, null, c, f) : fs(o, s.child, c, f);
        }
        function d_(s, o, c, f, g) {
            c = c.render;
            var m = o.ref;
            if ("ref" in f) {
                var b = {};
                for(var T in f)T !== "ref" && (b[T] = f[T]);
            } else b = f;
            return fr(o), f = lf(s, o, c, b, m, g), T = cf(), s !== null && !yt ? (uf(s, o, g), ni(s, o, g)) : (Ue && T && Wu(o), o.flags |= 1, xt(s, o, f, g), o.child);
        }
        function g_(s, o, c, f, g) {
            if (s === null) {
                var m = c.type;
                return typeof m == "function" && !Vu(m) && m.defaultProps === void 0 && c.compare === null ? (o.tag = 15, o.type = m, p_(s, o, m, f, g)) : (s = el(c.type, null, f, o, o.mode, g), s.ref = o.ref, s.return = o, o.child = s);
            }
            if (m = s.child, !Pf(s, g)) {
                var b = m.memoizedProps;
                if (c = c.compare, c = c !== null ? c : pa, c(b, f) && s.ref === o.ref) return ni(s, o, g);
            }
            return o.flags |= 1, s = Kn(m, f), s.ref = o.ref, s.return = o, o.child = s;
        }
        function p_(s, o, c, f, g) {
            if (s !== null) {
                var m = s.memoizedProps;
                if (pa(m, f) && s.ref === o.ref) if (yt = !1, o.pendingProps = f = m, Pf(s, g)) (s.flags & 131072) !== 0 && (yt = !0);
                else return o.lanes = s.lanes, ni(s, o, g);
            }
            return Ef(s, o, c, f, g);
        }
        function m_(s, o, c) {
            var f = o.pendingProps, g = f.children, m = s !== null ? s.memoizedState : null;
            if (f.mode === "hidden") {
                if ((o.flags & 128) !== 0) {
                    if (f = m !== null ? m.baseLanes | c : c, s !== null) {
                        for(g = o.child = s.child, m = 0; g !== null;)m = m | g.lanes | g.childLanes, g = g.sibling;
                        o.childLanes = m & ~f;
                    } else o.childLanes = 0, o.child = null;
                    return __(s, o, f, c);
                }
                if ((c & 536870912) !== 0) o.memoizedState = {
                    baseLanes: 0,
                    cachePool: null
                }, s !== null && sl(o, m !== null ? m.cachePool : null), m !== null ? pm(o, m) : sf(), i_(o);
                else return o.lanes = o.childLanes = 536870912, __(s, o, m !== null ? m.baseLanes | c : c, c);
            } else m !== null ? (sl(o, m.cachePool), pm(o, m), Ai(), o.memoizedState = null) : (s !== null && sl(o, null), sf(), Ai());
            return xt(s, o, g, c), o.child;
        }
        function __(s, o, c, f) {
            var g = Gu();
            return g = g === null ? null : {
                parent: dt._currentValue,
                pool: g
            }, o.memoizedState = {
                baseLanes: c,
                cachePool: g
            }, s !== null && sl(o, null), sf(), i_(o), s !== null && va(s, o, f, !0), null;
        }
        function xl(s, o) {
            var c = o.ref;
            if (c === null) s !== null && s.ref !== null && (o.flags |= 4194816);
            else {
                if (typeof c != "function" && typeof c != "object") throw Error(i(284));
                (s === null || s.ref !== c) && (o.flags |= 4194816);
            }
        }
        function Ef(s, o, c, f, g) {
            return fr(o), c = lf(s, o, c, f, void 0, g), f = cf(), s !== null && !yt ? (uf(s, o, g), ni(s, o, g)) : (Ue && f && Wu(o), o.flags |= 1, xt(s, o, c, g), o.child);
        }
        function y_(s, o, c, f, g, m) {
            return fr(o), o.updateQueue = null, c = _m(o, f, c, g), mm(s), f = cf(), s !== null && !yt ? (uf(s, o, m), ni(s, o, m)) : (Ue && f && Wu(o), o.flags |= 1, xt(s, o, c, m), o.child);
        }
        function b_(s, o, c, f, g) {
            if (fr(o), o.stateNode === null) {
                var m = ts, b = c.contextType;
                typeof b == "object" && b !== null && (m = Et(b)), m = new c(f, m), o.memoizedState = m.state !== null && m.state !== void 0 ? m.state : null, m.updater = Af, o.stateNode = m, m._reactInternals = o, m = o.stateNode, m.props = f, m.state = o.memoizedState, m.refs = {}, ef(o), b = c.contextType, m.context = typeof b == "object" && b !== null ? Et(b) : ts, m.state = o.memoizedState, b = c.getDerivedStateFromProps, typeof b == "function" && (Sf(o, c, b, f), m.state = o.memoizedState), typeof c.getDerivedStateFromProps == "function" || typeof m.getSnapshotBeforeUpdate == "function" || typeof m.UNSAFE_componentWillMount != "function" && typeof m.componentWillMount != "function" || (b = m.state, typeof m.componentWillMount == "function" && m.componentWillMount(), typeof m.UNSAFE_componentWillMount == "function" && m.UNSAFE_componentWillMount(), b !== m.state && Af.enqueueReplaceState(m, m.state, null), Ra(o, f, m, g), Ea(), m.state = o.memoizedState), typeof m.componentDidMount == "function" && (o.flags |= 4194308), f = !0;
            } else if (s === null) {
                m = o.stateNode;
                var T = o.memoizedProps, w = gr(c, T);
                m.props = w;
                var V = m.context, X = c.contextType;
                b = ts, typeof X == "object" && X !== null && (b = Et(X));
                var K = c.getDerivedStateFromProps;
                X = typeof K == "function" || typeof m.getSnapshotBeforeUpdate == "function", T = o.pendingProps !== T, X || typeof m.UNSAFE_componentWillReceiveProps != "function" && typeof m.componentWillReceiveProps != "function" || (T || V !== b) && s_(o, m, f, b), bi = !1;
                var j = o.memoizedState;
                m.state = j, Ra(o, f, m, g), Ea(), V = o.memoizedState, T || j !== V || bi ? (typeof K == "function" && (Sf(o, c, K, f), V = o.memoizedState), (w = bi || r_(o, c, w, f, j, V, b)) ? (X || typeof m.UNSAFE_componentWillMount != "function" && typeof m.componentWillMount != "function" || (typeof m.componentWillMount == "function" && m.componentWillMount(), typeof m.UNSAFE_componentWillMount == "function" && m.UNSAFE_componentWillMount()), typeof m.componentDidMount == "function" && (o.flags |= 4194308)) : (typeof m.componentDidMount == "function" && (o.flags |= 4194308), o.memoizedProps = f, o.memoizedState = V), m.props = f, m.state = V, m.context = b, f = w) : (typeof m.componentDidMount == "function" && (o.flags |= 4194308), f = !1);
            } else {
                m = o.stateNode, tf(s, o), b = o.memoizedProps, X = gr(c, b), m.props = X, K = o.pendingProps, j = m.context, V = c.contextType, w = ts, typeof V == "object" && V !== null && (w = Et(V)), T = c.getDerivedStateFromProps, (V = typeof T == "function" || typeof m.getSnapshotBeforeUpdate == "function") || typeof m.UNSAFE_componentWillReceiveProps != "function" && typeof m.componentWillReceiveProps != "function" || (b !== K || j !== w) && s_(o, m, f, w), bi = !1, j = o.memoizedState, m.state = j, Ra(o, f, m, g), Ea();
                var W = o.memoizedState;
                b !== K || j !== W || bi || s !== null && s.dependencies !== null && il(s.dependencies) ? (typeof T == "function" && (Sf(o, c, T, f), W = o.memoizedState), (X = bi || r_(o, c, X, f, j, W, w) || s !== null && s.dependencies !== null && il(s.dependencies)) ? (V || typeof m.UNSAFE_componentWillUpdate != "function" && typeof m.componentWillUpdate != "function" || (typeof m.componentWillUpdate == "function" && m.componentWillUpdate(f, W, w), typeof m.UNSAFE_componentWillUpdate == "function" && m.UNSAFE_componentWillUpdate(f, W, w)), typeof m.componentDidUpdate == "function" && (o.flags |= 4), typeof m.getSnapshotBeforeUpdate == "function" && (o.flags |= 1024)) : (typeof m.componentDidUpdate != "function" || b === s.memoizedProps && j === s.memoizedState || (o.flags |= 4), typeof m.getSnapshotBeforeUpdate != "function" || b === s.memoizedProps && j === s.memoizedState || (o.flags |= 1024), o.memoizedProps = f, o.memoizedState = W), m.props = f, m.state = W, m.context = w, f = X) : (typeof m.componentDidUpdate != "function" || b === s.memoizedProps && j === s.memoizedState || (o.flags |= 4), typeof m.getSnapshotBeforeUpdate != "function" || b === s.memoizedProps && j === s.memoizedState || (o.flags |= 1024), f = !1);
            }
            return m = f, xl(s, o), f = (o.flags & 128) !== 0, m || f ? (m = o.stateNode, c = f && typeof c.getDerivedStateFromError != "function" ? null : m.render(), o.flags |= 1, s !== null && f ? (o.child = fs(o, s.child, null, g), o.child = fs(o, null, c, g)) : xt(s, o, c, g), o.memoizedState = m.state, s = o.child) : s = ni(s, o, g), s;
        }
        function v_(s, o, c, f) {
            return ya(), o.flags |= 256, xt(s, o, c, f), o.child;
        }
        var Rf = {
            dehydrated: null,
            treeContext: null,
            retryLane: 0,
            hydrationErrors: null
        };
        function Cf(s) {
            return {
                baseLanes: s,
                cachePool: om()
            };
        }
        function Mf(s, o, c) {
            return s = s !== null ? s.childLanes & ~c : 0, o && (s |= dn), s;
        }
        function T_(s, o, c) {
            var f = o.pendingProps, g = !1, m = (o.flags & 128) !== 0, b;
            if ((b = m) || (b = s !== null && s.memoizedState === null ? !1 : (gt.current & 2) !== 0), b && (g = !0, o.flags &= -129), b = (o.flags & 32) !== 0, o.flags &= -33, s === null) {
                if (Ue) {
                    if (g ? Si(o) : Ai(), Ue) {
                        var T = nt, w;
                        if (w = T) {
                            e: {
                                for(w = T, T = In; w.nodeType !== 8;){
                                    if (!T) {
                                        T = null;
                                        break e;
                                    }
                                    if (w = An(w.nextSibling), w === null) {
                                        T = null;
                                        break e;
                                    }
                                }
                                T = w;
                            }
                            T !== null ? (o.memoizedState = {
                                dehydrated: T,
                                treeContext: ar !== null ? {
                                    id: Zn,
                                    overflow: Qn
                                } : null,
                                retryLane: 536870912,
                                hydrationErrors: null
                            }, w = Kt(18, null, null, 0), w.stateNode = T, w.return = o, o.child = w, kt = o, nt = null, w = !0) : w = !1;
                        }
                        w || cr(o);
                    }
                    if (T = o.memoizedState, T !== null && (T = T.dehydrated, T !== null)) return hh(T) ? o.lanes = 32 : o.lanes = 536870912, null;
                    ti(o);
                }
                return T = f.children, f = f.fallback, g ? (Ai(), g = o.mode, T = Sl({
                    mode: "hidden",
                    children: T
                }, g), f = sr(f, g, c, null), T.return = o, f.return = o, T.sibling = f, o.child = T, g = o.child, g.memoizedState = Cf(c), g.childLanes = Mf(s, b, c), o.memoizedState = Rf, f) : (Si(o), Of(o, T));
            }
            if (w = s.memoizedState, w !== null && (T = w.dehydrated, T !== null)) {
                if (m) o.flags & 256 ? (Si(o), o.flags &= -257, o = If(s, o, c)) : o.memoizedState !== null ? (Ai(), o.child = s.child, o.flags |= 128, o = null) : (Ai(), g = f.fallback, T = o.mode, f = Sl({
                    mode: "visible",
                    children: f.children
                }, T), g = sr(g, T, c, null), g.flags |= 2, f.return = o, g.return = o, f.sibling = g, o.child = f, fs(o, s.child, null, c), f = o.child, f.memoizedState = Cf(c), f.childLanes = Mf(s, b, c), o.memoizedState = Rf, o = g);
                else if (Si(o), hh(T)) {
                    if (b = T.nextSibling && T.nextSibling.dataset, b) var V = b.dgst;
                    b = V, f = Error(i(419)), f.stack = "", f.digest = b, ba({
                        value: f,
                        source: null,
                        stack: null
                    }), o = If(s, o, c);
                } else if (yt || va(s, o, c, !1), b = (c & s.childLanes) !== 0, yt || b) {
                    if (b = Qe, b !== null && (f = c & -c, f = (f & 42) !== 0 ? 1 : hu(f), f = (f & (b.suspendedLanes | c)) !== 0 ? 0 : f, f !== 0 && f !== w.retryLane)) throw w.retryLane = f, es(s, f), en(b, s, f), h_;
                    T.data === "$?" || Kf(), o = If(s, o, c);
                } else T.data === "$?" ? (o.flags |= 192, o.child = s.child, o = null) : (s = w.treeContext, nt = An(T.nextSibling), kt = o, Ue = !0, lr = null, In = !1, s !== null && (un[fn++] = Zn, un[fn++] = Qn, un[fn++] = ar, Zn = s.id, Qn = s.overflow, ar = o), o = Of(o, f.children), o.flags |= 4096);
                return o;
            }
            return g ? (Ai(), g = f.fallback, T = o.mode, w = s.child, V = w.sibling, f = Kn(w, {
                mode: "hidden",
                children: f.children
            }), f.subtreeFlags = w.subtreeFlags & 65011712, V !== null ? g = Kn(V, g) : (g = sr(g, T, c, null), g.flags |= 2), g.return = o, f.return = o, f.sibling = g, o.child = f, f = g, g = o.child, T = s.child.memoizedState, T === null ? T = Cf(c) : (w = T.cachePool, w !== null ? (V = dt._currentValue, w = w.parent !== V ? {
                parent: V,
                pool: V
            } : w) : w = om(), T = {
                baseLanes: T.baseLanes | c,
                cachePool: w
            }), g.memoizedState = T, g.childLanes = Mf(s, b, c), o.memoizedState = Rf, f) : (Si(o), c = s.child, s = c.sibling, c = Kn(c, {
                mode: "visible",
                children: f.children
            }), c.return = o, c.sibling = null, s !== null && (b = o.deletions, b === null ? (o.deletions = [
                s
            ], o.flags |= 16) : b.push(s)), o.child = c, o.memoizedState = null, c);
        }
        function Of(s, o) {
            return o = Sl({
                mode: "visible",
                children: o
            }, s.mode), o.return = s, s.child = o;
        }
        function Sl(s, o) {
            return s = Kt(22, s, null, o), s.lanes = 0, s.stateNode = {
                _visibility: 1,
                _pendingMarkers: null,
                _retryCache: null,
                _transitions: null
            }, s;
        }
        function If(s, o, c) {
            return fs(o, s.child, null, c), s = Of(o, o.pendingProps.children), s.flags |= 2, o.memoizedState = null, s;
        }
        function x_(s, o, c) {
            s.lanes |= o;
            var f = s.alternate;
            f !== null && (f.lanes |= o), qu(s.return, o, c);
        }
        function Nf(s, o, c, f, g) {
            var m = s.memoizedState;
            m === null ? s.memoizedState = {
                isBackwards: o,
                rendering: null,
                renderingStartTime: 0,
                last: f,
                tail: c,
                tailMode: g
            } : (m.isBackwards = o, m.rendering = null, m.renderingStartTime = 0, m.last = f, m.tail = c, m.tailMode = g);
        }
        function S_(s, o, c) {
            var f = o.pendingProps, g = f.revealOrder, m = f.tail;
            if (xt(s, o, f.children, c), f = gt.current, (f & 2) !== 0) f = f & 1 | 2, o.flags |= 128;
            else {
                if (s !== null && (s.flags & 128) !== 0) e: for(s = o.child; s !== null;){
                    if (s.tag === 13) s.memoizedState !== null && x_(s, c, o);
                    else if (s.tag === 19) x_(s, c, o);
                    else if (s.child !== null) {
                        s.child.return = s, s = s.child;
                        continue;
                    }
                    if (s === o) break e;
                    for(; s.sibling === null;){
                        if (s.return === null || s.return === o) break e;
                        s = s.return;
                    }
                    s.sibling.return = s.return, s = s.sibling;
                }
                f &= 1;
            }
            switch(re(gt, f), g){
                case "forwards":
                    for(c = o.child, g = null; c !== null;)s = c.alternate, s !== null && bl(s) === null && (g = c), c = c.sibling;
                    c = g, c === null ? (g = o.child, o.child = null) : (g = c.sibling, c.sibling = null), Nf(o, !1, g, c, m);
                    break;
                case "backwards":
                    for(c = null, g = o.child, o.child = null; g !== null;){
                        if (s = g.alternate, s !== null && bl(s) === null) {
                            o.child = g;
                            break;
                        }
                        s = g.sibling, g.sibling = c, c = g, g = s;
                    }
                    Nf(o, !0, c, null, m);
                    break;
                case "together":
                    Nf(o, !1, null, null, void 0);
                    break;
                default:
                    o.memoizedState = null;
            }
            return o.child;
        }
        function ni(s, o, c) {
            if (s !== null && (o.dependencies = s.dependencies), Mi |= o.lanes, (c & o.childLanes) === 0) if (s !== null) {
                if (va(s, o, c, !1), (c & o.childLanes) === 0) return null;
            } else return null;
            if (s !== null && o.child !== s.child) throw Error(i(153));
            if (o.child !== null) {
                for(s = o.child, c = Kn(s, s.pendingProps), o.child = c, c.return = o; s.sibling !== null;)s = s.sibling, c = c.sibling = Kn(s, s.pendingProps), c.return = o;
                c.sibling = null;
            }
            return o.child;
        }
        function Pf(s, o) {
            return (s.lanes & o) !== 0 ? !0 : (s = s.dependencies, !!(s !== null && il(s)));
        }
        function px(s, o, c) {
            switch(o.tag){
                case 3:
                    Ze(o, o.stateNode.containerInfo), yi(o, dt, s.memoizedState.cache), ya();
                    break;
                case 27:
                case 5:
                    Pe(o);
                    break;
                case 4:
                    Ze(o, o.stateNode.containerInfo);
                    break;
                case 10:
                    yi(o, o.type, o.memoizedProps.value);
                    break;
                case 13:
                    var f = o.memoizedState;
                    if (f !== null) return f.dehydrated !== null ? (Si(o), o.flags |= 128, null) : (c & o.child.childLanes) !== 0 ? T_(s, o, c) : (Si(o), s = ni(s, o, c), s !== null ? s.sibling : null);
                    Si(o);
                    break;
                case 19:
                    var g = (s.flags & 128) !== 0;
                    if (f = (c & o.childLanes) !== 0, f || (va(s, o, c, !1), f = (c & o.childLanes) !== 0), g) {
                        if (f) return S_(s, o, c);
                        o.flags |= 128;
                    }
                    if (g = o.memoizedState, g !== null && (g.rendering = null, g.tail = null, g.lastEffect = null), re(gt, gt.current), f) break;
                    return null;
                case 22:
                case 23:
                    return o.lanes = 0, m_(s, o, c);
                case 24:
                    yi(o, dt, s.memoizedState.cache);
            }
            return ni(s, o, c);
        }
        function A_(s, o, c) {
            if (s !== null) if (s.memoizedProps !== o.pendingProps) yt = !0;
            else {
                if (!Pf(s, c) && (o.flags & 128) === 0) return yt = !1, px(s, o, c);
                yt = (s.flags & 131072) !== 0;
            }
            else yt = !1, Ue && (o.flags & 1048576) !== 0 && em(o, nl, o.index);
            switch(o.lanes = 0, o.tag){
                case 16:
                    e: {
                        s = o.pendingProps;
                        var f = o.elementType, g = f._init;
                        if (f = g(f._payload), o.type = f, typeof f == "function") Vu(f) ? (s = gr(f, s), o.tag = 1, o = b_(null, o, f, s, c)) : (o.tag = 0, o = Ef(null, o, f, s, c));
                        else {
                            if (f != null) {
                                if (g = f.$$typeof, g === U) {
                                    o.tag = 11, o = d_(null, o, f, s, c);
                                    break e;
                                } else if (g === se) {
                                    o.tag = 14, o = g_(null, o, f, s, c);
                                    break e;
                                }
                            }
                            throw o = ue(f) || f, Error(i(306, o, ""));
                        }
                    }
                    return o;
                case 0:
                    return Ef(s, o, o.type, o.pendingProps, c);
                case 1:
                    return f = o.type, g = gr(f, o.pendingProps), b_(s, o, f, g, c);
                case 3:
                    e: {
                        if (Ze(o, o.stateNode.containerInfo), s === null) throw Error(i(387));
                        f = o.pendingProps;
                        var m = o.memoizedState;
                        g = m.element, tf(s, o), Ra(o, f, null, c);
                        var b = o.memoizedState;
                        if (f = b.cache, yi(o, dt, f), f !== m.cache && Ku(o, [
                            dt
                        ], c, !0), Ea(), f = b.element, m.isDehydrated) if (m = {
                            element: f,
                            isDehydrated: !1,
                            cache: b.cache
                        }, o.updateQueue.baseState = m, o.memoizedState = m, o.flags & 256) {
                            o = v_(s, o, f, c);
                            break e;
                        } else if (f !== g) {
                            g = ln(Error(i(424)), o), ba(g), o = v_(s, o, f, c);
                            break e;
                        } else {
                            switch(s = o.stateNode.containerInfo, s.nodeType){
                                case 9:
                                    s = s.body;
                                    break;
                                default:
                                    s = s.nodeName === "HTML" ? s.ownerDocument.body : s;
                            }
                            for(nt = An(s.firstChild), kt = o, Ue = !0, lr = null, In = !0, c = n_(o, null, f, c), o.child = c; c;)c.flags = c.flags & -3 | 4096, c = c.sibling;
                        }
                        else {
                            if (ya(), f === g) {
                                o = ni(s, o, c);
                                break e;
                            }
                            xt(s, o, f, c);
                        }
                        o = o.child;
                    }
                    return o;
                case 26:
                    return xl(s, o), s === null ? (c = Cy(o.type, null, o.pendingProps, null)) ? o.memoizedState = c : Ue || (c = o.type, s = o.pendingProps, f = Bl(_e.current).createElement(c), f[wt] = o, f[Bt] = s, At(f, c, s), _t(f), o.stateNode = f) : o.memoizedState = Cy(o.type, s.memoizedProps, o.pendingProps, s.memoizedState), null;
                case 27:
                    return Pe(o), s === null && Ue && (f = o.stateNode = wy(o.type, o.pendingProps, _e.current), kt = o, In = !0, g = nt, Pi(o.type) ? (dh = g, nt = An(f.firstChild)) : nt = g), xt(s, o, o.pendingProps.children, c), xl(s, o), s === null && (o.flags |= 4194304), o.child;
                case 5:
                    return s === null && Ue && ((g = f = nt) && (f = jx(f, o.type, o.pendingProps, In), f !== null ? (o.stateNode = f, kt = o, nt = An(f.firstChild), In = !1, g = !0) : g = !1), g || cr(o)), Pe(o), g = o.type, m = o.pendingProps, b = s !== null ? s.memoizedProps : null, f = m.children, ch(g, m) ? f = null : b !== null && ch(g, b) && (o.flags |= 32), o.memoizedState !== null && (g = lf(s, o, ox, null, null, c), Ka._currentValue = g), xl(s, o), xt(s, o, f, c), o.child;
                case 6:
                    return s === null && Ue && ((s = c = nt) && (c = Wx(c, o.pendingProps, In), c !== null ? (o.stateNode = c, kt = o, nt = null, s = !0) : s = !1), s || cr(o)), null;
                case 13:
                    return T_(s, o, c);
                case 4:
                    return Ze(o, o.stateNode.containerInfo), f = o.pendingProps, s === null ? o.child = fs(o, null, f, c) : xt(s, o, f, c), o.child;
                case 11:
                    return d_(s, o, o.type, o.pendingProps, c);
                case 7:
                    return xt(s, o, o.pendingProps, c), o.child;
                case 8:
                    return xt(s, o, o.pendingProps.children, c), o.child;
                case 12:
                    return xt(s, o, o.pendingProps.children, c), o.child;
                case 10:
                    return f = o.pendingProps, yi(o, o.type, f.value), xt(s, o, f.children, c), o.child;
                case 9:
                    return g = o.type._context, f = o.pendingProps.children, fr(o), g = Et(g), f = f(g), o.flags |= 1, xt(s, o, f, c), o.child;
                case 14:
                    return g_(s, o, o.type, o.pendingProps, c);
                case 15:
                    return p_(s, o, o.type, o.pendingProps, c);
                case 19:
                    return S_(s, o, c);
                case 31:
                    return f = o.pendingProps, c = o.mode, f = {
                        mode: f.mode,
                        children: f.children
                    }, s === null ? (c = Sl(f, c), c.ref = o.ref, o.child = c, c.return = o, o = c) : (c = Kn(s.child, f), c.ref = o.ref, o.child = c, c.return = o, o = c), o;
                case 22:
                    return m_(s, o, c);
                case 24:
                    return fr(o), f = Et(dt), s === null ? (g = Gu(), g === null && (g = Qe, m = Zu(), g.pooledCache = m, m.refCount++, m !== null && (g.pooledCacheLanes |= c), g = m), o.memoizedState = {
                        parent: f,
                        cache: g
                    }, ef(o), yi(o, dt, g)) : ((s.lanes & c) !== 0 && (tf(s, o), Ra(o, null, null, c), Ea()), g = s.memoizedState, m = o.memoizedState, g.parent !== f ? (g = {
                        parent: f,
                        cache: f
                    }, o.memoizedState = g, o.lanes === 0 && (o.memoizedState = o.updateQueue.baseState = g), yi(o, dt, f)) : (f = m.cache, yi(o, dt, f), f !== g.cache && Ku(o, [
                        dt
                    ], c, !0))), xt(s, o, o.pendingProps.children, c), o.child;
                case 29:
                    throw o.pendingProps;
            }
            throw Error(i(156, o.tag));
        }
        function ii(s) {
            s.flags |= 4;
        }
        function w_(s, o) {
            if (o.type !== "stylesheet" || (o.state.loading & 4) !== 0) s.flags &= -16777217;
            else if (s.flags |= 16777216, !Py(o)) {
                if (o = hn.current, o !== null && ((De & 4194048) === De ? Nn !== null : (De & 62914560) !== De && (De & 536870912) === 0 || o !== Nn)) throw Aa = Ju, lm;
                s.flags |= 8192;
            }
        }
        function Al(s, o) {
            o !== null && (s.flags |= 4), s.flags & 16384 && (o = s.tag !== 22 ? ip() : 536870912, s.lanes |= o, ps |= o);
        }
        function Da(s, o) {
            if (!Ue) switch(s.tailMode){
                case "hidden":
                    o = s.tail;
                    for(var c = null; o !== null;)o.alternate !== null && (c = o), o = o.sibling;
                    c === null ? s.tail = null : c.sibling = null;
                    break;
                case "collapsed":
                    c = s.tail;
                    for(var f = null; c !== null;)c.alternate !== null && (f = c), c = c.sibling;
                    f === null ? o || s.tail === null ? s.tail = null : s.tail.sibling = null : f.sibling = null;
            }
        }
        function tt(s) {
            var o = s.alternate !== null && s.alternate.child === s.child, c = 0, f = 0;
            if (o) for(var g = s.child; g !== null;)c |= g.lanes | g.childLanes, f |= g.subtreeFlags & 65011712, f |= g.flags & 65011712, g.return = s, g = g.sibling;
            else for(g = s.child; g !== null;)c |= g.lanes | g.childLanes, f |= g.subtreeFlags, f |= g.flags, g.return = s, g = g.sibling;
            return s.subtreeFlags |= f, s.childLanes = c, o;
        }
        function mx(s, o, c) {
            var f = o.pendingProps;
            switch($u(o), o.tag){
                case 31:
                case 16:
                case 15:
                case 0:
                case 11:
                case 7:
                case 8:
                case 12:
                case 9:
                case 14:
                    return tt(o), null;
                case 1:
                    return tt(o), null;
                case 3:
                    return c = o.stateNode, f = null, s !== null && (f = s.memoizedState.cache), o.memoizedState.cache !== f && (o.flags |= 2048), Jn(dt), Re(), c.pendingContext && (c.context = c.pendingContext, c.pendingContext = null), (s === null || s.child === null) && (_a(o) ? ii(o) : s === null || s.memoizedState.isDehydrated && (o.flags & 256) === 0 || (o.flags |= 1024, im())), tt(o), null;
                case 26:
                    return c = o.memoizedState, s === null ? (ii(o), c !== null ? (tt(o), w_(o, c)) : (tt(o), o.flags &= -16777217)) : c ? c !== s.memoizedState ? (ii(o), tt(o), w_(o, c)) : (tt(o), o.flags &= -16777217) : (s.memoizedProps !== f && ii(o), tt(o), o.flags &= -16777217), null;
                case 27:
                    qe(o), c = _e.current;
                    var g = o.type;
                    if (s !== null && o.stateNode != null) s.memoizedProps !== f && ii(o);
                    else {
                        if (!f) {
                            if (o.stateNode === null) throw Error(i(166));
                            return tt(o), null;
                        }
                        s = de.current, _a(o) ? tm(o) : (s = wy(g, f, c), o.stateNode = s, ii(o));
                    }
                    return tt(o), null;
                case 5:
                    if (qe(o), c = o.type, s !== null && o.stateNode != null) s.memoizedProps !== f && ii(o);
                    else {
                        if (!f) {
                            if (o.stateNode === null) throw Error(i(166));
                            return tt(o), null;
                        }
                        if (s = de.current, _a(o)) tm(o);
                        else {
                            switch(g = Bl(_e.current), s){
                                case 1:
                                    s = g.createElementNS("http://www.w3.org/2000/svg", c);
                                    break;
                                case 2:
                                    s = g.createElementNS("http://www.w3.org/1998/Math/MathML", c);
                                    break;
                                default:
                                    switch(c){
                                        case "svg":
                                            s = g.createElementNS("http://www.w3.org/2000/svg", c);
                                            break;
                                        case "math":
                                            s = g.createElementNS("http://www.w3.org/1998/Math/MathML", c);
                                            break;
                                        case "script":
                                            s = g.createElement("div"), s.innerHTML = "<script><\/script>", s = s.removeChild(s.firstChild);
                                            break;
                                        case "select":
                                            s = typeof f.is == "string" ? g.createElement("select", {
                                                is: f.is
                                            }) : g.createElement("select"), f.multiple ? s.multiple = !0 : f.size && (s.size = f.size);
                                            break;
                                        default:
                                            s = typeof f.is == "string" ? g.createElement(c, {
                                                is: f.is
                                            }) : g.createElement(c);
                                    }
                            }
                            s[wt] = o, s[Bt] = f;
                            e: for(g = o.child; g !== null;){
                                if (g.tag === 5 || g.tag === 6) s.appendChild(g.stateNode);
                                else if (g.tag !== 4 && g.tag !== 27 && g.child !== null) {
                                    g.child.return = g, g = g.child;
                                    continue;
                                }
                                if (g === o) break e;
                                for(; g.sibling === null;){
                                    if (g.return === null || g.return === o) break e;
                                    g = g.return;
                                }
                                g.sibling.return = g.return, g = g.sibling;
                            }
                            o.stateNode = s;
                            e: switch(At(s, c, f), c){
                                case "button":
                                case "input":
                                case "select":
                                case "textarea":
                                    s = !!f.autoFocus;
                                    break e;
                                case "img":
                                    s = !0;
                                    break e;
                                default:
                                    s = !1;
                            }
                            s && ii(o);
                        }
                    }
                    return tt(o), o.flags &= -16777217, null;
                case 6:
                    if (s && o.stateNode != null) s.memoizedProps !== f && ii(o);
                    else {
                        if (typeof f != "string" && o.stateNode === null) throw Error(i(166));
                        if (s = _e.current, _a(o)) {
                            if (s = o.stateNode, c = o.memoizedProps, f = null, g = kt, g !== null) switch(g.tag){
                                case 27:
                                case 5:
                                    f = g.memoizedProps;
                            }
                            s[wt] = o, s = !!(s.nodeValue === c || f !== null && f.suppressHydrationWarning === !0 || yy(s.nodeValue, c)), s || cr(o);
                        } else s = Bl(s).createTextNode(f), s[wt] = o, o.stateNode = s;
                    }
                    return tt(o), null;
                case 13:
                    if (f = o.memoizedState, s === null || s.memoizedState !== null && s.memoizedState.dehydrated !== null) {
                        if (g = _a(o), f !== null && f.dehydrated !== null) {
                            if (s === null) {
                                if (!g) throw Error(i(318));
                                if (g = o.memoizedState, g = g !== null ? g.dehydrated : null, !g) throw Error(i(317));
                                g[wt] = o;
                            } else ya(), (o.flags & 128) === 0 && (o.memoizedState = null), o.flags |= 4;
                            tt(o), g = !1;
                        } else g = im(), s !== null && s.memoizedState !== null && (s.memoizedState.hydrationErrors = g), g = !0;
                        if (!g) return o.flags & 256 ? (ti(o), o) : (ti(o), null);
                    }
                    if (ti(o), (o.flags & 128) !== 0) return o.lanes = c, o;
                    if (c = f !== null, s = s !== null && s.memoizedState !== null, c) {
                        f = o.child, g = null, f.alternate !== null && f.alternate.memoizedState !== null && f.alternate.memoizedState.cachePool !== null && (g = f.alternate.memoizedState.cachePool.pool);
                        var m = null;
                        f.memoizedState !== null && f.memoizedState.cachePool !== null && (m = f.memoizedState.cachePool.pool), m !== g && (f.flags |= 2048);
                    }
                    return c !== s && c && (o.child.flags |= 8192), Al(o, o.updateQueue), tt(o), null;
                case 4:
                    return Re(), s === null && rh(o.stateNode.containerInfo), tt(o), null;
                case 10:
                    return Jn(o.type), tt(o), null;
                case 19:
                    if (oe(gt), g = o.memoizedState, g === null) return tt(o), null;
                    if (f = (o.flags & 128) !== 0, m = g.rendering, m === null) if (f) Da(g, !1);
                    else {
                        if (it !== 0 || s !== null && (s.flags & 128) !== 0) for(s = o.child; s !== null;){
                            if (m = bl(s), m !== null) {
                                for(o.flags |= 128, Da(g, !1), s = m.updateQueue, o.updateQueue = s, Al(o, s), o.subtreeFlags = 0, s = c, c = o.child; c !== null;)Jp(c, s), c = c.sibling;
                                return re(gt, gt.current & 1 | 2), o.child;
                            }
                            s = s.sibling;
                        }
                        g.tail !== null && Dt() > Rl && (o.flags |= 128, f = !0, Da(g, !1), o.lanes = 4194304);
                    }
                    else {
                        if (!f) if (s = bl(m), s !== null) {
                            if (o.flags |= 128, f = !0, s = s.updateQueue, o.updateQueue = s, Al(o, s), Da(g, !0), g.tail === null && g.tailMode === "hidden" && !m.alternate && !Ue) return tt(o), null;
                        } else 2 * Dt() - g.renderingStartTime > Rl && c !== 536870912 && (o.flags |= 128, f = !0, Da(g, !1), o.lanes = 4194304);
                        g.isBackwards ? (m.sibling = o.child, o.child = m) : (s = g.last, s !== null ? s.sibling = m : o.child = m, g.last = m);
                    }
                    return g.tail !== null ? (o = g.tail, g.rendering = o, g.tail = o.sibling, g.renderingStartTime = Dt(), o.sibling = null, s = gt.current, re(gt, f ? s & 1 | 2 : s & 1), o) : (tt(o), null);
                case 22:
                case 23:
                    return ti(o), af(), f = o.memoizedState !== null, s !== null ? s.memoizedState !== null !== f && (o.flags |= 8192) : f && (o.flags |= 8192), f ? (c & 536870912) !== 0 && (o.flags & 128) === 0 && (tt(o), o.subtreeFlags & 6 && (o.flags |= 8192)) : tt(o), c = o.updateQueue, c !== null && Al(o, c.retryQueue), c = null, s !== null && s.memoizedState !== null && s.memoizedState.cachePool !== null && (c = s.memoizedState.cachePool.pool), f = null, o.memoizedState !== null && o.memoizedState.cachePool !== null && (f = o.memoizedState.cachePool.pool), f !== c && (o.flags |= 2048), s !== null && oe(hr), null;
                case 24:
                    return c = null, s !== null && (c = s.memoizedState.cache), o.memoizedState.cache !== c && (o.flags |= 2048), Jn(dt), tt(o), null;
                case 25:
                    return null;
                case 30:
                    return null;
            }
            throw Error(i(156, o.tag));
        }
        function _x(s, o) {
            switch($u(o), o.tag){
                case 1:
                    return s = o.flags, s & 65536 ? (o.flags = s & -65537 | 128, o) : null;
                case 3:
                    return Jn(dt), Re(), s = o.flags, (s & 65536) !== 0 && (s & 128) === 0 ? (o.flags = s & -65537 | 128, o) : null;
                case 26:
                case 27:
                case 5:
                    return qe(o), null;
                case 13:
                    if (ti(o), s = o.memoizedState, s !== null && s.dehydrated !== null) {
                        if (o.alternate === null) throw Error(i(340));
                        ya();
                    }
                    return s = o.flags, s & 65536 ? (o.flags = s & -65537 | 128, o) : null;
                case 19:
                    return oe(gt), null;
                case 4:
                    return Re(), null;
                case 10:
                    return Jn(o.type), null;
                case 22:
                case 23:
                    return ti(o), af(), s !== null && oe(hr), s = o.flags, s & 65536 ? (o.flags = s & -65537 | 128, o) : null;
                case 24:
                    return Jn(dt), null;
                case 25:
                    return null;
                default:
                    return null;
            }
        }
        function E_(s, o) {
            switch($u(o), o.tag){
                case 3:
                    Jn(dt), Re();
                    break;
                case 26:
                case 27:
                case 5:
                    qe(o);
                    break;
                case 4:
                    Re();
                    break;
                case 13:
                    ti(o);
                    break;
                case 19:
                    oe(gt);
                    break;
                case 10:
                    Jn(o.type);
                    break;
                case 22:
                case 23:
                    ti(o), af(), s !== null && oe(hr);
                    break;
                case 24:
                    Jn(dt);
            }
        }
        function ka(s, o) {
            try {
                var c = o.updateQueue, f = c !== null ? c.lastEffect : null;
                if (f !== null) {
                    var g = f.next;
                    c = g;
                    do {
                        if ((c.tag & s) === s) {
                            f = void 0;
                            var m = c.create, b = c.inst;
                            f = m(), b.destroy = f;
                        }
                        c = c.next;
                    }while (c !== g);
                }
            } catch (T) {
                Ke(o, o.return, T);
            }
        }
        function wi(s, o, c) {
            try {
                var f = o.updateQueue, g = f !== null ? f.lastEffect : null;
                if (g !== null) {
                    var m = g.next;
                    f = m;
                    do {
                        if ((f.tag & s) === s) {
                            var b = f.inst, T = b.destroy;
                            if (T !== void 0) {
                                b.destroy = void 0, g = o;
                                var w = c, V = T;
                                try {
                                    V();
                                } catch (X) {
                                    Ke(g, w, X);
                                }
                            }
                        }
                        f = f.next;
                    }while (f !== m);
                }
            } catch (X) {
                Ke(o, o.return, X);
            }
        }
        function R_(s) {
            var o = s.updateQueue;
            if (o !== null) {
                var c = s.stateNode;
                try {
                    gm(o, c);
                } catch (f) {
                    Ke(s, s.return, f);
                }
            }
        }
        function C_(s, o, c) {
            c.props = gr(s.type, s.memoizedProps), c.state = s.memoizedState;
            try {
                c.componentWillUnmount();
            } catch (f) {
                Ke(s, o, f);
            }
        }
        function Ua(s, o) {
            try {
                var c = s.ref;
                if (c !== null) {
                    switch(s.tag){
                        case 26:
                        case 27:
                        case 5:
                            var f = s.stateNode;
                            break;
                        case 30:
                            f = s.stateNode;
                            break;
                        default:
                            f = s.stateNode;
                    }
                    typeof c == "function" ? s.refCleanup = c(f) : c.current = f;
                }
            } catch (g) {
                Ke(s, o, g);
            }
        }
        function Pn(s, o) {
            var c = s.ref, f = s.refCleanup;
            if (c !== null) if (typeof f == "function") try {
                f();
            } catch (g) {
                Ke(s, o, g);
            } finally{
                s.refCleanup = null, s = s.alternate, s != null && (s.refCleanup = null);
            }
            else if (typeof c == "function") try {
                c(null);
            } catch (g) {
                Ke(s, o, g);
            }
            else c.current = null;
        }
        function M_(s) {
            var o = s.type, c = s.memoizedProps, f = s.stateNode;
            try {
                e: switch(o){
                    case "button":
                    case "input":
                    case "select":
                    case "textarea":
                        c.autoFocus && f.focus();
                        break e;
                    case "img":
                        c.src ? f.src = c.src : c.srcSet && (f.srcset = c.srcSet);
                }
            } catch (g) {
                Ke(s, s.return, g);
            }
        }
        function Df(s, o, c) {
            try {
                var f = s.stateNode;
                Lx(f, s.type, c, o), f[Bt] = o;
            } catch (g) {
                Ke(s, s.return, g);
            }
        }
        function O_(s) {
            return s.tag === 5 || s.tag === 3 || s.tag === 26 || s.tag === 27 && Pi(s.type) || s.tag === 4;
        }
        function kf(s) {
            e: for(;;){
                for(; s.sibling === null;){
                    if (s.return === null || O_(s.return)) return null;
                    s = s.return;
                }
                for(s.sibling.return = s.return, s = s.sibling; s.tag !== 5 && s.tag !== 6 && s.tag !== 18;){
                    if (s.tag === 27 && Pi(s.type) || s.flags & 2 || s.child === null || s.tag === 4) continue e;
                    s.child.return = s, s = s.child;
                }
                if (!(s.flags & 2)) return s.stateNode;
            }
        }
        function Uf(s, o, c) {
            var f = s.tag;
            if (f === 5 || f === 6) s = s.stateNode, o ? (c.nodeType === 9 ? c.body : c.nodeName === "HTML" ? c.ownerDocument.body : c).insertBefore(s, o) : (o = c.nodeType === 9 ? c.body : c.nodeName === "HTML" ? c.ownerDocument.body : c, o.appendChild(s), c = c._reactRootContainer, c != null || o.onclick !== null || (o.onclick = Ul));
            else if (f !== 4 && (f === 27 && Pi(s.type) && (c = s.stateNode, o = null), s = s.child, s !== null)) for(Uf(s, o, c), s = s.sibling; s !== null;)Uf(s, o, c), s = s.sibling;
        }
        function wl(s, o, c) {
            var f = s.tag;
            if (f === 5 || f === 6) s = s.stateNode, o ? c.insertBefore(s, o) : c.appendChild(s);
            else if (f !== 4 && (f === 27 && Pi(s.type) && (c = s.stateNode), s = s.child, s !== null)) for(wl(s, o, c), s = s.sibling; s !== null;)wl(s, o, c), s = s.sibling;
        }
        function I_(s) {
            var o = s.stateNode, c = s.memoizedProps;
            try {
                for(var f = s.type, g = o.attributes; g.length;)o.removeAttributeNode(g[0]);
                At(o, f, c), o[wt] = s, o[Bt] = c;
            } catch (m) {
                Ke(s, s.return, m);
            }
        }
        var ri = !1, ot = !1, Bf = !1, N_ = typeof WeakSet == "function" ? WeakSet : Set, bt = null;
        function yx(s, o) {
            if (s = s.containerInfo, oh = jl, s = jp(s), Du(s)) {
                if ("selectionStart" in s) var c = {
                    start: s.selectionStart,
                    end: s.selectionEnd
                };
                else e: {
                    c = (c = s.ownerDocument) && c.defaultView || window;
                    var f = c.getSelection && c.getSelection();
                    if (f && f.rangeCount !== 0) {
                        c = f.anchorNode;
                        var g = f.anchorOffset, m = f.focusNode;
                        f = f.focusOffset;
                        try {
                            c.nodeType, m.nodeType;
                        } catch  {
                            c = null;
                            break e;
                        }
                        var b = 0, T = -1, w = -1, V = 0, X = 0, K = s, j = null;
                        t: for(;;){
                            for(var W; K !== c || g !== 0 && K.nodeType !== 3 || (T = b + g), K !== m || f !== 0 && K.nodeType !== 3 || (w = b + f), K.nodeType === 3 && (b += K.nodeValue.length), (W = K.firstChild) !== null;)j = K, K = W;
                            for(;;){
                                if (K === s) break t;
                                if (j === c && ++V === g && (T = b), j === m && ++X === f && (w = b), (W = K.nextSibling) !== null) break;
                                K = j, j = K.parentNode;
                            }
                            K = W;
                        }
                        c = T === -1 || w === -1 ? null : {
                            start: T,
                            end: w
                        };
                    } else c = null;
                }
                c = c || {
                    start: 0,
                    end: 0
                };
            } else c = null;
            for(lh = {
                focusedElem: s,
                selectionRange: c
            }, jl = !1, bt = o; bt !== null;)if (o = bt, s = o.child, (o.subtreeFlags & 1024) !== 0 && s !== null) s.return = o, bt = s;
            else for(; bt !== null;){
                switch(o = bt, m = o.alternate, s = o.flags, o.tag){
                    case 0:
                        break;
                    case 11:
                    case 15:
                        break;
                    case 1:
                        if ((s & 1024) !== 0 && m !== null) {
                            s = void 0, c = o, g = m.memoizedProps, m = m.memoizedState, f = c.stateNode;
                            try {
                                var ye = gr(c.type, g, c.elementType === c.type);
                                s = f.getSnapshotBeforeUpdate(ye, m), f.__reactInternalSnapshotBeforeUpdate = s;
                            } catch (ge) {
                                Ke(c, c.return, ge);
                            }
                        }
                        break;
                    case 3:
                        if ((s & 1024) !== 0) {
                            if (s = o.stateNode.containerInfo, c = s.nodeType, c === 9) fh(s);
                            else if (c === 1) switch(s.nodeName){
                                case "HEAD":
                                case "HTML":
                                case "BODY":
                                    fh(s);
                                    break;
                                default:
                                    s.textContent = "";
                            }
                        }
                        break;
                    case 5:
                    case 26:
                    case 27:
                    case 6:
                    case 4:
                    case 17:
                        break;
                    default:
                        if ((s & 1024) !== 0) throw Error(i(163));
                }
                if (s = o.sibling, s !== null) {
                    s.return = o.return, bt = s;
                    break;
                }
                bt = o.return;
            }
        }
        function P_(s, o, c) {
            var f = c.flags;
            switch(c.tag){
                case 0:
                case 11:
                case 15:
                    Ei(s, c), f & 4 && ka(5, c);
                    break;
                case 1:
                    if (Ei(s, c), f & 4) if (s = c.stateNode, o === null) try {
                        s.componentDidMount();
                    } catch (b) {
                        Ke(c, c.return, b);
                    }
                    else {
                        var g = gr(c.type, o.memoizedProps);
                        o = o.memoizedState;
                        try {
                            s.componentDidUpdate(g, o, s.__reactInternalSnapshotBeforeUpdate);
                        } catch (b) {
                            Ke(c, c.return, b);
                        }
                    }
                    f & 64 && R_(c), f & 512 && Ua(c, c.return);
                    break;
                case 3:
                    if (Ei(s, c), f & 64 && (s = c.updateQueue, s !== null)) {
                        if (o = null, c.child !== null) switch(c.child.tag){
                            case 27:
                            case 5:
                                o = c.child.stateNode;
                                break;
                            case 1:
                                o = c.child.stateNode;
                        }
                        try {
                            gm(s, o);
                        } catch (b) {
                            Ke(c, c.return, b);
                        }
                    }
                    break;
                case 27:
                    o === null && f & 4 && I_(c);
                case 26:
                case 5:
                    Ei(s, c), o === null && f & 4 && M_(c), f & 512 && Ua(c, c.return);
                    break;
                case 12:
                    Ei(s, c);
                    break;
                case 13:
                    Ei(s, c), f & 4 && U_(s, c), f & 64 && (s = c.memoizedState, s !== null && (s = s.dehydrated, s !== null && (c = Rx.bind(null, c), $x(s, c))));
                    break;
                case 22:
                    if (f = c.memoizedState !== null || ri, !f) {
                        o = o !== null && o.memoizedState !== null || ot, g = ri;
                        var m = ot;
                        ri = f, (ot = o) && !m ? Ri(s, c, (c.subtreeFlags & 8772) !== 0) : Ei(s, c), ri = g, ot = m;
                    }
                    break;
                case 30:
                    break;
                default:
                    Ei(s, c);
            }
        }
        function D_(s) {
            var o = s.alternate;
            o !== null && (s.alternate = null, D_(o)), s.child = null, s.deletions = null, s.sibling = null, s.tag === 5 && (o = s.stateNode, o !== null && pu(o)), s.stateNode = null, s.return = null, s.dependencies = null, s.memoizedProps = null, s.memoizedState = null, s.pendingProps = null, s.stateNode = null, s.updateQueue = null;
        }
        var Je = null, zt = !1;
        function si(s, o, c) {
            for(c = c.child; c !== null;)k_(s, o, c), c = c.sibling;
        }
        function k_(s, o, c) {
            if (Xt && typeof Xt.onCommitFiberUnmount == "function") try {
                Xt.onCommitFiberUnmount(ia, c);
            } catch  {}
            switch(c.tag){
                case 26:
                    ot || Pn(c, o), si(s, o, c), c.memoizedState ? c.memoizedState.count-- : c.stateNode && (c = c.stateNode, c.parentNode.removeChild(c));
                    break;
                case 27:
                    ot || Pn(c, o);
                    var f = Je, g = zt;
                    Pi(c.type) && (Je = c.stateNode, zt = !1), si(s, o, c), $a(c.stateNode), Je = f, zt = g;
                    break;
                case 5:
                    ot || Pn(c, o);
                case 6:
                    if (f = Je, g = zt, Je = null, si(s, o, c), Je = f, zt = g, Je !== null) if (zt) try {
                        (Je.nodeType === 9 ? Je.body : Je.nodeName === "HTML" ? Je.ownerDocument.body : Je).removeChild(c.stateNode);
                    } catch (m) {
                        Ke(c, o, m);
                    }
                    else try {
                        Je.removeChild(c.stateNode);
                    } catch (m) {
                        Ke(c, o, m);
                    }
                    break;
                case 18:
                    Je !== null && (zt ? (s = Je, Sy(s.nodeType === 9 ? s.body : s.nodeName === "HTML" ? s.ownerDocument.body : s, c.stateNode), Ja(s)) : Sy(Je, c.stateNode));
                    break;
                case 4:
                    f = Je, g = zt, Je = c.stateNode.containerInfo, zt = !0, si(s, o, c), Je = f, zt = g;
                    break;
                case 0:
                case 11:
                case 14:
                case 15:
                    ot || wi(2, c, o), ot || wi(4, c, o), si(s, o, c);
                    break;
                case 1:
                    ot || (Pn(c, o), f = c.stateNode, typeof f.componentWillUnmount == "function" && C_(c, o, f)), si(s, o, c);
                    break;
                case 21:
                    si(s, o, c);
                    break;
                case 22:
                    ot = (f = ot) || c.memoizedState !== null, si(s, o, c), ot = f;
                    break;
                default:
                    si(s, o, c);
            }
        }
        function U_(s, o) {
            if (o.memoizedState === null && (s = o.alternate, s !== null && (s = s.memoizedState, s !== null && (s = s.dehydrated, s !== null)))) try {
                Ja(s);
            } catch (c) {
                Ke(o, o.return, c);
            }
        }
        function bx(s) {
            switch(s.tag){
                case 13:
                case 19:
                    var o = s.stateNode;
                    return o === null && (o = s.stateNode = new N_), o;
                case 22:
                    return s = s.stateNode, o = s._retryCache, o === null && (o = s._retryCache = new N_), o;
                default:
                    throw Error(i(435, s.tag));
            }
        }
        function Lf(s, o) {
            var c = bx(s);
            o.forEach(function(f) {
                var g = Cx.bind(null, s, f);
                c.has(f) || (c.add(f), f.then(g, g));
            });
        }
        function Zt(s, o) {
            var c = o.deletions;
            if (c !== null) for(var f = 0; f < c.length; f++){
                var g = c[f], m = s, b = o, T = b;
                e: for(; T !== null;){
                    switch(T.tag){
                        case 27:
                            if (Pi(T.type)) {
                                Je = T.stateNode, zt = !1;
                                break e;
                            }
                            break;
                        case 5:
                            Je = T.stateNode, zt = !1;
                            break e;
                        case 3:
                        case 4:
                            Je = T.stateNode.containerInfo, zt = !0;
                            break e;
                    }
                    T = T.return;
                }
                if (Je === null) throw Error(i(160));
                k_(m, b, g), Je = null, zt = !1, m = g.alternate, m !== null && (m.return = null), g.return = null;
            }
            if (o.subtreeFlags & 13878) for(o = o.child; o !== null;)B_(o, s), o = o.sibling;
        }
        var Sn = null;
        function B_(s, o) {
            var c = s.alternate, f = s.flags;
            switch(s.tag){
                case 0:
                case 11:
                case 14:
                case 15:
                    Zt(o, s), Qt(s), f & 4 && (wi(3, s, s.return), ka(3, s), wi(5, s, s.return));
                    break;
                case 1:
                    Zt(o, s), Qt(s), f & 512 && (ot || c === null || Pn(c, c.return)), f & 64 && ri && (s = s.updateQueue, s !== null && (f = s.callbacks, f !== null && (c = s.shared.hiddenCallbacks, s.shared.hiddenCallbacks = c === null ? f : c.concat(f))));
                    break;
                case 26:
                    var g = Sn;
                    if (Zt(o, s), Qt(s), f & 512 && (ot || c === null || Pn(c, c.return)), f & 4) {
                        var m = c !== null ? c.memoizedState : null;
                        if (f = s.memoizedState, c === null) if (f === null) if (s.stateNode === null) {
                            e: {
                                f = s.type, c = s.memoizedProps, g = g.ownerDocument || g;
                                t: switch(f){
                                    case "title":
                                        m = g.getElementsByTagName("title")[0], (!m || m[aa] || m[wt] || m.namespaceURI === "http://www.w3.org/2000/svg" || m.hasAttribute("itemprop")) && (m = g.createElement(f), g.head.insertBefore(m, g.querySelector("head > title"))), At(m, f, c), m[wt] = s, _t(m), f = m;
                                        break e;
                                    case "link":
                                        var b = Iy("link", "href", g).get(f + (c.href || ""));
                                        if (b) {
                                            for(var T = 0; T < b.length; T++)if (m = b[T], m.getAttribute("href") === (c.href == null || c.href === "" ? null : c.href) && m.getAttribute("rel") === (c.rel == null ? null : c.rel) && m.getAttribute("title") === (c.title == null ? null : c.title) && m.getAttribute("crossorigin") === (c.crossOrigin == null ? null : c.crossOrigin)) {
                                                b.splice(T, 1);
                                                break t;
                                            }
                                        }
                                        m = g.createElement(f), At(m, f, c), g.head.appendChild(m);
                                        break;
                                    case "meta":
                                        if (b = Iy("meta", "content", g).get(f + (c.content || ""))) {
                                            for(T = 0; T < b.length; T++)if (m = b[T], m.getAttribute("content") === (c.content == null ? null : "" + c.content) && m.getAttribute("name") === (c.name == null ? null : c.name) && m.getAttribute("property") === (c.property == null ? null : c.property) && m.getAttribute("http-equiv") === (c.httpEquiv == null ? null : c.httpEquiv) && m.getAttribute("charset") === (c.charSet == null ? null : c.charSet)) {
                                                b.splice(T, 1);
                                                break t;
                                            }
                                        }
                                        m = g.createElement(f), At(m, f, c), g.head.appendChild(m);
                                        break;
                                    default:
                                        throw Error(i(468, f));
                                }
                                m[wt] = s, _t(m), f = m;
                            }
                            s.stateNode = f;
                        } else Ny(g, s.type, s.stateNode);
                        else s.stateNode = Oy(g, f, s.memoizedProps);
                        else m !== f ? (m === null ? c.stateNode !== null && (c = c.stateNode, c.parentNode.removeChild(c)) : m.count--, f === null ? Ny(g, s.type, s.stateNode) : Oy(g, f, s.memoizedProps)) : f === null && s.stateNode !== null && Df(s, s.memoizedProps, c.memoizedProps);
                    }
                    break;
                case 27:
                    Zt(o, s), Qt(s), f & 512 && (ot || c === null || Pn(c, c.return)), c !== null && f & 4 && Df(s, s.memoizedProps, c.memoizedProps);
                    break;
                case 5:
                    if (Zt(o, s), Qt(s), f & 512 && (ot || c === null || Pn(c, c.return)), s.flags & 32) {
                        g = s.stateNode;
                        try {
                            Yr(g, "");
                        } catch (W) {
                            Ke(s, s.return, W);
                        }
                    }
                    f & 4 && s.stateNode != null && (g = s.memoizedProps, Df(s, g, c !== null ? c.memoizedProps : g)), f & 1024 && (Bf = !0);
                    break;
                case 6:
                    if (Zt(o, s), Qt(s), f & 4) {
                        if (s.stateNode === null) throw Error(i(162));
                        f = s.memoizedProps, c = s.stateNode;
                        try {
                            c.nodeValue = f;
                        } catch (W) {
                            Ke(s, s.return, W);
                        }
                    }
                    break;
                case 3:
                    if (zl = null, g = Sn, Sn = Ll(o.containerInfo), Zt(o, s), Sn = g, Qt(s), f & 4 && c !== null && c.memoizedState.isDehydrated) try {
                        Ja(o.containerInfo);
                    } catch (W) {
                        Ke(s, s.return, W);
                    }
                    Bf && (Bf = !1, L_(s));
                    break;
                case 4:
                    f = Sn, Sn = Ll(s.stateNode.containerInfo), Zt(o, s), Qt(s), Sn = f;
                    break;
                case 12:
                    Zt(o, s), Qt(s);
                    break;
                case 13:
                    Zt(o, s), Qt(s), s.child.flags & 8192 && s.memoizedState !== null != (c !== null && c.memoizedState !== null) && (Wf = Dt()), f & 4 && (f = s.updateQueue, f !== null && (s.updateQueue = null, Lf(s, f)));
                    break;
                case 22:
                    g = s.memoizedState !== null;
                    var w = c !== null && c.memoizedState !== null, V = ri, X = ot;
                    if (ri = V || g, ot = X || w, Zt(o, s), ot = X, ri = V, Qt(s), f & 8192) e: for(o = s.stateNode, o._visibility = g ? o._visibility & -2 : o._visibility | 1, g && (c === null || w || ri || ot || pr(s)), c = null, o = s;;){
                        if (o.tag === 5 || o.tag === 26) {
                            if (c === null) {
                                w = c = o;
                                try {
                                    if (m = w.stateNode, g) b = m.style, typeof b.setProperty == "function" ? b.setProperty("display", "none", "important") : b.display = "none";
                                    else {
                                        T = w.stateNode;
                                        var K = w.memoizedProps.style, j = K != null && K.hasOwnProperty("display") ? K.display : null;
                                        T.style.display = j == null || typeof j == "boolean" ? "" : ("" + j).trim();
                                    }
                                } catch (W) {
                                    Ke(w, w.return, W);
                                }
                            }
                        } else if (o.tag === 6) {
                            if (c === null) {
                                w = o;
                                try {
                                    w.stateNode.nodeValue = g ? "" : w.memoizedProps;
                                } catch (W) {
                                    Ke(w, w.return, W);
                                }
                            }
                        } else if ((o.tag !== 22 && o.tag !== 23 || o.memoizedState === null || o === s) && o.child !== null) {
                            o.child.return = o, o = o.child;
                            continue;
                        }
                        if (o === s) break e;
                        for(; o.sibling === null;){
                            if (o.return === null || o.return === s) break e;
                            c === o && (c = null), o = o.return;
                        }
                        c === o && (c = null), o.sibling.return = o.return, o = o.sibling;
                    }
                    f & 4 && (f = s.updateQueue, f !== null && (c = f.retryQueue, c !== null && (f.retryQueue = null, Lf(s, c))));
                    break;
                case 19:
                    Zt(o, s), Qt(s), f & 4 && (f = s.updateQueue, f !== null && (s.updateQueue = null, Lf(s, f)));
                    break;
                case 30:
                    break;
                case 21:
                    break;
                default:
                    Zt(o, s), Qt(s);
            }
        }
        function Qt(s) {
            var o = s.flags;
            if (o & 2) {
                try {
                    for(var c, f = s.return; f !== null;){
                        if (O_(f)) {
                            c = f;
                            break;
                        }
                        f = f.return;
                    }
                    if (c == null) throw Error(i(160));
                    switch(c.tag){
                        case 27:
                            var g = c.stateNode, m = kf(s);
                            wl(s, m, g);
                            break;
                        case 5:
                            var b = c.stateNode;
                            c.flags & 32 && (Yr(b, ""), c.flags &= -33);
                            var T = kf(s);
                            wl(s, T, b);
                            break;
                        case 3:
                        case 4:
                            var w = c.stateNode.containerInfo, V = kf(s);
                            Uf(s, V, w);
                            break;
                        default:
                            throw Error(i(161));
                    }
                } catch (X) {
                    Ke(s, s.return, X);
                }
                s.flags &= -3;
            }
            o & 4096 && (s.flags &= -4097);
        }
        function L_(s) {
            if (s.subtreeFlags & 1024) for(s = s.child; s !== null;){
                var o = s;
                L_(o), o.tag === 5 && o.flags & 1024 && o.stateNode.reset(), s = s.sibling;
            }
        }
        function Ei(s, o) {
            if (o.subtreeFlags & 8772) for(o = o.child; o !== null;)P_(s, o.alternate, o), o = o.sibling;
        }
        function pr(s) {
            for(s = s.child; s !== null;){
                var o = s;
                switch(o.tag){
                    case 0:
                    case 11:
                    case 14:
                    case 15:
                        wi(4, o, o.return), pr(o);
                        break;
                    case 1:
                        Pn(o, o.return);
                        var c = o.stateNode;
                        typeof c.componentWillUnmount == "function" && C_(o, o.return, c), pr(o);
                        break;
                    case 27:
                        $a(o.stateNode);
                    case 26:
                    case 5:
                        Pn(o, o.return), pr(o);
                        break;
                    case 22:
                        o.memoizedState === null && pr(o);
                        break;
                    case 30:
                        pr(o);
                        break;
                    default:
                        pr(o);
                }
                s = s.sibling;
            }
        }
        function Ri(s, o, c) {
            for(c = c && (o.subtreeFlags & 8772) !== 0, o = o.child; o !== null;){
                var f = o.alternate, g = s, m = o, b = m.flags;
                switch(m.tag){
                    case 0:
                    case 11:
                    case 15:
                        Ri(g, m, c), ka(4, m);
                        break;
                    case 1:
                        if (Ri(g, m, c), f = m, g = f.stateNode, typeof g.componentDidMount == "function") try {
                            g.componentDidMount();
                        } catch (V) {
                            Ke(f, f.return, V);
                        }
                        if (f = m, g = f.updateQueue, g !== null) {
                            var T = f.stateNode;
                            try {
                                var w = g.shared.hiddenCallbacks;
                                if (w !== null) for(g.shared.hiddenCallbacks = null, g = 0; g < w.length; g++)dm(w[g], T);
                            } catch (V) {
                                Ke(f, f.return, V);
                            }
                        }
                        c && b & 64 && R_(m), Ua(m, m.return);
                        break;
                    case 27:
                        I_(m);
                    case 26:
                    case 5:
                        Ri(g, m, c), c && f === null && b & 4 && M_(m), Ua(m, m.return);
                        break;
                    case 12:
                        Ri(g, m, c);
                        break;
                    case 13:
                        Ri(g, m, c), c && b & 4 && U_(g, m);
                        break;
                    case 22:
                        m.memoizedState === null && Ri(g, m, c), Ua(m, m.return);
                        break;
                    case 30:
                        break;
                    default:
                        Ri(g, m, c);
                }
                o = o.sibling;
            }
        }
        function Ff(s, o) {
            var c = null;
            s !== null && s.memoizedState !== null && s.memoizedState.cachePool !== null && (c = s.memoizedState.cachePool.pool), s = null, o.memoizedState !== null && o.memoizedState.cachePool !== null && (s = o.memoizedState.cachePool.pool), s !== c && (s != null && s.refCount++, c != null && Ta(c));
        }
        function zf(s, o) {
            s = null, o.alternate !== null && (s = o.alternate.memoizedState.cache), o = o.memoizedState.cache, o !== s && (o.refCount++, s != null && Ta(s));
        }
        function Dn(s, o, c, f) {
            if (o.subtreeFlags & 10256) for(o = o.child; o !== null;)F_(s, o, c, f), o = o.sibling;
        }
        function F_(s, o, c, f) {
            var g = o.flags;
            switch(o.tag){
                case 0:
                case 11:
                case 15:
                    Dn(s, o, c, f), g & 2048 && ka(9, o);
                    break;
                case 1:
                    Dn(s, o, c, f);
                    break;
                case 3:
                    Dn(s, o, c, f), g & 2048 && (s = null, o.alternate !== null && (s = o.alternate.memoizedState.cache), o = o.memoizedState.cache, o !== s && (o.refCount++, s != null && Ta(s)));
                    break;
                case 12:
                    if (g & 2048) {
                        Dn(s, o, c, f), s = o.stateNode;
                        try {
                            var m = o.memoizedProps, b = m.id, T = m.onPostCommit;
                            typeof T == "function" && T(b, o.alternate === null ? "mount" : "update", s.passiveEffectDuration, -0);
                        } catch (w) {
                            Ke(o, o.return, w);
                        }
                    } else Dn(s, o, c, f);
                    break;
                case 13:
                    Dn(s, o, c, f);
                    break;
                case 23:
                    break;
                case 22:
                    m = o.stateNode, b = o.alternate, o.memoizedState !== null ? m._visibility & 2 ? Dn(s, o, c, f) : Ba(s, o) : m._visibility & 2 ? Dn(s, o, c, f) : (m._visibility |= 2, hs(s, o, c, f, (o.subtreeFlags & 10256) !== 0)), g & 2048 && Ff(b, o);
                    break;
                case 24:
                    Dn(s, o, c, f), g & 2048 && zf(o.alternate, o);
                    break;
                default:
                    Dn(s, o, c, f);
            }
        }
        function hs(s, o, c, f, g) {
            for(g = g && (o.subtreeFlags & 10256) !== 0, o = o.child; o !== null;){
                var m = s, b = o, T = c, w = f, V = b.flags;
                switch(b.tag){
                    case 0:
                    case 11:
                    case 15:
                        hs(m, b, T, w, g), ka(8, b);
                        break;
                    case 23:
                        break;
                    case 22:
                        var X = b.stateNode;
                        b.memoizedState !== null ? X._visibility & 2 ? hs(m, b, T, w, g) : Ba(m, b) : (X._visibility |= 2, hs(m, b, T, w, g)), g && V & 2048 && Ff(b.alternate, b);
                        break;
                    case 24:
                        hs(m, b, T, w, g), g && V & 2048 && zf(b.alternate, b);
                        break;
                    default:
                        hs(m, b, T, w, g);
                }
                o = o.sibling;
            }
        }
        function Ba(s, o) {
            if (o.subtreeFlags & 10256) for(o = o.child; o !== null;){
                var c = s, f = o, g = f.flags;
                switch(f.tag){
                    case 22:
                        Ba(c, f), g & 2048 && Ff(f.alternate, f);
                        break;
                    case 24:
                        Ba(c, f), g & 2048 && zf(f.alternate, f);
                        break;
                    default:
                        Ba(c, f);
                }
                o = o.sibling;
            }
        }
        var La = 8192;
        function ds(s) {
            if (s.subtreeFlags & La) for(s = s.child; s !== null;)z_(s), s = s.sibling;
        }
        function z_(s) {
            switch(s.tag){
                case 26:
                    ds(s), s.flags & La && s.memoizedState !== null && rS(Sn, s.memoizedState, s.memoizedProps);
                    break;
                case 5:
                    ds(s);
                    break;
                case 3:
                case 4:
                    var o = Sn;
                    Sn = Ll(s.stateNode.containerInfo), ds(s), Sn = o;
                    break;
                case 22:
                    s.memoizedState === null && (o = s.alternate, o !== null && o.memoizedState !== null ? (o = La, La = 16777216, ds(s), La = o) : ds(s));
                    break;
                default:
                    ds(s);
            }
        }
        function V_(s) {
            var o = s.alternate;
            if (o !== null && (s = o.child, s !== null)) {
                o.child = null;
                do o = s.sibling, s.sibling = null, s = o;
                while (s !== null);
            }
        }
        function Fa(s) {
            var o = s.deletions;
            if ((s.flags & 16) !== 0) {
                if (o !== null) for(var c = 0; c < o.length; c++){
                    var f = o[c];
                    bt = f, j_(f, s);
                }
                V_(s);
            }
            if (s.subtreeFlags & 10256) for(s = s.child; s !== null;)H_(s), s = s.sibling;
        }
        function H_(s) {
            switch(s.tag){
                case 0:
                case 11:
                case 15:
                    Fa(s), s.flags & 2048 && wi(9, s, s.return);
                    break;
                case 3:
                    Fa(s);
                    break;
                case 12:
                    Fa(s);
                    break;
                case 22:
                    var o = s.stateNode;
                    s.memoizedState !== null && o._visibility & 2 && (s.return === null || s.return.tag !== 13) ? (o._visibility &= -3, El(s)) : Fa(s);
                    break;
                default:
                    Fa(s);
            }
        }
        function El(s) {
            var o = s.deletions;
            if ((s.flags & 16) !== 0) {
                if (o !== null) for(var c = 0; c < o.length; c++){
                    var f = o[c];
                    bt = f, j_(f, s);
                }
                V_(s);
            }
            for(s = s.child; s !== null;){
                switch(o = s, o.tag){
                    case 0:
                    case 11:
                    case 15:
                        wi(8, o, o.return), El(o);
                        break;
                    case 22:
                        c = o.stateNode, c._visibility & 2 && (c._visibility &= -3, El(o));
                        break;
                    default:
                        El(o);
                }
                s = s.sibling;
            }
        }
        function j_(s, o) {
            for(; bt !== null;){
                var c = bt;
                switch(c.tag){
                    case 0:
                    case 11:
                    case 15:
                        wi(8, c, o);
                        break;
                    case 23:
                    case 22:
                        if (c.memoizedState !== null && c.memoizedState.cachePool !== null) {
                            var f = c.memoizedState.cachePool.pool;
                            f != null && f.refCount++;
                        }
                        break;
                    case 24:
                        Ta(c.memoizedState.cache);
                }
                if (f = c.child, f !== null) f.return = c, bt = f;
                else e: for(c = s; bt !== null;){
                    f = bt;
                    var g = f.sibling, m = f.return;
                    if (D_(f), f === c) {
                        bt = null;
                        break e;
                    }
                    if (g !== null) {
                        g.return = m, bt = g;
                        break e;
                    }
                    bt = m;
                }
            }
        }
        var vx = {
            getCacheForType: function(s) {
                var o = Et(dt), c = o.data.get(s);
                return c === void 0 && (c = s(), o.data.set(s, c)), c;
            }
        }, Tx = typeof WeakMap == "function" ? WeakMap : Map, ze = 0, Qe = null, Ce = null, De = 0, Ve = 0, Gt = null, Ci = !1, gs = !1, Vf = !1, ai = 0, it = 0, Mi = 0, mr = 0, Hf = 0, dn = 0, ps = 0, za = null, Vt = null, jf = !1, Wf = 0, Rl = 1 / 0, Cl = null, Oi = null, St = 0, Ii = null, ms = null, _s = 0, $f = 0, Xf = null, W_ = null, Va = 0, Yf = null;
        function Jt() {
            if ((ze & 2) !== 0 && De !== 0) return De & -De;
            if ($.T !== null) {
                var s = rs;
                return s !== 0 ? s : eh();
            }
            return ap();
        }
        function $_() {
            dn === 0 && (dn = (De & 536870912) === 0 || Ue ? np() : 536870912);
            var s = hn.current;
            return s !== null && (s.flags |= 32), dn;
        }
        function en(s, o, c) {
            (s === Qe && (Ve === 2 || Ve === 9) || s.cancelPendingCommit !== null) && (ys(s, 0), Ni(s, De, dn, !1)), sa(s, c), ((ze & 2) === 0 || s !== Qe) && (s === Qe && ((ze & 2) === 0 && (mr |= c), it === 4 && Ni(s, De, dn, !1)), kn(s));
        }
        function X_(s, o, c) {
            if ((ze & 6) !== 0) throw Error(i(327));
            var f = !c && (o & 124) === 0 && (o & s.expiredLanes) === 0 || ra(s, o), g = f ? Ax(s, o) : Zf(s, o, !0), m = f;
            do {
                if (g === 0) {
                    gs && !f && Ni(s, o, 0, !1);
                    break;
                } else {
                    if (c = s.current.alternate, m && !xx(c)) {
                        g = Zf(s, o, !1), m = !1;
                        continue;
                    }
                    if (g === 2) {
                        if (m = o, s.errorRecoveryDisabledLanes & m) var b = 0;
                        else b = s.pendingLanes & -536870913, b = b !== 0 ? b : b & 536870912 ? 536870912 : 0;
                        if (b !== 0) {
                            o = b;
                            e: {
                                var T = s;
                                g = za;
                                var w = T.current.memoizedState.isDehydrated;
                                if (w && (ys(T, b).flags |= 256), b = Zf(T, b, !1), b !== 2) {
                                    if (Vf && !w) {
                                        T.errorRecoveryDisabledLanes |= m, mr |= m, g = 4;
                                        break e;
                                    }
                                    m = Vt, Vt = g, m !== null && (Vt === null ? Vt = m : Vt.push.apply(Vt, m));
                                }
                                g = b;
                            }
                            if (m = !1, g !== 2) continue;
                        }
                    }
                    if (g === 1) {
                        ys(s, 0), Ni(s, o, 0, !0);
                        break;
                    }
                    e: {
                        switch(f = s, m = g, m){
                            case 0:
                            case 1:
                                throw Error(i(345));
                            case 4:
                                if ((o & 4194048) !== o) break;
                            case 6:
                                Ni(f, o, dn, !Ci);
                                break e;
                            case 2:
                                Vt = null;
                                break;
                            case 3:
                            case 5:
                                break;
                            default:
                                throw Error(i(329));
                        }
                        if ((o & 62914560) === o && (g = Wf + 300 - Dt(), 10 < g)) {
                            if (Ni(f, o, dn, !Ci), Fo(f, 0, !0) !== 0) break e;
                            f.timeoutHandle = Ty(Y_.bind(null, f, c, Vt, Cl, jf, o, dn, mr, ps, Ci, m, 2, -0, 0), g);
                            break e;
                        }
                        Y_(f, c, Vt, Cl, jf, o, dn, mr, ps, Ci, m, 0, -0, 0);
                    }
                }
                break;
            }while (!0);
            kn(s);
        }
        function Y_(s, o, c, f, g, m, b, T, w, V, X, K, j, W) {
            if (s.timeoutHandle = -1, K = o.subtreeFlags, (K & 8192 || (K & 16785408) === 16785408) && (qa = {
                stylesheets: null,
                count: 0,
                unsuspend: iS
            }, z_(o), K = sS(), K !== null)) {
                s.cancelPendingCommit = K(ey.bind(null, s, o, m, c, f, g, b, T, w, X, 1, j, W)), Ni(s, m, b, !V);
                return;
            }
            ey(s, o, m, c, f, g, b, T, w);
        }
        function xx(s) {
            for(var o = s;;){
                var c = o.tag;
                if ((c === 0 || c === 11 || c === 15) && o.flags & 16384 && (c = o.updateQueue, c !== null && (c = c.stores, c !== null))) for(var f = 0; f < c.length; f++){
                    var g = c[f], m = g.getSnapshot;
                    g = g.value;
                    try {
                        if (!qt(m(), g)) return !1;
                    } catch  {
                        return !1;
                    }
                }
                if (c = o.child, o.subtreeFlags & 16384 && c !== null) c.return = o, o = c;
                else {
                    if (o === s) break;
                    for(; o.sibling === null;){
                        if (o.return === null || o.return === s) return !0;
                        o = o.return;
                    }
                    o.sibling.return = o.return, o = o.sibling;
                }
            }
            return !0;
        }
        function Ni(s, o, c, f) {
            o &= ~Hf, o &= ~mr, s.suspendedLanes |= o, s.pingedLanes &= ~o, f && (s.warmLanes |= o), f = s.expirationTimes;
            for(var g = o; 0 < g;){
                var m = 31 - Yt(g), b = 1 << m;
                f[m] = -1, g &= ~b;
            }
            c !== 0 && rp(s, c, o);
        }
        function Ml() {
            return (ze & 6) === 0 ? (Ha(0), !1) : !0;
        }
        function qf() {
            if (Ce !== null) {
                if (Ve === 0) var s = Ce.return;
                else s = Ce, Gn = ur = null, ff(s), us = null, Na = 0, s = Ce;
                for(; s !== null;)E_(s.alternate, s), s = s.return;
                Ce = null;
            }
        }
        function ys(s, o) {
            var c = s.timeoutHandle;
            c !== -1 && (s.timeoutHandle = -1, zx(c)), c = s.cancelPendingCommit, c !== null && (s.cancelPendingCommit = null, c()), qf(), Qe = s, Ce = c = Kn(s.current, null), De = o, Ve = 0, Gt = null, Ci = !1, gs = ra(s, o), Vf = !1, ps = dn = Hf = mr = Mi = it = 0, Vt = za = null, jf = !1, (o & 8) !== 0 && (o |= o & 32);
            var f = s.entangledLanes;
            if (f !== 0) for(s = s.entanglements, f &= o; 0 < f;){
                var g = 31 - Yt(f), m = 1 << g;
                o |= s[g], f &= ~m;
            }
            return ai = o, Qo(), c;
        }
        function q_(s, o) {
            we = null, $.H = ml, o === Sa || o === al ? (o = fm(), Ve = 3) : o === lm ? (o = fm(), Ve = 4) : Ve = o === h_ ? 8 : o !== null && typeof o == "object" && typeof o.then == "function" ? 6 : 1, Gt = o, Ce === null && (it = 1, Tl(s, ln(o, s.current)));
        }
        function K_() {
            var s = $.H;
            return $.H = ml, s === null ? ml : s;
        }
        function Z_() {
            var s = $.A;
            return $.A = vx, s;
        }
        function Kf() {
            it = 4, Ci || (De & 4194048) !== De && hn.current !== null || (gs = !0), (Mi & 134217727) === 0 && (mr & 134217727) === 0 || Qe === null || Ni(Qe, De, dn, !1);
        }
        function Zf(s, o, c) {
            var f = ze;
            ze |= 2;
            var g = K_(), m = Z_();
            (Qe !== s || De !== o) && (Cl = null, ys(s, o)), o = !1;
            var b = it;
            e: do try {
                if (Ve !== 0 && Ce !== null) {
                    var T = Ce, w = Gt;
                    switch(Ve){
                        case 8:
                            qf(), b = 6;
                            break e;
                        case 3:
                        case 2:
                        case 9:
                        case 6:
                            hn.current === null && (o = !0);
                            var V = Ve;
                            if (Ve = 0, Gt = null, bs(s, T, w, V), c && gs) {
                                b = 0;
                                break e;
                            }
                            break;
                        default:
                            V = Ve, Ve = 0, Gt = null, bs(s, T, w, V);
                    }
                }
                Sx(), b = it;
                break;
            } catch (X) {
                q_(s, X);
            }
            while (!0);
            return o && s.shellSuspendCounter++, Gn = ur = null, ze = f, $.H = g, $.A = m, Ce === null && (Qe = null, De = 0, Qo()), b;
        }
        function Sx() {
            for(; Ce !== null;)Q_(Ce);
        }
        function Ax(s, o) {
            var c = ze;
            ze |= 2;
            var f = K_(), g = Z_();
            Qe !== s || De !== o ? (Cl = null, Rl = Dt() + 500, ys(s, o)) : gs = ra(s, o);
            e: do try {
                if (Ve !== 0 && Ce !== null) {
                    o = Ce;
                    var m = Gt;
                    t: switch(Ve){
                        case 1:
                            Ve = 0, Gt = null, bs(s, o, m, 1);
                            break;
                        case 2:
                        case 9:
                            if (cm(m)) {
                                Ve = 0, Gt = null, G_(o);
                                break;
                            }
                            o = function() {
                                Ve !== 2 && Ve !== 9 || Qe !== s || (Ve = 7), kn(s);
                            }, m.then(o, o);
                            break e;
                        case 3:
                            Ve = 7;
                            break e;
                        case 4:
                            Ve = 5;
                            break e;
                        case 7:
                            cm(m) ? (Ve = 0, Gt = null, G_(o)) : (Ve = 0, Gt = null, bs(s, o, m, 7));
                            break;
                        case 5:
                            var b = null;
                            switch(Ce.tag){
                                case 26:
                                    b = Ce.memoizedState;
                                case 5:
                                case 27:
                                    var T = Ce;
                                    if (!b || Py(b)) {
                                        Ve = 0, Gt = null;
                                        var w = T.sibling;
                                        if (w !== null) Ce = w;
                                        else {
                                            var V = T.return;
                                            V !== null ? (Ce = V, Ol(V)) : Ce = null;
                                        }
                                        break t;
                                    }
                            }
                            Ve = 0, Gt = null, bs(s, o, m, 5);
                            break;
                        case 6:
                            Ve = 0, Gt = null, bs(s, o, m, 6);
                            break;
                        case 8:
                            qf(), it = 6;
                            break e;
                        default:
                            throw Error(i(462));
                    }
                }
                wx();
                break;
            } catch (X) {
                q_(s, X);
            }
            while (!0);
            return Gn = ur = null, $.H = f, $.A = g, ze = c, Ce !== null ? 0 : (Qe = null, De = 0, Qo(), it);
        }
        function wx() {
            for(; Ce !== null && !Lr();)Q_(Ce);
        }
        function Q_(s) {
            var o = A_(s.alternate, s, ai);
            s.memoizedProps = s.pendingProps, o === null ? Ol(s) : Ce = o;
        }
        function G_(s) {
            var o = s, c = o.alternate;
            switch(o.tag){
                case 15:
                case 0:
                    o = y_(c, o, o.pendingProps, o.type, void 0, De);
                    break;
                case 11:
                    o = y_(c, o, o.pendingProps, o.type.render, o.ref, De);
                    break;
                case 5:
                    ff(o);
                default:
                    E_(c, o), o = Ce = Jp(o, ai), o = A_(c, o, ai);
            }
            s.memoizedProps = s.pendingProps, o === null ? Ol(s) : Ce = o;
        }
        function bs(s, o, c, f) {
            Gn = ur = null, ff(o), us = null, Na = 0;
            var g = o.return;
            try {
                if (gx(s, g, o, c, De)) {
                    it = 1, Tl(s, ln(c, s.current)), Ce = null;
                    return;
                }
            } catch (m) {
                if (g !== null) throw Ce = g, m;
                it = 1, Tl(s, ln(c, s.current)), Ce = null;
                return;
            }
            o.flags & 32768 ? (Ue || f === 1 ? s = !0 : gs || (De & 536870912) !== 0 ? s = !1 : (Ci = s = !0, (f === 2 || f === 9 || f === 3 || f === 6) && (f = hn.current, f !== null && f.tag === 13 && (f.flags |= 16384))), J_(o, s)) : Ol(o);
        }
        function Ol(s) {
            var o = s;
            do {
                if ((o.flags & 32768) !== 0) {
                    J_(o, Ci);
                    return;
                }
                s = o.return;
                var c = mx(o.alternate, o, ai);
                if (c !== null) {
                    Ce = c;
                    return;
                }
                if (o = o.sibling, o !== null) {
                    Ce = o;
                    return;
                }
                Ce = o = s;
            }while (o !== null);
            it === 0 && (it = 5);
        }
        function J_(s, o) {
            do {
                var c = _x(s.alternate, s);
                if (c !== null) {
                    c.flags &= 32767, Ce = c;
                    return;
                }
                if (c = s.return, c !== null && (c.flags |= 32768, c.subtreeFlags = 0, c.deletions = null), !o && (s = s.sibling, s !== null)) {
                    Ce = s;
                    return;
                }
                Ce = s = c;
            }while (s !== null);
            it = 6, Ce = null;
        }
        function ey(s, o, c, f, g, m, b, T, w) {
            s.cancelPendingCommit = null;
            do Il();
            while (St !== 0);
            if ((ze & 6) !== 0) throw Error(i(327));
            if (o !== null) {
                if (o === s.current) throw Error(i(177));
                if (m = o.lanes | o.childLanes, m |= Fu, i2(s, c, m, b, T, w), s === Qe && (Ce = Qe = null, De = 0), ms = o, Ii = s, _s = c, $f = m, Xf = g, W_ = f, (o.subtreeFlags & 10256) !== 0 || (o.flags & 10256) !== 0 ? (s.callbackNode = null, s.callbackPriority = 0, Mx(Uo, function() {
                    return sy(), null;
                })) : (s.callbackNode = null, s.callbackPriority = 0), f = (o.flags & 13878) !== 0, (o.subtreeFlags & 13878) !== 0 || f) {
                    f = $.T, $.T = null, g = ee.p, ee.p = 2, b = ze, ze |= 4;
                    try {
                        yx(s, o, c);
                    } finally{
                        ze = b, ee.p = g, $.T = f;
                    }
                }
                St = 1, ty(), ny(), iy();
            }
        }
        function ty() {
            if (St === 1) {
                St = 0;
                var s = Ii, o = ms, c = (o.flags & 13878) !== 0;
                if ((o.subtreeFlags & 13878) !== 0 || c) {
                    c = $.T, $.T = null;
                    var f = ee.p;
                    ee.p = 2;
                    var g = ze;
                    ze |= 4;
                    try {
                        B_(o, s);
                        var m = lh, b = jp(s.containerInfo), T = m.focusedElem, w = m.selectionRange;
                        if (b !== T && T && T.ownerDocument && Hp(T.ownerDocument.documentElement, T)) {
                            if (w !== null && Du(T)) {
                                var V = w.start, X = w.end;
                                if (X === void 0 && (X = V), "selectionStart" in T) T.selectionStart = V, T.selectionEnd = Math.min(X, T.value.length);
                                else {
                                    var K = T.ownerDocument || document, j = K && K.defaultView || window;
                                    if (j.getSelection) {
                                        var W = j.getSelection(), ye = T.textContent.length, ge = Math.min(w.start, ye), We = w.end === void 0 ? ge : Math.min(w.end, ye);
                                        !W.extend && ge > We && (b = We, We = ge, ge = b);
                                        var D = Vp(T, ge), C = Vp(T, We);
                                        if (D && C && (W.rangeCount !== 1 || W.anchorNode !== D.node || W.anchorOffset !== D.offset || W.focusNode !== C.node || W.focusOffset !== C.offset)) {
                                            var z = K.createRange();
                                            z.setStart(D.node, D.offset), W.removeAllRanges(), ge > We ? (W.addRange(z), W.extend(C.node, C.offset)) : (z.setEnd(C.node, C.offset), W.addRange(z));
                                        }
                                    }
                                }
                            }
                            for(K = [], W = T; W = W.parentNode;)W.nodeType === 1 && K.push({
                                element: W,
                                left: W.scrollLeft,
                                top: W.scrollTop
                            });
                            for(typeof T.focus == "function" && T.focus(), T = 0; T < K.length; T++){
                                var Y = K[T];
                                Y.element.scrollLeft = Y.left, Y.element.scrollTop = Y.top;
                            }
                        }
                        jl = !!oh, lh = oh = null;
                    } finally{
                        ze = g, ee.p = f, $.T = c;
                    }
                }
                s.current = o, St = 2;
            }
        }
        function ny() {
            if (St === 2) {
                St = 0;
                var s = Ii, o = ms, c = (o.flags & 8772) !== 0;
                if ((o.subtreeFlags & 8772) !== 0 || c) {
                    c = $.T, $.T = null;
                    var f = ee.p;
                    ee.p = 2;
                    var g = ze;
                    ze |= 4;
                    try {
                        P_(s, o.alternate, o);
                    } finally{
                        ze = g, ee.p = f, $.T = c;
                    }
                }
                St = 3;
            }
        }
        function iy() {
            if (St === 4 || St === 3) {
                St = 0, On();
                var s = Ii, o = ms, c = _s, f = W_;
                (o.subtreeFlags & 10256) !== 0 || (o.flags & 10256) !== 0 ? St = 5 : (St = 0, ms = Ii = null, ry(s, s.pendingLanes));
                var g = s.pendingLanes;
                if (g === 0 && (Oi = null), du(c), o = o.stateNode, Xt && typeof Xt.onCommitFiberRoot == "function") try {
                    Xt.onCommitFiberRoot(ia, o, void 0, (o.current.flags & 128) === 128);
                } catch  {}
                if (f !== null) {
                    o = $.T, g = ee.p, ee.p = 2, $.T = null;
                    try {
                        for(var m = s.onRecoverableError, b = 0; b < f.length; b++){
                            var T = f[b];
                            m(T.value, {
                                componentStack: T.stack
                            });
                        }
                    } finally{
                        $.T = o, ee.p = g;
                    }
                }
                (_s & 3) !== 0 && Il(), kn(s), g = s.pendingLanes, (c & 4194090) !== 0 && (g & 42) !== 0 ? s === Yf ? Va++ : (Va = 0, Yf = s) : Va = 0, Ha(0);
            }
        }
        function ry(s, o) {
            (s.pooledCacheLanes &= o) === 0 && (o = s.pooledCache, o != null && (s.pooledCache = null, Ta(o)));
        }
        function Il(s) {
            return ty(), ny(), iy(), sy();
        }
        function sy() {
            if (St !== 5) return !1;
            var s = Ii, o = $f;
            $f = 0;
            var c = du(_s), f = $.T, g = ee.p;
            try {
                ee.p = 32 > c ? 32 : c, $.T = null, c = Xf, Xf = null;
                var m = Ii, b = _s;
                if (St = 0, ms = Ii = null, _s = 0, (ze & 6) !== 0) throw Error(i(331));
                var T = ze;
                if (ze |= 4, H_(m.current), F_(m, m.current, b, c), ze = T, Ha(0, !1), Xt && typeof Xt.onPostCommitFiberRoot == "function") try {
                    Xt.onPostCommitFiberRoot(ia, m);
                } catch  {}
                return !0;
            } finally{
                ee.p = g, $.T = f, ry(s, o);
            }
        }
        function ay(s, o, c) {
            o = ln(c, o), o = wf(s.stateNode, o, 2), s = Ti(s, o, 2), s !== null && (sa(s, 2), kn(s));
        }
        function Ke(s, o, c) {
            if (s.tag === 3) ay(s, s, c);
            else for(; o !== null;){
                if (o.tag === 3) {
                    ay(o, s, c);
                    break;
                } else if (o.tag === 1) {
                    var f = o.stateNode;
                    if (typeof o.type.getDerivedStateFromError == "function" || typeof f.componentDidCatch == "function" && (Oi === null || !Oi.has(f))) {
                        s = ln(c, s), c = u_(2), f = Ti(o, c, 2), f !== null && (f_(c, f, o, s), sa(f, 2), kn(f));
                        break;
                    }
                }
                o = o.return;
            }
        }
        function Qf(s, o, c) {
            var f = s.pingCache;
            if (f === null) {
                f = s.pingCache = new Tx;
                var g = new Set;
                f.set(o, g);
            } else g = f.get(o), g === void 0 && (g = new Set, f.set(o, g));
            g.has(c) || (Vf = !0, g.add(c), s = Ex.bind(null, s, o, c), o.then(s, s));
        }
        function Ex(s, o, c) {
            var f = s.pingCache;
            f !== null && f.delete(o), s.pingedLanes |= s.suspendedLanes & c, s.warmLanes &= ~c, Qe === s && (De & c) === c && (it === 4 || it === 3 && (De & 62914560) === De && 300 > Dt() - Wf ? (ze & 2) === 0 && ys(s, 0) : Hf |= c, ps === De && (ps = 0)), kn(s);
        }
        function oy(s, o) {
            o === 0 && (o = ip()), s = es(s, o), s !== null && (sa(s, o), kn(s));
        }
        function Rx(s) {
            var o = s.memoizedState, c = 0;
            o !== null && (c = o.retryLane), oy(s, c);
        }
        function Cx(s, o) {
            var c = 0;
            switch(s.tag){
                case 13:
                    var f = s.stateNode, g = s.memoizedState;
                    g !== null && (c = g.retryLane);
                    break;
                case 19:
                    f = s.stateNode;
                    break;
                case 22:
                    f = s.stateNode._retryCache;
                    break;
                default:
                    throw Error(i(314));
            }
            f !== null && f.delete(o), oy(s, c);
        }
        function Mx(s, o) {
            return Mn(s, o);
        }
        var Nl = null, vs = null, Gf = !1, Pl = !1, Jf = !1, _r = 0;
        function kn(s) {
            s !== vs && s.next === null && (vs === null ? Nl = vs = s : vs = vs.next = s), Pl = !0, Gf || (Gf = !0, Ix());
        }
        function Ha(s, o) {
            if (!Jf && Pl) {
                Jf = !0;
                do for(var c = !1, f = Nl; f !== null;){
                    if (s !== 0) {
                        var g = f.pendingLanes;
                        if (g === 0) var m = 0;
                        else {
                            var b = f.suspendedLanes, T = f.pingedLanes;
                            m = (1 << 31 - Yt(42 | s) + 1) - 1, m &= g & ~(b & ~T), m = m & 201326741 ? m & 201326741 | 1 : m ? m | 2 : 0;
                        }
                        m !== 0 && (c = !0, fy(f, m));
                    } else m = De, m = Fo(f, f === Qe ? m : 0, f.cancelPendingCommit !== null || f.timeoutHandle !== -1), (m & 3) === 0 || ra(f, m) || (c = !0, fy(f, m));
                    f = f.next;
                }
                while (c);
                Jf = !1;
            }
        }
        function Ox() {
            ly();
        }
        function ly() {
            Pl = Gf = !1;
            var s = 0;
            _r !== 0 && (Fx() && (s = _r), _r = 0);
            for(var o = Dt(), c = null, f = Nl; f !== null;){
                var g = f.next, m = cy(f, o);
                m === 0 ? (f.next = null, c === null ? Nl = g : c.next = g, g === null && (vs = c)) : (c = f, (s !== 0 || (m & 3) !== 0) && (Pl = !0)), f = g;
            }
            Ha(s);
        }
        function cy(s, o) {
            for(var c = s.suspendedLanes, f = s.pingedLanes, g = s.expirationTimes, m = s.pendingLanes & -62914561; 0 < m;){
                var b = 31 - Yt(m), T = 1 << b, w = g[b];
                w === -1 ? ((T & c) === 0 || (T & f) !== 0) && (g[b] = n2(T, o)) : w <= o && (s.expiredLanes |= T), m &= ~T;
            }
            if (o = Qe, c = De, c = Fo(s, s === o ? c : 0, s.cancelPendingCommit !== null || s.timeoutHandle !== -1), f = s.callbackNode, c === 0 || s === o && (Ve === 2 || Ve === 9) || s.cancelPendingCommit !== null) return f !== null && f !== null && $t(f), s.callbackNode = null, s.callbackPriority = 0;
            if ((c & 3) === 0 || ra(s, c)) {
                if (o = c & -c, o === s.callbackPriority) return o;
                switch(f !== null && $t(f), du(c)){
                    case 2:
                    case 8:
                        c = ep;
                        break;
                    case 32:
                        c = Uo;
                        break;
                    case 268435456:
                        c = tp;
                        break;
                    default:
                        c = Uo;
                }
                return f = uy.bind(null, s), c = Mn(c, f), s.callbackPriority = o, s.callbackNode = c, o;
            }
            return f !== null && f !== null && $t(f), s.callbackPriority = 2, s.callbackNode = null, 2;
        }
        function uy(s, o) {
            if (St !== 0 && St !== 5) return s.callbackNode = null, s.callbackPriority = 0, null;
            var c = s.callbackNode;
            if (Il() && s.callbackNode !== c) return null;
            var f = De;
            return f = Fo(s, s === Qe ? f : 0, s.cancelPendingCommit !== null || s.timeoutHandle !== -1), f === 0 ? null : (X_(s, f, o), cy(s, Dt()), s.callbackNode != null && s.callbackNode === c ? uy.bind(null, s) : null);
        }
        function fy(s, o) {
            if (Il()) return null;
            X_(s, o, !0);
        }
        function Ix() {
            Vx(function() {
                (ze & 6) !== 0 ? Mn(Ji, Ox) : ly();
            });
        }
        function eh() {
            return _r === 0 && (_r = np()), _r;
        }
        function hy(s) {
            return s == null || typeof s == "symbol" || typeof s == "boolean" ? null : typeof s == "function" ? s : Wo("" + s);
        }
        function dy(s, o) {
            var c = o.ownerDocument.createElement("input");
            return c.name = o.name, c.value = o.value, s.id && c.setAttribute("form", s.id), o.parentNode.insertBefore(c, o), s = new FormData(s), c.parentNode.removeChild(c), s;
        }
        function Nx(s, o, c, f, g) {
            if (o === "submit" && c && c.stateNode === g) {
                var m = hy((g[Bt] || null).action), b = f.submitter;
                b && (o = (o = b[Bt] || null) ? hy(o.formAction) : b.getAttribute("formAction"), o !== null && (m = o, b = null));
                var T = new qo("action", "action", null, f, g);
                s.push({
                    event: T,
                    listeners: [
                        {
                            instance: null,
                            listener: function() {
                                if (f.defaultPrevented) {
                                    if (_r !== 0) {
                                        var w = b ? dy(g, b) : new FormData(g);
                                        vf(c, {
                                            pending: !0,
                                            data: w,
                                            method: g.method,
                                            action: m
                                        }, null, w);
                                    }
                                } else typeof m == "function" && (T.preventDefault(), w = b ? dy(g, b) : new FormData(g), vf(c, {
                                    pending: !0,
                                    data: w,
                                    method: g.method,
                                    action: m
                                }, m, w));
                            },
                            currentTarget: g
                        }
                    ]
                });
            }
        }
        for(var th = 0; th < Lu.length; th++){
            var nh = Lu[th], Px = nh.toLowerCase(), Dx = nh[0].toUpperCase() + nh.slice(1);
            xn(Px, "on" + Dx);
        }
        xn(Xp, "onAnimationEnd"), xn(Yp, "onAnimationIteration"), xn(qp, "onAnimationStart"), xn("dblclick", "onDoubleClick"), xn("focusin", "onFocus"), xn("focusout", "onBlur"), xn(Q2, "onTransitionRun"), xn(G2, "onTransitionStart"), xn(J2, "onTransitionCancel"), xn(Kp, "onTransitionEnd"), Wr("onMouseEnter", [
            "mouseout",
            "mouseover"
        ]), Wr("onMouseLeave", [
            "mouseout",
            "mouseover"
        ]), Wr("onPointerEnter", [
            "pointerout",
            "pointerover"
        ]), Wr("onPointerLeave", [
            "pointerout",
            "pointerover"
        ]), tr("onChange", "change click focusin focusout input keydown keyup selectionchange".split(" ")), tr("onSelect", "focusout contextmenu dragend focusin keydown keyup mousedown mouseup selectionchange".split(" ")), tr("onBeforeInput", [
            "compositionend",
            "keypress",
            "textInput",
            "paste"
        ]), tr("onCompositionEnd", "compositionend focusout keydown keypress keyup mousedown".split(" ")), tr("onCompositionStart", "compositionstart focusout keydown keypress keyup mousedown".split(" ")), tr("onCompositionUpdate", "compositionupdate focusout keydown keypress keyup mousedown".split(" "));
        var ja = "abort canplay canplaythrough durationchange emptied encrypted ended error loadeddata loadedmetadata loadstart pause play playing progress ratechange resize seeked seeking stalled suspend timeupdate volumechange waiting".split(" "), kx = new Set("beforetoggle cancel close invalid load scroll scrollend toggle".split(" ").concat(ja));
        function gy(s, o) {
            o = (o & 4) !== 0;
            for(var c = 0; c < s.length; c++){
                var f = s[c], g = f.event;
                f = f.listeners;
                e: {
                    var m = void 0;
                    if (o) for(var b = f.length - 1; 0 <= b; b--){
                        var T = f[b], w = T.instance, V = T.currentTarget;
                        if (T = T.listener, w !== m && g.isPropagationStopped()) break e;
                        m = T, g.currentTarget = V;
                        try {
                            m(g);
                        } catch (X) {
                            vl(X);
                        }
                        g.currentTarget = null, m = w;
                    }
                    else for(b = 0; b < f.length; b++){
                        if (T = f[b], w = T.instance, V = T.currentTarget, T = T.listener, w !== m && g.isPropagationStopped()) break e;
                        m = T, g.currentTarget = V;
                        try {
                            m(g);
                        } catch (X) {
                            vl(X);
                        }
                        g.currentTarget = null, m = w;
                    }
                }
            }
        }
        function Me(s, o) {
            var c = o[gu];
            c === void 0 && (c = o[gu] = new Set);
            var f = s + "__bubble";
            c.has(f) || (py(o, s, 2, !1), c.add(f));
        }
        function ih(s, o, c) {
            var f = 0;
            o && (f |= 4), py(c, s, f, o);
        }
        var Dl = "_reactListening" + Math.random().toString(36).slice(2);
        function rh(s) {
            if (!s[Dl]) {
                s[Dl] = !0, lp.forEach(function(c) {
                    c !== "selectionchange" && (kx.has(c) || ih(c, !1, s), ih(c, !0, s));
                });
                var o = s.nodeType === 9 ? s : s.ownerDocument;
                o === null || o[Dl] || (o[Dl] = !0, ih("selectionchange", !1, o));
            }
        }
        function py(s, o, c, f) {
            switch(Fy(o)){
                case 2:
                    var g = lS;
                    break;
                case 8:
                    g = cS;
                    break;
                default:
                    g = yh;
            }
            c = g.bind(null, o, c, s), g = void 0, !wu || o !== "touchstart" && o !== "touchmove" && o !== "wheel" || (g = !0), f ? g !== void 0 ? s.addEventListener(o, c, {
                capture: !0,
                passive: g
            }) : s.addEventListener(o, c, !0) : g !== void 0 ? s.addEventListener(o, c, {
                passive: g
            }) : s.addEventListener(o, c, !1);
        }
        function sh(s, o, c, f, g) {
            var m = f;
            if ((o & 1) === 0 && (o & 2) === 0 && f !== null) e: for(;;){
                if (f === null) return;
                var b = f.tag;
                if (b === 3 || b === 4) {
                    var T = f.stateNode.containerInfo;
                    if (T === g) break;
                    if (b === 4) for(b = f.return; b !== null;){
                        var w = b.tag;
                        if ((w === 3 || w === 4) && b.stateNode.containerInfo === g) return;
                        b = b.return;
                    }
                    for(; T !== null;){
                        if (b = Vr(T), b === null) return;
                        if (w = b.tag, w === 5 || w === 6 || w === 26 || w === 27) {
                            f = m = b;
                            continue e;
                        }
                        T = T.parentNode;
                    }
                }
                f = f.return;
            }
            xp(function() {
                var V = m, X = Su(c), K = [];
                e: {
                    var j = Zp.get(s);
                    if (j !== void 0) {
                        var W = qo, ye = s;
                        switch(s){
                            case "keypress":
                                if (Xo(c) === 0) break e;
                            case "keydown":
                            case "keyup":
                                W = M2;
                                break;
                            case "focusin":
                                ye = "focus", W = Mu;
                                break;
                            case "focusout":
                                ye = "blur", W = Mu;
                                break;
                            case "beforeblur":
                            case "afterblur":
                                W = Mu;
                                break;
                            case "click":
                                if (c.button === 2) break e;
                            case "auxclick":
                            case "dblclick":
                            case "mousedown":
                            case "mousemove":
                            case "mouseup":
                            case "mouseout":
                            case "mouseover":
                            case "contextmenu":
                                W = wp;
                                break;
                            case "drag":
                            case "dragend":
                            case "dragenter":
                            case "dragexit":
                            case "dragleave":
                            case "dragover":
                            case "dragstart":
                            case "drop":
                                W = _2;
                                break;
                            case "touchcancel":
                            case "touchend":
                            case "touchmove":
                            case "touchstart":
                                W = N2;
                                break;
                            case Xp:
                            case Yp:
                            case qp:
                                W = v2;
                                break;
                            case Kp:
                                W = D2;
                                break;
                            case "scroll":
                            case "scrollend":
                                W = p2;
                                break;
                            case "wheel":
                                W = U2;
                                break;
                            case "copy":
                            case "cut":
                            case "paste":
                                W = x2;
                                break;
                            case "gotpointercapture":
                            case "lostpointercapture":
                            case "pointercancel":
                            case "pointerdown":
                            case "pointermove":
                            case "pointerout":
                            case "pointerover":
                            case "pointerup":
                                W = Rp;
                                break;
                            case "toggle":
                            case "beforetoggle":
                                W = L2;
                        }
                        var ge = (o & 4) !== 0, We = !ge && (s === "scroll" || s === "scrollend"), D = ge ? j !== null ? j + "Capture" : null : j;
                        ge = [];
                        for(var C = V, z; C !== null;){
                            var Y = C;
                            if (z = Y.stateNode, Y = Y.tag, Y !== 5 && Y !== 26 && Y !== 27 || z === null || D === null || (Y = la(C, D), Y != null && ge.push(Wa(C, Y, z))), We) break;
                            C = C.return;
                        }
                        0 < ge.length && (j = new W(j, ye, null, c, X), K.push({
                            event: j,
                            listeners: ge
                        }));
                    }
                }
                if ((o & 7) === 0) {
                    e: {
                        if (j = s === "mouseover" || s === "pointerover", W = s === "mouseout" || s === "pointerout", j && c !== xu && (ye = c.relatedTarget || c.fromElement) && (Vr(ye) || ye[zr])) break e;
                        if ((W || j) && (j = X.window === X ? X : (j = X.ownerDocument) ? j.defaultView || j.parentWindow : window, W ? (ye = c.relatedTarget || c.toElement, W = V, ye = ye ? Vr(ye) : null, ye !== null && (We = a(ye), ge = ye.tag, ye !== We || ge !== 5 && ge !== 27 && ge !== 6) && (ye = null)) : (W = null, ye = V), W !== ye)) {
                            if (ge = wp, Y = "onMouseLeave", D = "onMouseEnter", C = "mouse", (s === "pointerout" || s === "pointerover") && (ge = Rp, Y = "onPointerLeave", D = "onPointerEnter", C = "pointer"), We = W == null ? j : oa(W), z = ye == null ? j : oa(ye), j = new ge(Y, C + "leave", W, c, X), j.target = We, j.relatedTarget = z, Y = null, Vr(X) === V && (ge = new ge(D, C + "enter", ye, c, X), ge.target = z, ge.relatedTarget = We, Y = ge), We = Y, W && ye) t: {
                                for(ge = W, D = ye, C = 0, z = ge; z; z = Ts(z))C++;
                                for(z = 0, Y = D; Y; Y = Ts(Y))z++;
                                for(; 0 < C - z;)ge = Ts(ge), C--;
                                for(; 0 < z - C;)D = Ts(D), z--;
                                for(; C--;){
                                    if (ge === D || D !== null && ge === D.alternate) break t;
                                    ge = Ts(ge), D = Ts(D);
                                }
                                ge = null;
                            }
                            else ge = null;
                            W !== null && my(K, j, W, ge, !1), ye !== null && We !== null && my(K, We, ye, ge, !0);
                        }
                    }
                    e: {
                        if (j = V ? oa(V) : window, W = j.nodeName && j.nodeName.toLowerCase(), W === "select" || W === "input" && j.type === "file") var le = kp;
                        else if (Pp(j)) if (Up) le = q2;
                        else {
                            le = X2;
                            var Ee = $2;
                        }
                        else W = j.nodeName, !W || W.toLowerCase() !== "input" || j.type !== "checkbox" && j.type !== "radio" ? V && Tu(V.elementType) && (le = kp) : le = Y2;
                        if (le && (le = le(s, V))) {
                            Dp(K, le, c, X);
                            break e;
                        }
                        Ee && Ee(s, j, V), s === "focusout" && V && j.type === "number" && V.memoizedProps.value != null && vu(j, "number", j.value);
                    }
                    switch(Ee = V ? oa(V) : window, s){
                        case "focusin":
                            (Pp(Ee) || Ee.contentEditable === "true") && (Qr = Ee, ku = V, ma = null);
                            break;
                        case "focusout":
                            ma = ku = Qr = null;
                            break;
                        case "mousedown":
                            Uu = !0;
                            break;
                        case "contextmenu":
                        case "mouseup":
                        case "dragend":
                            Uu = !1, Wp(K, c, X);
                            break;
                        case "selectionchange":
                            if (Z2) break;
                        case "keydown":
                        case "keyup":
                            Wp(K, c, X);
                    }
                    var he;
                    if (Iu) e: {
                        switch(s){
                            case "compositionstart":
                                var pe = "onCompositionStart";
                                break e;
                            case "compositionend":
                                pe = "onCompositionEnd";
                                break e;
                            case "compositionupdate":
                                pe = "onCompositionUpdate";
                                break e;
                        }
                        pe = void 0;
                    }
                    else Zr ? Ip(s, c) && (pe = "onCompositionEnd") : s === "keydown" && c.keyCode === 229 && (pe = "onCompositionStart");
                    pe && (Cp && c.locale !== "ko" && (Zr || pe !== "onCompositionStart" ? pe === "onCompositionEnd" && Zr && (he = Sp()) : (_i = X, Eu = "value" in _i ? _i.value : _i.textContent, Zr = !0)), Ee = kl(V, pe), 0 < Ee.length && (pe = new Ep(pe, s, null, c, X), K.push({
                        event: pe,
                        listeners: Ee
                    }), he ? pe.data = he : (he = Np(c), he !== null && (pe.data = he)))), (he = z2 ? V2(s, c) : H2(s, c)) && (pe = kl(V, "onBeforeInput"), 0 < pe.length && (Ee = new Ep("onBeforeInput", "beforeinput", null, c, X), K.push({
                        event: Ee,
                        listeners: pe
                    }), Ee.data = he)), Nx(K, s, V, c, X);
                }
                gy(K, o);
            });
        }
        function Wa(s, o, c) {
            return {
                instance: s,
                listener: o,
                currentTarget: c
            };
        }
        function kl(s, o) {
            for(var c = o + "Capture", f = []; s !== null;){
                var g = s, m = g.stateNode;
                if (g = g.tag, g !== 5 && g !== 26 && g !== 27 || m === null || (g = la(s, c), g != null && f.unshift(Wa(s, g, m)), g = la(s, o), g != null && f.push(Wa(s, g, m))), s.tag === 3) return f;
                s = s.return;
            }
            return [];
        }
        function Ts(s) {
            if (s === null) return null;
            do s = s.return;
            while (s && s.tag !== 5 && s.tag !== 27);
            return s || null;
        }
        function my(s, o, c, f, g) {
            for(var m = o._reactName, b = []; c !== null && c !== f;){
                var T = c, w = T.alternate, V = T.stateNode;
                if (T = T.tag, w !== null && w === f) break;
                T !== 5 && T !== 26 && T !== 27 || V === null || (w = V, g ? (V = la(c, m), V != null && b.unshift(Wa(c, V, w))) : g || (V = la(c, m), V != null && b.push(Wa(c, V, w)))), c = c.return;
            }
            b.length !== 0 && s.push({
                event: o,
                listeners: b
            });
        }
        var Ux = /\r\n?/g, Bx = /\u0000|\uFFFD/g;
        function _y(s) {
            return (typeof s == "string" ? s : "" + s).replace(Ux, `
`).replace(Bx, "");
        }
        function yy(s, o) {
            return o = _y(o), _y(s) === o;
        }
        function Ul() {}
        function je(s, o, c, f, g, m) {
            switch(c){
                case "children":
                    typeof f == "string" ? o === "body" || o === "textarea" && f === "" || Yr(s, f) : (typeof f == "number" || typeof f == "bigint") && o !== "body" && Yr(s, "" + f);
                    break;
                case "className":
                    Vo(s, "class", f);
                    break;
                case "tabIndex":
                    Vo(s, "tabindex", f);
                    break;
                case "dir":
                case "role":
                case "viewBox":
                case "width":
                case "height":
                    Vo(s, c, f);
                    break;
                case "style":
                    vp(s, f, m);
                    break;
                case "data":
                    if (o !== "object") {
                        Vo(s, "data", f);
                        break;
                    }
                case "src":
                case "href":
                    if (f === "" && (o !== "a" || c !== "href")) {
                        s.removeAttribute(c);
                        break;
                    }
                    if (f == null || typeof f == "function" || typeof f == "symbol" || typeof f == "boolean") {
                        s.removeAttribute(c);
                        break;
                    }
                    f = Wo("" + f), s.setAttribute(c, f);
                    break;
                case "action":
                case "formAction":
                    if (typeof f == "function") {
                        s.setAttribute(c, "javascript:throw new Error('A React form was unexpectedly submitted. If you called form.submit() manually, consider using form.requestSubmit() instead. If you\\'re trying to use event.stopPropagation() in a submit event handler, consider also calling event.preventDefault().')");
                        break;
                    } else typeof m == "function" && (c === "formAction" ? (o !== "input" && je(s, o, "name", g.name, g, null), je(s, o, "formEncType", g.formEncType, g, null), je(s, o, "formMethod", g.formMethod, g, null), je(s, o, "formTarget", g.formTarget, g, null)) : (je(s, o, "encType", g.encType, g, null), je(s, o, "method", g.method, g, null), je(s, o, "target", g.target, g, null)));
                    if (f == null || typeof f == "symbol" || typeof f == "boolean") {
                        s.removeAttribute(c);
                        break;
                    }
                    f = Wo("" + f), s.setAttribute(c, f);
                    break;
                case "onClick":
                    f != null && (s.onclick = Ul);
                    break;
                case "onScroll":
                    f != null && Me("scroll", s);
                    break;
                case "onScrollEnd":
                    f != null && Me("scrollend", s);
                    break;
                case "dangerouslySetInnerHTML":
                    if (f != null) {
                        if (typeof f != "object" || !("__html" in f)) throw Error(i(61));
                        if (c = f.__html, c != null) {
                            if (g.children != null) throw Error(i(60));
                            s.innerHTML = c;
                        }
                    }
                    break;
                case "multiple":
                    s.multiple = f && typeof f != "function" && typeof f != "symbol";
                    break;
                case "muted":
                    s.muted = f && typeof f != "function" && typeof f != "symbol";
                    break;
                case "suppressContentEditableWarning":
                case "suppressHydrationWarning":
                case "defaultValue":
                case "defaultChecked":
                case "innerHTML":
                case "ref":
                    break;
                case "autoFocus":
                    break;
                case "xlinkHref":
                    if (f == null || typeof f == "function" || typeof f == "boolean" || typeof f == "symbol") {
                        s.removeAttribute("xlink:href");
                        break;
                    }
                    c = Wo("" + f), s.setAttributeNS("http://www.w3.org/1999/xlink", "xlink:href", c);
                    break;
                case "contentEditable":
                case "spellCheck":
                case "draggable":
                case "value":
                case "autoReverse":
                case "externalResourcesRequired":
                case "focusable":
                case "preserveAlpha":
                    f != null && typeof f != "function" && typeof f != "symbol" ? s.setAttribute(c, "" + f) : s.removeAttribute(c);
                    break;
                case "inert":
                case "allowFullScreen":
                case "async":
                case "autoPlay":
                case "controls":
                case "default":
                case "defer":
                case "disabled":
                case "disablePictureInPicture":
                case "disableRemotePlayback":
                case "formNoValidate":
                case "hidden":
                case "loop":
                case "noModule":
                case "noValidate":
                case "open":
                case "playsInline":
                case "readOnly":
                case "required":
                case "reversed":
                case "scoped":
                case "seamless":
                case "itemScope":
                    f && typeof f != "function" && typeof f != "symbol" ? s.setAttribute(c, "") : s.removeAttribute(c);
                    break;
                case "capture":
                case "download":
                    f === !0 ? s.setAttribute(c, "") : f !== !1 && f != null && typeof f != "function" && typeof f != "symbol" ? s.setAttribute(c, f) : s.removeAttribute(c);
                    break;
                case "cols":
                case "rows":
                case "size":
                case "span":
                    f != null && typeof f != "function" && typeof f != "symbol" && !isNaN(f) && 1 <= f ? s.setAttribute(c, f) : s.removeAttribute(c);
                    break;
                case "rowSpan":
                case "start":
                    f == null || typeof f == "function" || typeof f == "symbol" || isNaN(f) ? s.removeAttribute(c) : s.setAttribute(c, f);
                    break;
                case "popover":
                    Me("beforetoggle", s), Me("toggle", s), zo(s, "popover", f);
                    break;
                case "xlinkActuate":
                    Yn(s, "http://www.w3.org/1999/xlink", "xlink:actuate", f);
                    break;
                case "xlinkArcrole":
                    Yn(s, "http://www.w3.org/1999/xlink", "xlink:arcrole", f);
                    break;
                case "xlinkRole":
                    Yn(s, "http://www.w3.org/1999/xlink", "xlink:role", f);
                    break;
                case "xlinkShow":
                    Yn(s, "http://www.w3.org/1999/xlink", "xlink:show", f);
                    break;
                case "xlinkTitle":
                    Yn(s, "http://www.w3.org/1999/xlink", "xlink:title", f);
                    break;
                case "xlinkType":
                    Yn(s, "http://www.w3.org/1999/xlink", "xlink:type", f);
                    break;
                case "xmlBase":
                    Yn(s, "http://www.w3.org/XML/1998/namespace", "xml:base", f);
                    break;
                case "xmlLang":
                    Yn(s, "http://www.w3.org/XML/1998/namespace", "xml:lang", f);
                    break;
                case "xmlSpace":
                    Yn(s, "http://www.w3.org/XML/1998/namespace", "xml:space", f);
                    break;
                case "is":
                    zo(s, "is", f);
                    break;
                case "innerText":
                case "textContent":
                    break;
                default:
                    (!(2 < c.length) || c[0] !== "o" && c[0] !== "O" || c[1] !== "n" && c[1] !== "N") && (c = d2.get(c) || c, zo(s, c, f));
            }
        }
        function ah(s, o, c, f, g, m) {
            switch(c){
                case "style":
                    vp(s, f, m);
                    break;
                case "dangerouslySetInnerHTML":
                    if (f != null) {
                        if (typeof f != "object" || !("__html" in f)) throw Error(i(61));
                        if (c = f.__html, c != null) {
                            if (g.children != null) throw Error(i(60));
                            s.innerHTML = c;
                        }
                    }
                    break;
                case "children":
                    typeof f == "string" ? Yr(s, f) : (typeof f == "number" || typeof f == "bigint") && Yr(s, "" + f);
                    break;
                case "onScroll":
                    f != null && Me("scroll", s);
                    break;
                case "onScrollEnd":
                    f != null && Me("scrollend", s);
                    break;
                case "onClick":
                    f != null && (s.onclick = Ul);
                    break;
                case "suppressContentEditableWarning":
                case "suppressHydrationWarning":
                case "innerHTML":
                case "ref":
                    break;
                case "innerText":
                case "textContent":
                    break;
                default:
                    if (!cp.hasOwnProperty(c)) e: {
                        if (c[0] === "o" && c[1] === "n" && (g = c.endsWith("Capture"), o = c.slice(2, g ? c.length - 7 : void 0), m = s[Bt] || null, m = m != null ? m[c] : null, typeof m == "function" && s.removeEventListener(o, m, g), typeof f == "function")) {
                            typeof m != "function" && m !== null && (c in s ? s[c] = null : s.hasAttribute(c) && s.removeAttribute(c)), s.addEventListener(o, f, g);
                            break e;
                        }
                        c in s ? s[c] = f : f === !0 ? s.setAttribute(c, "") : zo(s, c, f);
                    }
            }
        }
        function At(s, o, c) {
            switch(o){
                case "div":
                case "span":
                case "svg":
                case "path":
                case "a":
                case "g":
                case "p":
                case "li":
                    break;
                case "img":
                    Me("error", s), Me("load", s);
                    var f = !1, g = !1, m;
                    for(m in c)if (c.hasOwnProperty(m)) {
                        var b = c[m];
                        if (b != null) switch(m){
                            case "src":
                                f = !0;
                                break;
                            case "srcSet":
                                g = !0;
                                break;
                            case "children":
                            case "dangerouslySetInnerHTML":
                                throw Error(i(137, o));
                            default:
                                je(s, o, m, b, c, null);
                        }
                    }
                    g && je(s, o, "srcSet", c.srcSet, c, null), f && je(s, o, "src", c.src, c, null);
                    return;
                case "input":
                    Me("invalid", s);
                    var T = m = b = g = null, w = null, V = null;
                    for(f in c)if (c.hasOwnProperty(f)) {
                        var X = c[f];
                        if (X != null) switch(f){
                            case "name":
                                g = X;
                                break;
                            case "type":
                                b = X;
                                break;
                            case "checked":
                                w = X;
                                break;
                            case "defaultChecked":
                                V = X;
                                break;
                            case "value":
                                m = X;
                                break;
                            case "defaultValue":
                                T = X;
                                break;
                            case "children":
                            case "dangerouslySetInnerHTML":
                                if (X != null) throw Error(i(137, o));
                                break;
                            default:
                                je(s, o, f, X, c, null);
                        }
                    }
                    mp(s, m, T, w, V, b, g, !1), Ho(s);
                    return;
                case "select":
                    Me("invalid", s), f = b = m = null;
                    for(g in c)if (c.hasOwnProperty(g) && (T = c[g], T != null)) switch(g){
                        case "value":
                            m = T;
                            break;
                        case "defaultValue":
                            b = T;
                            break;
                        case "multiple":
                            f = T;
                        default:
                            je(s, o, g, T, c, null);
                    }
                    o = m, c = b, s.multiple = !!f, o != null ? Xr(s, !!f, o, !1) : c != null && Xr(s, !!f, c, !0);
                    return;
                case "textarea":
                    Me("invalid", s), m = g = f = null;
                    for(b in c)if (c.hasOwnProperty(b) && (T = c[b], T != null)) switch(b){
                        case "value":
                            f = T;
                            break;
                        case "defaultValue":
                            g = T;
                            break;
                        case "children":
                            m = T;
                            break;
                        case "dangerouslySetInnerHTML":
                            if (T != null) throw Error(i(91));
                            break;
                        default:
                            je(s, o, b, T, c, null);
                    }
                    yp(s, f, g, m), Ho(s);
                    return;
                case "option":
                    for(w in c)if (c.hasOwnProperty(w) && (f = c[w], f != null)) switch(w){
                        case "selected":
                            s.selected = f && typeof f != "function" && typeof f != "symbol";
                            break;
                        default:
                            je(s, o, w, f, c, null);
                    }
                    return;
                case "dialog":
                    Me("beforetoggle", s), Me("toggle", s), Me("cancel", s), Me("close", s);
                    break;
                case "iframe":
                case "object":
                    Me("load", s);
                    break;
                case "video":
                case "audio":
                    for(f = 0; f < ja.length; f++)Me(ja[f], s);
                    break;
                case "image":
                    Me("error", s), Me("load", s);
                    break;
                case "details":
                    Me("toggle", s);
                    break;
                case "embed":
                case "source":
                case "link":
                    Me("error", s), Me("load", s);
                case "area":
                case "base":
                case "br":
                case "col":
                case "hr":
                case "keygen":
                case "meta":
                case "param":
                case "track":
                case "wbr":
                case "menuitem":
                    for(V in c)if (c.hasOwnProperty(V) && (f = c[V], f != null)) switch(V){
                        case "children":
                        case "dangerouslySetInnerHTML":
                            throw Error(i(137, o));
                        default:
                            je(s, o, V, f, c, null);
                    }
                    return;
                default:
                    if (Tu(o)) {
                        for(X in c)c.hasOwnProperty(X) && (f = c[X], f !== void 0 && ah(s, o, X, f, c, void 0));
                        return;
                    }
            }
            for(T in c)c.hasOwnProperty(T) && (f = c[T], f != null && je(s, o, T, f, c, null));
        }
        function Lx(s, o, c, f) {
            switch(o){
                case "div":
                case "span":
                case "svg":
                case "path":
                case "a":
                case "g":
                case "p":
                case "li":
                    break;
                case "input":
                    var g = null, m = null, b = null, T = null, w = null, V = null, X = null;
                    for(W in c){
                        var K = c[W];
                        if (c.hasOwnProperty(W) && K != null) switch(W){
                            case "checked":
                                break;
                            case "value":
                                break;
                            case "defaultValue":
                                w = K;
                            default:
                                f.hasOwnProperty(W) || je(s, o, W, null, f, K);
                        }
                    }
                    for(var j in f){
                        var W = f[j];
                        if (K = c[j], f.hasOwnProperty(j) && (W != null || K != null)) switch(j){
                            case "type":
                                m = W;
                                break;
                            case "name":
                                g = W;
                                break;
                            case "checked":
                                V = W;
                                break;
                            case "defaultChecked":
                                X = W;
                                break;
                            case "value":
                                b = W;
                                break;
                            case "defaultValue":
                                T = W;
                                break;
                            case "children":
                            case "dangerouslySetInnerHTML":
                                if (W != null) throw Error(i(137, o));
                                break;
                            default:
                                W !== K && je(s, o, j, W, f, K);
                        }
                    }
                    bu(s, b, T, w, V, X, m, g);
                    return;
                case "select":
                    W = b = T = j = null;
                    for(m in c)if (w = c[m], c.hasOwnProperty(m) && w != null) switch(m){
                        case "value":
                            break;
                        case "multiple":
                            W = w;
                        default:
                            f.hasOwnProperty(m) || je(s, o, m, null, f, w);
                    }
                    for(g in f)if (m = f[g], w = c[g], f.hasOwnProperty(g) && (m != null || w != null)) switch(g){
                        case "value":
                            j = m;
                            break;
                        case "defaultValue":
                            T = m;
                            break;
                        case "multiple":
                            b = m;
                        default:
                            m !== w && je(s, o, g, m, f, w);
                    }
                    o = T, c = b, f = W, j != null ? Xr(s, !!c, j, !1) : !!f != !!c && (o != null ? Xr(s, !!c, o, !0) : Xr(s, !!c, c ? [] : "", !1));
                    return;
                case "textarea":
                    W = j = null;
                    for(T in c)if (g = c[T], c.hasOwnProperty(T) && g != null && !f.hasOwnProperty(T)) switch(T){
                        case "value":
                            break;
                        case "children":
                            break;
                        default:
                            je(s, o, T, null, f, g);
                    }
                    for(b in f)if (g = f[b], m = c[b], f.hasOwnProperty(b) && (g != null || m != null)) switch(b){
                        case "value":
                            j = g;
                            break;
                        case "defaultValue":
                            W = g;
                            break;
                        case "children":
                            break;
                        case "dangerouslySetInnerHTML":
                            if (g != null) throw Error(i(91));
                            break;
                        default:
                            g !== m && je(s, o, b, g, f, m);
                    }
                    _p(s, j, W);
                    return;
                case "option":
                    for(var ye in c)if (j = c[ye], c.hasOwnProperty(ye) && j != null && !f.hasOwnProperty(ye)) switch(ye){
                        case "selected":
                            s.selected = !1;
                            break;
                        default:
                            je(s, o, ye, null, f, j);
                    }
                    for(w in f)if (j = f[w], W = c[w], f.hasOwnProperty(w) && j !== W && (j != null || W != null)) switch(w){
                        case "selected":
                            s.selected = j && typeof j != "function" && typeof j != "symbol";
                            break;
                        default:
                            je(s, o, w, j, f, W);
                    }
                    return;
                case "img":
                case "link":
                case "area":
                case "base":
                case "br":
                case "col":
                case "embed":
                case "hr":
                case "keygen":
                case "meta":
                case "param":
                case "source":
                case "track":
                case "wbr":
                case "menuitem":
                    for(var ge in c)j = c[ge], c.hasOwnProperty(ge) && j != null && !f.hasOwnProperty(ge) && je(s, o, ge, null, f, j);
                    for(V in f)if (j = f[V], W = c[V], f.hasOwnProperty(V) && j !== W && (j != null || W != null)) switch(V){
                        case "children":
                        case "dangerouslySetInnerHTML":
                            if (j != null) throw Error(i(137, o));
                            break;
                        default:
                            je(s, o, V, j, f, W);
                    }
                    return;
                default:
                    if (Tu(o)) {
                        for(var We in c)j = c[We], c.hasOwnProperty(We) && j !== void 0 && !f.hasOwnProperty(We) && ah(s, o, We, void 0, f, j);
                        for(X in f)j = f[X], W = c[X], !f.hasOwnProperty(X) || j === W || j === void 0 && W === void 0 || ah(s, o, X, j, f, W);
                        return;
                    }
            }
            for(var D in c)j = c[D], c.hasOwnProperty(D) && j != null && !f.hasOwnProperty(D) && je(s, o, D, null, f, j);
            for(K in f)j = f[K], W = c[K], !f.hasOwnProperty(K) || j === W || j == null && W == null || je(s, o, K, j, f, W);
        }
        var oh = null, lh = null;
        function Bl(s) {
            return s.nodeType === 9 ? s : s.ownerDocument;
        }
        function by(s) {
            switch(s){
                case "http://www.w3.org/2000/svg":
                    return 1;
                case "http://www.w3.org/1998/Math/MathML":
                    return 2;
                default:
                    return 0;
            }
        }
        function vy(s, o) {
            if (s === 0) switch(o){
                case "svg":
                    return 1;
                case "math":
                    return 2;
                default:
                    return 0;
            }
            return s === 1 && o === "foreignObject" ? 0 : s;
        }
        function ch(s, o) {
            return s === "textarea" || s === "noscript" || typeof o.children == "string" || typeof o.children == "number" || typeof o.children == "bigint" || typeof o.dangerouslySetInnerHTML == "object" && o.dangerouslySetInnerHTML !== null && o.dangerouslySetInnerHTML.__html != null;
        }
        var uh = null;
        function Fx() {
            var s = window.event;
            return s && s.type === "popstate" ? s === uh ? !1 : (uh = s, !0) : (uh = null, !1);
        }
        var Ty = typeof setTimeout == "function" ? setTimeout : void 0, zx = typeof clearTimeout == "function" ? clearTimeout : void 0, xy = typeof Promise == "function" ? Promise : void 0, Vx = typeof queueMicrotask == "function" ? queueMicrotask : typeof xy < "u" ? function(s) {
            return xy.resolve(null).then(s).catch(Hx);
        } : Ty;
        function Hx(s) {
            setTimeout(function() {
                throw s;
            });
        }
        function Pi(s) {
            return s === "head";
        }
        function Sy(s, o) {
            var c = o, f = 0, g = 0;
            do {
                var m = c.nextSibling;
                if (s.removeChild(c), m && m.nodeType === 8) if (c = m.data, c === "/$") {
                    if (0 < f && 8 > f) {
                        c = f;
                        var b = s.ownerDocument;
                        if (c & 1 && $a(b.documentElement), c & 2 && $a(b.body), c & 4) for(c = b.head, $a(c), b = c.firstChild; b;){
                            var T = b.nextSibling, w = b.nodeName;
                            b[aa] || w === "SCRIPT" || w === "STYLE" || w === "LINK" && b.rel.toLowerCase() === "stylesheet" || c.removeChild(b), b = T;
                        }
                    }
                    if (g === 0) {
                        s.removeChild(m), Ja(o);
                        return;
                    }
                    g--;
                } else c === "$" || c === "$?" || c === "$!" ? g++ : f = c.charCodeAt(0) - 48;
                else f = 0;
                c = m;
            }while (c);
            Ja(o);
        }
        function fh(s) {
            var o = s.firstChild;
            for(o && o.nodeType === 10 && (o = o.nextSibling); o;){
                var c = o;
                switch(o = o.nextSibling, c.nodeName){
                    case "HTML":
                    case "HEAD":
                    case "BODY":
                        fh(c), pu(c);
                        continue;
                    case "SCRIPT":
                    case "STYLE":
                        continue;
                    case "LINK":
                        if (c.rel.toLowerCase() === "stylesheet") continue;
                }
                s.removeChild(c);
            }
        }
        function jx(s, o, c, f) {
            for(; s.nodeType === 1;){
                var g = c;
                if (s.nodeName.toLowerCase() !== o.toLowerCase()) {
                    if (!f && (s.nodeName !== "INPUT" || s.type !== "hidden")) break;
                } else if (f) {
                    if (!s[aa]) switch(o){
                        case "meta":
                            if (!s.hasAttribute("itemprop")) break;
                            return s;
                        case "link":
                            if (m = s.getAttribute("rel"), m === "stylesheet" && s.hasAttribute("data-precedence")) break;
                            if (m !== g.rel || s.getAttribute("href") !== (g.href == null || g.href === "" ? null : g.href) || s.getAttribute("crossorigin") !== (g.crossOrigin == null ? null : g.crossOrigin) || s.getAttribute("title") !== (g.title == null ? null : g.title)) break;
                            return s;
                        case "style":
                            if (s.hasAttribute("data-precedence")) break;
                            return s;
                        case "script":
                            if (m = s.getAttribute("src"), (m !== (g.src == null ? null : g.src) || s.getAttribute("type") !== (g.type == null ? null : g.type) || s.getAttribute("crossorigin") !== (g.crossOrigin == null ? null : g.crossOrigin)) && m && s.hasAttribute("async") && !s.hasAttribute("itemprop")) break;
                            return s;
                        default:
                            return s;
                    }
                } else if (o === "input" && s.type === "hidden") {
                    var m = g.name == null ? null : "" + g.name;
                    if (g.type === "hidden" && s.getAttribute("name") === m) return s;
                } else return s;
                if (s = An(s.nextSibling), s === null) break;
            }
            return null;
        }
        function Wx(s, o, c) {
            if (o === "") return null;
            for(; s.nodeType !== 3;)if ((s.nodeType !== 1 || s.nodeName !== "INPUT" || s.type !== "hidden") && !c || (s = An(s.nextSibling), s === null)) return null;
            return s;
        }
        function hh(s) {
            return s.data === "$!" || s.data === "$?" && s.ownerDocument.readyState === "complete";
        }
        function $x(s, o) {
            var c = s.ownerDocument;
            if (s.data !== "$?" || c.readyState === "complete") o();
            else {
                var f = function() {
                    o(), c.removeEventListener("DOMContentLoaded", f);
                };
                c.addEventListener("DOMContentLoaded", f), s._reactRetry = f;
            }
        }
        function An(s) {
            for(; s != null; s = s.nextSibling){
                var o = s.nodeType;
                if (o === 1 || o === 3) break;
                if (o === 8) {
                    if (o = s.data, o === "$" || o === "$!" || o === "$?" || o === "F!" || o === "F") break;
                    if (o === "/$") return null;
                }
            }
            return s;
        }
        var dh = null;
        function Ay(s) {
            s = s.previousSibling;
            for(var o = 0; s;){
                if (s.nodeType === 8) {
                    var c = s.data;
                    if (c === "$" || c === "$!" || c === "$?") {
                        if (o === 0) return s;
                        o--;
                    } else c === "/$" && o++;
                }
                s = s.previousSibling;
            }
            return null;
        }
        function wy(s, o, c) {
            switch(o = Bl(c), s){
                case "html":
                    if (s = o.documentElement, !s) throw Error(i(452));
                    return s;
                case "head":
                    if (s = o.head, !s) throw Error(i(453));
                    return s;
                case "body":
                    if (s = o.body, !s) throw Error(i(454));
                    return s;
                default:
                    throw Error(i(451));
            }
        }
        function $a(s) {
            for(var o = s.attributes; o.length;)s.removeAttributeNode(o[0]);
            pu(s);
        }
        var gn = new Map, Ey = new Set;
        function Ll(s) {
            return typeof s.getRootNode == "function" ? s.getRootNode() : s.nodeType === 9 ? s : s.ownerDocument;
        }
        var oi = ee.d;
        ee.d = {
            f: Xx,
            r: Yx,
            D: qx,
            C: Kx,
            L: Zx,
            m: Qx,
            X: Jx,
            S: Gx,
            M: eS
        };
        function Xx() {
            var s = oi.f(), o = Ml();
            return s || o;
        }
        function Yx(s) {
            var o = Hr(s);
            o !== null && o.tag === 5 && o.type === "form" ? Xm(o) : oi.r(s);
        }
        var xs = typeof document > "u" ? null : document;
        function Ry(s, o, c) {
            var f = xs;
            if (f && typeof o == "string" && o) {
                var g = on(o);
                g = 'link[rel="' + s + '"][href="' + g + '"]', typeof c == "string" && (g += '[crossorigin="' + c + '"]'), Ey.has(g) || (Ey.add(g), s = {
                    rel: s,
                    crossOrigin: c,
                    href: o
                }, f.querySelector(g) === null && (o = f.createElement("link"), At(o, "link", s), _t(o), f.head.appendChild(o)));
            }
        }
        function qx(s) {
            oi.D(s), Ry("dns-prefetch", s, null);
        }
        function Kx(s, o) {
            oi.C(s, o), Ry("preconnect", s, o);
        }
        function Zx(s, o, c) {
            oi.L(s, o, c);
            var f = xs;
            if (f && s && o) {
                var g = 'link[rel="preload"][as="' + on(o) + '"]';
                o === "image" && c && c.imageSrcSet ? (g += '[imagesrcset="' + on(c.imageSrcSet) + '"]', typeof c.imageSizes == "string" && (g += '[imagesizes="' + on(c.imageSizes) + '"]')) : g += '[href="' + on(s) + '"]';
                var m = g;
                switch(o){
                    case "style":
                        m = Ss(s);
                        break;
                    case "script":
                        m = As(s);
                }
                gn.has(m) || (s = p({
                    rel: "preload",
                    href: o === "image" && c && c.imageSrcSet ? void 0 : s,
                    as: o
                }, c), gn.set(m, s), f.querySelector(g) !== null || o === "style" && f.querySelector(Xa(m)) || o === "script" && f.querySelector(Ya(m)) || (o = f.createElement("link"), At(o, "link", s), _t(o), f.head.appendChild(o)));
            }
        }
        function Qx(s, o) {
            oi.m(s, o);
            var c = xs;
            if (c && s) {
                var f = o && typeof o.as == "string" ? o.as : "script", g = 'link[rel="modulepreload"][as="' + on(f) + '"][href="' + on(s) + '"]', m = g;
                switch(f){
                    case "audioworklet":
                    case "paintworklet":
                    case "serviceworker":
                    case "sharedworker":
                    case "worker":
                    case "script":
                        m = As(s);
                }
                if (!gn.has(m) && (s = p({
                    rel: "modulepreload",
                    href: s
                }, o), gn.set(m, s), c.querySelector(g) === null)) {
                    switch(f){
                        case "audioworklet":
                        case "paintworklet":
                        case "serviceworker":
                        case "sharedworker":
                        case "worker":
                        case "script":
                            if (c.querySelector(Ya(m))) return;
                    }
                    f = c.createElement("link"), At(f, "link", s), _t(f), c.head.appendChild(f);
                }
            }
        }
        function Gx(s, o, c) {
            oi.S(s, o, c);
            var f = xs;
            if (f && s) {
                var g = jr(f).hoistableStyles, m = Ss(s);
                o = o || "default";
                var b = g.get(m);
                if (!b) {
                    var T = {
                        loading: 0,
                        preload: null
                    };
                    if (b = f.querySelector(Xa(m))) T.loading = 5;
                    else {
                        s = p({
                            rel: "stylesheet",
                            href: s,
                            "data-precedence": o
                        }, c), (c = gn.get(m)) && gh(s, c);
                        var w = b = f.createElement("link");
                        _t(w), At(w, "link", s), w._p = new Promise(function(V, X) {
                            w.onload = V, w.onerror = X;
                        }), w.addEventListener("load", function() {
                            T.loading |= 1;
                        }), w.addEventListener("error", function() {
                            T.loading |= 2;
                        }), T.loading |= 4, Fl(b, o, f);
                    }
                    b = {
                        type: "stylesheet",
                        instance: b,
                        count: 1,
                        state: T
                    }, g.set(m, b);
                }
            }
        }
        function Jx(s, o) {
            oi.X(s, o);
            var c = xs;
            if (c && s) {
                var f = jr(c).hoistableScripts, g = As(s), m = f.get(g);
                m || (m = c.querySelector(Ya(g)), m || (s = p({
                    src: s,
                    async: !0
                }, o), (o = gn.get(g)) && ph(s, o), m = c.createElement("script"), _t(m), At(m, "link", s), c.head.appendChild(m)), m = {
                    type: "script",
                    instance: m,
                    count: 1,
                    state: null
                }, f.set(g, m));
            }
        }
        function eS(s, o) {
            oi.M(s, o);
            var c = xs;
            if (c && s) {
                var f = jr(c).hoistableScripts, g = As(s), m = f.get(g);
                m || (m = c.querySelector(Ya(g)), m || (s = p({
                    src: s,
                    async: !0,
                    type: "module"
                }, o), (o = gn.get(g)) && ph(s, o), m = c.createElement("script"), _t(m), At(m, "link", s), c.head.appendChild(m)), m = {
                    type: "script",
                    instance: m,
                    count: 1,
                    state: null
                }, f.set(g, m));
            }
        }
        function Cy(s, o, c, f) {
            var g = (g = _e.current) ? Ll(g) : null;
            if (!g) throw Error(i(446));
            switch(s){
                case "meta":
                case "title":
                    return null;
                case "style":
                    return typeof c.precedence == "string" && typeof c.href == "string" ? (o = Ss(c.href), c = jr(g).hoistableStyles, f = c.get(o), f || (f = {
                        type: "style",
                        instance: null,
                        count: 0,
                        state: null
                    }, c.set(o, f)), f) : {
                        type: "void",
                        instance: null,
                        count: 0,
                        state: null
                    };
                case "link":
                    if (c.rel === "stylesheet" && typeof c.href == "string" && typeof c.precedence == "string") {
                        s = Ss(c.href);
                        var m = jr(g).hoistableStyles, b = m.get(s);
                        if (b || (g = g.ownerDocument || g, b = {
                            type: "stylesheet",
                            instance: null,
                            count: 0,
                            state: {
                                loading: 0,
                                preload: null
                            }
                        }, m.set(s, b), (m = g.querySelector(Xa(s))) && !m._p && (b.instance = m, b.state.loading = 5), gn.has(s) || (c = {
                            rel: "preload",
                            as: "style",
                            href: c.href,
                            crossOrigin: c.crossOrigin,
                            integrity: c.integrity,
                            media: c.media,
                            hrefLang: c.hrefLang,
                            referrerPolicy: c.referrerPolicy
                        }, gn.set(s, c), m || tS(g, s, c, b.state))), o && f === null) throw Error(i(528, ""));
                        return b;
                    }
                    if (o && f !== null) throw Error(i(529, ""));
                    return null;
                case "script":
                    return o = c.async, c = c.src, typeof c == "string" && o && typeof o != "function" && typeof o != "symbol" ? (o = As(c), c = jr(g).hoistableScripts, f = c.get(o), f || (f = {
                        type: "script",
                        instance: null,
                        count: 0,
                        state: null
                    }, c.set(o, f)), f) : {
                        type: "void",
                        instance: null,
                        count: 0,
                        state: null
                    };
                default:
                    throw Error(i(444, s));
            }
        }
        function Ss(s) {
            return 'href="' + on(s) + '"';
        }
        function Xa(s) {
            return 'link[rel="stylesheet"][' + s + "]";
        }
        function My(s) {
            return p({}, s, {
                "data-precedence": s.precedence,
                precedence: null
            });
        }
        function tS(s, o, c, f) {
            s.querySelector('link[rel="preload"][as="style"][' + o + "]") ? f.loading = 1 : (o = s.createElement("link"), f.preload = o, o.addEventListener("load", function() {
                return f.loading |= 1;
            }), o.addEventListener("error", function() {
                return f.loading |= 2;
            }), At(o, "link", c), _t(o), s.head.appendChild(o));
        }
        function As(s) {
            return '[src="' + on(s) + '"]';
        }
        function Ya(s) {
            return "script[async]" + s;
        }
        function Oy(s, o, c) {
            if (o.count++, o.instance === null) switch(o.type){
                case "style":
                    var f = s.querySelector('style[data-href~="' + on(c.href) + '"]');
                    if (f) return o.instance = f, _t(f), f;
                    var g = p({}, c, {
                        "data-href": c.href,
                        "data-precedence": c.precedence,
                        href: null,
                        precedence: null
                    });
                    return f = (s.ownerDocument || s).createElement("style"), _t(f), At(f, "style", g), Fl(f, c.precedence, s), o.instance = f;
                case "stylesheet":
                    g = Ss(c.href);
                    var m = s.querySelector(Xa(g));
                    if (m) return o.state.loading |= 4, o.instance = m, _t(m), m;
                    f = My(c), (g = gn.get(g)) && gh(f, g), m = (s.ownerDocument || s).createElement("link"), _t(m);
                    var b = m;
                    return b._p = new Promise(function(T, w) {
                        b.onload = T, b.onerror = w;
                    }), At(m, "link", f), o.state.loading |= 4, Fl(m, c.precedence, s), o.instance = m;
                case "script":
                    return m = As(c.src), (g = s.querySelector(Ya(m))) ? (o.instance = g, _t(g), g) : (f = c, (g = gn.get(m)) && (f = p({}, c), ph(f, g)), s = s.ownerDocument || s, g = s.createElement("script"), _t(g), At(g, "link", f), s.head.appendChild(g), o.instance = g);
                case "void":
                    return null;
                default:
                    throw Error(i(443, o.type));
            }
            else o.type === "stylesheet" && (o.state.loading & 4) === 0 && (f = o.instance, o.state.loading |= 4, Fl(f, c.precedence, s));
            return o.instance;
        }
        function Fl(s, o, c) {
            for(var f = c.querySelectorAll('link[rel="stylesheet"][data-precedence],style[data-precedence]'), g = f.length ? f[f.length - 1] : null, m = g, b = 0; b < f.length; b++){
                var T = f[b];
                if (T.dataset.precedence === o) m = T;
                else if (m !== g) break;
            }
            m ? m.parentNode.insertBefore(s, m.nextSibling) : (o = c.nodeType === 9 ? c.head : c, o.insertBefore(s, o.firstChild));
        }
        function gh(s, o) {
            s.crossOrigin == null && (s.crossOrigin = o.crossOrigin), s.referrerPolicy == null && (s.referrerPolicy = o.referrerPolicy), s.title == null && (s.title = o.title);
        }
        function ph(s, o) {
            s.crossOrigin == null && (s.crossOrigin = o.crossOrigin), s.referrerPolicy == null && (s.referrerPolicy = o.referrerPolicy), s.integrity == null && (s.integrity = o.integrity);
        }
        var zl = null;
        function Iy(s, o, c) {
            if (zl === null) {
                var f = new Map, g = zl = new Map;
                g.set(c, f);
            } else g = zl, f = g.get(c), f || (f = new Map, g.set(c, f));
            if (f.has(s)) return f;
            for(f.set(s, null), c = c.getElementsByTagName(s), g = 0; g < c.length; g++){
                var m = c[g];
                if (!(m[aa] || m[wt] || s === "link" && m.getAttribute("rel") === "stylesheet") && m.namespaceURI !== "http://www.w3.org/2000/svg") {
                    var b = m.getAttribute(o) || "";
                    b = s + b;
                    var T = f.get(b);
                    T ? T.push(m) : f.set(b, [
                        m
                    ]);
                }
            }
            return f;
        }
        function Ny(s, o, c) {
            s = s.ownerDocument || s, s.head.insertBefore(c, o === "title" ? s.querySelector("head > title") : null);
        }
        function nS(s, o, c) {
            if (c === 1 || o.itemProp != null) return !1;
            switch(s){
                case "meta":
                case "title":
                    return !0;
                case "style":
                    if (typeof o.precedence != "string" || typeof o.href != "string" || o.href === "") break;
                    return !0;
                case "link":
                    if (typeof o.rel != "string" || typeof o.href != "string" || o.href === "" || o.onLoad || o.onError) break;
                    switch(o.rel){
                        case "stylesheet":
                            return s = o.disabled, typeof o.precedence == "string" && s == null;
                        default:
                            return !0;
                    }
                case "script":
                    if (o.async && typeof o.async != "function" && typeof o.async != "symbol" && !o.onLoad && !o.onError && o.src && typeof o.src == "string") return !0;
            }
            return !1;
        }
        function Py(s) {
            return !(s.type === "stylesheet" && (s.state.loading & 3) === 0);
        }
        var qa = null;
        function iS() {}
        function rS(s, o, c) {
            if (qa === null) throw Error(i(475));
            var f = qa;
            if (o.type === "stylesheet" && (typeof c.media != "string" || matchMedia(c.media).matches !== !1) && (o.state.loading & 4) === 0) {
                if (o.instance === null) {
                    var g = Ss(c.href), m = s.querySelector(Xa(g));
                    if (m) {
                        s = m._p, s !== null && typeof s == "object" && typeof s.then == "function" && (f.count++, f = Vl.bind(f), s.then(f, f)), o.state.loading |= 4, o.instance = m, _t(m);
                        return;
                    }
                    m = s.ownerDocument || s, c = My(c), (g = gn.get(g)) && gh(c, g), m = m.createElement("link"), _t(m);
                    var b = m;
                    b._p = new Promise(function(T, w) {
                        b.onload = T, b.onerror = w;
                    }), At(m, "link", c), o.instance = m;
                }
                f.stylesheets === null && (f.stylesheets = new Map), f.stylesheets.set(o, s), (s = o.state.preload) && (o.state.loading & 3) === 0 && (f.count++, o = Vl.bind(f), s.addEventListener("load", o), s.addEventListener("error", o));
            }
        }
        function sS() {
            if (qa === null) throw Error(i(475));
            var s = qa;
            return s.stylesheets && s.count === 0 && mh(s, s.stylesheets), 0 < s.count ? function(o) {
                var c = setTimeout(function() {
                    if (s.stylesheets && mh(s, s.stylesheets), s.unsuspend) {
                        var f = s.unsuspend;
                        s.unsuspend = null, f();
                    }
                }, 6e4);
                return s.unsuspend = o, function() {
                    s.unsuspend = null, clearTimeout(c);
                };
            } : null;
        }
        function Vl() {
            if (this.count--, this.count === 0) {
                if (this.stylesheets) mh(this, this.stylesheets);
                else if (this.unsuspend) {
                    var s = this.unsuspend;
                    this.unsuspend = null, s();
                }
            }
        }
        var Hl = null;
        function mh(s, o) {
            s.stylesheets = null, s.unsuspend !== null && (s.count++, Hl = new Map, o.forEach(aS, s), Hl = null, Vl.call(s));
        }
        function aS(s, o) {
            if (!(o.state.loading & 4)) {
                var c = Hl.get(s);
                if (c) var f = c.get(null);
                else {
                    c = new Map, Hl.set(s, c);
                    for(var g = s.querySelectorAll("link[data-precedence],style[data-precedence]"), m = 0; m < g.length; m++){
                        var b = g[m];
                        (b.nodeName === "LINK" || b.getAttribute("media") !== "not all") && (c.set(b.dataset.precedence, b), f = b);
                    }
                    f && c.set(null, f);
                }
                g = o.instance, b = g.getAttribute("data-precedence"), m = c.get(b) || f, m === f && c.set(null, g), c.set(b, g), this.count++, f = Vl.bind(this), g.addEventListener("load", f), g.addEventListener("error", f), m ? m.parentNode.insertBefore(g, m.nextSibling) : (s = s.nodeType === 9 ? s.head : s, s.insertBefore(g, s.firstChild)), o.state.loading |= 4;
            }
        }
        var Ka = {
            $$typeof: O,
            Provider: null,
            Consumer: null,
            _currentValue: ce,
            _currentValue2: ce,
            _threadCount: 0
        };
        function oS(s, o, c, f, g, m, b, T) {
            this.tag = 1, this.containerInfo = s, this.pingCache = this.current = this.pendingChildren = null, this.timeoutHandle = -1, this.callbackNode = this.next = this.pendingContext = this.context = this.cancelPendingCommit = null, this.callbackPriority = 0, this.expirationTimes = fu(-1), this.entangledLanes = this.shellSuspendCounter = this.errorRecoveryDisabledLanes = this.expiredLanes = this.warmLanes = this.pingedLanes = this.suspendedLanes = this.pendingLanes = 0, this.entanglements = fu(0), this.hiddenUpdates = fu(null), this.identifierPrefix = f, this.onUncaughtError = g, this.onCaughtError = m, this.onRecoverableError = b, this.pooledCache = null, this.pooledCacheLanes = 0, this.formState = T, this.incompleteTransitions = new Map;
        }
        function Dy(s, o, c, f, g, m, b, T, w, V, X, K) {
            return s = new oS(s, o, c, b, T, w, V, K), o = 1, m === !0 && (o |= 24), m = Kt(3, null, null, o), s.current = m, m.stateNode = s, o = Zu(), o.refCount++, s.pooledCache = o, o.refCount++, m.memoizedState = {
                element: f,
                isDehydrated: c,
                cache: o
            }, ef(m), s;
        }
        function ky(s) {
            return s ? (s = ts, s) : ts;
        }
        function Uy(s, o, c, f, g, m) {
            g = ky(g), f.context === null ? f.context = g : f.pendingContext = g, f = vi(o), f.payload = {
                element: c
            }, m = m === void 0 ? null : m, m !== null && (f.callback = m), c = Ti(s, f, o), c !== null && (en(c, s, o), wa(c, s, o));
        }
        function By(s, o) {
            if (s = s.memoizedState, s !== null && s.dehydrated !== null) {
                var c = s.retryLane;
                s.retryLane = c !== 0 && c < o ? c : o;
            }
        }
        function _h(s, o) {
            By(s, o), (s = s.alternate) && By(s, o);
        }
        function Ly(s) {
            if (s.tag === 13) {
                var o = es(s, 67108864);
                o !== null && en(o, s, 67108864), _h(s, 67108864);
            }
        }
        var jl = !0;
        function lS(s, o, c, f) {
            var g = $.T;
            $.T = null;
            var m = ee.p;
            try {
                ee.p = 2, yh(s, o, c, f);
            } finally{
                ee.p = m, $.T = g;
            }
        }
        function cS(s, o, c, f) {
            var g = $.T;
            $.T = null;
            var m = ee.p;
            try {
                ee.p = 8, yh(s, o, c, f);
            } finally{
                ee.p = m, $.T = g;
            }
        }
        function yh(s, o, c, f) {
            if (jl) {
                var g = bh(f);
                if (g === null) sh(s, o, f, Wl, c), zy(s, f);
                else if (fS(g, s, o, c, f)) f.stopPropagation();
                else if (zy(s, f), o & 4 && -1 < uS.indexOf(s)) {
                    for(; g !== null;){
                        var m = Hr(g);
                        if (m !== null) switch(m.tag){
                            case 3:
                                if (m = m.stateNode, m.current.memoizedState.isDehydrated) {
                                    var b = er(m.pendingLanes);
                                    if (b !== 0) {
                                        var T = m;
                                        for(T.pendingLanes |= 2, T.entangledLanes |= 2; b;){
                                            var w = 1 << 31 - Yt(b);
                                            T.entanglements[1] |= w, b &= ~w;
                                        }
                                        kn(m), (ze & 6) === 0 && (Rl = Dt() + 500, Ha(0));
                                    }
                                }
                                break;
                            case 13:
                                T = es(m, 2), T !== null && en(T, m, 2), Ml(), _h(m, 2);
                        }
                        if (m = bh(f), m === null && sh(s, o, f, Wl, c), m === g) break;
                        g = m;
                    }
                    g !== null && f.stopPropagation();
                } else sh(s, o, f, null, c);
            }
        }
        function bh(s) {
            return s = Su(s), vh(s);
        }
        var Wl = null;
        function vh(s) {
            if (Wl = null, s = Vr(s), s !== null) {
                var o = a(s);
                if (o === null) s = null;
                else {
                    var c = o.tag;
                    if (c === 13) {
                        if (s = l(o), s !== null) return s;
                        s = null;
                    } else if (c === 3) {
                        if (o.stateNode.current.memoizedState.isDehydrated) return o.tag === 3 ? o.stateNode.containerInfo : null;
                        s = null;
                    } else o !== s && (s = null);
                }
            }
            return Wl = s, null;
        }
        function Fy(s) {
            switch(s){
                case "beforetoggle":
                case "cancel":
                case "click":
                case "close":
                case "contextmenu":
                case "copy":
                case "cut":
                case "auxclick":
                case "dblclick":
                case "dragend":
                case "dragstart":
                case "drop":
                case "focusin":
                case "focusout":
                case "input":
                case "invalid":
                case "keydown":
                case "keypress":
                case "keyup":
                case "mousedown":
                case "mouseup":
                case "paste":
                case "pause":
                case "play":
                case "pointercancel":
                case "pointerdown":
                case "pointerup":
                case "ratechange":
                case "reset":
                case "resize":
                case "seeked":
                case "submit":
                case "toggle":
                case "touchcancel":
                case "touchend":
                case "touchstart":
                case "volumechange":
                case "change":
                case "selectionchange":
                case "textInput":
                case "compositionstart":
                case "compositionend":
                case "compositionupdate":
                case "beforeblur":
                case "afterblur":
                case "beforeinput":
                case "blur":
                case "fullscreenchange":
                case "focus":
                case "hashchange":
                case "popstate":
                case "select":
                case "selectstart":
                    return 2;
                case "drag":
                case "dragenter":
                case "dragexit":
                case "dragleave":
                case "dragover":
                case "mousemove":
                case "mouseout":
                case "mouseover":
                case "pointermove":
                case "pointerout":
                case "pointerover":
                case "scroll":
                case "touchmove":
                case "wheel":
                case "mouseenter":
                case "mouseleave":
                case "pointerenter":
                case "pointerleave":
                    return 8;
                case "message":
                    switch(Fr()){
                        case Ji:
                            return 2;
                        case ep:
                            return 8;
                        case Uo:
                        case Z1:
                            return 32;
                        case tp:
                            return 268435456;
                        default:
                            return 32;
                    }
                default:
                    return 32;
            }
        }
        var Th = !1, Di = null, ki = null, Ui = null, Za = new Map, Qa = new Map, Bi = [], uS = "mousedown mouseup touchcancel touchend touchstart auxclick dblclick pointercancel pointerdown pointerup dragend dragstart drop compositionend compositionstart keydown keypress keyup input textInput copy cut paste click change contextmenu reset".split(" ");
        function zy(s, o) {
            switch(s){
                case "focusin":
                case "focusout":
                    Di = null;
                    break;
                case "dragenter":
                case "dragleave":
                    ki = null;
                    break;
                case "mouseover":
                case "mouseout":
                    Ui = null;
                    break;
                case "pointerover":
                case "pointerout":
                    Za.delete(o.pointerId);
                    break;
                case "gotpointercapture":
                case "lostpointercapture":
                    Qa.delete(o.pointerId);
            }
        }
        function Ga(s, o, c, f, g, m) {
            return s === null || s.nativeEvent !== m ? (s = {
                blockedOn: o,
                domEventName: c,
                eventSystemFlags: f,
                nativeEvent: m,
                targetContainers: [
                    g
                ]
            }, o !== null && (o = Hr(o), o !== null && Ly(o)), s) : (s.eventSystemFlags |= f, o = s.targetContainers, g !== null && o.indexOf(g) === -1 && o.push(g), s);
        }
        function fS(s, o, c, f, g) {
            switch(o){
                case "focusin":
                    return Di = Ga(Di, s, o, c, f, g), !0;
                case "dragenter":
                    return ki = Ga(ki, s, o, c, f, g), !0;
                case "mouseover":
                    return Ui = Ga(Ui, s, o, c, f, g), !0;
                case "pointerover":
                    var m = g.pointerId;
                    return Za.set(m, Ga(Za.get(m) || null, s, o, c, f, g)), !0;
                case "gotpointercapture":
                    return m = g.pointerId, Qa.set(m, Ga(Qa.get(m) || null, s, o, c, f, g)), !0;
            }
            return !1;
        }
        function Vy(s) {
            var o = Vr(s.target);
            if (o !== null) {
                var c = a(o);
                if (c !== null) {
                    if (o = c.tag, o === 13) {
                        if (o = l(c), o !== null) {
                            s.blockedOn = o, r2(s.priority, function() {
                                if (c.tag === 13) {
                                    var f = Jt();
                                    f = hu(f);
                                    var g = es(c, f);
                                    g !== null && en(g, c, f), _h(c, f);
                                }
                            });
                            return;
                        }
                    } else if (o === 3 && c.stateNode.current.memoizedState.isDehydrated) {
                        s.blockedOn = c.tag === 3 ? c.stateNode.containerInfo : null;
                        return;
                    }
                }
            }
            s.blockedOn = null;
        }
        function $l(s) {
            if (s.blockedOn !== null) return !1;
            for(var o = s.targetContainers; 0 < o.length;){
                var c = bh(s.nativeEvent);
                if (c === null) {
                    c = s.nativeEvent;
                    var f = new c.constructor(c.type, c);
                    xu = f, c.target.dispatchEvent(f), xu = null;
                } else return o = Hr(c), o !== null && Ly(o), s.blockedOn = c, !1;
                o.shift();
            }
            return !0;
        }
        function Hy(s, o, c) {
            $l(s) && c.delete(o);
        }
        function hS() {
            Th = !1, Di !== null && $l(Di) && (Di = null), ki !== null && $l(ki) && (ki = null), Ui !== null && $l(Ui) && (Ui = null), Za.forEach(Hy), Qa.forEach(Hy);
        }
        function Xl(s, o) {
            s.blockedOn === o && (s.blockedOn = null, Th || (Th = !0, n.unstable_scheduleCallback(n.unstable_NormalPriority, hS)));
        }
        var Yl = null;
        function jy(s) {
            Yl !== s && (Yl = s, n.unstable_scheduleCallback(n.unstable_NormalPriority, function() {
                Yl === s && (Yl = null);
                for(var o = 0; o < s.length; o += 3){
                    var c = s[o], f = s[o + 1], g = s[o + 2];
                    if (typeof f != "function") {
                        if (vh(f || c) === null) continue;
                        break;
                    }
                    var m = Hr(c);
                    m !== null && (s.splice(o, 3), o -= 3, vf(m, {
                        pending: !0,
                        data: g,
                        method: c.method,
                        action: f
                    }, f, g));
                }
            }));
        }
        function Ja(s) {
            function o(w) {
                return Xl(w, s);
            }
            Di !== null && Xl(Di, s), ki !== null && Xl(ki, s), Ui !== null && Xl(Ui, s), Za.forEach(o), Qa.forEach(o);
            for(var c = 0; c < Bi.length; c++){
                var f = Bi[c];
                f.blockedOn === s && (f.blockedOn = null);
            }
            for(; 0 < Bi.length && (c = Bi[0], c.blockedOn === null);)Vy(c), c.blockedOn === null && Bi.shift();
            if (c = (s.ownerDocument || s).$$reactFormReplay, c != null) for(f = 0; f < c.length; f += 3){
                var g = c[f], m = c[f + 1], b = g[Bt] || null;
                if (typeof m == "function") b || jy(c);
                else if (b) {
                    var T = null;
                    if (m && m.hasAttribute("formAction")) {
                        if (g = m, b = m[Bt] || null) T = b.formAction;
                        else if (vh(g) !== null) continue;
                    } else T = b.action;
                    typeof T == "function" ? c[f + 1] = T : (c.splice(f, 3), f -= 3), jy(c);
                }
            }
        }
        function xh(s) {
            this._internalRoot = s;
        }
        ql.prototype.render = xh.prototype.render = function(s) {
            var o = this._internalRoot;
            if (o === null) throw Error(i(409));
            var c = o.current, f = Jt();
            Uy(c, f, s, o, null, null);
        }, ql.prototype.unmount = xh.prototype.unmount = function() {
            var s = this._internalRoot;
            if (s !== null) {
                this._internalRoot = null;
                var o = s.containerInfo;
                Uy(s.current, 2, null, s, null, null), Ml(), o[zr] = null;
            }
        };
        function ql(s) {
            this._internalRoot = s;
        }
        ql.prototype.unstable_scheduleHydration = function(s) {
            if (s) {
                var o = ap();
                s = {
                    blockedOn: null,
                    target: s,
                    priority: o
                };
                for(var c = 0; c < Bi.length && o !== 0 && o < Bi[c].priority; c++);
                Bi.splice(c, 0, s), c === 0 && Vy(s);
            }
        };
        var Wy = e.version;
        if (Wy !== "19.1.0") throw Error(i(527, Wy, "19.1.0"));
        ee.findDOMNode = function(s) {
            var o = s._reactInternals;
            if (o === void 0) throw typeof s.render == "function" ? Error(i(188)) : (s = Object.keys(s).join(","), Error(i(268, s)));
            return s = h(o), s = s !== null ? d(s) : null, s = s === null ? null : s.stateNode, s;
        };
        var dS = {
            bundleType: 0,
            version: "19.1.0",
            rendererPackageName: "react-dom",
            currentDispatcherRef: $,
            reconcilerVersion: "19.1.0"
        };
        if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < "u") {
            var Kl = __REACT_DEVTOOLS_GLOBAL_HOOK__;
            if (!Kl.isDisabled && Kl.supportsFiber) try {
                ia = Kl.inject(dS), Xt = Kl;
            } catch  {}
        }
        return to.createRoot = function(s, o) {
            if (!r(s)) throw Error(i(299));
            var c = !1, f = "", g = a_, m = o_, b = l_, T = null;
            return o != null && (o.unstable_strictMode === !0 && (c = !0), o.identifierPrefix !== void 0 && (f = o.identifierPrefix), o.onUncaughtError !== void 0 && (g = o.onUncaughtError), o.onCaughtError !== void 0 && (m = o.onCaughtError), o.onRecoverableError !== void 0 && (b = o.onRecoverableError), o.unstable_transitionCallbacks !== void 0 && (T = o.unstable_transitionCallbacks)), o = Dy(s, 1, !1, null, null, c, f, g, m, b, T, null), s[zr] = o.current, rh(s), new xh(o);
        }, to.hydrateRoot = function(s, o, c) {
            if (!r(s)) throw Error(i(299));
            var f = !1, g = "", m = a_, b = o_, T = l_, w = null, V = null;
            return c != null && (c.unstable_strictMode === !0 && (f = !0), c.identifierPrefix !== void 0 && (g = c.identifierPrefix), c.onUncaughtError !== void 0 && (m = c.onUncaughtError), c.onCaughtError !== void 0 && (b = c.onCaughtError), c.onRecoverableError !== void 0 && (T = c.onRecoverableError), c.unstable_transitionCallbacks !== void 0 && (w = c.unstable_transitionCallbacks), c.formState !== void 0 && (V = c.formState)), o = Dy(s, 1, !0, o, c ?? null, f, g, m, b, T, w, V), o.context = ky(null), c = o.current, f = Jt(), f = hu(f), g = vi(f), g.callback = null, Ti(c, g, f), c = f, o.current.lanes = c, sa(o, c), kn(o), s[zr] = o.current, rh(s), new ql(o);
        }, to.version = "19.1.0", to;
    }
    var eb;
    function AS() {
        if (eb) return wh.exports;
        eb = 1;
        function n() {
            if (!(typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ > "u" || typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE != "function")) try {
                __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(n);
            } catch (e) {
                console.error(e);
            }
        }
        return n(), wh.exports = SS(), wh.exports;
    }
    var wS = AS();
    const ES = Xv(wS), RS = "modulepreload", CS = function(n) {
        return "/mobile-network-map/" + n;
    }, tb = {}, MS = function(e, t, i) {
        let r = Promise.resolve();
        if (t && t.length > 0) {
            let l = function(d) {
                return Promise.all(d.map((p)=>Promise.resolve(p).then((_)=>({
                            status: "fulfilled",
                            value: _
                        }), (_)=>({
                            status: "rejected",
                            reason: _
                        }))));
            };
            document.getElementsByTagName("link");
            const u = document.querySelector("meta[property=csp-nonce]"), h = u?.nonce || u?.getAttribute("nonce");
            r = l(t.map((d)=>{
                if (d = CS(d), d in tb) return;
                tb[d] = !0;
                const p = d.endsWith(".css"), _ = p ? '[rel="stylesheet"]' : "";
                if (document.querySelector(`link[href="${d}"]${_}`)) return;
                const y = document.createElement("link");
                if (y.rel = p ? "stylesheet" : RS, p || (y.as = "script"), y.crossOrigin = "", y.href = d, h && y.setAttribute("nonce", h), document.head.appendChild(y), p) return new Promise((v, S)=>{
                    y.addEventListener("load", v), y.addEventListener("error", ()=>S(new Error(`Unable to preload CSS for ${d}`)));
                });
            }));
        }
        function a(l) {
            const u = new Event("vite:preloadError", {
                cancelable: !0
            });
            if (u.payload = l, window.dispatchEvent(u), !u.defaultPrevented) throw l;
        }
        return r.then((l)=>{
            for (const u of l || [])u.status === "rejected" && a(u.reason);
            return e().catch(a);
        });
    }, OS = Q.createContext(null);
    function IS(n, e) {
        const t = Array.isArray(n) ? n[0] : n ? n.x : 0, i = Array.isArray(n) ? n[1] : n ? n.y : 0, r = Array.isArray(e) ? e[0] : e ? e.x : 0, a = Array.isArray(e) ? e[1] : e ? e.y : 0;
        return t === r && i === a;
    }
    function Fn(n, e) {
        if (n === e) return !0;
        if (!n || !e) return !1;
        if (Array.isArray(n)) {
            if (!Array.isArray(e) || n.length !== e.length) return !1;
            for(let t = 0; t < n.length; t++)if (!Fn(n[t], e[t])) return !1;
            return !0;
        } else if (Array.isArray(e)) return !1;
        if (typeof n == "object" && typeof e == "object") {
            const t = Object.keys(n), i = Object.keys(e);
            if (t.length !== i.length) return !1;
            for (const r of t)if (!e.hasOwnProperty(r) || !Fn(n[r], e[r])) return !1;
            return !0;
        }
        return !1;
    }
    function nb(n) {
        return {
            longitude: n.center.lng,
            latitude: n.center.lat,
            zoom: n.zoom,
            pitch: n.pitch,
            bearing: n.bearing,
            padding: n.padding
        };
    }
    function ib(n, e) {
        const t = e.viewState || e, i = {};
        if ("longitude" in t && "latitude" in t && (t.longitude !== n.center.lng || t.latitude !== n.center.lat)) {
            const r = n.center.constructor;
            i.center = new r(t.longitude, t.latitude);
        }
        return "zoom" in t && t.zoom !== n.zoom && (i.zoom = t.zoom), "bearing" in t && t.bearing !== n.bearing && (i.bearing = t.bearing), "pitch" in t && t.pitch !== n.pitch && (i.pitch = t.pitch), t.padding && n.padding && !Fn(t.padding, n.padding) && (i.padding = t.padding), i;
    }
    const NS = [
        "type",
        "source",
        "source-layer",
        "minzoom",
        "maxzoom",
        "filter",
        "layout"
    ];
    function rb(n) {
        if (!n) return null;
        if (typeof n == "string" || ("toJS" in n && (n = n.toJS()), !n.layers)) return n;
        const e = {};
        for (const i of n.layers)e[i.id] = i;
        const t = n.layers.map((i)=>{
            let r = null;
            "interactive" in i && (r = Object.assign({}, i), delete r.interactive);
            const a = e[i.ref];
            if (a) {
                r = r || Object.assign({}, i), delete r.ref;
                for (const l of NS)l in a && (r[l] = a[l]);
            }
            return r || i;
        });
        return {
            ...n,
            layers: t
        };
    }
    const sb = {
        version: 8,
        sources: {},
        layers: []
    }, ab = {
        mousedown: "onMouseDown",
        mouseup: "onMouseUp",
        mouseover: "onMouseOver",
        mousemove: "onMouseMove",
        click: "onClick",
        dblclick: "onDblClick",
        mouseenter: "onMouseEnter",
        mouseleave: "onMouseLeave",
        mouseout: "onMouseOut",
        contextmenu: "onContextMenu",
        touchstart: "onTouchStart",
        touchend: "onTouchEnd",
        touchmove: "onTouchMove",
        touchcancel: "onTouchCancel"
    }, ob = {
        movestart: "onMoveStart",
        move: "onMove",
        moveend: "onMoveEnd",
        dragstart: "onDragStart",
        drag: "onDrag",
        dragend: "onDragEnd",
        zoomstart: "onZoomStart",
        zoom: "onZoom",
        zoomend: "onZoomEnd",
        rotatestart: "onRotateStart",
        rotate: "onRotate",
        rotateend: "onRotateEnd",
        pitchstart: "onPitchStart",
        pitch: "onPitch",
        pitchend: "onPitchEnd"
    }, lb = {
        wheel: "onWheel",
        boxzoomstart: "onBoxZoomStart",
        boxzoomend: "onBoxZoomEnd",
        boxzoomcancel: "onBoxZoomCancel",
        resize: "onResize",
        load: "onLoad",
        render: "onRender",
        idle: "onIdle",
        remove: "onRemove",
        data: "onData",
        styledata: "onStyleData",
        sourcedata: "onSourceData",
        error: "onError"
    }, PS = [
        "minZoom",
        "maxZoom",
        "minPitch",
        "maxPitch",
        "maxBounds",
        "projection",
        "renderWorldCopies"
    ], DS = [
        "scrollZoom",
        "boxZoom",
        "dragRotate",
        "dragPan",
        "keyboard",
        "doubleClickZoom",
        "touchZoomRotate",
        "touchPitch"
    ];
    class Ws {
        constructor(e, t, i){
            this._map = null, this._internalUpdate = !1, this._hoveredFeatures = null, this._propsedCameraUpdate = null, this._styleComponents = {}, this._onEvent = (r)=>{
                const a = this.props[lb[r.type]];
                a ? a(r) : r.type === "error" && console.error(r.error);
            }, this._onCameraEvent = (r)=>{
                if (this._internalUpdate) return;
                r.viewState = this._propsedCameraUpdate || nb(this._map.transform);
                const a = this.props[ob[r.type]];
                a && a(r);
            }, this._onCameraUpdate = (r)=>this._internalUpdate ? r : (this._propsedCameraUpdate = nb(r), ib(r, this.props)), this._onPointerEvent = (r)=>{
                (r.type === "mousemove" || r.type === "mouseout") && this._updateHover(r);
                const a = this.props[ab[r.type]];
                a && (this.props.interactiveLayerIds && r.type !== "mouseover" && r.type !== "mouseout" && (r.features = this._hoveredFeatures || this._queryRenderedFeatures(r.point)), a(r), delete r.features);
            }, this._MapClass = e, this.props = t, this._initialize(i);
        }
        get map() {
            return this._map;
        }
        setProps(e) {
            const t = this.props;
            this.props = e;
            const i = this._updateSettings(e, t), r = this._updateSize(e), a = this._updateViewState(e);
            this._updateStyle(e, t), this._updateStyleComponents(e), this._updateHandlers(e, t), (i || r || a && !this._map.isMoving()) && this.redraw();
        }
        static reuse(e, t) {
            const i = Ws.savedMaps.pop();
            if (!i) return null;
            const r = i.map, a = r.getContainer();
            for(t.className = a.className; a.childNodes.length > 0;)t.appendChild(a.childNodes[0]);
            r._container = t;
            const l = r._resizeObserver;
            l && (l.disconnect(), l.observe(t)), i.setProps({
                ...e,
                styleDiffing: !1
            }), r.resize();
            const { initialViewState: u } = e;
            return u && (u.bounds ? r.fitBounds(u.bounds, {
                ...u.fitBoundsOptions,
                duration: 0
            }) : i._updateViewState(u)), r.isStyleLoaded() ? r.fire("load") : r.once("style.load", ()=>r.fire("load")), r._update(), i;
        }
        _initialize(e) {
            const { props: t } = this, { mapStyle: i = sb } = t, r = {
                ...t,
                ...t.initialViewState,
                container: e,
                style: rb(i)
            }, a = r.initialViewState || r.viewState || r;
            if (Object.assign(r, {
                center: [
                    a.longitude || 0,
                    a.latitude || 0
                ],
                zoom: a.zoom || 0,
                pitch: a.pitch || 0,
                bearing: a.bearing || 0
            }), t.gl) {
                const u = HTMLCanvasElement.prototype.getContext;
                HTMLCanvasElement.prototype.getContext = ()=>(HTMLCanvasElement.prototype.getContext = u, t.gl);
            }
            const l = new this._MapClass(r);
            a.padding && l.setPadding(a.padding), t.cursor && (l.getCanvas().style.cursor = t.cursor), l.transformCameraUpdate = this._onCameraUpdate, l.on("style.load", ()=>{
                this._styleComponents = {
                    light: l.getLight(),
                    sky: l.getSky(),
                    projection: l.getProjection?.(),
                    terrain: l.getTerrain()
                }, this._updateStyleComponents(this.props);
            }), l.on("sourcedata", ()=>{
                this._updateStyleComponents(this.props);
            });
            for(const u in ab)l.on(u, this._onPointerEvent);
            for(const u in ob)l.on(u, this._onCameraEvent);
            for(const u in lb)l.on(u, this._onEvent);
            this._map = l;
        }
        recycle() {
            this.map.getContainer().querySelector("[mapboxgl-children]")?.remove(), Ws.savedMaps.push(this);
        }
        destroy() {
            this._map.remove();
        }
        redraw() {
            const e = this._map;
            e.style && (e._frame && (e._frame.cancel(), e._frame = null), e._render());
        }
        _updateSize(e) {
            const { viewState: t } = e;
            if (t) {
                const i = this._map;
                if (t.width !== i.transform.width || t.height !== i.transform.height) return i.resize(), !0;
            }
            return !1;
        }
        _updateViewState(e) {
            const t = this._map, i = t.transform;
            if (!t.isMoving()) {
                const a = ib(i, e);
                if (Object.keys(a).length > 0) return this._internalUpdate = !0, t.jumpTo(a), this._internalUpdate = !1, !0;
            }
            return !1;
        }
        _updateSettings(e, t) {
            const i = this._map;
            let r = !1;
            for (const a of PS)a in e && !Fn(e[a], t[a]) && (r = !0, i[`set${a[0].toUpperCase()}${a.slice(1)}`]?.call(i, e[a]));
            return r;
        }
        _updateStyle(e, t) {
            if (e.cursor !== t.cursor && (this._map.getCanvas().style.cursor = e.cursor || ""), e.mapStyle !== t.mapStyle) {
                const { mapStyle: i = sb, styleDiffing: r = !0 } = e, a = {
                    diff: r
                };
                "localIdeographFontFamily" in e && (a.localIdeographFontFamily = e.localIdeographFontFamily), this._map.setStyle(rb(i), a);
            }
        }
        _updateStyleComponents({ light: e, projection: t, sky: i, terrain: r }) {
            const a = this._map, l = this._styleComponents;
            a.style._loaded && (e && !Fn(e, l.light) && (l.light = e, a.setLight(e)), t && !Fn(t, l.projection) && t !== l.projection?.type && (l.projection = typeof t == "string" ? {
                type: t
            } : t, a.setProjection?.(l.projection)), i && !Fn(i, l.sky) && (l.sky = i, a.setSky(i)), r !== void 0 && !Fn(r, l.terrain) && (!r || a.getSource(r.source)) && (l.terrain = r, a.setTerrain(r)));
        }
        _updateHandlers(e, t) {
            const i = this._map;
            for (const r of DS){
                const a = e[r] ?? !0, l = t[r] ?? !0;
                Fn(a, l) || (a ? i[r].enable(a) : i[r].disable());
            }
        }
        _queryRenderedFeatures(e) {
            const t = this._map, { interactiveLayerIds: i = [] } = this.props;
            try {
                return t.queryRenderedFeatures(e, {
                    layers: i.filter(t.getLayer.bind(t))
                });
            } catch  {
                return [];
            }
        }
        _updateHover(e) {
            const { props: t } = this;
            if (t.interactiveLayerIds && (t.onMouseMove || t.onMouseEnter || t.onMouseLeave)) {
                const r = e.type, a = this._hoveredFeatures?.length > 0, l = this._queryRenderedFeatures(e.point), u = l.length > 0;
                !u && a && (e.type = "mouseleave", this._onPointerEvent(e)), this._hoveredFeatures = l, u && !a && (e.type = "mouseenter", this._onPointerEvent(e)), e.type = r;
            } else this._hoveredFeatures = null;
        }
    }
    Ws.savedMaps = [];
    const kS = [
        "setMaxBounds",
        "setMinZoom",
        "setMaxZoom",
        "setMinPitch",
        "setMaxPitch",
        "setRenderWorldCopies",
        "setProjection",
        "setStyle",
        "addSource",
        "removeSource",
        "addLayer",
        "removeLayer",
        "setLayerZoomRange",
        "setFilter",
        "setPaintProperty",
        "setLayoutProperty",
        "setLight",
        "setTerrain",
        "setFog",
        "remove"
    ];
    function US(n) {
        if (!n) return null;
        const e = n.map, t = {
            getMap: ()=>e
        };
        for (const i of BS(e))!(i in t) && !kS.includes(i) && (t[i] = e[i].bind(e));
        return t;
    }
    function BS(n) {
        const e = new Set;
        let t = n;
        for(; t;){
            for (const i of Object.getOwnPropertyNames(t))i[0] !== "_" && typeof n[i] == "function" && i !== "fire" && i !== "setEventedParent" && e.add(i);
            t = Object.getPrototypeOf(t);
        }
        return Array.from(e);
    }
    const LS = typeof document < "u" ? Q.useLayoutEffect : Q.useEffect;
    function FS(n, e) {
        const { RTLTextPlugin: t, maxParallelImageRequests: i, workerCount: r, workerUrl: a } = e;
        if (t && n.getRTLTextPluginStatus && n.getRTLTextPluginStatus() === "unavailable") {
            const { pluginUrl: l, lazy: u = !0 } = typeof t == "string" ? {
                pluginUrl: t
            } : t;
            n.setRTLTextPlugin(l, (h)=>{
                h && console.error(h);
            }, u);
        }
        i !== void 0 && n.setMaxParallelImageRequests(i), r !== void 0 && n.setWorkerCount(r), a !== void 0 && n.setWorkerUrl(a);
    }
    const Zc = Q.createContext(null);
    function zS(n, e) {
        const t = Q.useContext(OS), [i, r] = Q.useState(null), a = Q.useRef(), { current: l } = Q.useRef({
            mapLib: null,
            map: null
        });
        Q.useEffect(()=>{
            const d = n.mapLib;
            let p = !0, _;
            return Promise.resolve(d || MS(()=>import("./maplibre-gl-fD2gdbVq.js").then((y)=>y.m), [])).then((y)=>{
                if (!p) return;
                if (!y) throw new Error("Invalid mapLib");
                const v = "Map" in y ? y : y.default;
                if (!v.Map) throw new Error("Invalid mapLib");
                FS(v, n), n.reuseMaps && (_ = Ws.reuse(n, a.current)), _ || (_ = new Ws(v.Map, n, a.current)), l.map = US(_), l.mapLib = v, r(_), t?.onMapMount(l.map, n.id);
            }).catch((y)=>{
                const { onError: v } = n;
                v ? v({
                    type: "error",
                    target: null,
                    originalEvent: null,
                    error: y
                }) : console.error(y);
            }), ()=>{
                p = !1, _ && (t?.onMapUnmount(n.id), n.reuseMaps ? _.recycle() : _.destroy());
            };
        }, []), LS(()=>{
            i && i.setProps(n);
        }), Q.useImperativeHandle(e, ()=>l.map, [
            i
        ]);
        const u = Q.useMemo(()=>({
                position: "relative",
                width: "100%",
                height: "100%",
                ...n.style
            }), [
            n.style
        ]), h = {
            height: "100%"
        };
        return Q.createElement("div", {
            id: n.id,
            ref: a,
            style: u
        }, i && Q.createElement(Zc.Provider, {
            value: l
        }, Q.createElement("div", {
            "mapboxgl-children": "",
            style: h
        }, n.children)));
    }
    const VS = Q.forwardRef(zS);
    var qv = Yv();
    const HS = /box|flex|grid|column|lineHeight|fontWeight|opacity|order|tabSize|zIndex/;
    function gi(n, e) {
        if (!n || !e) return;
        const t = n.style;
        for(const i in e){
            const r = e[i];
            Number.isFinite(r) && !HS.test(i) ? t[i] = `${r}px` : t[i] = r;
        }
    }
    function Kv(n, e) {
        if (n === e) return null;
        const t = cb(n), i = cb(e), r = [];
        for (const a of i)t.has(a) || r.push(a);
        for (const a of t)i.has(a) || r.push(a);
        return r.length === 0 ? null : r;
    }
    function cb(n) {
        return new Set(n ? n.trim().split(/\s+/) : []);
    }
    Q.memo(Q.forwardRef((n, e)=>{
        const { map: t, mapLib: i } = Q.useContext(Zc), r = Q.useRef({
            props: n
        }), a = Q.useMemo(()=>{
            let B = !1;
            Q.Children.forEach(n.children, (U)=>{
                U && (B = !0);
            });
            const H = {
                ...n,
                element: B ? document.createElement("div") : void 0
            }, O = new i.Marker(H);
            return O.setLngLat([
                n.longitude,
                n.latitude
            ]), O.getElement().addEventListener("click", (U)=>{
                r.current.props.onClick?.({
                    type: "click",
                    target: O,
                    originalEvent: U
                });
            }), O.on("dragstart", (U)=>{
                const L = U;
                L.lngLat = a.getLngLat(), r.current.props.onDragStart?.(L);
            }), O.on("drag", (U)=>{
                const L = U;
                L.lngLat = a.getLngLat(), r.current.props.onDrag?.(L);
            }), O.on("dragend", (U)=>{
                const L = U;
                L.lngLat = a.getLngLat(), r.current.props.onDragEnd?.(L);
            }), O;
        }, []);
        Q.useEffect(()=>(a.addTo(t.getMap()), ()=>{
                a.remove();
            }), []);
        const { longitude: l, latitude: u, offset: h, style: d, draggable: p = !1, popup: _ = null, rotation: y = 0, rotationAlignment: v = "auto", pitchAlignment: S = "auto" } = n;
        Q.useEffect(()=>{
            gi(a.getElement(), d);
        }, [
            d
        ]), Q.useImperativeHandle(e, ()=>a, []);
        const E = r.current.props;
        (a.getLngLat().lng !== l || a.getLngLat().lat !== u) && a.setLngLat([
            l,
            u
        ]), h && !IS(a.getOffset(), h) && a.setOffset(h), a.isDraggable() !== p && a.setDraggable(p), a.getRotation() !== y && a.setRotation(y), a.getRotationAlignment() !== v && a.setRotationAlignment(v), a.getPitchAlignment() !== S && a.setPitchAlignment(S), a.getPopup() !== _ && a.setPopup(_);
        const M = Kv(E.className, n.className);
        if (M) for (const B of M)a.toggleClassName(B);
        return r.current.props = n, qv.createPortal(n.children, a.getElement());
    }));
    Q.memo(Q.forwardRef((n, e)=>{
        const { map: t, mapLib: i } = Q.useContext(Zc), r = Q.useMemo(()=>document.createElement("div"), []), a = Q.useRef({
            props: n
        }), l = Q.useMemo(()=>{
            const u = {
                ...n
            }, h = new i.Popup(u);
            return h.setLngLat([
                n.longitude,
                n.latitude
            ]), h.once("open", (d)=>{
                a.current.props.onOpen?.(d);
            }), h;
        }, []);
        if (Q.useEffect(()=>{
            const u = (h)=>{
                a.current.props.onClose?.(h);
            };
            return l.on("close", u), l.setDOMContent(r).addTo(t.getMap()), ()=>{
                l.off("close", u), l.isOpen() && l.remove();
            };
        }, []), Q.useEffect(()=>{
            gi(l.getElement(), n.style);
        }, [
            n.style
        ]), Q.useImperativeHandle(e, ()=>l, []), l.isOpen()) {
            const u = a.current.props;
            (l.getLngLat().lng !== n.longitude || l.getLngLat().lat !== n.latitude) && l.setLngLat([
                n.longitude,
                n.latitude
            ]), n.offset && !Fn(u.offset, n.offset) && l.setOffset(n.offset), (u.anchor !== n.anchor || u.maxWidth !== n.maxWidth) && (l.options.anchor = n.anchor, l.setMaxWidth(n.maxWidth));
            const h = Kv(u.className, n.className);
            if (h) for (const d of h)l.toggleClassName(d);
            a.current.props = n;
        }
        return qv.createPortal(n.children, r);
    }));
    function Pr(n, e, t, i) {
        const r = Q.useContext(Zc), a = Q.useMemo(()=>n(r), []);
        return Q.useEffect(()=>{
            const l = e, u = null, h = typeof e == "function" ? e : null, { map: d } = r;
            return d.hasControl(a) || (d.addControl(a, l?.position), u && u(r)), ()=>{
                h && h(r), d.hasControl(a) && d.removeControl(a);
            };
        }, []), a;
    }
    function jS(n) {
        const e = Pr(({ mapLib: t })=>new t.AttributionControl(n), {
            position: n.position
        });
        return Q.useEffect(()=>{
            gi(e._container, n.style);
        }, [
            n.style
        ]), null;
    }
    Q.memo(jS);
    function WS(n) {
        const e = Pr(({ mapLib: t })=>new t.FullscreenControl({
                container: n.containerId && document.getElementById(n.containerId)
            }), {
            position: n.position
        });
        return Q.useEffect(()=>{
            gi(e._controlContainer, n.style);
        }, [
            n.style
        ]), null;
    }
    Q.memo(WS);
    function $S(n, e) {
        const t = Q.useRef({
            props: n
        }), i = Pr(({ mapLib: r })=>{
            const a = new r.GeolocateControl(n), l = a._setupUI;
            return a._setupUI = ()=>{
                a._container.hasChildNodes() || l();
            }, a.on("geolocate", (u)=>{
                t.current.props.onGeolocate?.(u);
            }), a.on("error", (u)=>{
                t.current.props.onError?.(u);
            }), a.on("outofmaxbounds", (u)=>{
                t.current.props.onOutOfMaxBounds?.(u);
            }), a.on("trackuserlocationstart", (u)=>{
                t.current.props.onTrackUserLocationStart?.(u);
            }), a.on("trackuserlocationend", (u)=>{
                t.current.props.onTrackUserLocationEnd?.(u);
            }), a;
        }, {
            position: n.position
        });
        return t.current.props = n, Q.useImperativeHandle(e, ()=>i, []), Q.useEffect(()=>{
            gi(i._container, n.style);
        }, [
            n.style
        ]), null;
    }
    Q.memo(Q.forwardRef($S));
    function XS(n) {
        const e = Pr(({ mapLib: t })=>new t.NavigationControl(n), {
            position: n.position
        });
        return Q.useEffect(()=>{
            gi(e._container, n.style);
        }, [
            n.style
        ]), null;
    }
    Q.memo(XS);
    function YS(n) {
        const e = Pr(({ mapLib: a })=>new a.ScaleControl(n), {
            position: n.position
        }), t = Q.useRef(n), i = t.current;
        t.current = n;
        const { style: r } = n;
        return n.maxWidth !== void 0 && n.maxWidth !== i.maxWidth && (e.options.maxWidth = n.maxWidth), n.unit !== void 0 && n.unit !== i.unit && e.setUnit(n.unit), Q.useEffect(()=>{
            gi(e._container, r);
        }, [
            r
        ]), null;
    }
    Q.memo(YS);
    function qS(n) {
        const e = Pr(({ mapLib: t })=>new t.TerrainControl(n), {
            position: n.position
        });
        return Q.useEffect(()=>{
            gi(e._container, n.style);
        }, [
            n.style
        ]), null;
    }
    Q.memo(qS);
    function KS(n) {
        const e = Pr(({ mapLib: t })=>new t.LogoControl(n), {
            position: n.position
        });
        return Q.useEffect(()=>{
            gi(e._container, n.style);
        }, [
            n.style
        ]), null;
    }
    Q.memo(KS);
    function vc(n, e) {
        if (!n) throw new Error(e || "loader assertion failed.");
    }
    const ig = !!(typeof process != "object" || String(process) !== "[object process]" || process.browser), ub = typeof process < "u" && process.version && /v([0-9]*)/.exec(process.version);
    ub && parseFloat(ub[1]);
    const fb = globalThis, hb = globalThis.process || {}, ZS = globalThis.navigator || {};
    function Zv(n) {
        if (typeof window < "u" && window.process?.type === "renderer" || typeof process < "u" && process.versions?.electron) return !0;
        const t = typeof navigator < "u" && navigator.userAgent;
        return !!(t && t.indexOf("Electron") >= 0);
    }
    function Dr() {
        return !(typeof process == "object" && String(process) === "[object process]" && !process?.browser) || Zv();
    }
    function QS(n) {
        return Dr() ? Zv() ? "Electron" : (ZS.userAgent || "").indexOf("Edge") > -1 ? "Edge" : globalThis.chrome ? "Chrome" : globalThis.safari ? "Safari" : globalThis.mozInnerScreenX ? "Firefox" : "Unknown" : "Node";
    }
    const Qv = "4.1.0";
    function GS(n) {
        try {
            const e = window[n], t = "__storage_test__";
            return e.setItem(t, t), e.removeItem(t), e;
        } catch  {
            return null;
        }
    }
    class JS {
        constructor(e, t, i = "sessionStorage"){
            this.storage = GS(i), this.id = e, this.config = t, this._loadConfiguration();
        }
        getConfiguration() {
            return this.config;
        }
        setConfiguration(e) {
            if (Object.assign(this.config, e), this.storage) {
                const t = JSON.stringify(this.config);
                this.storage.setItem(this.id, t);
            }
        }
        _loadConfiguration() {
            let e = {};
            if (this.storage) {
                const t = this.storage.getItem(this.id);
                e = t ? JSON.parse(t) : {};
            }
            return Object.assign(this.config, e), this;
        }
    }
    function eA(n) {
        let e;
        return n < 10 ? e = `${n.toFixed(2)}ms` : n < 100 ? e = `${n.toFixed(1)}ms` : n < 1e3 ? e = `${n.toFixed(0)}ms` : e = `${(n / 1e3).toFixed(2)}s`, e;
    }
    function tA(n, e = 8) {
        const t = Math.max(e - n.length, 0);
        return `${" ".repeat(t)}${n}`;
    }
    var Tc;
    (function(n) {
        n[n.BLACK = 30] = "BLACK", n[n.RED = 31] = "RED", n[n.GREEN = 32] = "GREEN", n[n.YELLOW = 33] = "YELLOW", n[n.BLUE = 34] = "BLUE", n[n.MAGENTA = 35] = "MAGENTA", n[n.CYAN = 36] = "CYAN", n[n.WHITE = 37] = "WHITE", n[n.BRIGHT_BLACK = 90] = "BRIGHT_BLACK", n[n.BRIGHT_RED = 91] = "BRIGHT_RED", n[n.BRIGHT_GREEN = 92] = "BRIGHT_GREEN", n[n.BRIGHT_YELLOW = 93] = "BRIGHT_YELLOW", n[n.BRIGHT_BLUE = 94] = "BRIGHT_BLUE", n[n.BRIGHT_MAGENTA = 95] = "BRIGHT_MAGENTA", n[n.BRIGHT_CYAN = 96] = "BRIGHT_CYAN", n[n.BRIGHT_WHITE = 97] = "BRIGHT_WHITE";
    })(Tc || (Tc = {}));
    const nA = 10;
    function db(n) {
        return typeof n != "string" ? n : (n = n.toUpperCase(), Tc[n] || Tc.WHITE);
    }
    function iA(n, e, t) {
        return !Dr && typeof n == "string" && (e && (n = `\x1B[${db(e)}m${n}\x1B[39m`), t && (n = `\x1B[${db(t) + nA}m${n}\x1B[49m`)), n;
    }
    function rA(n, e = [
        "constructor"
    ]) {
        const t = Object.getPrototypeOf(n), i = Object.getOwnPropertyNames(t), r = n;
        for (const a of i){
            const l = r[a];
            typeof l == "function" && (e.find((u)=>a === u) || (r[a] = l.bind(n)));
        }
    }
    function rg(n, e) {
        if (!n) throw new Error("Assertion failed");
    }
    function ws() {
        let n;
        if (Dr() && fb.performance) n = fb?.performance?.now?.();
        else if ("hrtime" in hb) {
            const e = hb?.hrtime?.();
            n = e[0] * 1e3 + e[1] / 1e6;
        } else n = Date.now();
        return n;
    }
    const Es = {
        debug: Dr() && console.debug || console.log,
        log: console.log,
        info: console.info,
        warn: console.warn,
        error: console.error
    }, sA = {
        enabled: !0,
        level: 0
    };
    function Rs() {}
    const gb = {}, pb = {
        once: !0
    };
    class Co {
        constructor({ id: e } = {
            id: ""
        }){
            this.VERSION = Qv, this._startTs = ws(), this._deltaTs = ws(), this.userData = {}, this.LOG_THROTTLE_TIMEOUT = 0, this.id = e, this.userData = {}, this._storage = new JS(`__probe-${this.id}__`, sA), this.timeStamp(`${this.id} started`), rA(this), Object.seal(this);
        }
        set level(e) {
            this.setLevel(e);
        }
        get level() {
            return this.getLevel();
        }
        isEnabled() {
            return this._storage.config.enabled;
        }
        getLevel() {
            return this._storage.config.level;
        }
        getTotal() {
            return Number((ws() - this._startTs).toPrecision(10));
        }
        getDelta() {
            return Number((ws() - this._deltaTs).toPrecision(10));
        }
        set priority(e) {
            this.level = e;
        }
        get priority() {
            return this.level;
        }
        getPriority() {
            return this.level;
        }
        enable(e = !0) {
            return this._storage.setConfiguration({
                enabled: e
            }), this;
        }
        setLevel(e) {
            return this._storage.setConfiguration({
                level: e
            }), this;
        }
        get(e) {
            return this._storage.config[e];
        }
        set(e, t) {
            this._storage.setConfiguration({
                [e]: t
            });
        }
        settings() {
            console.table ? console.table(this._storage.config) : console.log(this._storage.config);
        }
        assert(e, t) {
            if (!e) throw new Error(t || "Assertion failed");
        }
        warn(e) {
            return this._getLogFunction(0, e, Es.warn, arguments, pb);
        }
        error(e) {
            return this._getLogFunction(0, e, Es.error, arguments);
        }
        deprecated(e, t) {
            return this.warn(`\`${e}\` is deprecated and will be removed in a later version. Use \`${t}\` instead`);
        }
        removed(e, t) {
            return this.error(`\`${e}\` has been removed. Use \`${t}\` instead`);
        }
        probe(e, t) {
            return this._getLogFunction(e, t, Es.log, arguments, {
                time: !0,
                once: !0
            });
        }
        log(e, t) {
            return this._getLogFunction(e, t, Es.debug, arguments);
        }
        info(e, t) {
            return this._getLogFunction(e, t, console.info, arguments);
        }
        once(e, t) {
            return this._getLogFunction(e, t, Es.debug || Es.info, arguments, pb);
        }
        table(e, t, i) {
            return t ? this._getLogFunction(e, t, console.table || Rs, i && [
                i
            ], {
                tag: oA(t)
            }) : Rs;
        }
        time(e, t) {
            return this._getLogFunction(e, t, console.time ? console.time : console.info);
        }
        timeEnd(e, t) {
            return this._getLogFunction(e, t, console.timeEnd ? console.timeEnd : console.info);
        }
        timeStamp(e, t) {
            return this._getLogFunction(e, t, console.timeStamp || Rs);
        }
        group(e, t, i = {
            collapsed: !1
        }) {
            const r = mb({
                logLevel: e,
                message: t,
                opts: i
            }), { collapsed: a } = i;
            return r.method = (a ? console.groupCollapsed : console.group) || console.info, this._getLogFunction(r);
        }
        groupCollapsed(e, t, i = {}) {
            return this.group(e, t, Object.assign({}, i, {
                collapsed: !0
            }));
        }
        groupEnd(e) {
            return this._getLogFunction(e, "", console.groupEnd || Rs);
        }
        withGroup(e, t, i) {
            this.group(e, t)();
            try {
                i();
            } finally{
                this.groupEnd(e)();
            }
        }
        trace() {
            console.trace && console.trace();
        }
        _shouldLog(e) {
            return this.isEnabled() && this.getLevel() >= Gv(e);
        }
        _getLogFunction(e, t, i, r, a) {
            if (this._shouldLog(e)) {
                a = mb({
                    logLevel: e,
                    message: t,
                    args: r,
                    opts: a
                }), i = i || a.method, rg(i), a.total = this.getTotal(), a.delta = this.getDelta(), this._deltaTs = ws();
                const l = a.tag || a.message;
                if (a.once && l) if (!gb[l]) gb[l] = ws();
                else return Rs;
                return t = aA(this.id, a.message, a), i.bind(console, t, ...a.args);
            }
            return Rs;
        }
    }
    Co.VERSION = Qv;
    function Gv(n) {
        if (!n) return 0;
        let e;
        switch(typeof n){
            case "number":
                e = n;
                break;
            case "object":
                e = n.logLevel || n.priority || 0;
                break;
            default:
                return 0;
        }
        return rg(Number.isFinite(e) && e >= 0), e;
    }
    function mb(n) {
        const { logLevel: e, message: t } = n;
        n.logLevel = Gv(e);
        const i = n.args ? Array.from(n.args) : [];
        for(; i.length && i.shift() !== t;);
        switch(typeof e){
            case "string":
            case "function":
                t !== void 0 && i.unshift(t), n.message = e;
                break;
            case "object":
                Object.assign(n, e);
                break;
        }
        typeof n.message == "function" && (n.message = n.message());
        const r = typeof n.message;
        return rg(r === "string" || r === "object"), Object.assign(n, {
            args: i
        }, n.opts);
    }
    function aA(n, e, t) {
        if (typeof e == "string") {
            const i = t.time ? tA(eA(t.total)) : "";
            e = t.time ? `${n}: ${i}  ${e}` : `${n}: ${e}`, e = iA(e, t.color, t.background);
        }
        return e;
    }
    function oA(n) {
        for(const e in n)for(const t in n[e])return t || "untitled";
        return "empty";
    }
    const Mh = "4.3.2", lA = Mh[0] >= "0" && Mh[0] <= "9" ? `v${Mh}` : "";
    function cA() {
        const n = new Co({
            id: "loaders.gl"
        });
        return globalThis.loaders = globalThis.loaders || {}, globalThis.loaders.log = n, globalThis.loaders.version = lA, globalThis.probe = globalThis.probe || {}, globalThis.probe.loaders = n, n;
    }
    const uA = cA();
    function fA(n, e) {
        return Jv(n || {}, e);
    }
    function Jv(n, e, t = 0) {
        if (t > 3) return e;
        const i = {
            ...n
        };
        for (const [r, a] of Object.entries(e))a && typeof a == "object" && !Array.isArray(a) ? i[r] = Jv(i[r] || {}, e[r], t + 1) : i[r] = e[r];
        return i;
    }
    const hA = "latest";
    function dA() {
        return globalThis._loadersgl_?.version || (globalThis._loadersgl_ = globalThis._loadersgl_ || {}, globalThis._loadersgl_.version = "4.3.2"), globalThis._loadersgl_.version;
    }
    const gA = dA();
    function Qi(n, e) {
        if (!n) throw new Error(e || "loaders.gl assertion failed.");
    }
    const Ar = typeof process != "object" || String(process) !== "[object process]" || process.browser, pA = typeof window < "u" && typeof window.orientation < "u", _b = typeof process < "u" && process.version && /v([0-9]*)/.exec(process.version);
    _b && parseFloat(_b[1]);
    class mA {
        name;
        workerThread;
        isRunning = !0;
        result;
        _resolve = ()=>{};
        _reject = ()=>{};
        constructor(e, t){
            this.name = e, this.workerThread = t, this.result = new Promise((i, r)=>{
                this._resolve = i, this._reject = r;
            });
        }
        postMessage(e, t) {
            this.workerThread.postMessage({
                source: "loaders.gl",
                type: e,
                payload: t
            });
        }
        done(e) {
            Qi(this.isRunning), this.isRunning = !1, this._resolve(e);
        }
        error(e) {
            Qi(this.isRunning), this.isRunning = !1, this._reject(e);
        }
    }
    class Oh {
        terminate() {}
    }
    const Ih = new Map;
    function _A(n) {
        Qi(n.source && !n.url || !n.source && n.url);
        let e = Ih.get(n.source || n.url);
        return e || (n.url && (e = yA(n.url), Ih.set(n.url, e)), n.source && (e = e3(n.source), Ih.set(n.source, e))), Qi(e), e;
    }
    function yA(n) {
        if (!n.startsWith("http")) return n;
        const e = bA(n);
        return e3(e);
    }
    function e3(n) {
        const e = new Blob([
            n
        ], {
            type: "application/javascript"
        });
        return URL.createObjectURL(e);
    }
    function bA(n) {
        return `try {
  importScripts('${n}');
} catch (error) {
  console.error(error);
  throw error;
}`;
    }
    function t3(n, e = !0, t) {
        const i = t || new Set;
        if (n) {
            if (yb(n)) i.add(n);
            else if (yb(n.buffer)) i.add(n.buffer);
            else if (!ArrayBuffer.isView(n)) {
                if (e && typeof n == "object") for(const r in n)t3(n[r], e, i);
            }
        }
        return t === void 0 ? Array.from(i) : [];
    }
    function yb(n) {
        return n ? n instanceof ArrayBuffer || typeof MessagePort < "u" && n instanceof MessagePort || typeof ImageBitmap < "u" && n instanceof ImageBitmap || typeof OffscreenCanvas < "u" && n instanceof OffscreenCanvas : !1;
    }
    const Nh = ()=>{};
    class _d {
        name;
        source;
        url;
        terminated = !1;
        worker;
        onMessage;
        onError;
        _loadableURL = "";
        static isSupported() {
            return typeof Worker < "u" && Ar || typeof Oh < "u" && !Ar;
        }
        constructor(e){
            const { name: t, source: i, url: r } = e;
            Qi(i || r), this.name = t, this.source = i, this.url = r, this.onMessage = Nh, this.onError = (a)=>console.log(a), this.worker = Ar ? this._createBrowserWorker() : this._createNodeWorker();
        }
        destroy() {
            this.onMessage = Nh, this.onError = Nh, this.worker.terminate(), this.terminated = !0;
        }
        get isRunning() {
            return !!this.onMessage;
        }
        postMessage(e, t) {
            t = t || t3(e), this.worker.postMessage(e, t);
        }
        _getErrorFromErrorEvent(e) {
            let t = "Failed to load ";
            return t += `worker ${this.name} from ${this.url}. `, e.message && (t += `${e.message} in `), e.lineno && (t += `:${e.lineno}:${e.colno}`), new Error(t);
        }
        _createBrowserWorker() {
            this._loadableURL = _A({
                source: this.source,
                url: this.url
            });
            const e = new Worker(this._loadableURL, {
                name: this.name
            });
            return e.onmessage = (t)=>{
                t.data ? this.onMessage(t.data) : this.onError(new Error("No data received"));
            }, e.onerror = (t)=>{
                this.onError(this._getErrorFromErrorEvent(t)), this.terminated = !0;
            }, e.onmessageerror = (t)=>console.error(t), e;
        }
        _createNodeWorker() {
            let e;
            if (this.url) {
                const i = this.url.includes(":/") || this.url.startsWith("/") ? this.url : `./${this.url}`;
                e = new Oh(i, {
                    eval: !1
                });
            } else if (this.source) e = new Oh(this.source, {
                eval: !0
            });
            else throw new Error("no worker");
            return e.on("message", (t)=>{
                this.onMessage(t);
            }), e.on("error", (t)=>{
                this.onError(t);
            }), e.on("exit", (t)=>{}), e;
        }
    }
    let vA = class {
        name = "unnamed";
        source;
        url;
        maxConcurrency = 1;
        maxMobileConcurrency = 1;
        onDebug = ()=>{};
        reuseWorkers = !0;
        props = {};
        jobQueue = [];
        idleQueue = [];
        count = 0;
        isDestroyed = !1;
        static isSupported() {
            return _d.isSupported();
        }
        constructor(e){
            this.source = e.source, this.url = e.url, this.setProps(e);
        }
        destroy() {
            this.idleQueue.forEach((e)=>e.destroy()), this.isDestroyed = !0;
        }
        setProps(e) {
            this.props = {
                ...this.props,
                ...e
            }, e.name !== void 0 && (this.name = e.name), e.maxConcurrency !== void 0 && (this.maxConcurrency = e.maxConcurrency), e.maxMobileConcurrency !== void 0 && (this.maxMobileConcurrency = e.maxMobileConcurrency), e.reuseWorkers !== void 0 && (this.reuseWorkers = e.reuseWorkers), e.onDebug !== void 0 && (this.onDebug = e.onDebug);
        }
        async startJob(e, t = (r, a, l)=>r.done(l), i = (r, a)=>r.error(a)) {
            const r = new Promise((a)=>(this.jobQueue.push({
                    name: e,
                    onMessage: t,
                    onError: i,
                    onStart: a
                }), this));
            return this._startQueuedJob(), await r;
        }
        async _startQueuedJob() {
            if (!this.jobQueue.length) return;
            const e = this._getAvailableWorker();
            if (!e) return;
            const t = this.jobQueue.shift();
            if (t) {
                this.onDebug({
                    message: "Starting job",
                    name: t.name,
                    workerThread: e,
                    backlog: this.jobQueue.length
                });
                const i = new mA(t.name, e);
                e.onMessage = (r)=>t.onMessage(i, r.type, r.payload), e.onError = (r)=>t.onError(i, r), t.onStart(i);
                try {
                    await i.result;
                } catch (r) {
                    console.error(`Worker exception: ${r}`);
                } finally{
                    this.returnWorkerToQueue(e);
                }
            }
        }
        returnWorkerToQueue(e) {
            !Ar || this.isDestroyed || !this.reuseWorkers || this.count > this._getMaxConcurrency() ? (e.destroy(), this.count--) : this.idleQueue.push(e), this.isDestroyed || this._startQueuedJob();
        }
        _getAvailableWorker() {
            if (this.idleQueue.length > 0) return this.idleQueue.shift() || null;
            if (this.count < this._getMaxConcurrency()) {
                this.count++;
                const e = `${this.name.toLowerCase()} (#${this.count} of ${this.maxConcurrency})`;
                return new _d({
                    name: e,
                    source: this.source,
                    url: this.url
                });
            }
            return null;
        }
        _getMaxConcurrency() {
            return pA ? this.maxMobileConcurrency : this.maxConcurrency;
        }
    };
    const TA = {
        maxConcurrency: 3,
        maxMobileConcurrency: 1,
        reuseWorkers: !0,
        onDebug: ()=>{}
    };
    class Wi {
        props;
        workerPools = new Map;
        static _workerFarm;
        static isSupported() {
            return _d.isSupported();
        }
        static getWorkerFarm(e = {}) {
            return Wi._workerFarm = Wi._workerFarm || new Wi({}), Wi._workerFarm.setProps(e), Wi._workerFarm;
        }
        constructor(e){
            this.props = {
                ...TA
            }, this.setProps(e), this.workerPools = new Map;
        }
        destroy() {
            for (const e of this.workerPools.values())e.destroy();
            this.workerPools = new Map;
        }
        setProps(e) {
            this.props = {
                ...this.props,
                ...e
            };
            for (const t of this.workerPools.values())t.setProps(this._getWorkerPoolProps());
        }
        getWorkerPool(e) {
            const { name: t, source: i, url: r } = e;
            let a = this.workerPools.get(t);
            return a || (a = new vA({
                name: t,
                source: i,
                url: r
            }), a.setProps(this._getWorkerPoolProps()), this.workerPools.set(t, a)), a;
        }
        _getWorkerPoolProps() {
            return {
                maxConcurrency: this.props.maxConcurrency,
                maxMobileConcurrency: this.props.maxMobileConcurrency,
                reuseWorkers: this.props.reuseWorkers,
                onDebug: this.props.onDebug
            };
        }
    }
    function xA(n, e = {}) {
        const t = e[n.id] || {}, i = Ar ? `${n.id}-worker.js` : `${n.id}-worker-node.js`;
        let r = t.workerUrl;
        if (!r && n.id === "compression" && (r = e.workerUrl), e._workerType === "test" && (Ar ? r = `modules/${n.module}/dist/${i}` : r = `modules/${n.module}/src/workers/${n.id}-worker-node.ts`), !r) {
            let a = n.version;
            a === "latest" && (a = hA);
            const l = a ? `@${a}` : "";
            r = `https://unpkg.com/@loaders.gl/${n.module}${l}/dist/${i}`;
        }
        return Qi(r), r;
    }
    function SA(n, e = gA) {
        Qi(n, "no worker provided");
        const t = n.version;
        return !(!e || !t);
    }
    function AA(n, e) {
        return !Wi.isSupported() || !Ar && !e?._nodeWorkers ? !1 : n.worker && e?.worker;
    }
    async function wA(n, e, t, i, r) {
        const a = n.id, l = xA(n, t), h = Wi.getWorkerFarm(t).getWorkerPool({
            name: a,
            url: l
        });
        t = JSON.parse(JSON.stringify(t)), i = JSON.parse(JSON.stringify(i || {}));
        const d = await h.startJob("process-on-worker", EA.bind(null, r));
        return d.postMessage("process", {
            input: e,
            options: t,
            context: i
        }), await (await d.result).result;
    }
    async function EA(n, e, t, i) {
        switch(t){
            case "done":
                e.done(i);
                break;
            case "error":
                e.error(new Error(i.error));
                break;
            case "process":
                const { id: r, input: a, options: l } = i;
                try {
                    const u = await n(a, l);
                    e.postMessage("done", {
                        id: r,
                        result: u
                    });
                } catch (u) {
                    const h = u instanceof Error ? u.message : "unknown error";
                    e.postMessage("error", {
                        id: r,
                        error: h
                    });
                }
                break;
            default:
                console.warn(`parse-with-worker unknown message ${t}`);
        }
    }
    function RA(n, e, t) {
        if (t = t || n.byteLength, n.byteLength < t || e.byteLength < t) return !1;
        const i = new Uint8Array(n), r = new Uint8Array(e);
        for(let a = 0; a < i.length; ++a)if (i[a] !== r[a]) return !1;
        return !0;
    }
    function CA(...n) {
        return MA(n);
    }
    function MA(n) {
        const e = n.map((a)=>a instanceof ArrayBuffer ? new Uint8Array(a) : a), t = e.reduce((a, l)=>a + l.byteLength, 0), i = new Uint8Array(t);
        let r = 0;
        for (const a of e)i.set(a, r), r += a.byteLength;
        return i.buffer;
    }
    async function OA(n) {
        const e = [];
        for await (const t of n)e.push(t);
        return CA(...e);
    }
    function bb() {
        let n;
        if (typeof window < "u" && window.performance) n = window.performance.now();
        else if (typeof process < "u" && process.hrtime) {
            const e = process.hrtime();
            n = e[0] * 1e3 + e[1] / 1e6;
        } else n = Date.now();
        return n;
    }
    class vb {
        constructor(e, t){
            this.sampleSize = 1, this.time = 0, this.count = 0, this.samples = 0, this.lastTiming = 0, this.lastSampleTime = 0, this.lastSampleCount = 0, this._count = 0, this._time = 0, this._samples = 0, this._startTime = 0, this._timerPending = !1, this.name = e, this.type = t, this.reset();
        }
        reset() {
            return this.time = 0, this.count = 0, this.samples = 0, this.lastTiming = 0, this.lastSampleTime = 0, this.lastSampleCount = 0, this._count = 0, this._time = 0, this._samples = 0, this._startTime = 0, this._timerPending = !1, this;
        }
        setSampleSize(e) {
            return this.sampleSize = e, this;
        }
        incrementCount() {
            return this.addCount(1), this;
        }
        decrementCount() {
            return this.subtractCount(1), this;
        }
        addCount(e) {
            return this._count += e, this._samples++, this._checkSampling(), this;
        }
        subtractCount(e) {
            return this._count -= e, this._samples++, this._checkSampling(), this;
        }
        addTime(e) {
            return this._time += e, this.lastTiming = e, this._samples++, this._checkSampling(), this;
        }
        timeStart() {
            return this._startTime = bb(), this._timerPending = !0, this;
        }
        timeEnd() {
            return this._timerPending ? (this.addTime(bb() - this._startTime), this._timerPending = !1, this._checkSampling(), this) : this;
        }
        getSampleAverageCount() {
            return this.sampleSize > 0 ? this.lastSampleCount / this.sampleSize : 0;
        }
        getSampleAverageTime() {
            return this.sampleSize > 0 ? this.lastSampleTime / this.sampleSize : 0;
        }
        getSampleHz() {
            return this.lastSampleTime > 0 ? this.sampleSize / (this.lastSampleTime / 1e3) : 0;
        }
        getAverageCount() {
            return this.samples > 0 ? this.count / this.samples : 0;
        }
        getAverageTime() {
            return this.samples > 0 ? this.time / this.samples : 0;
        }
        getHz() {
            return this.time > 0 ? this.samples / (this.time / 1e3) : 0;
        }
        _checkSampling() {
            this._samples === this.sampleSize && (this.lastSampleTime = this._time, this.lastSampleCount = this._count, this.count += this._count, this.time += this._time, this.samples += this._samples, this._time = 0, this._count = 0, this._samples = 0);
        }
    }
    class Qc {
        constructor(e){
            this.stats = {}, this.id = e.id, this.stats = {}, this._initializeStats(e.stats), Object.seal(this);
        }
        get(e, t = "count") {
            return this._getOrCreate({
                name: e,
                type: t
            });
        }
        get size() {
            return Object.keys(this.stats).length;
        }
        reset() {
            for (const e of Object.values(this.stats))e.reset();
            return this;
        }
        forEach(e) {
            for (const t of Object.values(this.stats))e(t);
        }
        getTable() {
            const e = {};
            return this.forEach((t)=>{
                e[t.name] = {
                    time: t.time || 0,
                    count: t.count || 0,
                    average: t.getAverageTime() || 0,
                    hz: t.getHz() || 0
                };
            }), e;
        }
        _initializeStats(e = []) {
            e.forEach((t)=>this._getOrCreate(t));
        }
        _getOrCreate(e) {
            const { name: t, type: i } = e;
            let r = this.stats[t];
            return r || (e instanceof vb ? r = e : r = new vb(t, i), this.stats[t] = r), r;
        }
    }
    let IA = "";
    const Tb = {};
    function NA(n) {
        for(const e in Tb)if (n.startsWith(e)) {
            const t = Tb[e];
            n = n.replace(e, t);
        }
        return !n.startsWith("http://") && !n.startsWith("https://") && (n = `${IA}${n}`), n;
    }
    function PA(n) {
        return n && typeof n == "object" && n.isBuffer;
    }
    function n3(n) {
        if (PA(n)) return n;
        if (n instanceof ArrayBuffer) return n;
        if (ArrayBuffer.isView(n)) return n.byteOffset === 0 && n.byteLength === n.buffer.byteLength ? n.buffer : n.buffer.slice(n.byteOffset, n.byteOffset + n.byteLength);
        if (typeof n == "string") {
            const e = n;
            return new TextEncoder().encode(e).buffer;
        }
        if (n && typeof n == "object" && n._toArrayBuffer) return n._toArrayBuffer();
        throw new Error("toArrayBuffer");
    }
    function i3(n) {
        const e = n ? n.lastIndexOf("/") : -1;
        return e >= 0 ? n.substr(e + 1) : "";
    }
    function DA(n) {
        const e = n ? n.lastIndexOf("/") : -1;
        return e >= 0 ? n.substr(0, e) : "";
    }
    const kA = (n)=>typeof n == "boolean", fo = (n)=>typeof n == "function", Mo = (n)=>n !== null && typeof n == "object", xb = (n)=>Mo(n) && n.constructor === {}.constructor, UA = (n)=>!!n && typeof n[Symbol.iterator] == "function", BA = (n)=>n && typeof n[Symbol.asyncIterator] == "function", kr = (n)=>typeof Response < "u" && n instanceof Response || n && n.arrayBuffer && n.text && n.json, Ur = (n)=>typeof Blob < "u" && n instanceof Blob, LA = (n)=>n && typeof n == "object" && n.isBuffer, FA = (n)=>typeof ReadableStream < "u" && n instanceof ReadableStream || Mo(n) && fo(n.tee) && fo(n.cancel) && fo(n.getReader), zA = (n)=>Mo(n) && fo(n.read) && fo(n.pipe) && kA(n.readable), r3 = (n)=>FA(n) || zA(n);
    class VA extends Error {
        constructor(e, t){
            super(e), this.reason = t.reason, this.url = t.url, this.response = t.response;
        }
        reason;
        url;
        response;
    }
    const HA = /^data:([-\w.]+\/[-\w.+]+)(;|,)/, jA = /^([-\w.]+\/[-\w.+]+)/;
    function Sb(n, e) {
        return n.toLowerCase() === e.toLowerCase();
    }
    function WA(n) {
        const e = jA.exec(n);
        return e ? e[1] : n;
    }
    function Ab(n) {
        const e = HA.exec(n);
        return e ? e[1] : "";
    }
    const s3 = /\?.*/;
    function $A(n) {
        const e = n.match(s3);
        return e && e[0];
    }
    function sg(n) {
        return n.replace(s3, "");
    }
    function XA(n) {
        if (n.length < 50) return n;
        const e = n.slice(n.length - 15);
        return `${n.substr(0, 32)}...${e}`;
    }
    function Gc(n) {
        return kr(n) ? n.url : Ur(n) ? n.name || "" : typeof n == "string" ? n : "";
    }
    function ag(n) {
        if (kr(n)) {
            const e = n, t = e.headers.get("content-type") || "", i = sg(e.url);
            return WA(t) || Ab(i);
        }
        return Ur(n) ? n.type || "" : typeof n == "string" ? Ab(n) : "";
    }
    function YA(n) {
        return kr(n) ? n.headers["content-length"] || -1 : Ur(n) ? n.size : typeof n == "string" ? n.length : n instanceof ArrayBuffer || ArrayBuffer.isView(n) ? n.byteLength : -1;
    }
    async function a3(n) {
        if (kr(n)) return n;
        const e = {}, t = YA(n);
        t >= 0 && (e["content-length"] = String(t));
        const i = Gc(n), r = ag(n);
        r && (e["content-type"] = r);
        const a = await ZA(n);
        a && (e["x-first-bytes"] = a), typeof n == "string" && (n = new TextEncoder().encode(n));
        const l = new Response(n, {
            headers: e
        });
        return Object.defineProperty(l, "url", {
            value: i
        }), l;
    }
    async function qA(n) {
        if (!n.ok) throw await KA(n);
    }
    async function KA(n) {
        const e = XA(n.url);
        let t = `Failed to fetch resource (${n.status}) ${n.statusText}: ${e}`;
        t = t.length > 100 ? `${t.slice(0, 100)}...` : t;
        const i = {
            reason: n.statusText,
            url: n.url,
            response: n
        };
        try {
            const r = n.headers.get("Content-Type");
            i.reason = !n.bodyUsed && r?.includes("application/json") ? await n.json() : await n.text();
        } catch  {}
        return new VA(t, i);
    }
    async function ZA(n) {
        if (typeof n == "string") return `data:,${n.slice(0, 5)}`;
        if (n instanceof Blob) {
            const t = n.slice(0, 5);
            return await new Promise((i)=>{
                const r = new FileReader;
                r.onload = (a)=>i(a?.target?.result), r.readAsDataURL(t);
            });
        }
        if (n instanceof ArrayBuffer) {
            const t = n.slice(0, 5);
            return `data:base64,${QA(t)}`;
        }
        return null;
    }
    function QA(n) {
        let e = "";
        const t = new Uint8Array(n);
        for(let i = 0; i < t.byteLength; i++)e += String.fromCharCode(t[i]);
        return btoa(e);
    }
    function GA(n) {
        return !JA(n) && !ew(n);
    }
    function JA(n) {
        return n.startsWith("http:") || n.startsWith("https:");
    }
    function ew(n) {
        return n.startsWith("data:");
    }
    async function wb(n, e) {
        if (typeof n == "string") {
            const t = NA(n);
            return GA(t) && globalThis.loaders?.fetchNode ? globalThis.loaders?.fetchNode(t, e) : await fetch(t, e);
        }
        return await a3(n);
    }
    const Eb = new Co({
        id: "loaders.gl"
    });
    class tw {
        log() {
            return ()=>{};
        }
        info() {
            return ()=>{};
        }
        warn() {
            return ()=>{};
        }
        error() {
            return ()=>{};
        }
    }
    class nw {
        console;
        constructor(){
            this.console = console;
        }
        log(...e) {
            return this.console.log.bind(this.console, ...e);
        }
        info(...e) {
            return this.console.info.bind(this.console, ...e);
        }
        warn(...e) {
            return this.console.warn.bind(this.console, ...e);
        }
        error(...e) {
            return this.console.error.bind(this.console, ...e);
        }
    }
    const o3 = {
        fetch: null,
        mimeType: void 0,
        nothrow: !1,
        log: new nw,
        useLocalLibraries: !1,
        CDN: "https://unpkg.com/@loaders.gl",
        worker: !0,
        maxConcurrency: 3,
        maxMobileConcurrency: 1,
        reuseWorkers: ig,
        _nodeWorkers: !1,
        _workerType: "",
        limit: 0,
        _limitMB: 0,
        batchSize: "auto",
        batchDebounceMs: 0,
        metadata: !1,
        transforms: []
    }, iw = {
        throws: "nothrow",
        dataType: "(no longer used)",
        uri: "baseUri",
        method: "fetch.method",
        headers: "fetch.headers",
        body: "fetch.body",
        mode: "fetch.mode",
        credentials: "fetch.credentials",
        cache: "fetch.cache",
        redirect: "fetch.redirect",
        referrer: "fetch.referrer",
        referrerPolicy: "fetch.referrerPolicy",
        integrity: "fetch.integrity",
        keepalive: "fetch.keepalive",
        signal: "fetch.signal"
    };
    function l3() {
        globalThis.loaders = globalThis.loaders || {};
        const { loaders: n } = globalThis;
        return n._state || (n._state = {}), n._state;
    }
    function c3() {
        const n = l3();
        return n.globalOptions = n.globalOptions || {
            ...o3
        }, n.globalOptions;
    }
    function rw(n, e, t, i) {
        return t = t || [], t = Array.isArray(t) ? t : [
            t
        ], sw(n, t), ow(e, n, i);
    }
    function sw(n, e) {
        Rb(n, null, o3, iw, e);
        for (const t of e){
            const i = n && n[t.id] || {}, r = t.options && t.options[t.id] || {}, a = t.deprecatedOptions && t.deprecatedOptions[t.id] || {};
            Rb(i, t.id, r, a, e);
        }
    }
    function Rb(n, e, t, i, r) {
        const a = e || "Top level", l = e ? `${e}.` : "";
        for(const u in n){
            const h = !e && Mo(n[u]), d = u === "baseUri" && !e, p = u === "workerUrl" && e;
            if (!(u in t) && !d && !p) {
                if (u in i) Eb.warn(`${a} loader option '${l}${u}' no longer supported, use '${i[u]}'`)();
                else if (!h) {
                    const _ = aw(u, r);
                    Eb.warn(`${a} loader option '${l}${u}' not recognized. ${_}`)();
                }
            }
        }
    }
    function aw(n, e) {
        const t = n.toLowerCase();
        let i = "";
        for (const r of e)for(const a in r.options){
            if (n === a) return `Did you mean '${r.id}.${a}'?`;
            const l = a.toLowerCase();
            (t.startsWith(l) || l.startsWith(t)) && (i = i || `Did you mean '${r.id}.${a}'?`);
        }
        return i;
    }
    function ow(n, e, t) {
        const r = {
            ...n.options || {}
        };
        return lw(r, t), r.log === null && (r.log = new tw), Cb(r, c3()), Cb(r, e), r;
    }
    function Cb(n, e) {
        for(const t in e)if (t in e) {
            const i = e[t];
            xb(i) && xb(n[t]) ? n[t] = {
                ...n[t],
                ...e[t]
            } : n[t] = e[t];
        }
    }
    function lw(n, e) {
        e && !("baseUri" in n) && (n.baseUri = e);
    }
    function og(n) {
        return n ? (Array.isArray(n) && (n = n[0]), Array.isArray(n?.extensions)) : !1;
    }
    function lg(n) {
        vc(n, "null loader"), vc(og(n), "invalid loader");
        let e;
        return Array.isArray(n) && (e = n[1], n = n[0], n = {
            ...n,
            options: {
                ...n.options,
                ...e
            }
        }), (n?.parseTextSync || n?.parseText) && (n.text = !0), n.text || (n.binary = !0), n;
    }
    const u3 = ()=>{
        const n = l3();
        return n.loaderRegistry = n.loaderRegistry || [], n.loaderRegistry;
    };
    function cw(n) {
        const e = u3();
        n = Array.isArray(n) ? n : [
            n
        ];
        for (const t of n){
            const i = lg(t);
            e.find((r)=>i === r) || e.unshift(i);
        }
    }
    function uw() {
        return u3();
    }
    const fw = /\.([^.]+)$/;
    async function hw(n, e = [], t, i) {
        if (!f3(n)) return null;
        let r = Mb(n, e, {
            ...t,
            nothrow: !0
        }, i);
        if (r) return r;
        if (Ur(n) && (n = await n.slice(0, 10).arrayBuffer(), r = Mb(n, e, t, i)), !r && !t?.nothrow) throw new Error(h3(n));
        return r;
    }
    function Mb(n, e = [], t, i) {
        if (!f3(n)) return null;
        if (e && !Array.isArray(e)) return lg(e);
        let r = [];
        e && (r = r.concat(e)), t?.ignoreRegisteredLoaders || r.push(...uw()), gw(r);
        const a = dw(n, r, t, i);
        if (!a && !t?.nothrow) throw new Error(h3(n));
        return a;
    }
    function dw(n, e, t, i) {
        const r = Gc(n), a = ag(n), l = sg(r) || i?.url;
        let u = null, h = "";
        return t?.mimeType && (u = Ph(e, t?.mimeType), h = `match forced by supplied MIME type ${t?.mimeType}`), u = u || pw(e, l), h = h || (u ? `matched url ${l}` : ""), u = u || Ph(e, a), h = h || (u ? `matched MIME type ${a}` : ""), u = u || _w(e, n), h = h || (u ? `matched initial data ${d3(n)}` : ""), t?.fallbackMimeType && (u = u || Ph(e, t?.fallbackMimeType), h = h || (u ? `matched fallback MIME type ${a}` : "")), h && uA.log(1, `selectLoader selected ${u?.name}: ${h}.`), u;
    }
    function f3(n) {
        return !(n instanceof Response && n.status === 204);
    }
    function h3(n) {
        const e = Gc(n), t = ag(n);
        let i = "No valid loader found (";
        i += e ? `${i3(e)}, ` : "no url provided, ", i += `MIME type: ${t ? `"${t}"` : "not provided"}, `;
        const r = n ? d3(n) : "";
        return i += r ? ` first bytes: "${r}"` : "first bytes: not available", i += ")", i;
    }
    function gw(n) {
        for (const e of n)lg(e);
    }
    function pw(n, e) {
        const t = e && fw.exec(e), i = t && t[1];
        return i ? mw(n, i) : null;
    }
    function mw(n, e) {
        e = e.toLowerCase();
        for (const t of n)for (const i of t.extensions)if (i.toLowerCase() === e) return t;
        return null;
    }
    function Ph(n, e) {
        for (const t of n)if (t.mimeTypes?.some((i)=>Sb(e, i)) || Sb(e, `application/x.${t.id}`)) return t;
        return null;
    }
    function _w(n, e) {
        if (!e) return null;
        for (const t of n)if (typeof e == "string") {
            if (yw(e, t)) return t;
        } else if (ArrayBuffer.isView(e)) {
            if (Ob(e.buffer, e.byteOffset, t)) return t;
        } else if (e instanceof ArrayBuffer && Ob(e, 0, t)) return t;
        return null;
    }
    function yw(n, e) {
        return e.testText ? e.testText(n) : (Array.isArray(e.tests) ? e.tests : [
            e.tests
        ]).some((i)=>n.startsWith(i));
    }
    function Ob(n, e, t) {
        return (Array.isArray(t.tests) ? t.tests : [
            t.tests
        ]).some((r)=>bw(n, e, t, r));
    }
    function bw(n, e, t, i) {
        if (i instanceof ArrayBuffer) return RA(i, n, i.byteLength);
        switch(typeof i){
            case "function":
                return i(n);
            case "string":
                const r = yd(n, e, i.length);
                return i === r;
            default:
                return !1;
        }
    }
    function d3(n, e = 5) {
        return typeof n == "string" ? n.slice(0, e) : ArrayBuffer.isView(n) ? yd(n.buffer, n.byteOffset, e) : n instanceof ArrayBuffer ? yd(n, 0, e) : "";
    }
    function yd(n, e, t) {
        if (n.byteLength < e + t) return "";
        const i = new DataView(n);
        let r = "";
        for(let a = 0; a < t; a++)r += String.fromCharCode(i.getUint8(e + a));
        return r;
    }
    const vw = 256 * 1024;
    function* Tw(n, e) {
        const t = e?.chunkSize || vw;
        let i = 0;
        const r = new TextEncoder;
        for(; i < n.length;){
            const a = Math.min(n.length - i, t), l = n.slice(i, i + a);
            i += a, yield r.encode(l);
        }
    }
    const xw = 256 * 1024;
    function* Sw(n, e = {}) {
        const { chunkSize: t = xw } = e;
        let i = 0;
        for(; i < n.byteLength;){
            const r = Math.min(n.byteLength - i, t), a = new ArrayBuffer(r), l = new Uint8Array(n, i, r);
            new Uint8Array(a).set(l), i += r, yield a;
        }
    }
    const Aw = 1024 * 1024;
    async function* ww(n, e) {
        const t = e?.chunkSize || Aw;
        let i = 0;
        for(; i < n.size;){
            const r = i + t, a = await n.slice(i, r).arrayBuffer();
            i = r, yield a;
        }
    }
    function Ib(n, e) {
        return ig ? Ew(n, e) : Rw(n);
    }
    async function* Ew(n, e) {
        const t = n.getReader();
        let i;
        try {
            for(;;){
                const r = i || t.read();
                e?._streamReadAhead && (i = t.read());
                const { done: a, value: l } = await r;
                if (a) return;
                yield n3(l);
            }
        } catch  {
            t.releaseLock();
        }
    }
    async function* Rw(n, e) {
        for await (const t of n)yield n3(t);
    }
    function Cw(n, e) {
        if (typeof n == "string") return Tw(n, e);
        if (n instanceof ArrayBuffer) return Sw(n, e);
        if (Ur(n)) return ww(n, e);
        if (r3(n)) return Ib(n, e);
        if (kr(n)) return Ib(n.body, e);
        throw new Error("makeIterator");
    }
    const g3 = "Cannot convert supplied data type";
    function Mw(n, e, t) {
        if (e.text && typeof n == "string") return n;
        if (LA(n) && (n = n.buffer), n instanceof ArrayBuffer) {
            const i = n;
            return e.text && !e.binary ? new TextDecoder("utf8").decode(i) : i;
        }
        if (ArrayBuffer.isView(n)) {
            if (e.text && !e.binary) return new TextDecoder("utf8").decode(n);
            let i = n.buffer;
            const r = n.byteLength || n.length;
            return (n.byteOffset !== 0 || r !== i.byteLength) && (i = i.slice(n.byteOffset, n.byteOffset + r)), i;
        }
        throw new Error(g3);
    }
    async function Ow(n, e, t) {
        const i = n instanceof ArrayBuffer || ArrayBuffer.isView(n);
        if (typeof n == "string" || i) return Mw(n, e);
        if (Ur(n) && (n = await a3(n)), kr(n)) {
            const r = n;
            return await qA(r), e.binary ? await r.arrayBuffer() : await r.text();
        }
        if (r3(n) && (n = Cw(n, t)), UA(n) || BA(n)) return OA(n);
        throw new Error(g3);
    }
    function p3(n, e) {
        const t = c3(), i = n || t;
        return typeof i.fetch == "function" ? i.fetch : Mo(i.fetch) ? (r)=>wb(r, i.fetch) : e?.fetch ? e?.fetch : wb;
    }
    function Iw(n, e, t) {
        if (t) return t;
        const i = {
            fetch: p3(e, n),
            ...n
        };
        if (i.url) {
            const r = sg(i.url);
            i.baseUrl = r, i.queryString = $A(i.url), i.filename = i3(r), i.baseUrl = DA(r);
        }
        return Array.isArray(i.loaders) || (i.loaders = null), i;
    }
    function Nw(n, e) {
        if (n && !Array.isArray(n)) return n;
        let t;
        if (n && (t = Array.isArray(n) ? n : [
            n
        ]), e && e.loaders) {
            const i = Array.isArray(e.loaders) ? e.loaders : [
                e.loaders
            ];
            t = t ? [
                ...t,
                ...i
            ] : i;
        }
        return t && t.length ? t : void 0;
    }
    async function xc(n, e, t, i) {
        e && !Array.isArray(e) && !og(e) && (i = void 0, t = e, e = void 0), n = await n, t = t || {};
        const r = Gc(n), l = Nw(e, i), u = await hw(n, l, t);
        return u ? (t = rw(t, u, l, r), i = Iw({
            url: r,
            _parse: xc,
            loaders: l
        }, t, i || null), await Pw(u, n, t, i)) : null;
    }
    async function Pw(n, e, t, i) {
        if (SA(n), t = fA(n.options, t), kr(e)) {
            const a = e, { ok: l, redirected: u, status: h, statusText: d, type: p, url: _ } = a, y = Object.fromEntries(a.headers.entries());
            i.response = {
                headers: y,
                ok: l,
                redirected: u,
                status: h,
                statusText: d,
                type: p,
                url: _
            };
        }
        e = await Ow(e, n, t);
        const r = n;
        if (r.parseTextSync && typeof e == "string") return r.parseTextSync(e, t, i);
        if (AA(n, t)) return await wA(n, e, t, i, xc);
        if (r.parseText && typeof e == "string") return await r.parseText(e, t, i);
        if (r.parse) return await r.parse(e, t, i);
        throw Qi(!r.parseSync), new Error(`${n.id} loader - no parser found and worker is disabled`);
    }
    async function bd(n, e, t, i) {
        let r, a;
        !Array.isArray(e) && !og(e) ? (r = [], a = e) : (r = e, a = t);
        const l = p3(a);
        let u = n;
        return typeof n == "string" && (u = await l(n)), Ur(n) && (u = await l(n)), Array.isArray(r) ? await xc(u, r, a) : await xc(u, r, a);
    }
    const Dw = "4.3.2", kw = globalThis.loaders?.parseImageNode, vd = typeof Image < "u", Td = typeof ImageBitmap < "u", Uw = !!kw, xd = ig ? !0 : Uw;
    function Bw(n) {
        switch(n){
            case "auto":
                return Td || vd || xd;
            case "imagebitmap":
                return Td;
            case "image":
                return vd;
            case "data":
                return xd;
            default:
                throw new Error(`@loaders.gl/images: image ${n} not supported in this environment`);
        }
    }
    function Lw() {
        if (Td) return "imagebitmap";
        if (vd) return "image";
        if (xd) return "data";
        throw new Error("Install '@loaders.gl/polyfills' to parse images under Node.js");
    }
    function Fw(n) {
        const e = Vw(n);
        if (!e) throw new Error("Not an image");
        return e;
    }
    function zw(n) {
        switch(Fw(n)){
            case "data":
                return n;
            case "image":
            case "imagebitmap":
                const e = document.createElement("canvas"), t = e.getContext("2d");
                if (!t) throw new Error("getImageData");
                return e.width = n.width, e.height = n.height, t.drawImage(n, 0, 0), t.getImageData(0, 0, n.width, n.height);
            default:
                throw new Error("getImageData");
        }
    }
    function Vw(n) {
        return typeof ImageBitmap < "u" && n instanceof ImageBitmap ? "imagebitmap" : typeof Image < "u" && n instanceof Image ? "image" : n && typeof n == "object" && n.data && n.width && n.height ? "data" : null;
    }
    const Hw = /^data:image\/svg\+xml/, jw = /\.svg((\?|#).*)?$/;
    function cg(n) {
        return n && (Hw.test(n) || jw.test(n));
    }
    function Ww(n, e) {
        if (cg(e)) {
            let i = new TextDecoder().decode(n);
            try {
                typeof unescape == "function" && typeof encodeURIComponent == "function" && (i = unescape(encodeURIComponent(i)));
            } catch (a) {
                throw new Error(a.message);
            }
            return `data:image/svg+xml;base64,${btoa(i)}`;
        }
        return m3(n, e);
    }
    function m3(n, e) {
        if (cg(e)) throw new Error("SVG cannot be parsed directly to imagebitmap");
        return new Blob([
            new Uint8Array(n)
        ]);
    }
    async function _3(n, e, t) {
        const i = Ww(n, t), r = self.URL || self.webkitURL, a = typeof i != "string" && r.createObjectURL(i);
        try {
            return await $w(a || i, e);
        } finally{
            a && r.revokeObjectURL(a);
        }
    }
    async function $w(n, e) {
        const t = new Image;
        return t.src = n, e.image && e.image.decode && t.decode ? (await t.decode(), t) : await new Promise((i, r)=>{
            try {
                t.onload = ()=>i(t), t.onerror = (a)=>{
                    const l = a instanceof Error ? a.message : "error";
                    r(new Error(l));
                };
            } catch (a) {
                r(a);
            }
        });
    }
    const Xw = {};
    let Nb = !0;
    async function Yw(n, e, t) {
        let i;
        cg(t) ? i = await _3(n, e, t) : i = m3(n, t);
        const r = e && e.imagebitmap;
        return await qw(i, r);
    }
    async function qw(n, e = null) {
        if ((Kw(e) || !Nb) && (e = null), e) try {
            return await createImageBitmap(n, e);
        } catch (t) {
            console.warn(t), Nb = !1;
        }
        return await createImageBitmap(n);
    }
    function Kw(n) {
        for(const e in n || Xw)return !1;
        return !0;
    }
    function Zw(n) {
        return !eE(n, "ftyp", 4) || (n[8] & 96) === 0 ? null : Qw(n);
    }
    function Qw(n) {
        switch(Gw(n, 8, 12).replace("\0", " ").trim()){
            case "avif":
            case "avis":
                return {
                    extension: "avif",
                    mimeType: "image/avif"
                };
            default:
                return null;
        }
    }
    function Gw(n, e, t) {
        return String.fromCharCode(...n.slice(e, t));
    }
    function Jw(n) {
        return [
            ...n
        ].map((e)=>e.charCodeAt(0));
    }
    function eE(n, e, t = 0) {
        const i = Jw(e);
        for(let r = 0; r < i.length; ++r)if (i[r] !== n[r + t]) return !1;
        return !0;
    }
    const zn = !1, ho = !0;
    function y3(n) {
        const e = Oo(n);
        return nE(e) || sE(e) || iE(e) || rE(e) || tE(e);
    }
    function tE(n) {
        const e = new Uint8Array(n instanceof DataView ? n.buffer : n), t = Zw(e);
        return t ? {
            mimeType: t.mimeType,
            width: 0,
            height: 0
        } : null;
    }
    function nE(n) {
        const e = Oo(n);
        return e.byteLength >= 24 && e.getUint32(0, zn) === 2303741511 ? {
            mimeType: "image/png",
            width: e.getUint32(16, zn),
            height: e.getUint32(20, zn)
        } : null;
    }
    function iE(n) {
        const e = Oo(n);
        return e.byteLength >= 10 && e.getUint32(0, zn) === 1195984440 ? {
            mimeType: "image/gif",
            width: e.getUint16(6, ho),
            height: e.getUint16(8, ho)
        } : null;
    }
    function rE(n) {
        const e = Oo(n);
        return e.byteLength >= 14 && e.getUint16(0, zn) === 16973 && e.getUint32(2, ho) === e.byteLength ? {
            mimeType: "image/bmp",
            width: e.getUint32(18, ho),
            height: e.getUint32(22, ho)
        } : null;
    }
    function sE(n) {
        const e = Oo(n);
        if (!(e.byteLength >= 3 && e.getUint16(0, zn) === 65496 && e.getUint8(2) === 255)) return null;
        const { tableMarkers: i, sofMarkers: r } = aE();
        let a = 2;
        for(; a + 9 < e.byteLength;){
            const l = e.getUint16(a, zn);
            if (r.has(l)) return {
                mimeType: "image/jpeg",
                height: e.getUint16(a + 5, zn),
                width: e.getUint16(a + 7, zn)
            };
            if (!i.has(l)) return null;
            a += 2, a += e.getUint16(a, zn);
        }
        return null;
    }
    function aE() {
        const n = new Set([
            65499,
            65476,
            65484,
            65501,
            65534
        ]);
        for(let t = 65504; t < 65520; ++t)n.add(t);
        return {
            tableMarkers: n,
            sofMarkers: new Set([
                65472,
                65473,
                65474,
                65475,
                65477,
                65478,
                65479,
                65481,
                65482,
                65483,
                65485,
                65486,
                65487,
                65502
            ])
        };
    }
    function Oo(n) {
        if (n instanceof DataView) return n;
        if (ArrayBuffer.isView(n)) return new DataView(n.buffer);
        if (n instanceof ArrayBuffer) return new DataView(n);
        throw new Error("toDataView");
    }
    async function oE(n, e) {
        const { mimeType: t } = y3(n) || {}, i = globalThis.loaders?.parseImageNode;
        return vc(i), await i(n, t);
    }
    async function lE(n, e, t) {
        e = e || {};
        const r = (e.image || {}).type || "auto", { url: a } = t || {}, l = cE(r);
        let u;
        switch(l){
            case "imagebitmap":
                u = await Yw(n, e, a);
                break;
            case "image":
                u = await _3(n, e, a);
                break;
            case "data":
                u = await oE(n);
                break;
            default:
                vc(!1);
        }
        return r === "data" && (u = zw(u)), u;
    }
    function cE(n) {
        switch(n){
            case "auto":
            case "data":
                return Lw();
            default:
                return Bw(n), n;
        }
    }
    const uE = [
        "png",
        "jpg",
        "jpeg",
        "gif",
        "webp",
        "bmp",
        "ico",
        "svg",
        "avif"
    ], fE = [
        "image/png",
        "image/jpeg",
        "image/gif",
        "image/webp",
        "image/avif",
        "image/bmp",
        "image/vnd.microsoft.icon",
        "image/svg+xml"
    ], hE = {
        image: {
            type: "auto",
            decode: !0
        }
    }, dE = {
        dataType: null,
        batchType: null,
        id: "image",
        module: "images",
        name: "Images",
        version: Dw,
        mimeTypes: fE,
        extensions: uE,
        parse: lE,
        tests: [
            (n)=>!!y3(new DataView(n))
        ],
        options: hE
    }, Fe = new Co({
        id: "deck"
    });
    let Sd = {};
    function gE(n) {
        Sd = n;
    }
    function It(n, e, t, i) {
        Fe.level > 0 && Sd[n] && Sd[n].call(null, e, t, i);
    }
    function pE(n) {
        const e = n[0], t = n[n.length - 1];
        return e === "{" && t === "}" || e === "[" && t === "]";
    }
    const mE = {
        dataType: null,
        batchType: null,
        id: "JSON",
        name: "JSON",
        module: "",
        version: "",
        options: {},
        extensions: [
            "json",
            "geojson"
        ],
        mimeTypes: [
            "application/json",
            "application/geo+json"
        ],
        testText: pE,
        parseTextSync: JSON.parse
    };
    function _E() {
        const n = "9.1.11", e = globalThis.deck && globalThis.deck.VERSION;
        if (e && e !== n) throw new Error(`deck.gl - multiple versions detected: ${e} vs ${n}`);
        return e || (Fe.log(1, `deck.gl ${n}`)(), globalThis.deck = {
            ...globalThis.deck,
            VERSION: n,
            version: n,
            log: Fe,
            _registerLoggers: gE
        }, cw([
            mE,
            [
                dE,
                {
                    imagebitmap: {
                        premultiplyAlpha: "none"
                    }
                }
            ]
        ])), n;
    }
    const yE = _E();
    function ug(n, e) {
        if (!n) throw new Error(e || "shadertools: assertion failed.");
    }
    const Dh = {
        number: {
            type: "number",
            validate (n, e) {
                return Number.isFinite(n) && typeof e == "object" && (e.max === void 0 || n <= e.max) && (e.min === void 0 || n >= e.min);
            }
        },
        array: {
            type: "array",
            validate (n, e) {
                return Array.isArray(n) || ArrayBuffer.isView(n);
            }
        }
    };
    function bE(n) {
        const e = {};
        for (const [t, i] of Object.entries(n))e[t] = vE(i);
        return e;
    }
    function vE(n) {
        let e = Pb(n);
        if (e !== "object") return {
            value: n,
            ...Dh[e],
            type: e
        };
        if (typeof n == "object") return n ? n.type !== void 0 ? {
            ...n,
            ...Dh[n.type],
            type: n.type
        } : n.value === void 0 ? {
            type: "object",
            value: n
        } : (e = Pb(n.value), {
            ...n,
            ...Dh[e],
            type: e
        }) : {
            type: "object",
            value: null
        };
        throw new Error("props");
    }
    function Pb(n) {
        return Array.isArray(n) || ArrayBuffer.isView(n) ? "array" : typeof n;
    }
    const TE = `#ifdef MODULE_LOGDEPTH
  logdepth_adjustPosition(gl_Position);
#endif
`, xE = `#ifdef MODULE_MATERIAL
  fragColor = material_filterColor(fragColor);
#endif

#ifdef MODULE_LIGHTING
  fragColor = lighting_filterColor(fragColor);
#endif

#ifdef MODULE_FOG
  fragColor = fog_filterColor(fragColor);
#endif

#ifdef MODULE_PICKING
  fragColor = picking_filterHighlightColor(fragColor);
  fragColor = picking_filterPickingColor(fragColor);
#endif

#ifdef MODULE_LOGDEPTH
  logdepth_setFragDepth();
#endif
`, SE = {
        vertex: TE,
        fragment: xE
    }, Db = /void\s+main\s*\([^)]*\)\s*\{\n?/, kb = /}\n?[^{}]*$/, kh = [], hc = "__LUMA_INJECT_DECLARATIONS__";
    function AE(n) {
        const e = {
            vertex: {},
            fragment: {}
        };
        for(const t in n){
            let i = n[t];
            const r = wE(t);
            typeof i == "string" && (i = {
                order: 0,
                injection: i
            }), e[r][t] = i;
        }
        return e;
    }
    function wE(n) {
        const e = n.slice(0, 2);
        switch(e){
            case "vs":
                return "vertex";
            case "fs":
                return "fragment";
            default:
                throw new Error(e);
        }
    }
    function Sc(n, e, t, i = !1) {
        const r = e === "vertex";
        for(const a in t){
            const l = t[a];
            l.sort((h, d)=>h.order - d.order), kh.length = l.length;
            for(let h = 0, d = l.length; h < d; ++h)kh[h] = l[h].injection;
            const u = `${kh.join(`
`)}
`;
            switch(a){
                case "vs:#decl":
                    r && (n = n.replace(hc, u));
                    break;
                case "vs:#main-start":
                    r && (n = n.replace(Db, (h)=>h + u));
                    break;
                case "vs:#main-end":
                    r && (n = n.replace(kb, (h)=>u + h));
                    break;
                case "fs:#decl":
                    r || (n = n.replace(hc, u));
                    break;
                case "fs:#main-start":
                    r || (n = n.replace(Db, (h)=>h + u));
                    break;
                case "fs:#main-end":
                    r || (n = n.replace(kb, (h)=>u + h));
                    break;
                default:
                    n = n.replace(a, (h)=>h + u);
            }
        }
        return n = n.replace(hc, ""), i && (n = n.replace(/\}\s*$/, (a)=>a + SE[e])), n;
    }
    function Ac(n) {
        n.map((e)=>EE(e));
    }
    function EE(n) {
        if (n.instance) return;
        Ac(n.dependencies || []);
        const { propTypes: e = {}, deprecations: t = [], inject: i = {} } = n, r = {
            normalizedInjections: AE(i),
            parsedDeprecations: RE(t)
        };
        e && (r.propValidators = bE(e)), n.instance = r;
        let a = {};
        e && (a = Object.entries(e).reduce((l, [u, h])=>{
            const d = h?.value;
            return d && (l[u] = d), l;
        }, {})), n.defaultUniforms = {
            ...n.defaultUniforms,
            ...a
        };
    }
    function b3(n, e, t) {
        n.deprecations?.forEach((i)=>{
            i.regex?.test(e) && (i.deprecated ? t.deprecated(i.old, i.new)() : t.removed(i.old, i.new)());
        });
    }
    function RE(n) {
        return n.forEach((e)=>{
            switch(e.type){
                case "function":
                    e.regex = new RegExp(`\\b${e.old}\\(`);
                    break;
                default:
                    e.regex = new RegExp(`${e.type} ${e.old};`);
            }
        }), n;
    }
    function fg(n) {
        Ac(n);
        const e = {}, t = {};
        v3({
            modules: n,
            level: 0,
            moduleMap: e,
            moduleDepth: t
        });
        const i = Object.keys(t).sort((r, a)=>t[a] - t[r]).map((r)=>e[r]);
        return Ac(i), i;
    }
    function v3(n) {
        const { modules: e, level: t, moduleMap: i, moduleDepth: r } = n;
        if (t >= 5) throw new Error("Possible loop in shader dependency graph");
        for (const a of e)i[a.name] = a, (r[a.name] === void 0 || r[a.name] < t) && (r[a.name] = t);
        for (const a of e)a.dependencies && v3({
            modules: a.dependencies,
            level: t + 1,
            moduleMap: i,
            moduleDepth: r
        });
    }
    function CE(n) {
        switch(n?.gpu.toLowerCase()){
            case "apple":
                return `#define APPLE_GPU
// Apple optimizes away the calculation necessary for emulated fp64
#define LUMA_FP64_CODE_ELIMINATION_WORKAROUND 1
#define LUMA_FP32_TAN_PRECISION_WORKAROUND 1
// Intel GPU doesn't have full 32 bits precision in same cases, causes overflow
#define LUMA_FP64_HIGH_BITS_OVERFLOW_WORKAROUND 1
`;
            case "nvidia":
                return `#define NVIDIA_GPU
// Nvidia optimizes away the calculation necessary for emulated fp64
#define LUMA_FP64_CODE_ELIMINATION_WORKAROUND 1
`;
            case "intel":
                return `#define INTEL_GPU
// Intel optimizes away the calculation necessary for emulated fp64
#define LUMA_FP64_CODE_ELIMINATION_WORKAROUND 1
// Intel's built-in 'tan' function doesn't have acceptable precision
#define LUMA_FP32_TAN_PRECISION_WORKAROUND 1
// Intel GPU doesn't have full 32 bits precision in same cases, causes overflow
#define LUMA_FP64_HIGH_BITS_OVERFLOW_WORKAROUND 1
`;
            case "amd":
                return `#define AMD_GPU
`;
            default:
                return `#define DEFAULT_GPU
// Prevent driver from optimizing away the calculation necessary for emulated fp64
#define LUMA_FP64_CODE_ELIMINATION_WORKAROUND 1
// Headless Chrome's software shader 'tan' function doesn't have acceptable precision
#define LUMA_FP32_TAN_PRECISION_WORKAROUND 1
// If the GPU doesn't have full 32 bits precision, will causes overflow
#define LUMA_FP64_HIGH_BITS_OVERFLOW_WORKAROUND 1
`;
        }
    }
    function ME(n, e) {
        if (Number(n.match(/^#version[ \t]+(\d+)/m)?.[1] || 100) !== 300) throw new Error("luma.gl v9 only supports GLSL 3.00 shader sources");
        switch(e){
            case "vertex":
                return n = Ub(n, OE), n;
            case "fragment":
                return n = Ub(n, IE), n;
            default:
                throw new Error(e);
        }
    }
    const T3 = [
        [
            /^(#version[ \t]+(100|300[ \t]+es))?[ \t]*\n/,
            `#version 300 es
`
        ],
        [
            /\btexture(2D|2DProj|Cube)Lod(EXT)?\(/g,
            "textureLod("
        ],
        [
            /\btexture(2D|2DProj|Cube)(EXT)?\(/g,
            "texture("
        ]
    ], OE = [
        ...T3,
        [
            Ad("attribute"),
            "in $1"
        ],
        [
            Ad("varying"),
            "out $1"
        ]
    ], IE = [
        ...T3,
        [
            Ad("varying"),
            "in $1"
        ]
    ];
    function Ub(n, e) {
        for (const [t, i] of e)n = n.replace(t, i);
        return n;
    }
    function Ad(n) {
        return new RegExp(`\\b${n}[ \\t]+(\\w+[ \\t]+\\w+(\\[\\w+\\])?;)`, "g");
    }
    function x3(n, e) {
        let t = "";
        for(const i in n){
            const r = n[i];
            if (t += `void ${r.signature} {
`, r.header && (t += `  ${r.header}`), e[i]) {
                const a = e[i];
                a.sort((l, u)=>l.order - u.order);
                for (const l of a)t += `  ${l.injection}
`;
            }
            r.footer && (t += `  ${r.footer}`), t += `}
`;
        }
        return t;
    }
    function S3(n) {
        const e = {
            vertex: {},
            fragment: {}
        };
        for (const t of n){
            let i, r;
            typeof t != "string" ? (i = t, r = i.hook) : (i = {}, r = t), r = r.trim();
            const [a, l] = r.split(":"), u = r.replace(/\(.+/, ""), h = Object.assign(i, {
                signature: l
            });
            switch(a){
                case "vs":
                    e.vertex[u] = h;
                    break;
                case "fs":
                    e.fragment[u] = h;
                    break;
                default:
                    throw new Error(a);
            }
        }
        return e;
    }
    function NE(n, e) {
        return {
            name: PE(n, e),
            language: "glsl",
            version: DE(n)
        };
    }
    function PE(n, e = "unnamed") {
        const i = /#define[^\S\r\n]*SHADER_NAME[^\S\r\n]*([A-Za-z0-9_-]+)\s*/.exec(n);
        return i ? i[1] : e;
    }
    function DE(n) {
        let e = 100;
        const t = n.match(/[^\s]+/g);
        if (t && t.length >= 2 && t[0] === "#version") {
            const i = parseInt(t[1], 10);
            Number.isFinite(i) && (e = i);
        }
        if (e !== 100 && e !== 300) throw new Error(`Invalid GLSL version ${e}`);
        return e;
    }
    const A3 = `

${hc}
`, kE = `precision highp float;
`;
    function UE(n) {
        const e = fg(n.modules || []);
        return {
            source: LE(n.platformInfo, {
                ...n,
                source: n.source,
                stage: "vertex",
                modules: e
            }),
            getUniforms: w3(e)
        };
    }
    function BE(n) {
        const { vs: e, fs: t } = n, i = fg(n.modules || []);
        return {
            vs: Bb(n.platformInfo, {
                ...n,
                source: e,
                stage: "vertex",
                modules: i
            }),
            fs: Bb(n.platformInfo, {
                ...n,
                source: t,
                stage: "fragment",
                modules: i
            }),
            getUniforms: w3(i)
        };
    }
    function LE(n, e) {
        const { source: t, stage: i, modules: r, hookFunctions: a = [], inject: l = {}, log: u } = e;
        ug(typeof t == "string", "shader source must be a string");
        const h = t;
        let d = "";
        const p = S3(a), _ = {}, y = {}, v = {};
        for(const E in l){
            const M = typeof l[E] == "string" ? {
                injection: l[E],
                order: 0
            } : l[E], B = /^(v|f)s:(#)?([\w-]+)$/.exec(E);
            if (B) {
                const H = B[2], O = B[3];
                H ? O === "decl" ? y[E] = [
                    M
                ] : v[E] = [
                    M
                ] : _[E] = [
                    M
                ];
            } else v[E] = [
                M
            ];
        }
        const S = r;
        for (const E of S){
            u && b3(E, h, u);
            const M = E3(E, "wgsl");
            d += M;
            const B = E.injections?.[i] || {};
            for(const H in B){
                const O = /^(v|f)s:#([\w-]+)$/.exec(H);
                if (O) {
                    const L = O[2] === "decl" ? y : v;
                    L[H] = L[H] || [], L[H].push(B[H]);
                } else _[H] = _[H] || [], _[H].push(B[H]);
            }
        }
        return d += A3, d = Sc(d, i, y), d += x3(p[i], _), d += h, d = Sc(d, i, v), d;
    }
    function Bb(n, e) {
        const { id: t, source: i, stage: r, language: a = "glsl", modules: l, defines: u = {}, hookFunctions: h = [], inject: d = {}, prologue: p = !0, log: _ } = e;
        ug(typeof i == "string", "shader source must be a string");
        const y = a === "glsl" ? NE(i).version : -1, v = n.shaderLanguageVersion, S = y === 100 ? "#version 100" : "#version 300 es", M = i.split(`
`).slice(1).join(`
`), B = {};
        l.forEach((se)=>{
            Object.assign(B, se.defines);
        }), Object.assign(B, u);
        let H = "";
        switch(a){
            case "wgsl":
                break;
            case "glsl":
                H = p ? `${S}

// ----- PROLOGUE -------------------------
${FE({
                    id: t,
                    source: i,
                    stage: r
                })}
${`#define SHADER_TYPE_${r.toUpperCase()}`}

${CE(n)}
${r === "fragment" ? kE : ""}

// ----- APPLICATION DEFINES -------------------------

${zE(B)}

` : `${S}
`;
                break;
        }
        const O = S3(h), U = {}, L = {}, Z = {};
        for(const se in d){
            const ae = typeof d[se] == "string" ? {
                injection: d[se],
                order: 0
            } : d[se], te = /^(v|f)s:(#)?([\w-]+)$/.exec(se);
            if (te) {
                const fe = te[2], ne = te[3];
                fe ? ne === "decl" ? L[se] = [
                    ae
                ] : Z[se] = [
                    ae
                ] : U[se] = [
                    ae
                ];
            } else Z[se] = [
                ae
            ];
        }
        for (const se of l){
            _ && b3(se, M, _);
            const ae = E3(se, r);
            H += ae;
            const te = se.instance?.normalizedInjections[r] || {};
            for(const fe in te){
                const ne = /^(v|f)s:#([\w-]+)$/.exec(fe);
                if (ne) {
                    const Te = ne[2] === "decl" ? L : Z;
                    Te[fe] = Te[fe] || [], Te[fe].push(te[fe]);
                } else U[fe] = U[fe] || [], U[fe].push(te[fe]);
            }
        }
        return H += "// ----- MAIN SHADER SOURCE -------------------------", H += A3, H = Sc(H, r, L), H += x3(O[r], U), H += M, H = Sc(H, r, Z), a === "glsl" && y !== v && (H = ME(H, r)), H.trim();
    }
    function w3(n) {
        return function(t) {
            const i = {};
            for (const r of n){
                const a = r.getUniforms?.(t, i);
                Object.assign(i, a);
            }
            return i;
        };
    }
    function FE(n) {
        const { id: e, source: t, stage: i } = n;
        return e && t.indexOf("SHADER_NAME") === -1 ? `
#define SHADER_NAME ${e}_${i}` : "";
    }
    function zE(n = {}) {
        let e = "";
        for(const t in n){
            const i = n[t];
            (i || Number.isFinite(i)) && (e += `#define ${t.toUpperCase()} ${n[t]}
`);
        }
        return e;
    }
    function E3(n, e) {
        let t;
        switch(e){
            case "vertex":
                t = n.vs || "";
                break;
            case "fragment":
                t = n.fs || "";
                break;
            case "wgsl":
                t = n.source || "";
                break;
            default:
                ug(!1);
        }
        if (!n.name) throw new Error("Shader module must have a name");
        const i = n.name.toUpperCase().replace(/[^0-9a-z]/gi, "_");
        let r = `// ----- MODULE ${n.name} ---------------

`;
        return e !== "wgsl" && (r += `#define MODULE_${i}
`), r += `${t}
`, r;
    }
    const VE = /^\s*\#\s*ifdef\s*([a-zA-Z_]+)\s*$/, HE = /^\s*\#\s*endif\s*$/;
    function jE(n, e) {
        const t = n.split(`
`), i = [];
        let r = !0, a = null;
        for (const l of t){
            const u = l.match(VE), h = l.match(HE);
            u ? (a = u[1], r = !!e?.defines?.[a]) : h ? r = !0 : r && i.push(l);
        }
        return i.join(`
`);
    }
    class Tr {
        static defaultShaderAssembler;
        _hookFunctions = [];
        _defaultModules = [];
        static getDefaultShaderAssembler() {
            return Tr.defaultShaderAssembler = Tr.defaultShaderAssembler || new Tr, Tr.defaultShaderAssembler;
        }
        addDefaultModule(e) {
            this._defaultModules.find((t)=>t.name === (typeof e == "string" ? e : e.name)) || this._defaultModules.push(e);
        }
        removeDefaultModule(e) {
            const t = typeof e == "string" ? e : e.name;
            this._defaultModules = this._defaultModules.filter((i)=>i.name !== t);
        }
        addShaderHook(e, t) {
            t && (e = Object.assign(t, {
                hook: e
            })), this._hookFunctions.push(e);
        }
        assembleWGSLShader(e) {
            const t = this._getModuleList(e.modules), i = this._hookFunctions, { source: r, getUniforms: a } = UE({
                ...e,
                source: e.source,
                modules: t,
                hookFunctions: i
            });
            return {
                source: e.platformInfo.shaderLanguage === "wgsl" ? jE(r) : r,
                getUniforms: a,
                modules: t
            };
        }
        assembleGLSLShaderPair(e) {
            const t = this._getModuleList(e.modules), i = this._hookFunctions;
            return {
                ...BE({
                    ...e,
                    vs: e.vs,
                    fs: e.fs,
                    modules: t,
                    hookFunctions: i
                }),
                modules: t
            };
        }
        _getModuleList(e = []) {
            const t = new Array(this._defaultModules.length + e.length), i = {};
            let r = 0;
            for(let a = 0, l = this._defaultModules.length; a < l; ++a){
                const u = this._defaultModules[a], h = u.name;
                t[r++] = u, i[h] = !0;
            }
            for(let a = 0, l = e.length; a < l; ++a){
                const u = e[a], h = u.name;
                i[h] || (t[r++] = u, i[h] = !0);
            }
            return t.length = r, Ac(t), t;
        }
    }
    const WE = `out vec4 transform_output;
void main() {
  transform_output = vec4(0);
}`, $E = `#version 300 es
${WE}`;
    function R3(n) {
        const { input: e, inputChannels: t, output: i } = n || {};
        if (!e) return $E;
        if (!t) throw new Error("inputChannels");
        const r = XE(t), a = YE(e, t);
        return `#version 300 es
in ${r} ${e};
out vec4 ${i};
void main() {
  ${i} = ${a};
}`;
    }
    function XE(n) {
        switch(n){
            case 1:
                return "float";
            case 2:
                return "vec2";
            case 3:
                return "vec3";
            case 4:
                return "vec4";
            default:
                throw new Error(`invalid channels: ${n}`);
        }
    }
    function YE(n, e) {
        switch(e){
            case 1:
                return `vec4(${n}, 0.0, 0.0, 1.0)`;
            case 2:
                return `vec4(${n}, 0.0, 1.0)`;
            case 3:
                return `vec4(${n}, 1.0)`;
            case 4:
                return n;
            default:
                throw new Error(`invalid channels: ${e}`);
        }
    }
    class qE {
        stats = new Map;
        getStats(e) {
            return this.get(e);
        }
        get(e) {
            return this.stats.has(e) || this.stats.set(e, new Qc({
                id: e
            })), this.stats.get(e);
        }
    }
    const C3 = new qE, J = new Co({
        id: "luma.gl"
    }), Uh = {};
    function Jc(n = "id") {
        Uh[n] = Uh[n] || 1;
        const e = Uh[n]++;
        return `${n}-${e}`;
    }
    let Ye = class {
        static defaultProps = {
            id: "undefined",
            handle: void 0,
            userData: void 0
        };
        toString() {
            return `${this[Symbol.toStringTag] || this.constructor.name}:"${this.id}"`;
        }
        id;
        props;
        userData = {};
        _device;
        destroyed = !1;
        allocatedBytes = 0;
        _attachedResources = new Set;
        constructor(e, t, i){
            if (!e) throw new Error("no device");
            this._device = e, this.props = KE(t, i);
            const r = this.props.id !== "undefined" ? this.props.id : Jc(this[Symbol.toStringTag]);
            this.props.id = r, this.id = r, this.userData = this.props.userData || {}, this.addStats();
        }
        destroy() {
            this.destroyResource();
        }
        delete() {
            return this.destroy(), this;
        }
        getProps() {
            return this.props;
        }
        attachResource(e) {
            this._attachedResources.add(e);
        }
        detachResource(e) {
            this._attachedResources.delete(e);
        }
        destroyAttachedResource(e) {
            this._attachedResources.delete(e) && e.destroy();
        }
        destroyAttachedResources() {
            for (const e of Object.values(this._attachedResources))e.destroy();
            this._attachedResources = new Set;
        }
        destroyResource() {
            this.destroyAttachedResources(), this.removeStats(), this.destroyed = !0;
        }
        removeStats() {
            const e = this._device.statsManager.getStats("Resource Counts"), t = this[Symbol.toStringTag];
            e.get(`${t}s Active`).decrementCount();
        }
        trackAllocatedMemory(e, t = this[Symbol.toStringTag]) {
            const i = this._device.statsManager.getStats("Resource Counts");
            i.get("GPU Memory").addCount(e), i.get(`${t} Memory`).addCount(e), this.allocatedBytes = e;
        }
        trackDeallocatedMemory(e = this[Symbol.toStringTag]) {
            const t = this._device.statsManager.getStats("Resource Counts");
            t.get("GPU Memory").subtractCount(this.allocatedBytes), t.get(`${e} Memory`).subtractCount(this.allocatedBytes), this.allocatedBytes = 0;
        }
        addStats() {
            const e = this._device.statsManager.getStats("Resource Counts"), t = this[Symbol.toStringTag];
            e.get("Resources Created").incrementCount(), e.get(`${t}s Created`).incrementCount(), e.get(`${t}s Active`).incrementCount();
        }
    };
    function KE(n, e) {
        const t = {
            ...e
        };
        for(const i in n)n[i] !== void 0 && (t[i] = n[i]);
        return t;
    }
    class Ge extends Ye {
        static defaultProps = {
            ...Ye.defaultProps,
            usage: 0,
            byteLength: 0,
            byteOffset: 0,
            data: null,
            indexType: "uint16",
            mappedAtCreation: !1
        };
        static MAP_READ = 1;
        static MAP_WRITE = 2;
        static COPY_SRC = 4;
        static COPY_DST = 8;
        static INDEX = 16;
        static VERTEX = 32;
        static UNIFORM = 64;
        static STORAGE = 128;
        static INDIRECT = 256;
        static QUERY_RESOLVE = 512;
        get [Symbol.toStringTag]() {
            return "Buffer";
        }
        usage;
        indexType;
        updateTimestamp;
        constructor(e, t){
            const i = {
                ...t
            };
            (t.usage || 0) & Ge.INDEX && !t.indexType && (t.data instanceof Uint32Array ? i.indexType = "uint32" : t.data instanceof Uint16Array && (i.indexType = "uint16")), delete i.data, super(e, i, Ge.defaultProps), this.usage = i.usage || 0, this.indexType = i.indexType, this.updateTimestamp = e.incrementTimestamp();
        }
        clone(e) {
            return this.device.createBuffer({
                ...this.props,
                ...e
            });
        }
        readSyncWebGL(e, t) {
            throw new Error("not implemented");
        }
        static DEBUG_DATA_MAX_LENGTH = 32;
        debugData = new ArrayBuffer(0);
        _setDebugData(e, t, i) {
            const r = ArrayBuffer.isView(e) ? e.buffer : e, a = Math.min(e ? e.byteLength : i, Ge.DEBUG_DATA_MAX_LENGTH);
            r === null ? this.debugData = new ArrayBuffer(a) : t === 0 && i === r.byteLength ? this.debugData = r.slice(0, a) : this.debugData = r.slice(t, t + a);
        }
    }
    function M3(n) {
        const e = Lb[n], t = ZE(e), i = n.includes("norm"), r = !i && !n.startsWith("float"), a = n.startsWith("s");
        return {
            dataType: Lb[n],
            byteLength: t,
            integer: r,
            signed: a,
            normalized: i
        };
    }
    function ZE(n) {
        return QE[n];
    }
    const Lb = {
        uint8: "uint8",
        sint8: "sint8",
        unorm8: "uint8",
        snorm8: "sint8",
        uint16: "uint16",
        sint16: "sint16",
        unorm16: "uint16",
        snorm16: "sint16",
        float16: "float16",
        float32: "float32",
        uint32: "uint32",
        sint32: "sint32"
    }, QE = {
        uint8: 1,
        sint8: 1,
        uint16: 2,
        sint16: 2,
        float16: 2,
        float32: 4,
        uint32: 4,
        sint32: 4
    }, Ct = "texture-compression-bc", $e = "texture-compression-astc", Un = "texture-compression-etc2", GE = "texture-compression-etc1-webgl", Zl = "texture-compression-pvrtc-webgl", Bh = "texture-compression-atc-webgl", Ql = "float32-renderable-webgl", Lh = "float16-renderable-webgl", JE = "rgb9e5ufloat-renderable-webgl", Fh = "snorm8-renderable-webgl", no = "norm16-renderable-webgl", zh = "snorm16-renderable-webgl", Gl = "float32-filterable", Fb = "float16-filterable-webgl";
    function O3(n) {
        const e = eR[n];
        if (!e) throw new Error(`Unsupported texture format ${n}`);
        return e;
    }
    const eR = {
        r8unorm: {},
        r8snorm: {
            render: Fh
        },
        r8uint: {},
        r8sint: {},
        rg8unorm: {},
        rg8snorm: {
            render: Fh
        },
        rg8uint: {},
        rg8sint: {},
        r16uint: {},
        r16sint: {},
        r16float: {
            render: Lh,
            filter: "float16-filterable-webgl"
        },
        "r16unorm-webgl": {
            f: no
        },
        "r16snorm-webgl": {
            f: zh
        },
        "rgba4unorm-webgl": {
            channels: "rgba",
            bitsPerChannel: [
                4,
                4,
                4,
                4
            ],
            packed: !0
        },
        "rgb565unorm-webgl": {
            channels: "rgb",
            bitsPerChannel: [
                5,
                6,
                5,
                0
            ],
            packed: !0
        },
        "rgb5a1unorm-webgl": {
            channels: "rgba",
            bitsPerChannel: [
                5,
                5,
                5,
                1
            ],
            packed: !0
        },
        "rgb8unorm-webgl": {},
        "rgb8snorm-webgl": {},
        rgba8unorm: {},
        "rgba8unorm-srgb": {},
        rgba8snorm: {
            render: Fh
        },
        rgba8uint: {},
        rgba8sint: {},
        bgra8unorm: {},
        "bgra8unorm-srgb": {},
        rg16uint: {},
        rg16sint: {},
        rg16float: {
            render: Lh,
            filter: Fb
        },
        "rg16unorm-webgl": {
            render: no
        },
        "rg16snorm-webgl": {
            render: zh
        },
        r32uint: {},
        r32sint: {},
        r32float: {
            render: Ql,
            filter: Gl
        },
        rgb9e5ufloat: {
            channels: "rgb",
            packed: !0,
            render: JE
        },
        rg11b10ufloat: {
            channels: "rgb",
            bitsPerChannel: [
                11,
                11,
                10,
                0
            ],
            packed: !0,
            p: 1,
            render: Ql
        },
        rgb10a2unorm: {
            channels: "rgba",
            bitsPerChannel: [
                10,
                10,
                10,
                2
            ],
            packed: !0,
            p: 1
        },
        "rgb10a2uint-webgl": {
            channels: "rgba",
            bitsPerChannel: [
                10,
                10,
                10,
                2
            ],
            packed: !0,
            p: 1,
            wgpu: !1
        },
        "rgb16unorm-webgl": {
            f: no
        },
        "rgb16snorm-webgl": {
            f: no
        },
        rg32uint: {},
        rg32sint: {},
        rg32float: {
            render: !1,
            filter: Gl
        },
        rgba16uint: {},
        rgba16sint: {},
        rgba16float: {
            render: Lh,
            filter: Fb
        },
        "rgba16unorm-webgl": {
            render: no
        },
        "rgba16snorm-webgl": {
            render: zh
        },
        "rgb32float-webgl": {
            render: Ql,
            filter: Gl
        },
        rgba32uint: {},
        rgba32sint: {},
        rgba32float: {
            render: Ql,
            filter: Gl
        },
        stencil8: {
            attachment: "stencil",
            bitsPerChannel: [
                8,
                0,
                0,
                0
            ],
            dataType: "uint8"
        },
        depth16unorm: {
            attachment: "depth",
            bitsPerChannel: [
                16,
                0,
                0,
                0
            ],
            dataType: "uint16"
        },
        depth24plus: {
            attachment: "depth",
            bitsPerChannel: [
                24,
                0,
                0,
                0
            ],
            dataType: "uint32"
        },
        depth32float: {
            attachment: "depth",
            bitsPerChannel: [
                32,
                0,
                0,
                0
            ],
            dataType: "float32"
        },
        "depth24plus-stencil8": {
            attachment: "depth-stencil",
            bitsPerChannel: [
                24,
                8,
                0,
                0
            ],
            packed: !0
        },
        "depth32float-stencil8": {
            attachment: "depth-stencil",
            bitsPerChannel: [
                32,
                8,
                0,
                0
            ],
            packed: !0
        },
        "bc1-rgb-unorm-webgl": {
            f: Ct
        },
        "bc1-rgb-unorm-srgb-webgl": {
            f: Ct
        },
        "bc1-rgba-unorm": {
            f: Ct
        },
        "bc1-rgba-unorm-srgb": {
            f: Ct
        },
        "bc2-rgba-unorm": {
            f: Ct
        },
        "bc2-rgba-unorm-srgb": {
            f: Ct
        },
        "bc3-rgba-unorm": {
            f: Ct
        },
        "bc3-rgba-unorm-srgb": {
            f: Ct
        },
        "bc4-r-unorm": {
            f: Ct
        },
        "bc4-r-snorm": {
            f: Ct
        },
        "bc5-rg-unorm": {
            f: Ct
        },
        "bc5-rg-snorm": {
            f: Ct
        },
        "bc6h-rgb-ufloat": {
            f: Ct
        },
        "bc6h-rgb-float": {
            f: Ct
        },
        "bc7-rgba-unorm": {
            f: Ct
        },
        "bc7-rgba-unorm-srgb": {
            f: Ct
        },
        "etc2-rgb8unorm": {
            f: Un
        },
        "etc2-rgb8unorm-srgb": {
            f: Un
        },
        "etc2-rgb8a1unorm": {
            f: Un
        },
        "etc2-rgb8a1unorm-srgb": {
            f: Un
        },
        "etc2-rgba8unorm": {
            f: Un
        },
        "etc2-rgba8unorm-srgb": {
            f: Un
        },
        "eac-r11unorm": {
            f: Un
        },
        "eac-r11snorm": {
            f: Un
        },
        "eac-rg11unorm": {
            f: Un
        },
        "eac-rg11snorm": {
            f: Un
        },
        "astc-4x4-unorm": {
            f: $e
        },
        "astc-4x4-unorm-srgb": {
            f: $e
        },
        "astc-5x4-unorm": {
            f: $e
        },
        "astc-5x4-unorm-srgb": {
            f: $e
        },
        "astc-5x5-unorm": {
            f: $e
        },
        "astc-5x5-unorm-srgb": {
            f: $e
        },
        "astc-6x5-unorm": {
            f: $e
        },
        "astc-6x5-unorm-srgb": {
            f: $e
        },
        "astc-6x6-unorm": {
            f: $e
        },
        "astc-6x6-unorm-srgb": {
            f: $e
        },
        "astc-8x5-unorm": {
            f: $e
        },
        "astc-8x5-unorm-srgb": {
            f: $e
        },
        "astc-8x6-unorm": {
            f: $e
        },
        "astc-8x6-unorm-srgb": {
            f: $e
        },
        "astc-8x8-unorm": {
            f: $e
        },
        "astc-8x8-unorm-srgb": {
            f: $e
        },
        "astc-10x5-unorm": {
            f: $e
        },
        "astc-10x5-unorm-srgb": {
            f: $e
        },
        "astc-10x6-unorm": {
            f: $e
        },
        "astc-10x6-unorm-srgb": {
            f: $e
        },
        "astc-10x8-unorm": {
            f: $e
        },
        "astc-10x8-unorm-srgb": {
            f: $e
        },
        "astc-10x10-unorm": {
            f: $e
        },
        "astc-10x10-unorm-srgb": {
            f: $e
        },
        "astc-12x10-unorm": {
            f: $e
        },
        "astc-12x10-unorm-srgb": {
            f: $e
        },
        "astc-12x12-unorm": {
            f: $e
        },
        "astc-12x12-unorm-srgb": {
            f: $e
        },
        "pvrtc-rgb4unorm-webgl": {
            f: Zl
        },
        "pvrtc-rgba4unorm-webgl": {
            f: Zl
        },
        "pvrtc-rbg2unorm-webgl": {
            f: Zl
        },
        "pvrtc-rgba2unorm-webgl": {
            f: Zl
        },
        "etc1-rbg-unorm-webgl": {
            f: GE
        },
        "atc-rgb-unorm-webgl": {
            f: Bh
        },
        "atc-rgba-unorm-webgl": {
            f: Bh
        },
        "atc-rgbai-unorm-webgl": {
            f: Bh
        }
    }, tR = [
        "bc1",
        "bc2",
        "bc3",
        "bc4",
        "bc5",
        "bc6",
        "bc7",
        "etc1",
        "etc2",
        "eac",
        "atc",
        "astc",
        "pvrtc"
    ], nR = /^(r|rg|rgb|rgba|bgra)([0-9]*)([a-z]*)(-srgb)?(-webgl)?$/;
    function I3(n) {
        return tR.some((e)=>n.startsWith(e));
    }
    function hg(n) {
        let e = iR(n);
        if (I3(n)) {
            e.channels = "rgb", e.components = 3, e.bytesPerPixel = 1, e.srgb = !1, e.compressed = !0;
            const i = rR(n);
            i && (e.blockWidth = i.blockWidth, e.blockHeight = i.blockHeight);
        }
        const t = nR.exec(n);
        if (t) {
            const [, i, r, a, l, u] = t, h = `${a}${r}`, d = M3(h), p = d.byteLength * 8, _ = i.length, y = [
                p,
                _ >= 2 ? p : 0,
                _ >= 3 ? p : 0,
                _ >= 4 ? p : 0
            ];
            e = {
                format: n,
                attachment: e.attachment,
                dataType: d.dataType,
                components: _,
                channels: i,
                integer: d.integer,
                signed: d.signed,
                normalized: d.normalized,
                bitsPerChannel: y,
                bytesPerPixel: d.byteLength * i.length,
                packed: e.packed,
                srgb: e.srgb
            }, u === "-webgl" && (e.webgl = !0), l === "-srgb" && (e.srgb = !0);
        }
        return n.endsWith("-webgl") && (e.webgl = !0), n.endsWith("-srgb") && (e.srgb = !0), e;
    }
    function iR(n) {
        const e = O3(n), t = e.bytesPerPixel || 1, i = e.bitsPerChannel || [
            8,
            8,
            8,
            8
        ];
        return delete e.bitsPerChannel, delete e.bytesPerPixel, delete e.f, delete e.render, delete e.filter, delete e.blend, delete e.store, {
            ...e,
            format: n,
            attachment: e.attachment || "color",
            channels: e.channels || "r",
            components: e.components || e.channels?.length || 1,
            bytesPerPixel: t,
            bitsPerChannel: i,
            dataType: e.dataType || "uint8",
            srgb: e.srgb ?? !1,
            packed: e.packed ?? !1,
            webgl: e.webgl ?? !1,
            integer: e.integer ?? !1,
            signed: e.signed ?? !1,
            normalized: e.normalized ?? !1,
            compressed: e.compressed ?? !1
        };
    }
    function rR(n) {
        const t = /.*-(\d+)x(\d+)-.*/.exec(n);
        if (t) {
            const [, i, r] = t;
            return {
                blockWidth: Number(i),
                blockHeight: Number(r)
            };
        }
        return null;
    }
    function sR(n) {
        const e = O3(n), t = {
            format: n,
            create: e.f ?? !0,
            render: e.render ?? !0,
            filter: e.filter ?? !0,
            blend: e.blend ?? !0,
            store: e.store ?? !0
        }, i = hg(n), r = n.startsWith("depth") || n.startsWith("stencil"), a = i?.signed, l = i?.integer, u = i?.webgl;
        return t.render &&= !a, t.filter &&= !r && !a && !l && !u, t;
    }
    class aR {
    }
    class oR {
        features;
        disabledFeatures;
        constructor(e = [], t){
            this.features = new Set(e), this.disabledFeatures = t || {};
        }
        *[Symbol.iterator]() {
            yield* this.features;
        }
        has(e) {
            return !this.disabledFeatures?.[e] && this.features.has(e);
        }
    }
    class qi {
        static defaultProps = {
            id: null,
            powerPreference: "high-performance",
            failIfMajorPerformanceCaveat: !1,
            createCanvasContext: void 0,
            onError: (e)=>J.error(e.message)(),
            _reuseDevices: !1,
            _requestMaxLimits: !0,
            _factoryDestroyPolicy: "unused",
            _initializeFeatures: !0,
            _disabledFeatures: {
                "compilation-status-async-webgl": !0
            },
            _resourceDefaults: {},
            webgl: {},
            debug: J.get("debug") || void 0,
            debugShaders: J.get("debug-shaders") || void 0,
            debugFramebuffers: !!J.get("debug-framebuffers"),
            debugWebGL: !!J.get("debug-webgl"),
            debugSpectorJS: void 0,
            debugSpectorJSUrl: void 0,
            _handle: void 0
        };
        get [Symbol.toStringTag]() {
            return "Device";
        }
        constructor(e){
            this.props = {
                ...qi.defaultProps,
                ...e
            }, this.id = this.props.id || Jc(this[Symbol.toStringTag].toLowerCase());
        }
        id;
        props;
        userData = {};
        statsManager = C3;
        timestamp = 0;
        _reused = !1;
        _lumaData = {};
        getTextureFormatCapabilities(e) {
            const t = sR(e), i = (l)=>(typeof l == "string" ? this.features.has(l) : l) ?? !0, r = i(t.create), a = {
                format: e,
                create: r,
                render: r && i(t.render),
                filter: r && i(t.filter),
                blend: r && i(t.blend),
                store: r && i(t.store)
            };
            return this._getDeviceSpecificTextureFormatCapabilities(a);
        }
        isTextureFormatSupported(e, t) {
            return this.getTextureFormatCapabilities(e).create;
        }
        isTextureFormatFilterable(e) {
            return this.getTextureFormatCapabilities(e).filter;
        }
        isTextureFormatRenderable(e) {
            return this.getTextureFormatCapabilities(e).render;
        }
        isTextureFormatCompressed(e) {
            return I3(e);
        }
        loseDevice() {
            return !1;
        }
        reportError(e) {
            this.props.onError(e);
        }
        getDefaultCanvasContext() {
            if (!this.canvasContext) throw new Error("Device has no default CanvasContext. See props.createCanvasContext");
            return this.canvasContext;
        }
        createCommandEncoder(e = {}) {
            throw new Error("not implemented");
        }
        incrementTimestamp() {
            return this.timestamp++;
        }
        onError(e) {
            this.props.onError(e);
        }
        getCanvasContext() {
            return this.getDefaultCanvasContext();
        }
        readPixelsToArrayWebGL(e, t) {
            throw new Error("not implemented");
        }
        readPixelsToBufferWebGL(e, t) {
            throw new Error("not implemented");
        }
        setParametersWebGL(e) {
            throw new Error("not implemented");
        }
        getParametersWebGL(e) {
            throw new Error("not implemented");
        }
        withParametersWebGL(e, t) {
            throw new Error("not implemented");
        }
        clearWebGL(e) {
            throw new Error("not implemented");
        }
        resetWebGL() {
            throw new Error("not implemented");
        }
        static _getCanvasContextProps(e) {
            return e.createCanvasContext === !0 ? {} : e.createCanvasContext;
        }
        _normalizeBufferProps(e) {
            (e instanceof ArrayBuffer || ArrayBuffer.isView(e)) && (e = {
                data: e
            });
            const t = {
                ...e
            };
            return (e.usage || 0) & Ge.INDEX && !e.indexType && (e.data instanceof Uint32Array ? t.indexType = "uint32" : e.data instanceof Uint16Array ? t.indexType = "uint16" : J.warn("indices buffer content must be of integer type")()), t;
        }
    }
    const lR = Dr() && typeof document < "u", cR = ()=>lR && document.readyState === "complete", uR = "set luma.log.level=1 (or higher) to trace rendering", zb = "No matching device found. Ensure `@luma.gl/webgl` and/or `@luma.gl/webgpu` modules are imported.";
    class Ps {
        static defaultProps = {
            ...qi.defaultProps,
            type: "best-available",
            adapters: void 0,
            waitForPageLoad: !0
        };
        static pageLoaded = fR().then(()=>{
            J.probe(2, "DOM is loaded")();
        });
        stats = C3;
        log = J;
        VERSION = "9.1.9";
        spector;
        preregisteredAdapters = new Map;
        constructor(){
            if (globalThis.luma) {
                if (globalThis.luma.VERSION !== this.VERSION) throw J.error(`Found luma.gl ${globalThis.luma.VERSION} while initialzing ${this.VERSION}`)(), J.error("'yarn why @luma.gl/core' can help identify the source of the conflict")(), new Error("luma.gl - multiple versions detected: see console log");
                J.error("This version of luma.gl has already been initialized")();
            }
            J.log(1, `${this.VERSION} - ${uR}`)(), globalThis.luma = this;
        }
        registerAdapters(e) {
            for (const t of e)this.preregisteredAdapters.set(t.type, t);
        }
        getSupportedAdapters(e = []) {
            const t = this.getAdapterMap(e);
            return Array.from(t).map(([, i])=>i).filter((i)=>i.isSupported?.()).map((i)=>i.type);
        }
        getBestAvailableAdapter(e = []) {
            const t = this.getAdapterMap(e);
            return t.get("webgpu")?.isSupported?.() ? "webgpu" : t.get("webgl")?.isSupported?.() ? "webgl" : null;
        }
        setDefaultDeviceProps(e) {
            Object.assign(Ps.defaultProps, e);
        }
        async createDevice(e = {}) {
            e = {
                ...Ps.defaultProps,
                ...e
            }, e.waitForPageLoad && await Ps.pageLoaded;
            const t = this.getAdapterMap(e.adapters);
            let i = e.type || "";
            i === "best-available" && (i = this.getBestAvailableAdapter(e.adapters) || i);
            const l = await (this.getAdapterMap(e.adapters) || t).get(i)?.create?.(e);
            if (l) return l;
            throw new Error(zb);
        }
        async attachDevice(e) {
            const t = this.getAdapterMap(e.adapters);
            let i = "";
            e.handle instanceof WebGL2RenderingContext && (i = "webgl"), e.createCanvasContext && await Ps.pageLoaded, e.handle === null && (i = "unknown");
            const a = await t.get(i)?.attach?.(null);
            if (a) return a;
            throw new Error(zb);
        }
        enforceWebGL2(e = !0, t = []) {
            const r = this.getAdapterMap(t).get("webgl");
            r || J.warn("enforceWebGL2: webgl adapter not found")(), r?.enforceWebGL2?.(e);
        }
        getAdapterMap(e = []) {
            const t = new Map(this.preregisteredAdapters);
            for (const i of e)t.set(i.type, i);
            return t;
        }
        registerDevices(e) {
            J.warn("luma.registerDevices() is deprecated, use luma.registerAdapters() instead");
            for (const t of e){
                const i = t.adapter;
                i && this.preregisteredAdapters.set(i.type, i);
            }
        }
    }
    const wd = new Ps;
    function fR() {
        return cR() || typeof window > "u" ? Promise.resolve() : new Promise((n)=>{
            window.addEventListener("load", ()=>n());
        });
    }
    class hR {
    }
    class dg {
        static defaultProps = {
            canvas: null,
            width: 800,
            height: 600,
            useDevicePixels: !0,
            autoResize: !0,
            container: null,
            visible: !0,
            alphaMode: "opaque",
            colorSpace: "srgb"
        };
        id;
        props;
        canvas;
        htmlCanvas;
        offscreenCanvas;
        type;
        width = 1;
        height = 1;
        resizeObserver;
        _canvasSizeInfo = {
            clientWidth: 0,
            clientHeight: 0,
            devicePixelRatio: 1
        };
        toString() {
            return `${this[Symbol.toStringTag]}(${this.id})`;
        }
        constructor(e){
            if (this.props = {
                ...dg.defaultProps,
                ...e
            }, e = this.props, !Dr()) {
                this.id = "node-canvas-context", this.type = "node", this.width = this.props.width, this.height = this.props.height, this.canvas = null;
                return;
            }
            if (e.canvas) typeof e.canvas == "string" ? this.canvas = gR(e.canvas) : this.canvas = e.canvas;
            else {
                const t = pR(e), i = dR(e?.container || null);
                i.insertBefore(t, i.firstChild), this.canvas = t, e?.visible || (this.canvas.style.visibility = "hidden");
            }
            this.canvas instanceof HTMLCanvasElement ? (this.id = this.canvas.id, this.type = "html-canvas", this.htmlCanvas = this.canvas) : (this.id = "offscreen-canvas", this.type = "offscreen-canvas", this.offscreenCanvas = this.canvas), this.canvas instanceof HTMLCanvasElement && e.autoResize && (this.resizeObserver = new ResizeObserver((t)=>{
                for (const i of t)i.target === this.canvas && this.update();
            }), this.resizeObserver.observe(this.canvas));
        }
        getDevicePixelRatio(e) {
            return typeof OffscreenCanvas < "u" && this.canvas instanceof OffscreenCanvas || (e = e === void 0 ? this.props.useDevicePixels : e, !e || e <= 0) ? 1 : e === !0 ? typeof window < "u" && window.devicePixelRatio || 1 : e;
        }
        getPixelSize() {
            switch(this.type){
                case "node":
                    return [
                        this.width,
                        this.height
                    ];
                case "offscreen-canvas":
                    return [
                        this.canvas.width,
                        this.canvas.height
                    ];
                case "html-canvas":
                    const e = this.getDevicePixelRatio(), t = this.canvas;
                    return t.parentElement ? [
                        t.clientWidth * e,
                        t.clientHeight * e
                    ] : [
                        this.canvas.width,
                        this.canvas.height
                    ];
                default:
                    throw new Error(this.type);
            }
        }
        getAspect() {
            const [e, t] = this.getPixelSize();
            return e / t;
        }
        cssToDeviceRatio() {
            try {
                const [e] = this.getDrawingBufferSize(), t = this._canvasSizeInfo.clientWidth || this.htmlCanvas?.clientWidth;
                return t ? e / t : 1;
            } catch  {
                return 1;
            }
        }
        cssToDevicePixels(e, t = !0) {
            const i = this.cssToDeviceRatio(), [r, a] = this.getDrawingBufferSize();
            return mR(e, i, r, a, t);
        }
        setDevicePixelRatio(e, t = {}) {
            if (!this.htmlCanvas) return;
            let i = "width" in t ? t.width : this.htmlCanvas.clientWidth, r = "height" in t ? t.height : this.htmlCanvas.clientHeight;
            (!i || !r) && (J.log(1, "Canvas clientWidth/clientHeight is 0")(), e = 1, i = this.htmlCanvas.width || 1, r = this.htmlCanvas.height || 1);
            const a = this._canvasSizeInfo;
            if (a.clientWidth !== i || a.clientHeight !== r || a.devicePixelRatio !== e) {
                let l = e;
                const u = Math.floor(i * l), h = Math.floor(r * l);
                if (this.htmlCanvas.width = u, this.htmlCanvas.height = h, this.device.gl) {
                    const [p, _] = this.getDrawingBufferSize();
                    (p !== u || _ !== h) && (l = Math.min(p / i, _ / r), this.htmlCanvas.width = Math.floor(i * l), this.htmlCanvas.height = Math.floor(r * l), J.warn("Device pixel ratio clamped")()), this._canvasSizeInfo.clientWidth = i, this._canvasSizeInfo.clientHeight = r, this._canvasSizeInfo.devicePixelRatio = e;
                }
            }
        }
        getDrawingBufferSize() {
            const e = this.device.gl;
            return e ? [
                e.drawingBufferWidth,
                e.drawingBufferHeight
            ] : this.getPixelSize();
        }
        _setAutoCreatedCanvasId(e) {
            this.htmlCanvas?.id === "lumagl-auto-created-canvas" && (this.htmlCanvas.id = e);
        }
    }
    function dR(n) {
        if (typeof n == "string") {
            const e = document.getElementById(n);
            if (!e) throw new Error(`${n} is not an HTML element`);
            return e;
        } else if (n) return n;
        return document.body;
    }
    function gR(n) {
        const e = document.getElementById(n);
        if (!(e instanceof HTMLCanvasElement)) throw new Error("Object is not a canvas element");
        return e;
    }
    function pR(n) {
        const { width: e, height: t } = n, i = document.createElement("canvas");
        return i.id = Jc("lumagl-auto-created-canvas"), i.width = e || 1, i.height = t || 1, i.style.width = Number.isFinite(e) ? `${e}px` : "100%", i.style.height = Number.isFinite(t) ? `${t}px` : "100%", i;
    }
    function mR(n, e, t, i, r) {
        const a = n, l = Vb(a[0], e, t);
        let u = Hb(a[1], e, i, r), h = Vb(a[0] + 1, e, t);
        const d = h === t - 1 ? h : h - 1;
        h = Hb(a[1] + 1, e, i, r);
        let p;
        return r ? (h = h === 0 ? h : h + 1, p = u, u = h) : p = h === i - 1 ? h : h - 1, {
            x: l,
            y: u,
            width: Math.max(d - l + 1, 1),
            height: Math.max(p - u + 1, 1)
        };
    }
    function Vb(n, e, t) {
        return Math.min(Math.round(n * e), t - 1);
    }
    function Hb(n, e, t, i) {
        return i ? Math.max(0, t - 1 - Math.round(n * e)) : Math.min(Math.round(n * e), t - 1);
    }
    class Xe extends Ye {
        static COPY_SRC = 1;
        static COPY_DST = 2;
        static TEXTURE = 4;
        static STORAGE = 8;
        static RENDER_ATTACHMENT = 16;
        static CubeFaces = [
            "+X",
            "-X",
            "+Y",
            "-Y",
            "+Z",
            "-Z"
        ];
        static defaultProps = {
            ...Ye.defaultProps,
            data: null,
            dimension: "2d",
            format: "rgba8unorm",
            width: void 0,
            height: void 0,
            depth: 1,
            mipmaps: !1,
            compressed: !1,
            usage: 0,
            mipLevels: void 0,
            samples: void 0,
            sampler: {},
            view: void 0,
            flipY: void 0
        };
        get [Symbol.toStringTag]() {
            return "Texture";
        }
        toString() {
            return `Texture(${this.id},${this.format},${this.width}x${this.height})`;
        }
        dimension;
        format;
        width;
        height;
        depth;
        mipLevels;
        updateTimestamp;
        constructor(e, t){
            if (t = Xe.normalizeProps(e, t), super(e, t, Xe.defaultProps), this.dimension = this.props.dimension, this.format = this.props.format, this.width = this.props.width, this.height = this.props.height, this.depth = this.props.depth, this.props.width === void 0 || this.props.height === void 0) {
                const i = Xe.getTextureDataSize(this.props.data);
                this.width = i?.width || 1, this.height = i?.height || 1;
            }
            this.props.mipmaps && this.props.mipLevels === void 0 && (this.props.mipLevels = "pyramid"), this.mipLevels = this.props.mipLevels === "pyramid" ? Xe.getMipLevelCount(this.width, this.height) : this.props.mipLevels || 1, this.updateTimestamp = e.incrementTimestamp();
        }
        clone(e) {
            return this.device.createTexture({
                ...this.props,
                ...e
            });
        }
        static isExternalImage(e) {
            return typeof ImageData < "u" && e instanceof ImageData || typeof ImageBitmap < "u" && e instanceof ImageBitmap || typeof HTMLImageElement < "u" && e instanceof HTMLImageElement || typeof HTMLVideoElement < "u" && e instanceof HTMLVideoElement || typeof VideoFrame < "u" && e instanceof VideoFrame || typeof HTMLCanvasElement < "u" && e instanceof HTMLCanvasElement || typeof OffscreenCanvas < "u" && e instanceof OffscreenCanvas;
        }
        static getExternalImageSize(e) {
            if (typeof ImageData < "u" && e instanceof ImageData || typeof ImageBitmap < "u" && e instanceof ImageBitmap || typeof HTMLCanvasElement < "u" && e instanceof HTMLCanvasElement || typeof OffscreenCanvas < "u" && e instanceof OffscreenCanvas) return {
                width: e.width,
                height: e.height
            };
            if (typeof HTMLImageElement < "u" && e instanceof HTMLImageElement) return {
                width: e.naturalWidth,
                height: e.naturalHeight
            };
            if (typeof HTMLVideoElement < "u" && e instanceof HTMLVideoElement) return {
                width: e.videoWidth,
                height: e.videoHeight
            };
            if (typeof VideoFrame < "u" && e instanceof VideoFrame) return {
                width: e.displayWidth,
                height: e.displayHeight
            };
            throw new Error("Unknown image type");
        }
        static isTextureLevelData(e) {
            const t = e?.data;
            return ArrayBuffer.isView(t);
        }
        static getTextureDataSize(e) {
            if (!e || ArrayBuffer.isView(e)) return null;
            if (Array.isArray(e)) return Xe.getTextureDataSize(e[0]);
            if (Xe.isExternalImage(e)) return Xe.getExternalImageSize(e);
            if (e && typeof e == "object" && e.constructor === Object) {
                const i = Object.values(e)[0];
                return {
                    width: i.width,
                    height: i.height
                };
            }
            throw new Error("texture size deduction failed");
        }
        static normalizeTextureData(e, t) {
            let i;
            return ArrayBuffer.isView(e) ? i = [
                {
                    data: e,
                    width: t.width,
                    height: t.height
                }
            ] : Array.isArray(e) ? i = e : i = [
                e
            ], i;
        }
        static getMipLevelCount(e, t) {
            return Math.floor(Math.log2(Math.max(e, t))) + 1;
        }
        static getCubeFaceDepth(e) {
            switch(e){
                case "+X":
                    return 0;
                case "-X":
                    return 1;
                case "+Y":
                    return 2;
                case "-Y":
                    return 3;
                case "+Z":
                    return 4;
                case "-Z":
                    return 5;
                default:
                    throw new Error(e);
            }
        }
        static defaultCopyExternalImageOptions = {
            image: void 0,
            sourceX: 0,
            sourceY: 0,
            width: void 0,
            height: void 0,
            depth: 1,
            mipLevel: 0,
            x: 0,
            y: 0,
            z: 0,
            aspect: "all",
            colorSpace: "srgb",
            premultipliedAlpha: !1,
            flipY: !1
        };
        static normalizeProps(e, t) {
            const i = {
                ...t
            }, r = e?.props?._resourceDefaults?.texture || {};
            Object.assign(i, r);
            const { width: a, height: l } = i;
            return typeof a == "number" && (i.width = Math.max(1, Math.ceil(a))), typeof l == "number" && (i.height = Math.max(1, Math.ceil(l))), i;
        }
    }
    class eu extends Ye {
        static defaultProps = {
            ...Ye.defaultProps,
            format: void 0,
            dimension: void 0,
            aspect: "all",
            baseMipLevel: 0,
            mipLevelCount: void 0,
            baseArrayLayer: 0,
            arrayLayerCount: void 0
        };
        get [Symbol.toStringTag]() {
            return "TextureView";
        }
        constructor(e, t){
            super(e, t, eu.defaultProps);
        }
    }
    function _R(n, e, t) {
        let i = "";
        const r = e.split(/\r?\n/), a = n.slice().sort((l, u)=>l.lineNum - u.lineNum);
        switch(t?.showSourceCode || "no"){
            case "all":
                let l = 0;
                for(let u = 1; u <= r.length; u++)for(i += N3(r[u - 1], u, t); a.length > l && a[l].lineNum === u;){
                    const h = a[l++];
                    i += jb(h, r, h.lineNum, {
                        ...t,
                        inlineSource: !1
                    });
                }
                return i;
            case "issues":
            case "no":
                for (const u of n)i += jb(u, r, u.lineNum, {
                    inlineSource: t?.showSourceCode !== "no"
                });
                return i;
        }
    }
    function jb(n, e, t, i) {
        if (i?.inlineSource) {
            const a = yR(e, t), l = n.linePos > 0 ? `${" ".repeat(n.linePos + 5)}^^^
` : "";
            return `
${a}${l}${n.type.toUpperCase()}: ${n.message}

`;
        }
        const r = n.type === "error" ? "red" : "#8B4000";
        return i?.html ? `<div class='luma-compiler-log-error' style="color:${r};"><b> ${n.type.toUpperCase()}: ${n.message}</b></div>` : `${n.type.toUpperCase()}: ${n.message}`;
    }
    function yR(n, e, t) {
        let i = "";
        for(let r = e - 2; r <= e; r++){
            const a = n[r - 1];
            a !== void 0 && (i += N3(a, e, t));
        }
        return i;
    }
    function N3(n, e, t) {
        const i = t?.html ? vR(n) : n;
        return `${bR(String(e), 4)}: ${i}${t?.html ? "<br/>" : `
`}`;
    }
    function bR(n, e) {
        let t = "";
        for(let i = n.length; i < e; ++i)t += " ";
        return t + n;
    }
    function vR(n) {
        return n.replaceAll("&", "&amp;").replaceAll("<", "&lt;").replaceAll(">", "&gt;").replaceAll('"', "&quot;").replaceAll("'", "&#039;");
    }
    class tu extends Ye {
        static defaultProps = {
            ...Ye.defaultProps,
            language: "auto",
            stage: void 0,
            source: "",
            sourceMap: null,
            entryPoint: "main",
            debugShaders: void 0
        };
        get [Symbol.toStringTag]() {
            return "Shader";
        }
        stage;
        source;
        compilationStatus = "pending";
        constructor(e, t){
            t = {
                ...t,
                debugShaders: t.debugShaders || e.props.debugShaders || "errors"
            }, super(e, {
                id: TR(t),
                ...t
            }, tu.defaultProps), this.stage = this.props.stage, this.source = this.props.source;
        }
        getCompilationInfoSync() {
            return null;
        }
        getTranslatedSource() {
            return null;
        }
        async debugShader() {
            const e = this.props.debugShaders;
            switch(e){
                case "never":
                    return;
                case "errors":
                    if (this.compilationStatus === "success") return;
                    break;
            }
            const t = await this.getCompilationInfo();
            e === "warnings" && t?.length === 0 || this._displayShaderLog(t);
        }
        _displayShaderLog(e) {
            if (typeof document > "u" || !document?.createElement) return;
            const t = P3(this.source), i = `${this.stage} ${t}`;
            let r = _R(e, this.source, {
                showSourceCode: "all",
                html: !0
            });
            const a = this.getTranslatedSource();
            a && (r += `<br /><br /><h1>Translated Source</h1><br /><br /><code style="user-select:text;"><pre>${a}</pre></code>`);
            const l = document.createElement("Button");
            l.innerHTML = `
<h1>Shader Compilation Error in ${i}</h1><br /><br />
<code style="user-select:text;"><pre>
${r}
</pre></code>`, l.style.top = "10px", l.style.left = "10px", l.style.position = "absolute", l.style.zIndex = "9999", l.style.width = "100%", l.style.textAlign = "left", document.body.appendChild(l), document.getElementsByClassName("luma-compiler-log-error")[0]?.scrollIntoView(), l.onclick = ()=>{
                const h = `data:text/plain,${encodeURIComponent(this.source)}`;
                navigator.clipboard.writeText(h);
            };
        }
    }
    function TR(n) {
        return P3(n.source) || n.id || Jc(`unnamed ${n.stage}-shader`);
    }
    function P3(n, e = "unnamed") {
        const i = /#define[\s*]SHADER_NAME[\s*]([A-Za-z0-9_-]+)[\s*]/.exec(n);
        return i ? i[1] : e;
    }
    class vo extends Ye {
        static defaultProps = {
            ...Ye.defaultProps,
            type: "color-sampler",
            addressModeU: "clamp-to-edge",
            addressModeV: "clamp-to-edge",
            addressModeW: "clamp-to-edge",
            magFilter: "nearest",
            minFilter: "nearest",
            mipmapFilter: "none",
            lodMinClamp: 0,
            lodMaxClamp: 32,
            compare: "less-equal",
            maxAnisotropy: 1
        };
        get [Symbol.toStringTag]() {
            return "Sampler";
        }
        constructor(e, t){
            t = vo.normalizeProps(e, t), super(e, t, vo.defaultProps);
        }
        static normalizeProps(e, t) {
            const i = e?.props?._resourceDefaults?.sampler || {};
            return {
                ...t,
                ...i
            };
        }
    }
    class nu extends Ye {
        static defaultProps = {
            ...Ye.defaultProps,
            width: 1,
            height: 1,
            colorAttachments: [],
            depthStencilAttachment: null
        };
        get [Symbol.toStringTag]() {
            return "Framebuffer";
        }
        width;
        height;
        constructor(e, t = {}){
            super(e, t, nu.defaultProps), this.width = this.props.width, this.height = this.props.height;
        }
        clone(e) {
            const t = this.colorAttachments.map((r)=>r.texture.clone(e)), i = this.depthStencilAttachment && this.depthStencilAttachment.texture.clone(e);
            return this.device.createFramebuffer({
                ...this.props,
                colorAttachments: t,
                depthStencilAttachment: i
            });
        }
        resize(e) {
            let t = !e;
            if (e) {
                const [i, r] = Array.isArray(e) ? e : [
                    e.width,
                    e.height
                ];
                t = t || r !== this.height || i !== this.width, this.width = i, this.height = r;
            }
            t && (J.log(2, `Resizing framebuffer ${this.id} to ${this.width}x${this.height}`)(), this.resizeAttachments(this.width, this.height));
        }
        autoCreateAttachmentTextures() {
            if (this.props.colorAttachments.length === 0 && !this.props.depthStencilAttachment) throw new Error("Framebuffer has noattachments");
            this.colorAttachments = this.props.colorAttachments.map((t, i)=>{
                if (typeof t == "string") {
                    const r = this.createColorTexture(t, i);
                    return this.attachResource(r), r.view;
                }
                return t instanceof Xe ? t.view : t;
            });
            const e = this.props.depthStencilAttachment;
            if (e) if (typeof e == "string") {
                const t = this.createDepthStencilTexture(e);
                this.attachResource(t), this.depthStencilAttachment = t.view;
            } else e instanceof Xe ? this.depthStencilAttachment = e.view : this.depthStencilAttachment = e;
        }
        createColorTexture(e, t) {
            return this.device.createTexture({
                id: `${this.id}-color-attachment-${t}`,
                usage: Xe.RENDER_ATTACHMENT,
                format: e,
                width: this.width,
                height: this.height,
                sampler: {
                    magFilter: "linear",
                    minFilter: "linear"
                }
            });
        }
        createDepthStencilTexture(e) {
            return this.device.createTexture({
                id: `${this.id}-depth-stencil-attachment`,
                usage: Xe.RENDER_ATTACHMENT,
                format: e,
                width: this.width,
                height: this.height,
                mipmaps: !1
            });
        }
        resizeAttachments(e, t) {
            for(let i = 0; i < this.colorAttachments.length; ++i)if (this.colorAttachments[i]) {
                const r = this.colorAttachments[i].texture.clone({
                    width: e,
                    height: t
                });
                this.destroyAttachedResource(this.colorAttachments[i]), this.colorAttachments[i] = r.view, this.attachResource(r.view);
            }
            if (this.depthStencilAttachment) {
                const i = this.depthStencilAttachment.texture.clone({
                    width: e,
                    height: t
                });
                this.destroyAttachedResource(this.depthStencilAttachment), this.depthStencilAttachment = i.view, this.attachResource(i);
            }
            this.updateAttachments();
        }
    }
    class $s extends Ye {
        static defaultProps = {
            ...Ye.defaultProps,
            vs: null,
            vertexEntryPoint: "vertexMain",
            vsConstants: {},
            fs: null,
            fragmentEntryPoint: "fragmentMain",
            fsConstants: {},
            shaderLayout: null,
            bufferLayout: [],
            topology: "triangle-list",
            parameters: {},
            bindings: {},
            uniforms: {}
        };
        get [Symbol.toStringTag]() {
            return "RenderPipeline";
        }
        shaderLayout;
        bufferLayout;
        linkStatus = "pending";
        hash = "";
        constructor(e, t){
            super(e, t, $s.defaultProps), this.shaderLayout = this.props.shaderLayout, this.bufferLayout = this.props.bufferLayout || [];
        }
        setUniformsWebGL(e) {
            throw new Error("Use uniform blocks");
        }
    }
    class vr extends Ye {
        static defaultClearColor = [
            0,
            0,
            0,
            1
        ];
        static defaultClearDepth = 1;
        static defaultClearStencil = 0;
        static defaultProps = {
            ...Ye.defaultProps,
            framebuffer: null,
            parameters: void 0,
            clearColor: vr.defaultClearColor,
            clearColors: void 0,
            clearDepth: vr.defaultClearDepth,
            clearStencil: vr.defaultClearStencil,
            depthReadOnly: !1,
            stencilReadOnly: !1,
            discard: !1,
            occlusionQuerySet: void 0,
            timestampQuerySet: void 0,
            beginTimestampIndex: void 0,
            endTimestampIndex: void 0
        };
        get [Symbol.toStringTag]() {
            return "RenderPass";
        }
        constructor(e, t){
            t = vr.normalizeProps(e, t), super(e, t, vr.defaultProps);
        }
        static normalizeProps(e, t) {
            return {
                ...e.props._resourceDefaults?.renderPass,
                ...t
            };
        }
    }
    class wc extends Ye {
        static defaultProps = {
            ...Ye.defaultProps,
            shader: void 0,
            entryPoint: void 0,
            constants: {},
            shaderLayout: void 0
        };
        get [Symbol.toStringTag]() {
            return "ComputePipeline";
        }
        hash = "";
        shaderLayout;
        constructor(e, t){
            super(e, t, wc.defaultProps), this.shaderLayout = t.shaderLayout;
        }
    }
    class gg extends Ye {
        static defaultProps = {
            ...Ye.defaultProps,
            measureExecutionTime: void 0
        };
        get [Symbol.toStringTag]() {
            return "CommandEncoder";
        }
        constructor(e, t){
            super(e, t, gg.defaultProps);
        }
    }
    class pg extends Ye {
        static defaultProps = {
            ...Ye.defaultProps
        };
        get [Symbol.toStringTag]() {
            return "CommandBuffer";
        }
        constructor(e, t){
            super(e, t, pg.defaultProps);
        }
    }
    function xR(n) {
        const [e, t] = AR[n], i = e === "i32" || e === "u32", r = e !== "u32", a = wR[e] * t, l = SR(e, t);
        return {
            dataType: e,
            components: t,
            defaultVertexFormat: l,
            byteLength: a,
            integer: i,
            signed: r
        };
    }
    function SR(n, e) {
        let t;
        switch(n){
            case "f32":
                t = "float32";
                break;
            case "i32":
                t = "sint32";
                break;
            case "u32":
                t = "uint32";
                break;
            case "f16":
                return e <= 2 ? "float16x2" : "float16x4";
        }
        return e === 1 ? t : `${t}x${e}`;
    }
    const AR = {
        f32: [
            "f32",
            1
        ],
        "vec2<f32>": [
            "f32",
            2
        ],
        "vec3<f32>": [
            "f32",
            3
        ],
        "vec4<f32>": [
            "f32",
            4
        ],
        f16: [
            "f16",
            1
        ],
        "vec2<f16>": [
            "f16",
            2
        ],
        "vec3<f16>": [
            "f16",
            3
        ],
        "vec4<f16>": [
            "f16",
            4
        ],
        i32: [
            "i32",
            1
        ],
        "vec2<i32>": [
            "i32",
            2
        ],
        "vec3<i32>": [
            "i32",
            3
        ],
        "vec4<i32>": [
            "i32",
            4
        ],
        u32: [
            "u32",
            1
        ],
        "vec2<u32>": [
            "u32",
            2
        ],
        "vec3<u32>": [
            "u32",
            3
        ],
        "vec4<u32>": [
            "u32",
            4
        ]
    }, wR = {
        f32: 4,
        f16: 2,
        i32: 4,
        u32: 4
    };
    function D3(n) {
        let e;
        n.endsWith("-webgl") && (n.replace("-webgl", ""), e = !0);
        const [t, i] = n.split("x"), r = t, a = i ? parseInt(i) : 1, l = M3(r), u = {
            type: r,
            components: a,
            byteLength: l.byteLength * a,
            integer: l.integer,
            signed: l.signed,
            normalized: l.normalized
        };
        return e && (u.webglOnly = !0), u;
    }
    function k3(n, e) {
        const t = {};
        for (const i of n.attributes){
            const r = RR(n, e, i.name);
            r && (t[i.name] = r);
        }
        return t;
    }
    function ER(n, e, t = 16) {
        const i = k3(n, e), r = new Array(t).fill(null);
        for (const a of Object.values(i))r[a.location] = a;
        return r;
    }
    function RR(n, e, t) {
        const i = CR(n, t), r = MR(e, t);
        if (!i) return null;
        const a = xR(i.type), l = r?.vertexFormat || a.defaultVertexFormat, u = D3(l);
        return {
            attributeName: r?.attributeName || i.name,
            bufferName: r?.bufferName || i.name,
            location: i.location,
            shaderType: i.type,
            shaderDataType: a.dataType,
            shaderComponents: a.components,
            vertexFormat: l,
            bufferDataType: u.type,
            bufferComponents: u.components,
            normalized: u.normalized,
            integer: a.integer,
            stepMode: r?.stepMode || i.stepMode || "vertex",
            byteOffset: r?.byteOffset || 0,
            byteStride: r?.byteStride || 0
        };
    }
    function CR(n, e) {
        const t = n.attributes.find((i)=>i.name === e);
        return t || J.warn(`shader layout attribute "${e}" not present in shader`), t || null;
    }
    function MR(n, e) {
        OR(n);
        let t = IR(n, e);
        return t || (t = NR(n, e), t) ? t : (J.warn(`layout for attribute "${e}" not present in buffer layout`), null);
    }
    function OR(n) {
        for (const e of n)(e.attributes && e.format || !e.attributes && !e.format) && J.warn(`BufferLayout ${name} must have either 'attributes' or 'format' field`);
    }
    function IR(n, e) {
        for (const t of n)if (t.format && t.name === e) return {
            attributeName: t.name,
            bufferName: e,
            stepMode: t.stepMode,
            vertexFormat: t.format,
            byteOffset: 0,
            byteStride: t.byteStride || 0
        };
        return null;
    }
    function NR(n, e) {
        for (const t of n){
            let i = t.byteStride;
            if (typeof t.byteStride != "number") for (const a of t.attributes || []){
                const l = D3(a.format);
                i += l.byteLength;
            }
            const r = t.attributes?.find((a)=>a.attribute === e);
            if (r) return {
                attributeName: r.attribute,
                bufferName: t.name,
                stepMode: t.stepMode,
                vertexFormat: r.format,
                byteOffset: r.byteOffset,
                byteStride: i
            };
        }
        return null;
    }
    class mg extends Ye {
        static defaultProps = {
            ...Ye.defaultProps,
            renderPipeline: null
        };
        get [Symbol.toStringTag]() {
            return "VertexArray";
        }
        maxVertexAttributes;
        attributeInfos;
        indexBuffer = null;
        attributes;
        constructor(e, t){
            super(e, t, mg.defaultProps), this.maxVertexAttributes = e.limits.maxVertexAttributes, this.attributes = new Array(this.maxVertexAttributes).fill(null);
            const { shaderLayout: i, bufferLayout: r } = t.renderPipeline || {};
            if (!i || !r) throw new Error("VertexArray");
            this.attributeInfos = ER(i, r, this.maxVertexAttributes);
        }
        setConstantWebGL(e, t) {
            this.device.reportError(new Error("constant attributes not supported"));
        }
    }
    class _g extends Ye {
        static defaultProps = {
            ...Ye.defaultProps,
            layout: void 0,
            buffers: {}
        };
        get [Symbol.toStringTag]() {
            return "TransformFeedback";
        }
        constructor(e, t){
            super(e, t, _g.defaultProps);
        }
    }
    class yg extends Ye {
        static defaultProps = {
            ...Ye.defaultProps,
            type: void 0,
            count: void 0
        };
        get [Symbol.toStringTag]() {
            return "QuerySet";
        }
        constructor(e, t){
            super(e, t, yg.defaultProps);
        }
    }
    const PR = {
        f32: {
            type: "f32",
            components: 1
        },
        i32: {
            type: "i32",
            components: 1
        },
        u32: {
            type: "u32",
            components: 1
        },
        "vec2<f32>": {
            type: "f32",
            components: 2
        },
        "vec3<f32>": {
            type: "f32",
            components: 3
        },
        "vec4<f32>": {
            type: "f32",
            components: 4
        },
        "vec2<i32>": {
            type: "i32",
            components: 2
        },
        "vec3<i32>": {
            type: "i32",
            components: 3
        },
        "vec4<i32>": {
            type: "i32",
            components: 4
        },
        "vec2<u32>": {
            type: "u32",
            components: 2
        },
        "vec3<u32>": {
            type: "u32",
            components: 3
        },
        "vec4<u32>": {
            type: "u32",
            components: 4
        },
        "mat2x2<f32>": {
            type: "f32",
            components: 4
        },
        "mat2x3<f32>": {
            type: "f32",
            components: 6
        },
        "mat2x4<f32>": {
            type: "f32",
            components: 8
        },
        "mat3x2<f32>": {
            type: "f32",
            components: 6
        },
        "mat3x3<f32>": {
            type: "f32",
            components: 9
        },
        "mat3x4<f32>": {
            type: "f32",
            components: 12
        },
        "mat4x2<f32>": {
            type: "f32",
            components: 8
        },
        "mat4x3<f32>": {
            type: "f32",
            components: 12
        },
        "mat4x4<f32>": {
            type: "f32",
            components: 16
        }
    };
    function DR(n) {
        return PR[n];
    }
    function kR(n, e) {
        switch(e){
            case 1:
                return n;
            case 2:
                return n + n % 2;
            default:
                return n + (4 - n % 4) % 4;
        }
    }
    let Jl;
    function U3(n) {
        return (!Jl || Jl.byteLength < n) && (Jl = new ArrayBuffer(n)), Jl;
    }
    function UR(n, e) {
        const t = U3(n.BYTES_PER_ELEMENT * e);
        return new n(t, 0, e);
    }
    function BR(n) {
        return ArrayBuffer.isView(n) && !(n instanceof DataView);
    }
    function Ec(n) {
        return Array.isArray(n) ? n.length === 0 || typeof n[0] == "number" : BR(n);
    }
    const Wb = 1024;
    class LR {
        layout = {};
        byteLength;
        constructor(e){
            let t = 0;
            for (const [r, a] of Object.entries(e)){
                const l = DR(a), { type: u, components: h } = l;
                t = kR(t, h);
                const d = t;
                t += h, this.layout[r] = {
                    type: u,
                    size: h,
                    offset: d
                };
            }
            t += (4 - t % 4) % 4;
            const i = t * 4;
            this.byteLength = Math.max(i, Wb);
        }
        getData(e) {
            const t = Math.max(this.byteLength, Wb), i = U3(t), r = {
                i32: new Int32Array(i),
                u32: new Uint32Array(i),
                f32: new Float32Array(i),
                f16: new Uint16Array(i)
            };
            for (const [a, l] of Object.entries(e)){
                const u = this.layout[a];
                if (!u) {
                    J.warn(`Supplied uniform value ${a} not present in uniform block layout`)();
                    continue;
                }
                const { type: h, size: d, offset: p } = u, _ = r[h];
                if (d === 1) {
                    if (typeof l != "number" && typeof l != "boolean") {
                        J.warn(`Supplied value for single component uniform ${a} is not a number: ${l}`)();
                        continue;
                    }
                    _[p] = Number(l);
                } else {
                    if (!Ec(l)) {
                        J.warn(`Supplied value for multi component / array uniform ${a} is not a numeric array: ${l}`)();
                        continue;
                    }
                    _.set(l, p);
                }
            }
            return new Uint8Array(i);
        }
        has(e) {
            return !!this.layout[e];
        }
        get(e) {
            return this.layout[e];
        }
    }
    function FR(n, e, t = 16) {
        if (n !== e) return !1;
        const i = n, r = e;
        if (!Ec(i)) return !1;
        if (Ec(r) && i.length === r.length) {
            for(let a = 0; a < i.length; ++a)if (r[a] !== i[a]) return !1;
        }
        return !0;
    }
    function zR(n) {
        return Ec(n) ? n.slice() : n;
    }
    class VR {
        name;
        uniforms = {};
        modifiedUniforms = {};
        modified = !0;
        bindingLayout = {};
        needsRedraw = "initialized";
        constructor(e){
            if (this.name = e?.name || "unnamed", e?.name && e?.shaderLayout) {
                const t = e?.shaderLayout.bindings?.find((r)=>r.type === "uniform" && r.name === e?.name);
                if (!t) throw new Error(e?.name);
                const i = t;
                for (const r of i.uniforms || [])this.bindingLayout[r.name] = r;
            }
        }
        setUniforms(e) {
            for (const [t, i] of Object.entries(e))this._setUniform(t, i), this.needsRedraw || this.setNeedsRedraw(`${this.name}.${t}=${i}`);
        }
        setNeedsRedraw(e) {
            this.needsRedraw = this.needsRedraw || e;
        }
        getAllUniforms() {
            return this.modifiedUniforms = {}, this.needsRedraw = !1, this.uniforms || {};
        }
        _setUniform(e, t) {
            FR(this.uniforms[e], t) || (this.uniforms[e] = zR(t), this.modifiedUniforms[e] = !0, this.modified = !0);
        }
    }
    class HR {
        uniformBlocks = new Map;
        uniformBufferLayouts = new Map;
        uniformBuffers = new Map;
        constructor(e){
            for (const [t, i] of Object.entries(e)){
                const r = t, a = new LR(i.uniformTypes || {});
                this.uniformBufferLayouts.set(r, a);
                const l = new VR({
                    name: t
                });
                l.setUniforms(i.defaultUniforms || {}), this.uniformBlocks.set(r, l);
            }
        }
        destroy() {
            for (const e of this.uniformBuffers.values())e.destroy();
        }
        setUniforms(e) {
            for (const [t, i] of Object.entries(e))this.uniformBlocks.get(t)?.setUniforms(i);
            this.updateUniformBuffers();
        }
        getUniformBufferByteLength(e) {
            return this.uniformBufferLayouts.get(e)?.byteLength || 0;
        }
        getUniformBufferData(e) {
            const t = this.uniformBlocks.get(e)?.getAllUniforms() || {};
            return this.uniformBufferLayouts.get(e)?.getData(t);
        }
        createUniformBuffer(e, t, i) {
            i && this.setUniforms(i);
            const r = this.getUniformBufferByteLength(t), a = e.createBuffer({
                usage: Ge.UNIFORM | Ge.COPY_DST,
                byteLength: r
            }), l = this.getUniformBufferData(t);
            return a.write(l), a;
        }
        getManagedUniformBuffer(e, t) {
            if (!this.uniformBuffers.get(t)) {
                const i = this.getUniformBufferByteLength(t), r = e.createBuffer({
                    usage: Ge.UNIFORM | Ge.COPY_DST,
                    byteLength: i
                });
                this.uniformBuffers.set(t, r);
            }
            return this.uniformBuffers.get(t);
        }
        updateUniformBuffers() {
            let e = !1;
            for (const t of this.uniformBlocks.keys()){
                const i = this.updateUniformBuffer(t);
                e ||= i;
            }
            return e && J.log(3, `UniformStore.updateUniformBuffers(): ${e}`)(), e;
        }
        updateUniformBuffer(e) {
            const t = this.uniformBlocks.get(e);
            let i = this.uniformBuffers.get(e), r = !1;
            if (i && t?.needsRedraw) {
                r ||= t.needsRedraw;
                const a = this.getUniformBufferData(e);
                i = this.uniformBuffers.get(e), i?.write(a);
                const l = this.uniformBlocks.get(e)?.getAllUniforms();
                J.log(4, `Writing to uniform buffer ${String(e)}`, a, l)();
            }
            return r;
        }
    }
    function B3(n) {
        const e = ArrayBuffer.isView(n) ? n.constructor : n;
        switch(e){
            case Float32Array:
                return "float32";
            case Uint16Array:
                return "uint16";
            case Uint32Array:
                return "uint32";
            case Uint8Array:
            case Uint8ClampedArray:
                return "uint8";
            case Int8Array:
                return "sint8";
            case Int16Array:
                return "sint16";
            case Int32Array:
                return "sint32";
            default:
                throw new Error(e.constructor.name);
        }
    }
    function L3(n) {
        switch(n){
            case "float32":
                return Float32Array;
            case "uint32":
                return Uint32Array;
            case "sint32":
                return Int32Array;
            case "uint16":
            case "unorm16":
                return Uint16Array;
            case "sint16":
            case "snorm16":
                return Int16Array;
            case "uint8":
            case "unorm8":
                return Uint8Array;
            case "sint8":
            case "snorm8":
                return Int8Array;
            default:
                throw new Error(n);
        }
    }
    function jR(n, e, t) {
        if (!e || e > 4) throw new Error(`size ${e}`);
        const i = e;
        let r = B3(n);
        if (r === "uint8" && t && i === 1) return "unorm8-webgl";
        if (r === "uint8" && t && i === 3) return "unorm8x3-webgl";
        if (r === "uint8" || r === "sint8") {
            if (i === 1 || i === 3) throw new Error(`size: ${e}`);
            return t && (r = r.replace("int", "norm")), `${r}x${i}`;
        }
        if (r === "uint16" || r === "sint16") {
            if (i === 1 || i === 3) throw new Error(`size: ${e}`);
            return t && (r = r.replace("int", "norm")), `${r}x${i}`;
        }
        return i === 1 ? r : `${r}x${i}`;
    }
    class Vh {
        bufferLayouts;
        constructor(e){
            this.bufferLayouts = e;
        }
        getBufferLayout(e) {
            return this.bufferLayouts.find((t)=>t.name === e) || null;
        }
        getAttributeNamesForBuffer(e) {
            return e.attributes ? e.attributes?.map((t)=>t.attribute) : [
                e.name
            ];
        }
        mergeBufferLayouts(e, t) {
            const i = [
                ...e
            ];
            for (const r of t){
                const a = i.findIndex((l)=>l.name === r.name);
                a < 0 ? i.push(r) : i[a] = r;
            }
            return i;
        }
        getBufferIndex(e) {
            const t = this.bufferLayouts.findIndex((i)=>i.name === e);
            return t === -1 && J.warn(`BufferLayout: Missing buffer for "${e}".`)(), t;
        }
    }
    function WR(n, e) {
        const t = Object.fromEntries(n.attributes.map((r)=>[
                r.name,
                r.location
            ])), i = e.slice();
        return i.sort((r, a)=>{
            const l = r.attributes ? r.attributes.map((p)=>p.attribute) : [
                r.name
            ], u = a.attributes ? a.attributes.map((p)=>p.attribute) : [
                a.name
            ], h = Math.min(...l.map((p)=>t[p])), d = Math.min(...u.map((p)=>t[p]));
            return h - d;
        }), i;
    }
    class _n {
        constructor(e, t){
            this.name = e, this.attributes = t, this.size = 0;
        }
        get isArray() {
            return !1;
        }
        get isStruct() {
            return !1;
        }
        get isTemplate() {
            return !1;
        }
        getTypeName() {
            return this.name;
        }
    }
    class $b {
        constructor(e, t, i){
            this.name = e, this.type = t, this.attributes = i, this.offset = 0, this.size = 0;
        }
        get isArray() {
            return this.type.isArray;
        }
        get isStruct() {
            return this.type.isStruct;
        }
        get isTemplate() {
            return this.type.isTemplate;
        }
        get align() {
            return this.type.isStruct ? this.type.align : 0;
        }
        get members() {
            return this.type.isStruct ? this.type.members : null;
        }
        get format() {
            return this.type.isArray || this.type.isTemplate ? this.type.format : null;
        }
        get count() {
            return this.type.isArray ? this.type.count : 0;
        }
        get stride() {
            return this.type.isArray ? this.type.stride : this.size;
        }
    }
    class $i extends _n {
        constructor(e, t){
            super(e, t), this.members = [], this.align = 0, this.startLine = -1, this.endLine = -1, this.inUse = !1;
        }
        get isStruct() {
            return !0;
        }
    }
    class Ki extends _n {
        constructor(e, t){
            super(e, t), this.count = 0, this.stride = 0;
        }
        get isArray() {
            return !0;
        }
    }
    class Mr extends _n {
        constructor(e, t, i, r){
            super(e, i), this.format = t, this.access = r;
        }
        get isTemplate() {
            return !0;
        }
        getTypeName() {
            let e = this.name;
            if (this.format !== null) {
                if (e === "vec2" || e === "vec3" || e === "vec4" || e === "mat2x2" || e === "mat2x3" || e === "mat2x4" || e === "mat3x2" || e === "mat3x3" || e === "mat3x4" || e === "mat4x2" || e === "mat4x3" || e === "mat4x4") {
                    if (this.format.name === "f32") return e += "f", e;
                    if (this.format.name === "i32") return e += "i", e;
                    if (this.format.name === "u32") return e += "u", e;
                    if (this.format.name === "bool") return e += "b", e;
                    if (this.format.name === "f16") return e += "h", e;
                }
                e += `<${this.format.name}>`;
            } else if (e === "vec2" || e === "vec3" || e === "vec4") return e;
            return e;
        }
    }
    var ji;
    ((n)=>{
        n[n.Uniform = 0] = "Uniform", n[n.Storage = 1] = "Storage", n[n.Texture = 2] = "Texture", n[n.Sampler = 3] = "Sampler", n[n.StorageTexture = 4] = "StorageTexture";
    })(ji || (ji = {}));
    class ec {
        constructor(e, t, i, r, a, l, u){
            this.name = e, this.type = t, this.group = i, this.binding = r, this.attributes = a, this.resourceType = l, this.access = u;
        }
        get isArray() {
            return this.type.isArray;
        }
        get isStruct() {
            return this.type.isStruct;
        }
        get isTemplate() {
            return this.type.isTemplate;
        }
        get size() {
            return this.type.size;
        }
        get align() {
            return this.type.isStruct ? this.type.align : 0;
        }
        get members() {
            return this.type.isStruct ? this.type.members : null;
        }
        get format() {
            return this.type.isArray || this.type.isTemplate ? this.type.format : null;
        }
        get count() {
            return this.type.isArray ? this.type.count : 0;
        }
        get stride() {
            return this.type.isArray ? this.type.stride : this.size;
        }
    }
    class $R {
        constructor(e, t){
            this.name = e, this.type = t;
        }
    }
    class XR {
        constructor(e, t, i, r){
            this.name = e, this.type = t, this.locationType = i, this.location = r, this.interpolation = null;
        }
    }
    class Xb {
        constructor(e, t, i, r){
            this.name = e, this.type = t, this.locationType = i, this.location = r;
        }
    }
    class YR {
        constructor(e, t, i, r){
            this.name = e, this.type = t, this.attributes = i, this.id = r;
        }
    }
    class qR {
        constructor(e, t, i){
            this.name = e, this.type = t, this.attributes = i;
        }
    }
    class KR {
        constructor(e, t = null, i){
            this.stage = null, this.inputs = [], this.outputs = [], this.arguments = [], this.returnType = null, this.resources = [], this.overrides = [], this.startLine = -1, this.endLine = -1, this.inUse = !1, this.calls = new Set, this.name = e, this.stage = t, this.attributes = i;
        }
    }
    class ZR {
        constructor(){
            this.vertex = [], this.fragment = [], this.compute = [];
        }
    }
    const F3 = new Float32Array(1), QR = new Int32Array(F3.buffer), Mt = new Uint16Array(1);
    function GR(n) {
        F3[0] = n;
        const e = QR[0], t = e >> 31 & 1;
        let i = e >> 23 & 255, r = 8388607 & e;
        if (i === 255) return Mt[0] = t << 15 | 31744 | (r !== 0 ? 512 : 0), Mt[0];
        if (i === 0) {
            if (r === 0) return Mt[0] = t << 15, Mt[0];
            r |= 8388608;
            let a = 113;
            for(; !(8388608 & r);)r <<= 1, a--;
            return i = 127 - a, r &= 8388607, i > 0 ? (r = (r >> 126 - i) + (r >> 127 - i & 1), Mt[0] = t << 15 | i << 10 | r >> 13, Mt[0]) : (Mt[0] = t << 15, Mt[0]);
        }
        return i = i - 127 + 15, i >= 31 ? (Mt[0] = t << 15 | 31744, Mt[0]) : i <= 0 ? i < -10 ? (Mt[0] = t << 15, Mt[0]) : (r = (8388608 | r) >> 1 - i, Mt[0] = t << 15 | r >> 13, Mt[0]) : (r >>= 13, Mt[0] = t << 15 | i << 10 | r, Mt[0]);
    }
    const bg = new Uint32Array(1), z3 = new Float32Array(bg.buffer, 0, 1);
    function Yb(n) {
        const e = 112 + (n >> 6 & 31) << 23 | (63 & n) << 17;
        return bg[0] = e, z3[0];
    }
    function JR(n, e, t, i, r, a, l, u, h) {
        const d = i * (l >>= r) * (a >>= r) + t * l + e * u;
        switch(h){
            case "r8unorm":
                return [
                    Be(n, d, "8unorm", 1)[0]
                ];
            case "r8snorm":
                return [
                    Be(n, d, "8snorm", 1)[0]
                ];
            case "r8uint":
                return [
                    Be(n, d, "8uint", 1)[0]
                ];
            case "r8sint":
                return [
                    Be(n, d, "8sint", 1)[0]
                ];
            case "rg8unorm":
                {
                    const p = Be(n, d, "8unorm", 2);
                    return [
                        p[0],
                        p[1]
                    ];
                }
            case "rg8snorm":
                {
                    const p = Be(n, d, "8snorm", 2);
                    return [
                        p[0],
                        p[1]
                    ];
                }
            case "rg8uint":
                {
                    const p = Be(n, d, "8uint", 2);
                    return [
                        p[0],
                        p[1]
                    ];
                }
            case "rg8sint":
                {
                    const p = Be(n, d, "8sint", 2);
                    return [
                        p[0],
                        p[1]
                    ];
                }
            case "rgba8unorm-srgb":
            case "rgba8unorm":
                {
                    const p = Be(n, d, "8unorm", 4);
                    return [
                        p[0],
                        p[1],
                        p[2],
                        p[3]
                    ];
                }
            case "rgba8snorm":
                {
                    const p = Be(n, d, "8snorm", 4);
                    return [
                        p[0],
                        p[1],
                        p[2],
                        p[3]
                    ];
                }
            case "rgba8uint":
                {
                    const p = Be(n, d, "8uint", 4);
                    return [
                        p[0],
                        p[1],
                        p[2],
                        p[3]
                    ];
                }
            case "rgba8sint":
                {
                    const p = Be(n, d, "8sint", 4);
                    return [
                        p[0],
                        p[1],
                        p[2],
                        p[3]
                    ];
                }
            case "bgra8unorm-srgb":
            case "bgra8unorm":
                {
                    const p = Be(n, d, "8unorm", 4);
                    return [
                        p[2],
                        p[1],
                        p[0],
                        p[3]
                    ];
                }
            case "r16uint":
                return [
                    Be(n, d, "16uint", 1)[0]
                ];
            case "r16sint":
                return [
                    Be(n, d, "16sint", 1)[0]
                ];
            case "r16float":
                return [
                    Be(n, d, "16float", 1)[0]
                ];
            case "rg16uint":
                {
                    const p = Be(n, d, "16uint", 2);
                    return [
                        p[0],
                        p[1]
                    ];
                }
            case "rg16sint":
                {
                    const p = Be(n, d, "16sint", 2);
                    return [
                        p[0],
                        p[1]
                    ];
                }
            case "rg16float":
                {
                    const p = Be(n, d, "16float", 2);
                    return [
                        p[0],
                        p[1]
                    ];
                }
            case "rgba16uint":
                {
                    const p = Be(n, d, "16uint", 4);
                    return [
                        p[0],
                        p[1],
                        p[2],
                        p[3]
                    ];
                }
            case "rgba16sint":
                {
                    const p = Be(n, d, "16sint", 4);
                    return [
                        p[0],
                        p[1],
                        p[2],
                        p[3]
                    ];
                }
            case "rgba16float":
                {
                    const p = Be(n, d, "16float", 4);
                    return [
                        p[0],
                        p[1],
                        p[2],
                        p[3]
                    ];
                }
            case "r32uint":
                return [
                    Be(n, d, "32uint", 1)[0]
                ];
            case "r32sint":
                return [
                    Be(n, d, "32sint", 1)[0]
                ];
            case "depth16unorm":
            case "depth24plus":
            case "depth24plus-stencil8":
            case "depth32float":
            case "depth32float-stencil8":
            case "r32float":
                return [
                    Be(n, d, "32float", 1)[0]
                ];
            case "rg32uint":
                {
                    const p = Be(n, d, "32uint", 2);
                    return [
                        p[0],
                        p[1]
                    ];
                }
            case "rg32sint":
                {
                    const p = Be(n, d, "32sint", 2);
                    return [
                        p[0],
                        p[1]
                    ];
                }
            case "rg32float":
                {
                    const p = Be(n, d, "32float", 2);
                    return [
                        p[0],
                        p[1]
                    ];
                }
            case "rgba32uint":
                {
                    const p = Be(n, d, "32uint", 4);
                    return [
                        p[0],
                        p[1],
                        p[2],
                        p[3]
                    ];
                }
            case "rgba32sint":
                {
                    const p = Be(n, d, "32sint", 4);
                    return [
                        p[0],
                        p[1],
                        p[2],
                        p[3]
                    ];
                }
            case "rgba32float":
                {
                    const p = Be(n, d, "32float", 4);
                    return [
                        p[0],
                        p[1],
                        p[2],
                        p[3]
                    ];
                }
            case "rg11b10ufloat":
                {
                    const p = new Uint32Array(n.buffer, d, 1)[0], _ = (4192256 & p) >> 11, y = (4290772992 & p) >> 22;
                    return [
                        Yb(2047 & p),
                        Yb(_),
                        function(v) {
                            const S = 112 + (v >> 5 & 31) << 23 | (31 & v) << 18;
                            return bg[0] = S, z3[0];
                        }(y),
                        1
                    ];
                }
        }
        return null;
    }
    function Be(n, e, t, i) {
        const r = [
            0,
            0,
            0,
            0
        ];
        for(let d = 0; d < i; ++d)switch(t){
            case "8unorm":
                r[d] = n[e] / 255, e++;
                break;
            case "8snorm":
                r[d] = n[e] / 255 * 2 - 1, e++;
                break;
            case "8uint":
                r[d] = n[e], e++;
                break;
            case "8sint":
                r[d] = n[e] - 127, e++;
                break;
            case "16uint":
                r[d] = n[e] | n[e + 1] << 8, e += 2;
                break;
            case "16sint":
                r[d] = (n[e] | n[e + 1] << 8) - 32768, e += 2;
                break;
            case "16float":
                r[d] = (a = n[e] | n[e + 1] << 8, l = void 0, u = void 0, h = void 0, l = (32768 & a) >> 15, h = 1023 & a, (u = (31744 & a) >> 10) == 0 ? (l ? -1 : 1) * Math.pow(2, -14) * (h / Math.pow(2, 10)) : u == 31 ? h ? NaN : 1 / 0 * (l ? -1 : 1) : (l ? -1 : 1) * Math.pow(2, u - 15) * (1 + h / Math.pow(2, 10))), e += 2;
                break;
            case "32uint":
            case "32sint":
                r[d] = n[e] | n[e + 1] << 8 | n[e + 2] << 16 | n[e + 3] << 24, e += 4;
                break;
            case "32float":
                r[d] = new Float32Array(n.buffer, e, 1)[0], e += 4;
        }
        var a, l, u, h;
        return r;
    }
    function Le(n, e, t, i, r) {
        for(let a = 0; a < i; ++a)switch(t){
            case "8unorm":
                n[e] = 255 * r[a], e++;
                break;
            case "8snorm":
                n[e] = .5 * (r[a] + 1) * 255, e++;
                break;
            case "8uint":
                n[e] = r[a], e++;
                break;
            case "8sint":
                n[e] = r[a] + 127, e++;
                break;
            case "16uint":
                new Uint16Array(n.buffer, e, 1)[0] = r[a], e += 2;
                break;
            case "16sint":
                new Int16Array(n.buffer, e, 1)[0] = r[a], e += 2;
                break;
            case "16float":
                {
                    const l = GR(r[a]);
                    new Uint16Array(n.buffer, e, 1)[0] = l, e += 2;
                    break;
                }
            case "32uint":
                new Uint32Array(n.buffer, e, 1)[0] = r[a], e += 4;
                break;
            case "32sint":
                new Int32Array(n.buffer, e, 1)[0] = r[a], e += 4;
                break;
            case "32float":
                new Float32Array(n.buffer, e, 1)[0] = r[a], e += 4;
        }
        return r;
    }
    const Hh = {
        r8unorm: {
            bytesPerBlock: 1,
            blockWidth: 1,
            blockHeight: 1,
            isCompressed: !1,
            channels: 1
        },
        r8snorm: {
            bytesPerBlock: 1,
            blockWidth: 1,
            blockHeight: 1,
            isCompressed: !1,
            channels: 1
        },
        r8uint: {
            bytesPerBlock: 1,
            blockWidth: 1,
            blockHeight: 1,
            isCompressed: !1,
            channels: 1
        },
        r8sint: {
            bytesPerBlock: 1,
            blockWidth: 1,
            blockHeight: 1,
            isCompressed: !1,
            channels: 1
        },
        rg8unorm: {
            bytesPerBlock: 2,
            blockWidth: 1,
            blockHeight: 1,
            isCompressed: !1,
            channels: 2
        },
        rg8snorm: {
            bytesPerBlock: 2,
            blockWidth: 1,
            blockHeight: 1,
            isCompressed: !1,
            channels: 2
        },
        rg8uint: {
            bytesPerBlock: 2,
            blockWidth: 1,
            blockHeight: 1,
            isCompressed: !1,
            channels: 2
        },
        rg8sint: {
            bytesPerBlock: 2,
            blockWidth: 1,
            blockHeight: 1,
            isCompressed: !1,
            channels: 2
        },
        rgba8unorm: {
            bytesPerBlock: 4,
            blockWidth: 1,
            blockHeight: 1,
            isCompressed: !1,
            channels: 4
        },
        "rgba8unorm-srgb": {
            bytesPerBlock: 4,
            blockWidth: 1,
            blockHeight: 1,
            isCompressed: !1,
            channels: 4
        },
        rgba8snorm: {
            bytesPerBlock: 4,
            blockWidth: 1,
            blockHeight: 1,
            isCompressed: !1,
            channels: 4
        },
        rgba8uint: {
            bytesPerBlock: 4,
            blockWidth: 1,
            blockHeight: 1,
            isCompressed: !1,
            channels: 4
        },
        rgba8sint: {
            bytesPerBlock: 4,
            blockWidth: 1,
            blockHeight: 1,
            isCompressed: !1,
            channels: 4
        },
        bgra8unorm: {
            bytesPerBlock: 4,
            blockWidth: 1,
            blockHeight: 1,
            isCompressed: !1,
            channels: 4
        },
        "bgra8unorm-srgb": {
            bytesPerBlock: 4,
            blockWidth: 1,
            blockHeight: 1,
            isCompressed: !1,
            channels: 4
        },
        r16uint: {
            bytesPerBlock: 2,
            blockWidth: 1,
            blockHeight: 1,
            isCompressed: !1,
            channels: 1
        },
        r16sint: {
            bytesPerBlock: 2,
            blockWidth: 1,
            blockHeight: 1,
            isCompressed: !1,
            channels: 1
        },
        r16float: {
            bytesPerBlock: 2,
            blockWidth: 1,
            blockHeight: 1,
            isCompressed: !1,
            channels: 1
        },
        rg16uint: {
            bytesPerBlock: 4,
            blockWidth: 1,
            blockHeight: 1,
            isCompressed: !1,
            channels: 2
        },
        rg16sint: {
            bytesPerBlock: 4,
            blockWidth: 1,
            blockHeight: 1,
            isCompressed: !1,
            channels: 2
        },
        rg16float: {
            bytesPerBlock: 4,
            blockWidth: 1,
            blockHeight: 1,
            isCompressed: !1,
            channels: 2
        },
        rgba16uint: {
            bytesPerBlock: 8,
            blockWidth: 1,
            blockHeight: 1,
            isCompressed: !1,
            channels: 4
        },
        rgba16sint: {
            bytesPerBlock: 8,
            blockWidth: 1,
            blockHeight: 1,
            isCompressed: !1,
            channels: 4
        },
        rgba16float: {
            bytesPerBlock: 8,
            blockWidth: 1,
            blockHeight: 1,
            isCompressed: !1,
            channels: 4
        },
        r32uint: {
            bytesPerBlock: 4,
            blockWidth: 1,
            blockHeight: 1,
            isCompressed: !1,
            channels: 1
        },
        r32sint: {
            bytesPerBlock: 4,
            blockWidth: 1,
            blockHeight: 1,
            isCompressed: !1,
            channels: 1
        },
        r32float: {
            bytesPerBlock: 4,
            blockWidth: 1,
            blockHeight: 1,
            isCompressed: !1,
            channels: 1
        },
        rg32uint: {
            bytesPerBlock: 8,
            blockWidth: 1,
            blockHeight: 1,
            isCompressed: !1,
            channels: 2
        },
        rg32sint: {
            bytesPerBlock: 8,
            blockWidth: 1,
            blockHeight: 1,
            isCompressed: !1,
            channels: 2
        },
        rg32float: {
            bytesPerBlock: 8,
            blockWidth: 1,
            blockHeight: 1,
            isCompressed: !1,
            channels: 2
        },
        rgba32uint: {
            bytesPerBlock: 16,
            blockWidth: 1,
            blockHeight: 1,
            isCompressed: !1,
            channels: 4
        },
        rgba32sint: {
            bytesPerBlock: 16,
            blockWidth: 1,
            blockHeight: 1,
            isCompressed: !1,
            channels: 4
        },
        rgba32float: {
            bytesPerBlock: 16,
            blockWidth: 1,
            blockHeight: 1,
            isCompressed: !1,
            channels: 4
        },
        rgb10a2uint: {
            bytesPerBlock: 4,
            blockWidth: 1,
            blockHeight: 1,
            isCompressed: !1,
            channels: 4
        },
        rgb10a2unorm: {
            bytesPerBlock: 4,
            blockWidth: 1,
            blockHeight: 1,
            isCompressed: !1,
            channels: 4
        },
        rg11b10ufloat: {
            bytesPerBlock: 4,
            blockWidth: 1,
            blockHeight: 1,
            isCompressed: !1,
            channels: 4
        },
        stencil8: {
            bytesPerBlock: 1,
            blockWidth: 1,
            blockHeight: 1,
            isCompressed: !1,
            isDepthStencil: !0,
            hasDepth: !1,
            hasStencil: !0,
            channels: 1
        },
        depth16unorm: {
            bytesPerBlock: 2,
            blockWidth: 1,
            blockHeight: 1,
            isCompressed: !1,
            isDepthStencil: !0,
            hasDepth: !0,
            hasStencil: !1,
            channels: 1
        },
        depth24plus: {
            bytesPerBlock: 4,
            blockWidth: 1,
            blockHeight: 1,
            isCompressed: !1,
            isDepthStencil: !0,
            hasDepth: !0,
            hasStencil: !1,
            depthOnlyFormat: "depth32float",
            channels: 1
        },
        "depth24plus-stencil8": {
            bytesPerBlock: 8,
            blockWidth: 1,
            blockHeight: 1,
            isCompressed: !1,
            isDepthStencil: !0,
            hasDepth: !0,
            hasStencil: !0,
            depthOnlyFormat: "depth32float",
            channels: 1
        },
        depth32float: {
            bytesPerBlock: 4,
            blockWidth: 1,
            blockHeight: 1,
            isCompressed: !1,
            isDepthStencil: !0,
            hasDepth: !0,
            hasStencil: !1,
            channels: 1
        },
        "depth32float-stencil8": {
            bytesPerBlock: 8,
            blockWidth: 1,
            blockHeight: 1,
            isCompressed: !1,
            isDepthStencil: !0,
            hasDepth: !0,
            hasStencil: !0,
            stencilOnlyFormat: "depth32float",
            channels: 1
        },
        rgb9e5ufloat: {
            bytesPerBlock: 4,
            blockWidth: 1,
            blockHeight: 1,
            isCompressed: !1,
            channels: 4
        },
        "bc1-rgba-unorm": {
            bytesPerBlock: 8,
            blockWidth: 4,
            blockHeight: 4,
            isCompressed: !0,
            channels: 4
        },
        "bc1-rgba-unorm-srgb": {
            bytesPerBlock: 8,
            blockWidth: 4,
            blockHeight: 4,
            isCompressed: !0,
            channels: 4
        },
        "bc2-rgba-unorm": {
            bytesPerBlock: 16,
            blockWidth: 4,
            blockHeight: 4,
            isCompressed: !0,
            channels: 4
        },
        "bc2-rgba-unorm-srgb": {
            bytesPerBlock: 16,
            blockWidth: 4,
            blockHeight: 4,
            isCompressed: !0,
            channels: 4
        },
        "bc3-rgba-unorm": {
            bytesPerBlock: 16,
            blockWidth: 4,
            blockHeight: 4,
            isCompressed: !0,
            channels: 4
        },
        "bc3-rgba-unorm-srgb": {
            bytesPerBlock: 16,
            blockWidth: 4,
            blockHeight: 4,
            isCompressed: !0,
            channels: 4
        },
        "bc4-r-unorm": {
            bytesPerBlock: 8,
            blockWidth: 4,
            blockHeight: 4,
            isCompressed: !0,
            channels: 1
        },
        "bc4-r-snorm": {
            bytesPerBlock: 8,
            blockWidth: 4,
            blockHeight: 4,
            isCompressed: !0,
            channels: 1
        },
        "bc5-rg-unorm": {
            bytesPerBlock: 16,
            blockWidth: 4,
            blockHeight: 4,
            isCompressed: !0,
            channels: 2
        },
        "bc5-rg-snorm": {
            bytesPerBlock: 16,
            blockWidth: 4,
            blockHeight: 4,
            isCompressed: !0,
            channels: 2
        },
        "bc6h-rgb-ufloat": {
            bytesPerBlock: 16,
            blockWidth: 4,
            blockHeight: 4,
            isCompressed: !0,
            channels: 4
        },
        "bc6h-rgb-float": {
            bytesPerBlock: 16,
            blockWidth: 4,
            blockHeight: 4,
            isCompressed: !0,
            channels: 4
        },
        "bc7-rgba-unorm": {
            bytesPerBlock: 16,
            blockWidth: 4,
            blockHeight: 4,
            isCompressed: !0,
            channels: 4
        },
        "bc7-rgba-unorm-srgb": {
            bytesPerBlock: 16,
            blockWidth: 4,
            blockHeight: 4,
            isCompressed: !0,
            channels: 4
        },
        "etc2-rgb8unorm": {
            bytesPerBlock: 8,
            blockWidth: 4,
            blockHeight: 4,
            isCompressed: !0,
            channels: 4
        },
        "etc2-rgb8unorm-srgb": {
            bytesPerBlock: 8,
            blockWidth: 4,
            blockHeight: 4,
            isCompressed: !0,
            channels: 4
        },
        "etc2-rgb8a1unorm": {
            bytesPerBlock: 8,
            blockWidth: 4,
            blockHeight: 4,
            isCompressed: !0,
            channels: 4
        },
        "etc2-rgb8a1unorm-srgb": {
            bytesPerBlock: 8,
            blockWidth: 4,
            blockHeight: 4,
            isCompressed: !0,
            channels: 4
        },
        "etc2-rgba8unorm": {
            bytesPerBlock: 16,
            blockWidth: 4,
            blockHeight: 4,
            isCompressed: !0,
            channels: 4
        },
        "etc2-rgba8unorm-srgb": {
            bytesPerBlock: 16,
            blockWidth: 4,
            blockHeight: 4,
            isCompressed: !0,
            channels: 4
        },
        "eac-r11unorm": {
            bytesPerBlock: 8,
            blockWidth: 1,
            blockHeight: 1,
            isCompressed: !0,
            channels: 1
        },
        "eac-r11snorm": {
            bytesPerBlock: 8,
            blockWidth: 1,
            blockHeight: 1,
            isCompressed: !0,
            channels: 1
        },
        "eac-rg11unorm": {
            bytesPerBlock: 16,
            blockWidth: 1,
            blockHeight: 1,
            isCompressed: !0,
            channels: 2
        },
        "eac-rg11snorm": {
            bytesPerBlock: 16,
            blockWidth: 1,
            blockHeight: 1,
            isCompressed: !0,
            channels: 2
        },
        "astc-4x4-unorm": {
            bytesPerBlock: 16,
            blockWidth: 4,
            blockHeight: 4,
            isCompressed: !0,
            channels: 4
        },
        "astc-4x4-unorm-srgb": {
            bytesPerBlock: 16,
            blockWidth: 4,
            blockHeight: 4,
            isCompressed: !0,
            channels: 4
        },
        "astc-5x4-unorm": {
            bytesPerBlock: 16,
            blockWidth: 5,
            blockHeight: 4,
            isCompressed: !0,
            channels: 4
        },
        "astc-5x4-unorm-srgb": {
            bytesPerBlock: 16,
            blockWidth: 5,
            blockHeight: 4,
            isCompressed: !0,
            channels: 4
        },
        "astc-5x5-unorm": {
            bytesPerBlock: 16,
            blockWidth: 5,
            blockHeight: 5,
            isCompressed: !0,
            channels: 4
        },
        "astc-5x5-unorm-srgb": {
            bytesPerBlock: 16,
            blockWidth: 5,
            blockHeight: 5,
            isCompressed: !0,
            channels: 4
        },
        "astc-6x5-unorm": {
            bytesPerBlock: 16,
            blockWidth: 6,
            blockHeight: 5,
            isCompressed: !0,
            channels: 4
        },
        "astc-6x5-unorm-srgb": {
            bytesPerBlock: 16,
            blockWidth: 6,
            blockHeight: 5,
            isCompressed: !0,
            channels: 4
        },
        "astc-6x6-unorm": {
            bytesPerBlock: 16,
            blockWidth: 6,
            blockHeight: 6,
            isCompressed: !0,
            channels: 4
        },
        "astc-6x6-unorm-srgb": {
            bytesPerBlock: 16,
            blockWidth: 6,
            blockHeight: 6,
            isCompressed: !0,
            channels: 4
        },
        "astc-8x5-unorm": {
            bytesPerBlock: 16,
            blockWidth: 8,
            blockHeight: 5,
            isCompressed: !0,
            channels: 4
        },
        "astc-8x5-unorm-srgb": {
            bytesPerBlock: 16,
            blockWidth: 8,
            blockHeight: 5,
            isCompressed: !0,
            channels: 4
        },
        "astc-8x6-unorm": {
            bytesPerBlock: 16,
            blockWidth: 8,
            blockHeight: 6,
            isCompressed: !0,
            channels: 4
        },
        "astc-8x6-unorm-srgb": {
            bytesPerBlock: 16,
            blockWidth: 8,
            blockHeight: 6,
            isCompressed: !0,
            channels: 4
        },
        "astc-8x8-unorm": {
            bytesPerBlock: 16,
            blockWidth: 8,
            blockHeight: 8,
            isCompressed: !0,
            channels: 4
        },
        "astc-8x8-unorm-srgb": {
            bytesPerBlock: 16,
            blockWidth: 8,
            blockHeight: 8,
            isCompressed: !0,
            channels: 4
        },
        "astc-10x5-unorm": {
            bytesPerBlock: 16,
            blockWidth: 10,
            blockHeight: 5,
            isCompressed: !0,
            channels: 4
        },
        "astc-10x5-unorm-srgb": {
            bytesPerBlock: 16,
            blockWidth: 10,
            blockHeight: 5,
            isCompressed: !0,
            channels: 4
        },
        "astc-10x6-unorm": {
            bytesPerBlock: 16,
            blockWidth: 10,
            blockHeight: 6,
            isCompressed: !0,
            channels: 4
        },
        "astc-10x6-unorm-srgb": {
            bytesPerBlock: 16,
            blockWidth: 10,
            blockHeight: 6,
            isCompressed: !0,
            channels: 4
        },
        "astc-10x8-unorm": {
            bytesPerBlock: 16,
            blockWidth: 10,
            blockHeight: 8,
            isCompressed: !0,
            channels: 4
        },
        "astc-10x8-unorm-srgb": {
            bytesPerBlock: 16,
            blockWidth: 10,
            blockHeight: 8,
            isCompressed: !0,
            channels: 4
        },
        "astc-10x10-unorm": {
            bytesPerBlock: 16,
            blockWidth: 10,
            blockHeight: 10,
            isCompressed: !0,
            channels: 4
        },
        "astc-10x10-unorm-srgb": {
            bytesPerBlock: 16,
            blockWidth: 10,
            blockHeight: 10,
            isCompressed: !0,
            channels: 4
        },
        "astc-12x10-unorm": {
            bytesPerBlock: 16,
            blockWidth: 12,
            blockHeight: 10,
            isCompressed: !0,
            channels: 4
        },
        "astc-12x10-unorm-srgb": {
            bytesPerBlock: 16,
            blockWidth: 12,
            blockHeight: 10,
            isCompressed: !0,
            channels: 4
        },
        "astc-12x12-unorm": {
            bytesPerBlock: 16,
            blockWidth: 12,
            blockHeight: 12,
            isCompressed: !0,
            channels: 4
        },
        "astc-12x12-unorm-srgb": {
            bytesPerBlock: 16,
            blockWidth: 12,
            blockHeight: 12,
            isCompressed: !0,
            channels: 4
        }
    };
    class Tn {
        constructor(){
            this.id = Tn._id++, this.line = 0;
        }
        get isAstNode() {
            return !0;
        }
        get astNodeType() {
            return "";
        }
        search(e) {
            e(this);
        }
        searchBlock(e, t) {
            if (e) {
                t(Rc.instance);
                for (const i of e)i instanceof Array ? this.searchBlock(i, t) : i.search(t);
                t(Cc.instance);
            }
        }
        constEvaluate(e, t) {
            throw new Error("Cannot evaluate node");
        }
        constEvaluateString(e) {
            return this.constEvaluate(e).toString();
        }
    }
    Tn._id = 0;
    class Rc extends Tn {
    }
    Rc.instance = new Rc;
    class Cc extends Tn {
    }
    Cc.instance = new Cc;
    const V3 = new Set([
        "all",
        "all",
        "any",
        "select",
        "arrayLength",
        "abs",
        "acos",
        "acosh",
        "asin",
        "asinh",
        "atan",
        "atanh",
        "atan2",
        "ceil",
        "clamp",
        "cos",
        "cosh",
        "countLeadingZeros",
        "countOneBits",
        "countTrailingZeros",
        "cross",
        "degrees",
        "determinant",
        "distance",
        "dot",
        "dot4U8Packed",
        "dot4I8Packed",
        "exp",
        "exp2",
        "extractBits",
        "faceForward",
        "firstLeadingBit",
        "firstTrailingBit",
        "floor",
        "fma",
        "fract",
        "frexp",
        "insertBits",
        "inverseSqrt",
        "ldexp",
        "length",
        "log",
        "log2",
        "max",
        "min",
        "mix",
        "modf",
        "normalize",
        "pow",
        "quantizeToF16",
        "radians",
        "reflect",
        "refract",
        "reverseBits",
        "round",
        "saturate",
        "sign",
        "sin",
        "sinh",
        "smoothStep",
        "sqrt",
        "step",
        "tan",
        "tanh",
        "transpose",
        "trunc",
        "dpdx",
        "dpdxCoarse",
        "dpdxFine",
        "dpdy",
        "dpdyCoarse",
        "dpdyFine",
        "fwidth",
        "fwidthCoarse",
        "fwidthFine",
        "textureDimensions",
        "textureGather",
        "textureGatherCompare",
        "textureLoad",
        "textureNumLayers",
        "textureNumLevels",
        "textureNumSamples",
        "textureSample",
        "textureSampleBias",
        "textureSampleCompare",
        "textureSampleCompareLevel",
        "textureSampleGrad",
        "textureSampleLevel",
        "textureSampleBaseClampToEdge",
        "textureStore",
        "atomicLoad",
        "atomicStore",
        "atomicAdd",
        "atomicSub",
        "atomicMax",
        "atomicMin",
        "atomicAnd",
        "atomicOr",
        "atomicXor",
        "atomicExchange",
        "atomicCompareExchangeWeak",
        "pack4x8snorm",
        "pack4x8unorm",
        "pack4xI8",
        "pack4xU8",
        "pack4x8Clamp",
        "pack4xU8Clamp",
        "pack2x16snorm",
        "pack2x16unorm",
        "pack2x16float",
        "unpack4x8snorm",
        "unpack4x8unorm",
        "unpack4xI8",
        "unpack4xU8",
        "unpack2x16snorm",
        "unpack2x16unorm",
        "unpack2x16float",
        "storageBarrier",
        "textureBarrier",
        "workgroupBarrier",
        "workgroupUniformLoad",
        "subgroupAdd",
        "subgroupExclusiveAdd",
        "subgroupInclusiveAdd",
        "subgroupAll",
        "subgroupAnd",
        "subgroupAny",
        "subgroupBallot",
        "subgroupBroadcast",
        "subgroupBroadcastFirst",
        "subgroupElect",
        "subgroupMax",
        "subgroupMin",
        "subgroupMul",
        "subgroupExclusiveMul",
        "subgroupInclusiveMul",
        "subgroupOr",
        "subgroupShuffle",
        "subgroupShuffleDown",
        "subgroupShuffleUp",
        "subgroupShuffleXor",
        "subgroupXor",
        "quadBroadcast",
        "quadSwapDiagonal",
        "quadSwapX",
        "quadSwapY"
    ]);
    class et extends Tn {
        constructor(){
            super();
        }
    }
    class To extends et {
        constructor(e, t, i, r, a, l){
            super(), this.calls = new Set, this.name = e, this.args = t, this.returnType = i, this.body = r, this.startLine = a, this.endLine = l;
        }
        get astNodeType() {
            return "function";
        }
        search(e) {
            if (this.attributes) for (const t of this.attributes)e(t);
            e(this);
            for (const t of this.args)e(t);
            this.searchBlock(this.body, e);
        }
    }
    class eC extends et {
        constructor(e){
            super(), this.expression = e;
        }
        get astNodeType() {
            return "staticAssert";
        }
        search(e) {
            this.expression.search(e);
        }
    }
    class H3 extends et {
        constructor(e, t){
            super(), this.condition = e, this.body = t;
        }
        get astNodeType() {
            return "while";
        }
        search(e) {
            this.condition.search(e), this.searchBlock(this.body, e);
        }
    }
    class Ed extends et {
        constructor(e, t){
            super(), this.body = e, this.loopId = t;
        }
        get astNodeType() {
            return "continuing";
        }
        search(e) {
            this.searchBlock(this.body, e);
        }
    }
    class j3 extends et {
        constructor(e, t, i, r){
            super(), this.init = e, this.condition = t, this.increment = i, this.body = r;
        }
        get astNodeType() {
            return "for";
        }
        search(e) {
            var t, i, r;
            (t = this.init) === null || t === void 0 || t.search(e), (i = this.condition) === null || i === void 0 || i.search(e), (r = this.increment) === null || r === void 0 || r.search(e), this.searchBlock(this.body, e);
        }
    }
    class fi extends et {
        constructor(e, t, i, r, a){
            super(), this.attributes = null, this.name = e, this.type = t, this.storage = i, this.access = r, this.value = a;
        }
        get astNodeType() {
            return "var";
        }
        search(e) {
            var t;
            e(this), (t = this.value) === null || t === void 0 || t.search(e);
        }
    }
    class vg extends et {
        constructor(e, t, i){
            super(), this.attributes = null, this.name = e, this.type = t, this.value = i;
        }
        get astNodeType() {
            return "override";
        }
        search(e) {
            var t;
            (t = this.value) === null || t === void 0 || t.search(e);
        }
    }
    class go extends et {
        constructor(e, t, i, r, a){
            super(), this.attributes = null, this.name = e, this.type = t, this.storage = i, this.access = r, this.value = a;
        }
        get astNodeType() {
            return "let";
        }
        search(e) {
            var t;
            e(this), (t = this.value) === null || t === void 0 || t.search(e);
        }
    }
    class dc extends et {
        constructor(e, t, i, r, a){
            super(), this.attributes = null, this.name = e, this.type = t, this.storage = i, this.access = r, this.value = a;
        }
        get astNodeType() {
            return "const";
        }
        constEvaluate(e, t) {
            return this.value.constEvaluate(e, t);
        }
        search(e) {
            var t;
            e(this), (t = this.value) === null || t === void 0 || t.search(e);
        }
    }
    var Ds, ao, F, N;
    ((n)=>{
        n.increment = "++", n.decrement = "--";
    })(Ds || (Ds = {})), ((n)=>{
        n.parse = function(e) {
            const t = e;
            if (t == "parse") throw new Error("Invalid value for IncrementOperator");
            return n[t];
        };
    })(Ds || (Ds = {}));
    class W3 extends et {
        constructor(e, t){
            super(), this.operator = e, this.variable = t;
        }
        get astNodeType() {
            return "increment";
        }
        search(e) {
            this.variable.search(e);
        }
    }
    ((n)=>{
        n.assign = "=", n.addAssign = "+=", n.subtractAssin = "-=", n.multiplyAssign = "*=", n.divideAssign = "/=", n.moduloAssign = "%=", n.andAssign = "&=", n.orAssign = "|=", n.xorAssign = "^=", n.shiftLeftAssign = "<<=", n.shiftRightAssign = ">>=";
    })(ao || (ao = {})), ((n)=>{
        n.parse = function(e) {
            const t = e;
            if (t == "parse") throw new Error("Invalid value for AssignOperator");
            return t;
        };
    })(ao || (ao = {}));
    class $3 extends et {
        constructor(e, t, i){
            super(), this.operator = e, this.variable = t, this.value = i;
        }
        get astNodeType() {
            return "assign";
        }
        search(e) {
            this.variable.search(e), this.value.search(e);
        }
    }
    class Tg extends et {
        constructor(e, t){
            super(), this.name = e, this.args = t;
        }
        get astNodeType() {
            return "call";
        }
        isBuiltin() {
            return V3.has(this.name);
        }
        search(e) {
            for (const t of this.args)t.search(e);
            e(this);
        }
    }
    class X3 extends et {
        constructor(e, t){
            super(), this.body = e, this.continuing = t;
        }
        get astNodeType() {
            return "loop";
        }
    }
    class Y3 extends et {
        constructor(e, t){
            super(), this.condition = e, this.cases = t;
        }
        get astNodeType() {
            return "switch";
        }
    }
    class q3 extends et {
        constructor(e, t, i, r){
            super(), this.condition = e, this.body = t, this.elseif = i, this.else = r;
        }
        get astNodeType() {
            return "if";
        }
        search(e) {
            this.condition.search(e), this.searchBlock(this.body, e), this.searchBlock(this.elseif, e), this.searchBlock(this.else, e);
        }
    }
    class K3 extends et {
        constructor(e){
            super(), this.value = e;
        }
        get astNodeType() {
            return "return";
        }
        search(e) {
            var t;
            (t = this.value) === null || t === void 0 || t.search(e);
        }
    }
    class tC extends et {
        constructor(e){
            super(), this.name = e;
        }
        get astNodeType() {
            return "enable";
        }
    }
    class nC extends et {
        constructor(e){
            super(), this.extensions = e;
        }
        get astNodeType() {
            return "requires";
        }
    }
    class Z3 extends et {
        constructor(e, t){
            super(), this.severity = e, this.rule = t;
        }
        get astNodeType() {
            return "diagnostic";
        }
    }
    class xg extends et {
        constructor(e, t){
            super(), this.name = e, this.type = t;
        }
        get astNodeType() {
            return "alias";
        }
    }
    class iC extends et {
        constructor(){
            super();
        }
        get astNodeType() {
            return "discard";
        }
    }
    class Q3 extends et {
        constructor(){
            super(), this.condition = null, this.loopId = -1;
        }
        get astNodeType() {
            return "break";
        }
    }
    class G3 extends et {
        constructor(){
            super(), this.loopId = -1;
        }
        get astNodeType() {
            return "continue";
        }
    }
    class q extends et {
        constructor(e){
            super(), this.attributes = null, this.name = e;
        }
        get astNodeType() {
            return "type";
        }
        get isStruct() {
            return !1;
        }
        get isArray() {
            return !1;
        }
        static maxFormatType(e) {
            let t = e[0];
            if (t.name === "f32") return t;
            for(let i = 1; i < e.length; ++i){
                const r = q._priority.get(t.name);
                q._priority.get(e[i].name) < r && (t = e[i]);
            }
            return t.name === "x32" ? q.i32 : t;
        }
        getTypeName() {
            return this.name;
        }
    }
    q.x32 = new q("x32"), q.f32 = new q("f32"), q.i32 = new q("i32"), q.u32 = new q("u32"), q.f16 = new q("f16"), q.bool = new q("bool"), q.void = new q("void"), q._priority = new Map([
        [
            "f32",
            0
        ],
        [
            "f16",
            1
        ],
        [
            "u32",
            2
        ],
        [
            "i32",
            3
        ],
        [
            "x32",
            3
        ]
    ]);
    let qb = class extends q {
        constructor(e){
            super(e);
        }
    };
    class ci extends q {
        constructor(e, t, i, r){
            super(e), this.members = t, this.startLine = i, this.endLine = r;
        }
        get astNodeType() {
            return "struct";
        }
        get isStruct() {
            return !0;
        }
        getMemberIndex(e) {
            for(let t = 0; t < this.members.length; t++)if (this.members[t].name == e) return t;
            return -1;
        }
        search(e) {
            for (const t of this.members)e(t);
        }
    }
    class k extends q {
        constructor(e, t, i){
            super(e), this.format = t, this.access = i;
        }
        get astNodeType() {
            return "template";
        }
        getTypeName() {
            let e = this.name;
            if (this.format !== null) {
                if (e === "vec2" || e === "vec3" || e === "vec4" || e === "mat2x2" || e === "mat2x3" || e === "mat2x4" || e === "mat3x2" || e === "mat3x3" || e === "mat3x4" || e === "mat4x2" || e === "mat4x3" || e === "mat4x4") {
                    if (this.format.name === "f32") return e += "f", e;
                    if (this.format.name === "i32") return e += "i", e;
                    if (this.format.name === "u32") return e += "u", e;
                    if (this.format.name === "bool") return e += "b", e;
                    if (this.format.name === "f16") return e += "h", e;
                }
                e += `<${this.format.name}>`;
            } else if (e === "vec2" || e === "vec3" || e === "vec4") return e;
            return e;
        }
    }
    k.vec2f = new k("vec2", q.f32, null), k.vec3f = new k("vec3", q.f32, null), k.vec4f = new k("vec4", q.f32, null), k.vec2i = new k("vec2", q.i32, null), k.vec3i = new k("vec3", q.i32, null), k.vec4i = new k("vec4", q.i32, null), k.vec2u = new k("vec2", q.u32, null), k.vec3u = new k("vec3", q.u32, null), k.vec4u = new k("vec4", q.u32, null), k.vec2h = new k("vec2", q.f16, null), k.vec3h = new k("vec3", q.f16, null), k.vec4h = new k("vec4", q.f16, null), k.vec2b = new k("vec2", q.bool, null), k.vec3b = new k("vec3", q.bool, null), k.vec4b = new k("vec4", q.bool, null), k.mat2x2f = new k("mat2x2", q.f32, null), k.mat2x3f = new k("mat2x3", q.f32, null), k.mat2x4f = new k("mat2x4", q.f32, null), k.mat3x2f = new k("mat3x2", q.f32, null), k.mat3x3f = new k("mat3x3", q.f32, null), k.mat3x4f = new k("mat3x4", q.f32, null), k.mat4x2f = new k("mat4x2", q.f32, null), k.mat4x3f = new k("mat4x3", q.f32, null), k.mat4x4f = new k("mat4x4", q.f32, null), k.mat2x2h = new k("mat2x2", q.f16, null), k.mat2x3h = new k("mat2x3", q.f16, null), k.mat2x4h = new k("mat2x4", q.f16, null), k.mat3x2h = new k("mat3x2", q.f16, null), k.mat3x3h = new k("mat3x3", q.f16, null), k.mat3x4h = new k("mat3x4", q.f16, null), k.mat4x2h = new k("mat4x2", q.f16, null), k.mat4x3h = new k("mat4x3", q.f16, null), k.mat4x4h = new k("mat4x4", q.f16, null), k.mat2x2i = new k("mat2x2", q.i32, null), k.mat2x3i = new k("mat2x3", q.i32, null), k.mat2x4i = new k("mat2x4", q.i32, null), k.mat3x2i = new k("mat3x2", q.i32, null), k.mat3x3i = new k("mat3x3", q.i32, null), k.mat3x4i = new k("mat3x4", q.i32, null), k.mat4x2i = new k("mat4x2", q.i32, null), k.mat4x3i = new k("mat4x3", q.i32, null), k.mat4x4i = new k("mat4x4", q.i32, null), k.mat2x2u = new k("mat2x2", q.u32, null), k.mat2x3u = new k("mat2x3", q.u32, null), k.mat2x4u = new k("mat2x4", q.u32, null), k.mat3x2u = new k("mat3x2", q.u32, null), k.mat3x3u = new k("mat3x3", q.u32, null), k.mat3x4u = new k("mat3x4", q.u32, null), k.mat4x2u = new k("mat4x2", q.u32, null), k.mat4x3u = new k("mat4x3", q.u32, null), k.mat4x4u = new k("mat4x4", q.u32, null);
    class jh extends q {
        constructor(e, t, i, r){
            super(e), this.storage = t, this.type = i, this.access = r;
        }
        get astNodeType() {
            return "pointer";
        }
    }
    class po extends q {
        constructor(e, t, i, r){
            super(e), this.attributes = t, this.format = i, this.count = r;
        }
        get astNodeType() {
            return "array";
        }
        get isArray() {
            return !0;
        }
    }
    class oo extends q {
        constructor(e, t, i){
            super(e), this.format = t, this.access = i;
        }
        get astNodeType() {
            return "sampler";
        }
    }
    class Xn extends Tn {
        constructor(){
            super(), this.postfix = null;
        }
    }
    class Or extends Xn {
        constructor(e){
            super(), this.value = e;
        }
        get astNodeType() {
            return "stringExpr";
        }
        toString() {
            return this.value;
        }
        constEvaluateString() {
            return this.value;
        }
    }
    class Ln extends Xn {
        constructor(e, t){
            super(), this.type = e, this.args = t;
        }
        get astNodeType() {
            return "createExpr";
        }
        search(e) {
            if (e(this), this.args) for (const t of this.args)t.search(e);
        }
        constEvaluate(e, t) {
            return t && (t[0] = this.type), e.evalExpression(this, e.context);
        }
    }
    class Sg extends Xn {
        constructor(e, t){
            super(), this.cachedReturnValue = null, this.name = e, this.args = t;
        }
        get astNodeType() {
            return "callExpr";
        }
        setCachedReturnValue(e) {
            this.cachedReturnValue = e;
        }
        get isBuiltin() {
            return V3.has(this.name);
        }
        constEvaluate(e, t) {
            return e.evalExpression(this, e.context);
        }
        search(e) {
            for (const t of this.args)t.search(e);
            e(this);
        }
    }
    class sn extends Xn {
        constructor(e){
            super(), this.name = e;
        }
        get astNodeType() {
            return "varExpr";
        }
        search(e) {
            e(this), this.postfix && this.postfix.search(e);
        }
        constEvaluate(e, t) {
            return e.evalExpression(this, e.context);
        }
    }
    class J3 extends Xn {
        constructor(e, t){
            super(), this.name = e, this.initializer = t;
        }
        get astNodeType() {
            return "constExpr";
        }
        constEvaluate(e, t) {
            if (this.initializer) {
                const i = e.evalExpression(this.initializer, e.context);
                return i !== null && this.postfix ? i.getSubData(e, this.postfix, e.context) : i;
            }
            return null;
        }
        search(e) {
            this.initializer.search(e);
        }
    }
    class pt extends Xn {
        constructor(e, t){
            super(), this.value = e, this.type = t;
        }
        get astNodeType() {
            return "literalExpr";
        }
        constEvaluate(e, t) {
            return t !== void 0 && (t[0] = this.type), this.value;
        }
        get isScalar() {
            return this.value instanceof I;
        }
        get isVector() {
            return this.value instanceof A || this.value instanceof me;
        }
        get scalarValue() {
            return this.value instanceof I ? this.value.value : (console.error("Value is not scalar."), 0);
        }
        get vectorValue() {
            return this.value instanceof A || this.value instanceof me ? this.value.data : (console.error("Value is not a vector or matrix."), new Float32Array(0));
        }
    }
    class eT extends Xn {
        constructor(e, t){
            super(), this.type = e, this.value = t;
        }
        get astNodeType() {
            return "bitcastExpr";
        }
        search(e) {
            this.value.search(e);
        }
    }
    class Xs extends Xn {
        constructor(e){
            super(), this.index = e;
        }
        search(e) {
            this.index.search(e);
        }
    }
    class tT extends Xn {
        constructor(){
            super();
        }
    }
    class ft extends tT {
        constructor(e, t){
            super(), this.operator = e, this.right = t;
        }
        get astNodeType() {
            return "unaryOp";
        }
        constEvaluate(e, t) {
            return e.evalExpression(this, e.context);
        }
        search(e) {
            this.right.search(e);
        }
    }
    class En extends tT {
        constructor(e, t, i){
            super(), this.operator = e, this.left = t, this.right = i;
        }
        get astNodeType() {
            return "binaryOp";
        }
        _getPromotedType(e, t) {
            return e.name === t.name ? e : e.name === "f32" || t.name === "f32" ? q.f32 : e.name === "u32" || t.name === "u32" ? q.u32 : q.i32;
        }
        constEvaluate(e, t) {
            return e.evalExpression(this, e.context);
        }
        search(e) {
            this.left.search(e), this.right.search(e);
        }
    }
    class nT extends Tn {
        constructor(e){
            super(), this.body = e;
        }
    }
    class gc extends Xn {
        constructor(){
            super();
        }
        get astNodeType() {
            return "default";
        }
    }
    class iT extends nT {
        constructor(e, t){
            super(t), this.selectors = e;
        }
        get astNodeType() {
            return "case";
        }
        search(e) {
            this.searchBlock(this.body, e);
        }
    }
    class rT extends nT {
        constructor(e){
            super(e);
        }
        get astNodeType() {
            return "default";
        }
        search(e) {
            this.searchBlock(this.body, e);
        }
    }
    class Kb extends Tn {
        constructor(e, t, i){
            super(), this.name = e, this.type = t, this.attributes = i;
        }
        get astNodeType() {
            return "argument";
        }
    }
    class rC extends Tn {
        constructor(e, t){
            super(), this.condition = e, this.body = t;
        }
        get astNodeType() {
            return "elseif";
        }
        search(e) {
            this.condition.search(e), this.searchBlock(this.body, e);
        }
    }
    class Zb extends Tn {
        constructor(e, t, i){
            super(), this.name = e, this.type = t, this.attributes = i;
        }
        get astNodeType() {
            return "member";
        }
    }
    class sT extends Tn {
        constructor(e, t){
            super(), this.name = e, this.value = t;
        }
        get astNodeType() {
            return "attribute";
        }
    }
    class vn {
        constructor(e, t){
            this.parent = null, this.typeInfo = e, this.parent = t, this.id = vn._id++;
        }
        clone() {
            throw `Clone: Not implemented for ${this.constructor.name}`;
        }
        setDataValue(e, t, i, r) {
            console.error(`SetDataValue: Not implemented for ${this.constructor.name}`);
        }
        getSubData(e, t, i) {
            return console.error(`GetDataValue: Not implemented for ${this.constructor.name}`), null;
        }
        toString() {
            return `<${this.typeInfo.name}>`;
        }
    }
    vn._id = 0;
    class Rd extends vn {
        constructor(){
            super(new _n("void", null), null);
        }
        toString() {
            return "void";
        }
    }
    Rd.void = new Rd;
    class Cs extends vn {
        constructor(e){
            super(new _n("pointer", null), null), this.reference = e;
        }
        clone() {
            return this;
        }
        setDataValue(e, t, i, r) {
            this.reference.setDataValue(e, t, i, r);
        }
        getSubData(e, t, i) {
            return t ? this.reference.getSubData(e, t, i) : this;
        }
    }
    class I extends vn {
        constructor(e, t, i = null){
            super(t, i), e instanceof Int32Array || e instanceof Uint32Array || e instanceof Float32Array ? this.data = e : this.typeInfo.name === "x32" ? e - Math.floor(e) != 0 ? this.data = new Float32Array([
                e
            ]) : this.data = e >= 0 ? new Uint32Array([
                e
            ]) : new Int32Array([
                e
            ]) : this.typeInfo.name === "i32" || this.typeInfo.name === "bool" ? this.data = new Int32Array([
                e
            ]) : this.typeInfo.name === "u32" ? this.data = new Uint32Array([
                e
            ]) : this.typeInfo.name === "f32" || this.typeInfo.name === "f16" ? this.data = new Float32Array([
                e
            ]) : console.error("ScalarData2: Invalid type", t);
        }
        clone() {
            if (this.data instanceof Float32Array) return new I(new Float32Array(this.data), this.typeInfo, null);
            if (this.data instanceof Int32Array) return new I(new Int32Array(this.data), this.typeInfo, null);
            if (this.data instanceof Uint32Array) return new I(new Uint32Array(this.data), this.typeInfo, null);
            throw "ScalarData: Invalid data type";
        }
        get value() {
            return this.data[0];
        }
        set value(e) {
            this.data[0] = e;
        }
        setDataValue(e, t, i, r) {
            if (i) return void console.error("SetDataValue: Scalar data does not support postfix", i);
            if (!(t instanceof I)) return void console.error("SetDataValue: Invalid value", t);
            let a = t.data[0];
            this.typeInfo.name === "i32" || this.typeInfo.name === "u32" ? a = Math.floor(a) : this.typeInfo.name === "bool" && (a = a ? 1 : 0), this.data[0] = a;
        }
        getSubData(e, t, i) {
            return t ? (console.error("getSubData: Scalar data does not support postfix", t), null) : this;
        }
        toString() {
            return `${this.value}`;
        }
    }
    function sC(n, e, t) {
        const i = e.length;
        return i === 2 ? t === "f32" ? new A(new Float32Array(e), n.getTypeInfo("vec2f")) : t === "i32" || t === "bool" ? new A(new Int32Array(e), n.getTypeInfo("vec2i")) : t === "u32" ? new A(new Uint32Array(e), n.getTypeInfo("vec2u")) : t === "f16" ? new A(new Float32Array(e), n.getTypeInfo("vec2h")) : (console.error(`getSubData: Unknown format ${t}`), null) : i === 3 ? t === "f32" ? new A(new Float32Array(e), n.getTypeInfo("vec3f")) : t === "i32" || t === "bool" ? new A(new Int32Array(e), n.getTypeInfo("vec3i")) : t === "u32" ? new A(new Uint32Array(e), n.getTypeInfo("vec3u")) : t === "f16" ? new A(new Float32Array(e), n.getTypeInfo("vec3h")) : (console.error(`getSubData: Unknown format ${t}`), null) : i === 4 ? t === "f32" ? new A(new Float32Array(e), n.getTypeInfo("vec4f")) : t === "i32" || t === "bool" ? new A(new Int32Array(e), n.getTypeInfo("vec4i")) : t === "u32" ? new A(new Uint32Array(e), n.getTypeInfo("vec4u")) : t === "f16" ? new A(new Float32Array(e), n.getTypeInfo("vec4h")) : (console.error(`getSubData: Unknown format ${t}`), null) : (console.error(`getSubData: Invalid vector size ${e.length}`), null);
    }
    class A extends vn {
        constructor(e, t, i = null){
            if (super(t, i), e instanceof Float32Array || e instanceof Uint32Array || e instanceof Int32Array) this.data = e;
            else {
                const r = this.typeInfo.name;
                r === "vec2f" || r === "vec3f" || r === "vec4f" ? this.data = new Float32Array(e) : r === "vec2i" || r === "vec3i" || r === "vec4i" ? this.data = new Int32Array(e) : r === "vec2u" || r === "vec3u" || r === "vec4u" ? this.data = new Uint32Array(e) : r === "vec2h" || r === "vec3h" || r === "vec4h" ? this.data = new Float32Array(e) : r === "vec2b" || r === "vec3b" || r === "vec4b" ? this.data = new Int32Array(e) : r === "vec2" || r === "vec3" || r === "vec4" ? this.data = new Float32Array(e) : console.error(`VectorData: Invalid type ${r}`);
            }
        }
        clone() {
            if (this.data instanceof Float32Array) return new A(new Float32Array(this.data), this.typeInfo, null);
            if (this.data instanceof Int32Array) return new A(new Int32Array(this.data), this.typeInfo, null);
            if (this.data instanceof Uint32Array) return new A(new Uint32Array(this.data), this.typeInfo, null);
            throw "VectorData: Invalid data type";
        }
        setDataValue(e, t, i, r) {
            i instanceof Or ? console.error("TODO: Set vector postfix") : t instanceof A ? this.data = t.data : console.error("SetDataValue: Invalid value", t);
        }
        getSubData(e, t, i) {
            if (t === null) return this;
            let r = e.getTypeInfo("f32");
            if (this.typeInfo instanceof Mr) r = this.typeInfo.format || r;
            else {
                const l = this.typeInfo.name;
                l === "vec2f" || l === "vec3f" || l === "vec4f" ? r = e.getTypeInfo("f32") : l === "vec2i" || l === "vec3i" || l === "vec4i" ? r = e.getTypeInfo("i32") : l === "vec2b" || l === "vec3b" || l === "vec4b" ? r = e.getTypeInfo("bool") : l === "vec2u" || l === "vec3u" || l === "vec4u" ? r = e.getTypeInfo("u32") : l === "vec2h" || l === "vec3h" || l === "vec4h" ? r = e.getTypeInfo("f16") : console.error(`GetSubData: Unknown type ${l}`);
            }
            let a = this;
            for(; t !== null && a !== null;){
                if (t instanceof Xs) {
                    const l = t.index;
                    let u = -1;
                    if (l instanceof pt) {
                        if (!(l.value instanceof I)) return console.error(`GetSubData: Invalid array index ${l.value}`), null;
                        u = l.value.value;
                    } else {
                        const h = e.evalExpression(l, i);
                        if (!(h instanceof I)) return console.error("GetSubData: Unknown index type", l), null;
                        u = h.value;
                    }
                    if (u < 0 || u >= a.data.length) return console.error("GetSubData: Index out of range", u), null;
                    if (a.data instanceof Float32Array) {
                        const h = new Float32Array(a.data.buffer, a.data.byteOffset + 4 * u, 1);
                        return new I(h, r);
                    }
                    if (a.data instanceof Int32Array) {
                        const h = new Int32Array(a.data.buffer, a.data.byteOffset + 4 * u, 1);
                        return new I(h, r);
                    }
                    if (a.data instanceof Uint32Array) {
                        const h = new Uint32Array(a.data.buffer, a.data.byteOffset + 4 * u, 1);
                        return new I(h, r);
                    }
                    throw "GetSubData: Invalid data type";
                }
                if (!(t instanceof Or)) return console.error("GetSubData: Unknown postfix", t), null;
                {
                    const l = t.value.toLowerCase();
                    if (l.length === 1) {
                        let h = 0;
                        if (l === "x" || l === "r") h = 0;
                        else if (l === "y" || l === "g") h = 1;
                        else if (l === "z" || l === "b") h = 2;
                        else {
                            if (l !== "w" && l !== "a") return console.error(`GetSubData: Unknown member ${l}`), null;
                            h = 3;
                        }
                        if (this.data instanceof Float32Array) {
                            let d = new Float32Array(this.data.buffer, this.data.byteOffset + 4 * h, 1);
                            return new I(d, r, this);
                        }
                        if (this.data instanceof Int32Array) {
                            let d = new Int32Array(this.data.buffer, this.data.byteOffset + 4 * h, 1);
                            return new I(d, r, this);
                        }
                        if (this.data instanceof Uint32Array) {
                            let d = new Uint32Array(this.data.buffer, this.data.byteOffset + 4 * h, 1);
                            return new I(d, r, this);
                        }
                    }
                    const u = [];
                    for (const h of l)h === "x" || h === "r" ? u.push(this.data[0]) : h === "y" || h === "g" ? u.push(this.data[1]) : h === "z" || h === "b" ? u.push(this.data[2]) : h === "w" || h === "a" ? u.push(this.data[3]) : console.error(`GetDataValue: Unknown member ${h}`);
                    a = sC(e, u, r.name);
                }
                t = t.postfix;
            }
            return a;
        }
        toString() {
            let e = `${this.data[0]}`;
            for(let t = 1; t < this.data.length; ++t)e += `, ${this.data[t]}`;
            return e;
        }
    }
    class me extends vn {
        constructor(e, t, i = null){
            super(t, i), e instanceof Float32Array ? this.data = e : this.data = new Float32Array(e);
        }
        clone() {
            return new me(new Float32Array(this.data), this.typeInfo, null);
        }
        setDataValue(e, t, i, r) {
            i instanceof Or ? console.error("TODO: Set matrix postfix") : t instanceof me ? this.data = t.data : console.error("SetDataValue: Invalid value", t);
        }
        getSubData(e, t, i) {
            if (t === null) return this;
            const r = this.typeInfo.name;
            if (e.getTypeInfo("f32"), this.typeInfo instanceof Mr) this.typeInfo.format;
            else if (r.endsWith("f")) e.getTypeInfo("f32");
            else if (r.endsWith("i")) e.getTypeInfo("i32");
            else if (r.endsWith("u")) e.getTypeInfo("u32");
            else {
                if (!r.endsWith("h")) return console.error(`GetDataValue: Unknown type ${r}`), null;
                e.getTypeInfo("f16");
            }
            if (t instanceof Xs) {
                const a = t.index;
                let l = -1;
                if (a instanceof pt) {
                    if (!(a.value instanceof I)) return console.error(`GetDataValue: Invalid array index ${a.value}`), null;
                    l = a.value.value;
                } else {
                    const d = e.evalExpression(a, i);
                    if (!(d instanceof I)) return console.error("GetDataValue: Unknown index type", a), null;
                    l = d.value;
                }
                if (l < 0 || l >= this.data.length) return console.error("GetDataValue: Index out of range", l), null;
                const u = r.endsWith("h") ? "h" : "f";
                let h;
                if (r === "mat2x2" || r === "mat2x2f" || r === "mat2x2h" || r === "mat3x2" || r === "mat3x2f" || r === "mat3x2h" || r === "mat4x2" || r === "mat4x2f" || r === "mat4x2h") h = new A(new Float32Array(this.data.buffer, this.data.byteOffset + 2 * l * 4, 2), e.getTypeInfo(`vec2${u}`));
                else if (r === "mat2x3" || r === "mat2x3f" || r === "mat2x3h" || r === "mat3x3" || r === "mat3x3f" || r === "mat3x3h" || r === "mat4x3" || r === "mat4x3f" || r === "mat4x3h") h = new A(new Float32Array(this.data.buffer, this.data.byteOffset + 3 * l * 4, 3), e.getTypeInfo(`vec3${u}`));
                else {
                    if (r !== "mat2x4" && r !== "mat2x4f" && r !== "mat2x4h" && r !== "mat3x4" && r !== "mat3x4f" && r !== "mat3x4h" && r !== "mat4x4" && r !== "mat4x4f" && r !== "mat4x4h") return console.error(`GetDataValue: Unknown type ${r}`), null;
                    h = new A(new Float32Array(this.data.buffer, this.data.byteOffset + 4 * l * 4, 4), e.getTypeInfo(`vec4${u}`));
                }
                return t.postfix ? h.getSubData(e, t.postfix, i) : h;
            }
            return console.error("GetDataValue: Invalid postfix", t), null;
        }
        toString() {
            let e = `${this.data[0]}`;
            for(let t = 1; t < this.data.length; ++t)e += `, ${this.data[t]}`;
            return e;
        }
    }
    class st extends vn {
        constructor(e, t, i = 0, r = null){
            super(t, r), this.buffer = e instanceof ArrayBuffer ? e : e.buffer, this.offset = i;
        }
        clone() {
            const e = new Uint8Array(new Uint8Array(this.buffer, this.offset, this.typeInfo.size));
            return new st(e.buffer, this.typeInfo, 0, null);
        }
        setDataValue(e, t, i, r) {
            if (t === null) return void console.log("setDataValue: NULL data.");
            let a = this.offset, l = this.typeInfo;
            for(; i;){
                if (i instanceof Xs) if (l instanceof Ki) {
                    const u = i.index;
                    if (u instanceof pt) {
                        if (!(u.value instanceof I)) return void console.error(`SetDataValue: Invalid index type ${u.value}`);
                        a += u.value.value * l.stride;
                    } else {
                        const h = e.evalExpression(u, r);
                        if (!(h instanceof I)) return void console.error("SetDataValue: Unknown index type", u);
                        a += h.value * l.stride;
                    }
                    l = l.format;
                } else console.error(`SetDataValue: Type ${l.getTypeName()} is not an array`);
                else {
                    if (!(i instanceof Or)) return void console.error("SetDataValue: Unknown postfix type", i);
                    {
                        const u = i.value;
                        if (l instanceof $i) {
                            let h = !1;
                            for (const d of l.members)if (d.name === u) {
                                a += d.offset, l = d.type, h = !0;
                                break;
                            }
                            if (!h) return void console.error(`SetDataValue: Member ${u} not found`);
                        } else if (l instanceof _n) {
                            const h = l.getTypeName();
                            let d = 0;
                            if (u === "x" || u === "r") d = 0;
                            else if (u === "y" || u === "g") d = 1;
                            else if (u === "z" || u === "b") d = 2;
                            else {
                                if (u !== "w" && u !== "a") return void console.error(`SetDataValue: Unknown member ${u}`);
                                d = 3;
                            }
                            if (!(t instanceof I)) return void console.error("SetDataValue: Invalid value", t);
                            const p = t.value;
                            return h === "vec2f" ? void (new Float32Array(this.buffer, a, 2)[d] = p) : h === "vec3f" ? void (new Float32Array(this.buffer, a, 3)[d] = p) : h === "vec4f" ? void (new Float32Array(this.buffer, a, 4)[d] = p) : h === "vec2i" ? void (new Int32Array(this.buffer, a, 2)[d] = p) : h === "vec3i" ? void (new Int32Array(this.buffer, a, 3)[d] = p) : h === "vec4i" ? void (new Int32Array(this.buffer, a, 4)[d] = p) : h === "vec2u" ? void (new Uint32Array(this.buffer, a, 2)[d] = p) : h === "vec3u" ? void (new Uint32Array(this.buffer, a, 3)[d] = p) : h === "vec4u" ? void (new Uint32Array(this.buffer, a, 4)[d] = p) : void console.error(`SetDataValue: Type ${h} is not a struct`);
                        }
                    }
                }
                i = i.postfix;
            }
            this.setData(e, t, l, a, r);
        }
        setData(e, t, i, r, a) {
            const l = i.getTypeName();
            if (l !== "f32" && l !== "f16") if (l !== "i32" && l !== "atomic<i32>" && l !== "x32") if (l !== "u32" && l !== "atomic<u32>") if (l !== "bool") if (l !== "vec2f" && l !== "vec2h") if (l !== "vec3f" && l !== "vec3h") if (l !== "vec4f" && l !== "vec4h") if (l !== "vec2i") if (l !== "vec3i") if (l !== "vec4i") if (l !== "vec2u") if (l !== "vec3u") if (l !== "vec4u") if (l !== "vec2b") if (l !== "vec3b") if (l !== "vec4b") if (l !== "mat2x2f" && l !== "mat2x2h") if (l !== "mat2x3f" && l !== "mat2x3h") if (l !== "mat2x4f" && l !== "mat2x4h") if (l !== "mat3x2f" && l !== "mat3x2h") if (l !== "mat3x3f" && l !== "mat3x3h") if (l !== "mat3x4f" && l !== "mat3x4h") if (l !== "mat4x2f" && l !== "mat4x2h") if (l !== "mat4x3f" && l !== "mat4x3h") if (l !== "mat4x4f" && l !== "mat4x4h") if (t instanceof st) {
                if (i === t.typeInfo) return void new Uint8Array(this.buffer, r, t.buffer.byteLength).set(new Uint8Array(t.buffer));
                console.error("SetDataValue: Type mismatch", l, t.typeInfo.getTypeName());
            } else console.error(`SetData: Unknown type ${l}`);
            else {
                const u = new Float32Array(this.buffer, r, 16);
                t instanceof me ? (u[0] = t.data[0], u[1] = t.data[1], u[2] = t.data[2], u[3] = t.data[3], u[4] = t.data[4], u[5] = t.data[5], u[6] = t.data[6], u[7] = t.data[7], u[8] = t.data[8], u[9] = t.data[9], u[10] = t.data[10], u[11] = t.data[11], u[12] = t.data[12], u[13] = t.data[13], u[14] = t.data[14], u[15] = t.data[15]) : (u[0] = t[0], u[1] = t[1], u[2] = t[2], u[3] = t[3], u[4] = t[4], u[5] = t[5], u[6] = t[6], u[7] = t[7], u[8] = t[8], u[9] = t[9], u[10] = t[10], u[11] = t[11], u[12] = t[12], u[13] = t[13], u[14] = t[14], u[15] = t[15]);
            }
            else {
                const u = new Float32Array(this.buffer, r, 12);
                t instanceof me ? (u[0] = t.data[0], u[1] = t.data[1], u[2] = t.data[2], u[3] = t.data[3], u[4] = t.data[4], u[5] = t.data[5], u[6] = t.data[6], u[7] = t.data[7], u[8] = t.data[8], u[9] = t.data[9], u[10] = t.data[10], u[11] = t.data[11]) : (u[0] = t[0], u[1] = t[1], u[2] = t[2], u[3] = t[3], u[4] = t[4], u[5] = t[5], u[6] = t[6], u[7] = t[7], u[8] = t[8], u[9] = t[9], u[10] = t[10], u[11] = t[11]);
            }
            else {
                const u = new Float32Array(this.buffer, r, 8);
                t instanceof me ? (u[0] = t.data[0], u[1] = t.data[1], u[2] = t.data[2], u[3] = t.data[3], u[4] = t.data[4], u[5] = t.data[5], u[6] = t.data[6], u[7] = t.data[7]) : (u[0] = t[0], u[1] = t[1], u[2] = t[2], u[3] = t[3], u[4] = t[4], u[5] = t[5], u[6] = t[6], u[7] = t[7]);
            }
            else {
                const u = new Float32Array(this.buffer, r, 12);
                t instanceof me ? (u[0] = t.data[0], u[1] = t.data[1], u[2] = t.data[2], u[3] = t.data[3], u[4] = t.data[4], u[5] = t.data[5], u[6] = t.data[6], u[7] = t.data[7], u[8] = t.data[8], u[9] = t.data[9], u[10] = t.data[10], u[11] = t.data[11]) : (u[0] = t[0], u[1] = t[1], u[2] = t[2], u[3] = t[3], u[4] = t[4], u[5] = t[5], u[6] = t[6], u[7] = t[7], u[8] = t[8], u[9] = t[9], u[10] = t[10], u[11] = t[11]);
            }
            else {
                const u = new Float32Array(this.buffer, r, 9);
                t instanceof me ? (u[0] = t.data[0], u[1] = t.data[1], u[2] = t.data[2], u[3] = t.data[3], u[4] = t.data[4], u[5] = t.data[5], u[6] = t.data[6], u[7] = t.data[7], u[8] = t.data[8]) : (u[0] = t[0], u[1] = t[1], u[2] = t[2], u[3] = t[3], u[4] = t[4], u[5] = t[5], u[6] = t[6], u[7] = t[7], u[8] = t[8]);
            }
            else {
                const u = new Float32Array(this.buffer, r, 6);
                t instanceof me ? (u[0] = t.data[0], u[1] = t.data[1], u[2] = t.data[2], u[3] = t.data[3], u[4] = t.data[4], u[5] = t.data[5]) : (u[0] = t[0], u[1] = t[1], u[2] = t[2], u[3] = t[3], u[4] = t[4], u[5] = t[5]);
            }
            else {
                const u = new Float32Array(this.buffer, r, 8);
                t instanceof me ? (u[0] = t.data[0], u[1] = t.data[1], u[2] = t.data[2], u[3] = t.data[3], u[4] = t.data[4], u[5] = t.data[5], u[6] = t.data[6], u[7] = t.data[7]) : (u[0] = t[0], u[1] = t[1], u[2] = t[2], u[3] = t[3], u[4] = t[4], u[5] = t[5], u[6] = t[6], u[7] = t[7]);
            }
            else {
                const u = new Float32Array(this.buffer, r, 6);
                t instanceof me ? (u[0] = t.data[0], u[1] = t.data[1], u[2] = t.data[2], u[3] = t.data[3], u[4] = t.data[4], u[5] = t.data[5]) : (u[0] = t[0], u[1] = t[1], u[2] = t[2], u[3] = t[3], u[4] = t[4], u[5] = t[5]);
            }
            else {
                const u = new Float32Array(this.buffer, r, 4);
                t instanceof me ? (u[0] = t.data[0], u[1] = t.data[1], u[2] = t.data[2], u[3] = t.data[3]) : (u[0] = t[0], u[1] = t[1], u[2] = t[2], u[3] = t[3]);
            }
            else {
                const u = new Uint32Array(this.buffer, r, 4);
                t instanceof A ? (u[0] = t.data[0], u[1] = t.data[1], u[2] = t.data[2], u[3] = t.data[3]) : (u[0] = t[0], u[1] = t[1], u[2] = t[2], u[3] = t[3]);
            }
            else {
                const u = new Uint32Array(this.buffer, r, 3);
                t instanceof A ? (u[0] = t.data[0], u[1] = t.data[1], u[2] = t.data[2]) : (u[0] = t[0], u[1] = t[1], u[2] = t[2]);
            }
            else {
                const u = new Uint32Array(this.buffer, r, 2);
                t instanceof A ? (u[0] = t.data[0], u[1] = t.data[1]) : (u[0] = t[0], u[1] = t[1]);
            }
            else {
                const u = new Uint32Array(this.buffer, r, 4);
                t instanceof A ? (u[0] = t.data[0], u[1] = t.data[1], u[2] = t.data[2], u[3] = t.data[3]) : (u[0] = t[0], u[1] = t[1], u[2] = t[2], u[3] = t[3]);
            }
            else {
                const u = new Uint32Array(this.buffer, r, 3);
                t instanceof A ? (u[0] = t.data[0], u[1] = t.data[1], u[2] = t.data[2]) : (u[0] = t[0], u[1] = t[1], u[2] = t[2]);
            }
            else {
                const u = new Uint32Array(this.buffer, r, 2);
                t instanceof A ? (u[0] = t.data[0], u[1] = t.data[1]) : (u[0] = t[0], u[1] = t[1]);
            }
            else {
                const u = new Int32Array(this.buffer, r, 4);
                t instanceof A ? (u[0] = t.data[0], u[1] = t.data[1], u[2] = t.data[2], u[3] = t.data[3]) : (u[0] = t[0], u[1] = t[1], u[2] = t[2], u[3] = t[3]);
            }
            else {
                const u = new Int32Array(this.buffer, r, 3);
                t instanceof A ? (u[0] = t.data[0], u[1] = t.data[1], u[2] = t.data[2]) : (u[0] = t[0], u[1] = t[1], u[2] = t[2]);
            }
            else {
                const u = new Int32Array(this.buffer, r, 2);
                t instanceof A ? (u[0] = t.data[0], u[1] = t.data[1]) : (u[0] = t[0], u[1] = t[1]);
            }
            else {
                const u = new Float32Array(this.buffer, r, 4);
                t instanceof A ? (u[0] = t.data[0], u[1] = t.data[1], u[2] = t.data[2], u[3] = t.data[3]) : (u[0] = t[0], u[1] = t[1], u[2] = t[2], u[3] = t[3]);
            }
            else {
                const u = new Float32Array(this.buffer, r, 3);
                t instanceof A ? (u[0] = t.data[0], u[1] = t.data[1], u[2] = t.data[2]) : (u[0] = t[0], u[1] = t[1], u[2] = t[2]);
            }
            else {
                const u = new Float32Array(this.buffer, r, 2);
                t instanceof A ? (u[0] = t.data[0], u[1] = t.data[1]) : (u[0] = t[0], u[1] = t[1]);
            }
            else t instanceof I && (new Int32Array(this.buffer, r, 1)[0] = t.value);
            else t instanceof I && (new Uint32Array(this.buffer, r, 1)[0] = t.value);
            else t instanceof I && (new Int32Array(this.buffer, r, 1)[0] = t.value);
            else t instanceof I && (new Float32Array(this.buffer, r, 1)[0] = t.value);
        }
        getSubData(e, t, i) {
            var r, a, l;
            if (t === null) return this;
            let u = this.offset, h = this.typeInfo;
            for(; t;){
                if (t instanceof Xs) {
                    const p = t.index, _ = e.evalExpression(p, i);
                    let y = 0;
                    if (_ instanceof I ? y = _.value : console.error("GetDataValue: Invalid index type", p), h instanceof Ki) u += y * h.stride, h = h.format;
                    else {
                        const v = h.getTypeName();
                        v === "mat4x4" || v === "mat4x4f" || v === "mat4x4h" ? (u += 16 * y, h = e.getTypeInfo("vec4f")) : console.error(`getDataValue: Type ${h.getTypeName()} is not an array`);
                    }
                } else {
                    if (!(t instanceof Or)) return console.error("GetDataValue: Unknown postfix type", t), null;
                    {
                        const p = t.value;
                        if (h instanceof $i) {
                            let _ = !1;
                            for (const y of h.members)if (y.name === p) {
                                u += y.offset, h = y.type, _ = !0;
                                break;
                            }
                            if (!_) return console.error(`GetDataValue: Member ${p} not found`), null;
                        } else if (h instanceof _n) {
                            const _ = h.getTypeName();
                            if (_ === "vec2f" || _ === "vec3f" || _ === "vec4f" || _ === "vec2i" || _ === "vec3i" || _ === "vec4i" || _ === "vec2u" || _ === "vec3u" || _ === "vec4u" || _ === "vec2b" || _ === "vec3b" || _ === "vec4b" || _ === "vec2h" || _ === "vec3h" || _ === "vec4h" || _ === "vec2" || _ === "vec3" || _ === "vec4") {
                                if (p.length > 0 && p.length < 5) {
                                    let y = "f";
                                    const v = [];
                                    for(let S = 0; S < p.length; ++S){
                                        const E = p[S].toLowerCase();
                                        let M = 0;
                                        if (E === "x" || E === "r") M = 0;
                                        else if (E === "y" || E === "g") M = 1;
                                        else if (E === "z" || E === "b") M = 2;
                                        else {
                                            if (E !== "w" && E !== "a") return console.error(`Unknown member ${p}`), null;
                                            M = 3;
                                        }
                                        if (p.length === 1) {
                                            if (_.endsWith("f")) return this.buffer.byteLength < u + 4 * M + 4 ? (console.log("Insufficient buffer data"), null) : new I(new Float32Array(this.buffer, u + 4 * M, 1), e.getTypeInfo("f32"), this);
                                            if (_.endsWith("h")) return new I(new Float32Array(this.buffer, u + 4 * M, 1), e.getTypeInfo("f16"), this);
                                            if (_.endsWith("i")) return new I(new Int32Array(this.buffer, u + 4 * M, 1), e.getTypeInfo("i32"), this);
                                            if (_.endsWith("b")) return new I(new Int32Array(this.buffer, u + 4 * M, 1), e.getTypeInfo("bool"), this);
                                            if (_.endsWith("u")) return new I(new Uint32Array(this.buffer, u + 4 * M, 1), e.getTypeInfo("i32"), this);
                                        }
                                        if (_ === "vec2f") v.push(new Float32Array(this.buffer, u, 2)[M]);
                                        else if (_ === "vec3f") {
                                            if (u + 12 >= this.buffer.byteLength) return console.log("Insufficient buffer data"), null;
                                            const B = new Float32Array(this.buffer, u, 3);
                                            v.push(B[M]);
                                        } else if (_ === "vec4f") v.push(new Float32Array(this.buffer, u, 4)[M]);
                                        else if (_ === "vec2i") y = "i", v.push(new Int32Array(this.buffer, u, 2)[M]);
                                        else if (_ === "vec3i") y = "i", v.push(new Int32Array(this.buffer, u, 3)[M]);
                                        else if (_ === "vec4i") y = "i", v.push(new Int32Array(this.buffer, u, 4)[M]);
                                        else if (_ === "vec2u") {
                                            y = "u";
                                            const B = new Uint32Array(this.buffer, u, 2);
                                            v.push(B[M]);
                                        } else _ === "vec3u" ? (y = "u", v.push(new Uint32Array(this.buffer, u, 3)[M])) : _ === "vec4u" && (y = "u", v.push(new Uint32Array(this.buffer, u, 4)[M]));
                                    }
                                    return v.length === 2 ? h = e.getTypeInfo(`vec2${y}`) : v.length === 3 ? h = e.getTypeInfo(`vec3${y}`) : v.length === 4 ? h = e.getTypeInfo(`vec4${y}`) : console.error(`GetDataValue: Invalid vector length ${v.length}`), new A(v, h, null);
                                }
                                return console.error(`GetDataValue: Unknown member ${p}`), null;
                            }
                            return console.error(`GetDataValue: Type ${_} is not a struct`), null;
                        }
                    }
                }
                t = t.postfix;
            }
            const d = h.getTypeName();
            return d === "f32" ? new I(new Float32Array(this.buffer, u, 1), h, this) : d === "i32" ? new I(new Int32Array(this.buffer, u, 1), h, this) : d === "u32" ? new I(new Uint32Array(this.buffer, u, 1), h, this) : d === "vec2f" ? new A(new Float32Array(this.buffer, u, 2), h, this) : d === "vec3f" ? new A(new Float32Array(this.buffer, u, 3), h, this) : d === "vec4f" ? new A(new Float32Array(this.buffer, u, 4), h, this) : d === "vec2i" ? new A(new Int32Array(this.buffer, u, 2), h, this) : d === "vec3i" ? new A(new Int32Array(this.buffer, u, 3), h, this) : d === "vec4i" ? new A(new Int32Array(this.buffer, u, 4), h, this) : d === "vec2u" ? new A(new Uint32Array(this.buffer, u, 2), h, this) : d === "vec3u" ? new A(new Uint32Array(this.buffer, u, 3), h, this) : d === "vec4u" ? new A(new Uint32Array(this.buffer, u, 4), h, this) : h instanceof Mr && h.name === "atomic" ? ((r = h.format) === null || r === void 0 ? void 0 : r.name) === "u32" ? new I(new Uint32Array(this.buffer, u, 1)[0], h.format, this) : ((a = h.format) === null || a === void 0 ? void 0 : a.name) === "i32" ? new I(new Int32Array(this.buffer, u, 1)[0], h.format, this) : (console.error(`GetDataValue: Invalid atomic format ${(l = h.format) === null || l === void 0 ? void 0 : l.name}`), null) : new st(this.buffer, h, u, this);
        }
        toString() {
            let e = "";
            if (this.typeInfo instanceof Ki) if (this.typeInfo.format.name === "f32") {
                const t = new Float32Array(this.buffer, this.offset);
                e = `[${t[0]}`;
                for(let i = 1; i < t.length; ++i)e += `, ${t[i]}`;
            } else if (this.typeInfo.format.name === "i32") {
                const t = new Int32Array(this.buffer, this.offset);
                e = `[${t[0]}`;
                for(let i = 1; i < t.length; ++i)e += `, ${t[i]}`;
            } else if (this.typeInfo.format.name === "u32") {
                const t = new Uint32Array(this.buffer, this.offset);
                e = `[${t[0]}`;
                for(let i = 1; i < t.length; ++i)e += `, ${t[i]}`;
            } else if (this.typeInfo.format.name === "vec2f") {
                const t = new Float32Array(this.buffer, this.offset);
                e = `[${t[0]}, ${t[1]}]`;
                for(let i = 1; i < t.length / 2; ++i)e += `, [${t[2 * i]}, ${t[2 * i + 1]}]`;
            } else if (this.typeInfo.format.name === "vec3f") {
                const t = new Float32Array(this.buffer, this.offset);
                e = `[${t[0]}, ${t[1]}, ${t[2]}]`;
                for(let i = 4; i < t.length; i += 4)e += `, [${t[i]}, ${t[i + 1]}, ${t[i + 2]}]`;
            } else if (this.typeInfo.format.name === "vec4f") {
                const t = new Float32Array(this.buffer, this.offset);
                e = `[${t[0]}, ${t[1]}, ${t[2]}, ${t[3]}]`;
                for(let i = 4; i < t.length; i += 4)e += `, [${t[i]}, ${t[i + 1]}, ${t[i + 2]}, ${t[i + 3]}]`;
            } else e = "[...]";
            else this.typeInfo instanceof $i ? e += "{...}" : e = "[...]";
            return e;
        }
    }
    class ui extends vn {
        constructor(e, t, i, r){
            super(t, null), this.data = e, this.descriptor = i, this.view = r;
        }
        clone() {
            return new ui(this.data, this.typeInfo, this.descriptor, this.view);
        }
        get width() {
            var e, t;
            const i = this.descriptor.size;
            return i instanceof Array && i.length > 0 ? (e = i[0]) !== null && e !== void 0 ? e : 0 : i instanceof Object && (t = i.width) !== null && t !== void 0 ? t : 0;
        }
        get height() {
            var e, t;
            const i = this.descriptor.size;
            return i instanceof Array && i.length > 1 ? (e = i[1]) !== null && e !== void 0 ? e : 0 : i instanceof Object && (t = i.height) !== null && t !== void 0 ? t : 0;
        }
        get depthOrArrayLayers() {
            var e, t;
            const i = this.descriptor.size;
            return i instanceof Array && i.length > 2 ? (e = i[2]) !== null && e !== void 0 ? e : 0 : i instanceof Object && (t = i.depthOrArrayLayers) !== null && t !== void 0 ? t : 0;
        }
        get format() {
            var e;
            return this.descriptor && (e = this.descriptor.format) !== null && e !== void 0 ? e : "rgba8unorm";
        }
        get sampleCount() {
            var e;
            return this.descriptor && (e = this.descriptor.sampleCount) !== null && e !== void 0 ? e : 1;
        }
        get mipLevelCount() {
            var e;
            return this.descriptor && (e = this.descriptor.mipLevelCount) !== null && e !== void 0 ? e : 1;
        }
        get dimension() {
            var e;
            return this.descriptor && (e = this.descriptor.dimension) !== null && e !== void 0 ? e : "2d";
        }
        getMipLevelSize(e) {
            if (e >= this.mipLevelCount) return [
                0,
                0,
                0
            ];
            const t = [
                this.width,
                this.height,
                this.depthOrArrayLayers
            ];
            for(let i = 0; i < t.length; ++i)t[i] = Math.max(1, t[i] >> e);
            return t;
        }
        get texelByteSize() {
            const e = this.format, t = Hh[e];
            return t ? t.isDepthStencil ? 4 : t.bytesPerBlock : 0;
        }
        get bytesPerRow() {
            return this.width * this.texelByteSize;
        }
        get isDepthStencil() {
            const e = this.format, t = Hh[e];
            return !!t && t.isDepthStencil;
        }
        getGpuSize() {
            const e = this.format, t = Hh[e], i = this.width;
            if (!e || i <= 0 || !t) return -1;
            const r = this.height, a = this.depthOrArrayLayers, l = this.dimension;
            return i / t.blockWidth * (l === "1d" ? 1 : r / t.blockHeight) * t.bytesPerBlock * a;
        }
        getPixel(e, t, i = 0, r = 0) {
            const a = this.texelByteSize, l = this.bytesPerRow, u = this.height, h = this.data[r];
            return JR(new Uint8Array(h), e, t, i, r, u, l, a, this.format);
        }
        setPixel(e, t, i, r, a) {
            const l = this.texelByteSize, u = this.bytesPerRow, h = this.height, d = this.data[r];
            (function(p, _, y, v, S, E, M, B, H, O) {
                const U = v * (M >>= S) * (E >>= S) + y * M + _ * B;
                switch(H){
                    case "r8unorm":
                        return void Le(p, U, "8unorm", 1, O);
                    case "r8snorm":
                        return void Le(p, U, "8snorm", 1, O);
                    case "r8uint":
                        return void Le(p, U, "8uint", 1, O);
                    case "r8sint":
                        return void Le(p, U, "8sint", 1, O);
                    case "rg8unorm":
                        return void Le(p, U, "8unorm", 2, O);
                    case "rg8snorm":
                        return void Le(p, U, "8snorm", 2, O);
                    case "rg8uint":
                        return void Le(p, U, "8uint", 2, O);
                    case "rg8sint":
                        return void Le(p, U, "8sint", 2, O);
                    case "rgba8unorm-srgb":
                    case "rgba8unorm":
                    case "bgra8unorm-srgb":
                    case "bgra8unorm":
                        return void Le(p, U, "8unorm", 4, O);
                    case "rgba8snorm":
                        return void Le(p, U, "8snorm", 4, O);
                    case "rgba8uint":
                        return void Le(p, U, "8uint", 4, O);
                    case "rgba8sint":
                        return void Le(p, U, "8sint", 4, O);
                    case "r16uint":
                        return void Le(p, U, "16uint", 1, O);
                    case "r16sint":
                        return void Le(p, U, "16sint", 1, O);
                    case "r16float":
                        return void Le(p, U, "16float", 1, O);
                    case "rg16uint":
                        return void Le(p, U, "16uint", 2, O);
                    case "rg16sint":
                        return void Le(p, U, "16sint", 2, O);
                    case "rg16float":
                        return void Le(p, U, "16float", 2, O);
                    case "rgba16uint":
                        return void Le(p, U, "16uint", 4, O);
                    case "rgba16sint":
                        return void Le(p, U, "16sint", 4, O);
                    case "rgba16float":
                        return void Le(p, U, "16float", 4, O);
                    case "r32uint":
                        return void Le(p, U, "32uint", 1, O);
                    case "r32sint":
                        return void Le(p, U, "32sint", 1, O);
                    case "depth16unorm":
                    case "depth24plus":
                    case "depth24plus-stencil8":
                    case "depth32float":
                    case "depth32float-stencil8":
                    case "r32float":
                        return void Le(p, U, "32float", 1, O);
                    case "rg32uint":
                        return void Le(p, U, "32uint", 2, O);
                    case "rg32sint":
                        return void Le(p, U, "32sint", 2, O);
                    case "rg32float":
                        return void Le(p, U, "32float", 2, O);
                    case "rgba32uint":
                        return void Le(p, U, "32uint", 4, O);
                    case "rgba32sint":
                        return void Le(p, U, "32sint", 4, O);
                    case "rgba32float":
                        return void Le(p, U, "32float", 4, O);
                    case "rg11b10ufloat":
                        console.error("TODO: rg11b10ufloat not supported for writing");
                }
            })(new Uint8Array(d), e, t, i, r, h, u, l, this.format, a);
        }
    }
    ((n)=>{
        n[n.token = 0] = "token", n[n.keyword = 1] = "keyword", n[n.reserved = 2] = "reserved";
    })(N || (N = {}));
    class P {
        constructor(e, t, i){
            this.name = e, this.type = t, this.rule = i;
        }
        toString() {
            return this.name;
        }
    }
    class x {
    }
    F = x, x.none = new P("", N.reserved, ""), x.eof = new P("EOF", N.token, ""), x.reserved = {
        asm: new P("asm", N.reserved, "asm"),
        bf16: new P("bf16", N.reserved, "bf16"),
        do: new P("do", N.reserved, "do"),
        enum: new P("enum", N.reserved, "enum"),
        f16: new P("f16", N.reserved, "f16"),
        f64: new P("f64", N.reserved, "f64"),
        handle: new P("handle", N.reserved, "handle"),
        i8: new P("i8", N.reserved, "i8"),
        i16: new P("i16", N.reserved, "i16"),
        i64: new P("i64", N.reserved, "i64"),
        mat: new P("mat", N.reserved, "mat"),
        premerge: new P("premerge", N.reserved, "premerge"),
        regardless: new P("regardless", N.reserved, "regardless"),
        typedef: new P("typedef", N.reserved, "typedef"),
        u8: new P("u8", N.reserved, "u8"),
        u16: new P("u16", N.reserved, "u16"),
        u64: new P("u64", N.reserved, "u64"),
        unless: new P("unless", N.reserved, "unless"),
        using: new P("using", N.reserved, "using"),
        vec: new P("vec", N.reserved, "vec"),
        void: new P("void", N.reserved, "void")
    }, x.keywords = {
        array: new P("array", N.keyword, "array"),
        atomic: new P("atomic", N.keyword, "atomic"),
        bool: new P("bool", N.keyword, "bool"),
        f32: new P("f32", N.keyword, "f32"),
        i32: new P("i32", N.keyword, "i32"),
        mat2x2: new P("mat2x2", N.keyword, "mat2x2"),
        mat2x3: new P("mat2x3", N.keyword, "mat2x3"),
        mat2x4: new P("mat2x4", N.keyword, "mat2x4"),
        mat3x2: new P("mat3x2", N.keyword, "mat3x2"),
        mat3x3: new P("mat3x3", N.keyword, "mat3x3"),
        mat3x4: new P("mat3x4", N.keyword, "mat3x4"),
        mat4x2: new P("mat4x2", N.keyword, "mat4x2"),
        mat4x3: new P("mat4x3", N.keyword, "mat4x3"),
        mat4x4: new P("mat4x4", N.keyword, "mat4x4"),
        ptr: new P("ptr", N.keyword, "ptr"),
        sampler: new P("sampler", N.keyword, "sampler"),
        sampler_comparison: new P("sampler_comparison", N.keyword, "sampler_comparison"),
        struct: new P("struct", N.keyword, "struct"),
        texture_1d: new P("texture_1d", N.keyword, "texture_1d"),
        texture_2d: new P("texture_2d", N.keyword, "texture_2d"),
        texture_2d_array: new P("texture_2d_array", N.keyword, "texture_2d_array"),
        texture_3d: new P("texture_3d", N.keyword, "texture_3d"),
        texture_cube: new P("texture_cube", N.keyword, "texture_cube"),
        texture_cube_array: new P("texture_cube_array", N.keyword, "texture_cube_array"),
        texture_multisampled_2d: new P("texture_multisampled_2d", N.keyword, "texture_multisampled_2d"),
        texture_storage_1d: new P("texture_storage_1d", N.keyword, "texture_storage_1d"),
        texture_storage_2d: new P("texture_storage_2d", N.keyword, "texture_storage_2d"),
        texture_storage_2d_array: new P("texture_storage_2d_array", N.keyword, "texture_storage_2d_array"),
        texture_storage_3d: new P("texture_storage_3d", N.keyword, "texture_storage_3d"),
        texture_depth_2d: new P("texture_depth_2d", N.keyword, "texture_depth_2d"),
        texture_depth_2d_array: new P("texture_depth_2d_array", N.keyword, "texture_depth_2d_array"),
        texture_depth_cube: new P("texture_depth_cube", N.keyword, "texture_depth_cube"),
        texture_depth_cube_array: new P("texture_depth_cube_array", N.keyword, "texture_depth_cube_array"),
        texture_depth_multisampled_2d: new P("texture_depth_multisampled_2d", N.keyword, "texture_depth_multisampled_2d"),
        texture_external: new P("texture_external", N.keyword, "texture_external"),
        u32: new P("u32", N.keyword, "u32"),
        vec2: new P("vec2", N.keyword, "vec2"),
        vec3: new P("vec3", N.keyword, "vec3"),
        vec4: new P("vec4", N.keyword, "vec4"),
        bitcast: new P("bitcast", N.keyword, "bitcast"),
        block: new P("block", N.keyword, "block"),
        break: new P("break", N.keyword, "break"),
        case: new P("case", N.keyword, "case"),
        continue: new P("continue", N.keyword, "continue"),
        continuing: new P("continuing", N.keyword, "continuing"),
        default: new P("default", N.keyword, "default"),
        diagnostic: new P("diagnostic", N.keyword, "diagnostic"),
        discard: new P("discard", N.keyword, "discard"),
        else: new P("else", N.keyword, "else"),
        enable: new P("enable", N.keyword, "enable"),
        fallthrough: new P("fallthrough", N.keyword, "fallthrough"),
        false: new P("false", N.keyword, "false"),
        fn: new P("fn", N.keyword, "fn"),
        for: new P("for", N.keyword, "for"),
        function: new P("function", N.keyword, "function"),
        if: new P("if", N.keyword, "if"),
        let: new P("let", N.keyword, "let"),
        const: new P("const", N.keyword, "const"),
        loop: new P("loop", N.keyword, "loop"),
        while: new P("while", N.keyword, "while"),
        private: new P("private", N.keyword, "private"),
        read: new P("read", N.keyword, "read"),
        read_write: new P("read_write", N.keyword, "read_write"),
        return: new P("return", N.keyword, "return"),
        requires: new P("requires", N.keyword, "requires"),
        storage: new P("storage", N.keyword, "storage"),
        switch: new P("switch", N.keyword, "switch"),
        true: new P("true", N.keyword, "true"),
        alias: new P("alias", N.keyword, "alias"),
        type: new P("type", N.keyword, "type"),
        uniform: new P("uniform", N.keyword, "uniform"),
        var: new P("var", N.keyword, "var"),
        override: new P("override", N.keyword, "override"),
        workgroup: new P("workgroup", N.keyword, "workgroup"),
        write: new P("write", N.keyword, "write"),
        r8unorm: new P("r8unorm", N.keyword, "r8unorm"),
        r8snorm: new P("r8snorm", N.keyword, "r8snorm"),
        r8uint: new P("r8uint", N.keyword, "r8uint"),
        r8sint: new P("r8sint", N.keyword, "r8sint"),
        r16uint: new P("r16uint", N.keyword, "r16uint"),
        r16sint: new P("r16sint", N.keyword, "r16sint"),
        r16float: new P("r16float", N.keyword, "r16float"),
        rg8unorm: new P("rg8unorm", N.keyword, "rg8unorm"),
        rg8snorm: new P("rg8snorm", N.keyword, "rg8snorm"),
        rg8uint: new P("rg8uint", N.keyword, "rg8uint"),
        rg8sint: new P("rg8sint", N.keyword, "rg8sint"),
        r32uint: new P("r32uint", N.keyword, "r32uint"),
        r32sint: new P("r32sint", N.keyword, "r32sint"),
        r32float: new P("r32float", N.keyword, "r32float"),
        rg16uint: new P("rg16uint", N.keyword, "rg16uint"),
        rg16sint: new P("rg16sint", N.keyword, "rg16sint"),
        rg16float: new P("rg16float", N.keyword, "rg16float"),
        rgba8unorm: new P("rgba8unorm", N.keyword, "rgba8unorm"),
        rgba8unorm_srgb: new P("rgba8unorm_srgb", N.keyword, "rgba8unorm_srgb"),
        rgba8snorm: new P("rgba8snorm", N.keyword, "rgba8snorm"),
        rgba8uint: new P("rgba8uint", N.keyword, "rgba8uint"),
        rgba8sint: new P("rgba8sint", N.keyword, "rgba8sint"),
        bgra8unorm: new P("bgra8unorm", N.keyword, "bgra8unorm"),
        bgra8unorm_srgb: new P("bgra8unorm_srgb", N.keyword, "bgra8unorm_srgb"),
        rgb10a2unorm: new P("rgb10a2unorm", N.keyword, "rgb10a2unorm"),
        rg11b10float: new P("rg11b10float", N.keyword, "rg11b10float"),
        rg32uint: new P("rg32uint", N.keyword, "rg32uint"),
        rg32sint: new P("rg32sint", N.keyword, "rg32sint"),
        rg32float: new P("rg32float", N.keyword, "rg32float"),
        rgba16uint: new P("rgba16uint", N.keyword, "rgba16uint"),
        rgba16sint: new P("rgba16sint", N.keyword, "rgba16sint"),
        rgba16float: new P("rgba16float", N.keyword, "rgba16float"),
        rgba32uint: new P("rgba32uint", N.keyword, "rgba32uint"),
        rgba32sint: new P("rgba32sint", N.keyword, "rgba32sint"),
        rgba32float: new P("rgba32float", N.keyword, "rgba32float"),
        static_assert: new P("static_assert", N.keyword, "static_assert")
    }, x.tokens = {
        decimal_float_literal: new P("decimal_float_literal", N.token, /((-?[0-9]*\.[0-9]+|-?[0-9]+\.[0-9]*)((e|E)(\+|-)?[0-9]+)?[fh]?)|(-?[0-9]+(e|E)(\+|-)?[0-9]+[fh]?)|(-?[0-9]+[fh])/),
        hex_float_literal: new P("hex_float_literal", N.token, /-?0x((([0-9a-fA-F]*\.[0-9a-fA-F]+|[0-9a-fA-F]+\.[0-9a-fA-F]*)((p|P)(\+|-)?[0-9]+[fh]?)?)|([0-9a-fA-F]+(p|P)(\+|-)?[0-9]+[fh]?))/),
        int_literal: new P("int_literal", N.token, /-?0x[0-9a-fA-F]+|0i?|-?[1-9][0-9]*i?/),
        uint_literal: new P("uint_literal", N.token, /0x[0-9a-fA-F]+u|0u|[1-9][0-9]*u/),
        name: new P("name", N.token, /([_\p{XID_Start}][\p{XID_Continue}]+)|([\p{XID_Start}])/u),
        ident: new P("ident", N.token, /[_a-zA-Z][0-9a-zA-Z_]*/),
        and: new P("and", N.token, "&"),
        and_and: new P("and_and", N.token, "&&"),
        arrow: new P("arrow ", N.token, "->"),
        attr: new P("attr", N.token, "@"),
        forward_slash: new P("forward_slash", N.token, "/"),
        bang: new P("bang", N.token, "!"),
        bracket_left: new P("bracket_left", N.token, "["),
        bracket_right: new P("bracket_right", N.token, "]"),
        brace_left: new P("brace_left", N.token, "{"),
        brace_right: new P("brace_right", N.token, "}"),
        colon: new P("colon", N.token, ":"),
        comma: new P("comma", N.token, ","),
        equal: new P("equal", N.token, "="),
        equal_equal: new P("equal_equal", N.token, "=="),
        not_equal: new P("not_equal", N.token, "!="),
        greater_than: new P("greater_than", N.token, ">"),
        greater_than_equal: new P("greater_than_equal", N.token, ">="),
        shift_right: new P("shift_right", N.token, ">>"),
        less_than: new P("less_than", N.token, "<"),
        less_than_equal: new P("less_than_equal", N.token, "<="),
        shift_left: new P("shift_left", N.token, "<<"),
        modulo: new P("modulo", N.token, "%"),
        minus: new P("minus", N.token, "-"),
        minus_minus: new P("minus_minus", N.token, "--"),
        period: new P("period", N.token, "."),
        plus: new P("plus", N.token, "+"),
        plus_plus: new P("plus_plus", N.token, "++"),
        or: new P("or", N.token, "|"),
        or_or: new P("or_or", N.token, "||"),
        paren_left: new P("paren_left", N.token, "("),
        paren_right: new P("paren_right", N.token, ")"),
        semicolon: new P("semicolon", N.token, ";"),
        star: new P("star", N.token, "*"),
        tilde: new P("tilde", N.token, "~"),
        underscore: new P("underscore", N.token, "_"),
        xor: new P("xor", N.token, "^"),
        plus_equal: new P("plus_equal", N.token, "+="),
        minus_equal: new P("minus_equal", N.token, "-="),
        times_equal: new P("times_equal", N.token, "*="),
        division_equal: new P("division_equal", N.token, "/="),
        modulo_equal: new P("modulo_equal", N.token, "%="),
        and_equal: new P("and_equal", N.token, "&="),
        or_equal: new P("or_equal", N.token, "|="),
        xor_equal: new P("xor_equal", N.token, "^="),
        shift_right_equal: new P("shift_right_equal", N.token, ">>="),
        shift_left_equal: new P("shift_left_equal", N.token, "<<=")
    }, x.simpleTokens = {
        "@": F.tokens.attr,
        "{": F.tokens.brace_left,
        "}": F.tokens.brace_right,
        ":": F.tokens.colon,
        ",": F.tokens.comma,
        "(": F.tokens.paren_left,
        ")": F.tokens.paren_right,
        ";": F.tokens.semicolon
    }, x.literalTokens = {
        "&": F.tokens.and,
        "&&": F.tokens.and_and,
        "->": F.tokens.arrow,
        "/": F.tokens.forward_slash,
        "!": F.tokens.bang,
        "[": F.tokens.bracket_left,
        "]": F.tokens.bracket_right,
        "=": F.tokens.equal,
        "==": F.tokens.equal_equal,
        "!=": F.tokens.not_equal,
        ">": F.tokens.greater_than,
        ">=": F.tokens.greater_than_equal,
        ">>": F.tokens.shift_right,
        "<": F.tokens.less_than,
        "<=": F.tokens.less_than_equal,
        "<<": F.tokens.shift_left,
        "%": F.tokens.modulo,
        "-": F.tokens.minus,
        "--": F.tokens.minus_minus,
        ".": F.tokens.period,
        "+": F.tokens.plus,
        "++": F.tokens.plus_plus,
        "|": F.tokens.or,
        "||": F.tokens.or_or,
        "*": F.tokens.star,
        "~": F.tokens.tilde,
        _: F.tokens.underscore,
        "^": F.tokens.xor,
        "+=": F.tokens.plus_equal,
        "-=": F.tokens.minus_equal,
        "*=": F.tokens.times_equal,
        "/=": F.tokens.division_equal,
        "%=": F.tokens.modulo_equal,
        "&=": F.tokens.and_equal,
        "|=": F.tokens.or_equal,
        "^=": F.tokens.xor_equal,
        ">>=": F.tokens.shift_right_equal,
        "<<=": F.tokens.shift_left_equal
    }, x.regexTokens = {
        decimal_float_literal: F.tokens.decimal_float_literal,
        hex_float_literal: F.tokens.hex_float_literal,
        int_literal: F.tokens.int_literal,
        uint_literal: F.tokens.uint_literal,
        ident: F.tokens.ident
    }, x.storage_class = [
        F.keywords.function,
        F.keywords.private,
        F.keywords.workgroup,
        F.keywords.uniform,
        F.keywords.storage
    ], x.access_mode = [
        F.keywords.read,
        F.keywords.write,
        F.keywords.read_write
    ], x.sampler_type = [
        F.keywords.sampler,
        F.keywords.sampler_comparison
    ], x.sampled_texture_type = [
        F.keywords.texture_1d,
        F.keywords.texture_2d,
        F.keywords.texture_2d_array,
        F.keywords.texture_3d,
        F.keywords.texture_cube,
        F.keywords.texture_cube_array
    ], x.multisampled_texture_type = [
        F.keywords.texture_multisampled_2d
    ], x.storage_texture_type = [
        F.keywords.texture_storage_1d,
        F.keywords.texture_storage_2d,
        F.keywords.texture_storage_2d_array,
        F.keywords.texture_storage_3d
    ], x.depth_texture_type = [
        F.keywords.texture_depth_2d,
        F.keywords.texture_depth_2d_array,
        F.keywords.texture_depth_cube,
        F.keywords.texture_depth_cube_array,
        F.keywords.texture_depth_multisampled_2d
    ], x.texture_external_type = [
        F.keywords.texture_external
    ], x.any_texture_type = [
        ...F.sampled_texture_type,
        ...F.multisampled_texture_type,
        ...F.storage_texture_type,
        ...F.depth_texture_type,
        ...F.texture_external_type
    ], x.texel_format = [
        F.keywords.r8unorm,
        F.keywords.r8snorm,
        F.keywords.r8uint,
        F.keywords.r8sint,
        F.keywords.r16uint,
        F.keywords.r16sint,
        F.keywords.r16float,
        F.keywords.rg8unorm,
        F.keywords.rg8snorm,
        F.keywords.rg8uint,
        F.keywords.rg8sint,
        F.keywords.r32uint,
        F.keywords.r32sint,
        F.keywords.r32float,
        F.keywords.rg16uint,
        F.keywords.rg16sint,
        F.keywords.rg16float,
        F.keywords.rgba8unorm,
        F.keywords.rgba8unorm_srgb,
        F.keywords.rgba8snorm,
        F.keywords.rgba8uint,
        F.keywords.rgba8sint,
        F.keywords.bgra8unorm,
        F.keywords.bgra8unorm_srgb,
        F.keywords.rgb10a2unorm,
        F.keywords.rg11b10float,
        F.keywords.rg32uint,
        F.keywords.rg32sint,
        F.keywords.rg32float,
        F.keywords.rgba16uint,
        F.keywords.rgba16sint,
        F.keywords.rgba16float,
        F.keywords.rgba32uint,
        F.keywords.rgba32sint,
        F.keywords.rgba32float
    ], x.const_literal = [
        F.tokens.int_literal,
        F.tokens.uint_literal,
        F.tokens.decimal_float_literal,
        F.tokens.hex_float_literal,
        F.keywords.true,
        F.keywords.false
    ], x.literal_or_ident = [
        F.tokens.ident,
        F.tokens.int_literal,
        F.tokens.uint_literal,
        F.tokens.decimal_float_literal,
        F.tokens.hex_float_literal,
        F.tokens.name
    ], x.element_count_expression = [
        F.tokens.int_literal,
        F.tokens.uint_literal,
        F.tokens.ident
    ], x.template_types = [
        F.keywords.vec2,
        F.keywords.vec3,
        F.keywords.vec4,
        F.keywords.mat2x2,
        F.keywords.mat2x3,
        F.keywords.mat2x4,
        F.keywords.mat3x2,
        F.keywords.mat3x3,
        F.keywords.mat3x4,
        F.keywords.mat4x2,
        F.keywords.mat4x3,
        F.keywords.mat4x4,
        F.keywords.atomic,
        F.keywords.bitcast,
        ...F.any_texture_type
    ], x.attribute_name = [
        F.tokens.ident,
        F.keywords.block,
        F.keywords.diagnostic
    ], x.assignment_operators = [
        F.tokens.equal,
        F.tokens.plus_equal,
        F.tokens.minus_equal,
        F.tokens.times_equal,
        F.tokens.division_equal,
        F.tokens.modulo_equal,
        F.tokens.and_equal,
        F.tokens.or_equal,
        F.tokens.xor_equal,
        F.tokens.shift_right_equal,
        F.tokens.shift_left_equal
    ], x.increment_operators = [
        F.tokens.plus_plus,
        F.tokens.minus_minus
    ];
    class Qb {
        constructor(e, t, i, r, a){
            this.type = e, this.lexeme = t, this.line = i, this.start = r, this.end = a;
        }
        toString() {
            return this.lexeme;
        }
        isTemplateType() {
            return x.template_types.indexOf(this.type) != -1;
        }
        isArrayType() {
            return this.type == x.keywords.array;
        }
        isArrayOrTemplateType() {
            return this.isArrayType() || this.isTemplateType();
        }
    }
    class aC {
        constructor(e){
            this._tokens = [], this._start = 0, this._current = 0, this._line = 1, this._source = e ?? "";
        }
        scanTokens() {
            for(; !this._isAtEnd();)if (this._start = this._current, !this.scanToken()) throw `Invalid syntax at line ${this._line}`;
            return this._tokens.push(new Qb(x.eof, "", this._line, this._current, this._current)), this._tokens;
        }
        scanToken() {
            let e = this._advance();
            if (e == `
`) return this._line++, !0;
            if (this._isWhitespace(e)) return !0;
            if (e == "/") {
                if (this._peekAhead() == "/") {
                    for(; e != `
`;){
                        if (this._isAtEnd()) return !0;
                        e = this._advance();
                    }
                    return this._line++, !0;
                }
                if (this._peekAhead() == "*") {
                    this._advance();
                    let l = 1;
                    for(; l > 0;){
                        if (this._isAtEnd()) return !0;
                        if (e = this._advance(), e == `
`) this._line++;
                        else if (e == "*") {
                            if (this._peekAhead() == "/" && (this._advance(), l--, l == 0)) return !0;
                        } else e == "/" && this._peekAhead() == "*" && (this._advance(), l++);
                    }
                    return !0;
                }
            }
            const t = x.simpleTokens[e];
            if (t) return this._addToken(t), !0;
            let i = x.none;
            const r = this._isAlpha(e), a = e === "_";
            if (this._isAlphaNumeric(e)) {
                let l = this._peekAhead();
                for(; this._isAlphaNumeric(l);)e += this._advance(), l = this._peekAhead();
            }
            if (r) {
                const l = x.keywords[e];
                if (l) return this._addToken(l), !0;
            }
            if (r || a) return this._addToken(x.tokens.ident), !0;
            for(;;){
                let l = this._findType(e);
                const u = this._peekAhead();
                if (e == "-" && this._tokens.length > 0) {
                    if (u == "=") return this._current++, e += u, this._addToken(x.tokens.minus_equal), !0;
                    if (u == "-") return this._current++, e += u, this._addToken(x.tokens.minus_minus), !0;
                    const h = this._tokens.length - 1;
                    if ((x.literal_or_ident.indexOf(this._tokens[h].type) != -1 || this._tokens[h].type == x.tokens.paren_right) && u != ">") return this._addToken(l), !0;
                }
                if (e == ">" && (u == ">" || u == "=")) {
                    let h = !1, d = this._tokens.length - 1;
                    for(let p = 0; p < 5 && d >= 0 && x.assignment_operators.indexOf(this._tokens[d].type) === -1; ++p, --d)if (this._tokens[d].type === x.tokens.less_than) {
                        d > 0 && this._tokens[d - 1].isArrayOrTemplateType() && (h = !0);
                        break;
                    }
                    if (h) return this._addToken(l), !0;
                }
                if (l === x.none) {
                    let h = e, d = 0;
                    const p = 2;
                    for(let _ = 0; _ < p; ++_)if (h += this._peekAhead(_), l = this._findType(h), l !== x.none) {
                        d = _;
                        break;
                    }
                    if (l === x.none) return i !== x.none && (this._current--, this._addToken(i), !0);
                    e = h, this._current += d + 1;
                }
                if (i = l, this._isAtEnd()) break;
                e += this._advance();
            }
            return i !== x.none && (this._addToken(i), !0);
        }
        _findType(e) {
            for(const i in x.regexTokens){
                const r = x.regexTokens[i];
                if (this._match(e, r.rule)) return r;
            }
            return x.literalTokens[e] || x.none;
        }
        _match(e, t) {
            const i = t.exec(e);
            return i && i.index == 0 && i[0] == e;
        }
        _isAtEnd() {
            return this._current >= this._source.length;
        }
        _isAlpha(e) {
            return !this._isNumeric(e) && !this._isWhitespace(e) && e !== "_" && e !== "." && e !== "(" && e !== ")" && e !== "[" && e !== "]" && e !== "{" && e !== "}" && e !== "," && e !== ";" && e !== ":" && e !== "=" && e !== "!" && e !== "<" && e !== ">" && e !== "+" && e !== "-" && e !== "*" && e !== "/" && e !== "%" && e !== "&" && e !== "|" && e !== "^" && e !== "~" && e !== "@" && e !== "#" && e !== "?" && e !== "'" && e !== "`" && e !== '"' && e !== "\\" && e !== `
` && e !== "\r" && e !== "	" && e !== "\0";
        }
        _isNumeric(e) {
            return e >= "0" && e <= "9";
        }
        _isAlphaNumeric(e) {
            return this._isAlpha(e) || this._isNumeric(e) || e === "_";
        }
        _isWhitespace(e) {
            return e == " " || e == "	" || e == "\r";
        }
        _advance(e = 0) {
            let t = this._source[this._current];
            return e = e || 0, e++, this._current += e, t;
        }
        _peekAhead(e = 0) {
            return e = e || 0, this._current + e >= this._source.length ? "\0" : this._source[this._current + e];
        }
        _addToken(e) {
            const t = this._source.substring(this._start, this._current);
            this._tokens.push(new Qb(e, t, this._line, this._start, this._current));
        }
    }
    function ie(n) {
        return Array.isArray(n) || n?.buffer instanceof ArrayBuffer;
    }
    const Mc = new Float32Array(1), oC = new Uint32Array(Mc.buffer), lC = new Uint32Array(Mc.buffer), Oc = new Int32Array(1), cC = new Float32Array(Oc.buffer), uC = new Uint32Array(Oc.buffer), Ic = new Uint32Array(1), fC = new Float32Array(Ic.buffer), hC = new Int32Array(Ic.buffer);
    function Gb(n, e, t) {
        if (e === t) return n;
        if (e === "f32") {
            if (t === "i32" || t === "x32") return Mc[0] = n, oC[0];
            if (t === "u32") return Mc[0] = n, lC[0];
        } else if (e === "i32" || e === "x32") {
            if (t === "f32") return Oc[0] = n, cC[0];
            if (t === "u32") return Oc[0] = n, uC[0];
        } else if (e === "u32") {
            if (t === "f32") return Ic[0] = n, fC[0];
            if (t === "i32" || t === "x32") return Ic[0] = n, hC[0];
        }
        return console.error(`Unsupported cast from ${e} to ${t}`), n;
    }
    class dC {
        constructor(e){
            this.resources = null, this.inUse = !1, this.info = null, this.node = e;
        }
    }
    class tc {
        constructor(e, t){
            this.align = e, this.size = t;
        }
    }
    class Vn {
        constructor(){
            this.uniforms = [], this.storage = [], this.textures = [], this.samplers = [], this.aliases = [], this.overrides = [], this.structs = [], this.entry = new ZR, this.functions = [], this._types = new Map, this._functions = new Map;
        }
        _isStorageTexture(e) {
            return e.name == "texture_storage_1d" || e.name == "texture_storage_2d" || e.name == "texture_storage_2d_array" || e.name == "texture_storage_3d";
        }
        updateAST(e) {
            for (const t of e)t instanceof To && this._functions.set(t.name, new dC(t));
            for (const t of e)if (t instanceof ci) {
                const i = this.getTypeInfo(t, null);
                i instanceof $i && this.structs.push(i);
            }
            for (const t of e)if (t instanceof xg) this.aliases.push(this._getAliasInfo(t));
            else if (t instanceof vg) {
                const i = t, r = this._getAttributeNum(i.attributes, "id", 0), a = i.type != null ? this.getTypeInfo(i.type, i.attributes) : null;
                this.overrides.push(new YR(i.name, a, i.attributes, r));
            } else if (this._isUniformVar(t)) {
                const i = t, r = this._getAttributeNum(i.attributes, "group", 0), a = this._getAttributeNum(i.attributes, "binding", 0), l = this.getTypeInfo(i.type, i.attributes), u = new ec(i.name, l, r, a, i.attributes, ji.Uniform, i.access);
                u.access || (u.access = "read"), this.uniforms.push(u);
            } else if (this._isStorageVar(t)) {
                const i = t, r = this._getAttributeNum(i.attributes, "group", 0), a = this._getAttributeNum(i.attributes, "binding", 0), l = this.getTypeInfo(i.type, i.attributes), u = this._isStorageTexture(l), h = new ec(i.name, l, r, a, i.attributes, u ? ji.StorageTexture : ji.Storage, i.access);
                h.access || (h.access = "read"), this.storage.push(h);
            } else if (this._isTextureVar(t)) {
                const i = t, r = this._getAttributeNum(i.attributes, "group", 0), a = this._getAttributeNum(i.attributes, "binding", 0), l = this.getTypeInfo(i.type, i.attributes), u = this._isStorageTexture(l), h = new ec(i.name, l, r, a, i.attributes, u ? ji.StorageTexture : ji.Texture, i.access);
                h.access || (h.access = "read"), u ? this.storage.push(h) : this.textures.push(h);
            } else if (this._isSamplerVar(t)) {
                const i = t, r = this._getAttributeNum(i.attributes, "group", 0), a = this._getAttributeNum(i.attributes, "binding", 0), l = this.getTypeInfo(i.type, i.attributes), u = new ec(i.name, l, r, a, i.attributes, ji.Sampler, i.access);
                this.samplers.push(u);
            } else if (t instanceof To) {
                const i = this._getAttribute(t, "vertex"), r = this._getAttribute(t, "fragment"), a = this._getAttribute(t, "compute"), l = i || r || a, u = new KR(t.name, l?.name, t.attributes);
                u.attributes = t.attributes, u.startLine = t.startLine, u.endLine = t.endLine, this.functions.push(u), this._functions.get(t.name).info = u, l && (this._functions.get(t.name).inUse = !0, u.inUse = !0, u.resources = this._findResources(t, !!l), u.inputs = this._getInputs(t.args), u.outputs = this._getOutputs(t.returnType), this.entry[l.name].push(u)), u.arguments = t.args.map((h)=>new qR(h.name, this.getTypeInfo(h.type, h.attributes), h.attributes)), u.returnType = t.returnType ? this.getTypeInfo(t.returnType, t.attributes) : null;
            }
            for (const t of this._functions.values())t.info && (t.info.inUse = t.inUse, this._addCalls(t.node, t.info.calls));
            for (const t of this._functions.values())t.node.search((i)=>{
                var r, a, l;
                if (i instanceof sT) {
                    if (i.value) if (ie(i.value)) for (const u of i.value)for (const h of this.overrides)u === h.name && ((r = t.info) === null || r === void 0 || r.overrides.push(h));
                    else for (const u of this.overrides)i.value === u.name && ((a = t.info) === null || a === void 0 || a.overrides.push(u));
                } else if (i instanceof sn) for (const u of this.overrides)i.name === u.name && ((l = t.info) === null || l === void 0 || l.overrides.push(u));
            });
            for (const t of this.uniforms)this._markStructsInUse(t.type);
            for (const t of this.storage)this._markStructsInUse(t.type);
        }
        getStructInfo(e) {
            for (const t of this.structs)if (t.name == e) return t;
            return null;
        }
        getOverrideInfo(e) {
            for (const t of this.overrides)if (t.name == e) return t;
            return null;
        }
        _markStructsInUse(e) {
            if (e) if (e.isStruct) {
                if (e.inUse = !0, e.members) for (const t of e.members)this._markStructsInUse(t.type);
            } else if (e.isArray) this._markStructsInUse(e.format);
            else if (e.isTemplate) e.format && this._markStructsInUse(e.format);
            else {
                const t = this._getAlias(e.name);
                t && this._markStructsInUse(t);
            }
        }
        _addCalls(e, t) {
            var i;
            for (const r of e.calls){
                const a = (i = this._functions.get(r.name)) === null || i === void 0 ? void 0 : i.info;
                a && t.add(a);
            }
        }
        findResource(e, t, i) {
            if (i) {
                for (const r of this.entry.compute)if (r.name === i) {
                    for (const a of r.resources)if (a.group == e && a.binding == t) return a;
                }
                for (const r of this.entry.vertex)if (r.name === i) {
                    for (const a of r.resources)if (a.group == e && a.binding == t) return a;
                }
                for (const r of this.entry.fragment)if (r.name === i) {
                    for (const a of r.resources)if (a.group == e && a.binding == t) return a;
                }
            }
            for (const r of this.uniforms)if (r.group == e && r.binding == t) return r;
            for (const r of this.storage)if (r.group == e && r.binding == t) return r;
            for (const r of this.textures)if (r.group == e && r.binding == t) return r;
            for (const r of this.samplers)if (r.group == e && r.binding == t) return r;
            return null;
        }
        _findResource(e) {
            for (const t of this.uniforms)if (t.name == e) return t;
            for (const t of this.storage)if (t.name == e) return t;
            for (const t of this.textures)if (t.name == e) return t;
            for (const t of this.samplers)if (t.name == e) return t;
            return null;
        }
        _markStructsFromAST(e) {
            const t = this.getTypeInfo(e, null);
            this._markStructsInUse(t);
        }
        _findResources(e, t) {
            const i = [], r = this, a = [];
            return e.search((l)=>{
                if (l instanceof Rc) a.push({});
                else if (l instanceof Cc) a.pop();
                else if (l instanceof fi) {
                    const u = l;
                    t && u.type !== null && this._markStructsFromAST(u.type), a.length > 0 && (a[a.length - 1][u.name] = u);
                } else if (l instanceof Ln) {
                    const u = l;
                    t && u.type !== null && this._markStructsFromAST(u.type);
                } else if (l instanceof go) {
                    const u = l;
                    t && u.type !== null && this._markStructsFromAST(u.type), a.length > 0 && (a[a.length - 1][u.name] = u);
                } else if (l instanceof sn) {
                    const u = l;
                    if (a.length > 0 && a[a.length - 1][u.name]) return;
                    const h = r._findResource(u.name);
                    h && i.push(h);
                } else if (l instanceof Sg) {
                    const u = l, h = r._functions.get(u.name);
                    h && (t && (h.inUse = !0), e.calls.add(h.node), h.resources === null && (h.resources = r._findResources(h.node, t)), i.push(...h.resources));
                } else if (l instanceof Tg) {
                    const u = l, h = r._functions.get(u.name);
                    h && (t && (h.inUse = !0), e.calls.add(h.node), h.resources === null && (h.resources = r._findResources(h.node, t)), i.push(...h.resources));
                }
            }), [
                ...new Map(i.map((l)=>[
                        l.name,
                        l
                    ])).values()
            ];
        }
        getBindGroups() {
            const e = [];
            function t(i, r) {
                i >= e.length && (e.length = i + 1), e[i] === void 0 && (e[i] = []), r >= e[i].length && (e[i].length = r + 1);
            }
            for (const i of this.uniforms)t(i.group, i.binding), e[i.group][i.binding] = i;
            for (const i of this.storage)t(i.group, i.binding), e[i.group][i.binding] = i;
            for (const i of this.textures)t(i.group, i.binding), e[i.group][i.binding] = i;
            for (const i of this.samplers)t(i.group, i.binding), e[i.group][i.binding] = i;
            return e;
        }
        _getOutputs(e, t = void 0) {
            if (t === void 0 && (t = []), e instanceof ci) this._getStructOutputs(e, t);
            else {
                const i = this._getOutputInfo(e);
                i !== null && t.push(i);
            }
            return t;
        }
        _getStructOutputs(e, t) {
            for (const i of e.members)if (i.type instanceof ci) this._getStructOutputs(i.type, t);
            else {
                const r = this._getAttribute(i, "location") || this._getAttribute(i, "builtin");
                if (r !== null) {
                    const a = this.getTypeInfo(i.type, i.type.attributes), l = this._parseInt(r.value), u = new Xb(i.name, a, r.name, l);
                    t.push(u);
                }
            }
        }
        _getOutputInfo(e) {
            const t = this._getAttribute(e, "location") || this._getAttribute(e, "builtin");
            if (t !== null) {
                const i = this.getTypeInfo(e, e.attributes), r = this._parseInt(t.value);
                return new Xb("", i, t.name, r);
            }
            return null;
        }
        _getInputs(e, t = void 0) {
            t === void 0 && (t = []);
            for (const i of e)if (i.type instanceof ci) this._getStructInputs(i.type, t);
            else {
                const r = this._getInputInfo(i);
                r !== null && t.push(r);
            }
            return t;
        }
        _getStructInputs(e, t) {
            for (const i of e.members)if (i.type instanceof ci) this._getStructInputs(i.type, t);
            else {
                const r = this._getInputInfo(i);
                r !== null && t.push(r);
            }
        }
        _getInputInfo(e) {
            const t = this._getAttribute(e, "location") || this._getAttribute(e, "builtin");
            if (t !== null) {
                const i = this._getAttribute(e, "interpolation"), r = this.getTypeInfo(e.type, e.attributes), a = this._parseInt(t.value), l = new XR(e.name, r, t.name, a);
                return i !== null && (l.interpolation = this._parseString(i.value)), l;
            }
            return null;
        }
        _parseString(e) {
            return e instanceof Array && (e = e[0]), e;
        }
        _parseInt(e) {
            e instanceof Array && (e = e[0]);
            const t = parseInt(e);
            return isNaN(t) ? e : t;
        }
        _getAlias(e) {
            for (const t of this.aliases)if (t.name == e) return t.type;
            return null;
        }
        _getAliasInfo(e) {
            return new $R(e.name, this.getTypeInfo(e.type, null));
        }
        getTypeInfoByName(e) {
            for (const t of this.structs)if (t.name == e) return t;
            for (const t of this.aliases)if (t.name == e) return t.type;
            return null;
        }
        getTypeInfo(e, t = null) {
            if (this._types.has(e)) return this._types.get(e);
            if (e instanceof po) {
                const r = e, a = r.format ? this.getTypeInfo(r.format, r.attributes) : null, l = new Ki(r.name, t);
                return l.format = a, l.count = r.count, this._types.set(e, l), this._updateTypeInfo(l), l;
            }
            if (e instanceof ci) {
                const r = e, a = new $i(r.name, t);
                a.startLine = r.startLine, a.endLine = r.endLine;
                for (const l of r.members){
                    const u = this.getTypeInfo(l.type, l.attributes);
                    a.members.push(new $b(l.name, u, l.attributes));
                }
                return this._types.set(e, a), this._updateTypeInfo(a), a;
            }
            if (e instanceof oo) {
                const r = e, a = r.format instanceof q, l = r.format ? a ? this.getTypeInfo(r.format, null) : new _n(r.format, null) : null, u = new Mr(r.name, l, t, r.access);
                return this._types.set(e, u), this._updateTypeInfo(u), u;
            }
            if (e instanceof k) {
                const r = e, a = r.format ? this.getTypeInfo(r.format, null) : null, l = new Mr(r.name, a, t, r.access);
                return this._types.set(e, l), this._updateTypeInfo(l), l;
            }
            const i = new _n(e.name, t);
            return this._types.set(e, i), this._updateTypeInfo(i), i;
        }
        _updateTypeInfo(e) {
            var t, i, r;
            const a = this._getTypeSize(e);
            if (e.size = (t = a?.size) !== null && t !== void 0 ? t : 0, e instanceof Ki && e.format) {
                const l = this._getTypeSize(e.format);
                e.stride = Math.max((i = l?.size) !== null && i !== void 0 ? i : 0, (r = l?.align) !== null && r !== void 0 ? r : 0), this._updateTypeInfo(e.format);
            }
            e instanceof $i && this._updateStructInfo(e);
        }
        _updateStructInfo(e) {
            var t;
            let i = 0, r = 0, a = 0, l = 0;
            for(let u = 0, h = e.members.length; u < h; ++u){
                const d = e.members[u], p = this._getTypeSize(d);
                if (!p) continue;
                (t = this._getAlias(d.type.name)) !== null && t !== void 0 || d.type;
                const _ = p.align, y = p.size;
                i = this._roundUp(_, i + r), r = y, a = i, l = Math.max(l, _), d.offset = i, d.size = y, this._updateTypeInfo(d.type);
            }
            e.size = this._roundUp(l, a + r), e.align = l;
        }
        _getTypeSize(e) {
            var t, i;
            if (e == null) return null;
            const r = this._getAttributeNum(e.attributes, "size", 0), a = this._getAttributeNum(e.attributes, "align", 0);
            if (e instanceof $b && (e = e.type), e instanceof _n) {
                const l = this._getAlias(e.name);
                l !== null && (e = l);
            }
            {
                const l = Vn._typeInfo[e.name];
                if (l !== void 0) {
                    const u = ((t = e.format) === null || t === void 0 ? void 0 : t.name) === "f16" ? 2 : 1;
                    return new tc(Math.max(a, l.align / u), Math.max(r, l.size / u));
                }
            }
            {
                const l = Vn._typeInfo[e.name.substring(0, e.name.length - 1)];
                if (l) {
                    const u = e.name[e.name.length - 1] === "h" ? 2 : 1;
                    return new tc(Math.max(a, l.align / u), Math.max(r, l.size / u));
                }
            }
            if (e instanceof Ki) {
                let l = e, u = 8, h = 8;
                const d = this._getTypeSize(l.format);
                return d !== null && (h = d.size, u = d.align), h = l.count * this._getAttributeNum((i = e?.attributes) !== null && i !== void 0 ? i : null, "stride", this._roundUp(u, h)), r && (h = r), new tc(Math.max(a, u), Math.max(r, h));
            }
            if (e instanceof $i) {
                let l = 0, u = 0, h = 0, d = 0, p = 0;
                for (const _ of e.members){
                    const y = this._getTypeSize(_.type);
                    y !== null && (l = Math.max(y.align, l), h = this._roundUp(y.align, h + d), d = y.size, p = h);
                }
                return u = this._roundUp(l, p + d), new tc(Math.max(a, l), Math.max(r, u));
            }
            return null;
        }
        _isUniformVar(e) {
            return e instanceof fi && e.storage == "uniform";
        }
        _isStorageVar(e) {
            return e instanceof fi && e.storage == "storage";
        }
        _isTextureVar(e) {
            return e instanceof fi && e.type !== null && Vn._textureTypes.indexOf(e.type.name) != -1;
        }
        _isSamplerVar(e) {
            return e instanceof fi && e.type !== null && Vn._samplerTypes.indexOf(e.type.name) != -1;
        }
        _getAttribute(e, t) {
            const i = e;
            if (!i || !i.attributes) return null;
            const r = i.attributes;
            for (let a of r)if (a.name == t) return a;
            return null;
        }
        _getAttributeNum(e, t, i) {
            if (e === null) return i;
            for (let r of e)if (r.name == t) {
                let a = r !== null && r.value !== null ? r.value : i;
                return a instanceof Array && (a = a[0]), typeof a == "number" ? a : typeof a == "string" ? parseInt(a) : i;
            }
            return i;
        }
        _roundUp(e, t) {
            return Math.ceil(t / e) * e;
        }
    }
    Vn._typeInfo = {
        f16: {
            align: 2,
            size: 2
        },
        i32: {
            align: 4,
            size: 4
        },
        u32: {
            align: 4,
            size: 4
        },
        f32: {
            align: 4,
            size: 4
        },
        atomic: {
            align: 4,
            size: 4
        },
        vec2: {
            align: 8,
            size: 8
        },
        vec3: {
            align: 16,
            size: 12
        },
        vec4: {
            align: 16,
            size: 16
        },
        mat2x2: {
            align: 8,
            size: 16
        },
        mat3x2: {
            align: 8,
            size: 24
        },
        mat4x2: {
            align: 8,
            size: 32
        },
        mat2x3: {
            align: 16,
            size: 32
        },
        mat3x3: {
            align: 16,
            size: 48
        },
        mat4x3: {
            align: 16,
            size: 64
        },
        mat2x4: {
            align: 16,
            size: 32
        },
        mat3x4: {
            align: 16,
            size: 48
        },
        mat4x4: {
            align: 16,
            size: 64
        }
    }, Vn._textureTypes = x.any_texture_type.map((n)=>n.name), Vn._samplerTypes = x.sampler_type.map((n)=>n.name);
    class Ag {
        constructor(e, t, i){
            this.name = e, this.value = t, this.node = i;
        }
        clone() {
            return new Ag(this.name, this.value, this.node);
        }
    }
    class wg {
        constructor(e){
            this.name = e.name, this.node = e;
        }
        clone() {
            return new wg(this.node);
        }
    }
    class Eg {
        constructor(e){
            this.parent = null, this.variables = new Map, this.functions = new Map, this.currentFunctionName = "", e && (this.parent = e, this.currentFunctionName = e.currentFunctionName);
        }
        getVariable(e) {
            var t;
            return this.variables.has(e) ? (t = this.variables.get(e)) !== null && t !== void 0 ? t : null : this.parent ? this.parent.getVariable(e) : null;
        }
        getFunction(e) {
            var t;
            return this.functions.has(e) ? (t = this.functions.get(e)) !== null && t !== void 0 ? t : null : this.parent ? this.parent.getFunction(e) : null;
        }
        createVariable(e, t, i) {
            this.variables.set(e, new Ag(e, t, i ?? null));
        }
        setVariable(e, t, i) {
            const r = this.getVariable(e);
            r !== null ? r.value = t : this.createVariable(e, t, i);
        }
        getVariableValue(e) {
            var t;
            const i = this.getVariable(e);
            return (t = i?.value) !== null && t !== void 0 ? t : null;
        }
        clone() {
            return new Eg(this);
        }
    }
    class gC {
        evalExpression(e, t) {
            return null;
        }
        getTypeInfo(e) {
            return null;
        }
        getVariableName(e, t) {
            return "";
        }
    }
    class pC {
        constructor(e){
            this.exec = e;
        }
        getTypeInfo(e) {
            return this.exec.getTypeInfo(e);
        }
        All(e, t) {
            const i = this.exec.evalExpression(e.args[0], t);
            let r = !0;
            if (i instanceof A) return i.data.forEach((a)=>{
                a || (r = !1);
            }), new I(r ? 1 : 0, this.getTypeInfo("bool"));
            throw new Error(`All() expects a vector argument. Line ${e.line}`);
        }
        Any(e, t) {
            const i = this.exec.evalExpression(e.args[0], t);
            if (i instanceof A) {
                const r = i.data.some((a)=>a);
                return new I(r ? 1 : 0, this.getTypeInfo("bool"));
            }
            throw new Error(`Any() expects a vector argument. Line ${e.line}`);
        }
        Select(e, t) {
            const i = this.exec.evalExpression(e.args[2], t);
            if (!(i instanceof I)) throw new Error(`Select() expects a bool condition. Line ${e.line}`);
            return i.value ? this.exec.evalExpression(e.args[1], t) : this.exec.evalExpression(e.args[0], t);
        }
        ArrayLength(e, t) {
            let i = e.args[0];
            i instanceof ft && (i = i.right);
            const r = this.exec.evalExpression(i, t);
            if (r instanceof st && r.typeInfo.size === 0) {
                const a = r.typeInfo, l = r.buffer.byteLength / a.stride;
                return new I(l, this.getTypeInfo("u32"));
            }
            return new I(r.typeInfo.size, this.getTypeInfo("u32"));
        }
        Abs(e, t) {
            const i = this.exec.evalExpression(e.args[0], t);
            if (i instanceof A) return new A(i.data.map((a)=>Math.abs(a)), i.typeInfo);
            const r = i;
            return new I(Math.abs(r.value), r.typeInfo);
        }
        Acos(e, t) {
            const i = this.exec.evalExpression(e.args[0], t);
            if (i instanceof A) return new A(i.data.map((a)=>Math.acos(a)), i.typeInfo);
            const r = i;
            return new I(Math.acos(r.value), i.typeInfo);
        }
        Acosh(e, t) {
            const i = this.exec.evalExpression(e.args[0], t);
            if (i instanceof A) return new A(i.data.map((a)=>Math.acosh(a)), i.typeInfo);
            const r = i;
            return new I(Math.acosh(r.value), i.typeInfo);
        }
        Asin(e, t) {
            const i = this.exec.evalExpression(e.args[0], t);
            if (i instanceof A) return new A(i.data.map((a)=>Math.asin(a)), i.typeInfo);
            const r = i;
            return new I(Math.asin(r.value), i.typeInfo);
        }
        Asinh(e, t) {
            const i = this.exec.evalExpression(e.args[0], t);
            if (i instanceof A) return new A(i.data.map((a)=>Math.asinh(a)), i.typeInfo);
            const r = i;
            return new I(Math.asinh(r.value), i.typeInfo);
        }
        Atan(e, t) {
            const i = this.exec.evalExpression(e.args[0], t);
            if (i instanceof A) return new A(i.data.map((a)=>Math.atan(a)), i.typeInfo);
            const r = i;
            return new I(Math.atan(r.value), i.typeInfo);
        }
        Atanh(e, t) {
            const i = this.exec.evalExpression(e.args[0], t);
            if (i instanceof A) return new A(i.data.map((a)=>Math.atanh(a)), i.typeInfo);
            const r = i;
            return new I(Math.atanh(r.value), i.typeInfo);
        }
        Atan2(e, t) {
            const i = this.exec.evalExpression(e.args[0], t), r = this.exec.evalExpression(e.args[1], t);
            if (i instanceof A && r instanceof A) return new A(i.data.map((u, h)=>Math.atan2(u, r.data[h])), i.typeInfo);
            const a = i, l = r;
            return new I(Math.atan2(a.value, l.value), i.typeInfo);
        }
        Ceil(e, t) {
            const i = this.exec.evalExpression(e.args[0], t);
            if (i instanceof A) return new A(i.data.map((a)=>Math.ceil(a)), i.typeInfo);
            const r = i;
            return new I(Math.ceil(r.value), i.typeInfo);
        }
        _clamp(e, t, i) {
            return Math.min(Math.max(e, t), i);
        }
        Clamp(e, t) {
            const i = this.exec.evalExpression(e.args[0], t), r = this.exec.evalExpression(e.args[1], t), a = this.exec.evalExpression(e.args[2], t);
            if (i instanceof A && r instanceof A && a instanceof A) return new A(i.data.map((d, p)=>this._clamp(d, r.data[p], a.data[p])), i.typeInfo);
            const l = i, u = r, h = a;
            return new I(this._clamp(l.value, u.value, h.value), i.typeInfo);
        }
        Cos(e, t) {
            const i = this.exec.evalExpression(e.args[0], t);
            if (i instanceof A) return new A(i.data.map((a)=>Math.cos(a)), i.typeInfo);
            const r = i;
            return new I(Math.cos(r.value), i.typeInfo);
        }
        Cosh(e, t) {
            const i = this.exec.evalExpression(e.args[0], t);
            if (i instanceof A) return new A(i.data.map((a)=>Math.cosh(a)), i.typeInfo);
            const r = i;
            return new I(Math.cos(r.value), i.typeInfo);
        }
        CountLeadingZeros(e, t) {
            const i = this.exec.evalExpression(e.args[0], t);
            if (i instanceof A) return new A(i.data.map((a)=>Math.clz32(a)), i.typeInfo);
            const r = i;
            return new I(Math.clz32(r.value), i.typeInfo);
        }
        _countOneBits(e) {
            let t = 0;
            for(; e !== 0;)1 & e && t++, e >>= 1;
            return t;
        }
        CountOneBits(e, t) {
            const i = this.exec.evalExpression(e.args[0], t);
            if (i instanceof A) return new A(i.data.map((a)=>this._countOneBits(a)), i.typeInfo);
            const r = i;
            return new I(this._countOneBits(r.value), i.typeInfo);
        }
        _countTrailingZeros(e) {
            if (e === 0) return 32;
            let t = 0;
            for(; !(1 & e);)e >>= 1, t++;
            return t;
        }
        CountTrailingZeros(e, t) {
            const i = this.exec.evalExpression(e.args[0], t);
            if (i instanceof A) return new A(i.data.map((a)=>this._countTrailingZeros(a)), i.typeInfo);
            const r = i;
            return new I(this._countTrailingZeros(r.value), i.typeInfo);
        }
        Cross(e, t) {
            const i = this.exec.evalExpression(e.args[0], t), r = this.exec.evalExpression(e.args[1], t);
            if (i instanceof A && r instanceof A) {
                if (i.data.length !== 3 || r.data.length !== 3) return console.error(`Cross() expects 3D vectors. Line ${e.line}`), null;
                const a = i.data, l = r.data;
                return new A([
                    a[1] * l[2] - l[1] * a[2],
                    a[2] * l[0] - l[2] * a[0],
                    a[0] * l[1] - l[0] * a[1]
                ], i.typeInfo);
            }
            return console.error(`Cross() expects vector arguments. Line ${e.line}`), null;
        }
        Degrees(e, t) {
            const i = this.exec.evalExpression(e.args[0], t), r = 180 / Math.PI;
            return i instanceof A ? new A(i.data.map((a)=>a * r), i.typeInfo) : new I(i.value * r, this.getTypeInfo("f32"));
        }
        Determinant(e, t) {
            const i = this.exec.evalExpression(e.args[0], t);
            if (i instanceof me) {
                const r = i.data, a = i.typeInfo.getTypeName(), l = a.endsWith("h") ? this.getTypeInfo("f16") : this.getTypeInfo("f32");
                if (a === "mat2x2" || a === "mat2x2f" || a === "mat2x2h") return new I(r[0] * r[3] - r[1] * r[2], l);
                if (a === "mat2x3" || a === "mat2x3f" || a === "mat2x3h") return new I(r[0] * (r[4] * r[8] - r[5] * r[7]) - r[1] * (r[3] * r[8] - r[5] * r[6]) + r[2] * (r[3] * r[7] - r[4] * r[6]), l);
                if (a === "mat2x4" || a === "mat2x4f" || a === "mat2x4h") console.error(`TODO: Determinant for ${a}`);
                else if (a === "mat3x2" || a === "mat3x2f" || a === "mat3x2h") console.error(`TODO: Determinant for ${a}`);
                else {
                    if (a === "mat3x3" || a === "mat3x3f" || a === "mat3x3h") return new I(r[0] * (r[4] * r[8] - r[5] * r[7]) - r[1] * (r[3] * r[8] - r[5] * r[6]) + r[2] * (r[3] * r[7] - r[4] * r[6]), l);
                    a === "mat3x4" || a === "mat3x4f" || a === "mat3x4h" || a === "mat4x2" || a === "mat4x2f" || a === "mat4x2h" || a === "mat4x3" || a === "mat4x3f" || a === "mat4x3h" ? console.error(`TODO: Determinant for ${a}`) : a !== "mat4x4" && a !== "mat4x4f" && a !== "mat4x4h" || console.error(`TODO: Determinant for ${a}`);
                }
            }
            return console.error(`Determinant expects a matrix argument. Line ${e.line}`), null;
        }
        Distance(e, t) {
            const i = this.exec.evalExpression(e.args[0], t), r = this.exec.evalExpression(e.args[1], t);
            if (i instanceof A && r instanceof A) {
                let u = 0;
                for(let h = 0; h < i.data.length; ++h)u += (i.data[h] - r.data[h]) * (i.data[h] - r.data[h]);
                return new I(Math.sqrt(u), this.getTypeInfo("f32"));
            }
            const a = i, l = r;
            return new I(Math.abs(a.value - l.value), i.typeInfo);
        }
        _dot(e, t) {
            let i = 0;
            for(let r = 0; r < e.length; ++r)i += t[r] * e[r];
            return i;
        }
        Dot(e, t) {
            const i = this.exec.evalExpression(e.args[0], t), r = this.exec.evalExpression(e.args[1], t);
            return i instanceof A && r instanceof A ? new I(this._dot(i.data, r.data), this.getTypeInfo("f32")) : (console.error(`Dot() expects vector arguments. Line ${e.line}`), null);
        }
        Dot4U8Packed(e, t) {
            return console.error(`TODO: dot4U8Packed. Line ${e.line}`), null;
        }
        Dot4I8Packed(e, t) {
            return console.error(`TODO: dot4I8Packed. Line ${e.line}`), null;
        }
        Exp(e, t) {
            const i = this.exec.evalExpression(e.args[0], t);
            if (i instanceof A) return new A(i.data.map((a)=>Math.exp(a)), i.typeInfo);
            const r = i;
            return new I(Math.exp(r.value), i.typeInfo);
        }
        Exp2(e, t) {
            const i = this.exec.evalExpression(e.args[0], t);
            if (i instanceof A) return new A(i.data.map((a)=>Math.pow(2, a)), i.typeInfo);
            const r = i;
            return new I(Math.pow(2, r.value), i.typeInfo);
        }
        ExtractBits(e, t) {
            const i = this.exec.evalExpression(e.args[0], t), r = this.exec.evalExpression(e.args[1], t), a = this.exec.evalExpression(e.args[2], t);
            if (r.typeInfo.name !== "u32" && r.typeInfo.name !== "x32") return console.error(`ExtractBits() expects an i32 offset argument. Line ${e.line}`), null;
            if (a.typeInfo.name !== "u32" && a.typeInfo.name !== "x32") return console.error(`ExtractBits() expects an i32 count argument. Line ${e.line}`), null;
            const l = r.value, u = a.value;
            if (i instanceof A) return new A(i.data.map((d)=>d >> l & (1 << u) - 1), i.typeInfo);
            if (i.typeInfo.name !== "i32" && i.typeInfo.name !== "x32") return console.error(`ExtractBits() expects an i32 argument. Line ${e.line}`), null;
            const h = i.value;
            return new I(h >> l & (1 << u) - 1, this.getTypeInfo("i32"));
        }
        FaceForward(e, t) {
            const i = this.exec.evalExpression(e.args[0], t), r = this.exec.evalExpression(e.args[1], t), a = this.exec.evalExpression(e.args[2], t);
            if (i instanceof A && r instanceof A && a instanceof A) {
                const l = this._dot(r.data, a.data);
                return new A(l < 0 ? Array.from(i.data) : i.data.map((u)=>-u), i.typeInfo);
            }
            return console.error(`FaceForward() expects vector arguments. Line ${e.line}`), null;
        }
        _firstLeadingBit(e) {
            return e === 0 ? -1 : 31 - Math.clz32(e);
        }
        FirstLeadingBit(e, t) {
            const i = this.exec.evalExpression(e.args[0], t);
            if (i instanceof A) return new A(i.data.map((a)=>this._firstLeadingBit(a)), i.typeInfo);
            const r = i;
            return new I(this._firstLeadingBit(r.value), i.typeInfo);
        }
        _firstTrailingBit(e) {
            return e === 0 ? -1 : Math.log2(e & -e);
        }
        FirstTrailingBit(e, t) {
            const i = this.exec.evalExpression(e.args[0], t);
            if (i instanceof A) return new A(i.data.map((a)=>this._firstTrailingBit(a)), i.typeInfo);
            const r = i;
            return new I(this._firstTrailingBit(r.value), i.typeInfo);
        }
        Floor(e, t) {
            const i = this.exec.evalExpression(e.args[0], t);
            if (i instanceof A) return new A(i.data.map((a)=>Math.floor(a)), i.typeInfo);
            const r = i;
            return new I(Math.floor(r.value), i.typeInfo);
        }
        Fma(e, t) {
            const i = this.exec.evalExpression(e.args[0], t), r = this.exec.evalExpression(e.args[1], t), a = this.exec.evalExpression(e.args[2], t);
            if (i instanceof A && r instanceof A && a instanceof A) return i.data.length !== r.data.length || i.data.length !== a.data.length ? (console.error(`Fma() expects vectors of the same length. Line ${e.line}`), null) : new A(i.data.map((d, p)=>d * r.data[p] + a.data[p]), i.typeInfo);
            const l = i, u = r, h = a;
            return new I(l.value * u.value + h.value, l.typeInfo);
        }
        Fract(e, t) {
            const i = this.exec.evalExpression(e.args[0], t);
            if (i instanceof A) return new A(i.data.map((a)=>a - Math.floor(a)), i.typeInfo);
            const r = i;
            return new I(r.value - Math.floor(r.value), i.typeInfo);
        }
        Frexp(e, t) {
            return console.error(`TODO: frexp. Line ${e.line}`), null;
        }
        InsertBits(e, t) {
            const i = this.exec.evalExpression(e.args[0], t), r = this.exec.evalExpression(e.args[1], t), a = this.exec.evalExpression(e.args[2], t), l = this.exec.evalExpression(e.args[3], t);
            if (a.typeInfo.name !== "u32" && a.typeInfo.name !== "x32") return console.error(`InsertBits() expects an i32 offset argument. Line ${e.line}`), null;
            const u = a.value, h = (1 << l.value) - 1 << u, d = ~h;
            if (i instanceof A && r instanceof A) return new A(i.data.map((y, v)=>y & d | r.data[v] << u & h), i.typeInfo);
            const p = i.value, _ = r.value;
            return new I(p & d | _ << u & h, i.typeInfo);
        }
        InverseSqrt(e, t) {
            const i = this.exec.evalExpression(e.args[0], t);
            if (i instanceof A) return new A(i.data.map((a)=>1 / Math.sqrt(a)), i.typeInfo);
            const r = i;
            return new I(1 / Math.sqrt(r.value), i.typeInfo);
        }
        Ldexp(e, t) {
            return console.error(`TODO: ldexp. Line ${e.line}`), null;
        }
        Length(e, t) {
            const i = this.exec.evalExpression(e.args[0], t);
            if (i instanceof A) {
                let a = 0;
                return i.data.forEach((l)=>{
                    a += l * l;
                }), new I(Math.sqrt(a), this.getTypeInfo("f32"));
            }
            const r = i;
            return new I(Math.abs(r.value), i.typeInfo);
        }
        Log(e, t) {
            const i = this.exec.evalExpression(e.args[0], t);
            if (i instanceof A) return new A(i.data.map((a)=>Math.log(a)), i.typeInfo);
            const r = i;
            return new I(Math.log(r.value), i.typeInfo);
        }
        Log2(e, t) {
            const i = this.exec.evalExpression(e.args[0], t);
            if (i instanceof A) return new A(i.data.map((a)=>Math.log2(a)), i.typeInfo);
            const r = i;
            return new I(Math.log2(r.value), i.typeInfo);
        }
        Max(e, t) {
            const i = this.exec.evalExpression(e.args[0], t), r = this.exec.evalExpression(e.args[1], t);
            if (i instanceof A && r instanceof A) return new A(i.data.map((u, h)=>Math.max(u, r.data[h])), i.typeInfo);
            const a = i, l = r;
            return new I(Math.max(a.value, l.value), i.typeInfo);
        }
        Min(e, t) {
            const i = this.exec.evalExpression(e.args[0], t), r = this.exec.evalExpression(e.args[1], t);
            if (i instanceof A && r instanceof A) return new A(i.data.map((u, h)=>Math.min(u, r.data[h])), i.typeInfo);
            const a = i, l = r;
            return new I(Math.min(a.value, l.value), i.typeInfo);
        }
        Mix(e, t) {
            const i = this.exec.evalExpression(e.args[0], t), r = this.exec.evalExpression(e.args[1], t), a = this.exec.evalExpression(e.args[2], t);
            if (i instanceof A && r instanceof A && a instanceof A) return new A(i.data.map((h, d)=>i.data[d] * (1 - a.data[d]) + r.data[d] * a.data[d]), i.typeInfo);
            const l = r, u = a;
            return new I(i.value * (1 - u.value) + l.value * u.value, i.typeInfo);
        }
        Modf(e, t) {
            const i = this.exec.evalExpression(e.args[0], t), r = this.exec.evalExpression(e.args[1], t);
            if (i instanceof A && r instanceof A) return new A(i.data.map((l, u)=>l % r.data[u]), i.typeInfo);
            const a = r;
            return new I(i.value % a.value, i.typeInfo);
        }
        Normalize(e, t) {
            const i = this.exec.evalExpression(e.args[0], t);
            if (i instanceof A) {
                const r = this.Length(e, t).value;
                return new A(i.data.map((a)=>a / r), i.typeInfo);
            }
            return console.error(`Normalize() expects a vector argument. Line ${e.line}`), null;
        }
        Pow(e, t) {
            const i = this.exec.evalExpression(e.args[0], t), r = this.exec.evalExpression(e.args[1], t);
            if (i instanceof A && r instanceof A) return new A(i.data.map((u, h)=>Math.pow(u, r.data[h])), i.typeInfo);
            const a = i, l = r;
            return new I(Math.pow(a.value, l.value), i.typeInfo);
        }
        QuantizeToF16(e, t) {
            const i = this.exec.evalExpression(e.args[0], t);
            return i instanceof A ? new A(i.data.map((r)=>r), i.typeInfo) : new I(i.value, i.typeInfo);
        }
        Radians(e, t) {
            const i = this.exec.evalExpression(e.args[0], t);
            return i instanceof A ? new A(i.data.map((r)=>r * Math.PI / 180), i.typeInfo) : new I(i.value * Math.PI / 180, this.getTypeInfo("f32"));
        }
        Reflect(e, t) {
            let i = this.exec.evalExpression(e.args[0], t), r = this.exec.evalExpression(e.args[1], t);
            if (i instanceof A && r instanceof A) {
                const a = this._dot(i.data, r.data);
                return new A(i.data.map((l, u)=>l - 2 * a * r.data[u]), i.typeInfo);
            }
            return console.error(`Reflect() expects vector arguments. Line ${e.line}`), null;
        }
        Refract(e, t) {
            let i = this.exec.evalExpression(e.args[0], t), r = this.exec.evalExpression(e.args[1], t), a = this.exec.evalExpression(e.args[2], t);
            if (i instanceof A && r instanceof A && a instanceof I) {
                const l = this._dot(r.data, i.data);
                return new A(i.data.map((u, h)=>{
                    const d = 1 - a.value * a.value * (1 - l * l);
                    if (d < 0) return 0;
                    const p = Math.sqrt(d);
                    return a.value * u - (a.value * l + p) * r.data[h];
                }), i.typeInfo);
            }
            return console.error(`Refract() expects vector arguments and a scalar argument. Line ${e.line}`), null;
        }
        ReverseBits(e, t) {
            return console.error(`TODO: reverseBits. Line ${e.line}`), null;
        }
        Round(e, t) {
            const i = this.exec.evalExpression(e.args[0], t);
            if (i instanceof A) return new A(i.data.map((a)=>Math.round(a)), i.typeInfo);
            const r = i;
            return new I(Math.round(r.value), i.typeInfo);
        }
        Saturate(e, t) {
            const i = this.exec.evalExpression(e.args[0], t);
            if (i instanceof A) return new A(i.data.map((a)=>Math.min(Math.max(a, 0), 1)), i.typeInfo);
            const r = i;
            return new I(Math.min(Math.max(r.value, 0), 1), i.typeInfo);
        }
        Sign(e, t) {
            const i = this.exec.evalExpression(e.args[0], t);
            if (i instanceof A) return new A(i.data.map((a)=>Math.sign(a)), i.typeInfo);
            const r = i;
            return new I(Math.sign(r.value), i.typeInfo);
        }
        Sin(e, t) {
            const i = this.exec.evalExpression(e.args[0], t);
            if (i instanceof A) return new A(i.data.map((a)=>Math.sin(a)), i.typeInfo);
            const r = i;
            return new I(Math.sin(r.value), i.typeInfo);
        }
        Sinh(e, t) {
            const i = this.exec.evalExpression(e.args[0], t);
            if (i instanceof A) return new A(i.data.map((a)=>Math.sinh(a)), i.typeInfo);
            const r = i;
            return new I(Math.sinh(r.value), i.typeInfo);
        }
        _smoothstep(e, t, i) {
            const r = Math.min(Math.max((i - e) / (t - e), 0), 1);
            return r * r * (3 - 2 * r);
        }
        SmoothStep(e, t) {
            const i = this.exec.evalExpression(e.args[0], t), r = this.exec.evalExpression(e.args[1], t), a = this.exec.evalExpression(e.args[2], t);
            if (a instanceof A && i instanceof A && r instanceof A) return new A(a.data.map((d, p)=>this._smoothstep(i.data[p], r.data[p], d)), a.typeInfo);
            const l = i, u = r, h = a;
            return new I(this._smoothstep(l.value, u.value, h.value), a.typeInfo);
        }
        Sqrt(e, t) {
            const i = this.exec.evalExpression(e.args[0], t);
            if (i instanceof A) return new A(i.data.map((a)=>Math.sqrt(a)), i.typeInfo);
            const r = i;
            return new I(Math.sqrt(r.value), i.typeInfo);
        }
        Step(e, t) {
            const i = this.exec.evalExpression(e.args[0], t), r = this.exec.evalExpression(e.args[1], t);
            if (r instanceof A && i instanceof A) return new A(r.data.map((l, u)=>l < i.data[u] ? 0 : 1), r.typeInfo);
            const a = i;
            return new I(r.value < a.value ? 0 : 1, a.typeInfo);
        }
        Tan(e, t) {
            const i = this.exec.evalExpression(e.args[0], t);
            if (i instanceof A) return new A(i.data.map((a)=>Math.tan(a)), i.typeInfo);
            const r = i;
            return new I(Math.tan(r.value), i.typeInfo);
        }
        Tanh(e, t) {
            const i = this.exec.evalExpression(e.args[0], t);
            if (i instanceof A) return new A(i.data.map((a)=>Math.tanh(a)), i.typeInfo);
            const r = i;
            return new I(Math.tanh(r.value), i.typeInfo);
        }
        _getTransposeType(e) {
            const t = e.getTypeName();
            return t === "mat2x2f" || t === "mat2x2h" ? e : t === "mat2x3f" ? this.getTypeInfo("mat3x2f") : t === "mat2x3h" ? this.getTypeInfo("mat3x2h") : t === "mat2x4f" ? this.getTypeInfo("mat4x2f") : t === "mat2x4h" ? this.getTypeInfo("mat4x2h") : t === "mat3x2f" ? this.getTypeInfo("mat2x3f") : t === "mat3x2h" ? this.getTypeInfo("mat2x3h") : t === "mat3x3f" || t === "mat3x3h" ? e : t === "mat3x4f" ? this.getTypeInfo("mat4x3f") : t === "mat3x4h" ? this.getTypeInfo("mat4x3h") : t === "mat4x2f" ? this.getTypeInfo("mat2x4f") : t === "mat4x2h" ? this.getTypeInfo("mat2x4h") : t === "mat4x3f" ? this.getTypeInfo("mat3x4f") : t === "mat4x3h" ? this.getTypeInfo("mat3x4h") : (t === "mat4x4f" || t === "mat4x4h" || console.error(`Invalid matrix type ${t}`), e);
        }
        Transpose(e, t) {
            const i = this.exec.evalExpression(e.args[0], t);
            if (!(i instanceof me)) return console.error(`Transpose() expects a matrix argument. Line ${e.line}`), null;
            const r = this._getTransposeType(i.typeInfo);
            if (i.typeInfo.name === "mat2x2" || i.typeInfo.name === "mat2x2f" || i.typeInfo.name === "mat2x2h") {
                const a = i.data;
                return new me([
                    a[0],
                    a[2],
                    a[1],
                    a[3]
                ], r);
            }
            if (i.typeInfo.name === "mat2x3" || i.typeInfo.name === "mat2x3f" || i.typeInfo.name === "mat2x3h") {
                const a = i.data;
                return new me([
                    a[0],
                    a[3],
                    a[6],
                    a[1],
                    a[4],
                    a[7]
                ], r);
            }
            if (i.typeInfo.name === "mat2x4" || i.typeInfo.name === "mat2x4f" || i.typeInfo.name === "mat2x4h") {
                const a = i.data;
                return new me([
                    a[0],
                    a[4],
                    a[8],
                    a[12],
                    a[1],
                    a[5],
                    a[9],
                    a[13]
                ], r);
            }
            if (i.typeInfo.name === "mat3x2" || i.typeInfo.name === "mat3x2f" || i.typeInfo.name === "mat3x2h") {
                const a = i.data;
                return new me([
                    a[0],
                    a[3],
                    a[1],
                    a[4],
                    a[2],
                    a[5]
                ], r);
            }
            if (i.typeInfo.name === "mat3x3" || i.typeInfo.name === "mat3x3f" || i.typeInfo.name === "mat3x3h") {
                const a = i.data;
                return new me([
                    a[0],
                    a[3],
                    a[6],
                    a[1],
                    a[4],
                    a[7],
                    a[2],
                    a[5],
                    a[8]
                ], r);
            }
            if (i.typeInfo.name === "mat3x4" || i.typeInfo.name === "mat3x4f" || i.typeInfo.name === "mat3x4h") {
                const a = i.data;
                return new me([
                    a[0],
                    a[4],
                    a[8],
                    a[12],
                    a[1],
                    a[5],
                    a[9],
                    a[13],
                    a[2],
                    a[6],
                    a[10],
                    a[14]
                ], r);
            }
            if (i.typeInfo.name === "mat4x2" || i.typeInfo.name === "mat4x2f" || i.typeInfo.name === "mat4x2h") {
                const a = i.data;
                return new me([
                    a[0],
                    a[4],
                    a[1],
                    a[5],
                    a[2],
                    a[6]
                ], r);
            }
            if (i.typeInfo.name === "mat4x3" || i.typeInfo.name === "mat4x3f" || i.typeInfo.name === "mat4x3h") {
                const a = i.data;
                return new me([
                    a[0],
                    a[4],
                    a[8],
                    a[1],
                    a[5],
                    a[9],
                    a[2],
                    a[6],
                    a[10]
                ], r);
            }
            if (i.typeInfo.name === "mat4x4" || i.typeInfo.name === "mat4x4f" || i.typeInfo.name === "mat4x4h") {
                const a = i.data;
                return new me([
                    a[0],
                    a[4],
                    a[8],
                    a[12],
                    a[1],
                    a[5],
                    a[9],
                    a[13],
                    a[2],
                    a[6],
                    a[10],
                    a[14],
                    a[3],
                    a[7],
                    a[11],
                    a[15]
                ], r);
            }
            return console.error(`Invalid matrix type ${i.typeInfo.name}`), null;
        }
        Trunc(e, t) {
            const i = this.exec.evalExpression(e.args[0], t);
            if (i instanceof A) return new A(i.data.map((a)=>Math.trunc(a)), i.typeInfo);
            const r = i;
            return new I(Math.trunc(r.value), i.typeInfo);
        }
        Dpdx(e, t) {
            return console.error(`TODO: dpdx. Line ${e.line}`), null;
        }
        DpdxCoarse(e, t) {
            return console.error(`TODO: dpdxCoarse. Line ${e.line}`), null;
        }
        DpdxFine(e, t) {
            return console.error("TODO: dpdxFine"), null;
        }
        Dpdy(e, t) {
            return console.error("TODO: dpdy"), null;
        }
        DpdyCoarse(e, t) {
            return console.error("TODO: dpdyCoarse"), null;
        }
        DpdyFine(e, t) {
            return console.error("TODO: dpdyFine"), null;
        }
        Fwidth(e, t) {
            return console.error("TODO: fwidth"), null;
        }
        FwidthCoarse(e, t) {
            return console.error("TODO: fwidthCoarse"), null;
        }
        FwidthFine(e, t) {
            return console.error("TODO: fwidthFine"), null;
        }
        TextureDimensions(e, t) {
            const i = e.args[0], r = e.args.length > 1 ? this.exec.evalExpression(e.args[1], t).value : 0;
            if (i instanceof sn) {
                const a = i.name, l = t.getVariableValue(a);
                if (l instanceof ui) {
                    if (r < 0 || r >= l.mipLevelCount) return console.error(`Invalid mip level for textureDimensions. Line ${e.line}`), null;
                    const u = l.getMipLevelSize(r), h = l.dimension;
                    return h === "1d" ? new I(u[0], this.getTypeInfo("u32")) : h === "3d" ? new A(u, this.getTypeInfo("vec3u")) : h === "2d" ? new A(u.slice(0, 2), this.getTypeInfo("vec2u")) : (console.error(`Invalid texture dimension ${h} not found. Line ${e.line}`), null);
                }
                return console.error(`Texture ${a} not found. Line ${e.line}`), null;
            }
            return console.error(`Invalid texture argument for textureDimensions. Line ${e.line}`), null;
        }
        TextureGather(e, t) {
            return console.error("TODO: textureGather"), null;
        }
        TextureGatherCompare(e, t) {
            return console.error("TODO: textureGatherCompare"), null;
        }
        TextureLoad(e, t) {
            const i = e.args[0], r = this.exec.evalExpression(e.args[1], t), a = e.args.length > 2 ? this.exec.evalExpression(e.args[2], t).value : 0;
            if (!(r instanceof A) || r.data.length !== 2) return console.error(`Invalid UV argument for textureLoad. Line ${e.line}`), null;
            if (i instanceof sn) {
                const l = i.name, u = t.getVariableValue(l);
                if (u instanceof ui) {
                    const h = Math.floor(r.data[0]), d = Math.floor(r.data[1]);
                    if (h < 0 || h >= u.width || d < 0 || d >= u.height) return console.error(`Texture ${l} out of bounds. Line ${e.line}`), null;
                    const p = u.getPixel(h, d, 0, a);
                    return p === null ? (console.error(`Invalid texture format for textureLoad. Line ${e.line}`), null) : new A(p, this.getTypeInfo("vec4f"));
                }
                return console.error(`Texture ${l} not found. Line ${e.line}`), null;
            }
            return console.error(`Invalid texture argument for textureLoad. Line ${e.line}`), null;
        }
        TextureNumLayers(e, t) {
            const i = e.args[0];
            if (i instanceof sn) {
                const r = i.name, a = t.getVariableValue(r);
                return a instanceof ui ? new I(a.depthOrArrayLayers, this.getTypeInfo("u32")) : (console.error(`Texture ${r} not found. Line ${e.line}`), null);
            }
            return console.error(`Invalid texture argument for textureNumLayers. Line ${e.line}`), null;
        }
        TextureNumLevels(e, t) {
            const i = e.args[0];
            if (i instanceof sn) {
                const r = i.name, a = t.getVariableValue(r);
                return a instanceof ui ? new I(a.mipLevelCount, this.getTypeInfo("u32")) : (console.error(`Texture ${r} not found. Line ${e.line}`), null);
            }
            return console.error(`Invalid texture argument for textureNumLevels. Line ${e.line}`), null;
        }
        TextureNumSamples(e, t) {
            const i = e.args[0];
            if (i instanceof sn) {
                const r = i.name, a = t.getVariableValue(r);
                return a instanceof ui ? new I(a.sampleCount, this.getTypeInfo("u32")) : (console.error(`Texture ${r} not found. Line ${e.line}`), null);
            }
            return console.error(`Invalid texture argument for textureNumSamples. Line ${e.line}`), null;
        }
        TextureSample(e, t) {
            return console.error("TODO: textureSample"), null;
        }
        TextureSampleBias(e, t) {
            return console.error("TODO: textureSampleBias"), null;
        }
        TextureSampleCompare(e, t) {
            return console.error("TODO: textureSampleCompare"), null;
        }
        TextureSampleCompareLevel(e, t) {
            return console.error("TODO: textureSampleCompareLevel"), null;
        }
        TextureSampleGrad(e, t) {
            return console.error("TODO: textureSampleGrad"), null;
        }
        TextureSampleLevel(e, t) {
            return console.error("TODO: textureSampleLevel"), null;
        }
        TextureSampleBaseClampToEdge(e, t) {
            return console.error("TODO: textureSampleBaseClampToEdge"), null;
        }
        TextureStore(e, t) {
            const i = e.args[0], r = this.exec.evalExpression(e.args[1], t), a = e.args.length === 4 ? this.exec.evalExpression(e.args[2], t).value : 0, l = e.args.length === 4 ? this.exec.evalExpression(e.args[3], t).data : this.exec.evalExpression(e.args[2], t).data;
            if (l.length !== 4) return console.error(`Invalid value argument for textureStore. Line ${e.line}`), null;
            if (!(r instanceof A) || r.data.length !== 2) return console.error(`Invalid UV argument for textureStore. Line ${e.line}`), null;
            if (i instanceof sn) {
                const u = i.name, h = t.getVariableValue(u);
                if (h instanceof ui) {
                    const d = h.getMipLevelSize(0), p = Math.floor(r.data[0]), _ = Math.floor(r.data[1]);
                    return p < 0 || p >= d[0] || _ < 0 || _ >= d[1] ? (console.error(`Texture ${u} out of bounds. Line ${e.line}`), null) : (h.setPixel(p, _, 0, a, Array.from(l)), null);
                }
                return console.error(`Texture ${u} not found. Line ${e.line}`), null;
            }
            return console.error(`Invalid texture argument for textureStore. Line ${e.line}`), null;
        }
        AtomicLoad(e, t) {
            let i = e.args[0];
            i instanceof ft && (i = i.right);
            const r = this.exec.getVariableName(i, t);
            return t.getVariable(r).value.getSubData(this.exec, i.postfix, t);
        }
        AtomicStore(e, t) {
            let i = e.args[0];
            i instanceof ft && (i = i.right);
            const r = this.exec.getVariableName(i, t), a = t.getVariable(r);
            let l = e.args[1];
            const u = this.exec.evalExpression(l, t), h = a.value.getSubData(this.exec, i.postfix, t);
            return h instanceof I && u instanceof I && (h.value = u.value), a.value instanceof st && a.value.setDataValue(this.exec, h, i.postfix, t), null;
        }
        AtomicAdd(e, t) {
            let i = e.args[0];
            i instanceof ft && (i = i.right);
            const r = this.exec.getVariableName(i, t), a = t.getVariable(r);
            let l = e.args[1];
            const u = this.exec.evalExpression(l, t), h = a.value.getSubData(this.exec, i.postfix, t), d = new I(h.value, h.typeInfo);
            return h instanceof I && u instanceof I && (h.value += u.value), a.value instanceof st && a.value.setDataValue(this.exec, h, i.postfix, t), d;
        }
        AtomicSub(e, t) {
            let i = e.args[0];
            i instanceof ft && (i = i.right);
            const r = this.exec.getVariableName(i, t), a = t.getVariable(r);
            let l = e.args[1];
            const u = this.exec.evalExpression(l, t), h = a.value.getSubData(this.exec, i.postfix, t), d = new I(h.value, h.typeInfo);
            return h instanceof I && u instanceof I && (h.value -= u.value), a.value instanceof st && a.value.setDataValue(this.exec, h, i.postfix, t), d;
        }
        AtomicMax(e, t) {
            let i = e.args[0];
            i instanceof ft && (i = i.right);
            const r = this.exec.getVariableName(i, t), a = t.getVariable(r);
            let l = e.args[1];
            const u = this.exec.evalExpression(l, t), h = a.value.getSubData(this.exec, i.postfix, t), d = new I(h.value, h.typeInfo);
            return h instanceof I && u instanceof I && (h.value = Math.max(h.value, u.value)), a.value instanceof st && a.value.setDataValue(this.exec, h, i.postfix, t), d;
        }
        AtomicMin(e, t) {
            let i = e.args[0];
            i instanceof ft && (i = i.right);
            const r = this.exec.getVariableName(i, t), a = t.getVariable(r);
            let l = e.args[1];
            const u = this.exec.evalExpression(l, t), h = a.value.getSubData(this.exec, i.postfix, t), d = new I(h.value, h.typeInfo);
            return h instanceof I && u instanceof I && (h.value = Math.min(h.value, u.value)), a.value instanceof st && a.value.setDataValue(this.exec, h, i.postfix, t), d;
        }
        AtomicAnd(e, t) {
            let i = e.args[0];
            i instanceof ft && (i = i.right);
            const r = this.exec.getVariableName(i, t), a = t.getVariable(r);
            let l = e.args[1];
            const u = this.exec.evalExpression(l, t), h = a.value.getSubData(this.exec, i.postfix, t), d = new I(h.value, h.typeInfo);
            return h instanceof I && u instanceof I && (h.value = h.value & u.value), a.value instanceof st && a.value.setDataValue(this.exec, h, i.postfix, t), d;
        }
        AtomicOr(e, t) {
            let i = e.args[0];
            i instanceof ft && (i = i.right);
            const r = this.exec.getVariableName(i, t), a = t.getVariable(r);
            let l = e.args[1];
            const u = this.exec.evalExpression(l, t), h = a.value.getSubData(this.exec, i.postfix, t), d = new I(h.value, h.typeInfo);
            return h instanceof I && u instanceof I && (h.value = h.value | u.value), a.value instanceof st && a.value.setDataValue(this.exec, h, i.postfix, t), d;
        }
        AtomicXor(e, t) {
            let i = e.args[0];
            i instanceof ft && (i = i.right);
            const r = this.exec.getVariableName(i, t), a = t.getVariable(r);
            let l = e.args[1];
            const u = this.exec.evalExpression(l, t), h = a.value.getSubData(this.exec, i.postfix, t), d = new I(h.value, h.typeInfo);
            return h instanceof I && u instanceof I && (h.value = h.value ^ u.value), a.value instanceof st && a.value.setDataValue(this.exec, h, i.postfix, t), d;
        }
        AtomicExchange(e, t) {
            let i = e.args[0];
            i instanceof ft && (i = i.right);
            const r = this.exec.getVariableName(i, t), a = t.getVariable(r);
            let l = e.args[1];
            const u = this.exec.evalExpression(l, t), h = a.value.getSubData(this.exec, i.postfix, t), d = new I(h.value, h.typeInfo);
            return h instanceof I && u instanceof I && (h.value = u.value), a.value instanceof st && a.value.setDataValue(this.exec, h, i.postfix, t), d;
        }
        AtomicCompareExchangeWeak(e, t) {
            return console.error("TODO: atomicCompareExchangeWeak"), null;
        }
        Pack4x8snorm(e, t) {
            return console.error("TODO: pack4x8snorm"), null;
        }
        Pack4x8unorm(e, t) {
            return console.error("TODO: pack4x8unorm"), null;
        }
        Pack4xI8(e, t) {
            return console.error("TODO: pack4xI8"), null;
        }
        Pack4xU8(e, t) {
            return console.error("TODO: pack4xU8"), null;
        }
        Pack4x8Clamp(e, t) {
            return console.error("TODO: pack4x8Clamp"), null;
        }
        Pack4xU8Clamp(e, t) {
            return console.error("TODO: pack4xU8Clamp"), null;
        }
        Pack2x16snorm(e, t) {
            return console.error("TODO: pack2x16snorm"), null;
        }
        Pack2x16unorm(e, t) {
            return console.error("TODO: pack2x16unorm"), null;
        }
        Pack2x16float(e, t) {
            return console.error("TODO: pack2x16float"), null;
        }
        Unpack4x8snorm(e, t) {
            return console.error("TODO: unpack4x8snorm"), null;
        }
        Unpack4x8unorm(e, t) {
            return console.error("TODO: unpack4x8unorm"), null;
        }
        Unpack4xI8(e, t) {
            return console.error("TODO: unpack4xI8"), null;
        }
        Unpack4xU8(e, t) {
            return console.error("TODO: unpack4xU8"), null;
        }
        Unpack2x16snorm(e, t) {
            return console.error("TODO: unpack2x16snorm"), null;
        }
        Unpack2x16unorm(e, t) {
            return console.error("TODO: unpack2x16unorm"), null;
        }
        Unpack2x16float(e, t) {
            return console.error("TODO: unpack2x16float"), null;
        }
        StorageBarrier(e, t) {
            return null;
        }
        TextureBarrier(e, t) {
            return null;
        }
        WorkgroupBarrier(e, t) {
            return null;
        }
        WorkgroupUniformLoad(e, t) {
            return null;
        }
        SubgroupAdd(e, t) {
            return console.error("TODO: subgroupAdd"), null;
        }
        SubgroupExclusiveAdd(e, t) {
            return console.error("TODO: subgroupExclusiveAdd"), null;
        }
        SubgroupInclusiveAdd(e, t) {
            return console.error("TODO: subgroupInclusiveAdd"), null;
        }
        SubgroupAll(e, t) {
            return console.error("TODO: subgroupAll"), null;
        }
        SubgroupAnd(e, t) {
            return console.error("TODO: subgroupAnd"), null;
        }
        SubgroupAny(e, t) {
            return console.error("TODO: subgroupAny"), null;
        }
        SubgroupBallot(e, t) {
            return console.error("TODO: subgroupBallot"), null;
        }
        SubgroupBroadcast(e, t) {
            return console.error("TODO: subgroupBroadcast"), null;
        }
        SubgroupBroadcastFirst(e, t) {
            return console.error("TODO: subgroupBroadcastFirst"), null;
        }
        SubgroupElect(e, t) {
            return console.error("TODO: subgroupElect"), null;
        }
        SubgroupMax(e, t) {
            return console.error("TODO: subgroupMax"), null;
        }
        SubgroupMin(e, t) {
            return console.error("TODO: subgroupMin"), null;
        }
        SubgroupMul(e, t) {
            return console.error("TODO: subgroupMul"), null;
        }
        SubgroupExclusiveMul(e, t) {
            return console.error("TODO: subgroupExclusiveMul"), null;
        }
        SubgroupInclusiveMul(e, t) {
            return console.error("TODO: subgroupInclusiveMul"), null;
        }
        SubgroupOr(e, t) {
            return console.error("TODO: subgroupOr"), null;
        }
        SubgroupShuffle(e, t) {
            return console.error("TODO: subgroupShuffle"), null;
        }
        SubgroupShuffleDown(e, t) {
            return console.error("TODO: subgroupShuffleDown"), null;
        }
        SubgroupShuffleUp(e, t) {
            return console.error("TODO: subgroupShuffleUp"), null;
        }
        SubgroupShuffleXor(e, t) {
            return console.error("TODO: subgroupShuffleXor"), null;
        }
        SubgroupXor(e, t) {
            return console.error("TODO: subgroupXor"), null;
        }
        QuadBroadcast(e, t) {
            return console.error("TODO: quadBroadcast"), null;
        }
        QuadSwapDiagonal(e, t) {
            return console.error("TODO: quadSwapDiagonal"), null;
        }
        QuadSwapX(e, t) {
            return console.error("TODO: quadSwapX"), null;
        }
        QuadSwapY(e, t) {
            return console.error("TODO: quadSwapY"), null;
        }
    }
    const Wh = {
        vec2: 2,
        vec2f: 2,
        vec2i: 2,
        vec2u: 2,
        vec2b: 2,
        vec2h: 2,
        vec3: 3,
        vec3f: 3,
        vec3i: 3,
        vec3u: 3,
        vec3b: 3,
        vec3h: 3,
        vec4: 4,
        vec4f: 4,
        vec4i: 4,
        vec4u: 4,
        vec4b: 4,
        vec4h: 4
    }, Ut = {
        mat2x2: [
            2,
            2,
            4
        ],
        mat2x2f: [
            2,
            2,
            4
        ],
        mat2x2h: [
            2,
            2,
            4
        ],
        mat2x3: [
            2,
            3,
            6
        ],
        mat2x3f: [
            2,
            3,
            6
        ],
        mat2x3h: [
            2,
            3,
            6
        ],
        mat2x4: [
            2,
            4,
            8
        ],
        mat2x4f: [
            2,
            4,
            8
        ],
        mat2x4h: [
            2,
            4,
            8
        ],
        mat3x2: [
            3,
            2,
            6
        ],
        mat3x2f: [
            3,
            2,
            6
        ],
        mat3x2h: [
            3,
            2,
            6
        ],
        mat3x3: [
            3,
            3,
            9
        ],
        mat3x3f: [
            3,
            3,
            9
        ],
        mat3x3h: [
            3,
            3,
            9
        ],
        mat3x4: [
            3,
            4,
            12
        ],
        mat3x4f: [
            3,
            4,
            12
        ],
        mat3x4h: [
            3,
            4,
            12
        ],
        mat4x2: [
            4,
            2,
            8
        ],
        mat4x2f: [
            4,
            2,
            8
        ],
        mat4x2h: [
            4,
            2,
            8
        ],
        mat4x3: [
            4,
            3,
            12
        ],
        mat4x3f: [
            4,
            3,
            12
        ],
        mat4x3h: [
            4,
            3,
            12
        ],
        mat4x4: [
            4,
            4,
            16
        ],
        mat4x4f: [
            4,
            4,
            16
        ],
        mat4x4h: [
            4,
            4,
            16
        ]
    };
    class Ot extends gC {
        constructor(e, t){
            var i;
            super(), this.ast = e ?? [], this.reflection = new Vn, this.reflection.updateAST(this.ast), this.context = (i = t?.clone()) !== null && i !== void 0 ? i : new Eg, this.builtins = new pC(this), this.typeInfo = {
                bool: this.getTypeInfo(q.bool),
                i32: this.getTypeInfo(q.i32),
                u32: this.getTypeInfo(q.u32),
                f32: this.getTypeInfo(q.f32),
                f16: this.getTypeInfo(q.f16),
                vec2f: this.getTypeInfo(k.vec2f),
                vec2u: this.getTypeInfo(k.vec2u),
                vec2i: this.getTypeInfo(k.vec2i),
                vec2h: this.getTypeInfo(k.vec2h),
                vec3f: this.getTypeInfo(k.vec3f),
                vec3u: this.getTypeInfo(k.vec3u),
                vec3i: this.getTypeInfo(k.vec3i),
                vec3h: this.getTypeInfo(k.vec3h),
                vec4f: this.getTypeInfo(k.vec4f),
                vec4u: this.getTypeInfo(k.vec4u),
                vec4i: this.getTypeInfo(k.vec4i),
                vec4h: this.getTypeInfo(k.vec4h),
                mat2x2f: this.getTypeInfo(k.mat2x2f),
                mat2x3f: this.getTypeInfo(k.mat2x3f),
                mat2x4f: this.getTypeInfo(k.mat2x4f),
                mat3x2f: this.getTypeInfo(k.mat3x2f),
                mat3x3f: this.getTypeInfo(k.mat3x3f),
                mat3x4f: this.getTypeInfo(k.mat3x4f),
                mat4x2f: this.getTypeInfo(k.mat4x2f),
                mat4x3f: this.getTypeInfo(k.mat4x3f),
                mat4x4f: this.getTypeInfo(k.mat4x4f)
            };
        }
        getVariableValue(e) {
            var t, i;
            const r = (i = (t = this.context.getVariable(e)) === null || t === void 0 ? void 0 : t.value) !== null && i !== void 0 ? i : null;
            if (r === null) return null;
            if (r instanceof I) return r.value;
            if (r instanceof A || r instanceof me) return Array.from(r.data);
            if (r instanceof st && r.typeInfo instanceof Ki) {
                if (r.typeInfo.format.name === "u32") return Array.from(new Uint32Array(r.buffer, r.offset, r.typeInfo.count));
                if (r.typeInfo.format.name === "i32") return Array.from(new Int32Array(r.buffer, r.offset, r.typeInfo.count));
                if (r.typeInfo.format.name === "f32") return Array.from(new Float32Array(r.buffer, r.offset, r.typeInfo.count));
            }
            return console.error(`Unsupported return variable type ${r.typeInfo.name}`), null;
        }
        execute(e) {
            (e = e ?? {}).constants && this._setOverrides(e.constants, this.context), this._execStatements(this.ast, this.context);
        }
        dispatchWorkgroups(e, t, i, r) {
            const a = this.context.clone();
            (r = r ?? {}).constants && this._setOverrides(r.constants, a), this._execStatements(this.ast, a);
            const l = a.getFunction(e);
            if (!l) return void console.error(`Function ${e} not found`);
            if (typeof t == "number") t = [
                t,
                1,
                1
            ];
            else {
                if (t.length === 0) return void console.error("Invalid dispatch count");
                t.length === 1 ? t = [
                    t[0],
                    1,
                    1
                ] : t.length === 2 ? t = [
                    t[0],
                    t[1],
                    1
                ] : t.length > 3 && (t = [
                    t[0],
                    t[1],
                    t[2]
                ]);
            }
            const u = t[0], h = t[1], d = t[2], p = this.getTypeInfo("vec3u");
            a.setVariable("@num_workgroups", new A(t, p));
            for(const _ in i)for(const y in i[_]){
                const v = i[_][y];
                a.variables.forEach((S)=>{
                    var E;
                    const M = S.node;
                    if (M?.attributes) {
                        let B = null, H = null;
                        for (const O of M.attributes)O.name === "binding" ? B = O.value : O.name === "group" && (H = O.value);
                        if (y == B && _ == H) if (v.texture !== void 0 && v.descriptor !== void 0) {
                            const O = new ui(v.texture, this.getTypeInfo(M.type), v.descriptor, (E = v.texture.view) !== null && E !== void 0 ? E : null);
                            S.value = O;
                        } else v.uniform !== void 0 ? S.value = new st(v.uniform, this.getTypeInfo(M.type)) : S.value = new st(v, this.getTypeInfo(M.type));
                    }
                });
            }
            for(let _ = 0; _ < d; ++_)for(let y = 0; y < h; ++y)for(let v = 0; v < u; ++v)a.setVariable("@workgroup_id", new A([
                v,
                y,
                _
            ], this.getTypeInfo("vec3u"))), this._dispatchWorkgroup(l, [
                v,
                y,
                _
            ], a);
        }
        execStatement(e, t) {
            if (e instanceof K3) return this.evalExpression(e.value, t);
            if (e instanceof Q3) {
                if (e.condition) {
                    const i = this.evalExpression(e.condition, t);
                    if (!(i instanceof I)) throw new Error("Invalid break-if condition");
                    if (!i.value) return null;
                }
                return Ot._breakObj;
            }
            if (e instanceof G3) return Ot._continueObj;
            if (e instanceof go) this._let(e, t);
            else if (e instanceof fi) this._var(e, t);
            else if (e instanceof dc) this._const(e, t);
            else if (e instanceof To) this._function(e, t);
            else {
                if (e instanceof q3) return this._if(e, t);
                if (e instanceof Y3) return this._switch(e, t);
                if (e instanceof j3) return this._for(e, t);
                if (e instanceof H3) return this._while(e, t);
                if (e instanceof X3) return this._loop(e, t);
                if (e instanceof Ed) {
                    const i = t.clone();
                    return i.currentFunctionName = t.currentFunctionName, this._execStatements(e.body, i);
                }
                if (e instanceof $3) this._assign(e, t);
                else if (e instanceof W3) this._increment(e, t);
                else {
                    if (e instanceof ci) return null;
                    if (e instanceof vg) {
                        const i = e.name;
                        t.getVariable(i) === null && t.setVariable(i, new I(0, this.getTypeInfo("u32")));
                    } else if (e instanceof Tg) this._call(e, t);
                    else {
                        if (e instanceof Z3 || e instanceof xg) return null;
                        console.error("Invalid statement type.", e, `Line ${e.line}`);
                    }
                }
            }
            return null;
        }
        evalExpression(e, t) {
            return e instanceof En ? this._evalBinaryOp(e, t) : e instanceof pt ? this._evalLiteral(e, t) : e instanceof sn ? this._evalVariable(e, t) : e instanceof Sg ? this._evalCall(e, t) : e instanceof Ln ? this._evalCreate(e, t) : e instanceof J3 ? this._evalConst(e, t) : e instanceof eT ? this._evalBitcast(e, t) : e instanceof ft ? this._evalUnaryOp(e, t) : (console.error("Invalid expression type", e, `Line ${e.line}`), null);
        }
        getTypeInfo(e) {
            var t;
            if (e instanceof q) {
                const r = this.reflection.getTypeInfo(e);
                if (r !== null) return r;
            }
            let i = (t = this.typeInfo[e]) !== null && t !== void 0 ? t : null;
            return i !== null || (i = this.reflection.getTypeInfoByName(e)), i;
        }
        _setOverrides(e, t) {
            for(const i in e){
                const r = e[i], a = this.reflection.getOverrideInfo(i);
                a !== null ? (a.type === null && (a.type = this.getTypeInfo("u32")), a.type.name === "u32" || a.type.name === "i32" || a.type.name === "f32" || a.type.name === "f16" ? t.setVariable(i, new I(r, a.type)) : a.type.name === "bool" ? t.setVariable(i, new I(r ? 1 : 0, a.type)) : a.type.name === "vec2" || a.type.name === "vec3" || a.type.name === "vec4" || a.type.name === "vec2f" || a.type.name === "vec3f" || a.type.name === "vec4f" || a.type.name === "vec2i" || a.type.name === "vec3i" || a.type.name === "vec4i" || a.type.name === "vec2u" || a.type.name === "vec3u" || a.type.name === "vec4u" || a.type.name === "vec2h" || a.type.name === "vec3h" || a.type.name === "vec4h" ? t.setVariable(i, new A(r, a.type)) : console.error(`Invalid constant type for ${i}`)) : console.error(`Override ${i} does not exist in the shader.`);
            }
        }
        _dispatchWorkgroup(e, t, i) {
            const r = [
                1,
                1,
                1
            ];
            for (const p of e.node.attributes)if (p.name === "workgroup_size") {
                if (p.value.length > 0) {
                    const _ = i.getVariableValue(p.value[0]);
                    r[0] = _ instanceof I ? _.value : parseInt(p.value[0]);
                }
                if (p.value.length > 1) {
                    const _ = i.getVariableValue(p.value[1]);
                    r[1] = _ instanceof I ? _.value : parseInt(p.value[1]);
                }
                if (p.value.length > 2) {
                    const _ = i.getVariableValue(p.value[2]);
                    r[2] = _ instanceof I ? _.value : parseInt(p.value[2]);
                }
            }
            const a = this.getTypeInfo("vec3u"), l = this.getTypeInfo("u32");
            i.setVariable("@workgroup_size", new A(r, a));
            const u = r[0], h = r[1], d = r[2];
            for(let p = 0, _ = 0; p < d; ++p)for(let y = 0; y < h; ++y)for(let v = 0; v < u; ++v, ++_){
                const S = [
                    v,
                    y,
                    p
                ], E = [
                    v + t[0] * r[0],
                    y + t[1] * r[1],
                    p + t[2] * r[2]
                ];
                i.setVariable("@local_invocation_id", new A(S, a)), i.setVariable("@global_invocation_id", new A(E, a)), i.setVariable("@local_invocation_index", new I(_, l)), this._dispatchExec(e, i);
            }
        }
        _dispatchExec(e, t) {
            for (const i of e.node.args)for (const r of i.attributes)if (r.name === "builtin") {
                const a = `@${r.value}`, l = t.getVariable(a);
                l !== void 0 && t.variables.set(i.name, l);
            }
            this._execStatements(e.node.body, t);
        }
        getVariableName(e, t) {
            for(; e instanceof ft;)e = e.right;
            return e instanceof sn ? e.name : (console.error("Unknown variable type", e, "Line", e.line), null);
        }
        _execStatements(e, t) {
            for (const i of e){
                if (i instanceof Array) {
                    const a = t.clone(), l = this._execStatements(i, a);
                    if (l) return l;
                    continue;
                }
                const r = this.execStatement(i, t);
                if (r) return r;
            }
            return null;
        }
        _call(e, t) {
            const i = t.clone();
            i.currentFunctionName = e.name;
            const r = t.getFunction(e.name);
            if (r) {
                for(let a = 0; a < r.node.args.length; ++a){
                    const l = r.node.args[a], u = this.evalExpression(e.args[a], i);
                    i.setVariable(l.name, u, l);
                }
                this._execStatements(r.node.body, i);
            } else e.isBuiltin ? this._callBuiltinFunction(e, i) : this.getTypeInfo(e.name) && this._evalCreate(e, t);
        }
        _increment(e, t) {
            const i = this.getVariableName(e.variable, t), r = t.getVariable(i);
            r ? e.operator === "++" ? r.value instanceof I ? r.value.value++ : console.error(`Variable ${i} is not a scalar. Line ${e.line}`) : e.operator === "--" ? r.value instanceof I ? r.value.value-- : console.error(`Variable ${i} is not a scalar. Line ${e.line}`) : console.error(`Unknown increment operator ${e.operator}. Line ${e.line}`) : console.error(`Variable ${i} not found. Line ${e.line}`);
        }
        _getVariableData(e, t) {
            if (e instanceof sn) {
                const i = this.getVariableName(e, t), r = t.getVariable(i);
                return r === null ? (console.error(`Variable ${i} not found. Line ${e.line}`), null) : r.value.getSubData(this, e.postfix, t);
            }
            if (e instanceof ft) {
                if (e.operator === "*") {
                    const i = this._getVariableData(e.right, t);
                    return i instanceof Cs ? i.reference.getSubData(this, e.postfix, t) : (console.error(`Variable ${e.right} is not a pointer. Line ${e.line}`), null);
                }
                if (e.operator === "&") {
                    const i = this._getVariableData(e.right, t);
                    return new Cs(i);
                }
            }
            return null;
        }
        _assign(e, t) {
            let i = null, r = "<var>", a = null;
            if (e.variable instanceof ft) {
                const h = this._getVariableData(e.variable, t), d = this.evalExpression(e.value, t), p = e.operator;
                if (p === "=") {
                    if (h instanceof I || h instanceof A || h instanceof me) {
                        if (d instanceof I || d instanceof A || d instanceof me && h.data.length === d.data.length) return void h.data.set(d.data);
                        console.error(`Invalid assignment. Line ${e.line}`);
                    } else if (h instanceof st && d instanceof st && h.buffer.byteLength - h.offset >= d.buffer.byteLength - d.offset) return void (h.buffer.byteLength % 4 == 0 ? new Uint32Array(h.buffer, h.offset, h.typeInfo.size / 4).set(new Uint32Array(d.buffer, d.offset, d.typeInfo.size / 4)) : new Uint8Array(h.buffer, h.offset, h.typeInfo.size).set(new Uint8Array(d.buffer, d.offset, d.typeInfo.size)));
                    return console.error(`Invalid assignment. Line ${e.line}`), null;
                }
                if (p === "+=") return h instanceof I || h instanceof A || h instanceof me ? d instanceof I || d instanceof A || d instanceof me ? void h.data.set(d.data.map((_, y)=>h.data[y] + _)) : void console.error(`Invalid assignment . Line ${e.line}`) : void console.error(`Invalid assignment. Line ${e.line}`);
                if (p === "-=") return (h instanceof I || h instanceof A || h instanceof me) && (d instanceof I || d instanceof A || d instanceof me) ? void h.data.set(d.data.map((_, y)=>h.data[y] - _)) : void console.error(`Invalid assignment. Line ${e.line}`);
            }
            if (e.variable instanceof ft) {
                if (e.variable.operator === "*") {
                    r = this.getVariableName(e.variable.right, t);
                    const h = t.getVariable(r);
                    if (!(h && h.value instanceof Cs)) return void console.error(`Variable ${r} is not a pointer. Line ${e.line}`);
                    i = h.value.reference;
                    let d = e.variable.postfix;
                    if (!d) {
                        let p = e.variable.right;
                        for(; p instanceof ft;){
                            if (p.postfix) {
                                d = p.postfix;
                                break;
                            }
                            p = p.right;
                        }
                    }
                    d && (i = i.getSubData(this, d, t));
                }
            } else {
                a = e.variable.postfix, r = this.getVariableName(e.variable, t);
                const h = t.getVariable(r);
                if (h === null) return void console.error(`Variable ${r} not found. Line ${e.line}`);
                i = h.value;
            }
            if (i instanceof Cs && (i = i.reference), i === null) return void console.error(`Variable ${r} not found. Line ${e.line}`);
            const l = this.evalExpression(e.value, t), u = e.operator;
            if (u === "=") if (i instanceof st) i.setDataValue(this, l, a, t);
            else if (a) {
                if (!(i instanceof A || i instanceof me)) return void console.error(`Variable ${r} is not a vector or matrix. Line ${e.line}`);
                if (a instanceof Xs) {
                    const h = this.evalExpression(a.index, t).value;
                    if (i instanceof A) {
                        if (!(l instanceof I)) return void console.error(`Invalid assignment to ${r}. Line ${e.line}`);
                        i.data[h] = l.value;
                    } else {
                        if (!(i instanceof me)) return void console.error(`Invalid assignment to ${r}. Line ${e.line}`);
                        {
                            const d = this.evalExpression(a.index, t).value;
                            if (d < 0) return void console.error(`Invalid assignment to ${r}. Line ${e.line}`);
                            if (!(l instanceof A)) return void console.error(`Invalid assignment to ${r}. Line ${e.line}`);
                            {
                                const p = i.typeInfo.getTypeName();
                                if (p === "mat2x2" || p === "mat2x2f" || p === "mat2x2h") {
                                    if (!(d < 2 && l.data.length === 2)) return void console.error(`Invalid assignment to ${r}. Line ${e.line}`);
                                    i.data[2 * d] = l.data[0], i.data[2 * d + 1] = l.data[1];
                                } else if (p === "mat2x3" || p === "mat2x3f" || p === "mat2x3h") {
                                    if (!(d < 2 && l.data.length === 3)) return void console.error(`Invalid assignment to ${r}. Line ${e.line}`);
                                    i.data[3 * d] = l.data[0], i.data[3 * d + 1] = l.data[1], i.data[3 * d + 2] = l.data[2];
                                } else if (p === "mat2x4" || p === "mat2x4f" || p === "mat2x4h") {
                                    if (!(d < 2 && l.data.length === 4)) return void console.error(`Invalid assignment to ${r}. Line ${e.line}`);
                                    i.data[4 * d] = l.data[0], i.data[4 * d + 1] = l.data[1], i.data[4 * d + 2] = l.data[2], i.data[4 * d + 3] = l.data[3];
                                } else if (p === "mat3x2" || p === "mat3x2f" || p === "mat3x2h") {
                                    if (!(d < 3 && l.data.length === 2)) return void console.error(`Invalid assignment to ${r}. Line ${e.line}`);
                                    i.data[2 * d] = l.data[0], i.data[2 * d + 1] = l.data[1];
                                } else if (p === "mat3x3" || p === "mat3x3f" || p === "mat3x3h") {
                                    if (!(d < 3 && l.data.length === 3)) return void console.error(`Invalid assignment to ${r}. Line ${e.line}`);
                                    i.data[3 * d] = l.data[0], i.data[3 * d + 1] = l.data[1], i.data[3 * d + 2] = l.data[2];
                                } else if (p === "mat3x4" || p === "mat3x4f" || p === "mat3x4h") {
                                    if (!(d < 3 && l.data.length === 4)) return void console.error(`Invalid assignment to ${r}. Line ${e.line}`);
                                    i.data[4 * d] = l.data[0], i.data[4 * d + 1] = l.data[1], i.data[4 * d + 2] = l.data[2], i.data[4 * d + 3] = l.data[3];
                                } else if (p === "mat4x2" || p === "mat4x2f" || p === "mat4x2h") {
                                    if (!(d < 4 && l.data.length === 2)) return void console.error(`Invalid assignment to ${r}. Line ${e.line}`);
                                    i.data[2 * d] = l.data[0], i.data[2 * d + 1] = l.data[1];
                                } else if (p === "mat4x3" || p === "mat4x3f" || p === "mat4x3h") {
                                    if (!(d < 4 && l.data.length === 3)) return void console.error(`Invalid assignment to ${r}. Line ${e.line}`);
                                    i.data[3 * d] = l.data[0], i.data[3 * d + 1] = l.data[1], i.data[3 * d + 2] = l.data[2];
                                } else {
                                    if (p !== "mat4x4" && p !== "mat4x4f" && p !== "mat4x4h") return void console.error(`Invalid assignment to ${r}. Line ${e.line}`);
                                    if (!(d < 4 && l.data.length === 4)) return void console.error(`Invalid assignment to ${r}. Line ${e.line}`);
                                    i.data[4 * d] = l.data[0], i.data[4 * d + 1] = l.data[1], i.data[4 * d + 2] = l.data[2], i.data[4 * d + 3] = l.data[3];
                                }
                            }
                        }
                    }
                } else if (a instanceof Or) {
                    const h = a.value;
                    if (!(i instanceof A)) return void console.error(`Invalid assignment to ${h}. Variable ${r} is not a vector. Line ${e.line}`);
                    if (l instanceof I) {
                        if (h.length > 1) return void console.error(`Invalid assignment to ${h} for variable ${r}. Line ${e.line}`);
                        if (h === "x") i.data[0] = l.value;
                        else if (h === "y") {
                            if (i.data.length < 2) return void console.error(`Invalid assignment to ${h} for variable ${r}. Line ${e.line}`);
                            i.data[1] = l.value;
                        } else if (h === "z") {
                            if (i.data.length < 3) return void console.error(`Invalid assignment to ${h} for variable ${r}. Line ${e.line}`);
                            i.data[2] = l.value;
                        } else if (h === "w") {
                            if (i.data.length < 4) return void console.error(`Invalid assignment to ${h} for variable ${r}. Line ${e.line}`);
                            i.data[3] = l.value;
                        }
                    } else {
                        if (!(l instanceof A)) return void console.error(`Invalid assignment to ${r}. Line ${e.line}`);
                        if (h.length !== l.data.length) return void console.error(`Invalid assignment to ${h} for variable ${r}. Line ${e.line}`);
                        for(let d = 0; d < h.length; ++d){
                            const p = h[d];
                            if (p === "x" || p === "r") i.data[0] = l.data[d];
                            else if (p === "y" || p === "g") {
                                if (l.data.length < 2) return void console.error(`Invalid assignment to ${p} for variable ${r}. Line ${e.line}`);
                                i.data[1] = l.data[d];
                            } else if (p === "z" || p === "b") {
                                if (l.data.length < 3) return void console.error(`Invalid assignment to ${p} for variable ${r}. Line ${e.line}`);
                                i.data[2] = l.data[d];
                            } else {
                                if (p !== "w" && p !== "a") return void console.error(`Invalid assignment to ${p} for variable ${r}. Line ${e.line}`);
                                if (l.data.length < 4) return void console.error(`Invalid assignment to ${p} for variable ${r}. Line ${e.line}`);
                                i.data[3] = l.data[d];
                            }
                        }
                    }
                }
            } else i instanceof I && l instanceof I ? i.value = l.value : i instanceof A && l instanceof A || i instanceof me && l instanceof me ? i.data.set(l.data) : console.error(`Invalid assignment to ${r}. Line ${e.line}`);
            else {
                const h = i.getSubData(this, a, t);
                if (h instanceof A && l instanceof I) {
                    const d = h.data, p = l.value;
                    if (u === "+=") for(let _ = 0; _ < d.length; ++_)d[_] += p;
                    else if (u === "-=") for(let _ = 0; _ < d.length; ++_)d[_] -= p;
                    else if (u === "*=") for(let _ = 0; _ < d.length; ++_)d[_] *= p;
                    else if (u === "/=") for(let _ = 0; _ < d.length; ++_)d[_] /= p;
                    else if (u === "%=") for(let _ = 0; _ < d.length; ++_)d[_] %= p;
                    else if (u === "&=") for(let _ = 0; _ < d.length; ++_)d[_] &= p;
                    else if (u === "|=") for(let _ = 0; _ < d.length; ++_)d[_] |= p;
                    else if (u === "^=") for(let _ = 0; _ < d.length; ++_)d[_] ^= p;
                    else if (u === "<<=") for(let _ = 0; _ < d.length; ++_)d[_] <<= p;
                    else if (u === ">>=") for(let _ = 0; _ < d.length; ++_)d[_] >>= p;
                    else console.error(`Invalid operator ${u}. Line ${e.line}`);
                } else if (h instanceof A && l instanceof A) {
                    const d = h.data, p = l.data;
                    if (d.length !== p.length) return void console.error(`Vector length mismatch. Line ${e.line}`);
                    if (u === "+=") for(let _ = 0; _ < d.length; ++_)d[_] += p[_];
                    else if (u === "-=") for(let _ = 0; _ < d.length; ++_)d[_] -= p[_];
                    else if (u === "*=") for(let _ = 0; _ < d.length; ++_)d[_] *= p[_];
                    else if (u === "/=") for(let _ = 0; _ < d.length; ++_)d[_] /= p[_];
                    else if (u === "%=") for(let _ = 0; _ < d.length; ++_)d[_] %= p[_];
                    else if (u === "&=") for(let _ = 0; _ < d.length; ++_)d[_] &= p[_];
                    else if (u === "|=") for(let _ = 0; _ < d.length; ++_)d[_] |= p[_];
                    else if (u === "^=") for(let _ = 0; _ < d.length; ++_)d[_] ^= p[_];
                    else if (u === "<<=") for(let _ = 0; _ < d.length; ++_)d[_] <<= p[_];
                    else if (u === ">>=") for(let _ = 0; _ < d.length; ++_)d[_] >>= p[_];
                    else console.error(`Invalid operator ${u}. Line ${e.line}`);
                } else {
                    if (!(h instanceof I && l instanceof I)) return void console.error(`Invalid type for ${e.operator} operator. Line ${e.line}`);
                    u === "+=" ? h.value += l.value : u === "-=" ? h.value -= l.value : u === "*=" ? h.value *= l.value : u === "/=" ? h.value /= l.value : u === "%=" ? h.value %= l.value : u === "&=" ? h.value &= l.value : u === "|=" ? h.value |= l.value : u === "^=" ? h.value ^= l.value : u === "<<=" ? h.value <<= l.value : u === ">>=" ? h.value >>= l.value : console.error(`Invalid operator ${u}. Line ${e.line}`);
                }
                i instanceof st && i.setDataValue(this, h, a, t);
            }
        }
        _function(e, t) {
            const i = new wg(e);
            t.functions.set(e.name, i);
        }
        _const(e, t) {
            let i = null;
            e.value !== null && (i = this.evalExpression(e.value, t)), t.createVariable(e.name, i, e);
        }
        _let(e, t) {
            let i = null;
            if (e.value !== null) {
                if (i = this.evalExpression(e.value, t), i === null) return void console.error(`Invalid value for variable ${e.name}. Line ${e.line}`);
                e.value instanceof ft || (i = i.clone());
            } else {
                const r = e.type.name;
                if (r === "f32" || r === "i32" || r === "u32" || r === "bool" || r === "f16" || r === "vec2" || r === "vec3" || r === "vec4" || r === "vec2f" || r === "vec3f" || r === "vec4f" || r === "vec2i" || r === "vec3i" || r === "vec4i" || r === "vec2u" || r === "vec3u" || r === "vec4u" || r === "vec2h" || r === "vec3h" || r === "vec4h" || r === "vec2b" || r === "vec3b" || r === "vec4b" || r === "mat2x2" || r === "mat2x3" || r === "mat2x4" || r === "mat3x2" || r === "mat3x3" || r === "mat3x4" || r === "mat4x2" || r === "mat4x3" || r === "mat4x4" || r === "mat2x2f" || r === "mat2x3f" || r === "mat2x4f" || r === "mat3x2f" || r === "mat3x3f" || r === "mat3x4f" || r === "mat4x2f" || r === "mat4x3f" || r === "mat4x4f" || r === "mat2x2h" || r === "mat2x3h" || r === "mat2x4h" || r === "mat3x2h" || r === "mat3x3h" || r === "mat3x4h" || r === "mat4x2h" || r === "mat4x3h" || r === "mat4x4h" || r === "array") {
                    const a = new Ln(e.type, []);
                    i = this._evalCreate(a, t);
                }
            }
            t.createVariable(e.name, i, e);
        }
        _var(e, t) {
            let i = null;
            if (e.value !== null) {
                if (i = this.evalExpression(e.value, t), i === null) return void console.error(`Invalid value for variable ${e.name}. Line ${e.line}`);
                e.value instanceof ft || (i = i.clone());
            } else {
                if (e.type === null) return void console.error(`Variable ${e.name} has no type. Line ${e.line}`);
                const r = e.type.name;
                if (r === "f32" || r === "i32" || r === "u32" || r === "bool" || r === "f16" || r === "vec2" || r === "vec3" || r === "vec4" || r === "vec2f" || r === "vec3f" || r === "vec4f" || r === "vec2i" || r === "vec3i" || r === "vec4i" || r === "vec2u" || r === "vec3u" || r === "vec4u" || r === "vec2h" || r === "vec3h" || r === "vec4h" || r === "vec2b" || r === "vec3b" || r === "vec4b" || r === "mat2x2" || r === "mat2x3" || r === "mat2x4" || r === "mat3x2" || r === "mat3x3" || r === "mat3x4" || r === "mat4x2" || r === "mat4x3" || r === "mat4x4" || r === "mat2x2f" || r === "mat2x3f" || r === "mat2x4f" || r === "mat3x2f" || r === "mat3x3f" || r === "mat3x4f" || r === "mat4x2f" || r === "mat4x3f" || r === "mat4x4f" || r === "mat2x2h" || r === "mat2x3h" || r === "mat2x4h" || r === "mat3x2h" || r === "mat3x3h" || r === "mat3x4h" || r === "mat4x2h" || r === "mat4x3h" || r === "mat4x4h" || e.type instanceof po || e.type instanceof ci || e.type instanceof k) {
                    const a = new Ln(e.type, []);
                    i = this._evalCreate(a, t);
                }
            }
            t.createVariable(e.name, i, e);
        }
        _switch(e, t) {
            t = t.clone();
            const i = this.evalExpression(e.condition, t);
            if (!(i instanceof I)) return console.error(`Invalid if condition. Line ${e.line}`), null;
            let r = null;
            for (const a of e.cases)if (a instanceof iT) for (const l of a.selectors){
                if (l instanceof gc) {
                    r = a;
                    continue;
                }
                const u = this.evalExpression(l, t);
                if (!(u instanceof I)) return console.error(`Invalid case selector. Line ${e.line}`), null;
                if (u.value === i.value) return this._execStatements(a.body, t);
            }
            else a instanceof rT && (r = a);
            return r ? this._execStatements(r.body, t) : null;
        }
        _if(e, t) {
            t = t.clone();
            const i = this.evalExpression(e.condition, t);
            if (!(i instanceof I)) return console.error(`Invalid if condition. Line ${e.line}`), null;
            if (i.value) return this._execStatements(e.body, t);
            for (const r of e.elseif){
                const a = this.evalExpression(r.condition, t);
                if (!(a instanceof I)) return console.error(`Invalid if condition. Line ${e.line}`), null;
                if (a.value) return this._execStatements(r.body, t);
            }
            return e.else ? this._execStatements(e.else, t) : null;
        }
        _getScalarValue(e) {
            return e instanceof I ? e.value : (console.error("Expected scalar value.", e), 0);
        }
        _for(e, t) {
            for(t = t.clone(), this.execStatement(e.init, t); this._getScalarValue(this.evalExpression(e.condition, t));){
                const i = this._execStatements(e.body, t);
                if (i === Ot._breakObj) break;
                if (i !== null && i !== Ot._continueObj) return i;
                this.execStatement(e.increment, t);
            }
            return null;
        }
        _loop(e, t) {
            for(t = t.clone();;){
                const i = this._execStatements(e.body, t);
                if (i === Ot._breakObj) break;
                if (i === Ot._continueObj) {
                    if (e.continuing && this._execStatements(e.continuing.body, t) === Ot._breakObj) break;
                } else if (i !== null) return i;
            }
            return null;
        }
        _while(e, t) {
            for(t = t.clone(); this._getScalarValue(this.evalExpression(e.condition, t));){
                const i = this._execStatements(e.body, t);
                if (i === Ot._breakObj) break;
                if (i !== Ot._continueObj && i !== null) return i;
            }
            return null;
        }
        _evalBitcast(e, t) {
            const i = this.evalExpression(e.value, t), r = e.type;
            if (i instanceof I) {
                const a = Gb(i.value, i.typeInfo.name, r.name);
                return new I(a, this.getTypeInfo(r));
            }
            if (i instanceof A) {
                const a = i.typeInfo.getTypeName();
                let l = "";
                if (a.endsWith("f")) l = "f32";
                else if (a.endsWith("i")) l = "i32";
                else if (a.endsWith("u")) l = "u32";
                else if (a.endsWith("b")) l = "bool";
                else {
                    if (!a.endsWith("h")) return console.error(`Unknown vector type ${a}. Line ${e.line}`), null;
                    l = "f16";
                }
                const u = r.getTypeName();
                let h = "";
                if (u.endsWith("f")) h = "f32";
                else if (u.endsWith("i")) h = "i32";
                else if (u.endsWith("u")) h = "u32";
                else if (u.endsWith("b")) h = "bool";
                else {
                    if (!u.endsWith("h")) return console.error(`Unknown vector type ${h}. Line ${e.line}`), null;
                    h = "f16";
                }
                const d = function(p, _, y) {
                    if (_ === y) return p;
                    const v = new Array(p.length);
                    for(let S = 0; S < p.length; S++)v[S] = Gb(p[S], _, y);
                    return v;
                }(Array.from(i.data), l, h);
                return new A(d, this.getTypeInfo(r));
            }
            return console.error(`TODO: bitcast for ${i.typeInfo.name}. Line ${e.line}`), null;
        }
        _evalConst(e, t) {
            return t.getVariableValue(e.name).clone().getSubData(this, e.postfix, t);
        }
        _evalCreate(e, t) {
            var i;
            if (e instanceof Ln) {
                if (e.type === null) return Rd.void;
                switch(e.type.getTypeName()){
                    case "bool":
                    case "i32":
                    case "u32":
                    case "f32":
                    case "f16":
                        return this._callConstructorValue(e, t);
                    case "vec2":
                    case "vec3":
                    case "vec4":
                    case "vec2f":
                    case "vec3f":
                    case "vec4f":
                    case "vec2h":
                    case "vec3h":
                    case "vec4h":
                    case "vec2i":
                    case "vec3i":
                    case "vec4i":
                    case "vec2u":
                    case "vec3u":
                    case "vec4u":
                    case "vec2b":
                    case "vec3b":
                    case "vec4b":
                        return this._callConstructorVec(e, t);
                    case "mat2x2":
                    case "mat2x2f":
                    case "mat2x2h":
                    case "mat2x3":
                    case "mat2x3f":
                    case "mat2x3h":
                    case "mat2x4":
                    case "mat2x4f":
                    case "mat2x4h":
                    case "mat3x2":
                    case "mat3x2f":
                    case "mat3x2h":
                    case "mat3x3":
                    case "mat3x3f":
                    case "mat3x3h":
                    case "mat3x4":
                    case "mat3x4f":
                    case "mat3x4h":
                    case "mat4x2":
                    case "mat4x2f":
                    case "mat4x2h":
                    case "mat4x3":
                    case "mat4x3f":
                    case "mat4x3h":
                    case "mat4x4":
                    case "mat4x4f":
                    case "mat4x4h":
                        return this._callConstructorMatrix(e, t);
                }
            }
            const r = e instanceof Ln ? e.type.name : e.name, a = e instanceof Ln ? this.getTypeInfo(e.type) : this.getTypeInfo(e.name);
            if (a === null) return console.error(`Unknown type ${r}. Line ${e.line}`), null;
            if (a.size === 0) return null;
            const l = new st(new ArrayBuffer(a.size), a, 0);
            if (a instanceof $i) {
                if (e.args) for(let u = 0; u < e.args.length; ++u){
                    const h = a.members[u], d = e.args[u], p = this.evalExpression(d, t);
                    l.setData(this, p, h.type, h.offset, t);
                }
            } else if (a instanceof Ki) {
                let u = 0;
                if (e.args) for(let h = 0; h < e.args.length; ++h){
                    const d = e.args[h], p = this.evalExpression(d, t);
                    a.format === null && (((i = p.typeInfo) === null || i === void 0 ? void 0 : i.name) === "x32" ? a.format = this.getTypeInfo("i32") : a.format = p.typeInfo), l.setData(this, p, a.format, u, t), u += a.stride;
                }
            } else console.error(`Unknown type "${r}". Line ${e.line}`);
            return e instanceof Ln ? l.getSubData(this, e.postfix, t) : l;
        }
        _evalLiteral(e, t) {
            const i = this.getTypeInfo(e.type), r = i.name;
            return r === "x32" || r === "u32" || r === "f32" || r === "f16" || r === "i32" || r === "bool" ? new I(e.scalarValue, i) : r === "vec2" || r === "vec3" || r === "vec4" || r === "vec2f" || r === "vec3f" || r === "vec4f" || r === "vec2h" || r === "vec3h" || r === "vec4h" || r === "vec2i" || r === "vec3i" || r === "vec4i" || r === "vec2u" || r === "vec3u" || r === "vec4u" ? this._callConstructorVec(e, t) : r === "mat2x2" || r === "mat2x3" || r === "mat2x4" || r === "mat3x2" || r === "mat3x3" || r === "mat3x4" || r === "mat4x2" || r === "mat4x3" || r === "mat4x4" || r === "mat2x2f" || r === "mat2x3f" || r === "mat2x4f" || r === "mat3x2f" || r === "mat3x3f" || r === "mat3x4f" || r === "mat4x2f" || r === "mat4x3f" || r === "mat4x4f" || r === "mat2x2h" || r === "mat2x3h" || r === "mat2x4h" || r === "mat3x2h" || r === "mat3x3h" || r === "mat3x4h" || r === "mat4x2h" || r === "mat4x3h" || r === "mat4x4h" ? this._callConstructorMatrix(e, t) : e.value;
        }
        _evalVariable(e, t) {
            const i = t.getVariableValue(e.name);
            return i === null ? i : i.getSubData(this, e.postfix, t);
        }
        _maxFormatTypeInfo(e) {
            let t = e[0];
            if (t.name === "f32") return t;
            for(let i = 1; i < e.length; ++i){
                const r = Ot._priority.get(t.name);
                Ot._priority.get(e[i].name) < r && (t = e[i]);
            }
            return t.name === "x32" ? this.getTypeInfo("i32") : t;
        }
        _evalUnaryOp(e, t) {
            const i = this.evalExpression(e.right, t);
            if (e.operator === "&") return new Cs(i);
            if (e.operator === "*") return i instanceof Cs ? i.reference.getSubData(this, e.postfix, t) : (console.error(`Invalid dereference. Line ${e.line}`), null);
            const r = i instanceof I ? i.value : i instanceof A ? Array.from(i.data) : null;
            switch(e.operator){
                case "+":
                    {
                        if (ie(r)) {
                            const u = r.map((h, d)=>+h);
                            return new A(u, i.typeInfo);
                        }
                        const a = r, l = this._maxFormatTypeInfo([
                            i.typeInfo,
                            i.typeInfo
                        ]);
                        return new I(+a, l);
                    }
                case "-":
                    {
                        if (ie(r)) {
                            const u = r.map((h, d)=>-h);
                            return new A(u, i.typeInfo);
                        }
                        const a = r, l = this._maxFormatTypeInfo([
                            i.typeInfo,
                            i.typeInfo
                        ]);
                        return new I(-a, l);
                    }
                case "!":
                    {
                        if (ie(r)) {
                            const u = r.map((h, d)=>h ? 0 : 1);
                            return new A(u, i.typeInfo);
                        }
                        const a = r, l = this._maxFormatTypeInfo([
                            i.typeInfo,
                            i.typeInfo
                        ]);
                        return new I(a ? 0 : 1, l);
                    }
                case "~":
                    {
                        if (ie(r)) {
                            const u = r.map((h, d)=>~h);
                            return new A(u, i.typeInfo);
                        }
                        const a = r, l = this._maxFormatTypeInfo([
                            i.typeInfo,
                            i.typeInfo
                        ]);
                        return new I(~a, l);
                    }
            }
            return console.error(`Invalid unary operator ${e.operator}. Line ${e.line}`), null;
        }
        _evalBinaryOp(e, t) {
            const i = this.evalExpression(e.left, t), r = this.evalExpression(e.right, t), a = i instanceof I ? i.value : i instanceof A || i instanceof me ? Array.from(i.data) : null, l = r instanceof I ? r.value : r instanceof A || r instanceof me ? Array.from(r.data) : null;
            switch(e.operator){
                case "+":
                    {
                        if (ie(a) && ie(l)) {
                            const p = a, _ = l;
                            if (p.length !== _.length) return console.error(`Vector length mismatch. Line ${e.line}.`), null;
                            const y = p.map((v, S)=>v + _[S]);
                            return new A(y, i.typeInfo);
                        }
                        if (ie(a)) {
                            const p = l, _ = a.map((y, v)=>y + p);
                            return new A(_, i.typeInfo);
                        }
                        if (ie(l)) {
                            const p = a, _ = l.map((y, v)=>p + y);
                            return new A(_, r.typeInfo);
                        }
                        const u = a, h = l, d = this._maxFormatTypeInfo([
                            i.typeInfo,
                            r.typeInfo
                        ]);
                        return new I(u + h, d);
                    }
                case "-":
                    {
                        if (ie(a) && ie(l)) {
                            const p = a, _ = l;
                            if (p.length !== _.length) return console.error(`Vector length mismatch. Line ${e.line}.`), null;
                            const y = p.map((v, S)=>v - _[S]);
                            return new A(y, i.typeInfo);
                        }
                        if (ie(a)) {
                            const p = l, _ = a.map((y, v)=>y - p);
                            return new A(_, i.typeInfo);
                        }
                        if (ie(l)) {
                            const p = a, _ = l.map((y, v)=>p - y);
                            return new A(_, r.typeInfo);
                        }
                        const u = a, h = l, d = this._maxFormatTypeInfo([
                            i.typeInfo,
                            r.typeInfo
                        ]);
                        return new I(u - h, d);
                    }
                case "*":
                    {
                        if (ie(a) && ie(l)) {
                            const p = a, _ = l;
                            if (i instanceof me && r instanceof me) {
                                const y = function(M, B, H, O) {
                                    if (Ut[B.name] === void 0 || Ut[O.name] === void 0) return null;
                                    const U = Ut[B.name][0], L = Ut[B.name][1], Z = Ut[O.name][0];
                                    if (U !== Ut[O.name][1]) return null;
                                    const se = new Array(Z * L);
                                    for(let ae = 0; ae < L; ae++)for(let te = 0; te < Z; te++){
                                        let fe = 0;
                                        for(let ne = 0; ne < U; ne++)fe += M[ne * L + ae] * H[te * U + ne];
                                        se[ae * Z + te] = fe;
                                    }
                                    return se;
                                }(p, i.typeInfo, _, r.typeInfo);
                                if (y === null) return console.error(`Matrix multiplication failed. Line ${e.line}.`), null;
                                const v = Ut[r.typeInfo.name][0], S = Ut[i.typeInfo.name][1], E = this.getTypeInfo(`mat${v}x${S}f`);
                                return new me(y, E);
                            }
                            if (i instanceof me && r instanceof A) {
                                const y = function(v, S, E, M) {
                                    if (Ut[S.name] === void 0 || Wh[M.name] === void 0) return null;
                                    const B = Ut[S.name][0], H = Ut[S.name][1];
                                    if (B !== E.length) return null;
                                    const O = new Array(H);
                                    for(let U = 0; U < H; U++){
                                        let L = 0;
                                        for(let Z = 0; Z < B; Z++)L += v[Z * H + U] * E[Z];
                                        O[U] = L;
                                    }
                                    return O;
                                }(p, i.typeInfo, _, r.typeInfo);
                                return y === null ? (console.error(`Matrix vector multiplication failed. Line ${e.line}.`), null) : new A(y, r.typeInfo);
                            }
                            if (i instanceof A && r instanceof me) {
                                const y = function(v, S, E, M) {
                                    if (Wh[S.name] === void 0 || Ut[M.name] === void 0) return null;
                                    const B = Ut[M.name][0], H = Ut[M.name][1];
                                    if (H !== v.length) return null;
                                    const O = [];
                                    for(let U = 0; U < B; U++){
                                        let L = 0;
                                        for(let Z = 0; Z < H; Z++)L += v[Z] * E[Z * B + U];
                                        O[U] = L;
                                    }
                                    return O;
                                }(p, i.typeInfo, _, r.typeInfo);
                                return y === null ? (console.error(`Matrix vector multiplication failed. Line ${e.line}.`), null) : new A(y, i.typeInfo);
                            }
                            {
                                if (p.length !== _.length) return console.error(`Vector length mismatch. Line ${e.line}.`), null;
                                const y = p.map((v, S)=>v * _[S]);
                                return new A(y, i.typeInfo);
                            }
                        }
                        if (ie(a)) {
                            const p = l, _ = a.map((y, v)=>y * p);
                            return i instanceof me ? new me(_, i.typeInfo) : new A(_, i.typeInfo);
                        }
                        if (ie(l)) {
                            const p = a, _ = l.map((y, v)=>p * y);
                            return r instanceof me ? new me(_, r.typeInfo) : new A(_, r.typeInfo);
                        }
                        const u = a, h = l, d = this._maxFormatTypeInfo([
                            i.typeInfo,
                            r.typeInfo
                        ]);
                        return new I(u * h, d);
                    }
                case "%":
                    {
                        if (ie(a) && ie(l)) {
                            const p = a, _ = l;
                            if (p.length !== _.length) return console.error(`Vector length mismatch. Line ${e.line}.`), null;
                            const y = p.map((v, S)=>v % _[S]);
                            return new A(y, i.typeInfo);
                        }
                        if (ie(a)) {
                            const p = l, _ = a.map((y, v)=>y % p);
                            return new A(_, i.typeInfo);
                        }
                        if (ie(l)) {
                            const p = a, _ = l.map((y, v)=>p % y);
                            return new A(_, r.typeInfo);
                        }
                        const u = a, h = l, d = this._maxFormatTypeInfo([
                            i.typeInfo,
                            r.typeInfo
                        ]);
                        return new I(u % h, d);
                    }
                case "/":
                    {
                        if (ie(a) && ie(l)) {
                            const p = a, _ = l;
                            if (p.length !== _.length) return console.error(`Vector length mismatch. Line ${e.line}.`), null;
                            const y = p.map((v, S)=>v / _[S]);
                            return new A(y, i.typeInfo);
                        }
                        if (ie(a)) {
                            const p = l, _ = a.map((y, v)=>y / p);
                            return new A(_, i.typeInfo);
                        }
                        if (ie(l)) {
                            const p = a, _ = l.map((y, v)=>p / y);
                            return new A(_, r.typeInfo);
                        }
                        const u = a, h = l, d = this._maxFormatTypeInfo([
                            i.typeInfo,
                            r.typeInfo
                        ]);
                        return new I(u / h, d);
                    }
                case "&":
                    {
                        if (ie(a) && ie(l)) {
                            const p = a, _ = l;
                            if (p.length !== _.length) return console.error(`Vector length mismatch. Line ${e.line}.`), null;
                            const y = p.map((v, S)=>v & _[S]);
                            return new A(y, i.typeInfo);
                        }
                        if (ie(a)) {
                            const p = l, _ = a.map((y, v)=>y & p);
                            return new A(_, i.typeInfo);
                        }
                        if (ie(l)) {
                            const p = a, _ = l.map((y, v)=>p & y);
                            return new A(_, r.typeInfo);
                        }
                        const u = a, h = l, d = this._maxFormatTypeInfo([
                            i.typeInfo,
                            r.typeInfo
                        ]);
                        return new I(u & h, d);
                    }
                case "|":
                    {
                        if (ie(a) && ie(l)) {
                            const p = a, _ = l;
                            if (p.length !== _.length) return console.error(`Vector length mismatch. Line ${e.line}.`), null;
                            const y = p.map((v, S)=>v | _[S]);
                            return new A(y, i.typeInfo);
                        }
                        if (ie(a)) {
                            const p = l, _ = a.map((y, v)=>y | p);
                            return new A(_, i.typeInfo);
                        }
                        if (ie(l)) {
                            const p = a, _ = l.map((y, v)=>p | y);
                            return new A(_, r.typeInfo);
                        }
                        const u = a, h = l, d = this._maxFormatTypeInfo([
                            i.typeInfo,
                            r.typeInfo
                        ]);
                        return new I(u | h, d);
                    }
                case "^":
                    {
                        if (ie(a) && ie(l)) {
                            const p = a, _ = l;
                            if (p.length !== _.length) return console.error(`Vector length mismatch. Line ${e.line}.`), null;
                            const y = p.map((v, S)=>v ^ _[S]);
                            return new A(y, i.typeInfo);
                        }
                        if (ie(a)) {
                            const p = l, _ = a.map((y, v)=>y ^ p);
                            return new A(_, i.typeInfo);
                        }
                        if (ie(l)) {
                            const p = a, _ = l.map((y, v)=>p ^ y);
                            return new A(_, r.typeInfo);
                        }
                        const u = a, h = l, d = this._maxFormatTypeInfo([
                            i.typeInfo,
                            r.typeInfo
                        ]);
                        return new I(u ^ h, d);
                    }
                case "<<":
                    {
                        if (ie(a) && ie(l)) {
                            const p = a, _ = l;
                            if (p.length !== _.length) return console.error(`Vector length mismatch. Line ${e.line}.`), null;
                            const y = p.map((v, S)=>v << _[S]);
                            return new A(y, i.typeInfo);
                        }
                        if (ie(a)) {
                            const p = l, _ = a.map((y, v)=>y << p);
                            return new A(_, i.typeInfo);
                        }
                        if (ie(l)) {
                            const p = a, _ = l.map((y, v)=>p << y);
                            return new A(_, r.typeInfo);
                        }
                        const u = a, h = l, d = this._maxFormatTypeInfo([
                            i.typeInfo,
                            r.typeInfo
                        ]);
                        return new I(u << h, d);
                    }
                case ">>":
                    {
                        if (ie(a) && ie(l)) {
                            const p = a, _ = l;
                            if (p.length !== _.length) return console.error(`Vector length mismatch. Line ${e.line}.`), null;
                            const y = p.map((v, S)=>v >> _[S]);
                            return new A(y, i.typeInfo);
                        }
                        if (ie(a)) {
                            const p = l, _ = a.map((y, v)=>y >> p);
                            return new A(_, i.typeInfo);
                        }
                        if (ie(l)) {
                            const p = a, _ = l.map((y, v)=>p >> y);
                            return new A(_, r.typeInfo);
                        }
                        const u = a, h = l, d = this._maxFormatTypeInfo([
                            i.typeInfo,
                            r.typeInfo
                        ]);
                        return new I(u >> h, d);
                    }
                case ">":
                    if (ie(a) && ie(l)) {
                        const u = a, h = l;
                        if (u.length !== h.length) return console.error(`Vector length mismatch. Line ${e.line}.`), null;
                        const d = u.map((p, _)=>p > h[_] ? 1 : 0);
                        return new A(d, i.typeInfo);
                    }
                    if (ie(a)) {
                        const u = l, h = a.map((d, p)=>d > u ? 1 : 0);
                        return new A(h, i.typeInfo);
                    }
                    if (ie(l)) {
                        const u = a, h = l.map((d, p)=>u > d ? 1 : 0);
                        return new A(h, r.typeInfo);
                    }
                    return new I(a > l ? 1 : 0, this.getTypeInfo("bool"));
                case "<":
                    if (ie(a) && ie(l)) {
                        const u = a, h = l;
                        if (u.length !== h.length) return console.error(`Vector length mismatch. Line ${e.line}.`), null;
                        const d = u.map((p, _)=>p < h[_] ? 1 : 0);
                        return new A(d, i.typeInfo);
                    }
                    if (ie(a)) {
                        const u = l, h = a.map((d, p)=>d < u ? 1 : 0);
                        return new A(h, i.typeInfo);
                    }
                    if (ie(l)) {
                        const u = a, h = l.map((d, p)=>u < d ? 1 : 0);
                        return new A(h, r.typeInfo);
                    }
                    return new I(a < l ? 1 : 0, this.getTypeInfo("bool"));
                case "==":
                    if (ie(a) && ie(l)) {
                        const u = a, h = l;
                        if (u.length !== h.length) return console.error(`Vector length mismatch. Line ${e.line}.`), null;
                        const d = u.map((p, _)=>p === h[_] ? 1 : 0);
                        return new A(d, i.typeInfo);
                    }
                    if (ie(a)) {
                        const u = l, h = a.map((d, p)=>d == u ? 1 : 0);
                        return new A(h, i.typeInfo);
                    }
                    if (ie(l)) {
                        const u = a, h = l.map((d, p)=>u == d ? 1 : 0);
                        return new A(h, r.typeInfo);
                    }
                    return new I(a === l ? 1 : 0, this.getTypeInfo("bool"));
                case "!=":
                    if (ie(a) && ie(l)) {
                        const u = a, h = l;
                        if (u.length !== h.length) return console.error(`Vector length mismatch. Line ${e.line}.`), null;
                        const d = u.map((p, _)=>p !== h[_] ? 1 : 0);
                        return new A(d, i.typeInfo);
                    }
                    if (ie(a)) {
                        const u = l, h = a.map((d, p)=>d !== u ? 1 : 0);
                        return new A(h, i.typeInfo);
                    }
                    if (ie(l)) {
                        const u = a, h = l.map((d, p)=>u !== d ? 1 : 0);
                        return new A(h, r.typeInfo);
                    }
                    return new I(a !== l ? 1 : 0, this.getTypeInfo("bool"));
                case ">=":
                    if (ie(a) && ie(l)) {
                        const u = a, h = l;
                        if (u.length !== h.length) return console.error(`Vector length mismatch. Line ${e.line}.`), null;
                        const d = u.map((p, _)=>p >= h[_] ? 1 : 0);
                        return new A(d, i.typeInfo);
                    }
                    if (ie(a)) {
                        const u = l, h = a.map((d, p)=>d >= u ? 1 : 0);
                        return new A(h, i.typeInfo);
                    }
                    if (ie(l)) {
                        const u = a, h = l.map((d, p)=>u >= d ? 1 : 0);
                        return new A(h, r.typeInfo);
                    }
                    return new I(a >= l ? 1 : 0, this.getTypeInfo("bool"));
                case "<=":
                    if (ie(a) && ie(l)) {
                        const u = a, h = l;
                        if (u.length !== h.length) return console.error(`Vector length mismatch. Line ${e.line}.`), null;
                        const d = u.map((p, _)=>p <= h[_] ? 1 : 0);
                        return new A(d, i.typeInfo);
                    }
                    if (ie(a)) {
                        const u = l, h = a.map((d, p)=>d <= u ? 1 : 0);
                        return new A(h, i.typeInfo);
                    }
                    if (ie(l)) {
                        const u = a, h = l.map((d, p)=>u <= d ? 1 : 0);
                        return new A(h, r.typeInfo);
                    }
                    return new I(a <= l ? 1 : 0, this.getTypeInfo("bool"));
                case "&&":
                    if (ie(a) && ie(l)) {
                        const u = a, h = l;
                        if (u.length !== h.length) return console.error(`Vector length mismatch. Line ${e.line}.`), null;
                        const d = u.map((p, _)=>p && h[_] ? 1 : 0);
                        return new A(d, i.typeInfo);
                    }
                    if (ie(a)) {
                        const u = l, h = a.map((d, p)=>d && u ? 1 : 0);
                        return new A(h, i.typeInfo);
                    }
                    if (ie(l)) {
                        const u = a, h = l.map((d, p)=>u && d ? 1 : 0);
                        return new A(h, r.typeInfo);
                    }
                    return new I(a && l ? 1 : 0, this.getTypeInfo("bool"));
                case "||":
                    if (ie(a) && ie(l)) {
                        const u = a, h = l;
                        if (u.length !== h.length) return console.error(`Vector length mismatch. Line ${e.line}.`), null;
                        const d = u.map((p, _)=>p || h[_] ? 1 : 0);
                        return new A(d, i.typeInfo);
                    }
                    if (ie(a)) {
                        const u = l, h = a.map((d, p)=>d || u ? 1 : 0);
                        return new A(h, i.typeInfo);
                    }
                    if (ie(l)) {
                        const u = a, h = l.map((d, p)=>u || d ? 1 : 0);
                        return new A(h, r.typeInfo);
                    }
                    return new I(a || l ? 1 : 0, this.getTypeInfo("bool"));
            }
            return console.error(`Unknown operator ${e.operator}. Line ${e.line}`), null;
        }
        _evalCall(e, t) {
            if (e.cachedReturnValue !== null) return e.cachedReturnValue;
            const i = t.clone();
            i.currentFunctionName = e.name;
            const r = t.getFunction(e.name);
            if (!r) return e.isBuiltin ? this._callBuiltinFunction(e, i) : this.getTypeInfo(e.name) ? this._evalCreate(e, t) : (console.error(`Unknown function "${e.name}". Line ${e.line}`), null);
            for(let a = 0; a < r.node.args.length; ++a){
                const l = r.node.args[a], u = this.evalExpression(e.args[a], i);
                i.createVariable(l.name, u, l);
            }
            return this._execStatements(r.node.body, i);
        }
        _callBuiltinFunction(e, t) {
            switch(e.name){
                case "all":
                    return this.builtins.All(e, t);
                case "any":
                    return this.builtins.Any(e, t);
                case "select":
                    return this.builtins.Select(e, t);
                case "arrayLength":
                    return this.builtins.ArrayLength(e, t);
                case "abs":
                    return this.builtins.Abs(e, t);
                case "acos":
                    return this.builtins.Acos(e, t);
                case "acosh":
                    return this.builtins.Acosh(e, t);
                case "asin":
                    return this.builtins.Asin(e, t);
                case "asinh":
                    return this.builtins.Asinh(e, t);
                case "atan":
                    return this.builtins.Atan(e, t);
                case "atanh":
                    return this.builtins.Atanh(e, t);
                case "atan2":
                    return this.builtins.Atan2(e, t);
                case "ceil":
                    return this.builtins.Ceil(e, t);
                case "clamp":
                    return this.builtins.Clamp(e, t);
                case "cos":
                    return this.builtins.Cos(e, t);
                case "cosh":
                    return this.builtins.Cosh(e, t);
                case "countLeadingZeros":
                    return this.builtins.CountLeadingZeros(e, t);
                case "countOneBits":
                    return this.builtins.CountOneBits(e, t);
                case "countTrailingZeros":
                    return this.builtins.CountTrailingZeros(e, t);
                case "cross":
                    return this.builtins.Cross(e, t);
                case "degrees":
                    return this.builtins.Degrees(e, t);
                case "determinant":
                    return this.builtins.Determinant(e, t);
                case "distance":
                    return this.builtins.Distance(e, t);
                case "dot":
                    return this.builtins.Dot(e, t);
                case "dot4U8Packed":
                    return this.builtins.Dot4U8Packed(e, t);
                case "dot4I8Packed":
                    return this.builtins.Dot4I8Packed(e, t);
                case "exp":
                    return this.builtins.Exp(e, t);
                case "exp2":
                    return this.builtins.Exp2(e, t);
                case "extractBits":
                    return this.builtins.ExtractBits(e, t);
                case "faceForward":
                    return this.builtins.FaceForward(e, t);
                case "firstLeadingBit":
                    return this.builtins.FirstLeadingBit(e, t);
                case "firstTrailingBit":
                    return this.builtins.FirstTrailingBit(e, t);
                case "floor":
                    return this.builtins.Floor(e, t);
                case "fma":
                    return this.builtins.Fma(e, t);
                case "fract":
                    return this.builtins.Fract(e, t);
                case "frexp":
                    return this.builtins.Frexp(e, t);
                case "insertBits":
                    return this.builtins.InsertBits(e, t);
                case "inverseSqrt":
                    return this.builtins.InverseSqrt(e, t);
                case "ldexp":
                    return this.builtins.Ldexp(e, t);
                case "length":
                    return this.builtins.Length(e, t);
                case "log":
                    return this.builtins.Log(e, t);
                case "log2":
                    return this.builtins.Log2(e, t);
                case "max":
                    return this.builtins.Max(e, t);
                case "min":
                    return this.builtins.Min(e, t);
                case "mix":
                    return this.builtins.Mix(e, t);
                case "modf":
                    return this.builtins.Modf(e, t);
                case "normalize":
                    return this.builtins.Normalize(e, t);
                case "pow":
                    return this.builtins.Pow(e, t);
                case "quantizeToF16":
                    return this.builtins.QuantizeToF16(e, t);
                case "radians":
                    return this.builtins.Radians(e, t);
                case "reflect":
                    return this.builtins.Reflect(e, t);
                case "refract":
                    return this.builtins.Refract(e, t);
                case "reverseBits":
                    return this.builtins.ReverseBits(e, t);
                case "round":
                    return this.builtins.Round(e, t);
                case "saturate":
                    return this.builtins.Saturate(e, t);
                case "sign":
                    return this.builtins.Sign(e, t);
                case "sin":
                    return this.builtins.Sin(e, t);
                case "sinh":
                    return this.builtins.Sinh(e, t);
                case "smoothStep":
                    return this.builtins.SmoothStep(e, t);
                case "sqrt":
                    return this.builtins.Sqrt(e, t);
                case "step":
                    return this.builtins.Step(e, t);
                case "tan":
                    return this.builtins.Tan(e, t);
                case "tanh":
                    return this.builtins.Tanh(e, t);
                case "transpose":
                    return this.builtins.Transpose(e, t);
                case "trunc":
                    return this.builtins.Trunc(e, t);
                case "dpdx":
                    return this.builtins.Dpdx(e, t);
                case "dpdxCoarse":
                    return this.builtins.DpdxCoarse(e, t);
                case "dpdxFine":
                    return this.builtins.DpdxFine(e, t);
                case "dpdy":
                    return this.builtins.Dpdy(e, t);
                case "dpdyCoarse":
                    return this.builtins.DpdyCoarse(e, t);
                case "dpdyFine":
                    return this.builtins.DpdyFine(e, t);
                case "fwidth":
                    return this.builtins.Fwidth(e, t);
                case "fwidthCoarse":
                    return this.builtins.FwidthCoarse(e, t);
                case "fwidthFine":
                    return this.builtins.FwidthFine(e, t);
                case "textureDimensions":
                    return this.builtins.TextureDimensions(e, t);
                case "textureGather":
                    return this.builtins.TextureGather(e, t);
                case "textureGatherCompare":
                    return this.builtins.TextureGatherCompare(e, t);
                case "textureLoad":
                    return this.builtins.TextureLoad(e, t);
                case "textureNumLayers":
                    return this.builtins.TextureNumLayers(e, t);
                case "textureNumLevels":
                    return this.builtins.TextureNumLevels(e, t);
                case "textureNumSamples":
                    return this.builtins.TextureNumSamples(e, t);
                case "textureSample":
                    return this.builtins.TextureSample(e, t);
                case "textureSampleBias":
                    return this.builtins.TextureSampleBias(e, t);
                case "textureSampleCompare":
                    return this.builtins.TextureSampleCompare(e, t);
                case "textureSampleCompareLevel":
                    return this.builtins.TextureSampleCompareLevel(e, t);
                case "textureSampleGrad":
                    return this.builtins.TextureSampleGrad(e, t);
                case "textureSampleLevel":
                    return this.builtins.TextureSampleLevel(e, t);
                case "textureSampleBaseClampToEdge":
                    return this.builtins.TextureSampleBaseClampToEdge(e, t);
                case "textureStore":
                    return this.builtins.TextureStore(e, t);
                case "atomicLoad":
                    return this.builtins.AtomicLoad(e, t);
                case "atomicStore":
                    return this.builtins.AtomicStore(e, t);
                case "atomicAdd":
                    return this.builtins.AtomicAdd(e, t);
                case "atomicSub":
                    return this.builtins.AtomicSub(e, t);
                case "atomicMax":
                    return this.builtins.AtomicMax(e, t);
                case "atomicMin":
                    return this.builtins.AtomicMin(e, t);
                case "atomicAnd":
                    return this.builtins.AtomicAnd(e, t);
                case "atomicOr":
                    return this.builtins.AtomicOr(e, t);
                case "atomicXor":
                    return this.builtins.AtomicXor(e, t);
                case "atomicExchange":
                    return this.builtins.AtomicExchange(e, t);
                case "atomicCompareExchangeWeak":
                    return this.builtins.AtomicCompareExchangeWeak(e, t);
                case "pack4x8snorm":
                    return this.builtins.Pack4x8snorm(e, t);
                case "pack4x8unorm":
                    return this.builtins.Pack4x8unorm(e, t);
                case "pack4xI8":
                    return this.builtins.Pack4xI8(e, t);
                case "pack4xU8":
                    return this.builtins.Pack4xU8(e, t);
                case "pack4x8Clamp":
                    return this.builtins.Pack4x8Clamp(e, t);
                case "pack4xU8Clamp":
                    return this.builtins.Pack4xU8Clamp(e, t);
                case "pack2x16snorm":
                    return this.builtins.Pack2x16snorm(e, t);
                case "pack2x16unorm":
                    return this.builtins.Pack2x16unorm(e, t);
                case "pack2x16float":
                    return this.builtins.Pack2x16float(e, t);
                case "unpack4x8snorm":
                    return this.builtins.Unpack4x8snorm(e, t);
                case "unpack4x8unorm":
                    return this.builtins.Unpack4x8unorm(e, t);
                case "unpack4xI8":
                    return this.builtins.Unpack4xI8(e, t);
                case "unpack4xU8":
                    return this.builtins.Unpack4xU8(e, t);
                case "unpack2x16snorm":
                    return this.builtins.Unpack2x16snorm(e, t);
                case "unpack2x16unorm":
                    return this.builtins.Unpack2x16unorm(e, t);
                case "unpack2x16float":
                    return this.builtins.Unpack2x16float(e, t);
                case "storageBarrier":
                    return this.builtins.StorageBarrier(e, t);
                case "textureBarrier":
                    return this.builtins.TextureBarrier(e, t);
                case "workgroupBarrier":
                    return this.builtins.WorkgroupBarrier(e, t);
                case "workgroupUniformLoad":
                    return this.builtins.WorkgroupUniformLoad(e, t);
                case "subgroupAdd":
                    return this.builtins.SubgroupAdd(e, t);
                case "subgroupExclusiveAdd":
                    return this.builtins.SubgroupExclusiveAdd(e, t);
                case "subgroupInclusiveAdd":
                    return this.builtins.SubgroupInclusiveAdd(e, t);
                case "subgroupAll":
                    return this.builtins.SubgroupAll(e, t);
                case "subgroupAnd":
                    return this.builtins.SubgroupAnd(e, t);
                case "subgroupAny":
                    return this.builtins.SubgroupAny(e, t);
                case "subgroupBallot":
                    return this.builtins.SubgroupBallot(e, t);
                case "subgroupBroadcast":
                    return this.builtins.SubgroupBroadcast(e, t);
                case "subgroupBroadcastFirst":
                    return this.builtins.SubgroupBroadcastFirst(e, t);
                case "subgroupElect":
                    return this.builtins.SubgroupElect(e, t);
                case "subgroupMax":
                    return this.builtins.SubgroupMax(e, t);
                case "subgroupMin":
                    return this.builtins.SubgroupMin(e, t);
                case "subgroupMul":
                    return this.builtins.SubgroupMul(e, t);
                case "subgroupExclusiveMul":
                    return this.builtins.SubgroupExclusiveMul(e, t);
                case "subgroupInclusiveMul":
                    return this.builtins.SubgroupInclusiveMul(e, t);
                case "subgroupOr":
                    return this.builtins.SubgroupOr(e, t);
                case "subgroupShuffle":
                    return this.builtins.SubgroupShuffle(e, t);
                case "subgroupShuffleDown":
                    return this.builtins.SubgroupShuffleDown(e, t);
                case "subgroupShuffleUp":
                    return this.builtins.SubgroupShuffleUp(e, t);
                case "subgroupShuffleXor":
                    return this.builtins.SubgroupShuffleXor(e, t);
                case "subgroupXor":
                    return this.builtins.SubgroupXor(e, t);
                case "quadBroadcast":
                    return this.builtins.QuadBroadcast(e, t);
                case "quadSwapDiagonal":
                    return this.builtins.QuadSwapDiagonal(e, t);
                case "quadSwapX":
                    return this.builtins.QuadSwapX(e, t);
                case "quadSwapY":
                    return this.builtins.QuadSwapY(e, t);
            }
            const i = t.getFunction(e.name);
            if (i) {
                const r = t.clone();
                for(let a = 0; a < i.node.args.length; ++a){
                    const l = i.node.args[a], u = this.evalExpression(e.args[a], r);
                    r.setVariable(l.name, u, l);
                }
                return this._execStatements(i.node.body, r);
            }
            return null;
        }
        _callConstructorValue(e, t) {
            if (!e.args || e.args.length === 0) return new I(0, this.getTypeInfo(e.type));
            const i = this.evalExpression(e.args[0], t);
            return i.typeInfo = this.getTypeInfo(e.type), i.getSubData(this, e.postfix, t).clone();
        }
        _callConstructorVec(e, t) {
            const i = this.getTypeInfo(e.type), r = e.type.getTypeName(), a = Wh[r];
            if (a === void 0) return console.error(`Invalid vec constructor ${r}. Line ${e.line}`), null;
            const l = [];
            if (e instanceof pt) if (e.isVector) {
                const u = e.vectorValue;
                for (const h of u)l.push(h);
            } else l.push(e.scalarValue);
            else if (e.args) for (const u of e.args){
                const h = this.evalExpression(u, t);
                if (h instanceof A) {
                    const d = h.data;
                    for(let p = 0; p < d.length; ++p){
                        let _ = d[p];
                        l.push(_);
                    }
                } else if (h instanceof I) {
                    let d = h.value;
                    l.push(d);
                }
            }
            if (e.type instanceof k && e.type.format === null && (e.type.format = k.f32), l.length === 0) {
                const u = new Array(a).fill(0);
                return new A(u, i).getSubData(this, e.postfix, t);
            }
            if (l.length === 1) for(; l.length < a;)l.push(l[0]);
            return l.length < a ? (console.error(`Invalid vec constructor. Line ${e.line}`), null) : new A(l.length > a ? l.slice(0, a) : l, i).getSubData(this, e.postfix, t);
        }
        _callConstructorMatrix(e, t) {
            const i = this.getTypeInfo(e.type), r = e.type.getTypeName(), a = Ut[r];
            if (a === void 0) return console.error(`Invalid matrix constructor ${r}. Line ${e.line}`), null;
            const l = [];
            if (e instanceof pt) if (e.isVector) {
                const u = e.vectorValue;
                for (const h of u)l.push(h);
            } else l.push(e.scalarValue);
            else if (e.args) for (const u of e.args){
                const h = this.evalExpression(u, t);
                h instanceof A ? l.push(...h.data) : h instanceof I ? l.push(h.value) : h instanceof me && l.push(...h.data);
            }
            if (i instanceof Mr && i.format === null && (i.format = this.getTypeInfo("f32")), l.length === 0) {
                const u = new Array(a[2]).fill(0);
                return new me(u, i).getSubData(this, e.postfix, t);
            }
            return l.length !== a[2] ? (console.error(`Invalid matrix constructor. Line ${e.line}`), null) : new me(l, i).getSubData(this, e.postfix, t);
        }
    }
    Ot._breakObj = new vn(new _n("BREAK", null), null), Ot._continueObj = new vn(new _n("CONTINUE", null), null), Ot._priority = new Map([
        [
            "f32",
            0
        ],
        [
            "f16",
            1
        ],
        [
            "u32",
            2
        ],
        [
            "i32",
            3
        ],
        [
            "x32",
            3
        ]
    ]);
    class mC {
        constructor(){
            this.constants = new Map, this.aliases = new Map, this.structs = new Map;
        }
    }
    class _C {
        constructor(){
            this._tokens = [], this._current = 0, this._currentLine = 1, this._deferArrayCountEval = [], this._currentLoop = [], this._context = new mC, this._exec = new Ot, this._forwardTypeCount = 0;
        }
        parse(e) {
            this._initialize(e), this._deferArrayCountEval.length = 0;
            const t = [];
            for(; !this._isAtEnd();){
                const i = this._global_decl_or_directive();
                if (!i) break;
                t.push(i);
            }
            if (this._deferArrayCountEval.length > 0) {
                for (const i of this._deferArrayCountEval){
                    const r = i.arrayType, a = i.countNode;
                    if (a instanceof sn) {
                        const l = a.name, u = this._context.constants.get(l);
                        if (u) try {
                            const h = u.constEvaluate(this._exec);
                            r.count = h;
                        } catch  {}
                    }
                }
                this._deferArrayCountEval.length = 0;
            }
            if (this._forwardTypeCount > 0) for (const i of t)i.search((r)=>{
                r instanceof Zb || r instanceof jh ? r.type = this._forwardType(r.type) : r instanceof po ? r.format = this._forwardType(r.format) : r instanceof fi || r instanceof go || r instanceof dc ? r.type = this._forwardType(r.type) : r instanceof To ? r.returnType = this._forwardType(r.returnType) : r instanceof Kb && (r.type = this._forwardType(r.type));
            });
            return t;
        }
        _forwardType(e) {
            if (e instanceof qb) {
                const t = this._getType(e.name);
                if (t) return t;
            } else e instanceof jh ? e.type = this._forwardType(e.type) : e instanceof po && (e.format = this._forwardType(e.format));
            return e;
        }
        _initialize(e) {
            if (e) if (typeof e == "string") {
                const t = new aC(e);
                this._tokens = t.scanTokens();
            } else this._tokens = e;
            else this._tokens = [];
            this._current = 0;
        }
        _updateNode(e, t) {
            return e.line = t ?? this._currentLine, e;
        }
        _error(e, t) {
            return {
                token: e,
                message: t,
                toString: ()=>`${t}`
            };
        }
        _isAtEnd() {
            return this._current >= this._tokens.length || this._peek().type == x.eof;
        }
        _match(e) {
            if (e instanceof P) return !!this._check(e) && (this._advance(), !0);
            for(let t = 0, i = e.length; t < i; ++t){
                const r = e[t];
                if (this._check(r)) return this._advance(), !0;
            }
            return !1;
        }
        _consume(e, t) {
            if (this._check(e)) return this._advance();
            throw this._error(this._peek(), `${t}. Line:${this._currentLine}`);
        }
        _check(e) {
            if (this._isAtEnd()) return !1;
            const t = this._peek();
            if (e instanceof Array) {
                const i = t.type;
                let r = !1;
                for (const a of e){
                    if (i === a) return !0;
                    a === x.tokens.name && (r = !0);
                }
                if (r) {
                    const a = x.tokens.name.rule.exec(t.lexeme);
                    if (a && a.index == 0 && a[0] == t.lexeme) return !0;
                }
                return !1;
            }
            if (t.type === e) return !0;
            if (e === x.tokens.name) {
                const i = x.tokens.name.rule.exec(t.lexeme);
                return i && i.index == 0 && i[0] == t.lexeme;
            }
            return !1;
        }
        _advance() {
            var e, t;
            return this._currentLine = (t = (e = this._peek()) === null || e === void 0 ? void 0 : e.line) !== null && t !== void 0 ? t : -1, this._isAtEnd() || this._current++, this._previous();
        }
        _peek() {
            return this._tokens[this._current];
        }
        _previous() {
            return this._tokens[this._current - 1];
        }
        _global_decl_or_directive() {
            for(; this._match(x.tokens.semicolon) && !this._isAtEnd(););
            if (this._match(x.keywords.alias)) {
                const t = this._type_alias();
                return this._consume(x.tokens.semicolon, "Expected ';'"), this._exec.reflection.updateAST([
                    t
                ]), t;
            }
            if (this._match(x.keywords.diagnostic)) {
                const t = this._diagnostic();
                return this._consume(x.tokens.semicolon, "Expected ';'"), this._exec.reflection.updateAST([
                    t
                ]), t;
            }
            if (this._match(x.keywords.requires)) {
                const t = this._requires_directive();
                return this._consume(x.tokens.semicolon, "Expected ';'"), this._exec.reflection.updateAST([
                    t
                ]), t;
            }
            if (this._match(x.keywords.enable)) {
                const t = this._enable_directive();
                return this._consume(x.tokens.semicolon, "Expected ';'"), this._exec.reflection.updateAST([
                    t
                ]), t;
            }
            const e = this._attribute();
            if (this._check(x.keywords.var)) {
                const t = this._global_variable_decl();
                return t != null && (t.attributes = e), this._consume(x.tokens.semicolon, "Expected ';'."), this._exec.reflection.updateAST([
                    t
                ]), t;
            }
            if (this._check(x.keywords.override)) {
                const t = this._override_variable_decl();
                return t != null && (t.attributes = e), this._consume(x.tokens.semicolon, "Expected ';'."), this._exec.reflection.updateAST([
                    t
                ]), t;
            }
            if (this._check(x.keywords.let)) {
                const t = this._global_let_decl();
                return t != null && (t.attributes = e), this._consume(x.tokens.semicolon, "Expected ';'."), this._exec.reflection.updateAST([
                    t
                ]), t;
            }
            if (this._check(x.keywords.const)) {
                const t = this._global_const_decl();
                return t != null && (t.attributes = e), this._consume(x.tokens.semicolon, "Expected ';'."), this._exec.reflection.updateAST([
                    t
                ]), t;
            }
            if (this._check(x.keywords.struct)) {
                const t = this._struct_decl();
                return t != null && (t.attributes = e), this._exec.reflection.updateAST([
                    t
                ]), t;
            }
            if (this._check(x.keywords.fn)) {
                const t = this._function_decl();
                return t != null && (t.attributes = e), this._exec.reflection.updateAST([
                    t
                ]), t;
            }
            return null;
        }
        _function_decl() {
            if (!this._match(x.keywords.fn)) return null;
            const e = this._currentLine, t = this._consume(x.tokens.ident, "Expected function name.").toString();
            this._consume(x.tokens.paren_left, "Expected '(' for function arguments.");
            const i = [];
            if (!this._check(x.tokens.paren_right)) do {
                if (this._check(x.tokens.paren_right)) break;
                const u = this._attribute(), h = this._consume(x.tokens.name, "Expected argument name.").toString();
                this._consume(x.tokens.colon, "Expected ':' for argument type.");
                const d = this._attribute(), p = this._type_decl();
                p != null && (p.attributes = d, i.push(this._updateNode(new Kb(h, p, u))));
            }while (this._match(x.tokens.comma));
            this._consume(x.tokens.paren_right, "Expected ')' after function arguments.");
            let r = null;
            if (this._match(x.tokens.arrow)) {
                const u = this._attribute();
                r = this._type_decl(), r != null && (r.attributes = u);
            }
            const a = this._compound_statement(), l = this._currentLine;
            return this._updateNode(new To(t, i, r, a, e, l), e);
        }
        _compound_statement() {
            const e = [];
            for(this._consume(x.tokens.brace_left, "Expected '{' for block."); !this._check(x.tokens.brace_right);){
                const t = this._statement();
                t !== null && e.push(t);
            }
            return this._consume(x.tokens.brace_right, "Expected '}' for block."), e;
        }
        _statement() {
            for(; this._match(x.tokens.semicolon) && !this._isAtEnd(););
            if (this._check(x.tokens.attr) && this._attribute(), this._check(x.keywords.if)) return this._if_statement();
            if (this._check(x.keywords.switch)) return this._switch_statement();
            if (this._check(x.keywords.loop)) return this._loop_statement();
            if (this._check(x.keywords.for)) return this._for_statement();
            if (this._check(x.keywords.while)) return this._while_statement();
            if (this._check(x.keywords.continuing)) return this._continuing_statement();
            if (this._check(x.keywords.static_assert)) return this._static_assert_statement();
            if (this._check(x.tokens.brace_left)) return this._compound_statement();
            let e = null;
            if (this._check(x.keywords.return)) e = this._return_statement();
            else if (this._check([
                x.keywords.var,
                x.keywords.let,
                x.keywords.const
            ])) e = this._variable_statement();
            else if (this._match(x.keywords.discard)) e = this._updateNode(new iC);
            else if (this._match(x.keywords.break)) {
                const t = this._updateNode(new Q3);
                if (this._currentLoop.length > 0) {
                    const i = this._currentLoop[this._currentLoop.length - 1];
                    t.loopId = i.id;
                }
                e = t, this._check(x.keywords.if) && (this._advance(), t.condition = this._optional_paren_expression());
            } else if (this._match(x.keywords.continue)) {
                const t = this._updateNode(new G3);
                if (!(this._currentLoop.length > 0)) throw this._error(this._peek(), `Continue statement must be inside a loop. Line: ${t.line}`);
                {
                    const i = this._currentLoop[this._currentLoop.length - 1];
                    t.loopId = i.id;
                }
                e = t;
            } else e = this._increment_decrement_statement() || this._func_call_statement() || this._assignment_statement();
            return e != null && this._consume(x.tokens.semicolon, "Expected ';' after statement."), e;
        }
        _static_assert_statement() {
            if (!this._match(x.keywords.static_assert)) return null;
            const e = this._currentLine, t = this._optional_paren_expression();
            return this._updateNode(new eC(t), e);
        }
        _while_statement() {
            if (!this._match(x.keywords.while)) return null;
            const e = this._updateNode(new H3(null, null));
            return this._currentLoop.push(e), e.condition = this._optional_paren_expression(), this._check(x.tokens.attr) && this._attribute(), e.body = this._compound_statement(), this._currentLoop.pop(), e;
        }
        _continuing_statement() {
            const e = this._currentLoop.length > 0 ? this._currentLoop[this._currentLoop.length - 1].id : -1;
            if (!this._match(x.keywords.continuing)) return null;
            const t = this._currentLine, i = this._compound_statement();
            return this._updateNode(new Ed(i, e), t);
        }
        _for_statement() {
            if (!this._match(x.keywords.for)) return null;
            this._consume(x.tokens.paren_left, "Expected '('.");
            const e = this._updateNode(new j3(null, null, null, null));
            return this._currentLoop.push(e), e.init = this._check(x.tokens.semicolon) ? null : this._for_init(), this._consume(x.tokens.semicolon, "Expected ';'."), e.condition = this._check(x.tokens.semicolon) ? null : this._short_circuit_or_expression(), this._consume(x.tokens.semicolon, "Expected ';'."), e.increment = this._check(x.tokens.paren_right) ? null : this._for_increment(), this._consume(x.tokens.paren_right, "Expected ')'."), this._check(x.tokens.attr) && this._attribute(), e.body = this._compound_statement(), this._currentLoop.pop(), e;
        }
        _for_init() {
            return this._variable_statement() || this._func_call_statement() || this._assignment_statement();
        }
        _for_increment() {
            return this._func_call_statement() || this._increment_decrement_statement() || this._assignment_statement();
        }
        _variable_statement() {
            if (this._check(x.keywords.var)) {
                const e = this._variable_decl();
                if (e === null) throw this._error(this._peek(), "Variable declaration expected.");
                let t = null;
                return this._match(x.tokens.equal) && (t = this._short_circuit_or_expression()), this._updateNode(new fi(e.name, e.type, e.storage, e.access, t), e.line);
            }
            if (this._match(x.keywords.let)) {
                const e = this._currentLine, t = this._consume(x.tokens.name, "Expected name for let.").toString();
                let i = null;
                if (this._match(x.tokens.colon)) {
                    const a = this._attribute();
                    i = this._type_decl(), i != null && (i.attributes = a);
                }
                this._consume(x.tokens.equal, "Expected '=' for let.");
                const r = this._short_circuit_or_expression();
                return this._updateNode(new go(t, i, null, null, r), e);
            }
            if (this._match(x.keywords.const)) {
                const e = this._currentLine, t = this._consume(x.tokens.name, "Expected name for const.").toString();
                let i = null;
                if (this._match(x.tokens.colon)) {
                    const a = this._attribute();
                    i = this._type_decl(), i != null && (i.attributes = a);
                }
                this._consume(x.tokens.equal, "Expected '=' for const.");
                const r = this._short_circuit_or_expression();
                return i === null && r instanceof pt && (i = r.type), this._updateNode(new dc(t, i, null, null, r), e);
            }
            return null;
        }
        _increment_decrement_statement() {
            const e = this._current, t = this._unary_expression();
            if (t == null) return null;
            if (!this._check(x.increment_operators)) return this._current = e, null;
            const i = this._consume(x.increment_operators, "Expected increment operator");
            return this._updateNode(new W3(i.type === x.tokens.plus_plus ? Ds.increment : Ds.decrement, t));
        }
        _assignment_statement() {
            let e = null;
            const t = this._currentLine;
            if (this._check(x.tokens.brace_right)) return null;
            let i = this._match(x.tokens.underscore);
            if (i || (e = this._unary_expression()), !i && e == null) return null;
            const r = this._consume(x.assignment_operators, "Expected assignment operator."), a = this._short_circuit_or_expression();
            return this._updateNode(new $3(ao.parse(r.lexeme), e, a), t);
        }
        _func_call_statement() {
            if (!this._check(x.tokens.ident)) return null;
            const e = this._currentLine, t = this._current, i = this._consume(x.tokens.ident, "Expected function name."), r = this._argument_expression_list();
            return r === null ? (this._current = t, null) : this._updateNode(new Tg(i.lexeme, r), e);
        }
        _loop_statement() {
            if (!this._match(x.keywords.loop)) return null;
            this._check(x.tokens.attr) && this._attribute(), this._consume(x.tokens.brace_left, "Expected '{' for loop.");
            const e = this._updateNode(new X3([], null));
            this._currentLoop.push(e);
            let t = this._statement();
            for(; t !== null;){
                if (Array.isArray(t)) for (let i of t)e.body.push(i);
                else e.body.push(t);
                if (t instanceof Ed) {
                    e.continuing = t;
                    break;
                }
                t = this._statement();
            }
            return this._currentLoop.pop(), this._consume(x.tokens.brace_right, "Expected '}' for loop."), e;
        }
        _switch_statement() {
            if (!this._match(x.keywords.switch)) return null;
            const e = this._updateNode(new Y3(null, []));
            if (this._currentLoop.push(e), e.condition = this._optional_paren_expression(), this._check(x.tokens.attr) && this._attribute(), this._consume(x.tokens.brace_left, "Expected '{' for switch."), e.cases = this._switch_body(), e.cases == null || e.cases.length == 0) throw this._error(this._previous(), "Expected 'case' or 'default'.");
            return this._consume(x.tokens.brace_right, "Expected '}' for switch."), this._currentLoop.pop(), e;
        }
        _switch_body() {
            const e = [];
            let t = !1;
            for(; this._check([
                x.keywords.default,
                x.keywords.case
            ]);){
                if (this._match(x.keywords.case)) {
                    const i = this._case_selectors();
                    for (const a of i)if (a instanceof gc) {
                        if (t) throw this._error(this._previous(), "Multiple default cases in switch statement.");
                        t = !0;
                        break;
                    }
                    this._match(x.tokens.colon), this._check(x.tokens.attr) && this._attribute(), this._consume(x.tokens.brace_left, "Exected '{' for switch case.");
                    const r = this._case_body();
                    this._consume(x.tokens.brace_right, "Exected '}' for switch case."), e.push(this._updateNode(new iT(i, r)));
                }
                if (this._match(x.keywords.default)) {
                    if (t) throw this._error(this._previous(), "Multiple default cases in switch statement.");
                    this._match(x.tokens.colon), this._check(x.tokens.attr) && this._attribute(), this._consume(x.tokens.brace_left, "Exected '{' for switch default.");
                    const i = this._case_body();
                    this._consume(x.tokens.brace_right, "Exected '}' for switch default."), e.push(this._updateNode(new rT(i)));
                }
            }
            return e;
        }
        _case_selectors() {
            const e = [];
            for(this._match(x.keywords.default) ? e.push(this._updateNode(new gc)) : e.push(this._shift_expression()); this._match(x.tokens.comma);)this._match(x.keywords.default) ? e.push(this._updateNode(new gc)) : e.push(this._shift_expression());
            return e;
        }
        _case_body() {
            if (this._match(x.keywords.fallthrough)) return this._consume(x.tokens.semicolon, "Expected ';'"), [];
            let e = this._statement();
            if (e == null) return [];
            e instanceof Array || (e = [
                e
            ]);
            const t = this._case_body();
            return t.length == 0 ? e : [
                ...e,
                t[0]
            ];
        }
        _if_statement() {
            if (!this._match(x.keywords.if)) return null;
            const e = this._currentLine, t = this._optional_paren_expression();
            this._check(x.tokens.attr) && this._attribute();
            const i = this._compound_statement();
            let r = [];
            this._match_elseif() && (this._check(x.tokens.attr) && this._attribute(), r = this._elseif_statement(r));
            let a = null;
            return this._match(x.keywords.else) && (this._check(x.tokens.attr) && this._attribute(), a = this._compound_statement()), this._updateNode(new q3(t, i, r, a), e);
        }
        _match_elseif() {
            return this._tokens[this._current].type === x.keywords.else && this._tokens[this._current + 1].type === x.keywords.if && (this._advance(), this._advance(), !0);
        }
        _elseif_statement(e = []) {
            const t = this._optional_paren_expression(), i = this._compound_statement();
            return e.push(this._updateNode(new rC(t, i))), this._match_elseif() && (this._check(x.tokens.attr) && this._attribute(), this._elseif_statement(e)), e;
        }
        _return_statement() {
            if (!this._match(x.keywords.return)) return null;
            const e = this._short_circuit_or_expression();
            return this._updateNode(new K3(e));
        }
        _short_circuit_or_expression() {
            let e = this._short_circuit_and_expr();
            for(; this._match(x.tokens.or_or);)e = this._updateNode(new En(this._previous().toString(), e, this._short_circuit_and_expr()));
            return e;
        }
        _short_circuit_and_expr() {
            let e = this._inclusive_or_expression();
            for(; this._match(x.tokens.and_and);)e = this._updateNode(new En(this._previous().toString(), e, this._inclusive_or_expression()));
            return e;
        }
        _inclusive_or_expression() {
            let e = this._exclusive_or_expression();
            for(; this._match(x.tokens.or);)e = this._updateNode(new En(this._previous().toString(), e, this._exclusive_or_expression()));
            return e;
        }
        _exclusive_or_expression() {
            let e = this._and_expression();
            for(; this._match(x.tokens.xor);)e = this._updateNode(new En(this._previous().toString(), e, this._and_expression()));
            return e;
        }
        _and_expression() {
            let e = this._equality_expression();
            for(; this._match(x.tokens.and);)e = this._updateNode(new En(this._previous().toString(), e, this._equality_expression()));
            return e;
        }
        _equality_expression() {
            const e = this._relational_expression();
            return this._match([
                x.tokens.equal_equal,
                x.tokens.not_equal
            ]) ? this._updateNode(new En(this._previous().toString(), e, this._relational_expression())) : e;
        }
        _relational_expression() {
            let e = this._shift_expression();
            for(; this._match([
                x.tokens.less_than,
                x.tokens.greater_than,
                x.tokens.less_than_equal,
                x.tokens.greater_than_equal
            ]);)e = this._updateNode(new En(this._previous().toString(), e, this._shift_expression()));
            return e;
        }
        _shift_expression() {
            let e = this._additive_expression();
            for(; this._match([
                x.tokens.shift_left,
                x.tokens.shift_right
            ]);)e = this._updateNode(new En(this._previous().toString(), e, this._additive_expression()));
            return e;
        }
        _additive_expression() {
            let e = this._multiplicative_expression();
            for(; this._match([
                x.tokens.plus,
                x.tokens.minus
            ]);)e = this._updateNode(new En(this._previous().toString(), e, this._multiplicative_expression()));
            return e;
        }
        _multiplicative_expression() {
            let e = this._unary_expression();
            for(; this._match([
                x.tokens.star,
                x.tokens.forward_slash,
                x.tokens.modulo
            ]);)e = this._updateNode(new En(this._previous().toString(), e, this._unary_expression()));
            return e;
        }
        _unary_expression() {
            return this._match([
                x.tokens.minus,
                x.tokens.bang,
                x.tokens.tilde,
                x.tokens.star,
                x.tokens.and
            ]) ? this._updateNode(new ft(this._previous().toString(), this._unary_expression())) : this._singular_expression();
        }
        _singular_expression() {
            const e = this._primary_expression(), t = this._postfix_expression();
            return t && (e.postfix = t), e;
        }
        _postfix_expression() {
            if (this._match(x.tokens.bracket_left)) {
                const e = this._short_circuit_or_expression();
                this._consume(x.tokens.bracket_right, "Expected ']'.");
                const t = this._updateNode(new Xs(e)), i = this._postfix_expression();
                return i && (t.postfix = i), t;
            }
            if (this._match(x.tokens.period)) {
                const e = this._consume(x.tokens.name, "Expected member name."), t = this._postfix_expression(), i = this._updateNode(new Or(e.lexeme));
                return t && (i.postfix = t), i;
            }
            return null;
        }
        _getStruct(e) {
            return this._context.aliases.has(e) ? this._context.aliases.get(e).type : this._context.structs.has(e) ? this._context.structs.get(e) : null;
        }
        _getType(e) {
            const t = this._getStruct(e);
            if (t !== null) return t;
            switch(e){
                case "void":
                    return q.void;
                case "bool":
                    return q.bool;
                case "i32":
                    return q.i32;
                case "u32":
                    return q.u32;
                case "f32":
                    return q.f32;
                case "f16":
                    return q.f16;
                case "vec2f":
                    return k.vec2f;
                case "vec3f":
                    return k.vec3f;
                case "vec4f":
                    return k.vec4f;
                case "vec2i":
                    return k.vec2i;
                case "vec3i":
                    return k.vec3i;
                case "vec4i":
                    return k.vec4i;
                case "vec2u":
                    return k.vec2u;
                case "vec3u":
                    return k.vec3u;
                case "vec4u":
                    return k.vec4u;
                case "vec2h":
                    return k.vec2h;
                case "vec3h":
                    return k.vec3h;
                case "vec4h":
                    return k.vec4h;
                case "mat2x2f":
                    return k.mat2x2f;
                case "mat2x3f":
                    return k.mat2x3f;
                case "mat2x4f":
                    return k.mat2x4f;
                case "mat3x2f":
                    return k.mat3x2f;
                case "mat3x3f":
                    return k.mat3x3f;
                case "mat3x4f":
                    return k.mat3x4f;
                case "mat4x2f":
                    return k.mat4x2f;
                case "mat4x3f":
                    return k.mat4x3f;
                case "mat4x4f":
                    return k.mat4x4f;
                case "mat2x2h":
                    return k.mat2x2h;
                case "mat2x3h":
                    return k.mat2x3h;
                case "mat2x4h":
                    return k.mat2x4h;
                case "mat3x2h":
                    return k.mat3x2h;
                case "mat3x3h":
                    return k.mat3x3h;
                case "mat3x4h":
                    return k.mat3x4h;
                case "mat4x2h":
                    return k.mat4x2h;
                case "mat4x3h":
                    return k.mat4x3h;
                case "mat4x4h":
                    return k.mat4x4h;
                case "mat2x2i":
                    return k.mat2x2i;
                case "mat2x3i":
                    return k.mat2x3i;
                case "mat2x4i":
                    return k.mat2x4i;
                case "mat3x2i":
                    return k.mat3x2i;
                case "mat3x3i":
                    return k.mat3x3i;
                case "mat3x4i":
                    return k.mat3x4i;
                case "mat4x2i":
                    return k.mat4x2i;
                case "mat4x3i":
                    return k.mat4x3i;
                case "mat4x4i":
                    return k.mat4x4i;
                case "mat2x2u":
                    return k.mat2x2u;
                case "mat2x3u":
                    return k.mat2x3u;
                case "mat2x4u":
                    return k.mat2x4u;
                case "mat3x2u":
                    return k.mat3x2u;
                case "mat3x3u":
                    return k.mat3x3u;
                case "mat3x4u":
                    return k.mat3x4u;
                case "mat4x2u":
                    return k.mat4x2u;
                case "mat4x3u":
                    return k.mat4x3u;
                case "mat4x4u":
                    return k.mat4x4u;
            }
            return null;
        }
        _validateTypeRange(e, t) {
            if (t.name === "i32") {
                if (e < -2147483648 || e > 2147483647) throw this._error(this._previous(), `Value out of range for i32: ${e}. Line: ${this._currentLine}.`);
            } else if (t.name === "u32" && (e < 0 || e > 4294967295)) throw this._error(this._previous(), `Value out of range for u32: ${e}. Line: ${this._currentLine}.`);
        }
        _primary_expression() {
            if (this._match(x.tokens.ident)) {
                const i = this._previous().toString();
                if (this._check(x.tokens.paren_left)) {
                    const r = this._argument_expression_list(), a = this._getType(i);
                    return a !== null ? this._updateNode(new Ln(a, r)) : this._updateNode(new Sg(i, r));
                }
                if (this._context.constants.has(i)) {
                    const r = this._context.constants.get(i);
                    return this._updateNode(new J3(i, r.value));
                }
                return this._updateNode(new sn(i));
            }
            if (this._match(x.tokens.int_literal)) {
                const i = this._previous().toString();
                let r = i.endsWith("i") || i.endsWith("i") ? q.i32 : i.endsWith("u") || i.endsWith("U") ? q.u32 : q.x32;
                const a = parseInt(i);
                return this._validateTypeRange(a, r), this._updateNode(new pt(new I(a, this._exec.getTypeInfo(r)), r));
            }
            if (this._match(x.tokens.uint_literal)) {
                const i = parseInt(this._previous().toString());
                return this._validateTypeRange(i, q.u32), this._updateNode(new pt(new I(i, this._exec.getTypeInfo(q.u32)), q.u32));
            }
            if (this._match([
                x.tokens.decimal_float_literal,
                x.tokens.hex_float_literal
            ])) {
                let i = this._previous().toString(), r = i.endsWith("h");
                r && (i = i.substring(0, i.length - 1));
                const a = parseFloat(i);
                this._validateTypeRange(a, r ? q.f16 : q.f32);
                const l = r ? q.f16 : q.f32;
                return this._updateNode(new pt(new I(a, this._exec.getTypeInfo(l)), l));
            }
            if (this._match([
                x.keywords.true,
                x.keywords.false
            ])) {
                let i = this._previous().toString() === x.keywords.true.rule;
                return this._updateNode(new pt(new I(i ? 1 : 0, this._exec.getTypeInfo(q.bool)), q.bool));
            }
            if (this._check(x.tokens.paren_left)) return this._paren_expression();
            if (this._match(x.keywords.bitcast)) {
                this._consume(x.tokens.less_than, "Expected '<'.");
                const i = this._type_decl();
                this._consume(x.tokens.greater_than, "Expected '>'.");
                const r = this._paren_expression();
                return this._updateNode(new eT(i, r));
            }
            const e = this._type_decl(), t = this._argument_expression_list();
            return this._updateNode(new Ln(e, t));
        }
        _argument_expression_list() {
            if (!this._match(x.tokens.paren_left)) return null;
            const e = [];
            do {
                if (this._check(x.tokens.paren_right)) break;
                const t = this._short_circuit_or_expression();
                e.push(t);
            }while (this._match(x.tokens.comma));
            return this._consume(x.tokens.paren_right, "Expected ')' for agument list"), e;
        }
        _optional_paren_expression() {
            this._match(x.tokens.paren_left);
            const e = this._short_circuit_or_expression();
            return this._match(x.tokens.paren_right), e;
        }
        _paren_expression() {
            this._consume(x.tokens.paren_left, "Expected '('.");
            const e = this._short_circuit_or_expression();
            return this._consume(x.tokens.paren_right, "Expected ')'."), e;
        }
        _struct_decl() {
            if (!this._match(x.keywords.struct)) return null;
            const e = this._currentLine, t = this._consume(x.tokens.ident, "Expected name for struct.").toString();
            this._consume(x.tokens.brace_left, "Expected '{' for struct body.");
            const i = [];
            for(; !this._check(x.tokens.brace_right);){
                const l = this._attribute(), u = this._consume(x.tokens.name, "Expected variable name.").toString();
                this._consume(x.tokens.colon, "Expected ':' for struct member type.");
                const h = this._attribute(), d = this._type_decl();
                d != null && (d.attributes = h), this._check(x.tokens.brace_right) ? this._match(x.tokens.comma) : this._consume(x.tokens.comma, "Expected ',' for struct member."), i.push(this._updateNode(new Zb(u, d, l)));
            }
            this._consume(x.tokens.brace_right, "Expected '}' after struct body.");
            const r = this._currentLine, a = this._updateNode(new ci(t, i, e, r), e);
            return this._context.structs.set(t, a), a;
        }
        _global_variable_decl() {
            const e = this._variable_decl();
            if (!e) return null;
            if (this._match(x.tokens.equal)) {
                const t = this._const_expression();
                e.value = t;
            }
            if (e.type !== null && e.value instanceof pt) {
                if (e.value.type.name !== "x32" && e.type.getTypeName() !== e.value.type.getTypeName()) throw this._error(this._peek(), `Invalid cast from ${e.value.type.name} to ${e.type.name}. Line:${this._currentLine}`);
                e.value.isScalar && this._validateTypeRange(e.value.scalarValue, e.type), e.value.type = e.type;
            } else e.type === null && e.value instanceof pt && (e.type = e.value.type.name === "x32" ? q.i32 : e.value.type, e.value.isScalar && this._validateTypeRange(e.value.scalarValue, e.type));
            return e;
        }
        _override_variable_decl() {
            const e = this._override_decl();
            return e && this._match(x.tokens.equal) && (e.value = this._const_expression()), e;
        }
        _global_const_decl() {
            var e;
            if (!this._match(x.keywords.const)) return null;
            const t = this._consume(x.tokens.name, "Expected variable name"), i = this._currentLine;
            let r = null;
            if (this._match(x.tokens.colon)) {
                const h = this._attribute();
                r = this._type_decl(), r != null && (r.attributes = h);
            }
            let a = null;
            this._consume(x.tokens.equal, "const declarations require an assignment");
            const l = this._short_circuit_or_expression();
            try {
                let h = [
                    q.f32
                ], d = l.constEvaluate(this._exec, h);
                d instanceof I && this._validateTypeRange(d.value, h[0]), h[0] instanceof k && h[0].format === null && d.typeInfo instanceof Mr && d.typeInfo.format !== null && (d.typeInfo.format.name === "f16" ? h[0].format = q.f16 : d.typeInfo.format.name === "f32" ? h[0].format = q.f32 : d.typeInfo.format.name === "i32" ? h[0].format = q.i32 : d.typeInfo.format.name === "u32" ? h[0].format = q.u32 : d.typeInfo.format.name === "bool" ? h[0].format = q.bool : console.error(`TODO: impelement template format type ${d.typeInfo.format.name}`)), a = this._updateNode(new pt(d, h[0])), this._exec.context.setVariable(t.toString(), d);
            } catch  {
                a = l;
            }
            if (r !== null && a instanceof pt) {
                if (a.type.name !== "x32" && r.getTypeName() !== a.type.getTypeName()) throw this._error(this._peek(), `Invalid cast from ${a.type.name} to ${r.name}. Line:${this._currentLine}`);
                a.type = r, a.isScalar && this._validateTypeRange(a.scalarValue, a.type);
            } else r === null && a instanceof pt && (r = (e = a?.type) !== null && e !== void 0 ? e : q.f32, r === q.x32 && (r = q.i32));
            const u = this._updateNode(new dc(t.toString(), r, "", "", a), i);
            return this._context.constants.set(u.name, u), u;
        }
        _global_let_decl() {
            if (!this._match(x.keywords.let)) return null;
            const e = this._currentLine, t = this._consume(x.tokens.name, "Expected variable name");
            let i = null;
            if (this._match(x.tokens.colon)) {
                const a = this._attribute();
                i = this._type_decl(), i != null && (i.attributes = a);
            }
            let r = null;
            if (this._match(x.tokens.equal) && (r = this._const_expression()), i !== null && r instanceof pt) {
                if (r.type.name !== "x32" && i.getTypeName() !== r.type.getTypeName()) throw this._error(this._peek(), `Invalid cast from ${r.type.name} to ${i.name}. Line:${this._currentLine}`);
                r.type = i;
            } else i === null && r instanceof pt && (i = r.type.name === "x32" ? q.i32 : r.type);
            return r instanceof pt && r.isScalar && this._validateTypeRange(r.scalarValue, i), this._updateNode(new go(t.toString(), i, "", "", r), e);
        }
        _const_expression() {
            return this._short_circuit_or_expression();
        }
        _variable_decl() {
            if (!this._match(x.keywords.var)) return null;
            const e = this._currentLine;
            let t = "", i = "";
            this._match(x.tokens.less_than) && (t = this._consume(x.storage_class, "Expected storage_class.").toString(), this._match(x.tokens.comma) && (i = this._consume(x.access_mode, "Expected access_mode.").toString()), this._consume(x.tokens.greater_than, "Expected '>'."));
            const r = this._consume(x.tokens.name, "Expected variable name");
            let a = null;
            if (this._match(x.tokens.colon)) {
                const l = this._attribute();
                a = this._type_decl(), a != null && (a.attributes = l);
            }
            return this._updateNode(new fi(r.toString(), a, t, i, null), e);
        }
        _override_decl() {
            if (!this._match(x.keywords.override)) return null;
            const e = this._consume(x.tokens.name, "Expected variable name");
            let t = null;
            if (this._match(x.tokens.colon)) {
                const i = this._attribute();
                t = this._type_decl(), t != null && (t.attributes = i);
            }
            return this._updateNode(new vg(e.toString(), t, null));
        }
        _diagnostic() {
            this._consume(x.tokens.paren_left, "Expected '('");
            const e = this._consume(x.tokens.ident, "Expected severity control name.");
            this._consume(x.tokens.comma, "Expected ','");
            let t = this._consume(x.tokens.ident, "Expected diagnostic rule name.").toString();
            return this._match(x.tokens.period) && (t += `.${this._consume(x.tokens.ident, "Expected diagnostic message.").toString()}`), this._consume(x.tokens.paren_right, "Expected ')'"), this._updateNode(new Z3(e.toString(), t));
        }
        _enable_directive() {
            const e = this._consume(x.tokens.ident, "identity expected.");
            return this._updateNode(new tC(e.toString()));
        }
        _requires_directive() {
            const e = [
                this._consume(x.tokens.ident, "identity expected.").toString()
            ];
            for(; this._match(x.tokens.comma);){
                const t = this._consume(x.tokens.ident, "identity expected.");
                e.push(t.toString());
            }
            return this._updateNode(new nC(e));
        }
        _type_alias() {
            const e = this._consume(x.tokens.ident, "identity expected.");
            this._consume(x.tokens.equal, "Expected '=' for type alias.");
            let t = this._type_decl();
            if (t === null) throw this._error(this._peek(), "Expected Type for Alias.");
            this._context.aliases.has(t.name) && (t = this._context.aliases.get(t.name).type);
            const i = this._updateNode(new xg(e.toString(), t));
            return this._context.aliases.set(i.name, i), i;
        }
        _type_decl() {
            if (this._check([
                x.tokens.ident,
                ...x.texel_format,
                x.keywords.bool,
                x.keywords.f32,
                x.keywords.i32,
                x.keywords.u32
            ])) {
                const i = this._advance().toString();
                if (this._context.structs.has(i)) return this._context.structs.get(i);
                if (this._context.aliases.has(i)) return this._context.aliases.get(i).type;
                if (!this._getType(i)) {
                    const r = this._updateNode(new qb(i));
                    return this._forwardTypeCount++, r;
                }
                return this._updateNode(new q(i));
            }
            let e = this._texture_sampler_types();
            if (e) return e;
            if (this._check(x.template_types)) {
                let i = this._advance().toString(), r = null, a = null;
                return this._match(x.tokens.less_than) && (r = this._type_decl(), a = null, this._match(x.tokens.comma) && (a = this._consume(x.access_mode, "Expected access_mode for pointer").toString()), this._consume(x.tokens.greater_than, "Expected '>' for type.")), this._updateNode(new k(i, r, a));
            }
            if (this._match(x.keywords.ptr)) {
                let i = this._previous().toString();
                this._consume(x.tokens.less_than, "Expected '<' for pointer.");
                const r = this._consume(x.storage_class, "Expected storage_class for pointer");
                this._consume(x.tokens.comma, "Expected ',' for pointer.");
                const a = this._type_decl();
                let l = null;
                return this._match(x.tokens.comma) && (l = this._consume(x.access_mode, "Expected access_mode for pointer").toString()), this._consume(x.tokens.greater_than, "Expected '>' for pointer."), this._updateNode(new jh(i, r.toString(), a, l));
            }
            const t = this._attribute();
            if (this._match(x.keywords.array)) {
                let i = null, r = -1;
                const a = this._previous();
                let l = null;
                if (this._match(x.tokens.less_than)) {
                    i = this._type_decl(), this._context.aliases.has(i.name) && (i = this._context.aliases.get(i.name).type);
                    let h = "";
                    if (this._match(x.tokens.comma)) {
                        l = this._shift_expression();
                        try {
                            h = l.constEvaluate(this._exec).toString(), l = null;
                        } catch  {
                            h = "1";
                        }
                    }
                    this._consume(x.tokens.greater_than, "Expected '>' for array."), r = h ? parseInt(h) : 0;
                }
                const u = this._updateNode(new po(a.toString(), t, i, r));
                return l && this._deferArrayCountEval.push({
                    arrayType: u,
                    countNode: l
                }), u;
            }
            return null;
        }
        _texture_sampler_types() {
            if (this._match(x.sampler_type)) return this._updateNode(new oo(this._previous().toString(), null, null));
            if (this._match(x.depth_texture_type)) return this._updateNode(new oo(this._previous().toString(), null, null));
            if (this._match(x.sampled_texture_type) || this._match(x.multisampled_texture_type)) {
                const e = this._previous();
                this._consume(x.tokens.less_than, "Expected '<' for sampler type.");
                const t = this._type_decl();
                return this._consume(x.tokens.greater_than, "Expected '>' for sampler type."), this._updateNode(new oo(e.toString(), t, null));
            }
            if (this._match(x.storage_texture_type)) {
                const e = this._previous();
                this._consume(x.tokens.less_than, "Expected '<' for sampler type.");
                const t = this._consume(x.texel_format, "Invalid texel format.").toString();
                this._consume(x.tokens.comma, "Expected ',' after texel format.");
                const i = this._consume(x.access_mode, "Expected access mode for storage texture type.").toString();
                return this._consume(x.tokens.greater_than, "Expected '>' for sampler type."), this._updateNode(new oo(e.toString(), t, i));
            }
            return null;
        }
        _attribute() {
            let e = [];
            for(; this._match(x.tokens.attr);){
                const t = this._consume(x.attribute_name, "Expected attribute name"), i = this._updateNode(new sT(t.toString(), null));
                if (this._match(x.tokens.paren_left)) {
                    if (i.value = this._consume(x.literal_or_ident, "Expected attribute value").toString(), this._check(x.tokens.comma)) {
                        this._advance();
                        do {
                            const r = this._consume(x.literal_or_ident, "Expected attribute value").toString();
                            i.value instanceof Array || (i.value = [
                                i.value
                            ]), i.value.push(r);
                        }while (this._match(x.tokens.comma));
                    }
                    this._consume(x.tokens.paren_right, "Expected ')'");
                }
                e.push(i);
            }
            return e.length == 0 ? null : e;
        }
    }
    class yC extends Vn {
        constructor(e){
            super(), e && this.update(e);
        }
        update(e) {
            const t = new _C().parse(e);
            this.updateAST(t);
        }
    }
    function bC(n) {
        const e = {
            attributes: [],
            bindings: []
        };
        let t;
        try {
            t = vC(n);
        } catch (a) {
            return J.error(a.message)(), e;
        }
        for (const a of t.uniforms){
            const l = [];
            for (const u of a.type?.members || [])l.push({
                name: u.name,
                type: Jb(u.type)
            });
            e.bindings.push({
                type: "uniform",
                name: a.name,
                group: a.group,
                location: a.binding,
                members: l
            });
        }
        for (const a of t.textures)e.bindings.push({
            type: "texture",
            name: a.name,
            group: a.group,
            location: a.binding
        });
        for (const a of t.samplers)e.bindings.push({
            type: "sampler",
            name: a.name,
            group: a.group,
            location: a.binding
        });
        const i = t.entry.vertex[0], r = i?.inputs.length || 0;
        for(let a = 0; a < r; a++){
            const l = i.inputs[a];
            if (l.locationType === "location") {
                const u = Jb(l.type);
                e.attributes.push({
                    name: l.name,
                    location: Number(l.location),
                    type: u
                });
            }
        }
        return e;
    }
    function Jb(n) {
        return n.format ? `${n.name}<${n.format.name}>` : n.name;
    }
    function vC(n) {
        try {
            return new yC(n);
        } catch (e) {
            if (e instanceof Error) throw e;
            let t = "WGSL parse error";
            throw typeof e == "object" && e?.message && (t += `: ${e.message} `), typeof e == "object" && e?.token && (t += e.token.line || ""), new Error(t, {
                cause: e
            });
        }
    }
    const TC = {
        EPSILON: 1e-12,
        debug: !1,
        precision: 4,
        printTypes: !1,
        printDegrees: !1,
        printRowMajor: !0,
        _cartographicRadians: !1
    };
    globalThis.mathgl = globalThis.mathgl || {
        config: {
            ...TC
        }
    };
    const yn = globalThis.mathgl.config;
    function xC(n, { precision: e = yn.precision } = {}) {
        return n = SC(n), `${parseFloat(n.toPrecision(e))}`;
    }
    function Ys(n) {
        return Array.isArray(n) || ArrayBuffer.isView(n) && !(n instanceof DataView);
    }
    function Xi(n, e, t) {
        return wC(n, (i)=>Math.max(e, Math.min(t, i)));
    }
    function Nc(n, e, t) {
        return Ys(n) ? n.map((i, r)=>Nc(i, e[r], t)) : t * e + (1 - t) * n;
    }
    function xo(n, e, t) {
        const i = yn.EPSILON;
        try {
            if (n === e) return !0;
            if (Ys(n) && Ys(e)) {
                if (n.length !== e.length) return !1;
                for(let r = 0; r < n.length; ++r)if (!xo(n[r], e[r])) return !1;
                return !0;
            }
            return n && n.equals ? n.equals(e) : e && e.equals ? e.equals(n) : typeof n == "number" && typeof e == "number" ? Math.abs(n - e) <= yn.EPSILON * Math.max(1, Math.abs(n), Math.abs(e)) : !1;
        } finally{
            yn.EPSILON = i;
        }
    }
    function SC(n) {
        return Math.round(n / yn.EPSILON) * yn.EPSILON;
    }
    function AC(n) {
        return n.clone ? n.clone() : new Array(n.length);
    }
    function wC(n, e, t) {
        if (Ys(n)) {
            const i = n;
            t = t || AC(i);
            for(let r = 0; r < t.length && r < i.length; ++r){
                const a = typeof n == "number" ? n : n[r];
                t[r] = e(a, r, t);
            }
            return t;
        }
        return e(n);
    }
    class aT extends Array {
        clone() {
            return new this.constructor().copy(this);
        }
        fromArray(e, t = 0) {
            for(let i = 0; i < this.ELEMENTS; ++i)this[i] = e[i + t];
            return this.check();
        }
        toArray(e = [], t = 0) {
            for(let i = 0; i < this.ELEMENTS; ++i)e[t + i] = this[i];
            return e;
        }
        toObject(e) {
            return e;
        }
        from(e) {
            return Array.isArray(e) ? this.copy(e) : this.fromObject(e);
        }
        to(e) {
            return e === this ? this : Ys(e) ? this.toArray(e) : this.toObject(e);
        }
        toTarget(e) {
            return e ? this.to(e) : this;
        }
        toFloat32Array() {
            return new Float32Array(this);
        }
        toString() {
            return this.formatString(yn);
        }
        formatString(e) {
            let t = "";
            for(let i = 0; i < this.ELEMENTS; ++i)t += (i > 0 ? ", " : "") + xC(this[i], e);
            return `${e.printTypes ? this.constructor.name : ""}[${t}]`;
        }
        equals(e) {
            if (!e || this.length !== e.length) return !1;
            for(let t = 0; t < this.ELEMENTS; ++t)if (!xo(this[t], e[t])) return !1;
            return !0;
        }
        exactEquals(e) {
            if (!e || this.length !== e.length) return !1;
            for(let t = 0; t < this.ELEMENTS; ++t)if (this[t] !== e[t]) return !1;
            return !0;
        }
        negate() {
            for(let e = 0; e < this.ELEMENTS; ++e)this[e] = -this[e];
            return this.check();
        }
        lerp(e, t, i) {
            if (i === void 0) return this.lerp(this, e, t);
            for(let r = 0; r < this.ELEMENTS; ++r){
                const a = e[r], l = typeof t == "number" ? t : t[r];
                this[r] = a + i * (l - a);
            }
            return this.check();
        }
        min(e) {
            for(let t = 0; t < this.ELEMENTS; ++t)this[t] = Math.min(e[t], this[t]);
            return this.check();
        }
        max(e) {
            for(let t = 0; t < this.ELEMENTS; ++t)this[t] = Math.max(e[t], this[t]);
            return this.check();
        }
        clamp(e, t) {
            for(let i = 0; i < this.ELEMENTS; ++i)this[i] = Math.min(Math.max(this[i], e[i]), t[i]);
            return this.check();
        }
        add(...e) {
            for (const t of e)for(let i = 0; i < this.ELEMENTS; ++i)this[i] += t[i];
            return this.check();
        }
        subtract(...e) {
            for (const t of e)for(let i = 0; i < this.ELEMENTS; ++i)this[i] -= t[i];
            return this.check();
        }
        scale(e) {
            if (typeof e == "number") for(let t = 0; t < this.ELEMENTS; ++t)this[t] *= e;
            else for(let t = 0; t < this.ELEMENTS && t < e.length; ++t)this[t] *= e[t];
            return this.check();
        }
        multiplyByScalar(e) {
            for(let t = 0; t < this.ELEMENTS; ++t)this[t] *= e;
            return this.check();
        }
        check() {
            if (yn.debug && !this.validate()) throw new Error(`math.gl: ${this.constructor.name} some fields set to invalid numbers'`);
            return this;
        }
        validate() {
            let e = this.length === this.ELEMENTS;
            for(let t = 0; t < this.ELEMENTS; ++t)e = e && Number.isFinite(this[t]);
            return e;
        }
        sub(e) {
            return this.subtract(e);
        }
        setScalar(e) {
            for(let t = 0; t < this.ELEMENTS; ++t)this[t] = e;
            return this.check();
        }
        addScalar(e) {
            for(let t = 0; t < this.ELEMENTS; ++t)this[t] += e;
            return this.check();
        }
        subScalar(e) {
            return this.addScalar(-e);
        }
        multiplyScalar(e) {
            for(let t = 0; t < this.ELEMENTS; ++t)this[t] *= e;
            return this.check();
        }
        divideScalar(e) {
            return this.multiplyByScalar(1 / e);
        }
        clampScalar(e, t) {
            for(let i = 0; i < this.ELEMENTS; ++i)this[i] = Math.min(Math.max(this[i], e), t);
            return this.check();
        }
        get elements() {
            return this;
        }
    }
    function EC(n, e) {
        if (n.length !== e) return !1;
        for(let t = 0; t < n.length; ++t)if (!Number.isFinite(n[t])) return !1;
        return !0;
    }
    function rn(n) {
        if (!Number.isFinite(n)) throw new Error(`Invalid number ${JSON.stringify(n)}`);
        return n;
    }
    function $h(n, e, t = "") {
        if (yn.debug && !EC(n, e)) throw new Error(`math.gl: ${t} some fields set to invalid numbers'`);
        return n;
    }
    function e0(n, e) {
        if (!n) throw new Error(`math.gl assertion ${e}`);
    }
    class RC extends aT {
        get x() {
            return this[0];
        }
        set x(e) {
            this[0] = rn(e);
        }
        get y() {
            return this[1];
        }
        set y(e) {
            this[1] = rn(e);
        }
        len() {
            return Math.sqrt(this.lengthSquared());
        }
        magnitude() {
            return this.len();
        }
        lengthSquared() {
            let e = 0;
            for(let t = 0; t < this.ELEMENTS; ++t)e += this[t] * this[t];
            return e;
        }
        magnitudeSquared() {
            return this.lengthSquared();
        }
        distance(e) {
            return Math.sqrt(this.distanceSquared(e));
        }
        distanceSquared(e) {
            let t = 0;
            for(let i = 0; i < this.ELEMENTS; ++i){
                const r = this[i] - e[i];
                t += r * r;
            }
            return rn(t);
        }
        dot(e) {
            let t = 0;
            for(let i = 0; i < this.ELEMENTS; ++i)t += this[i] * e[i];
            return rn(t);
        }
        normalize() {
            const e = this.magnitude();
            if (e !== 0) for(let t = 0; t < this.ELEMENTS; ++t)this[t] /= e;
            return this.check();
        }
        multiply(...e) {
            for (const t of e)for(let i = 0; i < this.ELEMENTS; ++i)this[i] *= t[i];
            return this.check();
        }
        divide(...e) {
            for (const t of e)for(let i = 0; i < this.ELEMENTS; ++i)this[i] /= t[i];
            return this.check();
        }
        lengthSq() {
            return this.lengthSquared();
        }
        distanceTo(e) {
            return this.distance(e);
        }
        distanceToSquared(e) {
            return this.distanceSquared(e);
        }
        getComponent(e) {
            return e0(e >= 0 && e < this.ELEMENTS, "index is out of range"), rn(this[e]);
        }
        setComponent(e, t) {
            return e0(e >= 0 && e < this.ELEMENTS, "index is out of range"), this[e] = t, this.check();
        }
        addVectors(e, t) {
            return this.copy(e).add(t);
        }
        subVectors(e, t) {
            return this.copy(e).subtract(t);
        }
        multiplyVectors(e, t) {
            return this.copy(e).multiply(t);
        }
        addScaledVector(e, t) {
            return this.add(new this.constructor(e).multiplyScalar(t));
        }
    }
    const pc = 1e-6;
    let qs = typeof Float32Array < "u" ? Float32Array : Array;
    function CC() {
        const n = new qs(2);
        return qs != Float32Array && (n[0] = 0, n[1] = 0), n;
    }
    function t0(n, e, t) {
        return n[0] = e[0] + t[0], n[1] = e[1] + t[1], n;
    }
    function MC(n, e) {
        return n[0] = -e[0], n[1] = -e[1], n;
    }
    function oT(n, e, t, i) {
        const r = e[0], a = e[1];
        return n[0] = r + i * (t[0] - r), n[1] = a + i * (t[1] - a), n;
    }
    function OC(n, e, t) {
        const i = e[0], r = e[1];
        return n[0] = t[0] * i + t[4] * r + t[12], n[1] = t[1] * i + t[5] * r + t[13], n;
    }
    (function() {
        const n = CC();
        return function(e, t, i, r, a, l) {
            let u, h;
            for(t || (t = 2), i || (i = 0), r ? h = Math.min(r * t + i, e.length) : h = e.length, u = i; u < h; u += t)n[0] = e[u], n[1] = e[u + 1], a(n, n, l), e[u] = n[0], e[u + 1] = n[1];
            return e;
        };
    })();
    function IC(n, e, t) {
        const i = e[0], r = e[1], a = t[3] * i + t[7] * r || 1;
        return n[0] = (t[0] * i + t[4] * r) / a, n[1] = (t[1] * i + t[5] * r) / a, n;
    }
    function lT(n, e, t) {
        const i = e[0], r = e[1], a = e[2], l = t[3] * i + t[7] * r + t[11] * a || 1;
        return n[0] = (t[0] * i + t[4] * r + t[8] * a) / l, n[1] = (t[1] * i + t[5] * r + t[9] * a) / l, n[2] = (t[2] * i + t[6] * r + t[10] * a) / l, n;
    }
    function NC(n, e, t) {
        const i = e[0], r = e[1];
        return n[0] = t[0] * i + t[2] * r, n[1] = t[1] * i + t[3] * r, n[2] = e[2], n;
    }
    function PC() {
        const n = new qs(3);
        return qs != Float32Array && (n[0] = 0, n[1] = 0, n[2] = 0), n;
    }
    function DC(n, e, t) {
        return n[0] = e[0] - t[0], n[1] = e[1] - t[1], n[2] = e[2] - t[2], n;
    }
    function kC(n, e) {
        return n[0] = -e[0], n[1] = -e[1], n[2] = -e[2], n;
    }
    function UC(n, e) {
        return n[0] * e[0] + n[1] * e[1] + n[2] * e[2];
    }
    function BC(n, e, t) {
        const i = e[0], r = e[1], a = e[2], l = t[0], u = t[1], h = t[2];
        return n[0] = r * h - a * u, n[1] = a * l - i * h, n[2] = i * u - r * l, n;
    }
    function cT(n, e, t) {
        const i = e[0], r = e[1], a = e[2];
        let l = t[3] * i + t[7] * r + t[11] * a + t[15];
        return l = l || 1, n[0] = (t[0] * i + t[4] * r + t[8] * a + t[12]) / l, n[1] = (t[1] * i + t[5] * r + t[9] * a + t[13]) / l, n[2] = (t[2] * i + t[6] * r + t[10] * a + t[14]) / l, n;
    }
    function LC(n, e, t) {
        const i = e[0], r = e[1], a = e[2];
        return n[0] = i * t[0] + r * t[3] + a * t[6], n[1] = i * t[1] + r * t[4] + a * t[7], n[2] = i * t[2] + r * t[5] + a * t[8], n;
    }
    function FC(n, e, t) {
        const i = t[0], r = t[1], a = t[2], l = t[3], u = e[0], h = e[1], d = e[2];
        let p = r * d - a * h, _ = a * u - i * d, y = i * h - r * u, v = r * y - a * _, S = a * p - i * y, E = i * _ - r * p;
        const M = l * 2;
        return p *= M, _ *= M, y *= M, v *= 2, S *= 2, E *= 2, n[0] = u + p + v, n[1] = h + _ + S, n[2] = d + y + E, n;
    }
    function zC(n, e, t, i) {
        const r = [], a = [];
        return r[0] = e[0] - t[0], r[1] = e[1] - t[1], r[2] = e[2] - t[2], a[0] = r[0], a[1] = r[1] * Math.cos(i) - r[2] * Math.sin(i), a[2] = r[1] * Math.sin(i) + r[2] * Math.cos(i), n[0] = a[0] + t[0], n[1] = a[1] + t[1], n[2] = a[2] + t[2], n;
    }
    function VC(n, e, t, i) {
        const r = [], a = [];
        return r[0] = e[0] - t[0], r[1] = e[1] - t[1], r[2] = e[2] - t[2], a[0] = r[2] * Math.sin(i) + r[0] * Math.cos(i), a[1] = r[1], a[2] = r[2] * Math.cos(i) - r[0] * Math.sin(i), n[0] = a[0] + t[0], n[1] = a[1] + t[1], n[2] = a[2] + t[2], n;
    }
    function HC(n, e, t, i) {
        const r = [], a = [];
        return r[0] = e[0] - t[0], r[1] = e[1] - t[1], r[2] = e[2] - t[2], a[0] = r[0] * Math.cos(i) - r[1] * Math.sin(i), a[1] = r[0] * Math.sin(i) + r[1] * Math.cos(i), a[2] = r[2], n[0] = a[0] + t[0], n[1] = a[1] + t[1], n[2] = a[2] + t[2], n;
    }
    function jC(n, e) {
        const t = n[0], i = n[1], r = n[2], a = e[0], l = e[1], u = e[2], h = Math.sqrt((t * t + i * i + r * r) * (a * a + l * l + u * u)), d = h && UC(n, e) / h;
        return Math.acos(Math.min(Math.max(d, -1), 1));
    }
    const WC = DC;
    (function() {
        const n = PC();
        return function(e, t, i, r, a, l) {
            let u, h;
            for(t || (t = 3), i || (i = 0), r ? h = Math.min(r * t + i, e.length) : h = e.length, u = i; u < h; u += t)n[0] = e[u], n[1] = e[u + 1], n[2] = e[u + 2], a(n, n, l), e[u] = n[0], e[u + 1] = n[1], e[u + 2] = n[2];
            return e;
        };
    })();
    const Xh = [
        0,
        0,
        0
    ];
    let nc;
    class jn extends RC {
        static get ZERO() {
            return nc || (nc = new jn(0, 0, 0), Object.freeze(nc)), nc;
        }
        constructor(e = 0, t = 0, i = 0){
            super(-0, -0, -0), arguments.length === 1 && Ys(e) ? this.copy(e) : (yn.debug && (rn(e), rn(t), rn(i)), this[0] = e, this[1] = t, this[2] = i);
        }
        set(e, t, i) {
            return this[0] = e, this[1] = t, this[2] = i, this.check();
        }
        copy(e) {
            return this[0] = e[0], this[1] = e[1], this[2] = e[2], this.check();
        }
        fromObject(e) {
            return yn.debug && (rn(e.x), rn(e.y), rn(e.z)), this[0] = e.x, this[1] = e.y, this[2] = e.z, this.check();
        }
        toObject(e) {
            return e.x = this[0], e.y = this[1], e.z = this[2], e;
        }
        get ELEMENTS() {
            return 3;
        }
        get z() {
            return this[2];
        }
        set z(e) {
            this[2] = rn(e);
        }
        angle(e) {
            return jC(this, e);
        }
        cross(e) {
            return BC(this, this, e), this.check();
        }
        rotateX({ radians: e, origin: t = Xh }) {
            return zC(this, this, t, e), this.check();
        }
        rotateY({ radians: e, origin: t = Xh }) {
            return VC(this, this, t, e), this.check();
        }
        rotateZ({ radians: e, origin: t = Xh }) {
            return HC(this, this, t, e), this.check();
        }
        transform(e) {
            return this.transformAsPoint(e);
        }
        transformAsPoint(e) {
            return cT(this, this, e), this.check();
        }
        transformAsVector(e) {
            return lT(this, this, e), this.check();
        }
        transformByMatrix3(e) {
            return LC(this, this, e), this.check();
        }
        transformByMatrix2(e) {
            return NC(this, this, e), this.check();
        }
        transformByQuaternion(e) {
            return FC(this, this, e), this.check();
        }
    }
    class $C extends aT {
        toString() {
            let e = "[";
            if (yn.printRowMajor) {
                e += "row-major:";
                for(let t = 0; t < this.RANK; ++t)for(let i = 0; i < this.RANK; ++i)e += ` ${this[i * this.RANK + t]}`;
            } else {
                e += "column-major:";
                for(let t = 0; t < this.ELEMENTS; ++t)e += ` ${this[t]}`;
            }
            return e += "]", e;
        }
        getElementIndex(e, t) {
            return t * this.RANK + e;
        }
        getElement(e, t) {
            return this[t * this.RANK + e];
        }
        setElement(e, t, i) {
            return this[t * this.RANK + e] = rn(i), this;
        }
        getColumn(e, t = new Array(this.RANK).fill(-0)) {
            const i = e * this.RANK;
            for(let r = 0; r < this.RANK; ++r)t[r] = this[i + r];
            return t;
        }
        setColumn(e, t) {
            const i = e * this.RANK;
            for(let r = 0; r < this.RANK; ++r)this[i + r] = t[r];
            return this;
        }
    }
    function XC(n) {
        return n[0] = 1, n[1] = 0, n[2] = 0, n[3] = 0, n[4] = 0, n[5] = 1, n[6] = 0, n[7] = 0, n[8] = 0, n[9] = 0, n[10] = 1, n[11] = 0, n[12] = 0, n[13] = 0, n[14] = 0, n[15] = 1, n;
    }
    function YC(n, e) {
        if (n === e) {
            const t = e[1], i = e[2], r = e[3], a = e[6], l = e[7], u = e[11];
            n[1] = e[4], n[2] = e[8], n[3] = e[12], n[4] = t, n[6] = e[9], n[7] = e[13], n[8] = i, n[9] = a, n[11] = e[14], n[12] = r, n[13] = l, n[14] = u;
        } else n[0] = e[0], n[1] = e[4], n[2] = e[8], n[3] = e[12], n[4] = e[1], n[5] = e[5], n[6] = e[9], n[7] = e[13], n[8] = e[2], n[9] = e[6], n[10] = e[10], n[11] = e[14], n[12] = e[3], n[13] = e[7], n[14] = e[11], n[15] = e[15];
        return n;
    }
    function Cd(n, e) {
        const t = e[0], i = e[1], r = e[2], a = e[3], l = e[4], u = e[5], h = e[6], d = e[7], p = e[8], _ = e[9], y = e[10], v = e[11], S = e[12], E = e[13], M = e[14], B = e[15], H = t * u - i * l, O = t * h - r * l, U = t * d - a * l, L = i * h - r * u, Z = i * d - a * u, se = r * d - a * h, ae = p * E - _ * S, te = p * M - y * S, fe = p * B - v * S, ne = _ * M - y * E, ve = _ * B - v * E, Te = y * B - v * M;
        let ue = H * Te - O * ve + U * ne + L * fe - Z * te + se * ae;
        return ue ? (ue = 1 / ue, n[0] = (u * Te - h * ve + d * ne) * ue, n[1] = (r * ve - i * Te - a * ne) * ue, n[2] = (E * se - M * Z + B * L) * ue, n[3] = (y * Z - _ * se - v * L) * ue, n[4] = (h * fe - l * Te - d * te) * ue, n[5] = (t * Te - r * fe + a * te) * ue, n[6] = (M * U - S * se - B * O) * ue, n[7] = (p * se - y * U + v * O) * ue, n[8] = (l * ve - u * fe + d * ae) * ue, n[9] = (i * fe - t * ve - a * ae) * ue, n[10] = (S * Z - E * U + B * H) * ue, n[11] = (_ * U - p * Z - v * H) * ue, n[12] = (u * te - l * ne - h * ae) * ue, n[13] = (t * ne - i * te + r * ae) * ue, n[14] = (E * O - S * L - M * H) * ue, n[15] = (p * L - _ * O + y * H) * ue, n) : null;
    }
    function qC(n) {
        const e = n[0], t = n[1], i = n[2], r = n[3], a = n[4], l = n[5], u = n[6], h = n[7], d = n[8], p = n[9], _ = n[10], y = n[11], v = n[12], S = n[13], E = n[14], M = n[15], B = e * l - t * a, H = e * u - i * a, O = t * u - i * l, U = d * S - p * v, L = d * E - _ * v, Z = p * E - _ * S, se = e * Z - t * L + i * U, ae = a * Z - l * L + u * U, te = d * O - p * H + _ * B, fe = v * O - S * H + E * B;
        return h * se - r * ae + M * te - y * fe;
    }
    function wr(n, e, t) {
        const i = e[0], r = e[1], a = e[2], l = e[3], u = e[4], h = e[5], d = e[6], p = e[7], _ = e[8], y = e[9], v = e[10], S = e[11], E = e[12], M = e[13], B = e[14], H = e[15];
        let O = t[0], U = t[1], L = t[2], Z = t[3];
        return n[0] = O * i + U * u + L * _ + Z * E, n[1] = O * r + U * h + L * y + Z * M, n[2] = O * a + U * d + L * v + Z * B, n[3] = O * l + U * p + L * S + Z * H, O = t[4], U = t[5], L = t[6], Z = t[7], n[4] = O * i + U * u + L * _ + Z * E, n[5] = O * r + U * h + L * y + Z * M, n[6] = O * a + U * d + L * v + Z * B, n[7] = O * l + U * p + L * S + Z * H, O = t[8], U = t[9], L = t[10], Z = t[11], n[8] = O * i + U * u + L * _ + Z * E, n[9] = O * r + U * h + L * y + Z * M, n[10] = O * a + U * d + L * v + Z * B, n[11] = O * l + U * p + L * S + Z * H, O = t[12], U = t[13], L = t[14], Z = t[15], n[12] = O * i + U * u + L * _ + Z * E, n[13] = O * r + U * h + L * y + Z * M, n[14] = O * a + U * d + L * v + Z * B, n[15] = O * l + U * p + L * S + Z * H, n;
    }
    function Pc(n, e, t) {
        const i = t[0], r = t[1], a = t[2];
        let l, u, h, d, p, _, y, v, S, E, M, B;
        return e === n ? (n[12] = e[0] * i + e[4] * r + e[8] * a + e[12], n[13] = e[1] * i + e[5] * r + e[9] * a + e[13], n[14] = e[2] * i + e[6] * r + e[10] * a + e[14], n[15] = e[3] * i + e[7] * r + e[11] * a + e[15]) : (l = e[0], u = e[1], h = e[2], d = e[3], p = e[4], _ = e[5], y = e[6], v = e[7], S = e[8], E = e[9], M = e[10], B = e[11], n[0] = l, n[1] = u, n[2] = h, n[3] = d, n[4] = p, n[5] = _, n[6] = y, n[7] = v, n[8] = S, n[9] = E, n[10] = M, n[11] = B, n[12] = l * i + p * r + S * a + e[12], n[13] = u * i + _ * r + E * a + e[13], n[14] = h * i + y * r + M * a + e[14], n[15] = d * i + v * r + B * a + e[15]), n;
    }
    function Rg(n, e, t) {
        const i = t[0], r = t[1], a = t[2];
        return n[0] = e[0] * i, n[1] = e[1] * i, n[2] = e[2] * i, n[3] = e[3] * i, n[4] = e[4] * r, n[5] = e[5] * r, n[6] = e[6] * r, n[7] = e[7] * r, n[8] = e[8] * a, n[9] = e[9] * a, n[10] = e[10] * a, n[11] = e[11] * a, n[12] = e[12], n[13] = e[13], n[14] = e[14], n[15] = e[15], n;
    }
    function KC(n, e, t, i) {
        let r = i[0], a = i[1], l = i[2], u = Math.sqrt(r * r + a * a + l * l), h, d, p, _, y, v, S, E, M, B, H, O, U, L, Z, se, ae, te, fe, ne, ve, Te, ue, Ie;
        return u < pc ? null : (u = 1 / u, r *= u, a *= u, l *= u, d = Math.sin(t), h = Math.cos(t), p = 1 - h, _ = e[0], y = e[1], v = e[2], S = e[3], E = e[4], M = e[5], B = e[6], H = e[7], O = e[8], U = e[9], L = e[10], Z = e[11], se = r * r * p + h, ae = a * r * p + l * d, te = l * r * p - a * d, fe = r * a * p - l * d, ne = a * a * p + h, ve = l * a * p + r * d, Te = r * l * p + a * d, ue = a * l * p - r * d, Ie = l * l * p + h, n[0] = _ * se + E * ae + O * te, n[1] = y * se + M * ae + U * te, n[2] = v * se + B * ae + L * te, n[3] = S * se + H * ae + Z * te, n[4] = _ * fe + E * ne + O * ve, n[5] = y * fe + M * ne + U * ve, n[6] = v * fe + B * ne + L * ve, n[7] = S * fe + H * ne + Z * ve, n[8] = _ * Te + E * ue + O * Ie, n[9] = y * Te + M * ue + U * Ie, n[10] = v * Te + B * ue + L * Ie, n[11] = S * Te + H * ue + Z * Ie, e !== n && (n[12] = e[12], n[13] = e[13], n[14] = e[14], n[15] = e[15]), n);
    }
    function uT(n, e, t) {
        const i = Math.sin(t), r = Math.cos(t), a = e[4], l = e[5], u = e[6], h = e[7], d = e[8], p = e[9], _ = e[10], y = e[11];
        return e !== n && (n[0] = e[0], n[1] = e[1], n[2] = e[2], n[3] = e[3], n[12] = e[12], n[13] = e[13], n[14] = e[14], n[15] = e[15]), n[4] = a * r + d * i, n[5] = l * r + p * i, n[6] = u * r + _ * i, n[7] = h * r + y * i, n[8] = d * r - a * i, n[9] = p * r - l * i, n[10] = _ * r - u * i, n[11] = y * r - h * i, n;
    }
    function ZC(n, e, t) {
        const i = Math.sin(t), r = Math.cos(t), a = e[0], l = e[1], u = e[2], h = e[3], d = e[8], p = e[9], _ = e[10], y = e[11];
        return e !== n && (n[4] = e[4], n[5] = e[5], n[6] = e[6], n[7] = e[7], n[12] = e[12], n[13] = e[13], n[14] = e[14], n[15] = e[15]), n[0] = a * r - d * i, n[1] = l * r - p * i, n[2] = u * r - _ * i, n[3] = h * r - y * i, n[8] = a * i + d * r, n[9] = l * i + p * r, n[10] = u * i + _ * r, n[11] = h * i + y * r, n;
    }
    function fT(n, e, t) {
        const i = Math.sin(t), r = Math.cos(t), a = e[0], l = e[1], u = e[2], h = e[3], d = e[4], p = e[5], _ = e[6], y = e[7];
        return e !== n && (n[8] = e[8], n[9] = e[9], n[10] = e[10], n[11] = e[11], n[12] = e[12], n[13] = e[13], n[14] = e[14], n[15] = e[15]), n[0] = a * r + d * i, n[1] = l * r + p * i, n[2] = u * r + _ * i, n[3] = h * r + y * i, n[4] = d * r - a * i, n[5] = p * r - l * i, n[6] = _ * r - u * i, n[7] = y * r - h * i, n;
    }
    function QC(n, e) {
        const t = e[0], i = e[1], r = e[2], a = e[3], l = t + t, u = i + i, h = r + r, d = t * l, p = i * l, _ = i * u, y = r * l, v = r * u, S = r * h, E = a * l, M = a * u, B = a * h;
        return n[0] = 1 - _ - S, n[1] = p + B, n[2] = y - M, n[3] = 0, n[4] = p - B, n[5] = 1 - d - S, n[6] = v + E, n[7] = 0, n[8] = y + M, n[9] = v - E, n[10] = 1 - d - _, n[11] = 0, n[12] = 0, n[13] = 0, n[14] = 0, n[15] = 1, n;
    }
    function GC(n, e, t, i, r, a, l) {
        const u = 1 / (t - e), h = 1 / (r - i), d = 1 / (a - l);
        return n[0] = a * 2 * u, n[1] = 0, n[2] = 0, n[3] = 0, n[4] = 0, n[5] = a * 2 * h, n[6] = 0, n[7] = 0, n[8] = (t + e) * u, n[9] = (r + i) * h, n[10] = (l + a) * d, n[11] = -1, n[12] = 0, n[13] = 0, n[14] = l * a * 2 * d, n[15] = 0, n;
    }
    function JC(n, e, t, i, r) {
        const a = 1 / Math.tan(e / 2);
        if (n[0] = a / t, n[1] = 0, n[2] = 0, n[3] = 0, n[4] = 0, n[5] = a, n[6] = 0, n[7] = 0, n[8] = 0, n[9] = 0, n[11] = -1, n[12] = 0, n[13] = 0, n[15] = 0, r != null && r !== 1 / 0) {
            const l = 1 / (i - r);
            n[10] = (r + i) * l, n[14] = 2 * r * i * l;
        } else n[10] = -1, n[14] = -2 * i;
        return n;
    }
    const eM = JC;
    function tM(n, e, t, i, r, a, l) {
        const u = 1 / (e - t), h = 1 / (i - r), d = 1 / (a - l);
        return n[0] = -2 * u, n[1] = 0, n[2] = 0, n[3] = 0, n[4] = 0, n[5] = -2 * h, n[6] = 0, n[7] = 0, n[8] = 0, n[9] = 0, n[10] = 2 * d, n[11] = 0, n[12] = (e + t) * u, n[13] = (r + i) * h, n[14] = (l + a) * d, n[15] = 1, n;
    }
    const nM = tM;
    function iM(n, e, t, i) {
        let r, a, l, u, h, d, p, _, y, v;
        const S = e[0], E = e[1], M = e[2], B = i[0], H = i[1], O = i[2], U = t[0], L = t[1], Z = t[2];
        return Math.abs(S - U) < pc && Math.abs(E - L) < pc && Math.abs(M - Z) < pc ? XC(n) : (_ = S - U, y = E - L, v = M - Z, r = 1 / Math.sqrt(_ * _ + y * y + v * v), _ *= r, y *= r, v *= r, a = H * v - O * y, l = O * _ - B * v, u = B * y - H * _, r = Math.sqrt(a * a + l * l + u * u), r ? (r = 1 / r, a *= r, l *= r, u *= r) : (a = 0, l = 0, u = 0), h = y * u - v * l, d = v * a - _ * u, p = _ * l - y * a, r = Math.sqrt(h * h + d * d + p * p), r ? (r = 1 / r, h *= r, d *= r, p *= r) : (h = 0, d = 0, p = 0), n[0] = a, n[1] = h, n[2] = _, n[3] = 0, n[4] = l, n[5] = d, n[6] = y, n[7] = 0, n[8] = u, n[9] = p, n[10] = v, n[11] = 0, n[12] = -(a * S + l * E + u * M), n[13] = -(h * S + d * E + p * M), n[14] = -(_ * S + y * E + v * M), n[15] = 1, n);
    }
    function rM() {
        const n = new qs(4);
        return qs != Float32Array && (n[0] = 0, n[1] = 0, n[2] = 0, n[3] = 0), n;
    }
    function sM(n, e, t) {
        return n[0] = e[0] * t, n[1] = e[1] * t, n[2] = e[2] * t, n[3] = e[3] * t, n;
    }
    function Io(n, e, t) {
        const i = e[0], r = e[1], a = e[2], l = e[3];
        return n[0] = t[0] * i + t[4] * r + t[8] * a + t[12] * l, n[1] = t[1] * i + t[5] * r + t[9] * a + t[13] * l, n[2] = t[2] * i + t[6] * r + t[10] * a + t[14] * l, n[3] = t[3] * i + t[7] * r + t[11] * a + t[15] * l, n;
    }
    (function() {
        const n = rM();
        return function(e, t, i, r, a, l) {
            let u, h;
            for(t || (t = 4), i || (i = 0), r ? h = Math.min(r * t + i, e.length) : h = e.length, u = i; u < h; u += t)n[0] = e[u], n[1] = e[u + 1], n[2] = e[u + 2], n[3] = e[u + 3], a(n, n, l), e[u] = n[0], e[u + 1] = n[1], e[u + 2] = n[2], e[u + 3] = n[3];
            return e;
        };
    })();
    var Md;
    (function(n) {
        n[n.COL0ROW0 = 0] = "COL0ROW0", n[n.COL0ROW1 = 1] = "COL0ROW1", n[n.COL0ROW2 = 2] = "COL0ROW2", n[n.COL0ROW3 = 3] = "COL0ROW3", n[n.COL1ROW0 = 4] = "COL1ROW0", n[n.COL1ROW1 = 5] = "COL1ROW1", n[n.COL1ROW2 = 6] = "COL1ROW2", n[n.COL1ROW3 = 7] = "COL1ROW3", n[n.COL2ROW0 = 8] = "COL2ROW0", n[n.COL2ROW1 = 9] = "COL2ROW1", n[n.COL2ROW2 = 10] = "COL2ROW2", n[n.COL2ROW3 = 11] = "COL2ROW3", n[n.COL3ROW0 = 12] = "COL3ROW0", n[n.COL3ROW1 = 13] = "COL3ROW1", n[n.COL3ROW2 = 14] = "COL3ROW2", n[n.COL3ROW3 = 15] = "COL3ROW3";
    })(Md || (Md = {}));
    const aM = 45 * Math.PI / 180, oM = 1, Yh = .1, qh = 500, lM = Object.freeze([
        1,
        0,
        0,
        0,
        0,
        1,
        0,
        0,
        0,
        0,
        1,
        0,
        0,
        0,
        0,
        1
    ]);
    class Wn extends $C {
        static get IDENTITY() {
            return uM();
        }
        static get ZERO() {
            return cM();
        }
        get ELEMENTS() {
            return 16;
        }
        get RANK() {
            return 4;
        }
        get INDICES() {
            return Md;
        }
        constructor(e){
            super(-0, -0, -0, -0, -0, -0, -0, -0, -0, -0, -0, -0, -0, -0, -0, -0), arguments.length === 1 && Array.isArray(e) ? this.copy(e) : this.identity();
        }
        copy(e) {
            return this[0] = e[0], this[1] = e[1], this[2] = e[2], this[3] = e[3], this[4] = e[4], this[5] = e[5], this[6] = e[6], this[7] = e[7], this[8] = e[8], this[9] = e[9], this[10] = e[10], this[11] = e[11], this[12] = e[12], this[13] = e[13], this[14] = e[14], this[15] = e[15], this.check();
        }
        set(e, t, i, r, a, l, u, h, d, p, _, y, v, S, E, M) {
            return this[0] = e, this[1] = t, this[2] = i, this[3] = r, this[4] = a, this[5] = l, this[6] = u, this[7] = h, this[8] = d, this[9] = p, this[10] = _, this[11] = y, this[12] = v, this[13] = S, this[14] = E, this[15] = M, this.check();
        }
        setRowMajor(e, t, i, r, a, l, u, h, d, p, _, y, v, S, E, M) {
            return this[0] = e, this[1] = a, this[2] = d, this[3] = v, this[4] = t, this[5] = l, this[6] = p, this[7] = S, this[8] = i, this[9] = u, this[10] = _, this[11] = E, this[12] = r, this[13] = h, this[14] = y, this[15] = M, this.check();
        }
        toRowMajor(e) {
            return e[0] = this[0], e[1] = this[4], e[2] = this[8], e[3] = this[12], e[4] = this[1], e[5] = this[5], e[6] = this[9], e[7] = this[13], e[8] = this[2], e[9] = this[6], e[10] = this[10], e[11] = this[14], e[12] = this[3], e[13] = this[7], e[14] = this[11], e[15] = this[15], e;
        }
        identity() {
            return this.copy(lM);
        }
        fromObject(e) {
            return this.check();
        }
        fromQuaternion(e) {
            return QC(this, e), this.check();
        }
        frustum(e) {
            const { left: t, right: i, bottom: r, top: a, near: l = Yh, far: u = qh } = e;
            return u === 1 / 0 ? fM(this, t, i, r, a, l) : GC(this, t, i, r, a, l, u), this.check();
        }
        lookAt(e) {
            const { eye: t, center: i = [
                0,
                0,
                0
            ], up: r = [
                0,
                1,
                0
            ] } = e;
            return iM(this, t, i, r), this.check();
        }
        ortho(e) {
            const { left: t, right: i, bottom: r, top: a, near: l = Yh, far: u = qh } = e;
            return nM(this, t, i, r, a, l, u), this.check();
        }
        orthographic(e) {
            const { fovy: t = aM, aspect: i = oM, focalDistance: r = 1, near: a = Yh, far: l = qh } = e;
            n0(t);
            const u = t / 2, h = r * Math.tan(u), d = h * i;
            return this.ortho({
                left: -d,
                right: d,
                bottom: -h,
                top: h,
                near: a,
                far: l
            });
        }
        perspective(e) {
            const { fovy: t = 45 * Math.PI / 180, aspect: i = 1, near: r = .1, far: a = 500 } = e;
            return n0(t), eM(this, t, i, r, a), this.check();
        }
        determinant() {
            return qC(this);
        }
        getScale(e = [
            -0,
            -0,
            -0
        ]) {
            return e[0] = Math.sqrt(this[0] * this[0] + this[1] * this[1] + this[2] * this[2]), e[1] = Math.sqrt(this[4] * this[4] + this[5] * this[5] + this[6] * this[6]), e[2] = Math.sqrt(this[8] * this[8] + this[9] * this[9] + this[10] * this[10]), e;
        }
        getTranslation(e = [
            -0,
            -0,
            -0
        ]) {
            return e[0] = this[12], e[1] = this[13], e[2] = this[14], e;
        }
        getRotation(e, t) {
            e = e || [
                -0,
                -0,
                -0,
                -0,
                -0,
                -0,
                -0,
                -0,
                -0,
                -0,
                -0,
                -0,
                -0,
                -0,
                -0,
                -0
            ], t = t || [
                -0,
                -0,
                -0
            ];
            const i = this.getScale(t), r = 1 / i[0], a = 1 / i[1], l = 1 / i[2];
            return e[0] = this[0] * r, e[1] = this[1] * a, e[2] = this[2] * l, e[3] = 0, e[4] = this[4] * r, e[5] = this[5] * a, e[6] = this[6] * l, e[7] = 0, e[8] = this[8] * r, e[9] = this[9] * a, e[10] = this[10] * l, e[11] = 0, e[12] = 0, e[13] = 0, e[14] = 0, e[15] = 1, e;
        }
        getRotationMatrix3(e, t) {
            e = e || [
                -0,
                -0,
                -0,
                -0,
                -0,
                -0,
                -0,
                -0,
                -0
            ], t = t || [
                -0,
                -0,
                -0
            ];
            const i = this.getScale(t), r = 1 / i[0], a = 1 / i[1], l = 1 / i[2];
            return e[0] = this[0] * r, e[1] = this[1] * a, e[2] = this[2] * l, e[3] = this[4] * r, e[4] = this[5] * a, e[5] = this[6] * l, e[6] = this[8] * r, e[7] = this[9] * a, e[8] = this[10] * l, e;
        }
        transpose() {
            return YC(this, this), this.check();
        }
        invert() {
            return Cd(this, this), this.check();
        }
        multiplyLeft(e) {
            return wr(this, e, this), this.check();
        }
        multiplyRight(e) {
            return wr(this, this, e), this.check();
        }
        rotateX(e) {
            return uT(this, this, e), this.check();
        }
        rotateY(e) {
            return ZC(this, this, e), this.check();
        }
        rotateZ(e) {
            return fT(this, this, e), this.check();
        }
        rotateXYZ(e) {
            return this.rotateX(e[0]).rotateY(e[1]).rotateZ(e[2]);
        }
        rotateAxis(e, t) {
            return KC(this, this, e, t), this.check();
        }
        scale(e) {
            return Rg(this, this, Array.isArray(e) ? e : [
                e,
                e,
                e
            ]), this.check();
        }
        translate(e) {
            return Pc(this, this, e), this.check();
        }
        transform(e, t) {
            return e.length === 4 ? (t = Io(t || [
                -0,
                -0,
                -0,
                -0
            ], e, this), $h(t, 4), t) : this.transformAsPoint(e, t);
        }
        transformAsPoint(e, t) {
            const { length: i } = e;
            let r;
            switch(i){
                case 2:
                    r = OC(t || [
                        -0,
                        -0
                    ], e, this);
                    break;
                case 3:
                    r = cT(t || [
                        -0,
                        -0,
                        -0
                    ], e, this);
                    break;
                default:
                    throw new Error("Illegal vector");
            }
            return $h(r, e.length), r;
        }
        transformAsVector(e, t) {
            let i;
            switch(e.length){
                case 2:
                    i = IC(t || [
                        -0,
                        -0
                    ], e, this);
                    break;
                case 3:
                    i = lT(t || [
                        -0,
                        -0,
                        -0
                    ], e, this);
                    break;
                default:
                    throw new Error("Illegal vector");
            }
            return $h(i, e.length), i;
        }
        transformPoint(e, t) {
            return this.transformAsPoint(e, t);
        }
        transformVector(e, t) {
            return this.transformAsPoint(e, t);
        }
        transformDirection(e, t) {
            return this.transformAsVector(e, t);
        }
        makeRotationX(e) {
            return this.identity().rotateX(e);
        }
        makeTranslation(e, t, i) {
            return this.identity().translate([
                e,
                t,
                i
            ]);
        }
    }
    let ic, rc;
    function cM() {
        return ic || (ic = new Wn([
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0,
            0
        ]), Object.freeze(ic)), ic;
    }
    function uM() {
        return rc || (rc = new Wn, Object.freeze(rc)), rc;
    }
    function n0(n) {
        if (n > Math.PI * 2) throw Error("expected radians");
    }
    function fM(n, e, t, i, r, a) {
        const l = 2 * a / (t - e), u = 2 * a / (r - i), h = (t + e) / (t - e), d = (r + i) / (r - i), p = -1, _ = -1, y = -2 * a;
        return n[0] = l, n[1] = 0, n[2] = 0, n[3] = 0, n[4] = 0, n[5] = u, n[6] = 0, n[7] = 0, n[8] = h, n[9] = d, n[10] = p, n[11] = _, n[12] = 0, n[13] = 0, n[14] = y, n[15] = 0, n;
    }
    function hT(n, e = [], t = 0) {
        const i = Math.fround(n), r = n - i;
        return e[t] = i, e[t + 1] = r, e;
    }
    function hM(n) {
        return n - Math.fround(n);
    }
    function dM(n) {
        const e = new Float32Array(32);
        for(let t = 0; t < 4; ++t)for(let i = 0; i < 4; ++i){
            const r = t * 4 + i;
            hT(n[i * 4 + t], e, r * 2);
        }
        return e;
    }
    const gM = `#ifdef LUMA_FP32_TAN_PRECISION_WORKAROUND

// All these functions are for substituting tan() function from Intel GPU only
const float TWO_PI = 6.2831854820251465;
const float PI_2 = 1.5707963705062866;
const float PI_16 = 0.1963495463132858;

const float SIN_TABLE_0 = 0.19509032368659973;
const float SIN_TABLE_1 = 0.3826834261417389;
const float SIN_TABLE_2 = 0.5555702447891235;
const float SIN_TABLE_3 = 0.7071067690849304;

const float COS_TABLE_0 = 0.9807852506637573;
const float COS_TABLE_1 = 0.9238795042037964;
const float COS_TABLE_2 = 0.8314695954322815;
const float COS_TABLE_3 = 0.7071067690849304;

const float INVERSE_FACTORIAL_3 = 1.666666716337204e-01; // 1/3!
const float INVERSE_FACTORIAL_5 = 8.333333767950535e-03; // 1/5!
const float INVERSE_FACTORIAL_7 = 1.9841270113829523e-04; // 1/7!
const float INVERSE_FACTORIAL_9 = 2.75573188446287533e-06; // 1/9!

float sin_taylor_fp32(float a) {
  float r, s, t, x;

  if (a == 0.0) {
    return 0.0;
  }

  x = -a * a;
  s = a;
  r = a;

  r = r * x;
  t = r * INVERSE_FACTORIAL_3;
  s = s + t;

  r = r * x;
  t = r * INVERSE_FACTORIAL_5;
  s = s + t;

  r = r * x;
  t = r * INVERSE_FACTORIAL_7;
  s = s + t;

  r = r * x;
  t = r * INVERSE_FACTORIAL_9;
  s = s + t;

  return s;
}

void sincos_taylor_fp32(float a, out float sin_t, out float cos_t) {
  if (a == 0.0) {
    sin_t = 0.0;
    cos_t = 1.0;
  }
  sin_t = sin_taylor_fp32(a);
  cos_t = sqrt(1.0 - sin_t * sin_t);
}

float tan_taylor_fp32(float a) {
    float sin_a;
    float cos_a;

    if (a == 0.0) {
        return 0.0;
    }

    // 2pi range reduction
    float z = floor(a / TWO_PI);
    float r = a - TWO_PI * z;

    float t;
    float q = floor(r / PI_2 + 0.5);
    int j = int(q);

    if (j < -2 || j > 2) {
        return 1.0 / 0.0;
    }

    t = r - PI_2 * q;

    q = floor(t / PI_16 + 0.5);
    int k = int(q);
    int abs_k = int(abs(float(k)));

    if (abs_k > 4) {
        return 1.0 / 0.0;
    } else {
        t = t - PI_16 * q;
    }

    float u = 0.0;
    float v = 0.0;

    float sin_t, cos_t;
    float s, c;
    sincos_taylor_fp32(t, sin_t, cos_t);

    if (k == 0) {
        s = sin_t;
        c = cos_t;
    } else {
        if (abs(float(abs_k) - 1.0) < 0.5) {
            u = COS_TABLE_0;
            v = SIN_TABLE_0;
        } else if (abs(float(abs_k) - 2.0) < 0.5) {
            u = COS_TABLE_1;
            v = SIN_TABLE_1;
        } else if (abs(float(abs_k) - 3.0) < 0.5) {
            u = COS_TABLE_2;
            v = SIN_TABLE_2;
        } else if (abs(float(abs_k) - 4.0) < 0.5) {
            u = COS_TABLE_3;
            v = SIN_TABLE_3;
        }
        if (k > 0) {
            s = u * sin_t + v * cos_t;
            c = u * cos_t - v * sin_t;
        } else {
            s = u * sin_t - v * cos_t;
            c = u * cos_t + v * sin_t;
        }
    }

    if (j == 0) {
        sin_a = s;
        cos_a = c;
    } else if (j == 1) {
        sin_a = c;
        cos_a = -s;
    } else if (j == -1) {
        sin_a = -c;
        cos_a = s;
    } else {
        sin_a = -s;
        cos_a = -c;
    }
    return sin_a / cos_a;
}
#endif

float tan_fp32(float a) {
#ifdef LUMA_FP32_TAN_PRECISION_WORKAROUND
  return tan_taylor_fp32(a);
#else
  return tan(a);
#endif
}
`, pM = {
        name: "fp32",
        vs: gM
    }, mM = `
uniform fp64arithmeticUniforms {
  uniform float ONE;
} fp64;

/*
About LUMA_FP64_CODE_ELIMINATION_WORKAROUND

The purpose of this workaround is to prevent shader compilers from
optimizing away necessary arithmetic operations by swapping their sequences
or transform the equation to some 'equivalent' form.

The method is to multiply an artifical variable, ONE, which will be known to
the compiler to be 1 only at runtime. The whole expression is then represented
as a polynomial with respective to ONE. In the coefficients of all terms, only one a
and one b should appear

err = (a + b) * ONE^6 - a * ONE^5 - (a + b) * ONE^4 + a * ONE^3 - b - (a + b) * ONE^2 + a * ONE
*/

// Divide float number to high and low floats to extend fraction bits
vec2 split(float a) {
  const float SPLIT = 4097.0;
  float t = a * SPLIT;
#if defined(LUMA_FP64_CODE_ELIMINATION_WORKAROUND)
  float a_hi = t * fp64.ONE - (t - a);
  float a_lo = a * fp64.ONE - a_hi;
#else
  float a_hi = t - (t - a);
  float a_lo = a - a_hi;
#endif
  return vec2(a_hi, a_lo);
}

// Divide float number again when high float uses too many fraction bits
vec2 split2(vec2 a) {
  vec2 b = split(a.x);
  b.y += a.y;
  return b;
}

// Special sum operation when a > b
vec2 quickTwoSum(float a, float b) {
#if defined(LUMA_FP64_CODE_ELIMINATION_WORKAROUND)
  float sum = (a + b) * fp64.ONE;
  float err = b - (sum - a) * fp64.ONE;
#else
  float sum = a + b;
  float err = b - (sum - a);
#endif
  return vec2(sum, err);
}

// General sum operation
vec2 twoSum(float a, float b) {
  float s = (a + b);
#if defined(LUMA_FP64_CODE_ELIMINATION_WORKAROUND)
  float v = (s * fp64.ONE - a) * fp64.ONE;
  float err = (a - (s - v) * fp64.ONE) * fp64.ONE * fp64.ONE * fp64.ONE + (b - v);
#else
  float v = s - a;
  float err = (a - (s - v)) + (b - v);
#endif
  return vec2(s, err);
}

vec2 twoSub(float a, float b) {
  float s = (a - b);
#if defined(LUMA_FP64_CODE_ELIMINATION_WORKAROUND)
  float v = (s * fp64.ONE - a) * fp64.ONE;
  float err = (a - (s - v) * fp64.ONE) * fp64.ONE * fp64.ONE * fp64.ONE - (b + v);
#else
  float v = s - a;
  float err = (a - (s - v)) - (b + v);
#endif
  return vec2(s, err);
}

vec2 twoSqr(float a) {
  float prod = a * a;
  vec2 a_fp64 = split(a);
#if defined(LUMA_FP64_CODE_ELIMINATION_WORKAROUND)
  float err = ((a_fp64.x * a_fp64.x - prod) * fp64.ONE + 2.0 * a_fp64.x *
    a_fp64.y * fp64.ONE * fp64.ONE) + a_fp64.y * a_fp64.y * fp64.ONE * fp64.ONE * fp64.ONE;
#else
  float err = ((a_fp64.x * a_fp64.x - prod) + 2.0 * a_fp64.x * a_fp64.y) + a_fp64.y * a_fp64.y;
#endif
  return vec2(prod, err);
}

vec2 twoProd(float a, float b) {
  float prod = a * b;
  vec2 a_fp64 = split(a);
  vec2 b_fp64 = split(b);
  float err = ((a_fp64.x * b_fp64.x - prod) + a_fp64.x * b_fp64.y +
    a_fp64.y * b_fp64.x) + a_fp64.y * b_fp64.y;
  return vec2(prod, err);
}

vec2 sum_fp64(vec2 a, vec2 b) {
  vec2 s, t;
  s = twoSum(a.x, b.x);
  t = twoSum(a.y, b.y);
  s.y += t.x;
  s = quickTwoSum(s.x, s.y);
  s.y += t.y;
  s = quickTwoSum(s.x, s.y);
  return s;
}

vec2 sub_fp64(vec2 a, vec2 b) {
  vec2 s, t;
  s = twoSub(a.x, b.x);
  t = twoSub(a.y, b.y);
  s.y += t.x;
  s = quickTwoSum(s.x, s.y);
  s.y += t.y;
  s = quickTwoSum(s.x, s.y);
  return s;
}

vec2 mul_fp64(vec2 a, vec2 b) {
  vec2 prod = twoProd(a.x, b.x);
  // y component is for the error
  prod.y += a.x * b.y;
#if defined(LUMA_FP64_HIGH_BITS_OVERFLOW_WORKAROUND)
  prod = split2(prod);
#endif
  prod = quickTwoSum(prod.x, prod.y);
  prod.y += a.y * b.x;
#if defined(LUMA_FP64_HIGH_BITS_OVERFLOW_WORKAROUND)
  prod = split2(prod);
#endif
  prod = quickTwoSum(prod.x, prod.y);
  return prod;
}

vec2 div_fp64(vec2 a, vec2 b) {
  float xn = 1.0 / b.x;
#if defined(LUMA_FP64_HIGH_BITS_OVERFLOW_WORKAROUND)
  vec2 yn = mul_fp64(a, vec2(xn, 0));
#else
  vec2 yn = a * xn;
#endif
  float diff = (sub_fp64(a, mul_fp64(b, yn))).x;
  vec2 prod = twoProd(xn, diff);
  return sum_fp64(yn, prod);
}

vec2 sqrt_fp64(vec2 a) {
  if (a.x == 0.0 && a.y == 0.0) return vec2(0.0, 0.0);
  if (a.x < 0.0) return vec2(0.0 / 0.0, 0.0 / 0.0);

  float x = 1.0 / sqrt(a.x);
  float yn = a.x * x;
#if defined(LUMA_FP64_CODE_ELIMINATION_WORKAROUND)
  vec2 yn_sqr = twoSqr(yn) * fp64.ONE;
#else
  vec2 yn_sqr = twoSqr(yn);
#endif
  float diff = sub_fp64(a, yn_sqr).x;
  vec2 prod = twoProd(x * 0.5, diff);
#if defined(LUMA_FP64_HIGH_BITS_OVERFLOW_WORKAROUND)
  return sum_fp64(split(yn), prod);
#else
  return sum_fp64(vec2(yn, 0.0), prod);
#endif
}
`, _M = {
        ONE: 1
    }, yM = {
        name: "fp64arithmetic",
        vs: mM,
        defaultUniforms: _M,
        uniformTypes: {
            ONE: "f32"
        },
        fp64ify: hT,
        fp64LowPart: hM,
        fp64ifyMatrix4: dM
    }, bM = [
        0,
        1,
        1,
        1
    ], vM = `uniform pickingUniforms {
  float isActive;
  float isAttribute;
  float isHighlightActive;
  float useFloatColors;
  vec3 highlightedObjectColor;
  vec4 highlightColor;
} picking;

out vec4 picking_vRGBcolor_Avalid;

// Normalize unsigned byte color to 0-1 range
vec3 picking_normalizeColor(vec3 color) {
  return picking.useFloatColors > 0.5 ? color : color / 255.0;
}

// Normalize unsigned byte color to 0-1 range
vec4 picking_normalizeColor(vec4 color) {
  return picking.useFloatColors > 0.5 ? color : color / 255.0;
}

bool picking_isColorZero(vec3 color) {
  return dot(color, vec3(1.0)) < 0.00001;
}

bool picking_isColorValid(vec3 color) {
  return dot(color, vec3(1.0)) > 0.00001;
}

// Check if this vertex is highlighted 
bool isVertexHighlighted(vec3 vertexColor) {
  vec3 highlightedObjectColor = picking_normalizeColor(picking.highlightedObjectColor);
  return
    bool(picking.isHighlightActive) && picking_isColorZero(abs(vertexColor - highlightedObjectColor));
}

// Set the current picking color
void picking_setPickingColor(vec3 pickingColor) {
  pickingColor = picking_normalizeColor(pickingColor);

  if (bool(picking.isActive)) {
    // Use alpha as the validity flag. If pickingColor is [0, 0, 0] fragment is non-pickable
    picking_vRGBcolor_Avalid.a = float(picking_isColorValid(pickingColor));

    if (!bool(picking.isAttribute)) {
      // Stores the picking color so that the fragment shader can render it during picking
      picking_vRGBcolor_Avalid.rgb = pickingColor;
    }
  } else {
    // Do the comparison with selected item color in vertex shader as it should mean fewer compares
    picking_vRGBcolor_Avalid.a = float(isVertexHighlighted(pickingColor));
  }
}

void picking_setPickingAttribute(float value) {
  if (bool(picking.isAttribute)) {
    picking_vRGBcolor_Avalid.r = value;
  }
}

void picking_setPickingAttribute(vec2 value) {
  if (bool(picking.isAttribute)) {
    picking_vRGBcolor_Avalid.rg = value;
  }
}

void picking_setPickingAttribute(vec3 value) {
  if (bool(picking.isAttribute)) {
    picking_vRGBcolor_Avalid.rgb = value;
  }
}
`, TM = `uniform pickingUniforms {
  float isActive;
  float isAttribute;
  float isHighlightActive;
  float useFloatColors;
  vec3 highlightedObjectColor;
  vec4 highlightColor;
} picking;

in vec4 picking_vRGBcolor_Avalid;

/*
 * Returns highlight color if this item is selected.
 */
vec4 picking_filterHighlightColor(vec4 color) {
  // If we are still picking, we don't highlight
  if (picking.isActive > 0.5) {
    return color;
  }

  bool selected = bool(picking_vRGBcolor_Avalid.a);

  if (selected) {
    // Blend in highlight color based on its alpha value
    float highLightAlpha = picking.highlightColor.a;
    float blendedAlpha = highLightAlpha + color.a * (1.0 - highLightAlpha);
    float highLightRatio = highLightAlpha / blendedAlpha;

    vec3 blendedRGB = mix(color.rgb, picking.highlightColor.rgb, highLightRatio);
    return vec4(blendedRGB, blendedAlpha);
  } else {
    return color;
  }
}

/*
 * Returns picking color if picking enabled else unmodified argument.
 */
vec4 picking_filterPickingColor(vec4 color) {
  if (bool(picking.isActive)) {
    if (picking_vRGBcolor_Avalid.a == 0.0) {
      discard;
    }
    return picking_vRGBcolor_Avalid;
  }
  return color;
}

/*
 * Returns picking color if picking is enabled if not
 * highlight color if this item is selected, otherwise unmodified argument.
 */
vec4 picking_filterColor(vec4 color) {
  vec4 highlightColor = picking_filterHighlightColor(color);
  return picking_filterPickingColor(highlightColor);
}
`, i0 = {
        props: {},
        uniforms: {},
        name: "picking",
        uniformTypes: {
            isActive: "f32",
            isAttribute: "f32",
            isHighlightActive: "f32",
            useFloatColors: "f32",
            highlightedObjectColor: "vec3<f32>",
            highlightColor: "vec4<f32>"
        },
        defaultUniforms: {
            isActive: !1,
            isAttribute: !1,
            isHighlightActive: !1,
            useFloatColors: !0,
            highlightedObjectColor: [
                0,
                0,
                0
            ],
            highlightColor: bM
        },
        vs: vM,
        fs: TM,
        getUniforms: xM
    };
    function xM(n = {}, e) {
        const t = {};
        if (n.highlightedObjectColor !== void 0) if (n.highlightedObjectColor === null) t.isHighlightActive = !1;
        else {
            t.isHighlightActive = !0;
            const i = n.highlightedObjectColor.slice(0, 3);
            t.highlightedObjectColor = i;
        }
        if (n.highlightColor) {
            const i = Array.from(n.highlightColor, (r)=>r / 255);
            Number.isFinite(i[3]) || (i[3] = 1), t.highlightColor = i;
        }
        return n.isActive !== void 0 && (t.isActive = !!n.isActive, t.isAttribute = !!n.isAttribute), n.useFloatColors !== void 0 && (t.useFloatColors = !!n.useFloatColors), t;
    }
    const r0 = `precision highp int;

// #if (defined(SHADER_TYPE_FRAGMENT) && defined(LIGHTING_FRAGMENT)) || (defined(SHADER_TYPE_VERTEX) && defined(LIGHTING_VERTEX))
struct AmbientLight {
  vec3 color;
};

struct PointLight {
  vec3 color;
  vec3 position;
  vec3 attenuation; // 2nd order x:Constant-y:Linear-z:Exponential
};

struct DirectionalLight {
  vec3 color;
  vec3 direction;
};

uniform lightingUniforms {
  int enabled;
  int lightType;

  int directionalLightCount;
  int pointLightCount;

  vec3 ambientColor;

  vec3 lightColor0;
  vec3 lightPosition0;
  vec3 lightDirection0;
  vec3 lightAttenuation0;

  vec3 lightColor1;
  vec3 lightPosition1;
  vec3 lightDirection1;
  vec3 lightAttenuation1;

  vec3 lightColor2;
  vec3 lightPosition2;
  vec3 lightDirection2;
  vec3 lightAttenuation2;
} lighting;

PointLight lighting_getPointLight(int index) {
  switch (index) {
    case 0:
      return PointLight(lighting.lightColor0, lighting.lightPosition0, lighting.lightAttenuation0);
    case 1:
      return PointLight(lighting.lightColor1, lighting.lightPosition1, lighting.lightAttenuation1);
    case 2:
    default:  
      return PointLight(lighting.lightColor2, lighting.lightPosition2, lighting.lightAttenuation2);
  }
}

DirectionalLight lighting_getDirectionalLight(int index) {
  switch (index) {
    case 0:
      return DirectionalLight(lighting.lightColor0, lighting.lightDirection0);
    case 1:
      return DirectionalLight(lighting.lightColor1, lighting.lightDirection1);
    case 2:
    default:   
      return DirectionalLight(lighting.lightColor2, lighting.lightDirection2);
  }
} 

float getPointLightAttenuation(PointLight pointLight, float distance) {
  return pointLight.attenuation.x
       + pointLight.attenuation.y * distance
       + pointLight.attenuation.z * distance * distance;
}

// #endif
`, SM = `// #if (defined(SHADER_TYPE_FRAGMENT) && defined(LIGHTING_FRAGMENT)) || (defined(SHADER_TYPE_VERTEX) && defined(LIGHTING_VERTEX))
struct AmbientLight {
  color: vec3<f32>,
};

struct PointLight {
  color: vec3<f32>,
  position: vec3<f32>,
  attenuation: vec3<f32>, // 2nd order x:Constant-y:Linear-z:Exponential
};

struct DirectionalLight {
  color: vec3<f32>,
  direction: vec3<f32>,
};

struct lightingUniforms {
  enabled: i32,
  pointLightCount: i32,
  directionalLightCount: i32,

  ambientColor: vec3<f32>,

  // TODO - support multiple lights by uncommenting arrays below
  lightType: i32,
  lightColor: vec3<f32>,
  lightDirection: vec3<f32>,
  lightPosition: vec3<f32>,
  lightAttenuation: vec3<f32>,

  // AmbientLight ambientLight;
  // PointLight pointLight[MAX_LIGHTS];
  // DirectionalLight directionalLight[MAX_LIGHTS];
};

// Binding 0:1 is reserved for lighting (Note: could go into separate bind group as it is stable across draw calls)
@binding(1) @group(0) var<uniform> lighting : lightingUniforms;

fn lighting_getPointLight(index: i32) -> PointLight {
  return PointLight(lighting.lightColor, lighting.lightPosition, lighting.lightAttenuation);
}

fn lighting_getDirectionalLight(index: i32) -> DirectionalLight {
  return DirectionalLight(lighting.lightColor, lighting.lightDirection);
} 

fn getPointLightAttenuation(pointLight: PointLight, distance: f32) -> f32 {
  return pointLight.attenuation.x
       + pointLight.attenuation.y * distance
       + pointLight.attenuation.z * distance * distance;
}
`, dT = 3, AM = 255;
    var So;
    (function(n) {
        n[n.POINT = 0] = "POINT", n[n.DIRECTIONAL = 1] = "DIRECTIONAL";
    })(So || (So = {}));
    const mo = {
        props: {},
        uniforms: {},
        name: "lighting",
        defines: {
            MAX_LIGHTS: dT
        },
        uniformTypes: {
            enabled: "i32",
            lightType: "i32",
            directionalLightCount: "i32",
            pointLightCount: "i32",
            ambientLightColor: "vec3<f32>",
            lightColor0: "vec3<f32>",
            lightPosition0: "vec3<f32>",
            lightDirection0: "vec3<f32>",
            lightAttenuation0: "vec3<f32>",
            lightColor1: "vec3<f32>",
            lightPosition1: "vec3<f32>",
            lightDirection1: "vec3<f32>",
            lightAttenuation1: "vec3<f32>",
            lightColor2: "vec3<f32>",
            lightPosition2: "vec3<f32>",
            lightDirection2: "vec3<f32>",
            lightAttenuation2: "vec3<f32>"
        },
        defaultUniforms: {
            enabled: 1,
            lightType: So.POINT,
            directionalLightCount: 0,
            pointLightCount: 0,
            ambientLightColor: [
                .1,
                .1,
                .1
            ],
            lightColor0: [
                1,
                1,
                1
            ],
            lightPosition0: [
                1,
                1,
                2
            ],
            lightDirection0: [
                1,
                1,
                1
            ],
            lightAttenuation0: [
                1,
                0,
                0
            ],
            lightColor1: [
                1,
                1,
                1
            ],
            lightPosition1: [
                1,
                1,
                2
            ],
            lightDirection1: [
                1,
                1,
                1
            ],
            lightAttenuation1: [
                1,
                0,
                0
            ],
            lightColor2: [
                1,
                1,
                1
            ],
            lightPosition2: [
                1,
                1,
                2
            ],
            lightDirection2: [
                1,
                1,
                1
            ],
            lightAttenuation2: [
                1,
                0,
                0
            ]
        },
        source: SM,
        vs: r0,
        fs: r0,
        getUniforms: wM
    };
    function wM(n, e = {}) {
        if (n = n && {
            ...n
        }, !n) return {
            ...mo.defaultUniforms
        };
        n.lights && (n = {
            ...n,
            ...RM(n.lights),
            lights: void 0
        });
        const { ambientLight: t, pointLights: i, directionalLights: r } = n || {};
        if (!(t || i && i.length > 0 || r && r.length > 0)) return {
            ...mo.defaultUniforms,
            enabled: 0
        };
        const l = {
            ...mo.defaultUniforms,
            ...e,
            ...EM({
                ambientLight: t,
                pointLights: i,
                directionalLights: r
            })
        };
        return n.enabled !== void 0 && (l.enabled = n.enabled ? 1 : 0), l;
    }
    function EM({ ambientLight: n, pointLights: e = [], directionalLights: t = [] }) {
        const i = {};
        i.ambientLightColor = Kh(n);
        let r = 0;
        for (const a of e){
            i.lightType = So.POINT;
            const l = r;
            i[`lightColor${l}`] = Kh(a), i[`lightPosition${l}`] = a.position, i[`lightAttenuation${l}`] = a.attenuation || [
                1,
                0,
                0
            ], r++;
        }
        for (const a of t){
            i.lightType = So.DIRECTIONAL;
            const l = r;
            i[`lightColor${l}`] = Kh(a), i[`lightDirection${l}`] = a.direction, r++;
        }
        return r > dT && J.warn("MAX_LIGHTS exceeded")(), i.directionalLightCount = t.length, i.pointLightCount = e.length, i;
    }
    function RM(n) {
        const e = {
            pointLights: [],
            directionalLights: []
        };
        for (const t of n || [])switch(t.type){
            case "ambient":
                e.ambientLight = t;
                break;
            case "directional":
                e.directionalLights?.push(t);
                break;
            case "point":
                e.pointLights?.push(t);
                break;
        }
        return e;
    }
    function Kh(n = {}) {
        const { color: e = [
            0,
            0,
            0
        ], intensity: t = 1 } = n;
        return e.map((i)=>i * t / AM);
    }
    const gT = `uniform phongMaterialUniforms {
  uniform float ambient;
  uniform float diffuse;
  uniform float shininess;
  uniform vec3  specularColor;
} material;
`, pT = `uniform phongMaterialUniforms {
  uniform float ambient;
  uniform float diffuse;
  uniform float shininess;
  uniform vec3  specularColor;
} material;

vec3 lighting_getLightColor(vec3 surfaceColor, vec3 light_direction, vec3 view_direction, vec3 normal_worldspace, vec3 color) {
  vec3 halfway_direction = normalize(light_direction + view_direction);
  float lambertian = dot(light_direction, normal_worldspace);
  float specular = 0.0;
  if (lambertian > 0.0) {
    float specular_angle = max(dot(normal_worldspace, halfway_direction), 0.0);
    specular = pow(specular_angle, material.shininess);
  }
  lambertian = max(lambertian, 0.0);
  return (lambertian * material.diffuse * surfaceColor + specular * material.specularColor) * color;
}

vec3 lighting_getLightColor(vec3 surfaceColor, vec3 cameraPosition, vec3 position_worldspace, vec3 normal_worldspace) {
  vec3 lightColor = surfaceColor;

  if (lighting.enabled == 0) {
    return lightColor;
  }

  vec3 view_direction = normalize(cameraPosition - position_worldspace);
  lightColor = material.ambient * surfaceColor * lighting.ambientColor;

  for (int i = 0; i < lighting.pointLightCount; i++) {
    PointLight pointLight = lighting_getPointLight(i);
    vec3 light_position_worldspace = pointLight.position;
    vec3 light_direction = normalize(light_position_worldspace - position_worldspace);
    float light_attenuation = getPointLightAttenuation(pointLight, distance(light_position_worldspace, position_worldspace));
    lightColor += lighting_getLightColor(surfaceColor, light_direction, view_direction, normal_worldspace, pointLight.color / light_attenuation);
  }

  int totalLights = min(MAX_LIGHTS, lighting.pointLightCount + lighting.directionalLightCount);
  for (int i = lighting.pointLightCount; i < totalLights; i++) {
    DirectionalLight directionalLight = lighting_getDirectionalLight(i);
    lightColor += lighting_getLightColor(surfaceColor, -directionalLight.direction, view_direction, normal_worldspace, directionalLight.color);
  }
  
  return lightColor;
}
`, mT = `struct phongMaterialUniforms {
  ambient: f32,
  diffuse: f32,
  shininess: f32,
  specularColor: vec3<f32>,
};

@binding(2) @group(0) var<uniform> phongMaterial : phongMaterialUniforms;

fn lighting_getLightColor(surfaceColor: vec3<f32>, light_direction: vec3<f32>, view_direction: vec3<f32>, normal_worldspace: vec3<f32>, color: vec3<f32>) -> vec3<f32> {
  let halfway_direction: vec3<f32> = normalize(light_direction + view_direction);
  var lambertian: f32 = dot(light_direction, normal_worldspace);
  var specular: f32 = 0.0;
  if (lambertian > 0.0) {
    let specular_angle = max(dot(normal_worldspace, halfway_direction), 0.0);
    specular = pow(specular_angle, phongMaterial.shininess);
  }
  lambertian = max(lambertian, 0.0);
  return (lambertian * phongMaterial.diffuse * surfaceColor + specular * phongMaterial.specularColor) * color;
}

fn lighting_getLightColor2(surfaceColor: vec3<f32>, cameraPosition: vec3<f32>, position_worldspace: vec3<f32>, normal_worldspace: vec3<f32>) -> vec3<f32> {
  var lightColor: vec3<f32> = surfaceColor;

  if (lighting.enabled == 0) {
    return lightColor;
  }

  let view_direction: vec3<f32> = normalize(cameraPosition - position_worldspace);
  lightColor = phongMaterial.ambient * surfaceColor * lighting.ambientColor;

  if (lighting.lightType == 0) {
    let pointLight: PointLight  = lighting_getPointLight(0);
    let light_position_worldspace: vec3<f32> = pointLight.position;
    let light_direction: vec3<f32> = normalize(light_position_worldspace - position_worldspace);
    lightColor += lighting_getLightColor(surfaceColor, light_direction, view_direction, normal_worldspace, pointLight.color);
  } else if (lighting.lightType == 1) {
    var directionalLight: DirectionalLight = lighting_getDirectionalLight(0);
    lightColor += lighting_getLightColor(surfaceColor, -directionalLight.direction, view_direction, normal_worldspace, directionalLight.color);
  }
  
  return lightColor;
  /*
  for (int i = 0; i < MAX_LIGHTS; i++) {
    if (i >= lighting.pointLightCount) {
      break;
    }
    PointLight pointLight = lighting.pointLight[i];
    vec3 light_position_worldspace = pointLight.position;
    vec3 light_direction = normalize(light_position_worldspace - position_worldspace);
    lightColor += lighting_getLightColor(surfaceColor, light_direction, view_direction, normal_worldspace, pointLight.color);
  }

  for (int i = 0; i < MAX_LIGHTS; i++) {
    if (i >= lighting.directionalLightCount) {
      break;
    }
    DirectionalLight directionalLight = lighting.directionalLight[i];
    lightColor += lighting_getLightColor(surfaceColor, -directionalLight.direction, view_direction, normal_worldspace, directionalLight.color);
  }
  */
}

fn lighting_getSpecularLightColor(cameraPosition: vec3<f32>, position_worldspace: vec3<f32>, normal_worldspace: vec3<f32>) -> vec3<f32>{
  var lightColor = vec3<f32>(0, 0, 0);
  let surfaceColor = vec3<f32>(0, 0, 0);

  if (lighting.enabled == 0) {
    let view_direction = normalize(cameraPosition - position_worldspace);

    switch (lighting.lightType) {
      case 0, default: {
        let pointLight: PointLight = lighting_getPointLight(0);
        let light_position_worldspace: vec3<f32> = pointLight.position;
        let light_direction: vec3<f32> = normalize(light_position_worldspace - position_worldspace);
        lightColor += lighting_getLightColor(surfaceColor, light_direction, view_direction, normal_worldspace, pointLight.color);
      }
      case 1: {
        let directionalLight: DirectionalLight = lighting_getDirectionalLight(0);
        lightColor += lighting_getLightColor(surfaceColor, -directionalLight.direction, view_direction, normal_worldspace, directionalLight.color);
      }
    }
  }
  return lightColor;
}
`, _T = {
        props: {},
        name: "gouraudMaterial",
        vs: pT.replace("phongMaterial", "gouraudMaterial"),
        fs: gT.replace("phongMaterial", "gouraudMaterial"),
        source: mT.replaceAll("phongMaterial", "gouraudMaterial"),
        defines: {
            LIGHTING_VERTEX: 1
        },
        dependencies: [
            mo
        ],
        uniformTypes: {
            ambient: "f32",
            diffuse: "f32",
            shininess: "f32",
            specularColor: "vec3<f32>"
        },
        defaultUniforms: {
            ambient: .35,
            diffuse: .6,
            shininess: 32,
            specularColor: [
                .15,
                .15,
                .15
            ]
        },
        getUniforms (n) {
            const e = {
                ...n
            };
            return e.specularColor && (e.specularColor = e.specularColor.map((t)=>t / 255)), {
                ..._T.defaultUniforms,
                ...e
            };
        }
    }, yT = {
        name: "phongMaterial",
        dependencies: [
            mo
        ],
        source: mT,
        vs: gT,
        fs: pT,
        defines: {
            LIGHTING_FRAGMENT: 1
        },
        uniformTypes: {
            ambient: "f32",
            diffuse: "f32",
            shininess: "f32",
            specularColor: "vec3<f32>"
        },
        defaultUniforms: {
            ambient: .35,
            diffuse: .6,
            shininess: 32,
            specularColor: [
                .15,
                .15,
                .15
            ]
        },
        getUniforms (n) {
            const e = {
                ...n
            };
            return e.specularColor && (e.specularColor = e.specularColor.map((t)=>t / 255)), {
                ...yT.defaultUniforms,
                ...e
            };
        }
    }, s0 = `uniform layerUniforms {
  uniform float opacity;
} layer;
`, CM = {
        name: "layer",
        vs: s0,
        fs: s0,
        getUniforms: (n)=>({
                opacity: Math.pow(n.opacity, 1 / 2.2)
            }),
        uniformTypes: {
            opacity: "f32"
        }
    }, MM = `const SMOOTH_EDGE_RADIUS: f32 = 0.5;

struct VertexGeometry {
  position: vec4<f32>,
  worldPosition: vec3<f32>,
  worldPositionAlt: vec3<f32>,
  normal: vec3<f32>,
  uv: vec2<f32>,
  pickingColor: vec3<f32>,
};

var<private> geometry_: VertexGeometry = VertexGeometry(
  vec4<f32>(0.0, 0.0, 1.0, 0.0),
  vec3<f32>(0.0, 0.0, 0.0),
  vec3<f32>(0.0, 0.0, 0.0),
  vec3<f32>(0.0, 0.0, 0.0),
  vec2<f32>(0.0, 0.0),
  vec3<f32>(0.0, 0.0, 0.0)
);

struct FragmentGeometry {
  uv: vec2<f32>,
};

var<private> fragmentGeometry: FragmentGeometry;

fn smoothedge(edge: f32, x: f32) -> f32 {
  return smoothstep(edge - SMOOTH_EDGE_RADIUS, edge + SMOOTH_EDGE_RADIUS, x);
}
`, bT = "#define SMOOTH_EDGE_RADIUS 0.5", OM = `${bT}

struct VertexGeometry {
  vec4 position;
  vec3 worldPosition;
  vec3 worldPositionAlt;
  vec3 normal;
  vec2 uv;
  vec3 pickingColor;
} geometry = VertexGeometry(
  vec4(0.0, 0.0, 1.0, 0.0),
  vec3(0.0),
  vec3(0.0),
  vec3(0.0),
  vec2(0.0),
  vec3(0.0)
);
`, IM = `${bT}

struct FragmentGeometry {
  vec2 uv;
} geometry;

float smoothedge(float edge, float x) {
  return smoothstep(edge - SMOOTH_EDGE_RADIUS, edge + SMOOTH_EDGE_RADIUS, x);
}
`, vT = {
        name: "geometry",
        source: MM,
        vs: OM,
        fs: IM
    }, NM = 25;
    var ht;
    (function(n) {
        n[n.Start = 1] = "Start", n[n.Move = 2] = "Move", n[n.End = 4] = "End", n[n.Cancel = 8] = "Cancel";
    })(ht || (ht = {}));
    var mt;
    (function(n) {
        n[n.None = 0] = "None", n[n.Left = 1] = "Left", n[n.Right = 2] = "Right", n[n.Up = 4] = "Up", n[n.Down = 8] = "Down", n[n.Horizontal = 3] = "Horizontal", n[n.Vertical = 12] = "Vertical", n[n.All = 15] = "All";
    })(mt || (mt = {}));
    var xe;
    (function(n) {
        n[n.Possible = 1] = "Possible", n[n.Began = 2] = "Began", n[n.Changed = 4] = "Changed", n[n.Ended = 8] = "Ended", n[n.Recognized = 8] = "Recognized", n[n.Cancelled = 16] = "Cancelled", n[n.Failed = 32] = "Failed";
    })(xe || (xe = {}));
    const PM = "compute", DM = "auto", Od = "manipulation", mc = "none", Id = "pan-x", Nd = "pan-y";
    function kM(n) {
        if (n.includes(mc)) return mc;
        const e = n.includes(Id), t = n.includes(Nd);
        return e && t ? mc : e || t ? e ? Id : Nd : n.includes(Od) ? Od : DM;
    }
    class UM {
        constructor(e, t){
            this.actions = "", this.manager = e, this.set(t);
        }
        set(e) {
            e === PM && (e = this.compute()), this.manager.element && (this.manager.element.style.touchAction = e, this.actions = e);
        }
        update() {
            this.set(this.manager.options.touchAction);
        }
        compute() {
            let e = [];
            for (const t of this.manager.recognizers)t.options.enable && (e = e.concat(t.getTouchAction()));
            return kM(e.join(" "));
        }
    }
    function Dc(n) {
        return n.trim().split(/\s+/g);
    }
    function Zh(n, e, t) {
        if (n) for (const i of Dc(e))n.addEventListener(i, t, !1);
    }
    function Qh(n, e, t) {
        if (n) for (const i of Dc(e))n.removeEventListener(i, t, !1);
    }
    function a0(n) {
        return (n.ownerDocument || n).defaultView;
    }
    function BM(n, e) {
        let t = n;
        for(; t;){
            if (t === e) return !0;
            t = t.parentNode;
        }
        return !1;
    }
    function TT(n) {
        const e = n.length;
        if (e === 1) return {
            x: Math.round(n[0].clientX),
            y: Math.round(n[0].clientY)
        };
        let t = 0, i = 0, r = 0;
        for(; r < e;)t += n[r].clientX, i += n[r].clientY, r++;
        return {
            x: Math.round(t / e),
            y: Math.round(i / e)
        };
    }
    function o0(n) {
        const e = [];
        let t = 0;
        for(; t < n.pointers.length;)e[t] = {
            clientX: Math.round(n.pointers[t].clientX),
            clientY: Math.round(n.pointers[t].clientY)
        }, t++;
        return {
            timeStamp: Date.now(),
            pointers: e,
            center: TT(e),
            deltaX: n.deltaX,
            deltaY: n.deltaY
        };
    }
    function xT(n, e) {
        const t = e.x - n.x, i = e.y - n.y;
        return Math.sqrt(t * t + i * i);
    }
    function l0(n, e) {
        const t = e.clientX - n.clientX, i = e.clientY - n.clientY;
        return Math.sqrt(t * t + i * i);
    }
    function LM(n, e) {
        const t = e.x - n.x, i = e.y - n.y;
        return Math.atan2(i, t) * 180 / Math.PI;
    }
    function c0(n, e) {
        const t = e.clientX - n.clientX, i = e.clientY - n.clientY;
        return Math.atan2(i, t) * 180 / Math.PI;
    }
    function ST(n, e) {
        return n === e ? mt.None : Math.abs(n) >= Math.abs(e) ? n < 0 ? mt.Left : mt.Right : e < 0 ? mt.Up : mt.Down;
    }
    function FM(n, e) {
        const t = e.center;
        let i = n.offsetDelta, r = n.prevDelta;
        const a = n.prevInput;
        return (e.eventType === ht.Start || a?.eventType === ht.End) && (r = n.prevDelta = {
            x: a?.deltaX || 0,
            y: a?.deltaY || 0
        }, i = n.offsetDelta = {
            x: t.x,
            y: t.y
        }), {
            deltaX: r.x + (t.x - i.x),
            deltaY: r.y + (t.y - i.y)
        };
    }
    function AT(n, e, t) {
        return {
            x: e / n || 0,
            y: t / n || 0
        };
    }
    function zM(n, e) {
        return l0(e[0], e[1]) / l0(n[0], n[1]);
    }
    function VM(n, e) {
        return c0(e[1], e[0]) - c0(n[1], n[0]);
    }
    function HM(n, e) {
        const t = n.lastInterval || e, i = e.timeStamp - t.timeStamp;
        let r, a, l, u;
        if (e.eventType !== ht.Cancel && (i > NM || t.velocity === void 0)) {
            const h = e.deltaX - t.deltaX, d = e.deltaY - t.deltaY, p = AT(i, h, d);
            a = p.x, l = p.y, r = Math.abs(p.x) > Math.abs(p.y) ? p.x : p.y, u = ST(h, d), n.lastInterval = e;
        } else r = t.velocity, a = t.velocityX, l = t.velocityY, u = t.direction;
        e.velocity = r, e.velocityX = a, e.velocityY = l, e.direction = u;
    }
    function jM(n, e) {
        const { session: t } = n, { pointers: i } = e, { length: r } = i;
        t.firstInput || (t.firstInput = o0(e)), r > 1 && !t.firstMultiple ? t.firstMultiple = o0(e) : r === 1 && (t.firstMultiple = !1);
        const { firstInput: a, firstMultiple: l } = t, u = l ? l.center : a.center, h = e.center = TT(i);
        e.timeStamp = Date.now(), e.deltaTime = e.timeStamp - a.timeStamp, e.angle = LM(u, h), e.distance = xT(u, h);
        const { deltaX: d, deltaY: p } = FM(t, e);
        e.deltaX = d, e.deltaY = p, e.offsetDirection = ST(e.deltaX, e.deltaY);
        const _ = AT(e.deltaTime, e.deltaX, e.deltaY);
        e.overallVelocityX = _.x, e.overallVelocityY = _.y, e.overallVelocity = Math.abs(_.x) > Math.abs(_.y) ? _.x : _.y, e.scale = l ? zM(l.pointers, i) : 1, e.rotation = l ? VM(l.pointers, i) : 0, e.maxPointers = t.prevInput ? e.pointers.length > t.prevInput.maxPointers ? e.pointers.length : t.prevInput.maxPointers : e.pointers.length;
        let y = n.element;
        return BM(e.srcEvent.target, y) && (y = e.srcEvent.target), e.target = y, HM(t, e), e;
    }
    function WM(n, e, t) {
        const i = t.pointers.length, r = t.changedPointers.length, a = e & ht.Start && i - r === 0, l = e & (ht.End | ht.Cancel) && i - r === 0;
        t.isFirst = !!a, t.isFinal = !!l, a && (n.session = {}), t.eventType = e;
        const u = jM(n, t);
        n.emit("hammer.input", u), n.recognize(u), n.session.prevInput = u;
    }
    let $M = class {
        constructor(e){
            this.evEl = "", this.evWin = "", this.evTarget = "", this.domHandler = (t)=>{
                this.manager.options.enable && this.handler(t);
            }, this.manager = e, this.element = e.element, this.target = e.options.inputTarget || e.element;
        }
        callback(e, t) {
            WM(this.manager, e, t);
        }
        init() {
            Zh(this.element, this.evEl, this.domHandler), Zh(this.target, this.evTarget, this.domHandler), Zh(a0(this.element), this.evWin, this.domHandler);
        }
        destroy() {
            Qh(this.element, this.evEl, this.domHandler), Qh(this.target, this.evTarget, this.domHandler), Qh(a0(this.element), this.evWin, this.domHandler);
        }
    };
    const XM = {
        pointerdown: ht.Start,
        pointermove: ht.Move,
        pointerup: ht.End,
        pointercancel: ht.Cancel,
        pointerout: ht.Cancel
    }, YM = "pointerdown", qM = "pointermove pointerup pointercancel";
    class KM extends $M {
        constructor(e){
            super(e), this.evEl = YM, this.evWin = qM, this.store = this.manager.session.pointerEvents = [], this.init();
        }
        handler(e) {
            const { store: t } = this;
            let i = !1;
            const r = XM[e.type], a = e.pointerType, l = a === "touch";
            let u = t.findIndex((h)=>h.pointerId === e.pointerId);
            r & ht.Start && (e.buttons || l) ? u < 0 && (t.push(e), u = t.length - 1) : r & (ht.End | ht.Cancel) && (i = !0), !(u < 0) && (t[u] = e, this.callback(r, {
                pointers: t,
                changedPointers: [
                    e
                ],
                eventType: r,
                pointerType: a,
                srcEvent: e
            }), i && t.splice(u, 1));
        }
    }
    const ZM = [
        "",
        "webkit",
        "Moz",
        "MS",
        "ms",
        "o"
    ];
    function QM(n, e) {
        const t = e[0].toUpperCase() + e.slice(1);
        for (const i of ZM){
            const r = i ? i + t : e;
            if (r in n) return r;
        }
    }
    const GM = 1, u0 = 2, f0 = {
        touchAction: "compute",
        enable: !0,
        inputTarget: null,
        cssProps: {
            userSelect: "none",
            userDrag: "none",
            touchCallout: "none",
            tapHighlightColor: "rgba(0,0,0,0)"
        }
    };
    class JM {
        constructor(e, t){
            this.options = {
                ...f0,
                ...t,
                cssProps: {
                    ...f0.cssProps,
                    ...t.cssProps
                },
                inputTarget: t.inputTarget || e
            }, this.handlers = {}, this.session = {}, this.recognizers = [], this.oldCssProps = {}, this.element = e, this.input = new KM(this), this.touchAction = new UM(this, this.options.touchAction), this.toggleCssProps(!0);
        }
        set(e) {
            return Object.assign(this.options, e), e.touchAction && this.touchAction.update(), e.inputTarget && (this.input.destroy(), this.input.target = e.inputTarget, this.input.init()), this;
        }
        stop(e) {
            this.session.stopped = e ? u0 : GM;
        }
        recognize(e) {
            const { session: t } = this;
            if (t.stopped) return;
            this.session.prevented && e.srcEvent.preventDefault();
            let i;
            const { recognizers: r } = this;
            let { curRecognizer: a } = t;
            (!a || a && a.state & xe.Recognized) && (a = t.curRecognizer = null);
            let l = 0;
            for(; l < r.length;)i = r[l], t.stopped !== u0 && (!a || i === a || i.canRecognizeWith(a)) ? i.recognize(e) : i.reset(), !a && i.state & (xe.Began | xe.Changed | xe.Ended) && (a = t.curRecognizer = i), l++;
        }
        get(e) {
            const { recognizers: t } = this;
            for(let i = 0; i < t.length; i++)if (t[i].options.event === e) return t[i];
            return null;
        }
        add(e) {
            if (Array.isArray(e)) {
                for (const i of e)this.add(i);
                return this;
            }
            const t = this.get(e.options.event);
            return t && this.remove(t), this.recognizers.push(e), e.manager = this, this.touchAction.update(), e;
        }
        remove(e) {
            if (Array.isArray(e)) {
                for (const i of e)this.remove(i);
                return this;
            }
            const t = typeof e == "string" ? this.get(e) : e;
            if (t) {
                const { recognizers: i } = this, r = i.indexOf(t);
                r !== -1 && (i.splice(r, 1), this.touchAction.update());
            }
            return this;
        }
        on(e, t) {
            if (!e || !t) return;
            const { handlers: i } = this;
            for (const r of Dc(e))i[r] = i[r] || [], i[r].push(t);
        }
        off(e, t) {
            if (!e) return;
            const { handlers: i } = this;
            for (const r of Dc(e))t ? i[r] && i[r].splice(i[r].indexOf(t), 1) : delete i[r];
        }
        emit(e, t) {
            const i = this.handlers[e] && this.handlers[e].slice();
            if (!i || !i.length) return;
            const r = t;
            r.type = e, r.preventDefault = function() {
                t.srcEvent.preventDefault();
            };
            let a = 0;
            for(; a < i.length;)i[a](r), a++;
        }
        destroy() {
            this.toggleCssProps(!1), this.handlers = {}, this.session = {}, this.input.destroy(), this.element = null;
        }
        toggleCssProps(e) {
            const { element: t } = this;
            if (t) {
                for (const [i, r] of Object.entries(this.options.cssProps)){
                    const a = QM(t.style, i);
                    e ? (this.oldCssProps[a] = t.style[a], t.style[a] = r) : t.style[a] = this.oldCssProps[a] || "";
                }
                e || (this.oldCssProps = {});
            }
        }
    }
    let eO = 1;
    function tO() {
        return eO++;
    }
    function h0(n) {
        return n & xe.Cancelled ? "cancel" : n & xe.Ended ? "end" : n & xe.Changed ? "move" : n & xe.Began ? "start" : "";
    }
    class wT {
        constructor(e){
            this.options = e, this.id = tO(), this.state = xe.Possible, this.simultaneous = {}, this.requireFail = [];
        }
        set(e) {
            return Object.assign(this.options, e), this.manager.touchAction.update(), this;
        }
        recognizeWith(e) {
            if (Array.isArray(e)) {
                for (const r of e)this.recognizeWith(r);
                return this;
            }
            let t;
            if (typeof e == "string") {
                if (t = this.manager.get(e), !t) throw new Error(`Cannot find recognizer ${e}`);
            } else t = e;
            const { simultaneous: i } = this;
            return i[t.id] || (i[t.id] = t, t.recognizeWith(this)), this;
        }
        dropRecognizeWith(e) {
            if (Array.isArray(e)) {
                for (const i of e)this.dropRecognizeWith(i);
                return this;
            }
            let t;
            return typeof e == "string" ? t = this.manager.get(e) : t = e, t && delete this.simultaneous[t.id], this;
        }
        requireFailure(e) {
            if (Array.isArray(e)) {
                for (const r of e)this.requireFailure(r);
                return this;
            }
            let t;
            if (typeof e == "string") {
                if (t = this.manager.get(e), !t) throw new Error(`Cannot find recognizer ${e}`);
            } else t = e;
            const { requireFail: i } = this;
            return i.indexOf(t) === -1 && (i.push(t), t.requireFailure(this)), this;
        }
        dropRequireFailure(e) {
            if (Array.isArray(e)) {
                for (const i of e)this.dropRequireFailure(i);
                return this;
            }
            let t;
            if (typeof e == "string" ? t = this.manager.get(e) : t = e, t) {
                const i = this.requireFail.indexOf(t);
                i > -1 && this.requireFail.splice(i, 1);
            }
            return this;
        }
        hasRequireFailures() {
            return !!this.requireFail.find((e)=>e.options.enable);
        }
        canRecognizeWith(e) {
            return !!this.simultaneous[e.id];
        }
        emit(e) {
            if (!e) return;
            const { state: t } = this;
            t < xe.Ended && this.manager.emit(this.options.event + h0(t), e), this.manager.emit(this.options.event, e), e.additionalEvent && this.manager.emit(e.additionalEvent, e), t >= xe.Ended && this.manager.emit(this.options.event + h0(t), e);
        }
        tryEmit(e) {
            this.canEmit() ? this.emit(e) : this.state = xe.Failed;
        }
        canEmit() {
            let e = 0;
            for(; e < this.requireFail.length;){
                if (!(this.requireFail[e].state & (xe.Failed | xe.Possible))) return !1;
                e++;
            }
            return !0;
        }
        recognize(e) {
            const t = {
                ...e
            };
            if (!this.options.enable) {
                this.reset(), this.state = xe.Failed;
                return;
            }
            this.state & (xe.Recognized | xe.Cancelled | xe.Failed) && (this.state = xe.Possible), this.state = this.process(t), this.state & (xe.Began | xe.Changed | xe.Ended | xe.Cancelled) && this.tryEmit(t);
        }
        getEventNames() {
            return [
                this.options.event
            ];
        }
        reset() {}
    }
    class ET extends wT {
        attrTest(e) {
            const t = this.options.pointers;
            return t === 0 || e.pointers.length === t;
        }
        process(e) {
            const { state: t } = this, { eventType: i } = e, r = t & (xe.Began | xe.Changed), a = this.attrTest(e);
            return r && (i & ht.Cancel || !a) ? t | xe.Cancelled : r || a ? i & ht.End ? t | xe.Ended : t & xe.Began ? t | xe.Changed : xe.Began : xe.Failed;
        }
    }
    class d0 extends wT {
        constructor(e = {}){
            super({
                enable: !0,
                event: "tap",
                pointers: 1,
                taps: 1,
                interval: 300,
                time: 250,
                threshold: 9,
                posThreshold: 10,
                ...e
            }), this.pTime = null, this.pCenter = null, this._timer = null, this._input = null, this.count = 0;
        }
        getTouchAction() {
            return [
                Od
            ];
        }
        process(e) {
            const { options: t } = this, i = e.pointers.length === t.pointers, r = e.distance < t.threshold, a = e.deltaTime < t.time;
            if (this.reset(), e.eventType & ht.Start && this.count === 0) return this.failTimeout();
            if (r && a && i) {
                if (e.eventType !== ht.End) return this.failTimeout();
                const l = this.pTime ? e.timeStamp - this.pTime < t.interval : !0, u = !this.pCenter || xT(this.pCenter, e.center) < t.posThreshold;
                if (this.pTime = e.timeStamp, this.pCenter = e.center, !u || !l ? this.count = 1 : this.count += 1, this._input = e, this.count % t.taps === 0) return this.hasRequireFailures() ? (this._timer = setTimeout(()=>{
                    this.state = xe.Recognized, this.tryEmit(this._input);
                }, t.interval), xe.Began) : xe.Recognized;
            }
            return xe.Failed;
        }
        failTimeout() {
            return this._timer = setTimeout(()=>{
                this.state = xe.Failed;
            }, this.options.interval), xe.Failed;
        }
        reset() {
            clearTimeout(this._timer);
        }
        emit(e) {
            this.state === xe.Recognized && (e.tapCount = this.count, this.manager.emit(this.options.event, e));
        }
    }
    const nO = [
        "",
        "start",
        "move",
        "end",
        "cancel",
        "up",
        "down",
        "left",
        "right"
    ];
    class g0 extends ET {
        constructor(e = {}){
            super({
                enable: !0,
                pointers: 1,
                event: "pan",
                threshold: 10,
                direction: mt.All,
                ...e
            }), this.pX = null, this.pY = null;
        }
        getTouchAction() {
            const { options: { direction: e } } = this, t = [];
            return e & mt.Horizontal && t.push(Nd), e & mt.Vertical && t.push(Id), t;
        }
        getEventNames() {
            return nO.map((e)=>this.options.event + e);
        }
        directionTest(e) {
            const { options: t } = this;
            let i = !0, { distance: r } = e, { direction: a } = e;
            const l = e.deltaX, u = e.deltaY;
            return a & t.direction || (t.direction & mt.Horizontal ? (a = l === 0 ? mt.None : l < 0 ? mt.Left : mt.Right, i = l !== this.pX, r = Math.abs(e.deltaX)) : (a = u === 0 ? mt.None : u < 0 ? mt.Up : mt.Down, i = u !== this.pY, r = Math.abs(e.deltaY))), e.direction = a, i && r > t.threshold && !!(a & t.direction);
        }
        attrTest(e) {
            return super.attrTest(e) && (!!(this.state & xe.Began) || !(this.state & xe.Began) && this.directionTest(e));
        }
        emit(e) {
            this.pX = e.deltaX, this.pY = e.deltaY;
            const t = mt[e.direction].toLowerCase();
            t && (e.additionalEvent = this.options.event + t), super.emit(e);
        }
    }
    const iO = [
        "",
        "start",
        "move",
        "end",
        "cancel",
        "in",
        "out"
    ];
    class rO extends ET {
        constructor(e = {}){
            super({
                enable: !0,
                event: "pinch",
                threshold: 0,
                pointers: 2,
                ...e
            });
        }
        getTouchAction() {
            return [
                mc
            ];
        }
        getEventNames() {
            return iO.map((e)=>this.options.event + e);
        }
        attrTest(e) {
            return super.attrTest(e) && (Math.abs(e.scale - 1) > this.options.threshold || !!(this.state & xe.Began));
        }
        emit(e) {
            if (e.scale !== 1) {
                const t = e.scale < 1 ? "in" : "out";
                e.additionalEvent = this.options.event + t;
            }
            super.emit(e);
        }
    }
    class iu {
        constructor(e, t, i){
            this.element = e, this.callback = t, this.options = i;
        }
    }
    const sO = typeof navigator < "u" && navigator.userAgent ? navigator.userAgent.toLowerCase() : "", aO = sO.indexOf("firefox") !== -1, p0 = 4.000244140625, oO = 40, lO = .25;
    class cO extends iu {
        constructor(e, t, i){
            super(e, t, {
                enable: !0,
                ...i
            }), this.handleEvent = (r)=>{
                if (!this.options.enable) return;
                let a = r.deltaY;
                globalThis.WheelEvent && (aO && r.deltaMode === globalThis.WheelEvent.DOM_DELTA_PIXEL && (a /= globalThis.devicePixelRatio), r.deltaMode === globalThis.WheelEvent.DOM_DELTA_LINE && (a *= oO)), a !== 0 && a % p0 === 0 && (a = Math.floor(a / p0)), r.shiftKey && a && (a = a * lO), this.callback({
                    type: "wheel",
                    center: {
                        x: r.clientX,
                        y: r.clientY
                    },
                    delta: -a,
                    srcEvent: r,
                    pointerType: "mouse",
                    target: r.target
                });
            }, e.addEventListener("wheel", this.handleEvent, {
                passive: !1
            });
        }
        destroy() {
            this.element.removeEventListener("wheel", this.handleEvent);
        }
        enableEventType(e, t) {
            e === "wheel" && (this.options.enable = t);
        }
    }
    const m0 = [
        "mousedown",
        "mousemove",
        "mouseup",
        "mouseover",
        "mouseout",
        "mouseleave"
    ];
    class uO extends iu {
        constructor(e, t, i){
            super(e, t, {
                enable: !0,
                ...i
            }), this.handleEvent = (a)=>{
                this.handleOverEvent(a), this.handleOutEvent(a), this.handleEnterEvent(a), this.handleLeaveEvent(a), this.handleMoveEvent(a);
            }, this.pressed = !1;
            const { enable: r } = this.options;
            this.enableMoveEvent = r, this.enableLeaveEvent = r, this.enableEnterEvent = r, this.enableOutEvent = r, this.enableOverEvent = r, m0.forEach((a)=>e.addEventListener(a, this.handleEvent));
        }
        destroy() {
            m0.forEach((e)=>this.element.removeEventListener(e, this.handleEvent));
        }
        enableEventType(e, t) {
            switch(e){
                case "pointermove":
                    this.enableMoveEvent = t;
                    break;
                case "pointerover":
                    this.enableOverEvent = t;
                    break;
                case "pointerout":
                    this.enableOutEvent = t;
                    break;
                case "pointerenter":
                    this.enableEnterEvent = t;
                    break;
                case "pointerleave":
                    this.enableLeaveEvent = t;
                    break;
            }
        }
        handleOverEvent(e) {
            this.enableOverEvent && e.type === "mouseover" && this._emit("pointerover", e);
        }
        handleOutEvent(e) {
            this.enableOutEvent && e.type === "mouseout" && this._emit("pointerout", e);
        }
        handleEnterEvent(e) {
            this.enableEnterEvent && e.type === "mouseenter" && this._emit("pointerenter", e);
        }
        handleLeaveEvent(e) {
            this.enableLeaveEvent && e.type === "mouseleave" && this._emit("pointerleave", e);
        }
        handleMoveEvent(e) {
            if (this.enableMoveEvent) switch(e.type){
                case "mousedown":
                    e.button >= 0 && (this.pressed = !0);
                    break;
                case "mousemove":
                    e.buttons === 0 && (this.pressed = !1), this.pressed || this._emit("pointermove", e);
                    break;
                case "mouseup":
                    this.pressed = !1;
                    break;
            }
        }
        _emit(e, t) {
            this.callback({
                type: e,
                center: {
                    x: t.clientX,
                    y: t.clientY
                },
                srcEvent: t,
                pointerType: "mouse",
                target: t.target
            });
        }
    }
    const _0 = [
        "keydown",
        "keyup"
    ];
    class fO extends iu {
        constructor(e, t, i){
            super(e, t, {
                enable: !0,
                tabIndex: 0,
                ...i
            }), this.handleEvent = (r)=>{
                const a = r.target || r.srcElement;
                a.tagName === "INPUT" && a.type === "text" || a.tagName === "TEXTAREA" || (this.enableDownEvent && r.type === "keydown" && this.callback({
                    type: "keydown",
                    srcEvent: r,
                    key: r.key,
                    target: r.target
                }), this.enableUpEvent && r.type === "keyup" && this.callback({
                    type: "keyup",
                    srcEvent: r,
                    key: r.key,
                    target: r.target
                }));
            }, this.enableDownEvent = this.options.enable, this.enableUpEvent = this.options.enable, e.tabIndex = this.options.tabIndex, e.style.outline = "none", _0.forEach((r)=>e.addEventListener(r, this.handleEvent));
        }
        destroy() {
            _0.forEach((e)=>this.element.removeEventListener(e, this.handleEvent));
        }
        enableEventType(e, t) {
            e === "keydown" && (this.enableDownEvent = t), e === "keyup" && (this.enableUpEvent = t);
        }
    }
    class hO extends iu {
        constructor(e, t, i){
            super(e, t, i), this.handleEvent = (r)=>{
                this.options.enable && this.callback({
                    type: "contextmenu",
                    center: {
                        x: r.clientX,
                        y: r.clientY
                    },
                    srcEvent: r,
                    pointerType: "mouse",
                    target: r.target
                });
            }, e.addEventListener("contextmenu", this.handleEvent);
        }
        destroy() {
            this.element.removeEventListener("contextmenu", this.handleEvent);
        }
        enableEventType(e, t) {
            e === "contextmenu" && (this.options.enable = t);
        }
    }
    const y0 = 1, Pd = 2, b0 = 4, dO = {
        pointerdown: y0,
        pointermove: Pd,
        pointerup: b0,
        mousedown: y0,
        mousemove: Pd,
        mouseup: b0
    }, gO = 0, pO = 1, mO = 2, _O = 1, yO = 2, bO = 4;
    function vO(n) {
        const e = dO[n.srcEvent.type];
        if (!e) return null;
        const { buttons: t, button: i } = n.srcEvent;
        let r = !1, a = !1, l = !1;
        return e === Pd ? (r = !!(t & _O), a = !!(t & bO), l = !!(t & yO)) : (r = i === gO, a = i === pO, l = i === mO), {
            leftButton: r,
            middleButton: a,
            rightButton: l
        };
    }
    function TO(n, e) {
        const t = n.center;
        if (!t) return null;
        const i = e.getBoundingClientRect(), r = i.width / e.offsetWidth || 1, a = i.height / e.offsetHeight || 1, l = {
            x: (t.x - i.left - e.clientLeft) / r,
            y: (t.y - i.top - e.clientTop) / a
        };
        return {
            center: t,
            offsetCenter: l
        };
    }
    const xO = {
        srcElement: "root",
        priority: 0
    };
    class SO {
        constructor(e, t){
            this.handleEvent = (i)=>{
                if (this.isEmpty()) return;
                const r = this._normalizeEvent(i);
                let a = i.srcEvent.target;
                for(; a && a !== r.rootElement;){
                    if (this._emit(r, a), r.handled) return;
                    a = a.parentNode;
                }
                this._emit(r, "root");
            }, this.eventManager = e, this.recognizerName = t, this.handlers = [], this.handlersByElement = new Map, this._active = !1;
        }
        isEmpty() {
            return !this._active;
        }
        add(e, t, i, r = !1, a = !1) {
            const { handlers: l, handlersByElement: u } = this, h = {
                ...xO,
                ...i
            };
            let d = u.get(h.srcElement);
            d || (d = [], u.set(h.srcElement, d));
            const p = {
                type: e,
                handler: t,
                srcElement: h.srcElement,
                priority: h.priority
            };
            r && (p.once = !0), a && (p.passive = !0), l.push(p), this._active = this._active || !p.passive;
            let _ = d.length - 1;
            for(; _ >= 0 && !(d[_].priority >= p.priority);)_--;
            d.splice(_ + 1, 0, p);
        }
        remove(e, t) {
            const { handlers: i, handlersByElement: r } = this;
            for(let a = i.length - 1; a >= 0; a--){
                const l = i[a];
                if (l.type === e && l.handler === t) {
                    i.splice(a, 1);
                    const u = r.get(l.srcElement);
                    u.splice(u.indexOf(l), 1), u.length === 0 && r.delete(l.srcElement);
                }
            }
            this._active = i.some((a)=>!a.passive);
        }
        _emit(e, t) {
            const i = this.handlersByElement.get(t);
            if (i) {
                let r = !1;
                const a = ()=>{
                    e.handled = !0;
                }, l = ()=>{
                    e.handled = !0, r = !0;
                }, u = [];
                for(let h = 0; h < i.length; h++){
                    const { type: d, handler: p, once: _ } = i[h];
                    if (p({
                        ...e,
                        type: d,
                        stopPropagation: a,
                        stopImmediatePropagation: l
                    }), _ && u.push(i[h]), r) break;
                }
                for(let h = 0; h < u.length; h++){
                    const { type: d, handler: p } = u[h];
                    this.remove(d, p);
                }
            }
        }
        _normalizeEvent(e) {
            const t = this.eventManager.getElement();
            return {
                ...e,
                ...vO(e),
                ...TO(e, t),
                preventDefault: ()=>{
                    e.srcEvent.preventDefault();
                },
                stopImmediatePropagation: null,
                stopPropagation: null,
                handled: !1,
                rootElement: t
            };
        }
    }
    function AO(n) {
        if ("recognizer" in n) return n;
        let e;
        const t = Array.isArray(n) ? [
            ...n
        ] : [
            n
        ];
        if (typeof t[0] == "function") {
            const i = t.shift(), r = t.shift() || {};
            e = new i(r);
        } else e = t.shift();
        return {
            recognizer: e,
            recognizeWith: typeof t[0] == "string" ? [
                t[0]
            ] : t[0],
            requireFailure: typeof t[1] == "string" ? [
                t[1]
            ] : t[1]
        };
    }
    class wO {
        constructor(e = null, t = {}){
            if (this._onBasicInput = (i)=>{
                this.manager.emit(i.srcEvent.type, i);
            }, this._onOtherEvent = (i)=>{
                this.manager.emit(i.type, i);
            }, this.options = {
                recognizers: [],
                events: {},
                touchAction: "compute",
                tabIndex: 0,
                cssProps: {},
                ...t
            }, this.events = new Map, this.element = e, !!e) {
                this.manager = new JM(e, this.options);
                for (const i of this.options.recognizers){
                    const { recognizer: r, recognizeWith: a, requireFailure: l } = AO(i);
                    this.manager.add(r), a && r.recognizeWith(a), l && r.requireFailure(l);
                }
                this.manager.on("hammer.input", this._onBasicInput), this.wheelInput = new cO(e, this._onOtherEvent, {
                    enable: !1
                }), this.moveInput = new uO(e, this._onOtherEvent, {
                    enable: !1
                }), this.keyInput = new fO(e, this._onOtherEvent, {
                    enable: !1,
                    tabIndex: t.tabIndex
                }), this.contextmenuInput = new hO(e, this._onOtherEvent, {
                    enable: !1
                }), this.on(this.options.events);
            }
        }
        getElement() {
            return this.element;
        }
        destroy() {
            this.element && (this.wheelInput.destroy(), this.moveInput.destroy(), this.keyInput.destroy(), this.contextmenuInput.destroy(), this.manager.destroy());
        }
        on(e, t, i) {
            this._addEventHandler(e, t, i, !1);
        }
        once(e, t, i) {
            this._addEventHandler(e, t, i, !0);
        }
        watch(e, t, i) {
            this._addEventHandler(e, t, i, !1, !0);
        }
        off(e, t) {
            this._removeEventHandler(e, t);
        }
        _toggleRecognizer(e, t) {
            const { manager: i } = this;
            if (!i) return;
            const r = i.get(e);
            r && (r.set({
                enable: t
            }), i.touchAction.update()), this.wheelInput?.enableEventType(e, t), this.moveInput?.enableEventType(e, t), this.keyInput?.enableEventType(e, t), this.contextmenuInput?.enableEventType(e, t);
        }
        _addEventHandler(e, t, i, r, a) {
            if (typeof e != "string") {
                i = t;
                for (const [d, p] of Object.entries(e))this._addEventHandler(d, p, i, r, a);
                return;
            }
            const { manager: l, events: u } = this;
            if (!l) return;
            let h = u.get(e);
            if (!h) {
                const d = this._getRecognizerName(e) || e;
                h = new SO(this, d), u.set(e, h), l && l.on(e, h.handleEvent);
            }
            h.add(e, t, i, r, a), h.isEmpty() || this._toggleRecognizer(h.recognizerName, !0);
        }
        _removeEventHandler(e, t) {
            if (typeof e != "string") {
                for (const [a, l] of Object.entries(e))this._removeEventHandler(a, l);
                return;
            }
            const { events: i } = this, r = i.get(e);
            if (r && (r.remove(e, t), r.isEmpty())) {
                const { recognizerName: a } = r;
                let l = !1;
                for (const u of i.values())if (u.recognizerName === a && !u.isEmpty()) {
                    l = !0;
                    break;
                }
                l || this._toggleRecognizer(a, !1);
            }
        }
        _getRecognizerName(e) {
            return this.manager.recognizers.find((t)=>t.getEventNames().includes(e))?.options.event;
        }
    }
    const Oe = {
        DEFAULT: -1,
        LNGLAT: 1,
        METER_OFFSETS: 2,
        LNGLAT_OFFSETS: 3,
        CARTESIAN: 0
    };
    Object.defineProperty(Oe, "IDENTITY", {
        get: ()=>(Fe.deprecated("COORDINATE_SYSTEM.IDENTITY", "COORDINATE_SYSTEM.CARTESIAN")(), 0)
    });
    const mn = {
        WEB_MERCATOR: 1,
        GLOBE: 2,
        WEB_MERCATOR_AUTO_OFFSET: 4,
        IDENTITY: 0
    }, Gi = {
        common: 0,
        meters: 1,
        pixels: 2
    }, Dd = {
        click: "onClick",
        panstart: "onDragStart",
        panmove: "onDrag",
        panend: "onDragEnd"
    }, v0 = {
        multipan: [
            g0,
            {
                threshold: 10,
                direction: mt.Vertical,
                pointers: 2
            }
        ],
        pinch: [
            rO,
            {},
            null,
            [
                "multipan"
            ]
        ],
        pan: [
            g0,
            {
                threshold: 1
            },
            [
                "pinch"
            ],
            [
                "multipan"
            ]
        ],
        dblclick: [
            d0,
            {
                event: "dblclick",
                taps: 2
            }
        ],
        click: [
            d0,
            {
                event: "click"
            },
            null,
            [
                "dblclick"
            ]
        ]
    };
    function EO(n, e) {
        if (n === e) return !0;
        if (Array.isArray(n)) {
            const t = n.length;
            if (!e || e.length !== t) return !1;
            for(let i = 0; i < t; i++)if (n[i] !== e[i]) return !1;
            return !0;
        }
        return !1;
    }
    function No(n) {
        let e = {}, t;
        return (i)=>{
            for(const r in i)if (!EO(i[r], e[r])) {
                t = n(i), e = i;
                break;
            }
            return t;
        };
    }
    const T0 = [
        0,
        0,
        0,
        0
    ], RO = [
        1,
        0,
        0,
        0,
        0,
        1,
        0,
        0,
        0,
        0,
        1,
        0,
        0,
        0,
        0,
        0
    ], RT = [
        1,
        0,
        0,
        0,
        0,
        1,
        0,
        0,
        0,
        0,
        1,
        0,
        0,
        0,
        0,
        1
    ], CO = [
        0,
        0,
        0
    ], CT = [
        0,
        0,
        0
    ], MO = No(NO);
    function MT(n, e, t = CT) {
        t.length < 3 && (t = [
            t[0],
            t[1],
            0
        ]);
        let i = t, r, a = !0;
        switch(e === Oe.LNGLAT_OFFSETS || e === Oe.METER_OFFSETS ? r = t : r = n.isGeospatial ? [
            Math.fround(n.longitude),
            Math.fround(n.latitude),
            0
        ] : null, n.projectionMode){
            case mn.WEB_MERCATOR:
                (e === Oe.LNGLAT || e === Oe.CARTESIAN) && (r = [
                    0,
                    0,
                    0
                ], a = !1);
                break;
            case mn.WEB_MERCATOR_AUTO_OFFSET:
                e === Oe.LNGLAT ? i = r : e === Oe.CARTESIAN && (i = [
                    Math.fround(n.center[0]),
                    Math.fround(n.center[1]),
                    0
                ], r = n.unprojectPosition(i), i[0] -= t[0], i[1] -= t[1], i[2] -= t[2]);
                break;
            case mn.IDENTITY:
                i = n.position.map(Math.fround), i[2] = i[2] || 0;
                break;
            case mn.GLOBE:
                a = !1, r = null;
                break;
            default:
                a = !1;
        }
        return {
            geospatialOrigin: r,
            shaderCoordinateOrigin: i,
            offsetMode: a
        };
    }
    function OO(n, e, t) {
        const { viewMatrixUncentered: i, projectionMatrix: r } = n;
        let { viewMatrix: a, viewProjectionMatrix: l } = n, u = T0, h = T0, d = n.cameraPosition;
        const { geospatialOrigin: p, shaderCoordinateOrigin: _, offsetMode: y } = MT(n, e, t);
        return y && (h = n.projectPosition(p || _), d = [
            d[0] - h[0],
            d[1] - h[1],
            d[2] - h[2]
        ], h[3] = 1, u = Io([], h, l), a = i || a, l = wr([], r, a), l = wr([], l, RO)), {
            viewMatrix: a,
            viewProjectionMatrix: l,
            projectionCenter: u,
            originCommon: h,
            cameraPosCommon: d,
            shaderCoordinateOrigin: _,
            geospatialOrigin: p
        };
    }
    function IO({ viewport: n, devicePixelRatio: e = 1, modelMatrix: t = null, coordinateSystem: i = Oe.DEFAULT, coordinateOrigin: r = CT, autoWrapLongitude: a = !1 }) {
        i === Oe.DEFAULT && (i = n.isGeospatial ? Oe.LNGLAT : Oe.CARTESIAN);
        const l = MO({
            viewport: n,
            devicePixelRatio: e,
            coordinateSystem: i,
            coordinateOrigin: r
        });
        return l.wrapLongitude = a, l.modelMatrix = t || RT, l;
    }
    function NO({ viewport: n, devicePixelRatio: e, coordinateSystem: t, coordinateOrigin: i }) {
        const { projectionCenter: r, viewProjectionMatrix: a, originCommon: l, cameraPosCommon: u, shaderCoordinateOrigin: h, geospatialOrigin: d } = OO(n, t, i), p = n.getDistanceScales(), _ = [
            n.width * e,
            n.height * e
        ], y = Io([], [
            0,
            0,
            -n.focalDistance,
            1
        ], n.projectionMatrix)[3] || 1, v = {
            coordinateSystem: t,
            projectionMode: n.projectionMode,
            coordinateOrigin: h,
            commonOrigin: l.slice(0, 3),
            center: r,
            pseudoMeters: !!n._pseudoMeters,
            viewportSize: _,
            devicePixelRatio: e,
            focalDistance: y,
            commonUnitsPerMeter: p.unitsPerMeter,
            commonUnitsPerWorldUnit: p.unitsPerMeter,
            commonUnitsPerWorldUnit2: CO,
            scale: n.scale,
            wrapLongitude: !1,
            viewProjectionMatrix: a,
            modelMatrix: RT,
            cameraPosition: u
        };
        if (d) {
            const S = n.getDistanceScales(d);
            switch(t){
                case Oe.METER_OFFSETS:
                    v.commonUnitsPerWorldUnit = S.unitsPerMeter, v.commonUnitsPerWorldUnit2 = S.unitsPerMeter2;
                    break;
                case Oe.LNGLAT:
                case Oe.LNGLAT_OFFSETS:
                    n._pseudoMeters || (v.commonUnitsPerMeter = S.unitsPerMeter), v.commonUnitsPerWorldUnit = S.unitsPerDegree, v.commonUnitsPerWorldUnit2 = S.unitsPerDegree2;
                    break;
                case Oe.CARTESIAN:
                    v.commonUnitsPerWorldUnit = [
                        1,
                        1,
                        S.unitsPerMeter[2]
                    ], v.commonUnitsPerWorldUnit2 = [
                        0,
                        0,
                        S.unitsPerMeter2[2]
                    ];
                    break;
            }
        }
        return v;
    }
    const PO = Object.keys(Oe).map((n)=>`const COORDINATE_SYSTEM_${n}: i32 = ${Oe[n]};`).join(""), DO = Object.keys(mn).map((n)=>`const PROJECTION_MODE_${n}: i32 = ${mn[n]};`).join(""), kO = Object.keys(Gi).map((n)=>`const UNIT_${n.toUpperCase()}: i32 = ${Gi[n]};`).join(""), UO = `${PO}
${DO}
${kO}

const TILE_SIZE: f32 = 512.0;
const PI: f32 = 3.1415926536;
const WORLD_SCALE: f32 = TILE_SIZE / (PI * 2.0);
const ZERO_64_LOW: vec3<f32> = vec3<f32>(0.0, 0.0, 0.0);
const EARTH_RADIUS: f32 = 6370972.0; // meters
const GLOBE_RADIUS: f32 = 256.0;

// -----------------------------------------------------------------------------
// Uniform block (converted from GLSL uniform block)
// -----------------------------------------------------------------------------
struct ProjectUniforms {
  wrapLongitude: i32,
  coordinateSystem: i32,
  commonUnitsPerMeter: vec3<f32>,
  projectionMode: i32,
  scale: f32,
  commonUnitsPerWorldUnit: vec3<f32>,
  commonUnitsPerWorldUnit2: vec3<f32>,
  center: vec4<f32>,
  modelMatrix: mat4x4<f32>,
  viewProjectionMatrix: mat4x4<f32>,
  viewportSize: vec2<f32>,
  devicePixelRatio: f32,
  focalDistance: f32,
  cameraPosition: vec3<f32>,
  coordinateOrigin: vec3<f32>,
  commonOrigin: vec3<f32>,
  pseudoMeters: i32,
};

@group(0) @binding(0)
var<uniform> project: ProjectUniforms;

// -----------------------------------------------------------------------------
// Geometry data
// (In your GLSL code, "geometry" was assumed to be available globally. In WGSL,
// you might supply this via vertex attributes or a uniform. Here we define a
// uniform struct for demonstration.)
// -----------------------------------------------------------------------------

// Structure to carry additional geometry data used by deck.gl filters.
struct Geometry {
  worldPosition: vec3<f32>,
  worldPositionAlt: vec3<f32>,
  position: vec4<f32>,
  uv: vec2<f32>,
  pickingColor: vec3<f32>,
};

// @group(0) @binding(1)
var<private> geometry: Geometry;
`, BO = `${UO}

// -----------------------------------------------------------------------------
// Functions
// -----------------------------------------------------------------------------

// Returns an adjustment factor for commonUnitsPerMeter
fn _project_size_at_latitude(lat: f32) -> f32 {
  let y = clamp(lat, -89.9, 89.9);
  return 1.0 / cos(radians(y));
}

// Overloaded version: scales a value in meters at a given latitude.
fn _project_size_at_latitude_m(meters: f32, lat: f32) -> f32 {
  return meters * project.commonUnitsPerMeter.z * _project_size_at_latitude(lat);
}

// Computes a non-linear scale factor based on geometry.
// (Note: This function relies on "geometry" being provided.)
fn project_size() -> f32 {
  if (project.projectionMode == PROJECTION_MODE_WEB_MERCATOR &&
      project.coordinateSystem == COORDINATE_SYSTEM_LNGLAT &&
      project.pseudoMeters == 0) {
    if (geometry.position.w == 0.0) {
      return _project_size_at_latitude(geometry.worldPosition.y);
    }
    let y: f32 = geometry.position.y / TILE_SIZE * 2.0 - 1.0;
    let y2 = y * y;
    let y4 = y2 * y2;
    let y6 = y4 * y2;
    return 1.0 + 4.9348 * y2 + 4.0587 * y4 + 1.5642 * y6;
  }
  return 1.0;
}

// Overloads to scale offsets (meters to world units)
fn project_size_float(meters: f32) -> f32 {
  return meters * project.commonUnitsPerMeter.z * project_size();
}

fn project_size_vec2(meters: vec2<f32>) -> vec2<f32> {
  return meters * project.commonUnitsPerMeter.xy * project_size();
}

fn project_size_vec3(meters: vec3<f32>) -> vec3<f32> {
  return meters * project.commonUnitsPerMeter * project_size();
}

fn project_size_vec4(meters: vec4<f32>) -> vec4<f32> {
  return vec4<f32>(meters.xyz * project.commonUnitsPerMeter, meters.w);
}

// Returns a rotation matrix aligning the zaxis with the given up vector.
fn project_get_orientation_matrix(up: vec3<f32>) -> mat3x3<f32> {
  let uz = normalize(up);
  let ux = select(
    vec3<f32>(1.0, 0.0, 0.0),
    normalize(vec3<f32>(uz.y, -uz.x, 0.0)),
    abs(uz.z) == 1.0
  );
  let uy = cross(uz, ux);
  return mat3x3<f32>(ux, uy, uz);
}

// Since WGSL does not support "out" parameters, we return a struct.
struct RotationResult {
  needsRotation: bool,
  transform: mat3x3<f32>,
};

fn project_needs_rotation(commonPosition: vec3<f32>) -> RotationResult {
  if (project.projectionMode == PROJECTION_MODE_GLOBE) {
    return RotationResult(true, project_get_orientation_matrix(commonPosition));
  } else {
    return RotationResult(false, mat3x3<f32>());  // identity alternative if needed
  };
}

// Projects a normal vector from the current coordinate system to world space.
fn project_normal(vector: vec3<f32>) -> vec3<f32> {
  let normal_modelspace = project.modelMatrix * vec4<f32>(vector, 0.0);
  var n = normalize(normal_modelspace.xyz * project.commonUnitsPerMeter);
  let rotResult = project_needs_rotation(geometry.position.xyz);
  if (rotResult.needsRotation) {
    n = rotResult.transform * n;
  }
  return n;
}

// Applies a scale offset based on y-offset (dy)
fn project_offset_(offset: vec4<f32>) -> vec4<f32> {
  let dy: f32 = offset.y;
  let commonUnitsPerWorldUnit = project.commonUnitsPerWorldUnit + project.commonUnitsPerWorldUnit2 * dy;
  return vec4<f32>(offset.xyz * commonUnitsPerWorldUnit, offset.w);
}

// Projects lng/lat coordinates to a unit tile [0,1]
fn project_mercator_(lnglat: vec2<f32>) -> vec2<f32> {
  var x = lnglat.x;
  if (project.wrapLongitude != 0) {
    x = ((x + 180.0) % 360.0) - 180.0;
  }
  let y = clamp(lnglat.y, -89.9, 89.9);
  return vec2<f32>(
    radians(x) + PI,
    PI + log(tan(PI * 0.25 + radians(y) * 0.5))
  ) * WORLD_SCALE;
}

// Projects lng/lat/z coordinates for a globe projection.
fn project_globe_(lnglatz: vec3<f32>) -> vec3<f32> {
  let lambda = radians(lnglatz.x);
  let phi = radians(lnglatz.y);
  let cosPhi = cos(phi);
  let D = (lnglatz.z / EARTH_RADIUS + 1.0) * GLOBE_RADIUS;
  return vec3<f32>(
    sin(lambda) * cosPhi,
    -cos(lambda) * cosPhi,
    sin(phi)
  ) * D;
}

// Projects positions (with an optional 64-bit low part) from the input
// coordinate system to the common space.
fn project_position_vec4_f64(position: vec4<f32>, position64Low: vec3<f32>) -> vec4<f32> {
  var position_world = project.modelMatrix * position;

  // Work around for a Mac+NVIDIA bug:
  if (project.projectionMode == PROJECTION_MODE_WEB_MERCATOR) {
    if (project.coordinateSystem == COORDINATE_SYSTEM_LNGLAT) {
      return vec4<f32>(
        project_mercator_(position_world.xy),
        _project_size_at_latitude_m(position_world.z, position_world.y),
        position_world.w
      );
    }
    if (project.coordinateSystem == COORDINATE_SYSTEM_CARTESIAN) {
      position_world = vec4f(position_world.xyz + project.coordinateOrigin, position_world.w);
    }
  }
  if (project.projectionMode == PROJECTION_MODE_GLOBE) {
    if (project.coordinateSystem == COORDINATE_SYSTEM_LNGLAT) {
      return vec4<f32>(
        project_globe_(position_world.xyz),
        position_world.w
      );
    }
  }
  if (project.projectionMode == PROJECTION_MODE_WEB_MERCATOR_AUTO_OFFSET) {
    if (project.coordinateSystem == COORDINATE_SYSTEM_LNGLAT) {
      if (abs(position_world.y - project.coordinateOrigin.y) > 0.25) {
        return vec4<f32>(
          project_mercator_(position_world.xy) - project.commonOrigin.xy,
          project_size_float(position_world.z),
          position_world.w
        );
      }
    }
  }
  if (project.projectionMode == PROJECTION_MODE_IDENTITY ||
      (project.projectionMode == PROJECTION_MODE_WEB_MERCATOR_AUTO_OFFSET &&
       (project.coordinateSystem == COORDINATE_SYSTEM_LNGLAT ||
        project.coordinateSystem == COORDINATE_SYSTEM_CARTESIAN))) {
    position_world = vec4f(position_world.xyz - project.coordinateOrigin, position_world.w);
  }

  return project_offset_(position_world) +
         project_offset_(project.modelMatrix * vec4<f32>(position64Low, 0.0));
}

// Overloaded versions for different input types.
fn project_position_vec4_f32(position: vec4<f32>) -> vec4<f32> {
  return project_position_vec4_f64(position, ZERO_64_LOW);
}

fn project_position_vec3_f64(position: vec3<f32>, position64Low: vec3<f32>) -> vec3<f32> {
  let projected_position = project_position_vec4_f64(vec4<f32>(position, 1.0), position64Low);
  return projected_position.xyz;
}

fn project_position_vec3_f32(position: vec3<f32>) -> vec3<f32> {
  let projected_position = project_position_vec4_f64(vec4<f32>(position, 1.0), ZERO_64_LOW);
  return projected_position.xyz;
}

fn project_position_vec2_f32(position: vec2<f32>) -> vec2<f32> {
  let projected_position = project_position_vec4_f64(vec4<f32>(position, 0.0, 1.0), ZERO_64_LOW);
  return projected_position.xy;
}

// Transforms a common space position to clip space.
fn project_common_position_to_clipspace_with_projection(position: vec4<f32>, viewProjectionMatrix: mat4x4<f32>, center: vec4<f32>) -> vec4<f32> {
  return viewProjectionMatrix * position + center;
}

// Uses the project viewProjectionMatrix and center.
fn project_common_position_to_clipspace(position: vec4<f32>) -> vec4<f32> {
  return project_common_position_to_clipspace_with_projection(position, project.viewProjectionMatrix, project.center);
}

// Returns a clip space offset corresponding to a given number of screen pixels.
fn project_pixel_size_to_clipspace(pixels: vec2<f32>) -> vec2<f32> {
  let offset = pixels / project.viewportSize * project.devicePixelRatio * 2.0;
  return offset * project.focalDistance;
}

fn project_meter_size_to_pixel(meters: f32) -> f32 {
  return project_size_float(meters) * project.scale;
}

fn project_unit_size_to_pixel(size: f32, unit: i32) -> f32 {
  if (unit == UNIT_METERS) {
    return project_meter_size_to_pixel(size);
  } else if (unit == UNIT_COMMON) {
    return size * project.scale;
  }
  // UNIT_PIXELS: no scaling applied.
  return size;
}

fn project_pixel_size_float(pixels: f32) -> f32 {
  return pixels / project.scale;
}

fn project_pixel_size_vec2(pixels: vec2<f32>) -> vec2<f32> {
  return pixels / project.scale;
}
`, LO = Object.keys(Oe).map((n)=>`const int COORDINATE_SYSTEM_${n} = ${Oe[n]};`).join(""), FO = Object.keys(mn).map((n)=>`const int PROJECTION_MODE_${n} = ${mn[n]};`).join(""), zO = Object.keys(Gi).map((n)=>`const int UNIT_${n.toUpperCase()} = ${Gi[n]};`).join(""), VO = `${LO}
${FO}
${zO}
uniform projectUniforms {
bool wrapLongitude;
int coordinateSystem;
vec3 commonUnitsPerMeter;
int projectionMode;
float scale;
vec3 commonUnitsPerWorldUnit;
vec3 commonUnitsPerWorldUnit2;
vec4 center;
mat4 modelMatrix;
mat4 viewProjectionMatrix;
vec2 viewportSize;
float devicePixelRatio;
float focalDistance;
vec3 cameraPosition;
vec3 coordinateOrigin;
vec3 commonOrigin;
bool pseudoMeters;
} project;
const float TILE_SIZE = 512.0;
const float PI = 3.1415926536;
const float WORLD_SCALE = TILE_SIZE / (PI * 2.0);
const vec3 ZERO_64_LOW = vec3(0.0);
const float EARTH_RADIUS = 6370972.0;
const float GLOBE_RADIUS = 256.0;
float project_size_at_latitude(float lat) {
float y = clamp(lat, -89.9, 89.9);
return 1.0 / cos(radians(y));
}
float project_size() {
if (project.projectionMode == PROJECTION_MODE_WEB_MERCATOR &&
project.coordinateSystem == COORDINATE_SYSTEM_LNGLAT &&
project.pseudoMeters == false) {
if (geometry.position.w == 0.0) {
return project_size_at_latitude(geometry.worldPosition.y);
}
float y = geometry.position.y / TILE_SIZE * 2.0 - 1.0;
float y2 = y * y;
float y4 = y2 * y2;
float y6 = y4 * y2;
return 1.0 + 4.9348 * y2 + 4.0587 * y4 + 1.5642 * y6;
}
return 1.0;
}
float project_size_at_latitude(float meters, float lat) {
return meters * project.commonUnitsPerMeter.z * project_size_at_latitude(lat);
}
float project_size(float meters) {
return meters * project.commonUnitsPerMeter.z * project_size();
}
vec2 project_size(vec2 meters) {
return meters * project.commonUnitsPerMeter.xy * project_size();
}
vec3 project_size(vec3 meters) {
return meters * project.commonUnitsPerMeter * project_size();
}
vec4 project_size(vec4 meters) {
return vec4(meters.xyz * project.commonUnitsPerMeter, meters.w);
}
mat3 project_get_orientation_matrix(vec3 up) {
vec3 uz = normalize(up);
vec3 ux = abs(uz.z) == 1.0 ? vec3(1.0, 0.0, 0.0) : normalize(vec3(uz.y, -uz.x, 0));
vec3 uy = cross(uz, ux);
return mat3(ux, uy, uz);
}
bool project_needs_rotation(vec3 commonPosition, out mat3 transform) {
if (project.projectionMode == PROJECTION_MODE_GLOBE) {
transform = project_get_orientation_matrix(commonPosition);
return true;
}
return false;
}
vec3 project_normal(vec3 vector) {
vec4 normal_modelspace = project.modelMatrix * vec4(vector, 0.0);
vec3 n = normalize(normal_modelspace.xyz * project.commonUnitsPerMeter);
mat3 rotation;
if (project_needs_rotation(geometry.position.xyz, rotation)) {
n = rotation * n;
}
return n;
}
vec4 project_offset_(vec4 offset) {
float dy = offset.y;
vec3 commonUnitsPerWorldUnit = project.commonUnitsPerWorldUnit + project.commonUnitsPerWorldUnit2 * dy;
return vec4(offset.xyz * commonUnitsPerWorldUnit, offset.w);
}
vec2 project_mercator_(vec2 lnglat) {
float x = lnglat.x;
if (project.wrapLongitude) {
x = mod(x + 180., 360.0) - 180.;
}
float y = clamp(lnglat.y, -89.9, 89.9);
return vec2(
radians(x) + PI,
PI + log(tan_fp32(PI * 0.25 + radians(y) * 0.5))
) * WORLD_SCALE;
}
vec3 project_globe_(vec3 lnglatz) {
float lambda = radians(lnglatz.x);
float phi = radians(lnglatz.y);
float cosPhi = cos(phi);
float D = (lnglatz.z / EARTH_RADIUS + 1.0) * GLOBE_RADIUS;
return vec3(
sin(lambda) * cosPhi,
-cos(lambda) * cosPhi,
sin(phi)
) * D;
}
vec4 project_position(vec4 position, vec3 position64Low) {
vec4 position_world = project.modelMatrix * position;
if (project.projectionMode == PROJECTION_MODE_WEB_MERCATOR) {
if (project.coordinateSystem == COORDINATE_SYSTEM_LNGLAT) {
return vec4(
project_mercator_(position_world.xy),
project_size_at_latitude(position_world.z, position_world.y),
position_world.w
);
}
if (project.coordinateSystem == COORDINATE_SYSTEM_CARTESIAN) {
position_world.xyz += project.coordinateOrigin;
}
}
if (project.projectionMode == PROJECTION_MODE_GLOBE) {
if (project.coordinateSystem == COORDINATE_SYSTEM_LNGLAT) {
return vec4(
project_globe_(position_world.xyz),
position_world.w
);
}
}
if (project.projectionMode == PROJECTION_MODE_WEB_MERCATOR_AUTO_OFFSET) {
if (project.coordinateSystem == COORDINATE_SYSTEM_LNGLAT) {
if (abs(position_world.y - project.coordinateOrigin.y) > 0.25) {
return vec4(
project_mercator_(position_world.xy) - project.commonOrigin.xy,
project_size(position_world.z),
position_world.w
);
}
}
}
if (project.projectionMode == PROJECTION_MODE_IDENTITY ||
(project.projectionMode == PROJECTION_MODE_WEB_MERCATOR_AUTO_OFFSET &&
(project.coordinateSystem == COORDINATE_SYSTEM_LNGLAT ||
project.coordinateSystem == COORDINATE_SYSTEM_CARTESIAN))) {
position_world.xyz -= project.coordinateOrigin;
}
return project_offset_(position_world) + project_offset_(project.modelMatrix * vec4(position64Low, 0.0));
}
vec4 project_position(vec4 position) {
return project_position(position, ZERO_64_LOW);
}
vec3 project_position(vec3 position, vec3 position64Low) {
vec4 projected_position = project_position(vec4(position, 1.0), position64Low);
return projected_position.xyz;
}
vec3 project_position(vec3 position) {
vec4 projected_position = project_position(vec4(position, 1.0), ZERO_64_LOW);
return projected_position.xyz;
}
vec2 project_position(vec2 position) {
vec4 projected_position = project_position(vec4(position, 0.0, 1.0), ZERO_64_LOW);
return projected_position.xy;
}
vec4 project_common_position_to_clipspace(vec4 position, mat4 viewProjectionMatrix, vec4 center) {
return viewProjectionMatrix * position + center;
}
vec4 project_common_position_to_clipspace(vec4 position) {
return project_common_position_to_clipspace(position, project.viewProjectionMatrix, project.center);
}
vec2 project_pixel_size_to_clipspace(vec2 pixels) {
vec2 offset = pixels / project.viewportSize * project.devicePixelRatio * 2.0;
return offset * project.focalDistance;
}
float project_size_to_pixel(float meters) {
return project_size(meters) * project.scale;
}
float project_size_to_pixel(float size, int unit) {
if (unit == UNIT_METERS) return project_size_to_pixel(size);
if (unit == UNIT_COMMON) return size * project.scale;
return size;
}
float project_pixel_size(float pixels) {
return pixels / project.scale;
}
vec2 project_pixel_size(vec2 pixels) {
return pixels / project.scale;
}
`, HO = {};
    function jO(n = HO) {
        return "viewport" in n ? IO(n) : {};
    }
    const Cg = {
        name: "project",
        dependencies: [
            pM,
            vT
        ],
        source: BO,
        vs: VO,
        getUniforms: jO,
        uniformTypes: {
            wrapLongitude: "f32",
            coordinateSystem: "i32",
            commonUnitsPerMeter: "vec3<f32>",
            projectionMode: "i32",
            scale: "f32",
            commonUnitsPerWorldUnit: "vec3<f32>",
            commonUnitsPerWorldUnit2: "vec3<f32>",
            center: "vec4<f32>",
            modelMatrix: "mat4x4<f32>",
            viewProjectionMatrix: "mat4x4<f32>",
            viewportSize: "vec2<f32>",
            devicePixelRatio: "f32",
            focalDistance: "f32",
            cameraPosition: "vec3<f32>",
            coordinateOrigin: "vec3<f32>",
            commonOrigin: "vec3<f32>",
            pseudoMeters: "f32"
        }
    }, WO = `// Define a structure to hold both the clip-space position and the common position.
struct ProjectResult {
  clipPosition: vec4<f32>,
  commonPosition: vec4<f32>,
};

// This function mimics the GLSL version with the 'out' parameter by returning both values.
fn project_position_to_clipspace_and_commonspace(
    position: vec3<f32>,
    position64Low: vec3<f32>,
    offset: vec3<f32>
) -> ProjectResult {
  // Compute the projected position.
  let projectedPosition: vec3<f32> = project_position_vec3_f64(position, position64Low);

  // Start with the provided offset.
  var finalOffset: vec3<f32> = offset;

  // Get whether a rotation is needed and the rotation matrix.
  let rotationResult = project_needs_rotation(projectedPosition);

  // If rotation is needed, update the offset.
  if (rotationResult.needsRotation) {
    finalOffset = rotationResult.transform * offset;
  }

  // Compute the common position.
  let commonPosition: vec4<f32> = vec4<f32>(projectedPosition + finalOffset, 1.0);

  // Convert to clip-space.
  let clipPosition: vec4<f32> = project_common_position_to_clipspace(commonPosition);

  return ProjectResult(clipPosition, commonPosition);
}

// A convenience overload that returns only the clip-space position.
fn project_position_to_clipspace(
    position: vec3<f32>,
    position64Low: vec3<f32>,
    offset: vec3<f32>
) -> vec4<f32> {
  return project_position_to_clipspace_and_commonspace(position, position64Low, offset).clipPosition;
}
`, $O = `vec4 project_position_to_clipspace(
  vec3 position, vec3 position64Low, vec3 offset, out vec4 commonPosition
) {
  vec3 projectedPosition = project_position(position, position64Low);
  mat3 rotation;
  if (project_needs_rotation(projectedPosition, rotation)) {
    // offset is specified as ENU
    // when in globe projection, rotate offset so that the ground alighs with the surface of the globe
    offset = rotation * offset;
  }
  commonPosition = vec4(projectedPosition + offset, 1.0);
  return project_common_position_to_clipspace(commonPosition);
}

vec4 project_position_to_clipspace(
  vec3 position, vec3 position64Low, vec3 offset
) {
  vec4 commonPosition;
  return project_position_to_clipspace(position, position64Low, offset, commonPosition);
}
`, Po = {
        name: "project32",
        dependencies: [
            Cg
        ],
        source: WO,
        vs: $O
    };
    function XO() {
        return [
            1,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            1
        ];
    }
    function Vs(n, e) {
        const t = Io([], e, n);
        return sM(t, t, 1 / t[3]), t;
    }
    function x0(n, e) {
        const t = n % e;
        return t < 0 ? e + t : t;
    }
    function kd(n, e, t) {
        return n < e ? e : n > t ? t : n;
    }
    function YO(n) {
        return Math.log(n) * Math.LOG2E;
    }
    const Mg = Math.log2 || YO;
    function di(n, e) {
        if (!n) throw new Error(e || "@math.gl/web-mercator: assertion failed.");
    }
    const Cn = Math.PI, OT = Cn / 4, bn = Cn / 180, Ud = 180 / Cn, Ks = 512, kc = 4003e4, S0 = 85.051129, qO = 1.5;
    function KO(n) {
        return Mg(n);
    }
    function Uc(n) {
        const [e, t] = n;
        di(Number.isFinite(e)), di(Number.isFinite(t) && t >= -90 && t <= 90, "invalid latitude");
        const i = e * bn, r = t * bn, a = Ks * (i + Cn) / (2 * Cn), l = Ks * (Cn + Math.log(Math.tan(OT + r * .5))) / (2 * Cn);
        return [
            a,
            l
        ];
    }
    function Zs(n) {
        const [e, t] = n, i = e / Ks * (2 * Cn) - Cn, r = 2 * (Math.atan(Math.exp(t / Ks * (2 * Cn) - Cn)) - OT);
        return [
            i * Ud,
            r * Ud
        ];
    }
    function ZO(n) {
        const { latitude: e } = n;
        di(Number.isFinite(e));
        const t = Math.cos(e * bn);
        return KO(kc * t) - 9;
    }
    function Gh(n) {
        const e = Math.cos(n * bn);
        return Ks / kc / e;
    }
    function Bd(n) {
        const { latitude: e, longitude: t, highPrecision: i = !1 } = n;
        di(Number.isFinite(e) && Number.isFinite(t));
        const r = Ks, a = Math.cos(e * bn), l = r / 360, u = l / a, h = r / kc / a, d = {
            unitsPerMeter: [
                h,
                h,
                h
            ],
            metersPerUnit: [
                1 / h,
                1 / h,
                1 / h
            ],
            unitsPerDegree: [
                l,
                u,
                h
            ],
            degreesPerUnit: [
                1 / l,
                1 / u,
                1 / h
            ]
        };
        if (i) {
            const p = bn * Math.tan(e * bn) / a, _ = l * p / 2, y = r / kc * p, v = y / u * h;
            d.unitsPerDegree2 = [
                0,
                _,
                y
            ], d.unitsPerMeter2 = [
                v,
                0,
                v
            ];
        }
        return d;
    }
    function IT(n, e) {
        const [t, i, r] = n, [a, l, u] = e, { unitsPerMeter: h, unitsPerMeter2: d } = Bd({
            longitude: t,
            latitude: i,
            highPrecision: !0
        }), p = Uc(n);
        p[0] += a * (h[0] + d[0] * l), p[1] += l * (h[1] + d[1] * l);
        const _ = Zs(p), y = (r || 0) + (u || 0);
        return Number.isFinite(r) || Number.isFinite(u) ? [
            _[0],
            _[1],
            y
        ] : _;
    }
    function QO(n) {
        const { height: e, pitch: t, bearing: i, altitude: r, scale: a, center: l } = n, u = XO();
        Pc(u, u, [
            0,
            0,
            -r
        ]), uT(u, u, -t * bn), fT(u, u, i * bn);
        const h = a / e;
        return Rg(u, u, [
            h,
            h,
            h
        ]), l && Pc(u, u, kC([], l)), u;
    }
    function GO(n) {
        const { width: e, height: t, altitude: i, pitch: r = 0, offset: a, center: l, scale: u, nearZMultiplier: h = 1, farZMultiplier: d = 1 } = n;
        let { fovy: p = Bc(qO) } = n;
        i !== void 0 && (p = Bc(i));
        const _ = p * bn, y = r * bn, v = NT(p);
        let S = v;
        l && (S += l[2] * u / Math.cos(y) / t);
        const E = _ * (.5 + (a ? a[1] : 0) / t), M = Math.sin(E) * S / Math.sin(kd(Math.PI / 2 - y - E, .01, Math.PI - .01)), B = Math.sin(y) * M + S, H = S * 10, O = Math.min(B * d, H);
        return {
            fov: _,
            aspect: e / t,
            focalDistance: v,
            near: h,
            far: O
        };
    }
    function Bc(n) {
        return 2 * Math.atan(.5 / n) * Ud;
    }
    function NT(n) {
        return .5 / Math.tan(.5 * n * bn);
    }
    function PT(n, e) {
        const [t, i, r = 0] = n;
        return di(Number.isFinite(t) && Number.isFinite(i) && Number.isFinite(r)), Vs(e, [
            t,
            i,
            r,
            1
        ]);
    }
    function Og(n, e, t = 0) {
        const [i, r, a] = n;
        if (di(Number.isFinite(i) && Number.isFinite(r), "invalid pixel coordinate"), Number.isFinite(a)) return Vs(e, [
            i,
            r,
            a,
            1
        ]);
        const l = Vs(e, [
            i,
            r,
            0,
            1
        ]), u = Vs(e, [
            i,
            r,
            1,
            1
        ]), h = l[2], d = u[2], p = h === d ? 0 : ((t || 0) - h) / (d - h);
        return oT([], l, u, p);
    }
    function JO(n) {
        const { width: e, height: t, bounds: i, minExtent: r = 0, maxZoom: a = 24, offset: l = [
            0,
            0
        ] } = n, [[u, h], [d, p]] = i, _ = eI(n.padding), y = Uc([
            u,
            kd(p, -85.051129, S0)
        ]), v = Uc([
            d,
            kd(h, -85.051129, S0)
        ]), S = [
            Math.max(Math.abs(v[0] - y[0]), r),
            Math.max(Math.abs(v[1] - y[1]), r)
        ], E = [
            e - _.left - _.right - Math.abs(l[0]) * 2,
            t - _.top - _.bottom - Math.abs(l[1]) * 2
        ];
        di(E[0] > 0 && E[1] > 0);
        const M = E[0] / S[0], B = E[1] / S[1], H = (_.right - _.left) / 2 / M, O = (_.top - _.bottom) / 2 / B, U = [
            (v[0] + y[0]) / 2 + H,
            (v[1] + y[1]) / 2 + O
        ], L = Zs(U), Z = Math.min(a, Mg(Math.abs(Math.min(M, B))));
        return di(Number.isFinite(Z)), {
            longitude: L[0],
            latitude: L[1],
            zoom: Z
        };
    }
    function eI(n = 0) {
        return typeof n == "number" ? {
            top: n,
            bottom: n,
            left: n,
            right: n
        } : (di(Number.isFinite(n.top) && Number.isFinite(n.bottom) && Number.isFinite(n.left) && Number.isFinite(n.right)), n);
    }
    const A0 = Math.PI / 180;
    function tI(n, e = 0) {
        const { width: t, height: i, unproject: r } = n, a = {
            targetZ: e
        }, l = r([
            0,
            i
        ], a), u = r([
            t,
            i
        ], a);
        let h, d;
        const p = n.fovy ? .5 * n.fovy * A0 : Math.atan(.5 / n.altitude), _ = (90 - n.pitch) * A0;
        return p > _ - .01 ? (h = w0(n, 0, e), d = w0(n, t, e)) : (h = r([
            0,
            0
        ], a), d = r([
            t,
            0
        ], a)), [
            l,
            u,
            d,
            h
        ];
    }
    function w0(n, e, t) {
        const { pixelUnprojectionMatrix: i } = n, r = Vs(i, [
            e,
            0,
            1,
            1
        ]), a = Vs(i, [
            e,
            n.height,
            1,
            1
        ]), u = (t * n.distanceScales.unitsPerMeter[2] - r[2]) / (a[2] - r[2]), h = oT([], r, a, u), d = Zs(h);
        return d.push(t), d;
    }
    const E0 = 512;
    function nI(n) {
        const { width: e, height: t, pitch: i = 0 } = n;
        let { longitude: r, latitude: a, zoom: l, bearing: u = 0 } = n;
        (r < -180 || r > 180) && (r = x0(r + 180, 360) - 180), (u < -180 || u > 180) && (u = x0(u + 180, 360) - 180);
        const h = Mg(t / E0);
        if (l <= h) l = h, a = 0;
        else {
            const d = t / 2 / Math.pow(2, l), p = Zs([
                0,
                d
            ])[1];
            if (a < p) a = p;
            else {
                const _ = Zs([
                    0,
                    E0 - d
                ])[1];
                a > _ && (a = _);
            }
        }
        return {
            width: e,
            height: t,
            longitude: r,
            latitude: a,
            zoom: l,
            pitch: i,
            bearing: u
        };
    }
    const DT = `
uniform shadowUniforms {
  bool drawShadowMap;
  bool useShadowMap;
  vec4 color;
  highp int lightId;
  float lightCount;
  mat4 viewProjectionMatrix0;
  mat4 viewProjectionMatrix1;
  vec4 projectCenter0;
  vec4 projectCenter1;
} shadow;
`, iI = `
const int max_lights = 2;

out vec3 shadow_vPosition[max_lights];

vec4 shadow_setVertexPosition(vec4 position_commonspace) {
  mat4 viewProjectionMatrices[max_lights];
  viewProjectionMatrices[0] = shadow.viewProjectionMatrix0;
  viewProjectionMatrices[1] = shadow.viewProjectionMatrix1;
  vec4 projectCenters[max_lights];
  projectCenters[0] = shadow.projectCenter0;
  projectCenters[1] = shadow.projectCenter1;

  if (shadow.drawShadowMap) {
    return project_common_position_to_clipspace(position_commonspace, viewProjectionMatrices[shadow.lightId], projectCenters[shadow.lightId]);
  }
  if (shadow.useShadowMap) {
    for (int i = 0; i < max_lights; i++) {
      if(i < int(shadow.lightCount)) {
        vec4 shadowMap_position = project_common_position_to_clipspace(position_commonspace, viewProjectionMatrices[i], projectCenters[i]);
        shadow_vPosition[i] = (shadowMap_position.xyz / shadowMap_position.w + 1.0) / 2.0;
      }
    }
  }
  return gl_Position;
}
`, rI = `
${DT}
${iI}
`, sI = `
const int max_lights = 2;
uniform sampler2D shadow_uShadowMap0;
uniform sampler2D shadow_uShadowMap1;

in vec3 shadow_vPosition[max_lights];

const vec4 bitPackShift = vec4(1.0, 255.0, 65025.0, 16581375.0);
const vec4 bitUnpackShift = 1.0 / bitPackShift;
const vec4 bitMask = vec4(1.0 / 255.0, 1.0 / 255.0, 1.0 / 255.0,  0.0);

float shadow_getShadowWeight(vec3 position, sampler2D shadowMap) {
  vec4 rgbaDepth = texture(shadowMap, position.xy);

  float z = dot(rgbaDepth, bitUnpackShift);
  return smoothstep(0.001, 0.01, position.z - z);
}

vec4 shadow_filterShadowColor(vec4 color) {
  if (shadow.drawShadowMap) {
    vec4 rgbaDepth = fract(gl_FragCoord.z * bitPackShift);
    rgbaDepth -= rgbaDepth.gbaa * bitMask;
    return rgbaDepth;
  }
  if (shadow.useShadowMap) {
    float shadowAlpha = 0.0;
    shadowAlpha += shadow_getShadowWeight(shadow_vPosition[0], shadow_uShadowMap0);
    if(shadow.lightCount > 1.0) {
      shadowAlpha += shadow_getShadowWeight(shadow_vPosition[1], shadow_uShadowMap1);
    }
    shadowAlpha *= shadow.color.a / shadow.lightCount;
    float blendedAlpha = shadowAlpha + color.a * (1.0 - shadowAlpha);

    return vec4(
      mix(color.rgb, shadow.color.rgb, shadowAlpha / blendedAlpha),
      blendedAlpha
    );
  }
  return color;
}
`, aI = `
${DT}
${sI}
`, oI = No(hI), lI = No(dI), cI = [
        0,
        0,
        0,
        1
    ], uI = [
        1,
        0,
        0,
        0,
        0,
        1,
        0,
        0,
        0,
        0,
        1,
        0,
        0,
        0,
        0,
        0
    ];
    function fI(n, e) {
        const [t, i, r] = n, a = Og([
            t,
            i,
            r
        ], e);
        return Number.isFinite(r) ? a : [
            a[0],
            a[1],
            0
        ];
    }
    function hI({ viewport: n, center: e }) {
        return new Wn(n.viewProjectionMatrix).invert().transform(e);
    }
    function dI({ viewport: n, shadowMatrices: e }) {
        const t = [], i = n.pixelUnprojectionMatrix, r = n.isGeospatial ? void 0 : 1, a = [
            [
                0,
                0,
                r
            ],
            [
                n.width,
                0,
                r
            ],
            [
                0,
                n.height,
                r
            ],
            [
                n.width,
                n.height,
                r
            ],
            [
                0,
                0,
                -1
            ],
            [
                n.width,
                0,
                -1
            ],
            [
                0,
                n.height,
                -1
            ],
            [
                n.width,
                n.height,
                -1
            ]
        ].map((l)=>fI(l, i));
        for (const l of e){
            const u = l.clone().translate(new jn(n.center).negate()), h = a.map((p)=>u.transform(p)), d = new Wn().ortho({
                left: Math.min(...h.map((p)=>p[0])),
                right: Math.max(...h.map((p)=>p[0])),
                bottom: Math.min(...h.map((p)=>p[1])),
                top: Math.max(...h.map((p)=>p[1])),
                near: Math.min(...h.map((p)=>-p[2])),
                far: Math.max(...h.map((p)=>-p[2]))
            });
            t.push(d.multiplyRight(l));
        }
        return t;
    }
    function gI(n) {
        const { shadowEnabled: e = !0, project: t } = n;
        if (!e || !t || !n.shadowMatrices || !n.shadowMatrices.length) return {
            drawShadowMap: !1,
            useShadowMap: !1,
            shadow_uShadowMap0: n.dummyShadowMap,
            shadow_uShadowMap1: n.dummyShadowMap
        };
        const i = Cg.getUniforms(t), r = oI({
            viewport: t.viewport,
            center: i.center
        }), a = [], l = lI({
            shadowMatrices: n.shadowMatrices,
            viewport: t.viewport
        }).slice();
        for(let h = 0; h < n.shadowMatrices.length; h++){
            const d = l[h], p = d.clone().translate(new jn(t.viewport.center).negate());
            i.coordinateSystem === Oe.LNGLAT && i.projectionMode === mn.WEB_MERCATOR ? (l[h] = p, a[h] = r) : (l[h] = d.clone().multiplyRight(uI), a[h] = p.transform(r));
        }
        const u = {
            drawShadowMap: !!n.drawToShadowMap,
            useShadowMap: n.shadowMaps ? n.shadowMaps.length > 0 : !1,
            color: n.shadowColor || cI,
            lightId: n.shadowLightId || 0,
            lightCount: n.shadowMatrices.length,
            shadow_uShadowMap0: n.dummyShadowMap,
            shadow_uShadowMap1: n.dummyShadowMap
        };
        for(let h = 0; h < l.length; h++)u[`viewProjectionMatrix${h}`] = l[h], u[`projectCenter${h}`] = a[h];
        for(let h = 0; h < 2; h++)u[`shadow_uShadowMap${h}`] = n.shadowMaps && n.shadowMaps[h] || n.dummyShadowMap;
        return u;
    }
    const R0 = {
        name: "shadow",
        dependencies: [
            Cg
        ],
        vs: rI,
        fs: aI,
        inject: {
            "vs:DECKGL_FILTER_GL_POSITION": `
    position = shadow_setVertexPosition(geometry.position);
    `,
            "fs:DECKGL_FILTER_COLOR": `
    color = shadow_filterShadowColor(color);
    `
        },
        getUniforms: gI,
        uniformTypes: {
            drawShadowMap: "f32",
            useShadowMap: "f32",
            color: "vec4<f32>",
            lightId: "i32",
            lightCount: "f32",
            viewProjectionMatrix0: "mat4x4<f32>",
            viewProjectionMatrix1: "mat4x4<f32>",
            projectCenter0: "vec4<f32>",
            projectCenter1: "vec4<f32>"
        }
    }, kT = {
        ...i0,
        defaultUniforms: {
            ...i0.defaultUniforms,
            useFloatColors: !1
        },
        inject: {
            "vs:DECKGL_FILTER_GL_POSITION": `
    // for picking depth values
    picking_setPickingAttribute(position.z / position.w);
  `,
            "vs:DECKGL_FILTER_COLOR": `
  picking_setPickingColor(geometry.pickingColor);
  `,
            "fs:DECKGL_FILTER_COLOR": {
                order: 99,
                injection: `
  // use highlight color if this fragment belongs to the selected object.
  color = picking_filterHighlightColor(color);

  // use picking color if rendering to picking FBO.
  color = picking_filterPickingColor(color);
    `
            }
        }
    }, pI = [
        vT
    ], mI = [
        "vs:DECKGL_FILTER_SIZE(inout vec3 size, VertexGeometry geometry)",
        "vs:DECKGL_FILTER_GL_POSITION(inout vec4 position, VertexGeometry geometry)",
        "vs:DECKGL_FILTER_COLOR(inout vec4 color, VertexGeometry geometry)",
        "fs:DECKGL_FILTER_COLOR(inout vec4 color, FragmentGeometry geometry)"
    ], _I = [];
    function yI(n) {
        const e = Tr.getDefaultShaderAssembler();
        for (const i of pI)e.addDefaultModule(i);
        const t = n === "glsl" ? mI : _I;
        for (const i of t)e.addShaderHook(i);
        return e;
    }
    const bI = [
        255,
        255,
        255
    ], vI = 1;
    let TI = 0;
    class UT {
        constructor(e = {}){
            this.type = "ambient";
            const { color: t = bI } = e, { intensity: i = vI } = e;
            this.id = e.id || `ambient-${TI++}`, this.color = t, this.intensity = i;
        }
    }
    const xI = [
        255,
        255,
        255
    ], SI = 1, AI = [
        0,
        0,
        -1
    ];
    let wI = 0;
    class Ld {
        constructor(e = {}){
            this.type = "directional";
            const { color: t = xI } = e, { intensity: i = SI } = e, { direction: r = AI } = e, { _shadow: a = !1 } = e;
            this.id = e.id || `directional-${wI++}`, this.color = t, this.intensity = i, this.type = "directional", this.direction = new jn(r).normalize().toArray(), this.shadow = a;
        }
        getProjectedLight(e) {
            return this;
        }
    }
    class EI {
        constructor(e, t = {
            id: "pass"
        }){
            const { id: i } = t;
            this.id = i, this.device = e, this.props = {
                ...t
            };
        }
        setProps(e) {
            Object.assign(this.props, e);
        }
        render(e) {}
        cleanup() {}
    }
    class Ig extends EI {
        constructor(){
            super(...arguments), this._lastRenderIndex = -1;
        }
        render(e) {
            const [t, i] = this.device.canvasContext.getDrawingBufferSize(), r = e.clearCanvas ?? !0, a = e.clearColor ?? (r ? [
                0,
                0,
                0,
                0
            ] : !1), l = r ? 1 : !1, u = r ? 0 : !1, h = e.colorMask ?? 15, d = {
                viewport: [
                    0,
                    0,
                    t,
                    i
                ]
            };
            e.colorMask && (d.colorMask = h), e.scissorRect && (d.scissorRect = e.scissorRect);
            const p = this.device.beginRenderPass({
                framebuffer: e.target,
                parameters: d,
                clearColor: a,
                clearDepth: l,
                clearStencil: u
            });
            try {
                return this._drawLayers(p, e);
            } finally{
                p.end(), this.device.submit();
            }
        }
        _drawLayers(e, t) {
            const { target: i, shaderModuleProps: r, viewports: a, views: l, onViewportActive: u, clearStack: h = !0 } = t;
            t.pass = t.pass || "unknown", h && (this._lastRenderIndex = -1);
            const d = [];
            for (const p of a){
                const _ = l && l[p.id];
                u?.(p);
                const y = this._getDrawLayerParams(p, t), v = p.subViewports || [
                    p
                ];
                for (const S of v){
                    const E = this._drawLayersInViewport(e, {
                        target: i,
                        shaderModuleProps: r,
                        viewport: S,
                        view: _,
                        pass: t.pass,
                        layers: t.layers
                    }, y);
                    d.push(E);
                }
            }
            return d;
        }
        _getDrawLayerParams(e, { layers: t, pass: i, isPicking: r = !1, layerFilter: a, cullRect: l, effects: u, shaderModuleProps: h }, d = !1) {
            const p = [], _ = BT(this._lastRenderIndex + 1), y = {
                layer: t[0],
                viewport: e,
                isPicking: r,
                renderPass: i,
                cullRect: l
            }, v = {};
            for(let S = 0; S < t.length; S++){
                const E = t[S], M = this._shouldDrawLayer(E, y, a, v), B = {
                    shouldDrawLayer: M
                };
                M && !d && (B.shouldDrawLayer = !0, B.layerRenderIndex = _(E, M), B.shaderModuleProps = this._getShaderModuleProps(E, u, i, h), B.layerParameters = {
                    ...E.context.deck?.props.parameters,
                    ...this.getLayerParameters(E, S, e)
                }), p[S] = B;
            }
            return p;
        }
        _drawLayersInViewport(e, { layers: t, shaderModuleProps: i, pass: r, target: a, viewport: l, view: u }, h) {
            const d = RI(this.device, {
                shaderModuleProps: i,
                target: a,
                viewport: l
            });
            if (u && u.props.clear) {
                const _ = u.props.clear === !0 ? {
                    color: !0,
                    depth: !0
                } : u.props.clear;
                this.device.beginRenderPass({
                    framebuffer: a,
                    parameters: {
                        viewport: d,
                        scissorRect: d
                    },
                    clearColor: _.color ? [
                        0,
                        0,
                        0,
                        0
                    ] : !1,
                    clearDepth: _.depth ? 1 : !1
                }).end();
            }
            const p = {
                totalCount: t.length,
                visibleCount: 0,
                compositeCount: 0,
                pickableCount: 0
            };
            e.setParameters({
                viewport: d
            });
            for(let _ = 0; _ < t.length; _++){
                const y = t[_], v = h[_], { shouldDrawLayer: S } = v;
                if (S && y.props.pickable && p.pickableCount++, y.isComposite && p.compositeCount++, y.isDrawable && v.shouldDrawLayer) {
                    const { layerRenderIndex: E, shaderModuleProps: M, layerParameters: B } = v;
                    p.visibleCount++, this._lastRenderIndex = Math.max(this._lastRenderIndex, E), M.project && (M.project.viewport = l), y.context.renderPass = e;
                    try {
                        y._drawLayer({
                            renderPass: e,
                            shaderModuleProps: M,
                            uniforms: {
                                layerIndex: E
                            },
                            parameters: B
                        });
                    } catch (H) {
                        y.raiseError(H, `drawing ${y} to ${r}`);
                    }
                }
            }
            return p;
        }
        shouldDrawLayer(e) {
            return !0;
        }
        getShaderModuleProps(e, t, i) {
            return null;
        }
        getLayerParameters(e, t, i) {
            return e.props.parameters;
        }
        _shouldDrawLayer(e, t, i, r) {
            if (!(e.props.visible && this.shouldDrawLayer(e))) return !1;
            t.layer = e;
            let l = e.parent;
            for(; l;){
                if (!l.props.visible || !l.filterSubLayer(t)) return !1;
                t.layer = l, l = l.parent;
            }
            if (i) {
                const u = t.layer.id;
                if (u in r || (r[u] = i(t)), !r[u]) return !1;
            }
            return e.activateViewport(t.viewport), !0;
        }
        _getShaderModuleProps(e, t, i, r) {
            const a = this.device.canvasContext.cssToDeviceRatio(), l = e.internalState?.propsInTransition || e.props, u = {
                layer: l,
                picking: {
                    isActive: !1
                },
                project: {
                    viewport: e.context.viewport,
                    devicePixelRatio: a,
                    modelMatrix: l.modelMatrix,
                    coordinateSystem: l.coordinateSystem,
                    coordinateOrigin: l.coordinateOrigin,
                    autoWrapLongitude: e.wrapLongitude
                }
            };
            if (t) for (const h of t)C0(u, h.getShaderModuleProps?.(e, u));
            return C0(u, this.getShaderModuleProps(e, t, u), r);
        }
    }
    function BT(n = 0, e = {}) {
        const t = {}, i = (r, a)=>{
            const l = r.props._offset, u = r.id, h = r.parent && r.parent.id;
            let d;
            if (h && !(h in e) && i(r.parent, !1), h in t) {
                const p = t[h] = t[h] || BT(e[h], e);
                d = p(r, a), t[u] = p;
            } else Number.isFinite(l) ? (d = l + (e[h] || 0), t[u] = null) : d = n;
            return a && d >= n && (n = d + 1), e[u] = d, d;
        };
        return i;
    }
    function RI(n, { shaderModuleProps: e, target: t, viewport: i }) {
        const r = e?.project?.devicePixelRatio ?? n.canvasContext.cssToDeviceRatio(), [, a] = n.canvasContext.getDrawingBufferSize(), l = t ? t.height : a, u = i;
        return [
            u.x * r,
            l - (u.y + u.height) * r,
            u.width * r,
            u.height * r
        ];
    }
    function C0(n, ...e) {
        for (const t of e)if (t) for(const i in t)n[i] ? Object.assign(n[i], t[i]) : n[i] = t[i];
        return n;
    }
    class CI extends Ig {
        constructor(e, t){
            super(e, t);
            const i = e.createTexture({
                format: "rgba8unorm",
                width: 1,
                height: 1,
                sampler: {
                    minFilter: "linear",
                    magFilter: "linear",
                    addressModeU: "clamp-to-edge",
                    addressModeV: "clamp-to-edge"
                },
                mipmaps: !0
            }), r = e.createTexture({
                format: "depth16unorm",
                width: 1,
                height: 1,
                mipmaps: !1
            });
            this.fbo = e.createFramebuffer({
                id: "shadowmap",
                width: 1,
                height: 1,
                colorAttachments: [
                    i
                ],
                depthStencilAttachment: r
            });
        }
        delete() {
            this.fbo && (this.fbo.destroy(), this.fbo = null);
        }
        getShadowMap() {
            return this.fbo.colorAttachments[0].texture;
        }
        render(e) {
            const t = this.fbo, i = this.device.canvasContext.cssToDeviceRatio(), r = e.viewports[0], a = r.width * i, l = r.height * i, u = [
                1,
                1,
                1,
                1
            ];
            (a !== t.width || l !== t.height) && t.resize({
                width: a,
                height: l
            }), super.render({
                ...e,
                clearColor: u,
                target: t,
                pass: "shadow"
            });
        }
        getLayerParameters(e, t, i) {
            return {
                ...e.props.parameters,
                blend: !1,
                depthWriteEnabled: !0,
                depthCompare: "less-equal"
            };
        }
        shouldDrawLayer(e) {
            return e.props.shadowEnabled !== !1;
        }
        getShaderModuleProps(e, t, i) {
            return {
                shadow: {
                    project: i.project,
                    drawToShadowMap: !0
                }
            };
        }
    }
    const MI = {
        color: [
            255,
            255,
            255
        ],
        intensity: 1
    }, M0 = [
        {
            color: [
                255,
                255,
                255
            ],
            intensity: 1,
            direction: [
                -1,
                3,
                -1
            ]
        },
        {
            color: [
                255,
                255,
                255
            ],
            intensity: .9,
            direction: [
                1,
                -8,
                -2.5
            ]
        }
    ], OI = [
        0,
        0,
        0,
        200 / 255
    ];
    class Ng {
        constructor(e = {}){
            this.id = "lighting-effect", this.shadowColor = OI, this.shadow = !1, this.directionalLights = [], this.pointLights = [], this.shadowPasses = [], this.dummyShadowMap = null, this.setProps(e);
        }
        setup(e) {
            this.context = e;
            const { device: t, deck: i } = e;
            this.shadow && !this.dummyShadowMap && (this._createShadowPasses(t), i._addDefaultShaderModule(R0), this.dummyShadowMap = t.createTexture({
                width: 1,
                height: 1
            }));
        }
        setProps(e) {
            this.ambientLight = void 0, this.directionalLights = [], this.pointLights = [];
            for(const t in e){
                const i = e[t];
                switch(i.type){
                    case "ambient":
                        this.ambientLight = i;
                        break;
                    case "directional":
                        this.directionalLights.push(i);
                        break;
                    case "point":
                        this.pointLights.push(i);
                        break;
                }
            }
            this._applyDefaultLights(), this.shadow = this.directionalLights.some((t)=>t.shadow), this.context && this.setup(this.context), this.props = e;
        }
        preRender({ layers: e, layerFilter: t, viewports: i, onViewportActive: r, views: a }) {
            if (this.shadow) {
                this.shadowMatrices = this._calculateMatrices();
                for(let l = 0; l < this.shadowPasses.length; l++)this.shadowPasses[l].render({
                    layers: e,
                    layerFilter: t,
                    viewports: i,
                    onViewportActive: r,
                    views: a,
                    shaderModuleProps: {
                        shadow: {
                            shadowLightId: l,
                            dummyShadowMap: this.dummyShadowMap,
                            shadowMatrices: this.shadowMatrices
                        }
                    }
                });
            }
        }
        getShaderModuleProps(e, t) {
            const i = this.shadow ? {
                project: t.project,
                shadowMaps: this.shadowPasses.map((l)=>l.getShadowMap()),
                dummyShadowMap: this.dummyShadowMap,
                shadowColor: this.shadowColor,
                shadowMatrices: this.shadowMatrices
            } : {}, r = {
                enabled: !0,
                ambientLight: this.ambientLight,
                directionalLights: this.directionalLights.map((l)=>l.getProjectedLight({
                        layer: e
                    })),
                pointLights: this.pointLights.map((l)=>l.getProjectedLight({
                        layer: e
                    }))
            }, a = e.props.material;
            return {
                shadow: i,
                lighting: r,
                phongMaterial: a,
                gouraudMaterial: a
            };
        }
        cleanup(e) {
            for (const t of this.shadowPasses)t.delete();
            this.shadowPasses.length = 0, this.dummyShadowMap && (this.dummyShadowMap.destroy(), this.dummyShadowMap = null, e.deck._removeDefaultShaderModule(R0));
        }
        _calculateMatrices() {
            const e = [];
            for (const t of this.directionalLights){
                const i = new Wn().lookAt({
                    eye: new jn(t.direction).negate()
                });
                e.push(i);
            }
            return e;
        }
        _createShadowPasses(e) {
            for(let t = 0; t < this.directionalLights.length; t++){
                const i = new CI(e);
                this.shadowPasses[t] = i;
            }
        }
        _applyDefaultLights() {
            const { ambientLight: e, pointLights: t, directionalLights: i } = this;
            !e && t.length === 0 && i.length === 0 && (this.ambientLight = new UT(MI), this.directionalLights.push(new Ld(M0[0]), new Ld(M0[1])));
        }
    }
    class II {
        constructor(e = {}){
            this._pool = [], this.opts = {
                overAlloc: 2,
                poolSize: 100
            }, this.setOptions(e);
        }
        setOptions(e) {
            Object.assign(this.opts, e);
        }
        allocate(e, t, { size: i = 1, type: r, padding: a = 0, copy: l = !1, initialize: u = !1, maxCount: h }) {
            const d = r || e && e.constructor || Float32Array, p = t * i + a;
            if (ArrayBuffer.isView(e)) {
                if (p <= e.length) return e;
                if (p * e.BYTES_PER_ELEMENT <= e.buffer.byteLength) return new d(e.buffer, 0, p);
            }
            let _ = 1 / 0;
            h && (_ = h * i + a);
            const y = this._allocate(d, p, u, _);
            return e && l ? y.set(e) : u || y.fill(0, 0, 4), this._release(e), y;
        }
        release(e) {
            this._release(e);
        }
        _allocate(e, t, i, r) {
            let a = Math.max(Math.ceil(t * this.opts.overAlloc), 1);
            a > r && (a = r);
            const l = this._pool, u = e.BYTES_PER_ELEMENT * a, h = l.findIndex((d)=>d.byteLength >= u);
            if (h >= 0) {
                const d = new e(l.splice(h, 1)[0], 0, a);
                return i && d.fill(0), d;
            }
            return new e(a);
        }
        _release(e) {
            if (!ArrayBuffer.isView(e)) return;
            const t = this._pool, { buffer: i } = e, { byteLength: r } = i, a = t.findIndex((l)=>l.byteLength >= r);
            a < 0 ? t.push(i) : (a > 0 || t.length < this.opts.poolSize) && t.splice(a, 0, i), t.length > this.opts.poolSize && t.shift();
        }
    }
    const Ao = new II;
    function lo() {
        return [
            1,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            1,
            0,
            0,
            0,
            0,
            1
        ];
    }
    function NI(n) {
        return [
            n[12],
            n[13],
            n[14]
        ];
    }
    function PI(n) {
        return {
            left: Ms(n[3] + n[0], n[7] + n[4], n[11] + n[8], n[15] + n[12]),
            right: Ms(n[3] - n[0], n[7] - n[4], n[11] - n[8], n[15] - n[12]),
            bottom: Ms(n[3] + n[1], n[7] + n[5], n[11] + n[9], n[15] + n[13]),
            top: Ms(n[3] - n[1], n[7] - n[5], n[11] - n[9], n[15] - n[13]),
            near: Ms(n[3] + n[2], n[7] + n[6], n[11] + n[10], n[15] + n[14]),
            far: Ms(n[3] - n[2], n[7] - n[6], n[11] - n[10], n[15] - n[14])
        };
    }
    const O0 = new jn;
    function Ms(n, e, t, i) {
        O0.set(n, e, t);
        const r = O0.len();
        return {
            distance: i / r,
            normal: new jn(-n / r, -e / r, -t / r)
        };
    }
    function DI(n) {
        return n - Math.fround(n);
    }
    let io;
    function Jh(n, e) {
        const { size: t = 1, startIndex: i = 0 } = e, r = e.endIndex !== void 0 ? e.endIndex : n.length, a = (r - i) / t;
        io = Ao.allocate(io, a, {
            type: Float32Array,
            size: t * 2
        });
        let l = i, u = 0;
        for(; l < r;){
            for(let h = 0; h < t; h++){
                const d = n[l++];
                io[u + h] = d, io[u + h + t] = DI(d);
            }
            u += t * 2;
        }
        return io.subarray(0, a * t * 2);
    }
    function kI(n) {
        let e = null, t = !1;
        for (const i of n)i && (e ? (t || (e = [
            [
                e[0][0],
                e[0][1]
            ],
            [
                e[1][0],
                e[1][1]
            ]
        ], t = !0), e[0][0] = Math.min(e[0][0], i[0][0]), e[0][1] = Math.min(e[0][1], i[0][1]), e[1][0] = Math.max(e[1][0], i[1][0]), e[1][1] = Math.max(e[1][1], i[1][1])) : e = i);
        return e;
    }
    const UI = Math.PI / 180, BI = lo(), I0 = [
        0,
        0,
        0
    ], LI = {
        unitsPerMeter: [
            1,
            1,
            1
        ],
        metersPerUnit: [
            1,
            1,
            1
        ]
    };
    function FI({ width: n, height: e, orthographic: t, fovyRadians: i, focalDistance: r, padding: a, near: l, far: u }) {
        const h = n / e, d = t ? new Wn().orthographic({
            fovy: i,
            aspect: h,
            focalDistance: r,
            near: l,
            far: u
        }) : new Wn().perspective({
            fovy: i,
            aspect: h,
            near: l,
            far: u
        });
        if (a) {
            const { left: p = 0, right: _ = 0, top: y = 0, bottom: v = 0 } = a, S = Xi((p + n - _) / 2, 0, n) - n / 2, E = Xi((y + e - v) / 2, 0, e) - e / 2;
            d[8] -= S * 2 / n, d[9] += E * 2 / e;
        }
        return d;
    }
    class ta {
        constructor(e = {}){
            this._frustumPlanes = {}, this.id = e.id || this.constructor.displayName || "viewport", this.x = e.x || 0, this.y = e.y || 0, this.width = e.width || 1, this.height = e.height || 1, this.zoom = e.zoom || 0, this.padding = e.padding, this.distanceScales = e.distanceScales || LI, this.focalDistance = e.focalDistance || 1, this.position = e.position || I0, this.modelMatrix = e.modelMatrix || null;
            const { longitude: t, latitude: i } = e;
            this.isGeospatial = Number.isFinite(i) && Number.isFinite(t), this._initProps(e), this._initMatrices(e), this.equals = this.equals.bind(this), this.project = this.project.bind(this), this.unproject = this.unproject.bind(this), this.projectPosition = this.projectPosition.bind(this), this.unprojectPosition = this.unprojectPosition.bind(this), this.projectFlat = this.projectFlat.bind(this), this.unprojectFlat = this.unprojectFlat.bind(this);
        }
        get subViewports() {
            return null;
        }
        get metersPerPixel() {
            return this.distanceScales.metersPerUnit[2] / this.scale;
        }
        get projectionMode() {
            return this.isGeospatial ? this.zoom < 12 ? mn.WEB_MERCATOR : mn.WEB_MERCATOR_AUTO_OFFSET : mn.IDENTITY;
        }
        equals(e) {
            return e instanceof ta ? this === e ? !0 : e.width === this.width && e.height === this.height && e.scale === this.scale && xo(e.projectionMatrix, this.projectionMatrix) && xo(e.viewMatrix, this.viewMatrix) : !1;
        }
        project(e, { topLeft: t = !0 } = {}) {
            const i = this.projectPosition(e), r = PT(i, this.pixelProjectionMatrix), [a, l] = r, u = t ? l : this.height - l;
            return e.length === 2 ? [
                a,
                u
            ] : [
                a,
                u,
                r[2]
            ];
        }
        unproject(e, { topLeft: t = !0, targetZ: i } = {}) {
            const [r, a, l] = e, u = t ? a : this.height - a, h = i && i * this.distanceScales.unitsPerMeter[2], d = Og([
                r,
                u,
                l
            ], this.pixelUnprojectionMatrix, h), [p, _, y] = this.unprojectPosition(d);
            return Number.isFinite(l) ? [
                p,
                _,
                y
            ] : Number.isFinite(i) ? [
                p,
                _,
                i
            ] : [
                p,
                _
            ];
        }
        projectPosition(e) {
            const [t, i] = this.projectFlat(e), r = (e[2] || 0) * this.distanceScales.unitsPerMeter[2];
            return [
                t,
                i,
                r
            ];
        }
        unprojectPosition(e) {
            const [t, i] = this.unprojectFlat(e), r = (e[2] || 0) * this.distanceScales.metersPerUnit[2];
            return [
                t,
                i,
                r
            ];
        }
        projectFlat(e) {
            if (this.isGeospatial) {
                const t = Uc(e);
                return t[1] = Xi(t[1], -318, 830), t;
            }
            return e;
        }
        unprojectFlat(e) {
            return this.isGeospatial ? Zs(e) : e;
        }
        getBounds(e = {}) {
            const t = {
                targetZ: e.z || 0
            }, i = this.unproject([
                0,
                0
            ], t), r = this.unproject([
                this.width,
                0
            ], t), a = this.unproject([
                0,
                this.height
            ], t), l = this.unproject([
                this.width,
                this.height
            ], t);
            return [
                Math.min(i[0], r[0], a[0], l[0]),
                Math.min(i[1], r[1], a[1], l[1]),
                Math.max(i[0], r[0], a[0], l[0]),
                Math.max(i[1], r[1], a[1], l[1])
            ];
        }
        getDistanceScales(e) {
            return e && this.isGeospatial ? Bd({
                longitude: e[0],
                latitude: e[1],
                highPrecision: !0
            }) : this.distanceScales;
        }
        containsPixel({ x: e, y: t, width: i = 1, height: r = 1 }) {
            return e < this.x + this.width && this.x < e + i && t < this.y + this.height && this.y < t + r;
        }
        getFrustumPlanes() {
            return this._frustumPlanes.near ? this._frustumPlanes : (Object.assign(this._frustumPlanes, PI(this.viewProjectionMatrix)), this._frustumPlanes);
        }
        panByPosition(e, t) {
            return null;
        }
        _initProps(e) {
            const t = e.longitude, i = e.latitude;
            this.isGeospatial && (Number.isFinite(e.zoom) || (this.zoom = ZO({
                latitude: i
            }) + Math.log2(this.focalDistance)), this.distanceScales = e.distanceScales || Bd({
                latitude: i,
                longitude: t
            }));
            const r = Math.pow(2, this.zoom);
            this.scale = r;
            const { position: a, modelMatrix: l } = e;
            let u = I0;
            if (a && (u = l ? new Wn(l).transformAsVector(a, []) : a), this.isGeospatial) {
                const h = this.projectPosition([
                    t,
                    i,
                    0
                ]);
                this.center = new jn(u).scale(this.distanceScales.unitsPerMeter).add(h);
            } else this.center = this.projectPosition(u);
        }
        _initMatrices(e) {
            const { viewMatrix: t = BI, projectionMatrix: i = null, orthographic: r = !1, fovyRadians: a, fovy: l = 75, near: u = .1, far: h = 1e3, padding: d = null, focalDistance: p = 1 } = e;
            this.viewMatrixUncentered = t, this.viewMatrix = new Wn().multiplyRight(t).translate(new jn(this.center).negate()), this.projectionMatrix = i || FI({
                width: this.width,
                height: this.height,
                orthographic: r,
                fovyRadians: a || l * UI,
                focalDistance: p,
                padding: d,
                near: u,
                far: h
            });
            const _ = lo();
            wr(_, _, this.projectionMatrix), wr(_, _, this.viewMatrix), this.viewProjectionMatrix = _, this.viewMatrixInverse = Cd([], this.viewMatrix) || this.viewMatrix, this.cameraPosition = NI(this.viewMatrixInverse);
            const y = lo(), v = lo();
            Rg(y, y, [
                this.width / 2,
                -this.height / 2,
                1
            ]), Pc(y, y, [
                1,
                -1,
                0
            ]), wr(v, y, this.viewProjectionMatrix), this.pixelProjectionMatrix = v, this.pixelUnprojectionMatrix = Cd(lo(), this.pixelProjectionMatrix), this.pixelUnprojectionMatrix || Fe.warn("Pixel project matrix not invertible")();
        }
    }
    ta.displayName = "Viewport";
    class Qs extends ta {
        constructor(e = {}){
            const { latitude: t = 0, longitude: i = 0, zoom: r = 0, pitch: a = 0, bearing: l = 0, nearZMultiplier: u = .1, farZMultiplier: h = 1.01, nearZ: d, farZ: p, orthographic: _ = !1, projectionMatrix: y, repeat: v = !1, worldOffset: S = 0, position: E, padding: M, legacyMeterSizes: B = !1 } = e;
            let { width: H, height: O, altitude: U = 1.5 } = e;
            const L = Math.pow(2, r);
            H = H || 1, O = O || 1;
            let Z, se = null;
            if (y) U = y[5] / 2, Z = Bc(U);
            else {
                e.fovy ? (Z = e.fovy, U = NT(Z)) : Z = Bc(U);
                let te;
                if (M) {
                    const { top: fe = 0, bottom: ne = 0 } = M;
                    te = [
                        0,
                        Xi((fe + O - ne) / 2, 0, O) - O / 2
                    ];
                }
                se = GO({
                    width: H,
                    height: O,
                    scale: L,
                    center: E && [
                        0,
                        0,
                        E[2] * Gh(t)
                    ],
                    offset: te,
                    pitch: a,
                    fovy: Z,
                    nearZMultiplier: u,
                    farZMultiplier: h
                }), Number.isFinite(d) && (se.near = d), Number.isFinite(p) && (se.far = p);
            }
            let ae = QO({
                height: O,
                pitch: a,
                bearing: l,
                scale: L,
                altitude: U
            });
            S && (ae = new Wn().translate([
                512 * S,
                0,
                0
            ]).multiplyLeft(ae)), super({
                ...e,
                width: H,
                height: O,
                viewMatrix: ae,
                longitude: i,
                latitude: t,
                zoom: r,
                ...se,
                fovy: Z,
                focalDistance: U
            }), this.latitude = t, this.longitude = i, this.zoom = r, this.pitch = a, this.bearing = l, this.altitude = U, this.fovy = Z, this.orthographic = _, this._subViewports = v ? [] : null, this._pseudoMeters = B, Object.freeze(this);
        }
        get subViewports() {
            if (this._subViewports && !this._subViewports.length) {
                const e = this.getBounds(), t = Math.floor((e[0] + 180) / 360), i = Math.ceil((e[2] - 180) / 360);
                for(let r = t; r <= i; r++){
                    const a = r ? new Qs({
                        ...this,
                        worldOffset: r
                    }) : this;
                    this._subViewports.push(a);
                }
            }
            return this._subViewports;
        }
        projectPosition(e) {
            if (this._pseudoMeters) return super.projectPosition(e);
            const [t, i] = this.projectFlat(e), r = (e[2] || 0) * Gh(e[1]);
            return [
                t,
                i,
                r
            ];
        }
        unprojectPosition(e) {
            if (this._pseudoMeters) return super.unprojectPosition(e);
            const [t, i] = this.unprojectFlat(e), r = (e[2] || 0) / Gh(i);
            return [
                t,
                i,
                r
            ];
        }
        addMetersToLngLat(e, t) {
            return IT(e, t);
        }
        panByPosition(e, t) {
            const i = Og(t, this.pixelUnprojectionMatrix), r = this.projectFlat(e), a = t0([], r, MC([], i)), l = t0([], this.center, a), [u, h] = this.unprojectFlat(l);
            return {
                longitude: u,
                latitude: h
            };
        }
        getBounds(e = {}) {
            const t = tI(this, e.z || 0);
            return [
                Math.min(t[0][0], t[1][0], t[2][0], t[3][0]),
                Math.min(t[0][1], t[1][1], t[2][1], t[3][1]),
                Math.max(t[0][0], t[1][0], t[2][0], t[3][0]),
                Math.max(t[0][1], t[1][1], t[2][1], t[3][1])
            ];
        }
        fitBounds(e, t = {}) {
            const { width: i, height: r } = this, { longitude: a, latitude: l, zoom: u } = JO({
                width: i,
                height: r,
                bounds: e,
                ...t
            });
            return new Qs({
                width: i,
                height: r,
                longitude: a,
                latitude: l,
                zoom: u
            });
        }
    }
    Qs.displayName = "WebMercatorViewport";
    const N0 = [
        0,
        0,
        0
    ];
    function ed(n, e, t = !1) {
        const i = e.projectPosition(n);
        if (t && e instanceof Qs) {
            const [r, a, l = 0] = n, u = e.getDistanceScales([
                r,
                a
            ]);
            i[2] = l * u.unitsPerMeter[2];
        }
        return i;
    }
    function zI(n) {
        const { viewport: e, modelMatrix: t, coordinateOrigin: i } = n;
        let { coordinateSystem: r, fromCoordinateSystem: a, fromCoordinateOrigin: l } = n;
        return r === Oe.DEFAULT && (r = e.isGeospatial ? Oe.LNGLAT : Oe.CARTESIAN), a === void 0 && (a = r), l === void 0 && (l = i), {
            viewport: e,
            coordinateSystem: r,
            coordinateOrigin: i,
            modelMatrix: t,
            fromCoordinateSystem: a,
            fromCoordinateOrigin: l
        };
    }
    function LT(n, { viewport: e, modelMatrix: t, coordinateSystem: i, coordinateOrigin: r, offsetMode: a }) {
        let [l, u, h = 0] = n;
        switch(t && ([l, u, h] = Io([], [
            l,
            u,
            h,
            1
        ], t)), i){
            case Oe.LNGLAT:
                return ed([
                    l,
                    u,
                    h
                ], e, a);
            case Oe.LNGLAT_OFFSETS:
                return ed([
                    l + r[0],
                    u + r[1],
                    h + (r[2] || 0)
                ], e, a);
            case Oe.METER_OFFSETS:
                return ed(IT(r, [
                    l,
                    u,
                    h
                ]), e, a);
            case Oe.CARTESIAN:
            default:
                return e.isGeospatial ? [
                    l + r[0],
                    u + r[1],
                    h + r[2]
                ] : e.projectPosition([
                    l,
                    u,
                    h
                ]);
        }
    }
    function FT(n, e) {
        const { viewport: t, coordinateSystem: i, coordinateOrigin: r, modelMatrix: a, fromCoordinateSystem: l, fromCoordinateOrigin: u } = zI(e), { autoOffset: h = !0 } = e, { geospatialOrigin: d = N0, shaderCoordinateOrigin: p = N0, offsetMode: _ = !1 } = h ? MT(t, i, r) : {}, y = LT(n, {
            viewport: t,
            modelMatrix: a,
            coordinateSystem: l,
            coordinateOrigin: u,
            offsetMode: _
        });
        if (_) {
            const v = t.projectPosition(d || p);
            WC(y, y, v);
        }
        return y;
    }
    const VI = [
        255,
        255,
        255
    ], HI = 1, jI = [
        1,
        0,
        0
    ], WI = [
        0,
        0,
        1
    ];
    let $I = 0;
    class Pg {
        constructor(e = {}){
            this.type = "point";
            const { color: t = VI } = e, { intensity: i = HI } = e, { position: r = WI } = e;
            this.id = e.id || `point-${$I++}`, this.color = t, this.intensity = i, this.type = "point", this.position = r, this.attenuation = XI(e), this.projectedLight = {
                ...this
            };
        }
        getProjectedLight({ layer: e }) {
            const { projectedLight: t } = this, i = e.context.viewport, { coordinateSystem: r, coordinateOrigin: a } = e.props, l = FT(this.position, {
                viewport: i,
                coordinateSystem: r,
                coordinateOrigin: a,
                fromCoordinateSystem: i.isGeospatial ? Oe.LNGLAT : Oe.CARTESIAN,
                fromCoordinateOrigin: [
                    0,
                    0,
                    0
                ]
            });
            return t.color = this.color, t.intensity = this.intensity, t.position = l, t;
        }
    }
    function XI(n) {
        return n.attenuation ? n.attenuation : jI;
    }
    let YI = 1, qI = 1;
    class zT {
        time = 0;
        channels = new Map;
        animations = new Map;
        playing = !1;
        lastEngineTime = -1;
        constructor(){}
        addChannel(e) {
            const { delay: t = 0, duration: i = Number.POSITIVE_INFINITY, rate: r = 1, repeat: a = 1 } = e, l = YI++, u = {
                time: 0,
                delay: t,
                duration: i,
                rate: r,
                repeat: a
            };
            return this._setChannelTime(u, this.time), this.channels.set(l, u), l;
        }
        removeChannel(e) {
            this.channels.delete(e);
            for (const [t, i] of this.animations)i.channel === e && this.detachAnimation(t);
        }
        isFinished(e) {
            const t = this.channels.get(e);
            return t === void 0 ? !1 : this.time >= t.delay + t.duration * t.repeat;
        }
        getTime(e) {
            if (e === void 0) return this.time;
            const t = this.channels.get(e);
            return t === void 0 ? -1 : t.time;
        }
        setTime(e) {
            this.time = Math.max(0, e);
            const t = this.channels.values();
            for (const r of t)this._setChannelTime(r, this.time);
            const i = this.animations.values();
            for (const r of i){
                const { animation: a, channel: l } = r;
                a.setTime(this.getTime(l));
            }
        }
        play() {
            this.playing = !0;
        }
        pause() {
            this.playing = !1, this.lastEngineTime = -1;
        }
        reset() {
            this.setTime(0);
        }
        attachAnimation(e, t) {
            const i = qI++;
            return this.animations.set(i, {
                animation: e,
                channel: t
            }), e.setTime(this.getTime(t)), i;
        }
        detachAnimation(e) {
            this.animations.delete(e);
        }
        update(e) {
            this.playing && (this.lastEngineTime === -1 && (this.lastEngineTime = e), this.setTime(this.time + (e - this.lastEngineTime)), this.lastEngineTime = e);
        }
        _setChannelTime(e, t) {
            const i = t - e.delay, r = e.duration * e.repeat;
            i >= r ? e.time = e.duration * e.rate : (e.time = Math.max(0, i) % e.duration, e.time *= e.rate);
        }
    }
    function KI(n) {
        return typeof window < "u" && window.requestAnimationFrame ? window.requestAnimationFrame(n) : setTimeout(n, 1e3 / 60);
    }
    function ZI(n) {
        return typeof window < "u" && window.cancelAnimationFrame ? window.cancelAnimationFrame(n) : clearTimeout(n);
    }
    let QI = 0;
    const GI = {
        device: null,
        onAddHTML: ()=>"",
        onInitialize: async ()=>null,
        onRender: ()=>{},
        onFinalize: ()=>{},
        onError: (n)=>console.error(n),
        stats: wd.stats.get(`animation-loop-${QI++}`),
        useDevicePixels: !0,
        autoResizeViewport: !1,
        autoResizeDrawingBuffer: !1
    };
    class JI {
        device = null;
        canvas = null;
        props;
        animationProps = null;
        timeline = null;
        stats;
        cpuTime;
        gpuTime;
        frameRate;
        display;
        needsRedraw = "initialized";
        _initialized = !1;
        _running = !1;
        _animationFrameId = null;
        _nextFramePromise = null;
        _resolveNextFrame = null;
        _cpuStartTime = 0;
        _error = null;
        constructor(e){
            if (this.props = {
                ...GI,
                ...e
            }, e = this.props, !e.device) throw new Error("No device provided");
            const { useDevicePixels: t = !0 } = this.props;
            this.stats = e.stats || new Qc({
                id: "animation-loop-stats"
            }), this.cpuTime = this.stats.get("CPU Time"), this.gpuTime = this.stats.get("GPU Time"), this.frameRate = this.stats.get("Frame Rate"), this.setProps({
                autoResizeViewport: e.autoResizeViewport,
                autoResizeDrawingBuffer: e.autoResizeDrawingBuffer,
                useDevicePixels: t
            }), this.start = this.start.bind(this), this.stop = this.stop.bind(this), this._onMousemove = this._onMousemove.bind(this), this._onMouseleave = this._onMouseleave.bind(this);
        }
        destroy() {
            this.stop(), this._setDisplay(null);
        }
        delete() {
            this.destroy();
        }
        setError(e) {
            if (this.props.onError(e), this._error = Error(), this.device?.canvasContext?.canvas instanceof HTMLCanvasElement) {
                const i = document.createElement("h1");
                i.innerHTML = e.message, i.style.position = "absolute", i.style.top = "20%", i.style.left = "10px", i.style.color = "black", i.style.backgroundColor = "red", document.body.appendChild(i);
            }
        }
        setNeedsRedraw(e) {
            return this.needsRedraw = this.needsRedraw || e, this;
        }
        setProps(e) {
            return "autoResizeViewport" in e && (this.props.autoResizeViewport = e.autoResizeViewport || !1), "autoResizeDrawingBuffer" in e && (this.props.autoResizeDrawingBuffer = e.autoResizeDrawingBuffer || !1), "useDevicePixels" in e && (this.props.useDevicePixels = e.useDevicePixels || !1), this;
        }
        async start() {
            if (this._running) return this;
            this._running = !0;
            try {
                let e;
                return this._initialized || (this._initialized = !0, await this._initDevice(), this._initialize(), await this.props.onInitialize(this._getAnimationProps())), this._running ? (e !== !1 && (this._cancelAnimationFrame(), this._requestAnimationFrame()), this) : null;
            } catch (e) {
                const t = e instanceof Error ? e : new Error("Unknown error");
                throw this.props.onError(t), t;
            }
        }
        stop() {
            return this._running && (this.animationProps && !this._error && this.props.onFinalize(this.animationProps), this._cancelAnimationFrame(), this._nextFramePromise = null, this._resolveNextFrame = null, this._running = !1), this;
        }
        redraw() {
            return this.device?.isLost || this._error ? this : (this._beginFrameTimers(), this._setupFrame(), this._updateAnimationProps(), this._renderFrame(this._getAnimationProps()), this._clearNeedsRedraw(), this._resolveNextFrame && (this._resolveNextFrame(this), this._nextFramePromise = null, this._resolveNextFrame = null), this._endFrameTimers(), this);
        }
        attachTimeline(e) {
            return this.timeline = e, this.timeline;
        }
        detachTimeline() {
            this.timeline = null;
        }
        waitForRender() {
            return this.setNeedsRedraw("waitForRender"), this._nextFramePromise || (this._nextFramePromise = new Promise((e)=>{
                this._resolveNextFrame = e;
            })), this._nextFramePromise;
        }
        async toDataURL() {
            if (this.setNeedsRedraw("toDataURL"), await this.waitForRender(), this.canvas instanceof HTMLCanvasElement) return this.canvas.toDataURL();
            throw new Error("OffscreenCanvas");
        }
        _initialize() {
            this._startEventHandling(), this._initializeAnimationProps(), this._updateAnimationProps(), this._resizeCanvasDrawingBuffer(), this._resizeViewport();
        }
        _setDisplay(e) {
            this.display && (this.display.destroy(), this.display.animationLoop = null), e && (e.animationLoop = this), this.display = e;
        }
        _requestAnimationFrame() {
            this._running && (this._animationFrameId = KI(this._animationFrame.bind(this)));
        }
        _cancelAnimationFrame() {
            this._animationFrameId !== null && (ZI(this._animationFrameId), this._animationFrameId = null);
        }
        _animationFrame() {
            this._running && (this.redraw(), this._requestAnimationFrame());
        }
        _renderFrame(e) {
            if (this.display) {
                this.display._renderFrame(e);
                return;
            }
            this.props.onRender(this._getAnimationProps()), this.device?.submit();
        }
        _clearNeedsRedraw() {
            this.needsRedraw = !1;
        }
        _setupFrame() {
            this._resizeCanvasDrawingBuffer(), this._resizeViewport();
        }
        _initializeAnimationProps() {
            const e = this.device?.canvasContext?.canvas;
            if (!this.device || !e) throw new Error("loop");
            this.animationProps = {
                animationLoop: this,
                device: this.device,
                canvas: e,
                timeline: this.timeline,
                useDevicePixels: this.props.useDevicePixels,
                needsRedraw: !1,
                width: 1,
                height: 1,
                aspect: 1,
                time: 0,
                startTime: Date.now(),
                engineTime: 0,
                tick: 0,
                tock: 0,
                _mousePosition: null
            };
        }
        _getAnimationProps() {
            if (!this.animationProps) throw new Error("animationProps");
            return this.animationProps;
        }
        _updateAnimationProps() {
            if (!this.animationProps) return;
            const { width: e, height: t, aspect: i } = this._getSizeAndAspect();
            (e !== this.animationProps.width || t !== this.animationProps.height) && this.setNeedsRedraw("drawing buffer resized"), i !== this.animationProps.aspect && this.setNeedsRedraw("drawing buffer aspect changed"), this.animationProps.width = e, this.animationProps.height = t, this.animationProps.aspect = i, this.animationProps.needsRedraw = this.needsRedraw, this.animationProps.engineTime = Date.now() - this.animationProps.startTime, this.timeline && this.timeline.update(this.animationProps.engineTime), this.animationProps.tick = Math.floor(this.animationProps.time / 1e3 * 60), this.animationProps.tock++, this.animationProps.time = this.timeline ? this.timeline.getTime() : this.animationProps.engineTime;
        }
        async _initDevice() {
            if (this.device = await this.props.device, !this.device) throw new Error("No device provided");
            this.canvas = this.device.canvasContext?.canvas || null;
        }
        _createInfoDiv() {
            if (this.canvas && this.props.onAddHTML) {
                const e = document.createElement("div");
                document.body.appendChild(e), e.style.position = "relative";
                const t = document.createElement("div");
                t.style.position = "absolute", t.style.left = "10px", t.style.bottom = "10px", t.style.width = "300px", t.style.background = "white", this.canvas instanceof HTMLCanvasElement && e.appendChild(this.canvas), e.appendChild(t);
                const i = this.props.onAddHTML(t);
                i && (t.innerHTML = i);
            }
        }
        _getSizeAndAspect() {
            if (!this.device) return {
                width: 1,
                height: 1,
                aspect: 1
            };
            const [e, t] = this.device?.canvasContext?.getPixelSize() || [
                1,
                1
            ];
            let i = 1;
            const r = this.device?.canvasContext?.canvas;
            return r && r.clientHeight ? i = r.clientWidth / r.clientHeight : e > 0 && t > 0 && (i = e / t), {
                width: e,
                height: t,
                aspect: i
            };
        }
        _resizeViewport() {
            this.props.autoResizeViewport && this.device.gl && this.device.gl.viewport(0, 0, this.device.gl.drawingBufferWidth, this.device.gl.drawingBufferHeight);
        }
        _resizeCanvasDrawingBuffer() {
            this.props.autoResizeDrawingBuffer && this.device?.canvasContext?.resize({
                useDevicePixels: this.props.useDevicePixels
            });
        }
        _beginFrameTimers() {
            this.frameRate.timeEnd(), this.frameRate.timeStart(), this.cpuTime.timeStart();
        }
        _endFrameTimers() {
            this.cpuTime.timeEnd();
        }
        _startEventHandling() {
            this.canvas && (this.canvas.addEventListener("mousemove", this._onMousemove.bind(this)), this.canvas.addEventListener("mouseleave", this._onMouseleave.bind(this)));
        }
        _onMousemove(e) {
            e instanceof MouseEvent && (this._getAnimationProps()._mousePosition = [
                e.offsetX,
                e.offsetY
            ]);
        }
        _onMouseleave(e) {
            this._getAnimationProps()._mousePosition = null;
        }
    }
    const td = {};
    function ru(n = "id") {
        td[n] = td[n] || 1;
        const e = td[n]++;
        return `${n}-${e}`;
    }
    class P0 {
        id;
        userData = {};
        topology;
        bufferLayout = [];
        vertexCount;
        indices;
        attributes;
        constructor(e){
            if (this.id = e.id || ru("geometry"), this.topology = e.topology, this.indices = e.indices || null, this.attributes = e.attributes, this.vertexCount = e.vertexCount, this.bufferLayout = e.bufferLayout || [], this.indices && !(this.indices.usage & Ge.INDEX)) throw new Error("Index buffer must have INDEX usage");
        }
        destroy() {
            this.indices?.destroy();
            for (const e of Object.values(this.attributes))e.destroy();
        }
        getVertexCount() {
            return this.vertexCount;
        }
        getAttributes() {
            return this.attributes;
        }
        getIndexes() {
            return this.indices || null;
        }
        _calculateVertexCount(e) {
            return e.byteLength / 12;
        }
    }
    function e4(n, e) {
        if (e instanceof P0) return e;
        const t = t4(n, e), { attributes: i, bufferLayout: r } = n4(n, e);
        return new P0({
            topology: e.topology || "triangle-list",
            bufferLayout: r,
            vertexCount: e.vertexCount,
            indices: t,
            attributes: i
        });
    }
    function t4(n, e) {
        if (!e.indices) return;
        const t = e.indices.value;
        return n.createBuffer({
            usage: Ge.INDEX,
            data: t
        });
    }
    function n4(n, e) {
        const t = [], i = {};
        for (const [a, l] of Object.entries(e.attributes)){
            let u = a;
            switch(a){
                case "POSITION":
                    u = "positions";
                    break;
                case "NORMAL":
                    u = "normals";
                    break;
                case "TEXCOORD_0":
                    u = "texCoords";
                    break;
                case "COLOR_0":
                    u = "colors";
                    break;
            }
            if (l) {
                i[u] = n.createBuffer({
                    data: l.value,
                    id: `${a}-buffer`
                });
                const { value: h, size: d, normalized: p } = l;
                t.push({
                    name: u,
                    format: jR(h, d, p)
                });
            }
        }
        const r = e._calculateVertexCount(e.attributes, e.indices);
        return {
            attributes: i,
            bufferLayout: t,
            vertexCount: r
        };
    }
    class Dg {
        static defaultProps = {
            ...$s.defaultProps
        };
        static getDefaultPipelineFactory(e) {
            return e._lumaData.defaultPipelineFactory = e._lumaData.defaultPipelineFactory || new Dg(e), e._lumaData.defaultPipelineFactory;
        }
        device;
        destroyPolicy;
        _hashCounter = 0;
        _hashes = {};
        _renderPipelineCache = {};
        _computePipelineCache = {};
        constructor(e){
            this.device = e, this.destroyPolicy = e.props._factoryDestroyPolicy;
        }
        createRenderPipeline(e) {
            const t = {
                ...$s.defaultProps,
                ...e
            }, i = this._hashRenderPipeline(t);
            if (!this._renderPipelineCache[i]) {
                const r = this.device.createRenderPipeline({
                    ...t,
                    id: t.id ? `${t.id}-cached` : void 0
                });
                r.hash = i, this._renderPipelineCache[i] = {
                    pipeline: r,
                    useCount: 0
                };
            }
            return this._renderPipelineCache[i].useCount++, this._renderPipelineCache[i].pipeline;
        }
        createComputePipeline(e) {
            const t = {
                ...wc.defaultProps,
                ...e
            }, i = this._hashComputePipeline(t);
            if (!this._computePipelineCache[i]) {
                const r = this.device.createComputePipeline({
                    ...t,
                    id: t.id ? `${t.id}-cached` : void 0
                });
                r.hash = i, this._computePipelineCache[i] = {
                    pipeline: r,
                    useCount: 0
                };
            }
            return this._computePipelineCache[i].useCount++, this._computePipelineCache[i].pipeline;
        }
        release(e) {
            const t = e.hash, i = e instanceof wc ? this._computePipelineCache : this._renderPipelineCache;
            i[t].useCount--, i[t].useCount === 0 && this.destroyPolicy === "unused" && (i[t].pipeline.destroy(), delete i[t]);
        }
        _hashComputePipeline(e) {
            return `${this._getHash(e.shader.source)}`;
        }
        _hashRenderPipeline(e) {
            const t = e.vs ? this._getHash(e.vs.source) : 0, i = e.fs ? this._getHash(e.fs.source) : 0, r = "-", a = this._getHash(JSON.stringify(e.bufferLayout));
            switch(this.device.type){
                case "webgl":
                    return `${t}/${i}V${r}BL${a}`;
                default:
                    const l = this._getHash(JSON.stringify(e.parameters));
                    return `${t}/${i}V${r}T${e.topology}P${l}BL${a}`;
            }
        }
        _getHash(e) {
            return this._hashes[e] === void 0 && (this._hashes[e] = this._hashCounter++), this._hashes[e];
        }
    }
    class kg {
        static defaultProps = {
            ...tu.defaultProps
        };
        static getDefaultShaderFactory(e) {
            return e._lumaData.defaultShaderFactory ||= new kg(e), e._lumaData.defaultShaderFactory;
        }
        device;
        destroyPolicy;
        _cache = {};
        constructor(e){
            this.device = e, this.destroyPolicy = e.props._factoryDestroyPolicy;
        }
        createShader(e) {
            const t = this._hashShader(e);
            let i = this._cache[t];
            if (!i) {
                const r = this.device.createShader({
                    ...e,
                    id: e.id ? `${e.id}-cached` : void 0
                });
                this._cache[t] = i = {
                    shader: r,
                    useCount: 0
                };
            }
            return i.useCount++, i.shader;
        }
        release(e) {
            const t = this._hashShader(e), i = this._cache[t];
            i && (i.useCount--, i.useCount === 0 && this.destroyPolicy === "unused" && (delete this._cache[t], i.shader.destroy()));
        }
        _hashShader(e) {
            return `${e.stage}:${e.source}`;
        }
    }
    function i4(n, e) {
        const t = {}, i = "Values";
        if (n.attributes.length === 0 && !n.varyings?.length) return {
            "No attributes or varyings": {
                [i]: "N/A"
            }
        };
        for (const r of n.attributes)if (r) {
            const a = `${r.location} ${r.name}: ${r.type}`;
            t[`in ${a}`] = {
                [i]: r.stepMode || "vertex"
            };
        }
        for (const r of n.varyings || []){
            const a = `${r.location} ${r.name}`;
            t[`out ${a}`] = {
                [i]: JSON.stringify(r)
            };
        }
        return t;
    }
    let Tt = null, nd = null;
    function r4(n, { id: e, minimap: t, opaque: i, top: r = "0", left: a = "0", rgbaScale: l = 1 }) {
        Tt || (Tt = document.createElement("canvas"), Tt.id = e, Tt.title = e, Tt.style.zIndex = "100", Tt.style.position = "absolute", Tt.style.top = r, Tt.style.left = a, Tt.style.border = "blue 5px solid", Tt.style.transform = "scaleY(-1)", document.body.appendChild(Tt), nd = Tt.getContext("2d")), (Tt.width !== n.width || Tt.height !== n.height) && (Tt.width = n.width / 2, Tt.height = n.height / 2, Tt.style.width = "400px", Tt.style.height = "400px");
        const u = n.device.readPixelsToArrayWebGL(n), h = nd?.createImageData(n.width, n.height);
        if (h) {
            for(let p = 0; p < u.length; p += 4)h.data[0 + p + 0] = u[p + 0] * l, h.data[0 + p + 1] = u[p + 1] * l, h.data[0 + p + 2] = u[p + 2] * l, h.data[0 + p + 3] = i ? 255 : u[p + 3] * l;
            nd?.putImageData(h, 0, 0);
        }
    }
    function Fd(n, e, t) {
        if (n === e) return !0;
        if (!t || !n || !e) return !1;
        if (Array.isArray(n)) {
            if (!Array.isArray(e) || n.length !== e.length) return !1;
            for(let i = 0; i < n.length; i++)if (!Fd(n[i], e[i], t - 1)) return !1;
            return !0;
        }
        if (Array.isArray(e)) return !1;
        if (typeof n == "object" && typeof e == "object") {
            const i = Object.keys(n), r = Object.keys(e);
            if (i.length !== r.length) return !1;
            for (const a of i)if (!e.hasOwnProperty(a) || !Fd(n[a], e[a], t - 1)) return !1;
            return !0;
        }
        return !1;
    }
    function s4(n) {
        return ArrayBuffer.isView(n) && !(n instanceof DataView);
    }
    function a4(n) {
        return Array.isArray(n) ? n.length === 0 || typeof n[0] == "number" : !1;
    }
    function VT(n) {
        return s4(n) || a4(n);
    }
    function o4(n) {
        return VT(n) || typeof n == "number" || typeof n == "boolean";
    }
    function HT(n) {
        const e = {
            bindings: {},
            uniforms: {}
        };
        return Object.keys(n).forEach((t)=>{
            const i = n[t];
            o4(i) ? e.uniforms[t] = i : e.bindings[t] = i;
        }), e;
    }
    class l4 {
        options = {
            disableWarnings: !1
        };
        modules;
        moduleUniforms;
        moduleBindings;
        constructor(e, t){
            Object.assign(this.options, t);
            const i = fg(Object.values(e).filter((r)=>r.dependencies));
            for (const r of i)e[r.name] = r;
            J.log(1, "Creating ShaderInputs with modules", Object.keys(e))(), this.modules = e, this.moduleUniforms = {}, this.moduleBindings = {};
            for (const [r, a] of Object.entries(e))this._addModule(a), a.name && r !== a.name && !this.options.disableWarnings && J.warn(`Module name: ${r} vs ${a.name}`)();
        }
        destroy() {}
        setProps(e) {
            for (const t of Object.keys(e)){
                const i = t, r = e[i] || {}, a = this.modules[i];
                if (!a) {
                    this.options.disableWarnings || J.warn(`Module ${t} not found`)();
                    continue;
                }
                const l = this.moduleUniforms[i], u = this.moduleBindings[i], h = a.getUniforms?.(r, l) || r, { uniforms: d, bindings: p } = HT(h);
                this.moduleUniforms[i] = {
                    ...l,
                    ...d
                }, this.moduleBindings[i] = {
                    ...u,
                    ...p
                };
            }
        }
        getModules() {
            return Object.values(this.modules);
        }
        getUniformValues() {
            return this.moduleUniforms;
        }
        getBindingValues() {
            const e = {};
            for (const t of Object.values(this.moduleBindings))Object.assign(e, t);
            return e;
        }
        getDebugTable() {
            const e = {};
            for (const [t, i] of Object.entries(this.moduleUniforms))for (const [r, a] of Object.entries(i))e[`${t}.${r}`] = {
                type: this.modules[t].uniformTypes?.[r],
                value: String(a)
            };
            return e;
        }
        _addModule(e) {
            const t = e.name;
            this.moduleUniforms[t] = e.defaultUniforms || {}, this.moduleBindings[t] = {};
        }
    }
    let c4 = "";
    async function u4(n, e) {
        const t = new Image;
        return t.crossOrigin = "anonymous", t.src = n.startsWith("http") ? n : c4 + n, await t.decode(), e ? await createImageBitmap(t, e) : await createImageBitmap(t);
    }
    class id {
        device;
        id;
        texture;
        sampler;
        view;
        ready;
        isReady = !1;
        destroyed = !1;
        resolveReady = ()=>{};
        rejectReady = ()=>{};
        get [Symbol.toStringTag]() {
            return "AsyncTexture";
        }
        toString() {
            return `AsyncTexture:"${this.id}"(${this.isReady ? "ready" : "loading"})`;
        }
        constructor(e, t){
            this.device = e, this.id = t.id || ru("async-texture"), typeof t?.data == "string" && t.dimension === "2d" && (t = {
                ...t,
                data: u4(t.data)
            }), this.ready = new Promise((i, r)=>{
                this.resolveReady = ()=>{
                    this.isReady = !0, i();
                }, this.rejectReady = r;
            }), this.initAsync(t);
        }
        async initAsync(e) {
            const t = e.data;
            let i;
            try {
                i = await jT(t);
            } catch (a) {
                this.rejectReady(a);
            }
            if (this.destroyed) return;
            const r = {
                ...e,
                data: i
            };
            this.texture = this.device.createTexture(r), this.sampler = this.texture.sampler, this.view = this.texture.view, this.isReady = !0, this.resolveReady();
        }
        destroy() {
            this.texture && (this.texture.destroy(), this.texture = null), this.destroyed = !0;
        }
        resize(e) {
            if (!this.isReady) throw new Error("Cannot resize texture before it is ready");
            if (e.width === this.texture.width && e.height === this.texture.height) return !1;
            if (this.texture) {
                const t = this.texture;
                this.texture = t.clone(e), t.destroy();
            }
            return !0;
        }
    }
    async function jT(n) {
        if (n = await n, Array.isArray(n)) return await Promise.all(n.map(jT));
        if (n && typeof n == "object" && n.constructor === Object) {
            const e = n, t = await Promise.all(Object.values(e)), i = Object.keys(e), r = {};
            for(let a = 0; a < i.length; a++)r[i[a]] = t[a];
            return r;
        }
        return n;
    }
    const yr = 2, f4 = 1e4;
    class $n {
        static defaultProps = {
            ...$s.defaultProps,
            source: void 0,
            vs: null,
            fs: null,
            id: "unnamed",
            handle: void 0,
            userData: {},
            defines: {},
            modules: [],
            moduleSettings: void 0,
            geometry: null,
            indexBuffer: null,
            attributes: {},
            constantAttributes: {},
            varyings: [],
            isInstanced: void 0,
            instanceCount: 0,
            vertexCount: 0,
            shaderInputs: void 0,
            pipelineFactory: void 0,
            shaderFactory: void 0,
            transformFeedback: void 0,
            shaderAssembler: Tr.getDefaultShaderAssembler(),
            debugShaders: void 0,
            disableWarnings: void 0
        };
        device;
        id;
        source;
        vs;
        fs;
        pipelineFactory;
        shaderFactory;
        userData = {};
        parameters;
        topology;
        bufferLayout;
        isInstanced = void 0;
        instanceCount = 0;
        vertexCount;
        indexBuffer = null;
        bufferAttributes = {};
        constantAttributes = {};
        bindings = {};
        uniforms = {};
        vertexArray;
        transformFeedback = null;
        pipeline;
        shaderInputs;
        _uniformStore;
        _attributeInfos = {};
        _gpuGeometry = null;
        _getModuleUniforms;
        props;
        _pipelineNeedsUpdate = "newly created";
        _needsRedraw = "initializing";
        _destroyed = !1;
        _lastDrawTimestamp = -1;
        get [Symbol.toStringTag]() {
            return "Model";
        }
        toString() {
            return `Model(${this.id})`;
        }
        constructor(e, t){
            this.props = {
                ...$n.defaultProps,
                ...t
            }, t = this.props, this.id = t.id || ru("model"), this.device = e, Object.assign(this.userData, t.userData);
            const i = Object.fromEntries(this.props.modules?.map((h)=>[
                    h.name,
                    h
                ]) || []), r = t.shaderInputs || new l4(i, {
                disableWarnings: this.props.disableWarnings
            });
            this.setShaderInputs(r);
            const a = d4(e), l = (this.props.modules?.length > 0 ? this.props.modules : this.shaderInputs?.getModules()) || [];
            if (this.device.type === "webgpu" && this.props.source) {
                const { source: h, getUniforms: d } = this.props.shaderAssembler.assembleWGSLShader({
                    platformInfo: a,
                    ...this.props,
                    modules: l
                });
                this.source = h, this._getModuleUniforms = d, this.props.shaderLayout ||= bC(this.source);
            } else {
                const { vs: h, fs: d, getUniforms: p } = this.props.shaderAssembler.assembleGLSLShaderPair({
                    platformInfo: a,
                    ...this.props,
                    modules: l
                });
                this.vs = h, this.fs = d, this._getModuleUniforms = p;
            }
            this.vertexCount = this.props.vertexCount, this.instanceCount = this.props.instanceCount, this.topology = this.props.topology, this.bufferLayout = this.props.bufferLayout, this.parameters = this.props.parameters, t.geometry && this.setGeometry(t.geometry), this.pipelineFactory = t.pipelineFactory || Dg.getDefaultPipelineFactory(this.device), this.shaderFactory = t.shaderFactory || kg.getDefaultShaderFactory(this.device), this.pipeline = this._updatePipeline(), this.vertexArray = e.createVertexArray({
                renderPipeline: this.pipeline
            }), this._gpuGeometry && this._setGeometryAttributes(this._gpuGeometry), "isInstanced" in t && (this.isInstanced = t.isInstanced), t.instanceCount && this.setInstanceCount(t.instanceCount), t.vertexCount && this.setVertexCount(t.vertexCount), t.indexBuffer && this.setIndexBuffer(t.indexBuffer), t.attributes && this.setAttributes(t.attributes), t.constantAttributes && this.setConstantAttributes(t.constantAttributes), t.bindings && this.setBindings(t.bindings), t.uniforms && this.setUniformsWebGL(t.uniforms), t.moduleSettings && this.updateModuleSettingsWebGL(t.moduleSettings), t.transformFeedback && (this.transformFeedback = t.transformFeedback), Object.seal(this);
        }
        destroy() {
            this._destroyed || (this.pipelineFactory.release(this.pipeline), this.shaderFactory.release(this.pipeline.vs), this.pipeline.fs && this.shaderFactory.release(this.pipeline.fs), this._uniformStore.destroy(), this._gpuGeometry?.destroy(), this._destroyed = !0);
        }
        needsRedraw() {
            this._getBindingsUpdateTimestamp() > this._lastDrawTimestamp && this.setNeedsRedraw("contents of bound textures or buffers updated");
            const e = this._needsRedraw;
            return this._needsRedraw = !1, e;
        }
        setNeedsRedraw(e) {
            this._needsRedraw ||= e;
        }
        predraw() {
            this.updateShaderInputs(), this.pipeline = this._updatePipeline();
        }
        draw(e) {
            const t = this._areBindingsLoading();
            if (t) return J.info(yr, `>>> DRAWING ABORTED ${this.id}: ${t} not loaded`)(), !1;
            try {
                e.pushDebugGroup(`${this}.predraw(${e})`), this.predraw();
            } finally{
                e.popDebugGroup();
            }
            let i;
            try {
                e.pushDebugGroup(`${this}.draw(${e})`), this._logDrawCallStart(), this.pipeline = this._updatePipeline();
                const r = this._getBindings();
                this.pipeline.setBindings(r, {
                    disableWarnings: this.props.disableWarnings
                }), zd(this.uniforms) || this.pipeline.setUniformsWebGL(this.uniforms);
                const { indexBuffer: a } = this.vertexArray, l = a ? a.byteLength / (a.indexType === "uint32" ? 4 : 2) : void 0;
                i = this.pipeline.draw({
                    renderPass: e,
                    vertexArray: this.vertexArray,
                    isInstanced: this.isInstanced,
                    vertexCount: this.vertexCount,
                    instanceCount: this.instanceCount,
                    indexCount: l,
                    transformFeedback: this.transformFeedback || void 0,
                    parameters: this.parameters,
                    topology: this.topology
                });
            } finally{
                e.popDebugGroup(), this._logDrawCallEnd();
            }
            return this._logFramebuffer(e), i ? (this._lastDrawTimestamp = this.device.timestamp, this._needsRedraw = !1) : this._needsRedraw = "waiting for resource initialization", i;
        }
        setGeometry(e) {
            this._gpuGeometry?.destroy();
            const t = e && e4(this.device, e);
            if (t) {
                this.setTopology(t.topology || "triangle-list");
                const i = new Vh(this.bufferLayout);
                this.bufferLayout = i.mergeBufferLayouts(t.bufferLayout, this.bufferLayout), this.vertexArray && this._setGeometryAttributes(t);
            }
            this._gpuGeometry = t;
        }
        setTopology(e) {
            e !== this.topology && (this.topology = e, this._setPipelineNeedsUpdate("topology"));
        }
        setBufferLayout(e) {
            const t = new Vh(this.bufferLayout);
            this.bufferLayout = this._gpuGeometry ? t.mergeBufferLayouts(e, this._gpuGeometry.bufferLayout) : e, this._setPipelineNeedsUpdate("bufferLayout"), this.pipeline = this._updatePipeline(), this.vertexArray = this.device.createVertexArray({
                renderPipeline: this.pipeline
            }), this._gpuGeometry && this._setGeometryAttributes(this._gpuGeometry);
        }
        setParameters(e) {
            Fd(e, this.parameters, 2) || (this.parameters = e, this._setPipelineNeedsUpdate("parameters"));
        }
        setInstanceCount(e) {
            this.instanceCount = e, this.isInstanced === void 0 && e > 0 && (this.isInstanced = !0), this.setNeedsRedraw("instanceCount");
        }
        setVertexCount(e) {
            this.vertexCount = e, this.setNeedsRedraw("vertexCount");
        }
        setShaderInputs(e) {
            this.shaderInputs = e, this._uniformStore = new HR(this.shaderInputs.modules);
            for (const [t, i] of Object.entries(this.shaderInputs.modules))if (h4(i)) {
                const r = this._uniformStore.getManagedUniformBuffer(this.device, t);
                this.bindings[`${t}Uniforms`] = r;
            }
            this.setNeedsRedraw("shaderInputs");
        }
        updateShaderInputs() {
            this._uniformStore.setUniforms(this.shaderInputs.getUniformValues()), this.setBindings(this.shaderInputs.getBindingValues()), this.setNeedsRedraw("shaderInputs");
        }
        setBindings(e) {
            Object.assign(this.bindings, e), this.setNeedsRedraw("bindings");
        }
        setTransformFeedback(e) {
            this.transformFeedback = e, this.setNeedsRedraw("transformFeedback");
        }
        setIndexBuffer(e) {
            this.vertexArray.setIndexBuffer(e), this.setNeedsRedraw("indexBuffer");
        }
        setAttributes(e, t) {
            const i = t?.disableWarnings ?? this.props.disableWarnings;
            e.indices && J.warn(`Model:${this.id} setAttributes() - indexBuffer should be set using setIndexBuffer()`)(), this.bufferLayout = WR(this.pipeline.shaderLayout, this.bufferLayout);
            const r = new Vh(this.bufferLayout);
            for (const [a, l] of Object.entries(e)){
                const u = r.getBufferLayout(a);
                if (!u) {
                    i || J.warn(`Model(${this.id}): Missing layout for buffer "${a}".`)();
                    continue;
                }
                const h = r.getAttributeNamesForBuffer(u);
                let d = !1;
                for (const p of h){
                    const _ = this._attributeInfos[p];
                    if (_) {
                        const y = this.device.type === "webgpu" ? r.getBufferIndex(_.bufferName) : _.location;
                        this.vertexArray.setBuffer(y, l), d = !0;
                    }
                }
                !d && !i && J.warn(`Model(${this.id}): Ignoring buffer "${l.id}" for unknown attribute "${a}"`)();
            }
            this.setNeedsRedraw("attributes");
        }
        setConstantAttributes(e, t) {
            for (const [i, r] of Object.entries(e)){
                const a = this._attributeInfos[i];
                a ? this.vertexArray.setConstantWebGL(a.location, r) : (t?.disableWarnings ?? this.props.disableWarnings) || J.warn(`Model "${this.id}: Ignoring constant supplied for unknown attribute "${i}"`)();
            }
            this.setNeedsRedraw("constants");
        }
        setUniforms(e) {
            this.setUniformsWebGL(e);
        }
        setUniformsWebGL(e) {
            zd(e) || (this.pipeline.setUniformsWebGL(e), Object.assign(this.uniforms, e)), this.setNeedsRedraw("uniforms");
        }
        updateModuleSettingsWebGL(e) {
            const { bindings: t, uniforms: i } = HT(this._getModuleUniforms(e));
            Object.assign(this.bindings, t), Object.assign(this.uniforms, i), this.setNeedsRedraw("moduleSettings");
        }
        _areBindingsLoading() {
            for (const e of Object.values(this.bindings))if (e instanceof id && !e.isReady) return e.id;
            return !1;
        }
        _getBindings() {
            const e = {};
            for (const [t, i] of Object.entries(this.bindings))i instanceof id ? i.isReady && (e[t] = i.texture) : e[t] = i;
            return e;
        }
        _getBindingsUpdateTimestamp() {
            let e = 0;
            for (const t of Object.values(this.bindings))t instanceof eu ? e = Math.max(e, t.texture.updateTimestamp) : t instanceof Ge || t instanceof Xe ? e = Math.max(e, t.updateTimestamp) : t instanceof id ? e = t.texture ? Math.max(e, t.texture.updateTimestamp) : 1 / 0 : t instanceof vo || (e = Math.max(e, t.buffer.updateTimestamp));
            return e;
        }
        _setGeometryAttributes(e) {
            const t = {
                ...e.attributes
            };
            for (const [i] of Object.entries(t))!this.pipeline.shaderLayout.attributes.find((r)=>r.name === i) && i !== "positions" && delete t[i];
            this.vertexCount = e.vertexCount, this.setIndexBuffer(e.indices || null), this.setAttributes(e.attributes, {
                disableWarnings: !0
            }), this.setAttributes(t, {
                disableWarnings: this.props.disableWarnings
            }), this.setNeedsRedraw("geometry attributes");
        }
        _setPipelineNeedsUpdate(e) {
            this._pipelineNeedsUpdate ||= e, this.setNeedsRedraw(e);
        }
        _updatePipeline() {
            if (this._pipelineNeedsUpdate) {
                let e = null, t = null;
                this.pipeline && (J.log(1, `Model ${this.id}: Recreating pipeline because "${this._pipelineNeedsUpdate}".`)(), e = this.pipeline.vs, t = this.pipeline.fs), this._pipelineNeedsUpdate = !1;
                const i = this.shaderFactory.createShader({
                    id: `${this.id}-vertex`,
                    stage: "vertex",
                    source: this.source || this.vs,
                    debugShaders: this.props.debugShaders
                });
                let r = null;
                this.source ? r = i : this.fs && (r = this.shaderFactory.createShader({
                    id: `${this.id}-fragment`,
                    stage: "fragment",
                    source: this.source || this.fs,
                    debugShaders: this.props.debugShaders
                })), this.pipeline = this.pipelineFactory.createRenderPipeline({
                    ...this.props,
                    bufferLayout: this.bufferLayout,
                    topology: this.topology,
                    parameters: this.parameters,
                    bindings: this._getBindings(),
                    vs: i,
                    fs: r
                }), this._attributeInfos = k3(this.pipeline.shaderLayout, this.bufferLayout), e && this.shaderFactory.release(e), t && this.shaderFactory.release(t);
            }
            return this.pipeline;
        }
        _lastLogTime = 0;
        _logOpen = !1;
        _logDrawCallStart() {
            const e = J.level > 3 ? 0 : f4;
            J.level < 2 || Date.now() - this._lastLogTime < e || (this._lastLogTime = Date.now(), this._logOpen = !0, J.group(yr, `>>> DRAWING MODEL ${this.id}`, {
                collapsed: J.level <= 2
            })());
        }
        _logDrawCallEnd() {
            if (this._logOpen) {
                const e = i4(this.pipeline.shaderLayout, this.id);
                J.table(yr, e)();
                const t = this.shaderInputs.getDebugTable();
                for (const [r, a] of Object.entries(this.uniforms))t[r] = {
                    value: a
                };
                J.table(yr, t)();
                const i = this._getAttributeDebugTable();
                J.table(yr, this._attributeInfos)(), J.table(yr, i)(), J.groupEnd(yr)(), this._logOpen = !1;
            }
        }
        _drawCount = 0;
        _logFramebuffer(e) {
            const t = this.device.props.debugFramebuffers;
            if (this._drawCount++, !t) return;
            const i = e.props.framebuffer;
            i && r4(i, {
                id: i.id,
                minimap: !0
            });
        }
        _getAttributeDebugTable() {
            const e = {};
            for (const [t, i] of Object.entries(this._attributeInfos)){
                const r = this.vertexArray.attributes[i.location];
                e[i.location] = {
                    name: t,
                    type: i.shaderType,
                    values: r ? this._getBufferOrConstantValues(r, i.bufferDataType) : "null"
                };
            }
            if (this.vertexArray.indexBuffer) {
                const { indexBuffer: t } = this.vertexArray, i = t.indexType === "uint32" ? new Uint32Array(t.debugData) : new Uint16Array(t.debugData);
                e.indices = {
                    name: "indices",
                    type: t.indexType,
                    values: i.toString()
                };
            }
            return e;
        }
        _getBufferOrConstantValues(e, t) {
            const i = L3(t);
            return (e instanceof Ge ? new i(e.debugData) : e).toString();
        }
    }
    function h4(n) {
        return !!(n.uniformTypes && !zd(n.uniformTypes));
    }
    function d4(n) {
        return {
            type: n.type,
            shaderLanguage: n.info.shadingLanguage,
            shaderLanguageVersion: n.info.shadingLanguageVersion,
            gpu: n.info.gpu,
            features: n.features
        };
    }
    function zd(n) {
        for(const e in n)return !1;
        return !0;
    }
    class Ir {
        device;
        model;
        transformFeedback;
        static defaultProps = {
            ...$n.defaultProps,
            outputs: void 0,
            feedbackBuffers: void 0
        };
        static isSupported(e) {
            return e?.info?.type === "webgl";
        }
        constructor(e, t = Ir.defaultProps){
            if (!Ir.isSupported(e)) throw new Error("BufferTransform not yet implemented on WebGPU");
            this.device = e, this.model = new $n(this.device, {
                id: t.id || "buffer-transform-model",
                fs: t.fs || R3(),
                topology: t.topology || "point-list",
                varyings: t.outputs || t.varyings,
                ...t
            }), this.transformFeedback = this.device.createTransformFeedback({
                layout: this.model.pipeline.shaderLayout,
                buffers: t.feedbackBuffers
            }), this.model.setTransformFeedback(this.transformFeedback), Object.seal(this);
        }
        destroy() {
            this.model && this.model.destroy();
        }
        delete() {
            this.destroy();
        }
        run(e) {
            e?.inputBuffers && this.model.setAttributes(e.inputBuffers), e?.outputBuffers && this.transformFeedback.setBuffers(e.outputBuffers);
            const t = this.device.beginRenderPass(e);
            this.model.draw(t), t.end();
        }
        getBuffer(e) {
            return this.transformFeedback.getBuffer(e);
        }
        readAsync(e) {
            const t = this.getBuffer(e);
            if (!t) throw new Error("BufferTransform#getBuffer");
            if (t instanceof Ge) return t.readAsync();
            const { buffer: i, byteOffset: r = 0, byteLength: a = i.byteLength } = t;
            return i.readAsync(r, a);
        }
    }
    const g4 = "transform_output";
    class D0 {
        device;
        model;
        sampler;
        currentIndex = 0;
        samplerTextureMap = null;
        bindings = [];
        resources = {};
        constructor(e, t){
            this.device = e, this.sampler = e.createSampler({
                addressModeU: "clamp-to-edge",
                addressModeV: "clamp-to-edge",
                minFilter: "nearest",
                magFilter: "nearest",
                mipmapFilter: "nearest"
            }), this.model = new $n(this.device, {
                id: t.id || "texture-transform-model",
                fs: t.fs || R3({
                    input: t.targetTextureVarying,
                    inputChannels: t.targetTextureChannels,
                    output: g4
                }),
                vertexCount: t.vertexCount,
                ...t
            }), this._initialize(t), Object.seal(this);
        }
        destroy() {
            this.model.destroy();
            for (const e of this.bindings)e.framebuffer?.destroy();
        }
        delete() {
            this.destroy();
        }
        run(e) {
            const { framebuffer: t } = this.bindings[this.currentIndex], i = this.device.beginRenderPass({
                framebuffer: t,
                ...e
            });
            this.model.draw(i), i.end();
        }
        getTargetTexture() {
            const { targetTexture: e } = this.bindings[this.currentIndex];
            return e;
        }
        getFramebuffer() {
            return this.bindings[this.currentIndex].framebuffer;
        }
        _initialize(e) {
            this._updateBindings(e);
        }
        _updateBindings(e) {
            this.bindings[this.currentIndex] = this._updateBinding(this.bindings[this.currentIndex], e);
        }
        _updateBinding(e, { sourceBuffers: t, sourceTextures: i, targetTexture: r }) {
            if (e || (e = {
                sourceBuffers: {},
                sourceTextures: {},
                targetTexture: null
            }), Object.assign(e.sourceTextures, i), Object.assign(e.sourceBuffers, t), r) {
                e.targetTexture = r;
                const { width: a, height: l } = r;
                e.framebuffer && e.framebuffer.destroy(), e.framebuffer = this.device.createFramebuffer({
                    id: "transform-framebuffer",
                    width: a,
                    height: l,
                    colorAttachments: [
                        r
                    ]
                }), e.framebuffer.resize({
                    width: a,
                    height: l
                });
            }
            return e;
        }
        _setSourceTextureParameters() {
            const e = this.currentIndex, { sourceTextures: t } = this.bindings[e];
            for(const i in t)t[i].sampler = this.sampler;
        }
    }
    class WT {
        id;
        topology;
        vertexCount;
        indices;
        attributes;
        userData = {};
        constructor(e){
            const { attributes: t = {}, indices: i = null, vertexCount: r = null } = e;
            this.id = e.id || ru("geometry"), this.topology = e.topology, i && (this.indices = ArrayBuffer.isView(i) ? {
                value: i,
                size: 1
            } : i), this.attributes = {};
            for (const [a, l] of Object.entries(t)){
                const u = ArrayBuffer.isView(l) ? {
                    value: l
                } : l;
                if (!ArrayBuffer.isView(u.value)) throw new Error(`${this._print(a)}: must be typed array or object with value as typed array`);
                if ((a === "POSITION" || a === "positions") && !u.size && (u.size = 3), a === "indices") {
                    if (this.indices) throw new Error("Multiple indices detected");
                    this.indices = u;
                } else this.attributes[a] = u;
            }
            this.indices && this.indices.isIndexed !== void 0 && (this.indices = Object.assign({}, this.indices), delete this.indices.isIndexed), this.vertexCount = r || this._calculateVertexCount(this.attributes, this.indices);
        }
        getVertexCount() {
            return this.vertexCount;
        }
        getAttributes() {
            return this.indices ? {
                indices: this.indices,
                ...this.attributes
            } : this.attributes;
        }
        _print(e) {
            return `Geometry ${this.id} attribute ${e}`;
        }
        _setAttributes(e, t) {
            return this;
        }
        _calculateVertexCount(e, t) {
            if (t) return t.value.length;
            let i = 1 / 0;
            for (const r of Object.values(e)){
                const { value: a, size: l, constant: u } = r;
                !u && a && l !== void 0 && l >= 1 && (i = Math.min(i, a.length / l));
            }
            return i;
        }
    }
    const p4 = {
        blendColorOperation: "add",
        blendColorSrcFactor: "one",
        blendColorDstFactor: "zero",
        blendAlphaOperation: "add",
        blendAlphaSrcFactor: "constant-alpha",
        blendAlphaDstFactor: "zero"
    };
    class $T extends Ig {
        constructor(){
            super(...arguments), this._colorEncoderState = null;
        }
        render(e) {
            return "pickingFBO" in e ? this._drawPickingBuffer(e) : super.render(e);
        }
        _drawPickingBuffer({ layers: e, layerFilter: t, views: i, viewports: r, onViewportActive: a, pickingFBO: l, deviceRect: { x: u, y: h, width: d, height: p }, cullRect: _, effects: y, pass: v = "picking", pickZ: S, shaderModuleProps: E }) {
            this.pickZ = S;
            const M = this._resetColorEncoder(S), B = [
                u,
                h,
                d,
                p
            ], H = super.render({
                target: l,
                layers: e,
                layerFilter: t,
                views: i,
                viewports: r,
                onViewportActive: a,
                cullRect: _,
                effects: y?.filter((U)=>U.useInPicking),
                pass: v,
                isPicking: !0,
                shaderModuleProps: E,
                clearColor: [
                    0,
                    0,
                    0,
                    0
                ],
                colorMask: 15,
                scissorRect: B
            });
            return this._colorEncoderState = null, {
                decodePickingColor: M && _4.bind(null, M),
                stats: H
            };
        }
        shouldDrawLayer(e) {
            const { pickable: t, operation: i } = e.props;
            return t && i.includes("draw") || i.includes("terrain") || i.includes("mask");
        }
        getShaderModuleProps(e, t, i) {
            return {
                picking: {
                    isActive: 1,
                    isAttribute: this.pickZ
                },
                lighting: {
                    enabled: !1
                }
            };
        }
        getLayerParameters(e, t, i) {
            const r = {
                ...e.props.parameters
            }, { pickable: a, operation: l } = e.props;
            return !this._colorEncoderState || l.includes("terrain") ? r.blend = !1 : a && l.includes("draw") && (Object.assign(r, p4), r.blend = !0, r.blendColor = m4(this._colorEncoderState, e, i)), r;
        }
        _resetColorEncoder(e) {
            return this._colorEncoderState = e ? null : {
                byLayer: new Map,
                byAlpha: []
            }, this._colorEncoderState;
        }
    }
    function m4(n, e, t) {
        const { byLayer: i, byAlpha: r } = n;
        let a, l = i.get(e);
        return l ? (l.viewports.push(t), a = l.a) : (a = i.size + 1, a <= 255 ? (l = {
            a,
            layer: e,
            viewports: [
                t
            ]
        }, i.set(e, l), r[a] = l) : (Fe.warn("Too many pickable layers, only picking the first 255")(), a = 0)), [
            0,
            0,
            0,
            a / 255
        ];
    }
    function _4(n, e) {
        const t = n.byAlpha[e[3]];
        return t && {
            pickedLayer: t.layer,
            pickedViewports: t.viewports,
            pickedObjectIndex: t.layer.decodePickingColor(e)
        };
    }
    const Ns = {
        NO_STATE: "Awaiting state",
        MATCHED: "Matched. State transferred from previous layer",
        INITIALIZED: "Initialized",
        AWAITING_GC: "Discarded. Awaiting garbage collection",
        AWAITING_FINALIZATION: "No longer matched. Awaiting garbage collection",
        FINALIZED: "Finalized! Awaiting garbage collection"
    }, Lc = Symbol.for("component"), Zi = Symbol.for("propTypes"), rd = Symbol.for("deprecatedProps"), Hs = Symbol.for("asyncPropDefaults"), Nr = Symbol.for("asyncPropOriginal"), Yi = Symbol.for("asyncPropResolved");
    function Ug(n, e = ()=>!0) {
        return Array.isArray(n) ? XT(n, e, []) : e(n) ? [
            n
        ] : [];
    }
    function XT(n, e, t) {
        let i = -1;
        for(; ++i < n.length;){
            const r = n[i];
            Array.isArray(r) ? XT(r, e, t) : e(r) && t.push(r);
        }
        return t;
    }
    function y4({ target: n, source: e, start: t = 0, count: i = 1 }) {
        const r = e.length, a = i * r;
        let l = 0;
        for(let u = t; l < r; l++)n[u++] = e[l];
        for(; l < a;)l < a - l ? (n.copyWithin(t + l, t, t + l), l *= 2) : (n.copyWithin(t + l, t, t + a - l), l = a);
        return n;
    }
    class b4 {
        constructor(e, t, i){
            this._loadCount = 0, this._subscribers = new Set, this.id = e, this.context = i, this.setData(t);
        }
        subscribe(e) {
            this._subscribers.add(e);
        }
        unsubscribe(e) {
            this._subscribers.delete(e);
        }
        inUse() {
            return this._subscribers.size > 0;
        }
        delete() {}
        getData() {
            return this.isLoaded ? this._error ? Promise.reject(this._error) : this._content : this._loader.then(()=>this.getData());
        }
        setData(e, t) {
            if (e === this._data && !t) return;
            this._data = e;
            const i = ++this._loadCount;
            let r = e;
            typeof e == "string" && (r = bd(e)), r instanceof Promise ? (this.isLoaded = !1, this._loader = r.then((a)=>{
                this._loadCount === i && (this.isLoaded = !0, this._error = void 0, this._content = a);
            }).catch((a)=>{
                this._loadCount === i && (this.isLoaded = !0, this._error = a || !0);
            })) : (this.isLoaded = !0, this._error = void 0, this._content = e);
            for (const a of this._subscribers)a.onChange(this.getData());
        }
    }
    class v4 {
        constructor(e){
            this.protocol = e.protocol || "resource://", this._context = {
                device: e.device,
                gl: e.device?.gl,
                resourceManager: this
            }, this._resources = {}, this._consumers = {}, this._pruneRequest = null;
        }
        contains(e) {
            return e.startsWith(this.protocol) ? !0 : e in this._resources;
        }
        add({ resourceId: e, data: t, forceUpdate: i = !1, persistent: r = !0 }) {
            let a = this._resources[e];
            a ? a.setData(t, i) : (a = new b4(e, t, this._context), this._resources[e] = a), a.persistent = r;
        }
        remove(e) {
            const t = this._resources[e];
            t && (t.delete(), delete this._resources[e]);
        }
        unsubscribe({ consumerId: e }) {
            const t = this._consumers[e];
            if (t) {
                for(const i in t){
                    const r = t[i], a = this._resources[r.resourceId];
                    a && a.unsubscribe(r);
                }
                delete this._consumers[e], this.prune();
            }
        }
        subscribe({ resourceId: e, onChange: t, consumerId: i, requestId: r = "default" }) {
            const { _resources: a, protocol: l } = this;
            e.startsWith(l) && (e = e.replace(l, ""), a[e] || this.add({
                resourceId: e,
                data: null,
                persistent: !1
            }));
            const u = a[e];
            if (this._track(i, r, u, t), u) return u.getData();
        }
        prune() {
            this._pruneRequest || (this._pruneRequest = setTimeout(()=>this._prune(), 0));
        }
        finalize() {
            for(const e in this._resources)this._resources[e].delete();
        }
        _track(e, t, i, r) {
            const a = this._consumers, l = a[e] = a[e] || {};
            let u = l[t];
            const h = u && u.resourceId && this._resources[u.resourceId];
            h && (h.unsubscribe(u), this.prune()), i && (u ? (u.onChange = r, u.resourceId = i.id) : u = {
                onChange: r,
                resourceId: i.id
            }, l[t] = u, i.subscribe(u));
        }
        _prune() {
            this._pruneRequest = null;
            for (const e of Object.keys(this._resources)){
                const t = this._resources[e];
                !t.persistent && !t.inUse() && (t.delete(), delete this._resources[e]);
            }
        }
    }
    const T4 = "layerManager.setLayers", x4 = "layerManager.activateViewport";
    class S4 {
        constructor(e, t){
            this._lastRenderedLayers = [], this._needsRedraw = !1, this._needsUpdate = !1, this._nextLayers = null, this._debug = !1, this._defaultShaderModulesChanged = !1, this.activateViewport = (u)=>{
                It(x4, this, u), u && (this.context.viewport = u);
            };
            const { deck: i, stats: r, viewport: a, timeline: l } = t || {};
            this.layers = [], this.resourceManager = new v4({
                device: e,
                protocol: "deck://"
            }), this.context = {
                mousePosition: null,
                userData: {},
                layerManager: this,
                device: e,
                gl: e?.gl,
                deck: i,
                shaderAssembler: yI(e?.info?.shadingLanguage || "glsl"),
                defaultShaderModules: [
                    CM
                ],
                renderPass: void 0,
                stats: r || new Qc({
                    id: "deck.gl"
                }),
                viewport: a || new ta({
                    id: "DEFAULT-INITIAL-VIEWPORT"
                }),
                timeline: l || new zT,
                resourceManager: this.resourceManager,
                onError: void 0
            }, Object.seal(this);
        }
        finalize() {
            this.resourceManager.finalize();
            for (const e of this.layers)this._finalizeLayer(e);
        }
        needsRedraw(e = {
            clearRedrawFlags: !1
        }) {
            let t = this._needsRedraw;
            e.clearRedrawFlags && (this._needsRedraw = !1);
            for (const i of this.layers){
                const r = i.getNeedsRedraw(e);
                t = t || r;
            }
            return t;
        }
        needsUpdate() {
            return this._nextLayers && this._nextLayers !== this._lastRenderedLayers ? "layers changed" : this._defaultShaderModulesChanged ? "shader modules changed" : this._needsUpdate;
        }
        setNeedsRedraw(e) {
            this._needsRedraw = this._needsRedraw || e;
        }
        setNeedsUpdate(e) {
            this._needsUpdate = this._needsUpdate || e;
        }
        getLayers({ layerIds: e } = {}) {
            return e ? this.layers.filter((t)=>e.find((i)=>t.id.indexOf(i) === 0)) : this.layers;
        }
        setProps(e) {
            "debug" in e && (this._debug = e.debug), "userData" in e && (this.context.userData = e.userData), "layers" in e && (this._nextLayers = e.layers), "onError" in e && (this.context.onError = e.onError);
        }
        setLayers(e, t) {
            It(T4, this, t, e), this._lastRenderedLayers = e;
            const i = Ug(e, Boolean);
            for (const r of i)r.context = this.context;
            this._updateLayers(this.layers, i);
        }
        updateLayers() {
            const e = this.needsUpdate();
            e && (this.setNeedsRedraw(`updating layers: ${e}`), this.setLayers(this._nextLayers || this._lastRenderedLayers, e)), this._nextLayers = null;
        }
        addDefaultShaderModule(e) {
            const { defaultShaderModules: t } = this.context;
            t.find((i)=>i.name === e.name) || (t.push(e), this._defaultShaderModulesChanged = !0);
        }
        removeDefaultShaderModule(e) {
            const { defaultShaderModules: t } = this.context, i = t.findIndex((r)=>r.name === e.name);
            i >= 0 && (t.splice(i, 1), this._defaultShaderModulesChanged = !0);
        }
        _handleError(e, t, i) {
            i.raiseError(t, `${e} of ${i}`);
        }
        _updateLayers(e, t) {
            const i = {};
            for (const l of e)i[l.id] ? Fe.warn(`Multiple old layers with same id ${l.id}`)() : i[l.id] = l;
            if (this._defaultShaderModulesChanged) {
                for (const l of e)l.setNeedsUpdate(), l.setChangeFlags({
                    extensionsChanged: !0
                });
                this._defaultShaderModulesChanged = !1;
            }
            const r = [];
            this._updateSublayersRecursively(t, i, r), this._finalizeOldLayers(i);
            let a = !1;
            for (const l of r)if (l.hasUniformTransition()) {
                a = `Uniform transition in ${l}`;
                break;
            }
            this._needsUpdate = a, this.layers = r;
        }
        _updateSublayersRecursively(e, t, i) {
            for (const r of e){
                r.context = this.context;
                const a = t[r.id];
                a === null && Fe.warn(`Multiple new layers with same id ${r.id}`)(), t[r.id] = null;
                let l = null;
                try {
                    this._debug && a !== r && r.validateProps(), a ? (this._transferLayerState(a, r), this._updateLayer(r)) : this._initializeLayer(r), i.push(r), l = r.isComposite ? r.getSubLayers() : null;
                } catch (u) {
                    this._handleError("matching", u, r);
                }
                l && this._updateSublayersRecursively(l, t, i);
            }
        }
        _finalizeOldLayers(e) {
            for(const t in e){
                const i = e[t];
                i && this._finalizeLayer(i);
            }
        }
        _initializeLayer(e) {
            try {
                e._initialize(), e.lifecycle = Ns.INITIALIZED;
            } catch (t) {
                this._handleError("initialization", t, e);
            }
        }
        _transferLayerState(e, t) {
            t._transferState(e), t.lifecycle = Ns.MATCHED, t !== e && (e.lifecycle = Ns.AWAITING_GC);
        }
        _updateLayer(e) {
            try {
                e._update();
            } catch (t) {
                this._handleError("update", t, e);
            }
        }
        _finalizeLayer(e) {
            this._needsRedraw = this._needsRedraw || `finalized ${e}`, e.lifecycle = Ns.AWAITING_FINALIZATION;
            try {
                e._finalize(), e.lifecycle = Ns.FINALIZED;
            } catch (t) {
                this._handleError("finalization", t, e);
            }
        }
    }
    function Ht(n, e, t) {
        if (n === e) return !0;
        if (!t || !n || !e) return !1;
        if (Array.isArray(n)) {
            if (!Array.isArray(e) || n.length !== e.length) return !1;
            for(let i = 0; i < n.length; i++)if (!Ht(n[i], e[i], t - 1)) return !1;
            return !0;
        }
        if (Array.isArray(e)) return !1;
        if (typeof n == "object" && typeof e == "object") {
            const i = Object.keys(n), r = Object.keys(e);
            if (i.length !== r.length) return !1;
            for (const a of i)if (!e.hasOwnProperty(a) || !Ht(n[a], e[a], t - 1)) return !1;
            return !0;
        }
        return !1;
    }
    class A4 {
        constructor(e){
            this.views = [], this.width = 100, this.height = 100, this.viewState = {}, this.controllers = {}, this.timeline = e.timeline, this._viewports = [], this._viewportMap = {}, this._isUpdating = !1, this._needsRedraw = "First render", this._needsUpdate = "Initialize", this._eventManager = e.eventManager, this._eventCallbacks = {
                onViewStateChange: e.onViewStateChange,
                onInteractionStateChange: e.onInteractionStateChange
            }, Object.seal(this), this.setProps(e);
        }
        finalize() {
            for(const e in this.controllers){
                const t = this.controllers[e];
                t && t.finalize();
            }
            this.controllers = {};
        }
        needsRedraw(e = {
            clearRedrawFlags: !1
        }) {
            const t = this._needsRedraw;
            return e.clearRedrawFlags && (this._needsRedraw = !1), t;
        }
        setNeedsUpdate(e) {
            this._needsUpdate = this._needsUpdate || e, this._needsRedraw = this._needsRedraw || e;
        }
        updateViewStates() {
            for(const e in this.controllers){
                const t = this.controllers[e];
                t && t.updateTransition();
            }
        }
        getViewports(e) {
            return e ? this._viewports.filter((t)=>t.containsPixel(e)) : this._viewports;
        }
        getViews() {
            const e = {};
            return this.views.forEach((t)=>{
                e[t.id] = t;
            }), e;
        }
        getView(e) {
            return this.views.find((t)=>t.id === e);
        }
        getViewState(e) {
            const t = typeof e == "string" ? this.getView(e) : e, i = t && this.viewState[t.getViewStateId()] || this.viewState;
            return t ? t.filterViewState(i) : i;
        }
        getViewport(e) {
            return this._viewportMap[e];
        }
        unproject(e, t) {
            const i = this.getViewports(), r = {
                x: e[0],
                y: e[1]
            };
            for(let a = i.length - 1; a >= 0; --a){
                const l = i[a];
                if (l.containsPixel(r)) {
                    const u = e.slice();
                    return u[0] -= l.x, u[1] -= l.y, l.unproject(u, t);
                }
            }
            return null;
        }
        setProps(e) {
            e.views && this._setViews(e.views), e.viewState && this._setViewState(e.viewState), ("width" in e || "height" in e) && this._setSize(e.width, e.height), this._isUpdating || this._update();
        }
        _update() {
            this._isUpdating = !0, this._needsUpdate && (this._needsUpdate = !1, this._rebuildViewports()), this._needsUpdate && (this._needsUpdate = !1, this._rebuildViewports()), this._isUpdating = !1;
        }
        _setSize(e, t) {
            (e !== this.width || t !== this.height) && (this.width = e, this.height = t, this.setNeedsUpdate("Size changed"));
        }
        _setViews(e) {
            e = Ug(e, Boolean), this._diffViews(e, this.views) && this.setNeedsUpdate("views changed"), this.views = e;
        }
        _setViewState(e) {
            e ? (!Ht(e, this.viewState, 3) && this.setNeedsUpdate("viewState changed"), this.viewState = e) : Fe.warn("missing `viewState` or `initialViewState`")();
        }
        _createController(e, t) {
            const i = t.type;
            return new i({
                timeline: this.timeline,
                eventManager: this._eventManager,
                onViewStateChange: this._eventCallbacks.onViewStateChange,
                onStateChange: this._eventCallbacks.onInteractionStateChange,
                makeViewport: (a)=>this.getView(e.id)?.makeViewport({
                        viewState: a,
                        width: this.width,
                        height: this.height
                    })
            });
        }
        _updateController(e, t, i, r) {
            const a = e.controller;
            if (a && i) {
                const l = {
                    ...t,
                    ...a,
                    id: e.id,
                    x: i.x,
                    y: i.y,
                    width: i.width,
                    height: i.height
                };
                return (!r || r.constructor !== a.type) && (r = this._createController(e, l)), r && r.setProps(l), r;
            }
            return null;
        }
        _rebuildViewports() {
            const { views: e } = this, t = this.controllers;
            this._viewports = [], this.controllers = {};
            let i = !1;
            for(let r = e.length; r--;){
                const a = e[r], l = this.getViewState(a), u = a.makeViewport({
                    viewState: l,
                    width: this.width,
                    height: this.height
                });
                let h = t[a.id];
                const d = !!a.controller;
                d && !h && (i = !0), (i || !d) && h && (h.finalize(), h = null), this.controllers[a.id] = this._updateController(a, l, u, h), u && this._viewports.unshift(u);
            }
            for(const r in t){
                const a = t[r];
                a && !this.controllers[r] && a.finalize();
            }
            this._buildViewportMap();
        }
        _buildViewportMap() {
            this._viewportMap = {}, this._viewports.forEach((e)=>{
                e.id && (this._viewportMap[e.id] = this._viewportMap[e.id] || e);
            });
        }
        _diffViews(e, t) {
            return e.length !== t.length ? !0 : e.some((i, r)=>!e[r].equals(t[r]));
        }
    }
    const w4 = /([0-9]+\.?[0-9]*)(%|px)/;
    function Fi(n) {
        switch(typeof n){
            case "number":
                return {
                    position: n,
                    relative: !1
                };
            case "string":
                const e = w4.exec(n);
                if (e && e.length >= 3) {
                    const t = e[2] === "%", i = parseFloat(e[1]);
                    return {
                        position: t ? i / 100 : i,
                        relative: t
                    };
                }
            default:
                throw new Error(`Could not parse position string ${n}`);
        }
    }
    function zi(n, e) {
        return n.relative ? Math.round(n.position * e) : n.position;
    }
    class Gs {
        constructor(e){
            const { id: t, x: i = 0, y: r = 0, width: a = "100%", height: l = "100%", padding: u = null } = e;
            this.id = t || this.constructor.displayName || "view", this.props = {
                ...e,
                id: this.id
            }, this._x = Fi(i), this._y = Fi(r), this._width = Fi(a), this._height = Fi(l), this._padding = u && {
                left: Fi(u.left || 0),
                right: Fi(u.right || 0),
                top: Fi(u.top || 0),
                bottom: Fi(u.bottom || 0)
            }, this.equals = this.equals.bind(this), Object.seal(this);
        }
        equals(e) {
            return this === e ? !0 : this.constructor === e.constructor && Ht(this.props, e.props, 2);
        }
        makeViewport({ width: e, height: t, viewState: i }) {
            i = this.filterViewState(i);
            const r = this.getDimensions({
                width: e,
                height: t
            });
            if (!r.height || !r.width) return null;
            const a = this.getViewportType(i);
            return new a({
                ...i,
                ...this.props,
                ...r
            });
        }
        getViewStateId() {
            const { viewState: e } = this.props;
            return typeof e == "string" ? e : e?.id || this.id;
        }
        filterViewState(e) {
            if (this.props.viewState && typeof this.props.viewState == "object") {
                if (!this.props.viewState.id) return this.props.viewState;
                const t = {
                    ...e
                };
                for(const i in this.props.viewState)i !== "id" && (t[i] = this.props.viewState[i]);
                return t;
            }
            return e;
        }
        getDimensions({ width: e, height: t }) {
            const i = {
                x: zi(this._x, e),
                y: zi(this._y, t),
                width: zi(this._width, e),
                height: zi(this._height, t)
            };
            return this._padding && (i.padding = {
                left: zi(this._padding.left, e),
                top: zi(this._padding.top, t),
                right: zi(this._padding.right, e),
                bottom: zi(this._padding.bottom, t)
            }), i;
        }
        get controller() {
            const e = this.props.controller;
            return e ? e === !0 ? {
                type: this.ControllerType
            } : typeof e == "function" ? {
                type: e
            } : {
                type: this.ControllerType,
                ...e
            } : null;
        }
    }
    class su {
        constructor(e){
            this._inProgress = !1, this._handle = null, this.time = 0, this.settings = {
                duration: 0
            }, this._timeline = e;
        }
        get inProgress() {
            return this._inProgress;
        }
        start(e) {
            this.cancel(), this.settings = e, this._inProgress = !0, this.settings.onStart?.(this);
        }
        end() {
            this._inProgress && (this._timeline.removeChannel(this._handle), this._handle = null, this._inProgress = !1, this.settings.onEnd?.(this));
        }
        cancel() {
            this._inProgress && (this.settings.onInterrupt?.(this), this._timeline.removeChannel(this._handle), this._handle = null, this._inProgress = !1);
        }
        update() {
            if (!this._inProgress) return !1;
            if (this._handle === null) {
                const { _timeline: e, settings: t } = this;
                this._handle = e.addChannel({
                    delay: e.getTime(),
                    duration: t.duration
                });
            }
            return this.time = this._timeline.getTime(this._handle), this._onUpdate(), this.settings.onUpdate?.(this), this._timeline.isFinished(this._handle) && this.end(), !0;
        }
        _onUpdate() {}
    }
    const k0 = ()=>{}, Vd = {
        BREAK: 1,
        SNAP_TO_END: 2,
        IGNORE: 3
    }, E4 = (n)=>n, R4 = Vd.BREAK;
    class C4 {
        constructor(e){
            this._onTransitionUpdate = (t)=>{
                const { time: i, settings: { interpolator: r, startProps: a, endProps: l, duration: u, easing: h } } = t, d = h(i / u), p = r.interpolateProps(a, l, d);
                this.propsInTransition = this.getControllerState({
                    ...this.props,
                    ...p
                }).getViewportProps(), this.onViewStateChange({
                    viewState: this.propsInTransition,
                    oldViewState: this.props
                });
            }, this.getControllerState = e.getControllerState, this.propsInTransition = null, this.transition = new su(e.timeline), this.onViewStateChange = e.onViewStateChange || k0, this.onStateChange = e.onStateChange || k0;
        }
        finalize() {
            this.transition.cancel();
        }
        getViewportInTransition() {
            return this.propsInTransition;
        }
        processViewStateChange(e) {
            let t = !1;
            const i = this.props;
            if (this.props = e, !i || this._shouldIgnoreViewportChange(i, e)) return !1;
            if (this._isTransitionEnabled(e)) {
                let r = i;
                if (this.transition.inProgress) {
                    const { interruption: a, endProps: l } = this.transition.settings;
                    r = {
                        ...i,
                        ...a === Vd.SNAP_TO_END ? l : this.propsInTransition || i
                    };
                }
                this._triggerTransition(r, e), t = !0;
            } else this.transition.cancel();
            return t;
        }
        updateTransition() {
            this.transition.update();
        }
        _isTransitionEnabled(e) {
            const { transitionDuration: t, transitionInterpolator: i } = e;
            return (t > 0 || t === "auto") && !!i;
        }
        _isUpdateDueToCurrentTransition(e) {
            return this.transition.inProgress && this.propsInTransition ? this.transition.settings.interpolator.arePropsEqual(e, this.propsInTransition) : !1;
        }
        _shouldIgnoreViewportChange(e, t) {
            return this.transition.inProgress ? this.transition.settings.interruption === Vd.IGNORE || this._isUpdateDueToCurrentTransition(t) : this._isTransitionEnabled(t) ? t.transitionInterpolator.arePropsEqual(e, t) : !0;
        }
        _triggerTransition(e, t) {
            const i = this.getControllerState(e), r = this.getControllerState(t).shortestPathFrom(i), a = t.transitionInterpolator, l = a.getDuration ? a.getDuration(e, t) : t.transitionDuration;
            if (l === 0) return;
            const u = a.initializeProps(e, r);
            this.propsInTransition = {};
            const h = {
                duration: l,
                easing: t.transitionEasing || E4,
                interpolator: a,
                interruption: t.transitionInterruption || R4,
                startProps: u.start,
                endProps: u.end,
                onStart: t.onTransitionStart,
                onUpdate: this._onTransitionUpdate,
                onInterrupt: this._onTransitionEnd(t.onTransitionInterrupt),
                onEnd: this._onTransitionEnd(t.onTransitionEnd)
            };
            this.transition.start(h), this.onStateChange({
                inTransition: !0
            }), this.updateTransition();
        }
        _onTransitionEnd(e) {
            return (t)=>{
                this.propsInTransition = null, this.onStateChange({
                    inTransition: !1,
                    isZooming: !1,
                    isPanning: !1,
                    isRotating: !1
                }), e?.(t);
            };
        }
    }
    function Nt(n, e) {
        if (!n) throw new Error(e || "deck.gl: assertion failed.");
    }
    class M4 {
        constructor(e){
            const { compare: t, extract: i, required: r } = e;
            this._propsToCompare = t, this._propsToExtract = i || t, this._requiredProps = r;
        }
        arePropsEqual(e, t) {
            for (const i of this._propsToCompare)if (!(i in e) || !(i in t) || !xo(e[i], t[i])) return !1;
            return !0;
        }
        initializeProps(e, t) {
            const i = {}, r = {};
            for (const a of this._propsToExtract)(a in e || a in t) && (i[a] = e[a], r[a] = t[a]);
            return this._checkRequiredProps(i), this._checkRequiredProps(r), {
                start: i,
                end: r
            };
        }
        getDuration(e, t) {
            return t.transitionDuration;
        }
        _checkRequiredProps(e) {
            this._requiredProps && this._requiredProps.forEach((t)=>{
                const i = e[t];
                Nt(Number.isFinite(i) || Array.isArray(i), `${t} is required for transition`);
            });
        }
    }
    const O4 = [
        "longitude",
        "latitude",
        "zoom",
        "bearing",
        "pitch"
    ], I4 = [
        "longitude",
        "latitude",
        "zoom"
    ];
    class YT extends M4 {
        constructor(e = {}){
            const t = Array.isArray(e) ? e : e.transitionProps, i = Array.isArray(e) ? {} : e;
            i.transitionProps = Array.isArray(t) ? {
                compare: t,
                required: t
            } : t || {
                compare: O4,
                required: I4
            }, super(i.transitionProps), this.opts = i;
        }
        initializeProps(e, t) {
            const i = super.initializeProps(e, t), { makeViewport: r, around: a } = this.opts;
            if (r && a) {
                const l = r(e), u = r(t), h = l.unproject(a);
                i.start.around = a, Object.assign(i.end, {
                    around: u.project(h),
                    aroundPosition: h,
                    width: t.width,
                    height: t.height
                });
            }
            return i;
        }
        interpolateProps(e, t, i) {
            const r = {};
            for (const a of this._propsToExtract)r[a] = Nc(e[a] || 0, t[a] || 0, i);
            if (t.aroundPosition && this.opts.makeViewport) {
                const a = this.opts.makeViewport({
                    ...t,
                    ...r
                });
                Object.assign(r, a.panByPosition(t.aroundPosition, Nc(e.around, t.around, i)));
            }
            return r;
        }
    }
    const Vi = {
        transitionDuration: 0
    }, N4 = 300, sc = (n)=>1 - (1 - n) * (1 - n), Os = {
        WHEEL: [
            "wheel"
        ],
        PAN: [
            "panstart",
            "panmove",
            "panend"
        ],
        PINCH: [
            "pinchstart",
            "pinchmove",
            "pinchend"
        ],
        MULTI_PAN: [
            "multipanstart",
            "multipanmove",
            "multipanend"
        ],
        DOUBLE_CLICK: [
            "dblclick"
        ],
        KEYBOARD: [
            "keydown"
        ]
    }, br = {};
    class P4 {
        constructor(e){
            this.state = {}, this._events = {}, this._interactionState = {
                isDragging: !1
            }, this._customEvents = [], this._eventStartBlocked = null, this._panMove = !1, this.invertPan = !1, this.dragMode = "rotate", this.inertia = 0, this.scrollZoom = !0, this.dragPan = !0, this.dragRotate = !0, this.doubleClickZoom = !0, this.touchZoom = !0, this.touchRotate = !1, this.keyboard = !0, this.transitionManager = new C4({
                ...e,
                getControllerState: (t)=>new this.ControllerState(t),
                onViewStateChange: this._onTransition.bind(this),
                onStateChange: this._setInteractionState.bind(this)
            }), this.handleEvent = this.handleEvent.bind(this), this.eventManager = e.eventManager, this.onViewStateChange = e.onViewStateChange || (()=>{}), this.onStateChange = e.onStateChange || (()=>{}), this.makeViewport = e.makeViewport;
        }
        set events(e) {
            this.toggleEvents(this._customEvents, !1), this.toggleEvents(e, !0), this._customEvents = e, this.props && this.setProps(this.props);
        }
        finalize() {
            for(const e in this._events)this._events[e] && this.eventManager?.off(e, this.handleEvent);
            this.transitionManager.finalize();
        }
        handleEvent(e) {
            this._controllerState = void 0;
            const t = this._eventStartBlocked;
            switch(e.type){
                case "panstart":
                    return t ? !1 : this._onPanStart(e);
                case "panmove":
                    return this._onPan(e);
                case "panend":
                    return this._onPanEnd(e);
                case "pinchstart":
                    return t ? !1 : this._onPinchStart(e);
                case "pinchmove":
                    return this._onPinch(e);
                case "pinchend":
                    return this._onPinchEnd(e);
                case "multipanstart":
                    return t ? !1 : this._onMultiPanStart(e);
                case "multipanmove":
                    return this._onMultiPan(e);
                case "multipanend":
                    return this._onMultiPanEnd(e);
                case "dblclick":
                    return this._onDoubleClick(e);
                case "wheel":
                    return this._onWheel(e);
                case "keydown":
                    return this._onKeyDown(e);
                default:
                    return !1;
            }
        }
        get controllerState() {
            return this._controllerState = this._controllerState || new this.ControllerState({
                makeViewport: this.makeViewport,
                ...this.props,
                ...this.state
            }), this._controllerState;
        }
        getCenter(e) {
            const { x: t, y: i } = this.props, { offsetCenter: r } = e;
            return [
                r.x - t,
                r.y - i
            ];
        }
        isPointInBounds(e, t) {
            const { width: i, height: r } = this.props;
            if (t && t.handled) return !1;
            const a = e[0] >= 0 && e[0] <= i && e[1] >= 0 && e[1] <= r;
            return a && t && t.stopPropagation(), a;
        }
        isFunctionKeyPressed(e) {
            const { srcEvent: t } = e;
            return !!(t.metaKey || t.altKey || t.ctrlKey || t.shiftKey);
        }
        isDragging() {
            return this._interactionState.isDragging || !1;
        }
        blockEvents(e) {
            const t = setTimeout(()=>{
                this._eventStartBlocked === t && (this._eventStartBlocked = null);
            }, e);
            this._eventStartBlocked = t;
        }
        setProps(e) {
            e.dragMode && (this.dragMode = e.dragMode), this.props = e, "transitionInterpolator" in e || (e.transitionInterpolator = this._getTransitionProps().transitionInterpolator), this.transitionManager.processViewStateChange(e);
            const { inertia: t } = e;
            this.inertia = Number.isFinite(t) ? t : t === !0 ? N4 : 0;
            const { scrollZoom: i = !0, dragPan: r = !0, dragRotate: a = !0, doubleClickZoom: l = !0, touchZoom: u = !0, touchRotate: h = !1, keyboard: d = !0 } = e, p = !!this.onViewStateChange;
            this.toggleEvents(Os.WHEEL, p && i), this.toggleEvents(Os.PAN, p), this.toggleEvents(Os.PINCH, p && (u || h)), this.toggleEvents(Os.MULTI_PAN, p && h), this.toggleEvents(Os.DOUBLE_CLICK, p && l), this.toggleEvents(Os.KEYBOARD, p && d), this.scrollZoom = i, this.dragPan = r, this.dragRotate = a, this.doubleClickZoom = l, this.touchZoom = u, this.touchRotate = h, this.keyboard = d;
        }
        updateTransition() {
            this.transitionManager.updateTransition();
        }
        toggleEvents(e, t) {
            this.eventManager && e.forEach((i)=>{
                this._events[i] !== t && (this._events[i] = t, t ? this.eventManager.on(i, this.handleEvent) : this.eventManager.off(i, this.handleEvent));
            });
        }
        updateViewport(e, t = null, i = {}) {
            const r = {
                ...e.getViewportProps(),
                ...t
            }, a = this.controllerState !== e;
            if (this.state = e.getState(), this._setInteractionState(i), a) {
                const l = this.controllerState && this.controllerState.getViewportProps();
                this.onViewStateChange && this.onViewStateChange({
                    viewState: r,
                    interactionState: this._interactionState,
                    oldViewState: l,
                    viewId: this.props.id
                });
            }
        }
        _onTransition(e) {
            this.onViewStateChange({
                ...e,
                interactionState: this._interactionState,
                viewId: this.props.id
            });
        }
        _setInteractionState(e) {
            Object.assign(this._interactionState, e), this.onStateChange(this._interactionState);
        }
        _onPanStart(e) {
            const t = this.getCenter(e);
            if (!this.isPointInBounds(t, e)) return !1;
            let i = this.isFunctionKeyPressed(e) || e.rightButton || !1;
            (this.invertPan || this.dragMode === "pan") && (i = !i);
            const r = this.controllerState[i ? "panStart" : "rotateStart"]({
                pos: t
            });
            return this._panMove = i, this.updateViewport(r, Vi, {
                isDragging: !0
            }), !0;
        }
        _onPan(e) {
            return this.isDragging() ? this._panMove ? this._onPanMove(e) : this._onPanRotate(e) : !1;
        }
        _onPanEnd(e) {
            return this.isDragging() ? this._panMove ? this._onPanMoveEnd(e) : this._onPanRotateEnd(e) : !1;
        }
        _onPanMove(e) {
            if (!this.dragPan) return !1;
            const t = this.getCenter(e), i = this.controllerState.pan({
                pos: t
            });
            return this.updateViewport(i, Vi, {
                isDragging: !0,
                isPanning: !0
            }), !0;
        }
        _onPanMoveEnd(e) {
            const { inertia: t } = this;
            if (this.dragPan && t && e.velocity) {
                const i = this.getCenter(e), r = [
                    i[0] + e.velocityX * t / 2,
                    i[1] + e.velocityY * t / 2
                ], a = this.controllerState.pan({
                    pos: r
                }).panEnd();
                this.updateViewport(a, {
                    ...this._getTransitionProps(),
                    transitionDuration: t,
                    transitionEasing: sc
                }, {
                    isDragging: !1,
                    isPanning: !0
                });
            } else {
                const i = this.controllerState.panEnd();
                this.updateViewport(i, null, {
                    isDragging: !1,
                    isPanning: !1
                });
            }
            return !0;
        }
        _onPanRotate(e) {
            if (!this.dragRotate) return !1;
            const t = this.getCenter(e), i = this.controllerState.rotate({
                pos: t
            });
            return this.updateViewport(i, Vi, {
                isDragging: !0,
                isRotating: !0
            }), !0;
        }
        _onPanRotateEnd(e) {
            const { inertia: t } = this;
            if (this.dragRotate && t && e.velocity) {
                const i = this.getCenter(e), r = [
                    i[0] + e.velocityX * t / 2,
                    i[1] + e.velocityY * t / 2
                ], a = this.controllerState.rotate({
                    pos: r
                }).rotateEnd();
                this.updateViewport(a, {
                    ...this._getTransitionProps(),
                    transitionDuration: t,
                    transitionEasing: sc
                }, {
                    isDragging: !1,
                    isRotating: !0
                });
            } else {
                const i = this.controllerState.rotateEnd();
                this.updateViewport(i, null, {
                    isDragging: !1,
                    isRotating: !1
                });
            }
            return !0;
        }
        _onWheel(e) {
            if (!this.scrollZoom) return !1;
            const t = this.getCenter(e);
            if (!this.isPointInBounds(t, e)) return !1;
            e.srcEvent.preventDefault();
            const { speed: i = .01, smooth: r = !1 } = this.scrollZoom === !0 ? {} : this.scrollZoom, { delta: a } = e;
            let l = 2 / (1 + Math.exp(-Math.abs(a * i)));
            a < 0 && l !== 0 && (l = 1 / l);
            const u = this.controllerState.zoom({
                pos: t,
                scale: l
            });
            return this.updateViewport(u, {
                ...this._getTransitionProps({
                    around: t
                }),
                transitionDuration: r ? 250 : 1
            }, {
                isZooming: !0,
                isPanning: !0
            }), !0;
        }
        _onMultiPanStart(e) {
            const t = this.getCenter(e);
            if (!this.isPointInBounds(t, e)) return !1;
            const i = this.controllerState.rotateStart({
                pos: t
            });
            return this.updateViewport(i, Vi, {
                isDragging: !0
            }), !0;
        }
        _onMultiPan(e) {
            if (!this.touchRotate || !this.isDragging()) return !1;
            const t = this.getCenter(e);
            t[0] -= e.deltaX;
            const i = this.controllerState.rotate({
                pos: t
            });
            return this.updateViewport(i, Vi, {
                isDragging: !0,
                isRotating: !0
            }), !0;
        }
        _onMultiPanEnd(e) {
            if (!this.isDragging()) return !1;
            const { inertia: t } = this;
            if (this.touchRotate && t && e.velocityY) {
                const i = this.getCenter(e), r = [
                    i[0],
                    i[1] += e.velocityY * t / 2
                ], a = this.controllerState.rotate({
                    pos: r
                });
                this.updateViewport(a, {
                    ...this._getTransitionProps(),
                    transitionDuration: t,
                    transitionEasing: sc
                }, {
                    isDragging: !1,
                    isRotating: !0
                }), this.blockEvents(t);
            } else {
                const i = this.controllerState.rotateEnd();
                this.updateViewport(i, null, {
                    isDragging: !1,
                    isRotating: !1
                });
            }
            return !0;
        }
        _onPinchStart(e) {
            const t = this.getCenter(e);
            if (!this.isPointInBounds(t, e)) return !1;
            const i = this.controllerState.zoomStart({
                pos: t
            }).rotateStart({
                pos: t
            });
            return br._startPinchRotation = e.rotation, br._lastPinchEvent = e, this.updateViewport(i, Vi, {
                isDragging: !0
            }), !0;
        }
        _onPinch(e) {
            if (!this.touchZoom && !this.touchRotate || !this.isDragging()) return !1;
            let t = this.controllerState;
            if (this.touchZoom) {
                const { scale: i } = e, r = this.getCenter(e);
                t = t.zoom({
                    pos: r,
                    scale: i
                });
            }
            if (this.touchRotate) {
                const { rotation: i } = e;
                t = t.rotate({
                    deltaAngleX: br._startPinchRotation - i
                });
            }
            return this.updateViewport(t, Vi, {
                isDragging: !0,
                isPanning: this.touchZoom,
                isZooming: this.touchZoom,
                isRotating: this.touchRotate
            }), br._lastPinchEvent = e, !0;
        }
        _onPinchEnd(e) {
            if (!this.isDragging()) return !1;
            const { inertia: t } = this, { _lastPinchEvent: i } = br;
            if (this.touchZoom && t && i && e.scale !== i.scale) {
                const r = this.getCenter(e);
                let a = this.controllerState.rotateEnd();
                const l = Math.log2(e.scale), u = (l - Math.log2(i.scale)) / (e.deltaTime - i.deltaTime), h = Math.pow(2, l + u * t / 2);
                a = a.zoom({
                    pos: r,
                    scale: h
                }).zoomEnd(), this.updateViewport(a, {
                    ...this._getTransitionProps({
                        around: r
                    }),
                    transitionDuration: t,
                    transitionEasing: sc
                }, {
                    isDragging: !1,
                    isPanning: this.touchZoom,
                    isZooming: this.touchZoom,
                    isRotating: !1
                }), this.blockEvents(t);
            } else {
                const r = this.controllerState.zoomEnd().rotateEnd();
                this.updateViewport(r, null, {
                    isDragging: !1,
                    isPanning: !1,
                    isZooming: !1,
                    isRotating: !1
                });
            }
            return br._startPinchRotation = null, br._lastPinchEvent = null, !0;
        }
        _onDoubleClick(e) {
            if (!this.doubleClickZoom) return !1;
            const t = this.getCenter(e);
            if (!this.isPointInBounds(t, e)) return !1;
            const i = this.isFunctionKeyPressed(e), r = this.controllerState.zoom({
                pos: t,
                scale: i ? .5 : 2
            });
            return this.updateViewport(r, this._getTransitionProps({
                around: t
            }), {
                isZooming: !0,
                isPanning: !0
            }), this.blockEvents(100), !0;
        }
        _onKeyDown(e) {
            if (!this.keyboard) return !1;
            const t = this.isFunctionKeyPressed(e), { zoomSpeed: i, moveSpeed: r, rotateSpeedX: a, rotateSpeedY: l } = this.keyboard === !0 ? {} : this.keyboard, { controllerState: u } = this;
            let h;
            const d = {};
            switch(e.srcEvent.code){
                case "Minus":
                    h = t ? u.zoomOut(i).zoomOut(i) : u.zoomOut(i), d.isZooming = !0;
                    break;
                case "Equal":
                    h = t ? u.zoomIn(i).zoomIn(i) : u.zoomIn(i), d.isZooming = !0;
                    break;
                case "ArrowLeft":
                    t ? (h = u.rotateLeft(a), d.isRotating = !0) : (h = u.moveLeft(r), d.isPanning = !0);
                    break;
                case "ArrowRight":
                    t ? (h = u.rotateRight(a), d.isRotating = !0) : (h = u.moveRight(r), d.isPanning = !0);
                    break;
                case "ArrowUp":
                    t ? (h = u.rotateUp(l), d.isRotating = !0) : (h = u.moveUp(r), d.isPanning = !0);
                    break;
                case "ArrowDown":
                    t ? (h = u.rotateDown(l), d.isRotating = !0) : (h = u.moveDown(r), d.isPanning = !0);
                    break;
                default:
                    return !1;
            }
            return this.updateViewport(h, this._getTransitionProps(), d), !0;
        }
        _getTransitionProps(e) {
            const { transition: t } = this;
            return !t || !t.transitionInterpolator ? Vi : e ? {
                ...t,
                transitionInterpolator: new YT({
                    ...e,
                    ...t.transitionInterpolator.opts,
                    makeViewport: this.controllerState.makeViewport
                })
            } : t;
        }
    }
    class D4 {
        constructor(e, t){
            this._viewportProps = this.applyConstraints(e), this._state = t;
        }
        getViewportProps() {
            return this._viewportProps;
        }
        getState() {
            return this._state;
        }
    }
    const U0 = 5, k4 = 1.2;
    class U4 extends D4 {
        constructor(e){
            const { width: t, height: i, latitude: r, longitude: a, zoom: l, bearing: u = 0, pitch: h = 0, altitude: d = 1.5, position: p = [
                0,
                0,
                0
            ], maxZoom: _ = 20, minZoom: y = 0, maxPitch: v = 60, minPitch: S = 0, startPanLngLat: E, startZoomLngLat: M, startRotatePos: B, startBearing: H, startPitch: O, startZoom: U, normalize: L = !0 } = e;
            Nt(Number.isFinite(a)), Nt(Number.isFinite(r)), Nt(Number.isFinite(l)), super({
                width: t,
                height: i,
                latitude: r,
                longitude: a,
                zoom: l,
                bearing: u,
                pitch: h,
                altitude: d,
                maxZoom: _,
                minZoom: y,
                maxPitch: v,
                minPitch: S,
                normalize: L,
                position: p
            }, {
                startPanLngLat: E,
                startZoomLngLat: M,
                startRotatePos: B,
                startBearing: H,
                startPitch: O,
                startZoom: U
            }), this.makeViewport = e.makeViewport;
        }
        panStart({ pos: e }) {
            return this._getUpdatedState({
                startPanLngLat: this._unproject(e)
            });
        }
        pan({ pos: e, startPos: t }) {
            const i = this.getState().startPanLngLat || this._unproject(t);
            if (!i) return this;
            const a = this.makeViewport(this.getViewportProps()).panByPosition(i, e);
            return this._getUpdatedState(a);
        }
        panEnd() {
            return this._getUpdatedState({
                startPanLngLat: null
            });
        }
        rotateStart({ pos: e }) {
            return this._getUpdatedState({
                startRotatePos: e,
                startBearing: this.getViewportProps().bearing,
                startPitch: this.getViewportProps().pitch
            });
        }
        rotate({ pos: e, deltaAngleX: t = 0, deltaAngleY: i = 0 }) {
            const { startRotatePos: r, startBearing: a, startPitch: l } = this.getState();
            if (!r || a === void 0 || l === void 0) return this;
            let u;
            return e ? u = this._getNewRotation(e, r, l, a) : u = {
                bearing: a + t,
                pitch: l + i
            }, this._getUpdatedState(u);
        }
        rotateEnd() {
            return this._getUpdatedState({
                startBearing: null,
                startPitch: null
            });
        }
        zoomStart({ pos: e }) {
            return this._getUpdatedState({
                startZoomLngLat: this._unproject(e),
                startZoom: this.getViewportProps().zoom
            });
        }
        zoom({ pos: e, startPos: t, scale: i }) {
            let { startZoom: r, startZoomLngLat: a } = this.getState();
            if (a || (r = this.getViewportProps().zoom, a = this._unproject(t) || this._unproject(e)), !a) return this;
            const { maxZoom: l, minZoom: u } = this.getViewportProps();
            let h = r + Math.log2(i);
            h = Xi(h, u, l);
            const d = this.makeViewport({
                ...this.getViewportProps(),
                zoom: h
            });
            return this._getUpdatedState({
                zoom: h,
                ...d.panByPosition(a, e)
            });
        }
        zoomEnd() {
            return this._getUpdatedState({
                startZoomLngLat: null,
                startZoom: null
            });
        }
        zoomIn(e = 2) {
            return this._zoomFromCenter(e);
        }
        zoomOut(e = 2) {
            return this._zoomFromCenter(1 / e);
        }
        moveLeft(e = 100) {
            return this._panFromCenter([
                e,
                0
            ]);
        }
        moveRight(e = 100) {
            return this._panFromCenter([
                -e,
                0
            ]);
        }
        moveUp(e = 100) {
            return this._panFromCenter([
                0,
                e
            ]);
        }
        moveDown(e = 100) {
            return this._panFromCenter([
                0,
                -e
            ]);
        }
        rotateLeft(e = 15) {
            return this._getUpdatedState({
                bearing: this.getViewportProps().bearing - e
            });
        }
        rotateRight(e = 15) {
            return this._getUpdatedState({
                bearing: this.getViewportProps().bearing + e
            });
        }
        rotateUp(e = 10) {
            return this._getUpdatedState({
                pitch: this.getViewportProps().pitch + e
            });
        }
        rotateDown(e = 10) {
            return this._getUpdatedState({
                pitch: this.getViewportProps().pitch - e
            });
        }
        shortestPathFrom(e) {
            const t = e.getViewportProps(), i = {
                ...this.getViewportProps()
            }, { bearing: r, longitude: a } = i;
            return Math.abs(r - t.bearing) > 180 && (i.bearing = r < 0 ? r + 360 : r - 360), Math.abs(a - t.longitude) > 180 && (i.longitude = a < 0 ? a + 360 : a - 360), i;
        }
        applyConstraints(e) {
            const { maxZoom: t, minZoom: i, zoom: r } = e;
            e.zoom = Xi(r, i, t);
            const { maxPitch: a, minPitch: l, pitch: u } = e;
            e.pitch = Xi(u, l, a);
            const { normalize: h = !0 } = e;
            return h && Object.assign(e, nI(e)), e;
        }
        _zoomFromCenter(e) {
            const { width: t, height: i } = this.getViewportProps();
            return this.zoom({
                pos: [
                    t / 2,
                    i / 2
                ],
                scale: e
            });
        }
        _panFromCenter(e) {
            const { width: t, height: i } = this.getViewportProps();
            return this.pan({
                startPos: [
                    t / 2,
                    i / 2
                ],
                pos: [
                    t / 2 + e[0],
                    i / 2 + e[1]
                ]
            });
        }
        _getUpdatedState(e) {
            return new this.constructor({
                makeViewport: this.makeViewport,
                ...this.getViewportProps(),
                ...this.getState(),
                ...e
            });
        }
        _unproject(e) {
            const t = this.makeViewport(this.getViewportProps());
            return e && t.unproject(e);
        }
        _getNewRotation(e, t, i, r) {
            const a = e[0] - t[0], l = e[1] - t[1], u = e[1], h = t[1], { width: d, height: p } = this.getViewportProps(), _ = a / d;
            let y = 0;
            l > 0 ? Math.abs(p - h) > U0 && (y = l / (h - p) * k4) : l < 0 && h > U0 && (y = 1 - u / h), y = Xi(y, -1, 1);
            const { minPitch: v, maxPitch: S } = this.getViewportProps(), E = r + 180 * _;
            let M = i;
            return y > 0 ? M = i + y * (S - i) : y < 0 && (M = i - y * (v - i)), {
                pitch: M,
                bearing: E
            };
        }
    }
    class B4 extends P4 {
        constructor(){
            super(...arguments), this.ControllerState = U4, this.transition = {
                transitionDuration: 300,
                transitionInterpolator: new YT({
                    transitionProps: {
                        compare: [
                            "longitude",
                            "latitude",
                            "zoom",
                            "bearing",
                            "pitch",
                            "position"
                        ],
                        required: [
                            "longitude",
                            "latitude",
                            "zoom"
                        ]
                    }
                })
            }, this.dragMode = "pan";
        }
        setProps(e) {
            e.position = e.position || [
                0,
                0,
                0
            ];
            const t = this.props;
            super.setProps(e), (!t || t.height !== e.height) && this.updateViewport(new this.ControllerState({
                makeViewport: this.makeViewport,
                ...e,
                ...this.state
            }));
        }
    }
    class qT extends Gs {
        constructor(e = {}){
            super(e);
        }
        getViewportType() {
            return Qs;
        }
        get ControllerType() {
            return B4;
        }
    }
    qT.displayName = "MapView";
    const L4 = new Ng;
    function F4(n, e) {
        const t = n.order ?? 1 / 0, i = e.order ?? 1 / 0;
        return t - i;
    }
    class z4 {
        constructor(e){
            this._resolvedEffects = [], this._defaultEffects = [], this.effects = [], this._context = e, this._needsRedraw = "Initial render", this._setEffects([]);
        }
        addDefaultEffect(e) {
            const t = this._defaultEffects;
            if (!t.find((i)=>i.id === e.id)) {
                const i = t.findIndex((r)=>F4(r, e) > 0);
                i < 0 ? t.push(e) : t.splice(i, 0, e), e.setup(this._context), this._setEffects(this.effects);
            }
        }
        setProps(e) {
            "effects" in e && (Ht(e.effects, this.effects, 1) || this._setEffects(e.effects));
        }
        needsRedraw(e = {
            clearRedrawFlags: !1
        }) {
            const t = this._needsRedraw;
            return e.clearRedrawFlags && (this._needsRedraw = !1), t;
        }
        getEffects() {
            return this._resolvedEffects;
        }
        _setEffects(e) {
            const t = {};
            for (const r of this.effects)t[r.id] = r;
            const i = [];
            for (const r of e){
                const a = t[r.id];
                let l = r;
                a && a !== r ? a.setProps ? (a.setProps(r.props), l = a) : a.cleanup(this._context) : a || r.setup(this._context), i.push(l), delete t[r.id];
            }
            for(const r in t)t[r].cleanup(this._context);
            this.effects = i, this._resolvedEffects = i.concat(this._defaultEffects), e.some((r)=>r instanceof Ng) || this._resolvedEffects.push(L4), this._needsRedraw = "effects changed";
        }
        finalize() {
            for (const e of this._resolvedEffects)e.cleanup(this._context);
            this.effects.length = 0, this._resolvedEffects.length = 0, this._defaultEffects.length = 0;
        }
    }
    class V4 extends Ig {
        shouldDrawLayer(e) {
            const { operation: t } = e.props;
            return t.includes("draw") || t.includes("terrain");
        }
    }
    const H4 = "deckRenderer.renderLayers";
    class j4 {
        constructor(e){
            this.device = e, this.layerFilter = null, this.drawPickingColors = !1, this.drawLayersPass = new V4(e), this.pickLayersPass = new $T(e), this.renderCount = 0, this._needsRedraw = "Initial render", this.renderBuffers = [], this.lastPostProcessEffect = null;
        }
        setProps(e) {
            this.layerFilter !== e.layerFilter && (this.layerFilter = e.layerFilter, this._needsRedraw = "layerFilter changed"), this.drawPickingColors !== e.drawPickingColors && (this.drawPickingColors = e.drawPickingColors, this._needsRedraw = "drawPickingColors changed");
        }
        renderLayers(e) {
            if (!e.viewports.length) return;
            const t = this.drawPickingColors ? this.pickLayersPass : this.drawLayersPass, i = {
                layerFilter: this.layerFilter,
                isPicking: this.drawPickingColors,
                ...e
            };
            i.effects && this._preRender(i.effects, i);
            const r = this.lastPostProcessEffect ? this.renderBuffers[0] : i.target;
            this.lastPostProcessEffect && (i.clearColor = [
                0,
                0,
                0,
                0
            ], i.clearCanvas = !0);
            const a = t.render({
                ...i,
                target: r
            });
            i.effects && this._postRender(i.effects, i), this.renderCount++, It(H4, this, a, e);
        }
        needsRedraw(e = {
            clearRedrawFlags: !1
        }) {
            const t = this._needsRedraw;
            return e.clearRedrawFlags && (this._needsRedraw = !1), t;
        }
        finalize() {
            const { renderBuffers: e } = this;
            for (const t of e)t.delete();
            e.length = 0;
        }
        _preRender(e, t) {
            this.lastPostProcessEffect = null, t.preRenderStats = t.preRenderStats || {};
            for (const i of e)t.preRenderStats[i.id] = i.preRender(t), i.postRender && (this.lastPostProcessEffect = i.id);
            this.lastPostProcessEffect && this._resizeRenderBuffers();
        }
        _resizeRenderBuffers() {
            const { renderBuffers: e } = this, t = this.device.canvasContext.getDrawingBufferSize();
            e.length === 0 && [
                0,
                1
            ].map((i)=>{
                const r = this.device.createTexture({
                    sampler: {
                        minFilter: "linear",
                        magFilter: "linear"
                    }
                });
                e.push(this.device.createFramebuffer({
                    id: `deck-renderbuffer-${i}`,
                    colorAttachments: [
                        r
                    ]
                }));
            });
            for (const i of e)i.resize(t);
        }
        _postRender(e, t) {
            const { renderBuffers: i } = this, r = {
                ...t,
                inputBuffer: i[0],
                swapBuffer: i[1]
            };
            for (const a of e)if (a.postRender) {
                r.target = a.id === this.lastPostProcessEffect ? t.target : void 0;
                const l = a.postRender(r);
                r.inputBuffer = l, r.swapBuffer = l === i[0] ? i[1] : i[0];
            }
        }
    }
    const W4 = {
        pickedColor: null,
        pickedObjectIndex: -1
    };
    function $4({ pickedColors: n, decodePickingColor: e, deviceX: t, deviceY: i, deviceRadius: r, deviceRect: a }) {
        const { x: l, y: u, width: h, height: d } = a;
        let p = r * r, _ = -1, y = 0;
        for(let v = 0; v < d; v++){
            const S = v + u - i, E = S * S;
            if (E > p) y += 4 * h;
            else for(let M = 0; M < h; M++){
                if (n[y + 3] - 1 >= 0) {
                    const H = M + l - t, O = H * H + E;
                    O <= p && (p = O, _ = y);
                }
                y += 4;
            }
        }
        if (_ >= 0) {
            const v = n.slice(_, _ + 4), S = e(v);
            if (S) {
                const E = Math.floor(_ / 4 / h), M = _ / 4 - E * h;
                return {
                    ...S,
                    pickedColor: v,
                    pickedX: l + M,
                    pickedY: u + E
                };
            }
            Fe.error("Picked non-existent layer. Is picking buffer corrupt?")();
        }
        return W4;
    }
    function X4({ pickedColors: n, decodePickingColor: e }) {
        const t = new Map;
        if (n) {
            for(let i = 0; i < n.length; i += 4)if (n[i + 3] - 1 >= 0) {
                const a = n.slice(i, i + 4), l = a.join(",");
                if (!t.has(l)) {
                    const u = e(a);
                    u ? t.set(l, {
                        ...u,
                        color: a
                    }) : Fe.error("Picked non-existent layer. Is picking buffer corrupt?")();
                }
            }
        }
        return Array.from(t.values());
    }
    function KT({ pickInfo: n, viewports: e, pixelRatio: t, x: i, y: r, z: a }) {
        let l = e[0];
        e.length > 1 && (l = q4(n?.pickedViewports || e, {
            x: i,
            y: r
        }));
        let u;
        if (l) {
            const h = [
                i - l.x,
                r - l.y
            ];
            a !== void 0 && (h[2] = a), u = l.unproject(h);
        }
        return {
            color: null,
            layer: null,
            viewport: l,
            index: -1,
            picked: !1,
            x: i,
            y: r,
            pixel: [
                i,
                r
            ],
            coordinate: u,
            devicePixel: n && "pickedX" in n ? [
                n.pickedX,
                n.pickedY
            ] : void 0,
            pixelRatio: t
        };
    }
    function Y4(n) {
        const { pickInfo: e, lastPickedInfo: t, mode: i, layers: r } = n, { pickedColor: a, pickedLayer: l, pickedObjectIndex: u } = e, h = l ? [
            l
        ] : [];
        if (i === "hover") {
            const _ = t.index, y = t.layerId, v = l ? l.props.id : null;
            if (v !== y || u !== _) {
                if (v !== y) {
                    const S = r.find((E)=>E.props.id === y);
                    S && h.unshift(S);
                }
                t.layerId = v, t.index = u, t.info = null;
            }
        }
        const d = KT(n), p = new Map;
        return p.set(null, d), h.forEach((_)=>{
            let y = {
                ...d
            };
            _ === l && (y.color = a, y.index = u, y.picked = !0), y = ZT({
                layer: _,
                info: y,
                mode: i
            });
            const v = y.layer;
            _ === l && i === "hover" && (t.info = y), p.set(v.id, y), i === "hover" && v.updateAutoHighlight(y);
        }), p;
    }
    function ZT({ layer: n, info: e, mode: t }) {
        for(; n && e;){
            const i = e.layer || null;
            e.sourceLayer = i, e.layer = n, e = n.getPickingInfo({
                info: e,
                mode: t,
                sourceLayer: i
            }), n = n.parent;
        }
        return e;
    }
    function q4(n, e) {
        for(let t = n.length - 1; t >= 0; t--){
            const i = n[t];
            if (i.containsPixel(e)) return i;
        }
        return n[0];
    }
    class K4 {
        constructor(e){
            this._pickable = !0, this.device = e, this.pickLayersPass = new $T(e), this.lastPickedInfo = {
                index: -1,
                layerId: null,
                info: null
            };
        }
        setProps(e) {
            "layerFilter" in e && (this.layerFilter = e.layerFilter), "_pickable" in e && (this._pickable = e._pickable);
        }
        finalize() {
            this.pickingFBO && this.pickingFBO.destroy(), this.depthFBO && this.depthFBO.destroy();
        }
        pickObject(e) {
            return this._pickClosestObject(e);
        }
        pickObjects(e) {
            return this._pickVisibleObjects(e);
        }
        getLastPickedObject({ x: e, y: t, layers: i, viewports: r }, a = this.lastPickedInfo.info) {
            const l = a && a.layer && a.layer.id, u = a && a.viewport && a.viewport.id, h = l ? i.find((y)=>y.id === l) : null, d = u && r.find((y)=>y.id === u) || r[0], p = d && d.unproject([
                e - d.x,
                t - d.y
            ]);
            return {
                ...a,
                ...{
                    x: e,
                    y: t,
                    viewport: d,
                    coordinate: p,
                    layer: h
                }
            };
        }
        _resizeBuffer() {
            if (!this.pickingFBO && (this.pickingFBO = this.device.createFramebuffer({
                colorAttachments: [
                    "rgba8unorm"
                ],
                depthStencilAttachment: "depth16unorm"
            }), this.device.isTextureFormatRenderable("rgba32float"))) {
                const t = this.device.createFramebuffer({
                    colorAttachments: [
                        "rgba32float"
                    ],
                    depthStencilAttachment: "depth16unorm"
                });
                this.depthFBO = t;
            }
            const { canvas: e } = this.device.getDefaultCanvasContext();
            this.pickingFBO?.resize({
                width: e.width,
                height: e.height
            }), this.depthFBO?.resize({
                width: e.width,
                height: e.height
            });
        }
        _getPickable(e) {
            if (this._pickable === !1) return null;
            const t = e.filter((i)=>this.pickLayersPass.shouldDrawLayer(i) && !i.isComposite);
            return t.length ? t : null;
        }
        _pickClosestObject({ layers: e, views: t, viewports: i, x: r, y: a, radius: l = 0, depth: u = 1, mode: h = "query", unproject3D: d, onViewportActive: p, effects: _ }) {
            const y = this.device.canvasContext.cssToDeviceRatio(), v = this._getPickable(e);
            if (!v || i.length === 0) return {
                result: [],
                emptyInfo: KT({
                    viewports: i,
                    x: r,
                    y: a,
                    pixelRatio: y
                })
            };
            this._resizeBuffer();
            const S = this.device.canvasContext.cssToDevicePixels([
                r,
                a
            ], !0), E = [
                S.x + Math.floor(S.width / 2),
                S.y + Math.floor(S.height / 2)
            ], M = Math.round(l * y), { width: B, height: H } = this.pickingFBO, O = this._getPickingRect({
                deviceX: E[0],
                deviceY: E[1],
                deviceRadius: M,
                deviceWidth: B,
                deviceHeight: H
            }), U = {
                x: r - l,
                y: a - l,
                width: l * 2 + 1,
                height: l * 2 + 1
            };
            let L;
            const Z = [], se = new Set;
            for(let ae = 0; ae < u; ae++){
                let te;
                if (O) {
                    const ne = this._drawAndSample({
                        layers: v,
                        views: t,
                        viewports: i,
                        onViewportActive: p,
                        deviceRect: O,
                        cullRect: U,
                        effects: _,
                        pass: `picking:${h}`
                    });
                    te = $4({
                        ...ne,
                        deviceX: E[0],
                        deviceY: E[1],
                        deviceRadius: M,
                        deviceRect: O
                    });
                } else te = {
                    pickedColor: null,
                    pickedObjectIndex: -1
                };
                let fe;
                if (te.pickedLayer && d && this.depthFBO) {
                    const { pickedColors: ne } = this._drawAndSample({
                        layers: [
                            te.pickedLayer
                        ],
                        views: t,
                        viewports: i,
                        onViewportActive: p,
                        deviceRect: {
                            x: te.pickedX,
                            y: te.pickedY,
                            width: 1,
                            height: 1
                        },
                        cullRect: U,
                        effects: _,
                        pass: `picking:${h}:z`
                    }, !0);
                    ne[3] && (fe = ne[0]);
                }
                te.pickedLayer && ae + 1 < u && (se.add(te.pickedLayer), te.pickedLayer.disablePickingIndex(te.pickedObjectIndex)), L = Y4({
                    pickInfo: te,
                    lastPickedInfo: this.lastPickedInfo,
                    mode: h,
                    layers: v,
                    viewports: i,
                    x: r,
                    y: a,
                    z: fe,
                    pixelRatio: y
                });
                for (const ne of L.values())ne.layer && Z.push(ne);
                if (!te.pickedColor) break;
            }
            for (const ae of se)ae.restorePickingColors();
            return {
                result: Z,
                emptyInfo: L.get(null)
            };
        }
        _pickVisibleObjects({ layers: e, views: t, viewports: i, x: r, y: a, width: l = 1, height: u = 1, mode: h = "query", maxObjects: d = null, onViewportActive: p, effects: _ }) {
            const y = this._getPickable(e);
            if (!y || i.length === 0) return [];
            this._resizeBuffer();
            const v = this.device.canvasContext.cssToDeviceRatio(), S = this.device.canvasContext.cssToDevicePixels([
                r,
                a
            ], !0), E = S.x, M = S.y + S.height, B = this.device.canvasContext.cssToDevicePixels([
                r + l,
                a + u
            ], !0), H = B.x + B.width, O = B.y, U = {
                x: E,
                y: O,
                width: H - E,
                height: M - O
            }, L = this._drawAndSample({
                layers: y,
                views: t,
                viewports: i,
                onViewportActive: p,
                deviceRect: U,
                cullRect: {
                    x: r,
                    y: a,
                    width: l,
                    height: u
                },
                effects: _,
                pass: `picking:${h}`
            }), Z = X4(L), se = new Map, ae = [], te = Number.isFinite(d);
            for(let fe = 0; fe < Z.length && !(te && ae.length >= d); fe++){
                const ne = Z[fe];
                let ve = {
                    color: ne.pickedColor,
                    layer: null,
                    index: ne.pickedObjectIndex,
                    picked: !0,
                    x: r,
                    y: a,
                    pixelRatio: v
                };
                ve = ZT({
                    layer: ne.pickedLayer,
                    info: ve,
                    mode: h
                });
                const Te = ve.layer.id;
                se.has(Te) || se.set(Te, new Set);
                const ue = se.get(Te), Ie = ve.object ?? ve.index;
                ue.has(Ie) || (ue.add(Ie), ae.push(ve));
            }
            return ae;
        }
        _drawAndSample({ layers: e, views: t, viewports: i, onViewportActive: r, deviceRect: a, cullRect: l, effects: u, pass: h }, d = !1) {
            const p = d ? this.depthFBO : this.pickingFBO, _ = {
                layers: e,
                layerFilter: this.layerFilter,
                views: t,
                viewports: i,
                onViewportActive: r,
                pickingFBO: p,
                deviceRect: a,
                cullRect: l,
                effects: u,
                pass: h,
                pickZ: d,
                preRenderStats: {},
                isPicking: !0
            };
            for (const H of u)H.useInPicking && (_.preRenderStats[H.id] = H.preRender(_));
            const { decodePickingColor: y } = this.pickLayersPass.render(_), { x: v, y: S, width: E, height: M } = a, B = new (d ? Float32Array : Uint8Array)(E * M * 4);
            return this.device.readPixelsToArrayWebGL(p, {
                sourceX: v,
                sourceY: S,
                sourceWidth: E,
                sourceHeight: M,
                target: B
            }), {
                pickedColors: B,
                decodePickingColor: y
            };
        }
        _getPickingRect({ deviceX: e, deviceY: t, deviceRadius: i, deviceWidth: r, deviceHeight: a }) {
            const l = Math.max(0, e - i), u = Math.max(0, t - i), h = Math.min(r, e + i + 1) - l, d = Math.min(a, t + i + 1) - u;
            return h <= 0 || d <= 0 ? null : {
                x: l,
                y: u,
                width: h,
                height: d
            };
        }
    }
    const Z4 = {
        "top-left": {
            top: 0,
            left: 0
        },
        "top-right": {
            top: 0,
            right: 0
        },
        "bottom-left": {
            bottom: 0,
            left: 0
        },
        "bottom-right": {
            bottom: 0,
            right: 0
        },
        fill: {
            top: 0,
            left: 0,
            bottom: 0,
            right: 0
        }
    }, Q4 = "top-left", B0 = "__root";
    class G4 {
        constructor({ deck: e, parentElement: t }){
            this.defaultWidgets = [], this.widgets = [], this.resolvedWidgets = [], this.containers = {}, this.lastViewports = {}, this.deck = e, this.parentElement = t;
        }
        getWidgets() {
            return this.resolvedWidgets;
        }
        setProps(e) {
            e.widgets && !Ht(e.widgets, this.widgets, 1) && this._setWidgets(e.widgets);
        }
        finalize() {
            for (const e of this.getWidgets())this._remove(e);
            this.defaultWidgets.length = 0, this.resolvedWidgets.length = 0;
            for(const e in this.containers)this.containers[e].remove();
        }
        addDefault(e) {
            this.defaultWidgets.find((t)=>t.id === e.id) || (this._add(e), this.defaultWidgets.push(e), this._setWidgets(this.widgets));
        }
        _setWidgets(e) {
            const t = {};
            for (const i of this.resolvedWidgets)t[i.id] = i;
            this.resolvedWidgets.length = 0;
            for (const i of this.defaultWidgets)t[i.id] = null, this.resolvedWidgets.push(i);
            for (let i of e){
                const r = t[i.id];
                r ? r.viewId !== i.viewId || r.placement !== i.placement ? (this._remove(r), this._add(i)) : i !== r && (r.setProps(i.props), i = r) : this._add(i), t[i.id] = null, this.resolvedWidgets.push(i);
            }
            for(const i in t){
                const r = t[i];
                r && this._remove(r);
            }
            this.widgets = e;
        }
        _add(e) {
            const { viewId: t = null, placement: i = Q4 } = e, r = e.onAdd({
                deck: this.deck,
                viewId: t
            });
            r && this._getContainer(t, i).append(r), e._element = r;
        }
        _remove(e) {
            e.onRemove?.(), e._element && e._element.remove(), e._element = void 0;
        }
        _getContainer(e, t) {
            const i = e || B0;
            let r = this.containers[i];
            r || (r = document.createElement("div"), r.style.pointerEvents = "none", r.style.position = "absolute", r.style.overflow = "hidden", this.parentElement?.append(r), this.containers[i] = r);
            let a = r.querySelector(`.${t}`);
            return a || (a = document.createElement("div"), a.className = t, a.style.position = "absolute", a.style.zIndex = "2", Object.assign(a.style, Z4[t]), r.append(a)), a;
        }
        _updateContainers() {
            const e = this.deck.width, t = this.deck.height;
            for(const i in this.containers){
                const r = this.lastViewports[i] || null, a = i === B0 || r, l = this.containers[i];
                a ? (l.style.display = "block", l.style.left = `${r ? r.x : 0}px`, l.style.top = `${r ? r.y : 0}px`, l.style.width = `${r ? r.width : e}px`, l.style.height = `${r ? r.height : t}px`) : l.style.display = "none";
            }
        }
        onRedraw({ viewports: e, layers: t }) {
            const i = e.reduce((r, a)=>(r[a.id] = a, r), {});
            for (const r of this.getWidgets()){
                const { viewId: a } = r;
                if (a) {
                    const l = i[a];
                    l && (r.onViewportChange && r.onViewportChange(l), r.onRedraw?.({
                        viewports: [
                            l
                        ],
                        layers: t
                    }));
                } else {
                    if (r.onViewportChange) for (const l of e)r.onViewportChange(l);
                    r.onRedraw?.({
                        viewports: e,
                        layers: t
                    });
                }
            }
            this.lastViewports = i, this._updateContainers();
        }
        onHover(e, t) {
            for (const i of this.getWidgets()){
                const { viewId: r } = i;
                (!r || r === e.viewport?.id) && i.onHover?.(e, t);
            }
        }
        onEvent(e, t) {
            const i = Dd[t.type];
            if (i) for (const r of this.getWidgets()){
                const { viewId: a } = r;
                (!a || a === e.viewport?.id) && r[i]?.(e, t);
            }
        }
    }
    const J4 = {
        zIndex: "1",
        position: "absolute",
        pointerEvents: "none",
        color: "#a0a7b4",
        backgroundColor: "#29323c",
        padding: "10px",
        top: "0",
        left: "0",
        display: "none"
    };
    class eN {
        constructor(){
            this.id = "default-tooltip", this.placement = "fill", this.props = {}, this.isVisible = !1;
        }
        onAdd({ deck: e }) {
            const t = document.createElement("div");
            return t.className = "deck-tooltip", Object.assign(t.style, J4), this.deck = e, this.element = t, t;
        }
        onRemove() {
            this.deck = void 0, this.element = void 0;
        }
        setProps() {}
        onViewportChange(e) {
            this.isVisible && e.id === this.lastViewport?.id && e !== this.lastViewport && this.setTooltip(null);
        }
        onHover(e) {
            const { deck: t } = this, i = t && t.props.getTooltip;
            if (!i) return;
            const r = i(e);
            this.lastViewport = e.viewport, this.setTooltip(r, e.x, e.y);
        }
        setTooltip(e, t, i) {
            const r = this.element;
            if (r) {
                if (typeof e == "string") r.innerText = e;
                else if (e) e.text && (r.innerText = e.text), e.html && (r.innerHTML = e.html), e.className && (r.className = e.className);
                else {
                    this.isVisible = !1, r.style.display = "none";
                    return;
                }
                this.isVisible = !0, r.style.display = "block", r.style.transform = `translate(${t}px, ${i}px)`, e && typeof e == "object" && "style" in e && Object.assign(r.style, e.style);
            }
        }
    }
    var ks;
    (function(n) {
        n[n.DEPTH_BUFFER_BIT = 256] = "DEPTH_BUFFER_BIT", n[n.STENCIL_BUFFER_BIT = 1024] = "STENCIL_BUFFER_BIT", n[n.COLOR_BUFFER_BIT = 16384] = "COLOR_BUFFER_BIT", n[n.POINTS = 0] = "POINTS", n[n.LINES = 1] = "LINES", n[n.LINE_LOOP = 2] = "LINE_LOOP", n[n.LINE_STRIP = 3] = "LINE_STRIP", n[n.TRIANGLES = 4] = "TRIANGLES", n[n.TRIANGLE_STRIP = 5] = "TRIANGLE_STRIP", n[n.TRIANGLE_FAN = 6] = "TRIANGLE_FAN", n[n.ZERO = 0] = "ZERO", n[n.ONE = 1] = "ONE", n[n.SRC_COLOR = 768] = "SRC_COLOR", n[n.ONE_MINUS_SRC_COLOR = 769] = "ONE_MINUS_SRC_COLOR", n[n.SRC_ALPHA = 770] = "SRC_ALPHA", n[n.ONE_MINUS_SRC_ALPHA = 771] = "ONE_MINUS_SRC_ALPHA", n[n.DST_ALPHA = 772] = "DST_ALPHA", n[n.ONE_MINUS_DST_ALPHA = 773] = "ONE_MINUS_DST_ALPHA", n[n.DST_COLOR = 774] = "DST_COLOR", n[n.ONE_MINUS_DST_COLOR = 775] = "ONE_MINUS_DST_COLOR", n[n.SRC_ALPHA_SATURATE = 776] = "SRC_ALPHA_SATURATE", n[n.CONSTANT_COLOR = 32769] = "CONSTANT_COLOR", n[n.ONE_MINUS_CONSTANT_COLOR = 32770] = "ONE_MINUS_CONSTANT_COLOR", n[n.CONSTANT_ALPHA = 32771] = "CONSTANT_ALPHA", n[n.ONE_MINUS_CONSTANT_ALPHA = 32772] = "ONE_MINUS_CONSTANT_ALPHA", n[n.FUNC_ADD = 32774] = "FUNC_ADD", n[n.FUNC_SUBTRACT = 32778] = "FUNC_SUBTRACT", n[n.FUNC_REVERSE_SUBTRACT = 32779] = "FUNC_REVERSE_SUBTRACT", n[n.BLEND_EQUATION = 32777] = "BLEND_EQUATION", n[n.BLEND_EQUATION_RGB = 32777] = "BLEND_EQUATION_RGB", n[n.BLEND_EQUATION_ALPHA = 34877] = "BLEND_EQUATION_ALPHA", n[n.BLEND_DST_RGB = 32968] = "BLEND_DST_RGB", n[n.BLEND_SRC_RGB = 32969] = "BLEND_SRC_RGB", n[n.BLEND_DST_ALPHA = 32970] = "BLEND_DST_ALPHA", n[n.BLEND_SRC_ALPHA = 32971] = "BLEND_SRC_ALPHA", n[n.BLEND_COLOR = 32773] = "BLEND_COLOR", n[n.ARRAY_BUFFER_BINDING = 34964] = "ARRAY_BUFFER_BINDING", n[n.ELEMENT_ARRAY_BUFFER_BINDING = 34965] = "ELEMENT_ARRAY_BUFFER_BINDING", n[n.LINE_WIDTH = 2849] = "LINE_WIDTH", n[n.ALIASED_POINT_SIZE_RANGE = 33901] = "ALIASED_POINT_SIZE_RANGE", n[n.ALIASED_LINE_WIDTH_RANGE = 33902] = "ALIASED_LINE_WIDTH_RANGE", n[n.CULL_FACE_MODE = 2885] = "CULL_FACE_MODE", n[n.FRONT_FACE = 2886] = "FRONT_FACE", n[n.DEPTH_RANGE = 2928] = "DEPTH_RANGE", n[n.DEPTH_WRITEMASK = 2930] = "DEPTH_WRITEMASK", n[n.DEPTH_CLEAR_VALUE = 2931] = "DEPTH_CLEAR_VALUE", n[n.DEPTH_FUNC = 2932] = "DEPTH_FUNC", n[n.STENCIL_CLEAR_VALUE = 2961] = "STENCIL_CLEAR_VALUE", n[n.STENCIL_FUNC = 2962] = "STENCIL_FUNC", n[n.STENCIL_FAIL = 2964] = "STENCIL_FAIL", n[n.STENCIL_PASS_DEPTH_FAIL = 2965] = "STENCIL_PASS_DEPTH_FAIL", n[n.STENCIL_PASS_DEPTH_PASS = 2966] = "STENCIL_PASS_DEPTH_PASS", n[n.STENCIL_REF = 2967] = "STENCIL_REF", n[n.STENCIL_VALUE_MASK = 2963] = "STENCIL_VALUE_MASK", n[n.STENCIL_WRITEMASK = 2968] = "STENCIL_WRITEMASK", n[n.STENCIL_BACK_FUNC = 34816] = "STENCIL_BACK_FUNC", n[n.STENCIL_BACK_FAIL = 34817] = "STENCIL_BACK_FAIL", n[n.STENCIL_BACK_PASS_DEPTH_FAIL = 34818] = "STENCIL_BACK_PASS_DEPTH_FAIL", n[n.STENCIL_BACK_PASS_DEPTH_PASS = 34819] = "STENCIL_BACK_PASS_DEPTH_PASS", n[n.STENCIL_BACK_REF = 36003] = "STENCIL_BACK_REF", n[n.STENCIL_BACK_VALUE_MASK = 36004] = "STENCIL_BACK_VALUE_MASK", n[n.STENCIL_BACK_WRITEMASK = 36005] = "STENCIL_BACK_WRITEMASK", n[n.VIEWPORT = 2978] = "VIEWPORT", n[n.SCISSOR_BOX = 3088] = "SCISSOR_BOX", n[n.COLOR_CLEAR_VALUE = 3106] = "COLOR_CLEAR_VALUE", n[n.COLOR_WRITEMASK = 3107] = "COLOR_WRITEMASK", n[n.UNPACK_ALIGNMENT = 3317] = "UNPACK_ALIGNMENT", n[n.PACK_ALIGNMENT = 3333] = "PACK_ALIGNMENT", n[n.MAX_TEXTURE_SIZE = 3379] = "MAX_TEXTURE_SIZE", n[n.MAX_VIEWPORT_DIMS = 3386] = "MAX_VIEWPORT_DIMS", n[n.SUBPIXEL_BITS = 3408] = "SUBPIXEL_BITS", n[n.RED_BITS = 3410] = "RED_BITS", n[n.GREEN_BITS = 3411] = "GREEN_BITS", n[n.BLUE_BITS = 3412] = "BLUE_BITS", n[n.ALPHA_BITS = 3413] = "ALPHA_BITS", n[n.DEPTH_BITS = 3414] = "DEPTH_BITS", n[n.STENCIL_BITS = 3415] = "STENCIL_BITS", n[n.POLYGON_OFFSET_UNITS = 10752] = "POLYGON_OFFSET_UNITS", n[n.POLYGON_OFFSET_FACTOR = 32824] = "POLYGON_OFFSET_FACTOR", n[n.TEXTURE_BINDING_2D = 32873] = "TEXTURE_BINDING_2D", n[n.SAMPLE_BUFFERS = 32936] = "SAMPLE_BUFFERS", n[n.SAMPLES = 32937] = "SAMPLES", n[n.SAMPLE_COVERAGE_VALUE = 32938] = "SAMPLE_COVERAGE_VALUE", n[n.SAMPLE_COVERAGE_INVERT = 32939] = "SAMPLE_COVERAGE_INVERT", n[n.COMPRESSED_TEXTURE_FORMATS = 34467] = "COMPRESSED_TEXTURE_FORMATS", n[n.VENDOR = 7936] = "VENDOR", n[n.RENDERER = 7937] = "RENDERER", n[n.VERSION = 7938] = "VERSION", n[n.IMPLEMENTATION_COLOR_READ_TYPE = 35738] = "IMPLEMENTATION_COLOR_READ_TYPE", n[n.IMPLEMENTATION_COLOR_READ_FORMAT = 35739] = "IMPLEMENTATION_COLOR_READ_FORMAT", n[n.BROWSER_DEFAULT_WEBGL = 37444] = "BROWSER_DEFAULT_WEBGL", n[n.STATIC_DRAW = 35044] = "STATIC_DRAW", n[n.STREAM_DRAW = 35040] = "STREAM_DRAW", n[n.DYNAMIC_DRAW = 35048] = "DYNAMIC_DRAW", n[n.ARRAY_BUFFER = 34962] = "ARRAY_BUFFER", n[n.ELEMENT_ARRAY_BUFFER = 34963] = "ELEMENT_ARRAY_BUFFER", n[n.BUFFER_SIZE = 34660] = "BUFFER_SIZE", n[n.BUFFER_USAGE = 34661] = "BUFFER_USAGE", n[n.CURRENT_VERTEX_ATTRIB = 34342] = "CURRENT_VERTEX_ATTRIB", n[n.VERTEX_ATTRIB_ARRAY_ENABLED = 34338] = "VERTEX_ATTRIB_ARRAY_ENABLED", n[n.VERTEX_ATTRIB_ARRAY_SIZE = 34339] = "VERTEX_ATTRIB_ARRAY_SIZE", n[n.VERTEX_ATTRIB_ARRAY_STRIDE = 34340] = "VERTEX_ATTRIB_ARRAY_STRIDE", n[n.VERTEX_ATTRIB_ARRAY_TYPE = 34341] = "VERTEX_ATTRIB_ARRAY_TYPE", n[n.VERTEX_ATTRIB_ARRAY_NORMALIZED = 34922] = "VERTEX_ATTRIB_ARRAY_NORMALIZED", n[n.VERTEX_ATTRIB_ARRAY_POINTER = 34373] = "VERTEX_ATTRIB_ARRAY_POINTER", n[n.VERTEX_ATTRIB_ARRAY_BUFFER_BINDING = 34975] = "VERTEX_ATTRIB_ARRAY_BUFFER_BINDING", n[n.CULL_FACE = 2884] = "CULL_FACE", n[n.FRONT = 1028] = "FRONT", n[n.BACK = 1029] = "BACK", n[n.FRONT_AND_BACK = 1032] = "FRONT_AND_BACK", n[n.BLEND = 3042] = "BLEND", n[n.DEPTH_TEST = 2929] = "DEPTH_TEST", n[n.DITHER = 3024] = "DITHER", n[n.POLYGON_OFFSET_FILL = 32823] = "POLYGON_OFFSET_FILL", n[n.SAMPLE_ALPHA_TO_COVERAGE = 32926] = "SAMPLE_ALPHA_TO_COVERAGE", n[n.SAMPLE_COVERAGE = 32928] = "SAMPLE_COVERAGE", n[n.SCISSOR_TEST = 3089] = "SCISSOR_TEST", n[n.STENCIL_TEST = 2960] = "STENCIL_TEST", n[n.NO_ERROR = 0] = "NO_ERROR", n[n.INVALID_ENUM = 1280] = "INVALID_ENUM", n[n.INVALID_VALUE = 1281] = "INVALID_VALUE", n[n.INVALID_OPERATION = 1282] = "INVALID_OPERATION", n[n.OUT_OF_MEMORY = 1285] = "OUT_OF_MEMORY", n[n.CONTEXT_LOST_WEBGL = 37442] = "CONTEXT_LOST_WEBGL", n[n.CW = 2304] = "CW", n[n.CCW = 2305] = "CCW", n[n.DONT_CARE = 4352] = "DONT_CARE", n[n.FASTEST = 4353] = "FASTEST", n[n.NICEST = 4354] = "NICEST", n[n.GENERATE_MIPMAP_HINT = 33170] = "GENERATE_MIPMAP_HINT", n[n.BYTE = 5120] = "BYTE", n[n.UNSIGNED_BYTE = 5121] = "UNSIGNED_BYTE", n[n.SHORT = 5122] = "SHORT", n[n.UNSIGNED_SHORT = 5123] = "UNSIGNED_SHORT", n[n.INT = 5124] = "INT", n[n.UNSIGNED_INT = 5125] = "UNSIGNED_INT", n[n.FLOAT = 5126] = "FLOAT", n[n.DOUBLE = 5130] = "DOUBLE", n[n.DEPTH_COMPONENT = 6402] = "DEPTH_COMPONENT", n[n.ALPHA = 6406] = "ALPHA", n[n.RGB = 6407] = "RGB", n[n.RGBA = 6408] = "RGBA", n[n.LUMINANCE = 6409] = "LUMINANCE", n[n.LUMINANCE_ALPHA = 6410] = "LUMINANCE_ALPHA", n[n.UNSIGNED_SHORT_4_4_4_4 = 32819] = "UNSIGNED_SHORT_4_4_4_4", n[n.UNSIGNED_SHORT_5_5_5_1 = 32820] = "UNSIGNED_SHORT_5_5_5_1", n[n.UNSIGNED_SHORT_5_6_5 = 33635] = "UNSIGNED_SHORT_5_6_5", n[n.FRAGMENT_SHADER = 35632] = "FRAGMENT_SHADER", n[n.VERTEX_SHADER = 35633] = "VERTEX_SHADER", n[n.COMPILE_STATUS = 35713] = "COMPILE_STATUS", n[n.DELETE_STATUS = 35712] = "DELETE_STATUS", n[n.LINK_STATUS = 35714] = "LINK_STATUS", n[n.VALIDATE_STATUS = 35715] = "VALIDATE_STATUS", n[n.ATTACHED_SHADERS = 35717] = "ATTACHED_SHADERS", n[n.ACTIVE_ATTRIBUTES = 35721] = "ACTIVE_ATTRIBUTES", n[n.ACTIVE_UNIFORMS = 35718] = "ACTIVE_UNIFORMS", n[n.MAX_VERTEX_ATTRIBS = 34921] = "MAX_VERTEX_ATTRIBS", n[n.MAX_VERTEX_UNIFORM_VECTORS = 36347] = "MAX_VERTEX_UNIFORM_VECTORS", n[n.MAX_VARYING_VECTORS = 36348] = "MAX_VARYING_VECTORS", n[n.MAX_COMBINED_TEXTURE_IMAGE_UNITS = 35661] = "MAX_COMBINED_TEXTURE_IMAGE_UNITS", n[n.MAX_VERTEX_TEXTURE_IMAGE_UNITS = 35660] = "MAX_VERTEX_TEXTURE_IMAGE_UNITS", n[n.MAX_TEXTURE_IMAGE_UNITS = 34930] = "MAX_TEXTURE_IMAGE_UNITS", n[n.MAX_FRAGMENT_UNIFORM_VECTORS = 36349] = "MAX_FRAGMENT_UNIFORM_VECTORS", n[n.SHADER_TYPE = 35663] = "SHADER_TYPE", n[n.SHADING_LANGUAGE_VERSION = 35724] = "SHADING_LANGUAGE_VERSION", n[n.CURRENT_PROGRAM = 35725] = "CURRENT_PROGRAM", n[n.NEVER = 512] = "NEVER", n[n.LESS = 513] = "LESS", n[n.EQUAL = 514] = "EQUAL", n[n.LEQUAL = 515] = "LEQUAL", n[n.GREATER = 516] = "GREATER", n[n.NOTEQUAL = 517] = "NOTEQUAL", n[n.GEQUAL = 518] = "GEQUAL", n[n.ALWAYS = 519] = "ALWAYS", n[n.KEEP = 7680] = "KEEP", n[n.REPLACE = 7681] = "REPLACE", n[n.INCR = 7682] = "INCR", n[n.DECR = 7683] = "DECR", n[n.INVERT = 5386] = "INVERT", n[n.INCR_WRAP = 34055] = "INCR_WRAP", n[n.DECR_WRAP = 34056] = "DECR_WRAP", n[n.NEAREST = 9728] = "NEAREST", n[n.LINEAR = 9729] = "LINEAR", n[n.NEAREST_MIPMAP_NEAREST = 9984] = "NEAREST_MIPMAP_NEAREST", n[n.LINEAR_MIPMAP_NEAREST = 9985] = "LINEAR_MIPMAP_NEAREST", n[n.NEAREST_MIPMAP_LINEAR = 9986] = "NEAREST_MIPMAP_LINEAR", n[n.LINEAR_MIPMAP_LINEAR = 9987] = "LINEAR_MIPMAP_LINEAR", n[n.TEXTURE_MAG_FILTER = 10240] = "TEXTURE_MAG_FILTER", n[n.TEXTURE_MIN_FILTER = 10241] = "TEXTURE_MIN_FILTER", n[n.TEXTURE_WRAP_S = 10242] = "TEXTURE_WRAP_S", n[n.TEXTURE_WRAP_T = 10243] = "TEXTURE_WRAP_T", n[n.TEXTURE_2D = 3553] = "TEXTURE_2D", n[n.TEXTURE = 5890] = "TEXTURE", n[n.TEXTURE_CUBE_MAP = 34067] = "TEXTURE_CUBE_MAP", n[n.TEXTURE_BINDING_CUBE_MAP = 34068] = "TEXTURE_BINDING_CUBE_MAP", n[n.TEXTURE_CUBE_MAP_POSITIVE_X = 34069] = "TEXTURE_CUBE_MAP_POSITIVE_X", n[n.TEXTURE_CUBE_MAP_NEGATIVE_X = 34070] = "TEXTURE_CUBE_MAP_NEGATIVE_X", n[n.TEXTURE_CUBE_MAP_POSITIVE_Y = 34071] = "TEXTURE_CUBE_MAP_POSITIVE_Y", n[n.TEXTURE_CUBE_MAP_NEGATIVE_Y = 34072] = "TEXTURE_CUBE_MAP_NEGATIVE_Y", n[n.TEXTURE_CUBE_MAP_POSITIVE_Z = 34073] = "TEXTURE_CUBE_MAP_POSITIVE_Z", n[n.TEXTURE_CUBE_MAP_NEGATIVE_Z = 34074] = "TEXTURE_CUBE_MAP_NEGATIVE_Z", n[n.MAX_CUBE_MAP_TEXTURE_SIZE = 34076] = "MAX_CUBE_MAP_TEXTURE_SIZE", n[n.TEXTURE0 = 33984] = "TEXTURE0", n[n.ACTIVE_TEXTURE = 34016] = "ACTIVE_TEXTURE", n[n.REPEAT = 10497] = "REPEAT", n[n.CLAMP_TO_EDGE = 33071] = "CLAMP_TO_EDGE", n[n.MIRRORED_REPEAT = 33648] = "MIRRORED_REPEAT", n[n.TEXTURE_WIDTH = 4096] = "TEXTURE_WIDTH", n[n.TEXTURE_HEIGHT = 4097] = "TEXTURE_HEIGHT", n[n.FLOAT_VEC2 = 35664] = "FLOAT_VEC2", n[n.FLOAT_VEC3 = 35665] = "FLOAT_VEC3", n[n.FLOAT_VEC4 = 35666] = "FLOAT_VEC4", n[n.INT_VEC2 = 35667] = "INT_VEC2", n[n.INT_VEC3 = 35668] = "INT_VEC3", n[n.INT_VEC4 = 35669] = "INT_VEC4", n[n.BOOL = 35670] = "BOOL", n[n.BOOL_VEC2 = 35671] = "BOOL_VEC2", n[n.BOOL_VEC3 = 35672] = "BOOL_VEC3", n[n.BOOL_VEC4 = 35673] = "BOOL_VEC4", n[n.FLOAT_MAT2 = 35674] = "FLOAT_MAT2", n[n.FLOAT_MAT3 = 35675] = "FLOAT_MAT3", n[n.FLOAT_MAT4 = 35676] = "FLOAT_MAT4", n[n.SAMPLER_2D = 35678] = "SAMPLER_2D", n[n.SAMPLER_CUBE = 35680] = "SAMPLER_CUBE", n[n.LOW_FLOAT = 36336] = "LOW_FLOAT", n[n.MEDIUM_FLOAT = 36337] = "MEDIUM_FLOAT", n[n.HIGH_FLOAT = 36338] = "HIGH_FLOAT", n[n.LOW_INT = 36339] = "LOW_INT", n[n.MEDIUM_INT = 36340] = "MEDIUM_INT", n[n.HIGH_INT = 36341] = "HIGH_INT", n[n.FRAMEBUFFER = 36160] = "FRAMEBUFFER", n[n.RENDERBUFFER = 36161] = "RENDERBUFFER", n[n.RGBA4 = 32854] = "RGBA4", n[n.RGB5_A1 = 32855] = "RGB5_A1", n[n.RGB565 = 36194] = "RGB565", n[n.DEPTH_COMPONENT16 = 33189] = "DEPTH_COMPONENT16", n[n.STENCIL_INDEX = 6401] = "STENCIL_INDEX", n[n.STENCIL_INDEX8 = 36168] = "STENCIL_INDEX8", n[n.DEPTH_STENCIL = 34041] = "DEPTH_STENCIL", n[n.RENDERBUFFER_WIDTH = 36162] = "RENDERBUFFER_WIDTH", n[n.RENDERBUFFER_HEIGHT = 36163] = "RENDERBUFFER_HEIGHT", n[n.RENDERBUFFER_INTERNAL_FORMAT = 36164] = "RENDERBUFFER_INTERNAL_FORMAT", n[n.RENDERBUFFER_RED_SIZE = 36176] = "RENDERBUFFER_RED_SIZE", n[n.RENDERBUFFER_GREEN_SIZE = 36177] = "RENDERBUFFER_GREEN_SIZE", n[n.RENDERBUFFER_BLUE_SIZE = 36178] = "RENDERBUFFER_BLUE_SIZE", n[n.RENDERBUFFER_ALPHA_SIZE = 36179] = "RENDERBUFFER_ALPHA_SIZE", n[n.RENDERBUFFER_DEPTH_SIZE = 36180] = "RENDERBUFFER_DEPTH_SIZE", n[n.RENDERBUFFER_STENCIL_SIZE = 36181] = "RENDERBUFFER_STENCIL_SIZE", n[n.FRAMEBUFFER_ATTACHMENT_OBJECT_TYPE = 36048] = "FRAMEBUFFER_ATTACHMENT_OBJECT_TYPE", n[n.FRAMEBUFFER_ATTACHMENT_OBJECT_NAME = 36049] = "FRAMEBUFFER_ATTACHMENT_OBJECT_NAME", n[n.FRAMEBUFFER_ATTACHMENT_TEXTURE_LEVEL = 36050] = "FRAMEBUFFER_ATTACHMENT_TEXTURE_LEVEL", n[n.FRAMEBUFFER_ATTACHMENT_TEXTURE_CUBE_MAP_FACE = 36051] = "FRAMEBUFFER_ATTACHMENT_TEXTURE_CUBE_MAP_FACE", n[n.COLOR_ATTACHMENT0 = 36064] = "COLOR_ATTACHMENT0", n[n.DEPTH_ATTACHMENT = 36096] = "DEPTH_ATTACHMENT", n[n.STENCIL_ATTACHMENT = 36128] = "STENCIL_ATTACHMENT", n[n.DEPTH_STENCIL_ATTACHMENT = 33306] = "DEPTH_STENCIL_ATTACHMENT", n[n.NONE = 0] = "NONE", n[n.FRAMEBUFFER_COMPLETE = 36053] = "FRAMEBUFFER_COMPLETE", n[n.FRAMEBUFFER_INCOMPLETE_ATTACHMENT = 36054] = "FRAMEBUFFER_INCOMPLETE_ATTACHMENT", n[n.FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT = 36055] = "FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT", n[n.FRAMEBUFFER_INCOMPLETE_DIMENSIONS = 36057] = "FRAMEBUFFER_INCOMPLETE_DIMENSIONS", n[n.FRAMEBUFFER_UNSUPPORTED = 36061] = "FRAMEBUFFER_UNSUPPORTED", n[n.FRAMEBUFFER_BINDING = 36006] = "FRAMEBUFFER_BINDING", n[n.RENDERBUFFER_BINDING = 36007] = "RENDERBUFFER_BINDING", n[n.READ_FRAMEBUFFER = 36008] = "READ_FRAMEBUFFER", n[n.DRAW_FRAMEBUFFER = 36009] = "DRAW_FRAMEBUFFER", n[n.MAX_RENDERBUFFER_SIZE = 34024] = "MAX_RENDERBUFFER_SIZE", n[n.INVALID_FRAMEBUFFER_OPERATION = 1286] = "INVALID_FRAMEBUFFER_OPERATION", n[n.UNPACK_FLIP_Y_WEBGL = 37440] = "UNPACK_FLIP_Y_WEBGL", n[n.UNPACK_PREMULTIPLY_ALPHA_WEBGL = 37441] = "UNPACK_PREMULTIPLY_ALPHA_WEBGL", n[n.UNPACK_COLORSPACE_CONVERSION_WEBGL = 37443] = "UNPACK_COLORSPACE_CONVERSION_WEBGL", n[n.READ_BUFFER = 3074] = "READ_BUFFER", n[n.UNPACK_ROW_LENGTH = 3314] = "UNPACK_ROW_LENGTH", n[n.UNPACK_SKIP_ROWS = 3315] = "UNPACK_SKIP_ROWS", n[n.UNPACK_SKIP_PIXELS = 3316] = "UNPACK_SKIP_PIXELS", n[n.PACK_ROW_LENGTH = 3330] = "PACK_ROW_LENGTH", n[n.PACK_SKIP_ROWS = 3331] = "PACK_SKIP_ROWS", n[n.PACK_SKIP_PIXELS = 3332] = "PACK_SKIP_PIXELS", n[n.TEXTURE_BINDING_3D = 32874] = "TEXTURE_BINDING_3D", n[n.UNPACK_SKIP_IMAGES = 32877] = "UNPACK_SKIP_IMAGES", n[n.UNPACK_IMAGE_HEIGHT = 32878] = "UNPACK_IMAGE_HEIGHT", n[n.MAX_3D_TEXTURE_SIZE = 32883] = "MAX_3D_TEXTURE_SIZE", n[n.MAX_ELEMENTS_VERTICES = 33e3] = "MAX_ELEMENTS_VERTICES", n[n.MAX_ELEMENTS_INDICES = 33001] = "MAX_ELEMENTS_INDICES", n[n.MAX_TEXTURE_LOD_BIAS = 34045] = "MAX_TEXTURE_LOD_BIAS", n[n.MAX_FRAGMENT_UNIFORM_COMPONENTS = 35657] = "MAX_FRAGMENT_UNIFORM_COMPONENTS", n[n.MAX_VERTEX_UNIFORM_COMPONENTS = 35658] = "MAX_VERTEX_UNIFORM_COMPONENTS", n[n.MAX_ARRAY_TEXTURE_LAYERS = 35071] = "MAX_ARRAY_TEXTURE_LAYERS", n[n.MIN_PROGRAM_TEXEL_OFFSET = 35076] = "MIN_PROGRAM_TEXEL_OFFSET", n[n.MAX_PROGRAM_TEXEL_OFFSET = 35077] = "MAX_PROGRAM_TEXEL_OFFSET", n[n.MAX_VARYING_COMPONENTS = 35659] = "MAX_VARYING_COMPONENTS", n[n.FRAGMENT_SHADER_DERIVATIVE_HINT = 35723] = "FRAGMENT_SHADER_DERIVATIVE_HINT", n[n.RASTERIZER_DISCARD = 35977] = "RASTERIZER_DISCARD", n[n.VERTEX_ARRAY_BINDING = 34229] = "VERTEX_ARRAY_BINDING", n[n.MAX_VERTEX_OUTPUT_COMPONENTS = 37154] = "MAX_VERTEX_OUTPUT_COMPONENTS", n[n.MAX_FRAGMENT_INPUT_COMPONENTS = 37157] = "MAX_FRAGMENT_INPUT_COMPONENTS", n[n.MAX_SERVER_WAIT_TIMEOUT = 37137] = "MAX_SERVER_WAIT_TIMEOUT", n[n.MAX_ELEMENT_INDEX = 36203] = "MAX_ELEMENT_INDEX", n[n.RED = 6403] = "RED", n[n.RGB8 = 32849] = "RGB8", n[n.RGBA8 = 32856] = "RGBA8", n[n.RGB10_A2 = 32857] = "RGB10_A2", n[n.TEXTURE_3D = 32879] = "TEXTURE_3D", n[n.TEXTURE_WRAP_R = 32882] = "TEXTURE_WRAP_R", n[n.TEXTURE_MIN_LOD = 33082] = "TEXTURE_MIN_LOD", n[n.TEXTURE_MAX_LOD = 33083] = "TEXTURE_MAX_LOD", n[n.TEXTURE_BASE_LEVEL = 33084] = "TEXTURE_BASE_LEVEL", n[n.TEXTURE_MAX_LEVEL = 33085] = "TEXTURE_MAX_LEVEL", n[n.TEXTURE_COMPARE_MODE = 34892] = "TEXTURE_COMPARE_MODE", n[n.TEXTURE_COMPARE_FUNC = 34893] = "TEXTURE_COMPARE_FUNC", n[n.SRGB = 35904] = "SRGB", n[n.SRGB8 = 35905] = "SRGB8", n[n.SRGB8_ALPHA8 = 35907] = "SRGB8_ALPHA8", n[n.COMPARE_REF_TO_TEXTURE = 34894] = "COMPARE_REF_TO_TEXTURE", n[n.RGBA32F = 34836] = "RGBA32F", n[n.RGB32F = 34837] = "RGB32F", n[n.RGBA16F = 34842] = "RGBA16F", n[n.RGB16F = 34843] = "RGB16F", n[n.TEXTURE_2D_ARRAY = 35866] = "TEXTURE_2D_ARRAY", n[n.TEXTURE_BINDING_2D_ARRAY = 35869] = "TEXTURE_BINDING_2D_ARRAY", n[n.R11F_G11F_B10F = 35898] = "R11F_G11F_B10F", n[n.RGB9_E5 = 35901] = "RGB9_E5", n[n.RGBA32UI = 36208] = "RGBA32UI", n[n.RGB32UI = 36209] = "RGB32UI", n[n.RGBA16UI = 36214] = "RGBA16UI", n[n.RGB16UI = 36215] = "RGB16UI", n[n.RGBA8UI = 36220] = "RGBA8UI", n[n.RGB8UI = 36221] = "RGB8UI", n[n.RGBA32I = 36226] = "RGBA32I", n[n.RGB32I = 36227] = "RGB32I", n[n.RGBA16I = 36232] = "RGBA16I", n[n.RGB16I = 36233] = "RGB16I", n[n.RGBA8I = 36238] = "RGBA8I", n[n.RGB8I = 36239] = "RGB8I", n[n.RED_INTEGER = 36244] = "RED_INTEGER", n[n.RGB_INTEGER = 36248] = "RGB_INTEGER", n[n.RGBA_INTEGER = 36249] = "RGBA_INTEGER", n[n.R8 = 33321] = "R8", n[n.RG8 = 33323] = "RG8", n[n.R16F = 33325] = "R16F", n[n.R32F = 33326] = "R32F", n[n.RG16F = 33327] = "RG16F", n[n.RG32F = 33328] = "RG32F", n[n.R8I = 33329] = "R8I", n[n.R8UI = 33330] = "R8UI", n[n.R16I = 33331] = "R16I", n[n.R16UI = 33332] = "R16UI", n[n.R32I = 33333] = "R32I", n[n.R32UI = 33334] = "R32UI", n[n.RG8I = 33335] = "RG8I", n[n.RG8UI = 33336] = "RG8UI", n[n.RG16I = 33337] = "RG16I", n[n.RG16UI = 33338] = "RG16UI", n[n.RG32I = 33339] = "RG32I", n[n.RG32UI = 33340] = "RG32UI", n[n.R8_SNORM = 36756] = "R8_SNORM", n[n.RG8_SNORM = 36757] = "RG8_SNORM", n[n.RGB8_SNORM = 36758] = "RGB8_SNORM", n[n.RGBA8_SNORM = 36759] = "RGBA8_SNORM", n[n.RGB10_A2UI = 36975] = "RGB10_A2UI", n[n.TEXTURE_IMMUTABLE_FORMAT = 37167] = "TEXTURE_IMMUTABLE_FORMAT", n[n.TEXTURE_IMMUTABLE_LEVELS = 33503] = "TEXTURE_IMMUTABLE_LEVELS", n[n.UNSIGNED_INT_2_10_10_10_REV = 33640] = "UNSIGNED_INT_2_10_10_10_REV", n[n.UNSIGNED_INT_10F_11F_11F_REV = 35899] = "UNSIGNED_INT_10F_11F_11F_REV", n[n.UNSIGNED_INT_5_9_9_9_REV = 35902] = "UNSIGNED_INT_5_9_9_9_REV", n[n.FLOAT_32_UNSIGNED_INT_24_8_REV = 36269] = "FLOAT_32_UNSIGNED_INT_24_8_REV", n[n.UNSIGNED_INT_24_8 = 34042] = "UNSIGNED_INT_24_8", n[n.HALF_FLOAT = 5131] = "HALF_FLOAT", n[n.RG = 33319] = "RG", n[n.RG_INTEGER = 33320] = "RG_INTEGER", n[n.INT_2_10_10_10_REV = 36255] = "INT_2_10_10_10_REV", n[n.CURRENT_QUERY = 34917] = "CURRENT_QUERY", n[n.QUERY_RESULT = 34918] = "QUERY_RESULT", n[n.QUERY_RESULT_AVAILABLE = 34919] = "QUERY_RESULT_AVAILABLE", n[n.ANY_SAMPLES_PASSED = 35887] = "ANY_SAMPLES_PASSED", n[n.ANY_SAMPLES_PASSED_CONSERVATIVE = 36202] = "ANY_SAMPLES_PASSED_CONSERVATIVE", n[n.MAX_DRAW_BUFFERS = 34852] = "MAX_DRAW_BUFFERS", n[n.DRAW_BUFFER0 = 34853] = "DRAW_BUFFER0", n[n.DRAW_BUFFER1 = 34854] = "DRAW_BUFFER1", n[n.DRAW_BUFFER2 = 34855] = "DRAW_BUFFER2", n[n.DRAW_BUFFER3 = 34856] = "DRAW_BUFFER3", n[n.DRAW_BUFFER4 = 34857] = "DRAW_BUFFER4", n[n.DRAW_BUFFER5 = 34858] = "DRAW_BUFFER5", n[n.DRAW_BUFFER6 = 34859] = "DRAW_BUFFER6", n[n.DRAW_BUFFER7 = 34860] = "DRAW_BUFFER7", n[n.DRAW_BUFFER8 = 34861] = "DRAW_BUFFER8", n[n.DRAW_BUFFER9 = 34862] = "DRAW_BUFFER9", n[n.DRAW_BUFFER10 = 34863] = "DRAW_BUFFER10", n[n.DRAW_BUFFER11 = 34864] = "DRAW_BUFFER11", n[n.DRAW_BUFFER12 = 34865] = "DRAW_BUFFER12", n[n.DRAW_BUFFER13 = 34866] = "DRAW_BUFFER13", n[n.DRAW_BUFFER14 = 34867] = "DRAW_BUFFER14", n[n.DRAW_BUFFER15 = 34868] = "DRAW_BUFFER15", n[n.MAX_COLOR_ATTACHMENTS = 36063] = "MAX_COLOR_ATTACHMENTS", n[n.COLOR_ATTACHMENT1 = 36065] = "COLOR_ATTACHMENT1", n[n.COLOR_ATTACHMENT2 = 36066] = "COLOR_ATTACHMENT2", n[n.COLOR_ATTACHMENT3 = 36067] = "COLOR_ATTACHMENT3", n[n.COLOR_ATTACHMENT4 = 36068] = "COLOR_ATTACHMENT4", n[n.COLOR_ATTACHMENT5 = 36069] = "COLOR_ATTACHMENT5", n[n.COLOR_ATTACHMENT6 = 36070] = "COLOR_ATTACHMENT6", n[n.COLOR_ATTACHMENT7 = 36071] = "COLOR_ATTACHMENT7", n[n.COLOR_ATTACHMENT8 = 36072] = "COLOR_ATTACHMENT8", n[n.COLOR_ATTACHMENT9 = 36073] = "COLOR_ATTACHMENT9", n[n.COLOR_ATTACHMENT10 = 36074] = "COLOR_ATTACHMENT10", n[n.COLOR_ATTACHMENT11 = 36075] = "COLOR_ATTACHMENT11", n[n.COLOR_ATTACHMENT12 = 36076] = "COLOR_ATTACHMENT12", n[n.COLOR_ATTACHMENT13 = 36077] = "COLOR_ATTACHMENT13", n[n.COLOR_ATTACHMENT14 = 36078] = "COLOR_ATTACHMENT14", n[n.COLOR_ATTACHMENT15 = 36079] = "COLOR_ATTACHMENT15", n[n.SAMPLER_3D = 35679] = "SAMPLER_3D", n[n.SAMPLER_2D_SHADOW = 35682] = "SAMPLER_2D_SHADOW", n[n.SAMPLER_2D_ARRAY = 36289] = "SAMPLER_2D_ARRAY", n[n.SAMPLER_2D_ARRAY_SHADOW = 36292] = "SAMPLER_2D_ARRAY_SHADOW", n[n.SAMPLER_CUBE_SHADOW = 36293] = "SAMPLER_CUBE_SHADOW", n[n.INT_SAMPLER_2D = 36298] = "INT_SAMPLER_2D", n[n.INT_SAMPLER_3D = 36299] = "INT_SAMPLER_3D", n[n.INT_SAMPLER_CUBE = 36300] = "INT_SAMPLER_CUBE", n[n.INT_SAMPLER_2D_ARRAY = 36303] = "INT_SAMPLER_2D_ARRAY", n[n.UNSIGNED_INT_SAMPLER_2D = 36306] = "UNSIGNED_INT_SAMPLER_2D", n[n.UNSIGNED_INT_SAMPLER_3D = 36307] = "UNSIGNED_INT_SAMPLER_3D", n[n.UNSIGNED_INT_SAMPLER_CUBE = 36308] = "UNSIGNED_INT_SAMPLER_CUBE", n[n.UNSIGNED_INT_SAMPLER_2D_ARRAY = 36311] = "UNSIGNED_INT_SAMPLER_2D_ARRAY", n[n.MAX_SAMPLES = 36183] = "MAX_SAMPLES", n[n.SAMPLER_BINDING = 35097] = "SAMPLER_BINDING", n[n.PIXEL_PACK_BUFFER = 35051] = "PIXEL_PACK_BUFFER", n[n.PIXEL_UNPACK_BUFFER = 35052] = "PIXEL_UNPACK_BUFFER", n[n.PIXEL_PACK_BUFFER_BINDING = 35053] = "PIXEL_PACK_BUFFER_BINDING", n[n.PIXEL_UNPACK_BUFFER_BINDING = 35055] = "PIXEL_UNPACK_BUFFER_BINDING", n[n.COPY_READ_BUFFER = 36662] = "COPY_READ_BUFFER", n[n.COPY_WRITE_BUFFER = 36663] = "COPY_WRITE_BUFFER", n[n.COPY_READ_BUFFER_BINDING = 36662] = "COPY_READ_BUFFER_BINDING", n[n.COPY_WRITE_BUFFER_BINDING = 36663] = "COPY_WRITE_BUFFER_BINDING", n[n.FLOAT_MAT2x3 = 35685] = "FLOAT_MAT2x3", n[n.FLOAT_MAT2x4 = 35686] = "FLOAT_MAT2x4", n[n.FLOAT_MAT3x2 = 35687] = "FLOAT_MAT3x2", n[n.FLOAT_MAT3x4 = 35688] = "FLOAT_MAT3x4", n[n.FLOAT_MAT4x2 = 35689] = "FLOAT_MAT4x2", n[n.FLOAT_MAT4x3 = 35690] = "FLOAT_MAT4x3", n[n.UNSIGNED_INT_VEC2 = 36294] = "UNSIGNED_INT_VEC2", n[n.UNSIGNED_INT_VEC3 = 36295] = "UNSIGNED_INT_VEC3", n[n.UNSIGNED_INT_VEC4 = 36296] = "UNSIGNED_INT_VEC4", n[n.UNSIGNED_NORMALIZED = 35863] = "UNSIGNED_NORMALIZED", n[n.SIGNED_NORMALIZED = 36764] = "SIGNED_NORMALIZED", n[n.VERTEX_ATTRIB_ARRAY_INTEGER = 35069] = "VERTEX_ATTRIB_ARRAY_INTEGER", n[n.VERTEX_ATTRIB_ARRAY_DIVISOR = 35070] = "VERTEX_ATTRIB_ARRAY_DIVISOR", n[n.TRANSFORM_FEEDBACK_BUFFER_MODE = 35967] = "TRANSFORM_FEEDBACK_BUFFER_MODE", n[n.MAX_TRANSFORM_FEEDBACK_SEPARATE_COMPONENTS = 35968] = "MAX_TRANSFORM_FEEDBACK_SEPARATE_COMPONENTS", n[n.TRANSFORM_FEEDBACK_VARYINGS = 35971] = "TRANSFORM_FEEDBACK_VARYINGS", n[n.TRANSFORM_FEEDBACK_BUFFER_START = 35972] = "TRANSFORM_FEEDBACK_BUFFER_START", n[n.TRANSFORM_FEEDBACK_BUFFER_SIZE = 35973] = "TRANSFORM_FEEDBACK_BUFFER_SIZE", n[n.TRANSFORM_FEEDBACK_PRIMITIVES_WRITTEN = 35976] = "TRANSFORM_FEEDBACK_PRIMITIVES_WRITTEN", n[n.MAX_TRANSFORM_FEEDBACK_INTERLEAVED_COMPONENTS = 35978] = "MAX_TRANSFORM_FEEDBACK_INTERLEAVED_COMPONENTS", n[n.MAX_TRANSFORM_FEEDBACK_SEPARATE_ATTRIBS = 35979] = "MAX_TRANSFORM_FEEDBACK_SEPARATE_ATTRIBS", n[n.INTERLEAVED_ATTRIBS = 35980] = "INTERLEAVED_ATTRIBS", n[n.SEPARATE_ATTRIBS = 35981] = "SEPARATE_ATTRIBS", n[n.TRANSFORM_FEEDBACK_BUFFER = 35982] = "TRANSFORM_FEEDBACK_BUFFER", n[n.TRANSFORM_FEEDBACK_BUFFER_BINDING = 35983] = "TRANSFORM_FEEDBACK_BUFFER_BINDING", n[n.TRANSFORM_FEEDBACK = 36386] = "TRANSFORM_FEEDBACK", n[n.TRANSFORM_FEEDBACK_PAUSED = 36387] = "TRANSFORM_FEEDBACK_PAUSED", n[n.TRANSFORM_FEEDBACK_ACTIVE = 36388] = "TRANSFORM_FEEDBACK_ACTIVE", n[n.TRANSFORM_FEEDBACK_BINDING = 36389] = "TRANSFORM_FEEDBACK_BINDING", n[n.FRAMEBUFFER_ATTACHMENT_COLOR_ENCODING = 33296] = "FRAMEBUFFER_ATTACHMENT_COLOR_ENCODING", n[n.FRAMEBUFFER_ATTACHMENT_COMPONENT_TYPE = 33297] = "FRAMEBUFFER_ATTACHMENT_COMPONENT_TYPE", n[n.FRAMEBUFFER_ATTACHMENT_RED_SIZE = 33298] = "FRAMEBUFFER_ATTACHMENT_RED_SIZE", n[n.FRAMEBUFFER_ATTACHMENT_GREEN_SIZE = 33299] = "FRAMEBUFFER_ATTACHMENT_GREEN_SIZE", n[n.FRAMEBUFFER_ATTACHMENT_BLUE_SIZE = 33300] = "FRAMEBUFFER_ATTACHMENT_BLUE_SIZE", n[n.FRAMEBUFFER_ATTACHMENT_ALPHA_SIZE = 33301] = "FRAMEBUFFER_ATTACHMENT_ALPHA_SIZE", n[n.FRAMEBUFFER_ATTACHMENT_DEPTH_SIZE = 33302] = "FRAMEBUFFER_ATTACHMENT_DEPTH_SIZE", n[n.FRAMEBUFFER_ATTACHMENT_STENCIL_SIZE = 33303] = "FRAMEBUFFER_ATTACHMENT_STENCIL_SIZE", n[n.FRAMEBUFFER_DEFAULT = 33304] = "FRAMEBUFFER_DEFAULT", n[n.DEPTH24_STENCIL8 = 35056] = "DEPTH24_STENCIL8", n[n.DRAW_FRAMEBUFFER_BINDING = 36006] = "DRAW_FRAMEBUFFER_BINDING", n[n.READ_FRAMEBUFFER_BINDING = 36010] = "READ_FRAMEBUFFER_BINDING", n[n.RENDERBUFFER_SAMPLES = 36011] = "RENDERBUFFER_SAMPLES", n[n.FRAMEBUFFER_ATTACHMENT_TEXTURE_LAYER = 36052] = "FRAMEBUFFER_ATTACHMENT_TEXTURE_LAYER", n[n.FRAMEBUFFER_INCOMPLETE_MULTISAMPLE = 36182] = "FRAMEBUFFER_INCOMPLETE_MULTISAMPLE", n[n.UNIFORM_BUFFER = 35345] = "UNIFORM_BUFFER", n[n.UNIFORM_BUFFER_BINDING = 35368] = "UNIFORM_BUFFER_BINDING", n[n.UNIFORM_BUFFER_START = 35369] = "UNIFORM_BUFFER_START", n[n.UNIFORM_BUFFER_SIZE = 35370] = "UNIFORM_BUFFER_SIZE", n[n.MAX_VERTEX_UNIFORM_BLOCKS = 35371] = "MAX_VERTEX_UNIFORM_BLOCKS", n[n.MAX_FRAGMENT_UNIFORM_BLOCKS = 35373] = "MAX_FRAGMENT_UNIFORM_BLOCKS", n[n.MAX_COMBINED_UNIFORM_BLOCKS = 35374] = "MAX_COMBINED_UNIFORM_BLOCKS", n[n.MAX_UNIFORM_BUFFER_BINDINGS = 35375] = "MAX_UNIFORM_BUFFER_BINDINGS", n[n.MAX_UNIFORM_BLOCK_SIZE = 35376] = "MAX_UNIFORM_BLOCK_SIZE", n[n.MAX_COMBINED_VERTEX_UNIFORM_COMPONENTS = 35377] = "MAX_COMBINED_VERTEX_UNIFORM_COMPONENTS", n[n.MAX_COMBINED_FRAGMENT_UNIFORM_COMPONENTS = 35379] = "MAX_COMBINED_FRAGMENT_UNIFORM_COMPONENTS", n[n.UNIFORM_BUFFER_OFFSET_ALIGNMENT = 35380] = "UNIFORM_BUFFER_OFFSET_ALIGNMENT", n[n.ACTIVE_UNIFORM_BLOCKS = 35382] = "ACTIVE_UNIFORM_BLOCKS", n[n.UNIFORM_TYPE = 35383] = "UNIFORM_TYPE", n[n.UNIFORM_SIZE = 35384] = "UNIFORM_SIZE", n[n.UNIFORM_BLOCK_INDEX = 35386] = "UNIFORM_BLOCK_INDEX", n[n.UNIFORM_OFFSET = 35387] = "UNIFORM_OFFSET", n[n.UNIFORM_ARRAY_STRIDE = 35388] = "UNIFORM_ARRAY_STRIDE", n[n.UNIFORM_MATRIX_STRIDE = 35389] = "UNIFORM_MATRIX_STRIDE", n[n.UNIFORM_IS_ROW_MAJOR = 35390] = "UNIFORM_IS_ROW_MAJOR", n[n.UNIFORM_BLOCK_BINDING = 35391] = "UNIFORM_BLOCK_BINDING", n[n.UNIFORM_BLOCK_DATA_SIZE = 35392] = "UNIFORM_BLOCK_DATA_SIZE", n[n.UNIFORM_BLOCK_ACTIVE_UNIFORMS = 35394] = "UNIFORM_BLOCK_ACTIVE_UNIFORMS", n[n.UNIFORM_BLOCK_ACTIVE_UNIFORM_INDICES = 35395] = "UNIFORM_BLOCK_ACTIVE_UNIFORM_INDICES", n[n.UNIFORM_BLOCK_REFERENCED_BY_VERTEX_SHADER = 35396] = "UNIFORM_BLOCK_REFERENCED_BY_VERTEX_SHADER", n[n.UNIFORM_BLOCK_REFERENCED_BY_FRAGMENT_SHADER = 35398] = "UNIFORM_BLOCK_REFERENCED_BY_FRAGMENT_SHADER", n[n.OBJECT_TYPE = 37138] = "OBJECT_TYPE", n[n.SYNC_CONDITION = 37139] = "SYNC_CONDITION", n[n.SYNC_STATUS = 37140] = "SYNC_STATUS", n[n.SYNC_FLAGS = 37141] = "SYNC_FLAGS", n[n.SYNC_FENCE = 37142] = "SYNC_FENCE", n[n.SYNC_GPU_COMMANDS_COMPLETE = 37143] = "SYNC_GPU_COMMANDS_COMPLETE", n[n.UNSIGNALED = 37144] = "UNSIGNALED", n[n.SIGNALED = 37145] = "SIGNALED", n[n.ALREADY_SIGNALED = 37146] = "ALREADY_SIGNALED", n[n.TIMEOUT_EXPIRED = 37147] = "TIMEOUT_EXPIRED", n[n.CONDITION_SATISFIED = 37148] = "CONDITION_SATISFIED", n[n.WAIT_FAILED = 37149] = "WAIT_FAILED", n[n.SYNC_FLUSH_COMMANDS_BIT = 1] = "SYNC_FLUSH_COMMANDS_BIT", n[n.COLOR = 6144] = "COLOR", n[n.DEPTH = 6145] = "DEPTH", n[n.STENCIL = 6146] = "STENCIL", n[n.MIN = 32775] = "MIN", n[n.MAX = 32776] = "MAX", n[n.DEPTH_COMPONENT24 = 33190] = "DEPTH_COMPONENT24", n[n.STREAM_READ = 35041] = "STREAM_READ", n[n.STREAM_COPY = 35042] = "STREAM_COPY", n[n.STATIC_READ = 35045] = "STATIC_READ", n[n.STATIC_COPY = 35046] = "STATIC_COPY", n[n.DYNAMIC_READ = 35049] = "DYNAMIC_READ", n[n.DYNAMIC_COPY = 35050] = "DYNAMIC_COPY", n[n.DEPTH_COMPONENT32F = 36012] = "DEPTH_COMPONENT32F", n[n.DEPTH32F_STENCIL8 = 36013] = "DEPTH32F_STENCIL8", n[n.INVALID_INDEX = 4294967295] = "INVALID_INDEX", n[n.TIMEOUT_IGNORED = -1] = "TIMEOUT_IGNORED", n[n.MAX_CLIENT_WAIT_TIMEOUT_WEBGL = 37447] = "MAX_CLIENT_WAIT_TIMEOUT_WEBGL", n[n.UNMASKED_VENDOR_WEBGL = 37445] = "UNMASKED_VENDOR_WEBGL", n[n.UNMASKED_RENDERER_WEBGL = 37446] = "UNMASKED_RENDERER_WEBGL", n[n.MAX_TEXTURE_MAX_ANISOTROPY_EXT = 34047] = "MAX_TEXTURE_MAX_ANISOTROPY_EXT", n[n.TEXTURE_MAX_ANISOTROPY_EXT = 34046] = "TEXTURE_MAX_ANISOTROPY_EXT", n[n.R16_EXT = 33322] = "R16_EXT", n[n.RG16_EXT = 33324] = "RG16_EXT", n[n.RGB16_EXT = 32852] = "RGB16_EXT", n[n.RGBA16_EXT = 32859] = "RGBA16_EXT", n[n.R16_SNORM_EXT = 36760] = "R16_SNORM_EXT", n[n.RG16_SNORM_EXT = 36761] = "RG16_SNORM_EXT", n[n.RGB16_SNORM_EXT = 36762] = "RGB16_SNORM_EXT", n[n.RGBA16_SNORM_EXT = 36763] = "RGBA16_SNORM_EXT", n[n.COMPRESSED_RGB_S3TC_DXT1_EXT = 33776] = "COMPRESSED_RGB_S3TC_DXT1_EXT", n[n.COMPRESSED_RGBA_S3TC_DXT1_EXT = 33777] = "COMPRESSED_RGBA_S3TC_DXT1_EXT", n[n.COMPRESSED_RGBA_S3TC_DXT3_EXT = 33778] = "COMPRESSED_RGBA_S3TC_DXT3_EXT", n[n.COMPRESSED_RGBA_S3TC_DXT5_EXT = 33779] = "COMPRESSED_RGBA_S3TC_DXT5_EXT", n[n.COMPRESSED_SRGB_S3TC_DXT1_EXT = 35916] = "COMPRESSED_SRGB_S3TC_DXT1_EXT", n[n.COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT = 35917] = "COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT", n[n.COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT = 35918] = "COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT", n[n.COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT = 35919] = "COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT", n[n.COMPRESSED_RED_RGTC1_EXT = 36283] = "COMPRESSED_RED_RGTC1_EXT", n[n.COMPRESSED_SIGNED_RED_RGTC1_EXT = 36284] = "COMPRESSED_SIGNED_RED_RGTC1_EXT", n[n.COMPRESSED_RED_GREEN_RGTC2_EXT = 36285] = "COMPRESSED_RED_GREEN_RGTC2_EXT", n[n.COMPRESSED_SIGNED_RED_GREEN_RGTC2_EXT = 36286] = "COMPRESSED_SIGNED_RED_GREEN_RGTC2_EXT", n[n.COMPRESSED_RGBA_BPTC_UNORM_EXT = 36492] = "COMPRESSED_RGBA_BPTC_UNORM_EXT", n[n.COMPRESSED_SRGB_ALPHA_BPTC_UNORM_EXT = 36493] = "COMPRESSED_SRGB_ALPHA_BPTC_UNORM_EXT", n[n.COMPRESSED_RGB_BPTC_SIGNED_FLOAT_EXT = 36494] = "COMPRESSED_RGB_BPTC_SIGNED_FLOAT_EXT", n[n.COMPRESSED_RGB_BPTC_UNSIGNED_FLOAT_EXT = 36495] = "COMPRESSED_RGB_BPTC_UNSIGNED_FLOAT_EXT", n[n.COMPRESSED_R11_EAC = 37488] = "COMPRESSED_R11_EAC", n[n.COMPRESSED_SIGNED_R11_EAC = 37489] = "COMPRESSED_SIGNED_R11_EAC", n[n.COMPRESSED_RG11_EAC = 37490] = "COMPRESSED_RG11_EAC", n[n.COMPRESSED_SIGNED_RG11_EAC = 37491] = "COMPRESSED_SIGNED_RG11_EAC", n[n.COMPRESSED_RGB8_ETC2 = 37492] = "COMPRESSED_RGB8_ETC2", n[n.COMPRESSED_RGBA8_ETC2_EAC = 37493] = "COMPRESSED_RGBA8_ETC2_EAC", n[n.COMPRESSED_SRGB8_ETC2 = 37494] = "COMPRESSED_SRGB8_ETC2", n[n.COMPRESSED_SRGB8_ALPHA8_ETC2_EAC = 37495] = "COMPRESSED_SRGB8_ALPHA8_ETC2_EAC", n[n.COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2 = 37496] = "COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2", n[n.COMPRESSED_SRGB8_PUNCHTHROUGH_ALPHA1_ETC2 = 37497] = "COMPRESSED_SRGB8_PUNCHTHROUGH_ALPHA1_ETC2", n[n.COMPRESSED_RGB_PVRTC_4BPPV1_IMG = 35840] = "COMPRESSED_RGB_PVRTC_4BPPV1_IMG", n[n.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG = 35842] = "COMPRESSED_RGBA_PVRTC_4BPPV1_IMG", n[n.COMPRESSED_RGB_PVRTC_2BPPV1_IMG = 35841] = "COMPRESSED_RGB_PVRTC_2BPPV1_IMG", n[n.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG = 35843] = "COMPRESSED_RGBA_PVRTC_2BPPV1_IMG", n[n.COMPRESSED_RGB_ETC1_WEBGL = 36196] = "COMPRESSED_RGB_ETC1_WEBGL", n[n.COMPRESSED_RGB_ATC_WEBGL = 35986] = "COMPRESSED_RGB_ATC_WEBGL", n[n.COMPRESSED_RGBA_ATC_EXPLICIT_ALPHA_WEBGL = 35986] = "COMPRESSED_RGBA_ATC_EXPLICIT_ALPHA_WEBGL", n[n.COMPRESSED_RGBA_ATC_INTERPOLATED_ALPHA_WEBGL = 34798] = "COMPRESSED_RGBA_ATC_INTERPOLATED_ALPHA_WEBGL", n[n.COMPRESSED_RGBA_ASTC_4x4_KHR = 37808] = "COMPRESSED_RGBA_ASTC_4x4_KHR", n[n.COMPRESSED_RGBA_ASTC_5x4_KHR = 37809] = "COMPRESSED_RGBA_ASTC_5x4_KHR", n[n.COMPRESSED_RGBA_ASTC_5x5_KHR = 37810] = "COMPRESSED_RGBA_ASTC_5x5_KHR", n[n.COMPRESSED_RGBA_ASTC_6x5_KHR = 37811] = "COMPRESSED_RGBA_ASTC_6x5_KHR", n[n.COMPRESSED_RGBA_ASTC_6x6_KHR = 37812] = "COMPRESSED_RGBA_ASTC_6x6_KHR", n[n.COMPRESSED_RGBA_ASTC_8x5_KHR = 37813] = "COMPRESSED_RGBA_ASTC_8x5_KHR", n[n.COMPRESSED_RGBA_ASTC_8x6_KHR = 37814] = "COMPRESSED_RGBA_ASTC_8x6_KHR", n[n.COMPRESSED_RGBA_ASTC_8x8_KHR = 37815] = "COMPRESSED_RGBA_ASTC_8x8_KHR", n[n.COMPRESSED_RGBA_ASTC_10x5_KHR = 37816] = "COMPRESSED_RGBA_ASTC_10x5_KHR", n[n.COMPRESSED_RGBA_ASTC_10x6_KHR = 37817] = "COMPRESSED_RGBA_ASTC_10x6_KHR", n[n.COMPRESSED_RGBA_ASTC_10x8_KHR = 37818] = "COMPRESSED_RGBA_ASTC_10x8_KHR", n[n.COMPRESSED_RGBA_ASTC_10x10_KHR = 37819] = "COMPRESSED_RGBA_ASTC_10x10_KHR", n[n.COMPRESSED_RGBA_ASTC_12x10_KHR = 37820] = "COMPRESSED_RGBA_ASTC_12x10_KHR", n[n.COMPRESSED_RGBA_ASTC_12x12_KHR = 37821] = "COMPRESSED_RGBA_ASTC_12x12_KHR", n[n.COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR = 37840] = "COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR", n[n.COMPRESSED_SRGB8_ALPHA8_ASTC_5x4_KHR = 37841] = "COMPRESSED_SRGB8_ALPHA8_ASTC_5x4_KHR", n[n.COMPRESSED_SRGB8_ALPHA8_ASTC_5x5_KHR = 37842] = "COMPRESSED_SRGB8_ALPHA8_ASTC_5x5_KHR", n[n.COMPRESSED_SRGB8_ALPHA8_ASTC_6x5_KHR = 37843] = "COMPRESSED_SRGB8_ALPHA8_ASTC_6x5_KHR", n[n.COMPRESSED_SRGB8_ALPHA8_ASTC_6x6_KHR = 37844] = "COMPRESSED_SRGB8_ALPHA8_ASTC_6x6_KHR", n[n.COMPRESSED_SRGB8_ALPHA8_ASTC_8x5_KHR = 37845] = "COMPRESSED_SRGB8_ALPHA8_ASTC_8x5_KHR", n[n.COMPRESSED_SRGB8_ALPHA8_ASTC_8x6_KHR = 37846] = "COMPRESSED_SRGB8_ALPHA8_ASTC_8x6_KHR", n[n.COMPRESSED_SRGB8_ALPHA8_ASTC_8x8_KHR = 37847] = "COMPRESSED_SRGB8_ALPHA8_ASTC_8x8_KHR", n[n.COMPRESSED_SRGB8_ALPHA8_ASTC_10x5_KHR = 37848] = "COMPRESSED_SRGB8_ALPHA8_ASTC_10x5_KHR", n[n.COMPRESSED_SRGB8_ALPHA8_ASTC_10x6_KHR = 37849] = "COMPRESSED_SRGB8_ALPHA8_ASTC_10x6_KHR", n[n.COMPRESSED_SRGB8_ALPHA8_ASTC_10x8_KHR = 37850] = "COMPRESSED_SRGB8_ALPHA8_ASTC_10x8_KHR", n[n.COMPRESSED_SRGB8_ALPHA8_ASTC_10x10_KHR = 37851] = "COMPRESSED_SRGB8_ALPHA8_ASTC_10x10_KHR", n[n.COMPRESSED_SRGB8_ALPHA8_ASTC_12x10_KHR = 37852] = "COMPRESSED_SRGB8_ALPHA8_ASTC_12x10_KHR", n[n.COMPRESSED_SRGB8_ALPHA8_ASTC_12x12_KHR = 37853] = "COMPRESSED_SRGB8_ALPHA8_ASTC_12x12_KHR", n[n.QUERY_COUNTER_BITS_EXT = 34916] = "QUERY_COUNTER_BITS_EXT", n[n.CURRENT_QUERY_EXT = 34917] = "CURRENT_QUERY_EXT", n[n.QUERY_RESULT_EXT = 34918] = "QUERY_RESULT_EXT", n[n.QUERY_RESULT_AVAILABLE_EXT = 34919] = "QUERY_RESULT_AVAILABLE_EXT", n[n.TIME_ELAPSED_EXT = 35007] = "TIME_ELAPSED_EXT", n[n.TIMESTAMP_EXT = 36392] = "TIMESTAMP_EXT", n[n.GPU_DISJOINT_EXT = 36795] = "GPU_DISJOINT_EXT", n[n.COMPLETION_STATUS_KHR = 37297] = "COMPLETION_STATUS_KHR", n[n.DEPTH_CLAMP_EXT = 34383] = "DEPTH_CLAMP_EXT", n[n.FIRST_VERTEX_CONVENTION_WEBGL = 36429] = "FIRST_VERTEX_CONVENTION_WEBGL", n[n.LAST_VERTEX_CONVENTION_WEBGL = 36430] = "LAST_VERTEX_CONVENTION_WEBGL", n[n.PROVOKING_VERTEX_WEBL = 36431] = "PROVOKING_VERTEX_WEBL", n[n.POLYGON_MODE_WEBGL = 2880] = "POLYGON_MODE_WEBGL", n[n.POLYGON_OFFSET_LINE_WEBGL = 10754] = "POLYGON_OFFSET_LINE_WEBGL", n[n.LINE_WEBGL = 6913] = "LINE_WEBGL", n[n.FILL_WEBGL = 6914] = "FILL_WEBGL", n[n.MAX_CLIP_DISTANCES_WEBGL = 3378] = "MAX_CLIP_DISTANCES_WEBGL", n[n.MAX_CULL_DISTANCES_WEBGL = 33529] = "MAX_CULL_DISTANCES_WEBGL", n[n.MAX_COMBINED_CLIP_AND_CULL_DISTANCES_WEBGL = 33530] = "MAX_COMBINED_CLIP_AND_CULL_DISTANCES_WEBGL", n[n.CLIP_DISTANCE0_WEBGL = 12288] = "CLIP_DISTANCE0_WEBGL", n[n.CLIP_DISTANCE1_WEBGL = 12289] = "CLIP_DISTANCE1_WEBGL", n[n.CLIP_DISTANCE2_WEBGL = 12290] = "CLIP_DISTANCE2_WEBGL", n[n.CLIP_DISTANCE3_WEBGL = 12291] = "CLIP_DISTANCE3_WEBGL", n[n.CLIP_DISTANCE4_WEBGL = 12292] = "CLIP_DISTANCE4_WEBGL", n[n.CLIP_DISTANCE5_WEBGL = 12293] = "CLIP_DISTANCE5_WEBGL", n[n.CLIP_DISTANCE6_WEBGL = 12294] = "CLIP_DISTANCE6_WEBGL", n[n.CLIP_DISTANCE7_WEBGL = 12295] = "CLIP_DISTANCE7_WEBGL", n[n.POLYGON_OFFSET_CLAMP_EXT = 36379] = "POLYGON_OFFSET_CLAMP_EXT", n[n.LOWER_LEFT_EXT = 36001] = "LOWER_LEFT_EXT", n[n.UPPER_LEFT_EXT = 36002] = "UPPER_LEFT_EXT", n[n.NEGATIVE_ONE_TO_ONE_EXT = 37726] = "NEGATIVE_ONE_TO_ONE_EXT", n[n.ZERO_TO_ONE_EXT = 37727] = "ZERO_TO_ONE_EXT", n[n.CLIP_ORIGIN_EXT = 37724] = "CLIP_ORIGIN_EXT", n[n.CLIP_DEPTH_MODE_EXT = 37725] = "CLIP_DEPTH_MODE_EXT", n[n.SRC1_COLOR_WEBGL = 35065] = "SRC1_COLOR_WEBGL", n[n.SRC1_ALPHA_WEBGL = 34185] = "SRC1_ALPHA_WEBGL", n[n.ONE_MINUS_SRC1_COLOR_WEBGL = 35066] = "ONE_MINUS_SRC1_COLOR_WEBGL", n[n.ONE_MINUS_SRC1_ALPHA_WEBGL = 35067] = "ONE_MINUS_SRC1_ALPHA_WEBGL", n[n.MAX_DUAL_SOURCE_DRAW_BUFFERS_WEBGL = 35068] = "MAX_DUAL_SOURCE_DRAW_BUFFERS_WEBGL", n[n.MIRROR_CLAMP_TO_EDGE_EXT = 34627] = "MIRROR_CLAMP_TO_EDGE_EXT";
    })(ks || (ks = {}));
    const Bg = {
        3042: !1,
        32773: new Float32Array([
            0,
            0,
            0,
            0
        ]),
        32777: 32774,
        34877: 32774,
        32969: 1,
        32968: 0,
        32971: 1,
        32970: 0,
        3106: new Float32Array([
            0,
            0,
            0,
            0
        ]),
        3107: [
            !0,
            !0,
            !0,
            !0
        ],
        2884: !1,
        2885: 1029,
        2929: !1,
        2931: 1,
        2932: 513,
        2928: new Float32Array([
            0,
            1
        ]),
        2930: !0,
        3024: !0,
        35725: null,
        36006: null,
        36007: null,
        34229: null,
        34964: null,
        2886: 2305,
        33170: 4352,
        2849: 1,
        32823: !1,
        32824: 0,
        10752: 0,
        32926: !1,
        32928: !1,
        32938: 1,
        32939: !1,
        3089: !1,
        3088: new Int32Array([
            0,
            0,
            1024,
            1024
        ]),
        2960: !1,
        2961: 0,
        2968: 4294967295,
        36005: 4294967295,
        2962: 519,
        2967: 0,
        2963: 4294967295,
        34816: 519,
        36003: 0,
        36004: 4294967295,
        2964: 7680,
        2965: 7680,
        2966: 7680,
        34817: 7680,
        34818: 7680,
        34819: 7680,
        2978: [
            0,
            0,
            1024,
            1024
        ],
        36389: null,
        36662: null,
        36663: null,
        35053: null,
        35055: null,
        35723: 4352,
        36010: null,
        35977: !1,
        3333: 4,
        3317: 4,
        37440: !1,
        37441: !1,
        37443: 37444,
        3330: 0,
        3332: 0,
        3331: 0,
        3314: 0,
        32878: 0,
        3316: 0,
        3315: 0,
        32877: 0
    }, ut = (n, e, t)=>e ? n.enable(t) : n.disable(t), L0 = (n, e, t)=>n.hint(t, e), tn = (n, e, t)=>n.pixelStorei(t, e), F0 = (n, e, t)=>{
        const i = t === 36006 ? 36009 : 36008;
        return n.bindFramebuffer(i, e);
    }, ro = (n, e, t)=>{
        const r = {
            34964: 34962,
            36662: 36662,
            36663: 36663,
            35053: 35051,
            35055: 35052
        }[t];
        n.bindBuffer(r, e);
    };
    function sd(n) {
        return Array.isArray(n) || ArrayBuffer.isView(n) && !(n instanceof DataView);
    }
    const tN = {
        3042: ut,
        32773: (n, e)=>n.blendColor(...e),
        32777: "blendEquation",
        34877: "blendEquation",
        32969: "blendFunc",
        32968: "blendFunc",
        32971: "blendFunc",
        32970: "blendFunc",
        3106: (n, e)=>n.clearColor(...e),
        3107: (n, e)=>n.colorMask(...e),
        2884: ut,
        2885: (n, e)=>n.cullFace(e),
        2929: ut,
        2931: (n, e)=>n.clearDepth(e),
        2932: (n, e)=>n.depthFunc(e),
        2928: (n, e)=>n.depthRange(...e),
        2930: (n, e)=>n.depthMask(e),
        3024: ut,
        35723: L0,
        35725: (n, e)=>n.useProgram(e),
        36007: (n, e)=>n.bindRenderbuffer(36161, e),
        36389: (n, e)=>n.bindTransformFeedback?.(36386, e),
        34229: (n, e)=>n.bindVertexArray(e),
        36006: F0,
        36010: F0,
        34964: ro,
        36662: ro,
        36663: ro,
        35053: ro,
        35055: ro,
        2886: (n, e)=>n.frontFace(e),
        33170: L0,
        2849: (n, e)=>n.lineWidth(e),
        32823: ut,
        32824: "polygonOffset",
        10752: "polygonOffset",
        35977: ut,
        32926: ut,
        32928: ut,
        32938: "sampleCoverage",
        32939: "sampleCoverage",
        3089: ut,
        3088: (n, e)=>n.scissor(...e),
        2960: ut,
        2961: (n, e)=>n.clearStencil(e),
        2968: (n, e)=>n.stencilMaskSeparate(1028, e),
        36005: (n, e)=>n.stencilMaskSeparate(1029, e),
        2962: "stencilFuncFront",
        2967: "stencilFuncFront",
        2963: "stencilFuncFront",
        34816: "stencilFuncBack",
        36003: "stencilFuncBack",
        36004: "stencilFuncBack",
        2964: "stencilOpFront",
        2965: "stencilOpFront",
        2966: "stencilOpFront",
        34817: "stencilOpBack",
        34818: "stencilOpBack",
        34819: "stencilOpBack",
        2978: (n, e)=>n.viewport(...e),
        34383: ut,
        10754: ut,
        12288: ut,
        12289: ut,
        12290: ut,
        12291: ut,
        12292: ut,
        12293: ut,
        12294: ut,
        12295: ut,
        3333: tn,
        3317: tn,
        37440: tn,
        37441: tn,
        37443: tn,
        3330: tn,
        3332: tn,
        3331: tn,
        3314: tn,
        32878: tn,
        3316: tn,
        3315: tn,
        32877: tn,
        framebuffer: (n, e)=>{
            const t = e && "handle" in e ? e.handle : e;
            return n.bindFramebuffer(36160, t);
        },
        blend: (n, e)=>e ? n.enable(3042) : n.disable(3042),
        blendColor: (n, e)=>n.blendColor(...e),
        blendEquation: (n, e)=>{
            const t = typeof e == "number" ? [
                e,
                e
            ] : e;
            n.blendEquationSeparate(...t);
        },
        blendFunc: (n, e)=>{
            const t = e?.length === 2 ? [
                ...e,
                ...e
            ] : e;
            n.blendFuncSeparate(...t);
        },
        clearColor: (n, e)=>n.clearColor(...e),
        clearDepth: (n, e)=>n.clearDepth(e),
        clearStencil: (n, e)=>n.clearStencil(e),
        colorMask: (n, e)=>n.colorMask(...e),
        cull: (n, e)=>e ? n.enable(2884) : n.disable(2884),
        cullFace: (n, e)=>n.cullFace(e),
        depthTest: (n, e)=>e ? n.enable(2929) : n.disable(2929),
        depthFunc: (n, e)=>n.depthFunc(e),
        depthMask: (n, e)=>n.depthMask(e),
        depthRange: (n, e)=>n.depthRange(...e),
        dither: (n, e)=>e ? n.enable(3024) : n.disable(3024),
        derivativeHint: (n, e)=>{
            n.hint(35723, e);
        },
        frontFace: (n, e)=>n.frontFace(e),
        mipmapHint: (n, e)=>n.hint(33170, e),
        lineWidth: (n, e)=>n.lineWidth(e),
        polygonOffsetFill: (n, e)=>e ? n.enable(32823) : n.disable(32823),
        polygonOffset: (n, e)=>n.polygonOffset(...e),
        sampleCoverage: (n, e)=>n.sampleCoverage(e[0], e[1] || !1),
        scissorTest: (n, e)=>e ? n.enable(3089) : n.disable(3089),
        scissor: (n, e)=>n.scissor(...e),
        stencilTest: (n, e)=>e ? n.enable(2960) : n.disable(2960),
        stencilMask: (n, e)=>{
            e = sd(e) ? e : [
                e,
                e
            ];
            const [t, i] = e;
            n.stencilMaskSeparate(1028, t), n.stencilMaskSeparate(1029, i);
        },
        stencilFunc: (n, e)=>{
            e = sd(e) && e.length === 3 ? [
                ...e,
                ...e
            ] : e;
            const [t, i, r, a, l, u] = e;
            n.stencilFuncSeparate(1028, t, i, r), n.stencilFuncSeparate(1029, a, l, u);
        },
        stencilOp: (n, e)=>{
            e = sd(e) && e.length === 3 ? [
                ...e,
                ...e
            ] : e;
            const [t, i, r, a, l, u] = e;
            n.stencilOpSeparate(1028, t, i, r), n.stencilOpSeparate(1029, a, l, u);
        },
        viewport: (n, e)=>n.viewport(...e)
    };
    function rt(n, e, t) {
        return e[n] !== void 0 ? e[n] : t[n];
    }
    const nN = {
        blendEquation: (n, e, t)=>n.blendEquationSeparate(rt(32777, e, t), rt(34877, e, t)),
        blendFunc: (n, e, t)=>n.blendFuncSeparate(rt(32969, e, t), rt(32968, e, t), rt(32971, e, t), rt(32970, e, t)),
        polygonOffset: (n, e, t)=>n.polygonOffset(rt(32824, e, t), rt(10752, e, t)),
        sampleCoverage: (n, e, t)=>n.sampleCoverage(rt(32938, e, t), rt(32939, e, t)),
        stencilFuncFront: (n, e, t)=>n.stencilFuncSeparate(1028, rt(2962, e, t), rt(2967, e, t), rt(2963, e, t)),
        stencilFuncBack: (n, e, t)=>n.stencilFuncSeparate(1029, rt(34816, e, t), rt(36003, e, t), rt(36004, e, t)),
        stencilOpFront: (n, e, t)=>n.stencilOpSeparate(1028, rt(2964, e, t), rt(2965, e, t), rt(2966, e, t)),
        stencilOpBack: (n, e, t)=>n.stencilOpSeparate(1029, rt(34817, e, t), rt(34818, e, t), rt(34819, e, t))
    }, z0 = {
        enable: (n, e)=>n({
                [e]: !0
            }),
        disable: (n, e)=>n({
                [e]: !1
            }),
        pixelStorei: (n, e, t)=>n({
                [e]: t
            }),
        hint: (n, e, t)=>n({
                [e]: t
            }),
        useProgram: (n, e)=>n({
                35725: e
            }),
        bindRenderbuffer: (n, e, t)=>n({
                36007: t
            }),
        bindTransformFeedback: (n, e, t)=>n({
                36389: t
            }),
        bindVertexArray: (n, e)=>n({
                34229: e
            }),
        bindFramebuffer: (n, e, t)=>{
            switch(e){
                case 36160:
                    return n({
                        36006: t,
                        36010: t
                    });
                case 36009:
                    return n({
                        36006: t
                    });
                case 36008:
                    return n({
                        36010: t
                    });
                default:
                    return null;
            }
        },
        bindBuffer: (n, e, t)=>{
            const i = {
                34962: [
                    34964
                ],
                36662: [
                    36662
                ],
                36663: [
                    36663
                ],
                35051: [
                    35053
                ],
                35052: [
                    35055
                ]
            }[e];
            return i ? n({
                [i]: t
            }) : {
                valueChanged: !0
            };
        },
        blendColor: (n, e, t, i, r)=>n({
                32773: new Float32Array([
                    e,
                    t,
                    i,
                    r
                ])
            }),
        blendEquation: (n, e)=>n({
                32777: e,
                34877: e
            }),
        blendEquationSeparate: (n, e, t)=>n({
                32777: e,
                34877: t
            }),
        blendFunc: (n, e, t)=>n({
                32969: e,
                32968: t,
                32971: e,
                32970: t
            }),
        blendFuncSeparate: (n, e, t, i, r)=>n({
                32969: e,
                32968: t,
                32971: i,
                32970: r
            }),
        clearColor: (n, e, t, i, r)=>n({
                3106: new Float32Array([
                    e,
                    t,
                    i,
                    r
                ])
            }),
        clearDepth: (n, e)=>n({
                2931: e
            }),
        clearStencil: (n, e)=>n({
                2961: e
            }),
        colorMask: (n, e, t, i, r)=>n({
                3107: [
                    e,
                    t,
                    i,
                    r
                ]
            }),
        cullFace: (n, e)=>n({
                2885: e
            }),
        depthFunc: (n, e)=>n({
                2932: e
            }),
        depthRange: (n, e, t)=>n({
                2928: new Float32Array([
                    e,
                    t
                ])
            }),
        depthMask: (n, e)=>n({
                2930: e
            }),
        frontFace: (n, e)=>n({
                2886: e
            }),
        lineWidth: (n, e)=>n({
                2849: e
            }),
        polygonOffset: (n, e, t)=>n({
                32824: e,
                10752: t
            }),
        sampleCoverage: (n, e, t)=>n({
                32938: e,
                32939: t
            }),
        scissor: (n, e, t, i, r)=>n({
                3088: new Int32Array([
                    e,
                    t,
                    i,
                    r
                ])
            }),
        stencilMask: (n, e)=>n({
                2968: e,
                36005: e
            }),
        stencilMaskSeparate: (n, e, t)=>n({
                [e === 1028 ? 2968 : 36005]: t
            }),
        stencilFunc: (n, e, t, i)=>n({
                2962: e,
                2967: t,
                2963: i,
                34816: e,
                36003: t,
                36004: i
            }),
        stencilFuncSeparate: (n, e, t, i, r)=>n({
                [e === 1028 ? 2962 : 34816]: t,
                [e === 1028 ? 2967 : 36003]: i,
                [e === 1028 ? 2963 : 36004]: r
            }),
        stencilOp: (n, e, t, i)=>n({
                2964: e,
                2965: t,
                2966: i,
                34817: e,
                34818: t,
                34819: i
            }),
        stencilOpSeparate: (n, e, t, i, r)=>n({
                [e === 1028 ? 2964 : 34817]: t,
                [e === 1028 ? 2965 : 34818]: i,
                [e === 1028 ? 2966 : 34819]: r
            }),
        viewport: (n, e, t, i, r)=>n({
                2978: [
                    e,
                    t,
                    i,
                    r
                ]
            })
    }, Bn = (n, e)=>n.isEnabled(e), V0 = {
        3042: Bn,
        2884: Bn,
        2929: Bn,
        3024: Bn,
        32823: Bn,
        32926: Bn,
        32928: Bn,
        3089: Bn,
        2960: Bn,
        35977: Bn
    }, iN = new Set([
        34016,
        36388,
        36387,
        35983,
        35368,
        34965,
        35739,
        35738,
        3074,
        34853,
        34854,
        34855,
        34856,
        34857,
        34858,
        34859,
        34860,
        34861,
        34862,
        34863,
        34864,
        34865,
        34866,
        34867,
        34868,
        35097,
        32873,
        35869,
        32874,
        34068
    ]);
    function na(n, e) {
        if (sN(e)) return;
        const t = {};
        for(const r in e){
            const a = Number(r), l = tN[r];
            l && (typeof l == "string" ? t[l] = !0 : l(n, e[r], a));
        }
        const i = n.state && n.state.cache;
        if (i) for(const r in t){
            const a = nN[r];
            a(n, e, i);
        }
    }
    function QT(n, e = Bg) {
        if (typeof e == "number") {
            const r = e, a = V0[r];
            return a ? a(n, r) : n.getParameter(r);
        }
        const t = Array.isArray(e) ? e : Object.keys(e), i = {};
        for (const r of t){
            const a = V0[r];
            i[r] = a ? a(n, Number(r)) : n.getParameter(Number(r));
        }
        return i;
    }
    function rN(n) {
        na(n, Bg);
    }
    function sN(n) {
        for(const e in n)return !1;
        return !0;
    }
    function aN(n, e) {
        if (n === e) return !0;
        const t = Array.isArray(n) || ArrayBuffer.isView(n), i = Array.isArray(e) || ArrayBuffer.isView(e);
        if (t && i && n.length === e.length) {
            for(let r = 0; r < n.length; ++r)if (n[r] !== e[r]) return !1;
            return !0;
        }
        return !1;
    }
    class Er {
        static get(e) {
            return e.state;
        }
        gl;
        program = null;
        stateStack = [];
        enable = !0;
        cache = null;
        log;
        initialized = !1;
        constructor(e, t){
            this.gl = e, this.log = t?.log || (()=>{}), this._updateCache = this._updateCache.bind(this), Object.seal(this);
        }
        push(e = {}) {
            this.stateStack.push({});
        }
        pop() {
            const e = this.stateStack[this.stateStack.length - 1];
            na(this.gl, e), this.stateStack.pop();
        }
        trackState(e, t) {
            if (this.cache = t.copyState ? QT(e) : Object.assign({}, Bg), this.initialized) throw new Error("WebGLStateTracker");
            this.initialized = !0, this.gl.state = this, lN(e);
            for(const i in z0){
                const r = z0[i];
                oN(e, i, r);
            }
            H0(e, "getParameter"), H0(e, "isEnabled");
        }
        _updateCache(e) {
            let t = !1, i;
            const r = this.stateStack.length > 0 ? this.stateStack[this.stateStack.length - 1] : null;
            for(const a in e){
                const l = e[a], u = this.cache[a];
                aN(l, u) || (t = !0, i = u, r && !(a in r) && (r[a] = u), this.cache[a] = l);
            }
            return {
                valueChanged: t,
                oldValue: i
            };
        }
    }
    function H0(n, e) {
        const t = n[e].bind(n);
        n[e] = function(r) {
            if (r === void 0 || iN.has(r)) return t(r);
            const a = Er.get(n);
            return r in a.cache || (a.cache[r] = t(r)), a.enable ? a.cache[r] : t(r);
        }, Object.defineProperty(n[e], "name", {
            value: `${e}-from-cache`,
            configurable: !1
        });
    }
    function oN(n, e, t) {
        if (!n[e]) return;
        const i = n[e].bind(n);
        n[e] = function(...a) {
            const l = Er.get(n), { valueChanged: u, oldValue: h } = t(l._updateCache, ...a);
            return u && i(...a), h;
        }, Object.defineProperty(n[e], "name", {
            value: `${e}-to-cache`,
            configurable: !1
        });
    }
    function lN(n) {
        const e = n.useProgram.bind(n);
        n.useProgram = function(i) {
            const r = Er.get(n);
            r.program !== i && (e(i), r.program = i);
        };
    }
    function cN(n, e, t) {
        let i = "";
        const r = {
            preserveDrawingBuffer: !0,
            ...t
        };
        let a = null;
        if (a ||= n.getContext("webgl2", r), r.failIfMajorPerformanceCaveat && (i ||= "Only software GPU is available. Set `failIfMajorPerformanceCaveat: false` to allow."), !a && !t.failIfMajorPerformanceCaveat && (r.failIfMajorPerformanceCaveat = !1, a = n.getContext("webgl2", r), a.luma ||= {}, a.luma.softwareRenderer = !0), a || (a = n.getContext("webgl", {}), a && (a = null, i ||= "Your browser only supports WebGL1")), !a) throw i ||= "Your browser does not support WebGL", new Error(`Failed to create WebGL context: ${i}`);
        const { onContextLost: l, onContextRestored: u } = e;
        return n.addEventListener("webglcontextlost", (h)=>l(h), !1), n.addEventListener("webglcontextrestored", (h)=>u(h), !1), a.luma ||= {}, a;
    }
    function Js(n, e, t) {
        return t[e] === void 0 && (t[e] = n.getExtension(e) || null), t[e];
    }
    function uN(n, e) {
        const t = n.getParameter(7936), i = n.getParameter(7937);
        Js(n, "WEBGL_debug_renderer_info", e);
        const r = e.WEBGL_debug_renderer_info, a = n.getParameter(r ? r.UNMASKED_VENDOR_WEBGL : 7936), l = n.getParameter(r ? r.UNMASKED_RENDERER_WEBGL : 7937), u = a || t, h = l || i, d = n.getParameter(7938), p = GT(u, h), _ = fN(u, h), y = hN(u, h);
        return {
            type: "webgl",
            gpu: p,
            gpuType: y,
            gpuBackend: _,
            vendor: u,
            renderer: h,
            version: d,
            shadingLanguage: "glsl",
            shadingLanguageVersion: 300
        };
    }
    function GT(n, e) {
        return /NVIDIA/i.exec(n) || /NVIDIA/i.exec(e) ? "nvidia" : /INTEL/i.exec(n) || /INTEL/i.exec(e) ? "intel" : /Apple/i.exec(n) || /Apple/i.exec(e) ? "apple" : /AMD/i.exec(n) || /AMD/i.exec(e) || /ATI/i.exec(n) || /ATI/i.exec(e) ? "amd" : /SwiftShader/i.exec(n) || /SwiftShader/i.exec(e) ? "software" : "unknown";
    }
    function fN(n, e) {
        return /Metal/i.exec(n) || /Metal/i.exec(e) ? "metal" : /ANGLE/i.exec(n) || /ANGLE/i.exec(e) ? "opengl" : "unknown";
    }
    function hN(n, e) {
        if (/SwiftShader/i.exec(n) || /SwiftShader/i.exec(e)) return "cpu";
        switch(GT(n, e)){
            case "intel":
                return "integrated";
            case "software":
                return "cpu";
            case "unknown":
                return "unknown";
            default:
                return "discrete";
        }
    }
    function JT(n) {
        switch(n){
            case "uint8":
                return 5121;
            case "sint8":
                return 5120;
            case "unorm8":
                return 5121;
            case "snorm8":
                return 5120;
            case "uint16":
                return 5123;
            case "sint16":
                return 5122;
            case "unorm16":
                return 5123;
            case "snorm16":
                return 5122;
            case "uint32":
                return 5125;
            case "sint32":
                return 5124;
            case "float16":
                return 5131;
            case "float32":
                return 5126;
        }
        throw new Error(String(n));
    }
    const co = "WEBGL_compressed_texture_s3tc", uo = "WEBGL_compressed_texture_s3tc_srgb", Us = "EXT_texture_compression_rgtc", Bs = "EXT_texture_compression_bptc", dN = "WEBGL_compressed_texture_etc", gN = "WEBGL_compressed_texture_astc", pN = "WEBGL_compressed_texture_etc1", mN = "WEBGL_compressed_texture_pvrtc", _N = "WEBGL_compressed_texture_atc", j0 = "EXT_texture_norm16", W0 = "EXT_render_snorm", yN = "EXT_color_buffer_float", Lg = {
        "float32-renderable-webgl": [
            "EXT_color_buffer_float"
        ],
        "float16-renderable-webgl": [
            "EXT_color_buffer_half_float"
        ],
        "rgb9e5ufloat-renderable-webgl": [
            "WEBGL_render_shared_exponent"
        ],
        "snorm8-renderable-webgl": [
            W0
        ],
        "norm16-renderable-webgl": [
            j0
        ],
        "snorm16-renderable-webgl": [
            j0,
            W0
        ],
        "float32-filterable": [
            "OES_texture_float_linear"
        ],
        "float16-filterable-webgl": [
            "OES_texture_half_float_linear"
        ],
        "texture-filterable-anisotropic-webgl": [
            "EXT_texture_filter_anisotropic"
        ],
        "texture-blend-float-webgl": [
            "EXT_float_blend"
        ],
        "texture-compression-bc": [
            co,
            uo,
            Us,
            Bs
        ],
        "texture-compression-bc5-webgl": [
            Us
        ],
        "texture-compression-bc7-webgl": [
            Bs
        ],
        "texture-compression-etc2": [
            dN
        ],
        "texture-compression-astc": [
            gN
        ],
        "texture-compression-etc1-webgl": [
            pN
        ],
        "texture-compression-pvrtc-webgl": [
            mN
        ],
        "texture-compression-atc-webgl": [
            _N
        ]
    };
    function bN(n) {
        return n in Lg;
    }
    function vN(n, e, t) {
        return (Lg[e] || []).every((r)=>Js(n, r, t));
    }
    const Fg = {
        r8unorm: {
            gl: 33321,
            rb: !0
        },
        r8snorm: {
            gl: 36756
        },
        r8uint: {
            gl: 33330,
            rb: !0
        },
        r8sint: {
            gl: 33329,
            rb: !0
        },
        rg8unorm: {
            gl: 33323,
            rb: !0
        },
        rg8snorm: {
            gl: 36757
        },
        rg8uint: {
            gl: 33336,
            rb: !0
        },
        rg8sint: {
            gl: 33335,
            rb: !0
        },
        r16uint: {
            gl: 33332,
            rb: !0
        },
        r16sint: {
            gl: 33331,
            rb: !0
        },
        r16float: {
            gl: 33325,
            rb: !0
        },
        "r16unorm-webgl": {
            gl: 33322,
            rb: !0
        },
        "r16snorm-webgl": {
            gl: 36760
        },
        "rgba4unorm-webgl": {
            gl: 32854,
            rb: !0
        },
        "rgb565unorm-webgl": {
            gl: 36194,
            rb: !0
        },
        "rgb5a1unorm-webgl": {
            gl: 32855,
            rb: !0
        },
        "rgb8unorm-webgl": {
            gl: 32849
        },
        "rgb8snorm-webgl": {
            gl: 36758
        },
        rgba8unorm: {
            gl: 32856
        },
        "rgba8unorm-srgb": {
            gl: 35907
        },
        rgba8snorm: {
            gl: 36759
        },
        rgba8uint: {
            gl: 36220
        },
        rgba8sint: {
            gl: 36238
        },
        bgra8unorm: {},
        "bgra8unorm-srgb": {},
        rg16uint: {
            gl: 33338
        },
        rg16sint: {
            gl: 33337
        },
        rg16float: {
            gl: 33327,
            rb: !0
        },
        "rg16unorm-webgl": {
            gl: 33324
        },
        "rg16snorm-webgl": {
            gl: 36761
        },
        r32uint: {
            gl: 33334,
            rb: !0
        },
        r32sint: {
            gl: 33333,
            rb: !0
        },
        r32float: {
            gl: 33326
        },
        rgb9e5ufloat: {
            gl: 35901
        },
        rg11b10ufloat: {
            gl: 35898,
            rb: !0
        },
        rgb10a2unorm: {
            gl: 32857,
            rb: !0
        },
        "rgb10a2uint-webgl": {
            gl: 36975,
            rb: !0
        },
        "rgb16unorm-webgl": {
            gl: 32852
        },
        "rgb16snorm-webgl": {
            gl: 36762
        },
        rg32uint: {
            gl: 33340,
            rb: !0
        },
        rg32sint: {
            gl: 33339,
            rb: !0
        },
        rg32float: {
            gl: 33328,
            rb: !0
        },
        rgba16uint: {
            gl: 36214,
            rb: !0
        },
        rgba16sint: {
            gl: 36232,
            rb: !0
        },
        rgba16float: {
            gl: 34842
        },
        "rgba16unorm-webgl": {
            gl: 32859,
            rb: !0
        },
        "rgba16snorm-webgl": {
            gl: 36763
        },
        "rgb32float-webgl": {
            gl: 34837,
            x: yN,
            dataFormat: 6407,
            types: [
                5126
            ]
        },
        rgba32uint: {
            gl: 36208,
            rb: !0
        },
        rgba32sint: {
            gl: 36226,
            rb: !0
        },
        rgba32float: {
            gl: 34836,
            rb: !0
        },
        stencil8: {
            gl: 36168,
            rb: !0
        },
        depth16unorm: {
            gl: 33189,
            dataFormat: 6402,
            types: [
                5123
            ],
            rb: !0
        },
        depth24plus: {
            gl: 33190,
            dataFormat: 6402,
            types: [
                5125
            ]
        },
        depth32float: {
            gl: 36012,
            dataFormat: 6402,
            types: [
                5126
            ],
            rb: !0
        },
        "depth24plus-stencil8": {
            gl: 35056,
            rb: !0,
            depthTexture: !0,
            dataFormat: 34041,
            types: [
                34042
            ]
        },
        "depth32float-stencil8": {
            gl: 36013,
            dataFormat: 34041,
            types: [
                36269
            ],
            rb: !0
        },
        "bc1-rgb-unorm-webgl": {
            gl: 33776,
            x: co
        },
        "bc1-rgb-unorm-srgb-webgl": {
            gl: 35916,
            x: uo
        },
        "bc1-rgba-unorm": {
            gl: 33777,
            x: co
        },
        "bc1-rgba-unorm-srgb": {
            gl: 35916,
            x: uo
        },
        "bc2-rgba-unorm": {
            gl: 33778,
            x: co
        },
        "bc2-rgba-unorm-srgb": {
            gl: 35918,
            x: uo
        },
        "bc3-rgba-unorm": {
            gl: 33779,
            x: co
        },
        "bc3-rgba-unorm-srgb": {
            gl: 35919,
            x: uo
        },
        "bc4-r-unorm": {
            gl: 36283,
            x: Us
        },
        "bc4-r-snorm": {
            gl: 36284,
            x: Us
        },
        "bc5-rg-unorm": {
            gl: 36285,
            x: Us
        },
        "bc5-rg-snorm": {
            gl: 36286,
            x: Us
        },
        "bc6h-rgb-ufloat": {
            gl: 36495,
            x: Bs
        },
        "bc6h-rgb-float": {
            gl: 36494,
            x: Bs
        },
        "bc7-rgba-unorm": {
            gl: 36492,
            x: Bs
        },
        "bc7-rgba-unorm-srgb": {
            gl: 36493,
            x: Bs
        },
        "etc2-rgb8unorm": {
            gl: 37492
        },
        "etc2-rgb8unorm-srgb": {
            gl: 37494
        },
        "etc2-rgb8a1unorm": {
            gl: 37496
        },
        "etc2-rgb8a1unorm-srgb": {
            gl: 37497
        },
        "etc2-rgba8unorm": {
            gl: 37493
        },
        "etc2-rgba8unorm-srgb": {
            gl: 37495
        },
        "eac-r11unorm": {
            gl: 37488
        },
        "eac-r11snorm": {
            gl: 37489
        },
        "eac-rg11unorm": {
            gl: 37490
        },
        "eac-rg11snorm": {
            gl: 37491
        },
        "astc-4x4-unorm": {
            gl: 37808
        },
        "astc-4x4-unorm-srgb": {
            gl: 37840
        },
        "astc-5x4-unorm": {
            gl: 37809
        },
        "astc-5x4-unorm-srgb": {
            gl: 37841
        },
        "astc-5x5-unorm": {
            gl: 37810
        },
        "astc-5x5-unorm-srgb": {
            gl: 37842
        },
        "astc-6x5-unorm": {
            gl: 37811
        },
        "astc-6x5-unorm-srgb": {
            gl: 37843
        },
        "astc-6x6-unorm": {
            gl: 37812
        },
        "astc-6x6-unorm-srgb": {
            gl: 37844
        },
        "astc-8x5-unorm": {
            gl: 37813
        },
        "astc-8x5-unorm-srgb": {
            gl: 37845
        },
        "astc-8x6-unorm": {
            gl: 37814
        },
        "astc-8x6-unorm-srgb": {
            gl: 37846
        },
        "astc-8x8-unorm": {
            gl: 37815
        },
        "astc-8x8-unorm-srgb": {
            gl: 37847
        },
        "astc-10x5-unorm": {
            gl: 37819
        },
        "astc-10x5-unorm-srgb": {
            gl: 37851
        },
        "astc-10x6-unorm": {
            gl: 37817
        },
        "astc-10x6-unorm-srgb": {
            gl: 37849
        },
        "astc-10x8-unorm": {
            gl: 37818
        },
        "astc-10x8-unorm-srgb": {
            gl: 37850
        },
        "astc-10x10-unorm": {
            gl: 37819
        },
        "astc-10x10-unorm-srgb": {
            gl: 37851
        },
        "astc-12x10-unorm": {
            gl: 37820
        },
        "astc-12x10-unorm-srgb": {
            gl: 37852
        },
        "astc-12x12-unorm": {
            gl: 37821
        },
        "astc-12x12-unorm-srgb": {
            gl: 37853
        },
        "pvrtc-rgb4unorm-webgl": {
            gl: 35840
        },
        "pvrtc-rgba4unorm-webgl": {
            gl: 35842
        },
        "pvrtc-rbg2unorm-webgl": {
            gl: 35841
        },
        "pvrtc-rgba2unorm-webgl": {
            gl: 35843
        },
        "etc1-rbg-unorm-webgl": {
            gl: 36196
        },
        "atc-rgb-unorm-webgl": {
            gl: 35986
        },
        "atc-rgba-unorm-webgl": {
            gl: 35986
        },
        "atc-rgbai-unorm-webgl": {
            gl: 34798
        }
    };
    function TN(n, e, t) {
        let i = e.create;
        const r = Fg[e.format];
        return r?.gl === void 0 && (i = !1), r?.x && (i = i && !!Js(n, r.x, t)), {
            format: e.format,
            create: i && e.create,
            render: i && e.render,
            filter: i && e.filter,
            blend: i && e.blend,
            store: i && e.store
        };
    }
    function e1(n) {
        const e = Fg[n], t = AN(n), i = hg(n);
        return {
            internalFormat: t,
            format: e?.dataFormat || SN(i.channels, i.integer, i.normalized, t),
            type: i.dataType ? JT(i.dataType) : e?.types?.[0] || 5121,
            compressed: i.compressed || !1
        };
    }
    function xN(n) {
        switch(hg(n).attachment){
            case "depth":
                return 36096;
            case "stencil":
                return 36128;
            case "depth-stencil":
                return 33306;
            default:
                throw new Error(`Not a depth stencil format: ${n}`);
        }
    }
    function SN(n, e, t, i) {
        if (i === 6408 || i === 6407) return i;
        switch(n){
            case "r":
                return e && !t ? 36244 : 6403;
            case "rg":
                return e && !t ? 33320 : 33319;
            case "rgb":
                return e && !t ? 36248 : 6407;
            case "rgba":
                return e && !t ? 36249 : 6408;
            case "bgra":
                throw new Error("bgra pixels not supported by WebGL");
            default:
                return 6408;
        }
    }
    function AN(n) {
        const t = Fg[n]?.gl;
        if (t === void 0) throw new Error(`Unsupported texture format ${n}`);
        return t;
    }
    const $0 = {
        "depth-clip-control": "EXT_depth_clamp",
        "timer-query-webgl": "EXT_disjoint_timer_query_webgl2",
        "compilation-status-async-webgl": "KHR_parallel_shader_compile",
        "polygon-mode-webgl": "WEBGL_polygon_mode",
        "provoking-vertex-webgl": "WEBGL_provoking_vertex",
        "shader-clip-cull-distance-webgl": "WEBGL_clip_cull_distance",
        "shader-noperspective-interpolation-webgl": "NV_shader_noperspective_interpolation",
        "shader-conservative-depth-webgl": "EXT_conservative_depth"
    };
    class wN extends oR {
        gl;
        extensions;
        testedFeatures = new Set;
        constructor(e, t, i){
            super([], i), this.gl = e, this.extensions = t, Js(e, "EXT_color_buffer_float", t);
        }
        *[Symbol.iterator]() {
            const e = this.getFeatures();
            for (const t of e)this.has(t) && (yield t);
            return [];
        }
        has(e) {
            return this.disabledFeatures?.[e] ? !1 : (this.testedFeatures.has(e) || (this.testedFeatures.add(e), bN(e) && vN(this.gl, e, this.extensions) && this.features.add(e), this.getWebGLFeature(e) && this.features.add(e)), this.features.has(e));
        }
        initializeFeatures() {
            const e = this.getFeatures().filter((t)=>t !== "polygon-mode-webgl");
            for (const t of e)this.has(t);
        }
        getFeatures() {
            return [
                ...Object.keys($0),
                ...Object.keys(Lg)
            ];
        }
        getWebGLFeature(e) {
            const t = $0[e];
            return typeof t == "string" ? !!Js(this.gl, t, this.extensions) : !!t;
        }
    }
    class EN extends aR {
        get maxTextureDimension1D() {
            return 0;
        }
        get maxTextureDimension2D() {
            return this.getParameter(3379);
        }
        get maxTextureDimension3D() {
            return this.getParameter(32883);
        }
        get maxTextureArrayLayers() {
            return this.getParameter(35071);
        }
        get maxBindGroups() {
            return 0;
        }
        get maxDynamicUniformBuffersPerPipelineLayout() {
            return 0;
        }
        get maxDynamicStorageBuffersPerPipelineLayout() {
            return 0;
        }
        get maxSampledTexturesPerShaderStage() {
            return this.getParameter(35660);
        }
        get maxSamplersPerShaderStage() {
            return this.getParameter(35661);
        }
        get maxStorageBuffersPerShaderStage() {
            return 0;
        }
        get maxStorageTexturesPerShaderStage() {
            return 0;
        }
        get maxUniformBuffersPerShaderStage() {
            return this.getParameter(35375);
        }
        get maxUniformBufferBindingSize() {
            return this.getParameter(35376);
        }
        get maxStorageBufferBindingSize() {
            return 0;
        }
        get minUniformBufferOffsetAlignment() {
            return this.getParameter(35380);
        }
        get minStorageBufferOffsetAlignment() {
            return 0;
        }
        get maxVertexBuffers() {
            return 16;
        }
        get maxVertexAttributes() {
            return this.getParameter(34921);
        }
        get maxVertexBufferArrayStride() {
            return 2048;
        }
        get maxInterStageShaderComponents() {
            return this.getParameter(35659);
        }
        get maxComputeWorkgroupStorageSize() {
            return 0;
        }
        get maxComputeInvocationsPerWorkgroup() {
            return 0;
        }
        get maxComputeWorkgroupSizeX() {
            return 0;
        }
        get maxComputeWorkgroupSizeY() {
            return 0;
        }
        get maxComputeWorkgroupSizeZ() {
            return 0;
        }
        get maxComputeWorkgroupsPerDimension() {
            return 0;
        }
        gl;
        limits = {};
        constructor(e){
            super(), this.gl = e;
        }
        getParameter(e) {
            return this.limits[e] === void 0 && (this.limits[e] = this.gl.getParameter(e)), this.limits[e] || 0;
        }
    }
    class _o extends nu {
        device;
        gl;
        handle;
        colorAttachments = [];
        depthStencilAttachment = null;
        constructor(e, t){
            super(e, t);
            const i = t.handle === null;
            this.device = e, this.gl = e.gl, this.handle = this.props.handle || i ? this.props.handle : this.gl.createFramebuffer(), i || (e.setSpectorMetadata(this.handle, {
                id: this.props.id,
                props: this.props
            }), this.autoCreateAttachmentTextures(), this.updateAttachments());
        }
        destroy() {
            super.destroy(), !this.destroyed && this.handle !== null && this.gl.deleteFramebuffer(this.handle);
        }
        updateAttachments() {
            const e = this.gl.bindFramebuffer(36160, this.handle);
            for(let t = 0; t < this.colorAttachments.length; ++t){
                const i = this.colorAttachments[t];
                if (i) {
                    const r = 36064 + t;
                    this._attachTextureView(r, i);
                }
            }
            if (this.depthStencilAttachment) {
                const t = xN(this.depthStencilAttachment.props.format);
                this._attachTextureView(t, this.depthStencilAttachment);
            }
            if (this.device.props.debug) {
                const t = this.gl.checkFramebufferStatus(36160);
                if (t !== 36053) throw new Error(`Framebuffer ${CN(t)}`);
            }
            this.gl.bindFramebuffer(36160, e);
        }
        _attachTextureView(e, t) {
            const { gl: i } = this.device, { texture: r } = t, a = t.props.baseMipLevel, l = t.props.baseArrayLayer;
            switch(i.bindTexture(r.glTarget, r.handle), r.glTarget){
                case 35866:
                case 32879:
                    i.framebufferTextureLayer(36160, e, r.handle, a, l);
                    break;
                case 34067:
                    const u = RN(l);
                    i.framebufferTexture2D(36160, e, u, r.handle, a);
                    break;
                case 3553:
                    i.framebufferTexture2D(36160, e, 3553, r.handle, a);
                    break;
                default:
                    throw new Error("Illegal texture type");
            }
            i.bindTexture(r.glTarget, null);
        }
    }
    function RN(n) {
        return n < 34069 ? n + 34069 : n;
    }
    function CN(n) {
        switch(n){
            case 36053:
                return "success";
            case 36054:
                return "Mismatched attachments";
            case 36055:
                return "No attachments";
            case 36057:
                return "Height/width mismatch";
            case 36061:
                return "Unsupported or split attachments";
            case 36182:
                return "Samples mismatch";
            default:
                return `${n}`;
        }
    }
    class MN extends dg {
        device;
        format = "rgba8unorm";
        depthStencilFormat = "depth24plus";
        presentationSize;
        _framebuffer = null;
        get [Symbol.toStringTag]() {
            return "WebGLCanvasContext";
        }
        constructor(e, t){
            super(t), this.device = e, this.presentationSize = [
                -1,
                -1
            ], this._setAutoCreatedCanvasId(`${this.device.id}-canvas`), this.update();
        }
        getCurrentFramebuffer() {
            return this.update(), this._framebuffer = this._framebuffer || new _o(this.device, {
                handle: null
            }), this._framebuffer;
        }
        update() {
            const e = this.getPixelSize();
            (e[0] !== this.presentationSize[0] || e[1] !== this.presentationSize[1]) && (this.presentationSize = e, this.resize());
        }
        resize(e) {
            if (this.device.gl && this.canvas) {
                const t = this.getDevicePixelRatio(e?.useDevicePixels);
                this.setDevicePixelRatio(t, e);
                return;
            }
        }
        commit() {}
    }
    async function t1(n, e) {
        const t = document.getElementsByTagName("head")[0];
        if (!t) throw new Error("loadScript");
        const i = document.createElement("script");
        return i.setAttribute("type", "text/javascript"), i.setAttribute("src", n), new Promise((r, a)=>{
            i.onload = r, i.onerror = (l)=>a(new Error(`Unable to load script '${n}': ${l}`)), t.appendChild(i);
        });
    }
    const ON = 1;
    let nn = null, X0 = !1;
    const zg = {
        debugSpectorJS: J.get("debug-spectorjs"),
        debugSpectorJSUrl: "https://cdn.jsdelivr.net/npm/spectorjs@0.9.30/dist/spector.bundle.js",
        gl: void 0
    };
    async function IN(n) {
        if (!globalThis.SPECTOR) try {
            await t1(n.debugSpectorJSUrl || zg.debugSpectorJSUrl);
        } catch (e) {
            J.warn(String(e));
        }
    }
    function NN(n) {
        if (n = {
            ...zg,
            ...n
        }, !n.debugSpectorJS) return null;
        if (!nn && globalThis.SPECTOR && !globalThis.luma?.spector) {
            J.probe(ON, "SPECTOR found and initialized. Start with `luma.spector.displayUI()`")();
            const { Spector: e } = globalThis.SPECTOR;
            nn = new e, globalThis.luma && (globalThis.luma.spector = nn);
        }
        if (!nn) return null;
        if (X0 || (X0 = !0, nn.spyCanvases(), nn?.onCaptureStarted.add((e)=>J.info("Spector capture started:", e)()), nn?.onCapture.add((e)=>{
            J.info("Spector capture complete:", e)(), nn?.getResultUI(), nn?.resultView.display(), nn?.resultView.addCapture(e);
        })), n.gl) {
            const e = n.gl, t = e.device;
            nn?.startCapture(n.gl, 500), e.device = t, new Promise((i)=>setTimeout(i, 2e3)).then((i)=>{
                J.info("Spector capture stopped after 2 seconds")(), nn?.stopCapture();
            });
        }
        return nn;
    }
    const PN = "https://unpkg.com/webgl-debug@2.0.1/index.js";
    function n1(n) {
        return n.luma = n.luma || {}, n.luma;
    }
    async function DN() {
        Dr() && !globalThis.WebGLDebugUtils && (globalThis.global = globalThis.global || globalThis, globalThis.global.module = {}, await t1(PN));
    }
    function kN(n, e = {}) {
        return e.debugWebGL || e.traceWebGL ? BN(n, e) : UN(n);
    }
    function UN(n) {
        const e = n1(n);
        return e.realContext ? e.realContext : n;
    }
    function BN(n, e) {
        if (!globalThis.WebGLDebugUtils) return J.warn("webgl-debug not loaded")(), n;
        const t = n1(n);
        if (t.debugContext) return t.debugContext;
        globalThis.WebGLDebugUtils.init({
            ...ks,
            ...n
        });
        const i = globalThis.WebGLDebugUtils.makeDebugContext(n, LN.bind(null, e), FN.bind(null, e));
        for(const l in ks)!(l in i) && typeof ks[l] == "number" && (i[l] = ks[l]);
        class r {
        }
        Object.setPrototypeOf(i, Object.getPrototypeOf(n)), Object.setPrototypeOf(r, i);
        const a = Object.create(r);
        return t.realContext = n, t.debugContext = a, a.debug = !0, a;
    }
    function Y0(n, e) {
        e = Array.from(e).map((i)=>i === void 0 ? "undefined" : i);
        let t = globalThis.WebGLDebugUtils.glFunctionArgsToString(n, e);
        return t = `${t.slice(0, 100)}${t.length > 100 ? "..." : ""}`, `gl.${n}(${t})`;
    }
    function LN(n, e, t, i) {
        i = Array.from(i).map((u)=>u === void 0 ? "undefined" : u);
        const r = globalThis.WebGLDebugUtils.glEnumToString(e), a = globalThis.WebGLDebugUtils.glFunctionArgsToString(t, i), l = `${r} in gl.${t}(${a})`;
        J.error(l)();
        debugger;
    }
    function FN(n, e, t) {
        let i = "";
        J.level >= 1 && (i = Y0(e, t), n.traceWebGL && J.log(1, i)());
        for (const r of t)if (r === void 0) {
            i = i || Y0(e, t);
            debugger;
        }
    }
    const ad = {};
    function zN(n = "id") {
        ad[n] = ad[n] || 1;
        const e = ad[n]++;
        return `${n}-${e}`;
    }
    class yo extends Ge {
        device;
        gl;
        handle;
        glTarget;
        glUsage;
        glIndexType = 5123;
        byteLength;
        bytesUsed;
        constructor(e, t = {}){
            super(e, t), this.device = e, this.gl = this.device.gl;
            const i = typeof t == "object" ? t.handle : void 0;
            this.handle = i || this.gl.createBuffer(), e.setSpectorMetadata(this.handle, {
                ...this.props,
                data: typeof this.props.data
            }), this.glTarget = VN(this.props.usage), this.glUsage = HN(this.props.usage), this.glIndexType = this.props.indexType === "uint32" ? 5125 : 5123, t.data ? this._initWithData(t.data, t.byteOffset, t.byteLength) : this._initWithByteLength(t.byteLength || 0);
        }
        _initWithData(e, t = 0, i = e.byteLength + t) {
            const r = this.glTarget;
            this.gl.bindBuffer(r, this.handle), this.gl.bufferData(r, i, this.glUsage), this.gl.bufferSubData(r, t, e), this.gl.bindBuffer(r, null), this.bytesUsed = i, this.byteLength = i, this._setDebugData(e, t, i), this.trackAllocatedMemory(i);
        }
        _initWithByteLength(e) {
            let t = e;
            e === 0 && (t = new Float32Array(0));
            const i = this.glTarget;
            return this.gl.bindBuffer(i, this.handle), this.gl.bufferData(i, t, this.glUsage), this.gl.bindBuffer(i, null), this.bytesUsed = e, this.byteLength = e, this._setDebugData(null, 0, e), this.trackAllocatedMemory(e), this;
        }
        destroy() {
            !this.destroyed && this.handle && (this.removeStats(), this.trackDeallocatedMemory(), this.gl.deleteBuffer(this.handle), this.destroyed = !0, this.handle = null);
        }
        write(e, t = 0) {
            this.gl.bindBuffer(36663, this.handle), this.gl.bufferSubData(36663, t, e), this.gl.bindBuffer(36663, null), this._setDebugData(e, t, e.byteLength);
        }
        async readAsync(e = 0, t) {
            return this.readSyncWebGL(e, t);
        }
        readSyncWebGL(e = 0, t) {
            t = t ?? this.byteLength - e;
            const i = new Uint8Array(t), r = 0;
            return this.gl.bindBuffer(36662, this.handle), this.gl.getBufferSubData(36662, e, i, r, t), this.gl.bindBuffer(36662, null), this._setDebugData(i, e, t), i;
        }
    }
    function VN(n) {
        return n & Ge.INDEX ? 34963 : n & Ge.VERTEX ? 34962 : n & Ge.UNIFORM ? 35345 : 34962;
    }
    function HN(n) {
        return n & Ge.INDEX || n & Ge.VERTEX ? 35044 : n & Ge.UNIFORM ? 35048 : 35044;
    }
    function jN(n) {
        const e = n.split(/\r?\n/), t = [];
        for (const i of e){
            if (i.length <= 1) continue;
            const r = i.split(":");
            if (r.length === 2) {
                const [_, y] = r;
                t.push({
                    message: y.trim(),
                    type: q0(_),
                    lineNum: 0,
                    linePos: 0
                });
                continue;
            }
            const [a, l, u, ...h] = r;
            let d = parseInt(u, 10);
            isNaN(d) && (d = 0);
            let p = parseInt(l, 10);
            isNaN(p) && (p = 0), t.push({
                message: h.join(":").trim(),
                type: q0(a),
                lineNum: d,
                linePos: p
            });
        }
        return t;
    }
    function q0(n) {
        const e = [
            "warning",
            "error",
            "info"
        ], t = n.toLowerCase();
        return e.includes(t) ? t : "info";
    }
    class WN extends tu {
        device;
        handle;
        constructor(e, t){
            switch(super(e, t), this.device = e, this.props.stage){
                case "vertex":
                    this.handle = this.props.handle || this.device.gl.createShader(35633);
                    break;
                case "fragment":
                    this.handle = this.props.handle || this.device.gl.createShader(35632);
                    break;
                default:
                    throw new Error(this.props.stage);
            }
            this._compile(this.source);
        }
        destroy() {
            this.handle && (this.removeStats(), this.device.gl.deleteShader(this.handle), this.destroyed = !0);
        }
        get asyncCompilationStatus() {
            return this._waitForCompilationComplete().then(()=>this.compilationStatus);
        }
        async getCompilationInfo() {
            return await this._waitForCompilationComplete(), this.getCompilationInfoSync();
        }
        getCompilationInfoSync() {
            const e = this.device.gl.getShaderInfoLog(this.handle);
            return e ? jN(e) : [];
        }
        getTranslatedSource() {
            return this.device.getExtension("WEBGL_debug_shaders").WEBGL_debug_shaders?.getTranslatedShaderSource(this.handle) || null;
        }
        async _compile(e) {
            e = e.startsWith("#version ") ? e : `#version 300 es
${e}`;
            const { gl: t } = this.device;
            if (t.shaderSource(this.handle, e), t.compileShader(this.handle), !this.device.props.debug) {
                this.compilationStatus = "pending";
                return;
            }
            if (!this.device.features.has("compilation-status-async-webgl")) {
                if (this._getCompilationStatus(), this.debugShader(), this.compilationStatus === "error") throw new Error(`GLSL compilation errors in ${this.props.stage} shader ${this.props.id}`);
                return;
            }
            J.once(1, "Shader compilation is asynchronous")(), await this._waitForCompilationComplete(), J.info(2, `Shader ${this.id} - async compilation complete: ${this.compilationStatus}`)(), this._getCompilationStatus(), this.debugShader();
        }
        async _waitForCompilationComplete() {
            const e = async (r)=>await new Promise((a)=>setTimeout(a, r));
            if (!this.device.features.has("compilation-status-async-webgl")) {
                await e(10);
                return;
            }
            const { gl: i } = this.device;
            for(;;){
                if (i.getShaderParameter(this.handle, 37297)) return;
                await e(10);
            }
        }
        _getCompilationStatus() {
            this.compilationStatus = this.device.gl.getShaderParameter(this.handle, 35713) ? "success" : "error";
        }
    }
    function $N(n, e, t, i) {
        if (KN(e)) return i(n);
        const r = n;
        r.pushState();
        try {
            return XN(n, e), na(r.gl, t), i(n);
        } finally{
            r.popState();
        }
    }
    function XN(n, e) {
        const t = n, { gl: i } = t;
        if (e.cullMode) switch(e.cullMode){
            case "none":
                i.disable(2884);
                break;
            case "front":
                i.enable(2884), i.cullFace(1028);
                break;
            case "back":
                i.enable(2884), i.cullFace(1029);
                break;
        }
        if (e.frontFace && i.frontFace(Rr("frontFace", e.frontFace, {
            ccw: 2305,
            cw: 2304
        })), e.unclippedDepth && n.features.has("depth-clip-control") && i.enable(34383), e.depthBias !== void 0 && (i.enable(32823), i.polygonOffset(e.depthBias, e.depthBiasSlopeScale || 0)), e.provokingVertex && n.features.has("provoking-vertex-webgl")) {
            const a = t.getExtension("WEBGL_provoking_vertex").WEBGL_provoking_vertex, l = Rr("provokingVertex", e.provokingVertex, {
                first: 36429,
                last: 36430
            });
            a?.provokingVertexWEBGL(l);
        }
        if ((e.polygonMode || e.polygonOffsetLine) && n.features.has("polygon-mode-webgl")) {
            if (e.polygonMode) {
                const a = t.getExtension("WEBGL_polygon_mode").WEBGL_polygon_mode, l = Rr("polygonMode", e.polygonMode, {
                    fill: 6914,
                    line: 6913
                });
                a?.polygonModeWEBGL(1028, l), a?.polygonModeWEBGL(1029, l);
            }
            e.polygonOffsetLine && i.enable(10754);
        }
        if (n.features.has("shader-clip-cull-distance-webgl") && (e.clipDistance0 && i.enable(12288), e.clipDistance1 && i.enable(12289), e.clipDistance2 && i.enable(12290), e.clipDistance3 && i.enable(12291), e.clipDistance4 && i.enable(12292), e.clipDistance5 && i.enable(12293), e.clipDistance6 && i.enable(12294), e.clipDistance7 && i.enable(12295)), e.depthWriteEnabled !== void 0 && i.depthMask(qN("depthWriteEnabled", e.depthWriteEnabled)), e.depthCompare && (e.depthCompare !== "always" ? i.enable(2929) : i.disable(2929), i.depthFunc(Hd("depthCompare", e.depthCompare))), e.stencilWriteMask) {
            const r = e.stencilWriteMask;
            i.stencilMaskSeparate(1028, r), i.stencilMaskSeparate(1029, r);
        }
        if (e.stencilReadMask && J.warn("stencilReadMask not supported under WebGL"), e.stencilCompare) {
            const r = e.stencilReadMask || 4294967295, a = Hd("depthCompare", e.stencilCompare);
            e.stencilCompare !== "always" ? i.enable(2960) : i.disable(2960), i.stencilFuncSeparate(1028, a, 0, r), i.stencilFuncSeparate(1029, a, 0, r);
        }
        if (e.stencilPassOperation && e.stencilFailOperation && e.stencilDepthFailOperation) {
            const r = od("stencilPassOperation", e.stencilPassOperation), a = od("stencilFailOperation", e.stencilFailOperation), l = od("stencilDepthFailOperation", e.stencilDepthFailOperation);
            i.stencilOpSeparate(1028, a, l, r), i.stencilOpSeparate(1029, a, l, r);
        }
        switch(e.blend){
            case !0:
                i.enable(3042);
                break;
            case !1:
                i.disable(3042);
                break;
        }
        if (e.blendColorOperation || e.blendAlphaOperation) {
            const r = K0("blendColorOperation", e.blendColorOperation || "add"), a = K0("blendAlphaOperation", e.blendAlphaOperation || "add");
            i.blendEquationSeparate(r, a);
            const l = ac("blendColorSrcFactor", e.blendColorSrcFactor || "one"), u = ac("blendColorDstFactor", e.blendColorDstFactor || "zero"), h = ac("blendAlphaSrcFactor", e.blendAlphaSrcFactor || "one"), d = ac("blendAlphaDstFactor", e.blendAlphaDstFactor || "zero");
            i.blendFuncSeparate(l, u, h, d);
        }
    }
    function Hd(n, e) {
        return Rr(n, e, {
            never: 512,
            less: 513,
            equal: 514,
            "less-equal": 515,
            greater: 516,
            "not-equal": 517,
            "greater-equal": 518,
            always: 519
        });
    }
    function od(n, e) {
        return Rr(n, e, {
            keep: 7680,
            zero: 0,
            replace: 7681,
            invert: 5386,
            "increment-clamp": 7682,
            "decrement-clamp": 7683,
            "increment-wrap": 34055,
            "decrement-wrap": 34056
        });
    }
    function K0(n, e) {
        return Rr(n, e, {
            add: 32774,
            subtract: 32778,
            "reverse-subtract": 32779,
            min: 32775,
            max: 32776
        });
    }
    function ac(n, e) {
        return Rr(n, e, {
            one: 1,
            zero: 0,
            "src-color": 768,
            "one-minus-src-color": 769,
            "dst-color": 774,
            "one-minus-dst-color": 775,
            "src-alpha": 770,
            "one-minus-src-alpha": 771,
            "dst-alpha": 772,
            "one-minus-dst-alpha": 773,
            "src-alpha-saturated": 776,
            "constant-color": 32769,
            "one-minus-constant-color": 32770,
            "constant-alpha": 32771,
            "one-minus-constant-alpha": 32772
        });
    }
    function YN(n, e) {
        return `Illegal parameter ${e} for ${n}`;
    }
    function Rr(n, e, t) {
        if (!(e in t)) throw new Error(YN(n, e));
        return t[e];
    }
    function qN(n, e) {
        return e;
    }
    function KN(n) {
        let e = !0;
        for(const t in n){
            e = !1;
            break;
        }
        return e;
    }
    function i1(n) {
        const e = {};
        return n.addressModeU && (e[10242] = ld(n.addressModeU)), n.addressModeV && (e[10243] = ld(n.addressModeV)), n.addressModeW && (e[32882] = ld(n.addressModeW)), n.magFilter && (e[10240] = jd(n.magFilter)), (n.minFilter || n.mipmapFilter) && (e[10241] = ZN(n.minFilter || "linear", n.mipmapFilter)), n.lodMinClamp !== void 0 && (e[33082] = n.lodMinClamp), n.lodMaxClamp !== void 0 && (e[33083] = n.lodMaxClamp), n.type === "comparison-sampler" && (e[34892] = 34894), n.compare && (e[34893] = Hd("compare", n.compare)), n.maxAnisotropy && (e[34046] = n.maxAnisotropy), e;
    }
    function ld(n) {
        switch(n){
            case "clamp-to-edge":
                return 33071;
            case "repeat":
                return 10497;
            case "mirror-repeat":
                return 33648;
        }
    }
    function jd(n) {
        switch(n){
            case "nearest":
                return 9728;
            case "linear":
                return 9729;
        }
    }
    function ZN(n, e = "none") {
        if (!e) return jd(n);
        switch(e){
            case "none":
                return jd(n);
            case "nearest":
                return n === "nearest" ? 9984 : 9986;
            case "linear":
                return n === "nearest" ? 9985 : 9987;
        }
    }
    class Wd extends vo {
        device;
        handle;
        parameters;
        constructor(e, t){
            super(e, t), this.device = e, this.parameters = i1(t), this.handle = this.handle || this.device.gl.createSampler(), this._setSamplerParameters(this.parameters);
        }
        destroy() {
            this.handle && (this.device.gl.deleteSampler(this.handle), this.handle = void 0);
        }
        toString() {
            return `Sampler(${this.id},${JSON.stringify(this.props)})`;
        }
        _setSamplerParameters(e) {
            for (const [t, i] of Object.entries(e)){
                const r = Number(t);
                switch(r){
                    case 33082:
                    case 33083:
                        this.device.gl.samplerParameterf(this.handle, r, i);
                        break;
                    default:
                        this.device.gl.samplerParameteri(this.handle, r, i);
                        break;
                }
            }
        }
    }
    class Ls extends eu {
        device;
        gl;
        handle;
        texture;
        constructor(e, t){
            super(e, {
                ...Xe.defaultProps,
                ...t
            }), this.device = e, this.gl = this.device.gl, this.handle = null, this.texture = t.texture;
        }
    }
    const QN = "Failed to deduce GL constant from typed array";
    function GN(n) {
        switch(ArrayBuffer.isView(n) ? n.constructor : n){
            case Float32Array:
                return 5126;
            case Uint16Array:
                return 5123;
            case Uint32Array:
                return 5125;
            case Uint8Array:
                return 5121;
            case Uint8ClampedArray:
                return 5121;
            case Int8Array:
                return 5120;
            case Int16Array:
                return 5122;
            case Int32Array:
                return 5124;
            default:
                throw new Error(QN);
        }
    }
    function JN(n, e) {
        const { clamped: t = !0 } = e || {};
        switch(n){
            case 5126:
                return Float32Array;
            case 5123:
            case 33635:
            case 32819:
            case 32820:
                return Uint16Array;
            case 5125:
                return Uint32Array;
            case 5121:
                return t ? Uint8ClampedArray : Uint8Array;
            case 5120:
                return Int8Array;
            case 5122:
                return Int16Array;
            case 5124:
                return Int32Array;
            default:
                throw new Error("Failed to deduce typed array type from GL constant");
        }
    }
    function r1(n) {
        switch(n){
            case 6406:
            case 33326:
            case 6403:
            case 36244:
                return 1;
            case 33339:
            case 33340:
            case 33328:
            case 33320:
            case 33319:
                return 2;
            case 6407:
            case 36248:
            case 34837:
                return 3;
            case 6408:
            case 36249:
            case 34836:
                return 4;
            default:
                return 0;
        }
    }
    function eP(n) {
        switch(n){
            case 5121:
                return 1;
            case 33635:
            case 32819:
            case 32820:
                return 2;
            case 5126:
                return 4;
            default:
                return 0;
        }
    }
    function Fc(n, e, t) {
        if (tP(e)) return t(n);
        const { nocatch: i = !0 } = e, r = Er.get(n);
        r.push(), na(n, e);
        let a;
        if (i) a = t(n), r.pop();
        else try {
            a = t(n);
        } finally{
            r.pop();
        }
        return a;
    }
    function tP(n) {
        for(const e in n)return !1;
        return !0;
    }
    function nP(n, e, t) {
        const { dimension: i, width: r, height: a, depth: l = 0 } = t, { glInternalFormat: u } = t, h = t.glTarget;
        switch(i){
            case "2d-array":
            case "3d":
                n.texStorage3D(h, e, u, r, a, l);
                break;
            default:
                n.texStorage2D(h, e, u, r, a);
        }
    }
    function Z0(n, e, t, i) {
        const { width: r, height: a } = i, { dimension: l, depth: u = 0, mipLevel: h = 0 } = i, { x: d = 0, y: p = 0, z: _ = 0 } = i, { glFormat: y, glType: v } = i, S = s1(i.glTarget, l, u), E = i.flipY ? {
            37440: !0
        } : {};
        Fc(n, E, ()=>{
            switch(l){
                case "2d-array":
                case "3d":
                    n.bindTexture(S, e), n.texSubImage3D(S, h, d, p, _, r, a, u, y, v, t), n.bindTexture(S, null);
                    break;
                case "2d":
                case "cube":
                    n.bindTexture(S, e), n.texSubImage2D(S, h, d, p, r, a, y, v, t), n.bindTexture(S, null);
                    break;
                default:
                    throw new Error(l);
            }
        });
    }
    function Q0(n, e, t) {
        const { dimension: i, width: r, height: a, depth: l = 0, mipLevel: u = 0, byteOffset: h = 0 } = t, { x: d = 0, y: p = 0, z: _ = 0 } = t, { glFormat: y, glType: v, compressed: S } = t, E = s1(t.glTarget, i, l);
        switch(i){
            case "2d-array":
            case "3d":
                S ? n.compressedTexSubImage3D(E, u, d, p, _, r, a, l, y, e, h) : n.texSubImage3D(E, u, d, p, _, r, a, l, y, v, e, h);
                break;
            case "2d":
            case "cube":
                S ? n.compressedTexSubImage2D(E, u, d, p, r, a, y, e, h) : n.texSubImage2D(E, u, d, p, r, a, y, v, e, h);
                break;
            default:
                throw new Error(i);
        }
    }
    function iP(n) {
        switch(n){
            case "1d":
                break;
            case "2d":
                return 3553;
            case "3d":
                return 32879;
            case "cube":
                return 34067;
            case "2d-array":
                return 35866;
        }
        throw new Error(n);
    }
    function s1(n, e, t) {
        return e === "cube" ? 34069 + t : n;
    }
    function rP(n, e) {
        const { sourceX: t = 0, sourceY: i = 0, sourceAttachment: r = 0 } = e || {};
        let { target: a = null, sourceWidth: l, sourceHeight: u, sourceDepth: h, sourceFormat: d, sourceType: p } = e || {};
        const { framebuffer: _, deleteFramebuffer: y } = a1(n), { gl: v, handle: S } = _;
        l ||= _.width, u ||= _.height;
        const E = _.colorAttachments[r]?.texture;
        if (!E) throw new Error(`Invalid framebuffer attachment ${r}`);
        h = E?.depth || 1, d ||= E?.glFormat || 6408, p ||= E?.glType || 5121, a = oP(a, p, d, l, u), p = p || GN(a);
        const M = v.bindFramebuffer(36160, S);
        return v.readBuffer(36064 + r), v.readPixels(t, i, l, u, d, p, a), v.readBuffer(36064), v.bindFramebuffer(36160, M || null), y && _.destroy(), a;
    }
    function sP(n, e) {
        const { target: t, sourceX: i = 0, sourceY: r = 0, sourceFormat: a = 6408, targetByteOffset: l = 0 } = e || {};
        let { sourceWidth: u, sourceHeight: h, sourceType: d } = e || {};
        const { framebuffer: p, deleteFramebuffer: _ } = a1(n);
        u = u || p.width, h = h || p.height;
        const y = p;
        d = d || 5121;
        let v = t;
        if (!v) {
            const E = r1(a), M = eP(d), B = l + u * h * E * M;
            v = y.device.createBuffer({
                byteLength: B
            });
        }
        const S = n.device.createCommandEncoder();
        return S.copyTextureToBuffer({
            sourceTexture: n,
            width: u,
            height: h,
            origin: [
                i,
                r
            ],
            destinationBuffer: v,
            byteOffset: l
        }), S.destroy(), _ && p.destroy(), v;
    }
    function a1(n) {
        return n instanceof nu ? {
            framebuffer: n,
            deleteFramebuffer: !1
        } : {
            framebuffer: aP(n),
            deleteFramebuffer: !0
        };
    }
    function aP(n, e) {
        const { device: t, width: i, height: r, id: a } = n;
        return t.createFramebuffer({
            ...e,
            id: `framebuffer-for-${a}`,
            width: i,
            height: r,
            colorAttachments: [
                n
            ]
        });
    }
    function oP(n, e, t, i, r, a) {
        if (n) return n;
        e ||= 5121;
        const l = JN(e, {
            clamped: !1
        }), u = r1(t);
        return new l(i * r * u);
    }
    class bo extends Xe {
        device;
        gl;
        handle;
        sampler = void 0;
        view = void 0;
        mipmaps;
        compressed;
        glTarget;
        glFormat;
        glType;
        glInternalFormat;
        textureUnit = 0;
        constructor(e, t){
            super(e, t);
            const i = {
                ...this.props
            };
            i.data = t.data, this.device = e, this.gl = this.device.gl, this.glTarget = iP(this.props.dimension);
            const r = e1(this.props.format);
            this.glInternalFormat = r.internalFormat, this.glFormat = r.format, this.glType = r.type, this.compressed = r.compressed, this.mipmaps = !!this.props.mipmaps, this._initialize(i), Object.seal(this);
        }
        _initialize(e) {
            this.handle = this.props.handle || this.gl.createTexture(), this.device.setSpectorMetadata(this.handle, {
                ...this.props,
                data: e.data
            });
            let { width: t, height: i } = e;
            if (!t || !i) {
                const r = Xe.getTextureDataSize(e.data);
                t = r?.width || 1, i = r?.height || 1;
            }
            if (this.width = t, this.height = i, this.depth = e.depth, this.setSampler(e.sampler), this.view = new Ls(this.device, {
                ...this.props,
                texture: this
            }), this.bind(), nP(this.gl, this.mipLevels, this), e.data) switch(e.dimension){
                case "1d":
                    this.setTexture1DData(e.data);
                    break;
                case "2d":
                    this.setTexture2DData(e.data);
                    break;
                case "3d":
                    this.setTexture3DData(e.data);
                    break;
                case "cube":
                    this.setTextureCubeData(e.data);
                    break;
                case "2d-array":
                    this.setTextureArrayData(e.data);
                    break;
                case "cube-array":
                    this.setTextureCubeArrayData(e.data);
                    break;
                default:
                    throw new Error(e.dimension);
            }
            this.mipmaps && this.generateMipmap();
        }
        destroy() {
            this.handle && (this.gl.deleteTexture(this.handle), this.removeStats(), this.trackDeallocatedMemory("Texture"), this.destroyed = !0);
        }
        createView(e) {
            return new Ls(this.device, {
                ...e,
                texture: this
            });
        }
        setSampler(e = {}) {
            let t;
            e instanceof Wd ? (this.sampler = e, t = e.props) : (this.sampler = new Wd(this.device, e), t = e);
            const i = i1(t);
            this._setSamplerParameters(i);
        }
        generateMipmap(e) {
            if (!(!(this.device.isTextureFormatRenderable(this.props.format) && this.device.isTextureFormatFilterable(this.props.format)) && (J.warn(`${this} is not renderable or filterable, may not be able to generate mipmaps`)(), !e?.force))) try {
                this.gl.bindTexture(this.glTarget, this.handle), this.gl.generateMipmap(this.glTarget);
            } catch (i) {
                J.warn(`Error generating mipmap for ${this}: ${i.message}`)();
            } finally{
                this.gl.bindTexture(this.glTarget, null);
            }
        }
        copyExternalImage(e) {
            const t = Xe.getExternalImageSize(e.image), i = {
                ...Xe.defaultCopyExternalImageOptions,
                ...t,
                ...e
            }, { image: r, depth: a, mipLevel: l, x: u, y: h, z: d, flipY: p } = i;
            let { width: _, height: y } = i;
            const { dimension: v, glTarget: S, glFormat: E, glInternalFormat: M, glType: B } = this;
            if (_ = Math.min(_, this.width - u), y = Math.min(y, this.height - h), e.sourceX || e.sourceY) throw new Error("WebGL does not support sourceX/sourceY)");
            return Z0(this.device.gl, this.handle, r, {
                dimension: v,
                mipLevel: l,
                x: u,
                y: h,
                z: d,
                width: _,
                height: y,
                depth: a,
                glFormat: E,
                glType: B,
                glTarget: S,
                flipY: p
            }), {
                width: i.width,
                height: i.height
            };
        }
        setTexture1DData(e) {
            throw new Error("setTexture1DData not supported in WebGL.");
        }
        setTexture2DData(e, t = 0) {
            this.bind();
            const i = Xe.normalizeTextureData(e, this);
            i.length > 1 && this.props.mipmaps !== !1 && J.warn(`Texture ${this.id} mipmap and multiple LODs.`)();
            for(let r = 0; r < i.length; r++){
                const a = i[r];
                this._setMipLevel(t, r, a);
            }
            this.unbind();
        }
        setTexture3DData(e) {
            if (this.props.dimension !== "3d") throw new Error(this.id);
            ArrayBuffer.isView(e) && (this.bind(), Q0(this.device.gl, e, this), this.unbind());
        }
        setTextureCubeData(e, t = 0) {
            if (this.props.dimension !== "cube") throw new Error(this.id);
            for (const i of Xe.CubeFaces)this.setTextureCubeFaceData(e[i], i);
        }
        setTextureArrayData(e) {
            throw this.props.dimension !== "2d-array" ? new Error(this.id) : new Error("setTextureArrayData not implemented.");
        }
        setTextureCubeArrayData(e) {
            throw new Error("setTextureCubeArrayData not supported in WebGL2.");
        }
        setTextureCubeFaceData(e, t, i = 0) {
            Array.isArray(e) && e.length > 1 && this.props.mipmaps !== !1 && J.warn(`${this.id} has mipmap and multiple LODs.`)();
            const r = Xe.CubeFaces.indexOf(t);
            this.setTexture2DData(e, r);
        }
        update() {
            throw new Error("Texture.update() not implemented. Use ExternalTexture");
        }
        setImageDataForFace(e) {
            const { face: t, width: i, height: r, pixels: a, data: l, format: u = 6408, type: h = 5121 } = e, { gl: d } = this, p = a || l;
            this.bind(), p instanceof Promise ? p.then((_)=>this.setImageDataForFace(Object.assign({}, e, {
                    face: t,
                    data: _,
                    pixels: _
                }))) : this.width || this.height ? d.texImage2D(t, 0, u, i, r, 0, u, h, p) : d.texImage2D(t, 0, u, u, h, p);
        }
        _getImageDataMap(e) {
            for(let t = 0; t < Xe.CubeFaces.length; ++t){
                const i = Xe.CubeFaces[t];
                e[i] && (e[34069 + t] = e[i], delete e[i]);
            }
            return e;
        }
        _setSamplerParameters(e) {
            J.log(1, `${this.id} sampler parameters`, this.device.getGLKeys(e))(), this.gl.bindTexture(this.glTarget, this.handle);
            for (const [t, i] of Object.entries(e)){
                const r = Number(t), a = i;
                switch(r){
                    case 33082:
                    case 33083:
                        this.gl.texParameterf(this.glTarget, r, a);
                        break;
                    case 10241:
                        this.gl.texParameteri(this.glTarget, r, a);
                        break;
                    case 10242:
                    case 10243:
                        this.gl.texParameteri(this.glTarget, r, a);
                        break;
                    case 34046:
                        this.device.features.has("texture-filterable-anisotropic-webgl") && this.gl.texParameteri(this.glTarget, r, a);
                        break;
                    default:
                        this.gl.texParameteri(this.glTarget, r, a);
                        break;
                }
            }
            this.gl.bindTexture(this.glTarget, null);
        }
        _setMipLevel(e, t, i, r = this.glTarget) {
            if (Xe.isExternalImage(i)) {
                Z0(this.device.gl, this.handle, i, {
                    ...this,
                    depth: e,
                    mipLevel: t,
                    glTarget: r,
                    flipY: this.props.flipY
                });
                return;
            }
            if (Xe.isTextureLevelData(i)) {
                Q0(this.device.gl, i.data, {
                    ...this,
                    depth: e,
                    mipLevel: t,
                    glTarget: r
                });
                return;
            }
            throw new Error("Texture: invalid image data");
        }
        getActiveUnit() {
            return this.gl.getParameter(34016) - 33984;
        }
        bind(e) {
            const { gl: t } = this;
            return e !== void 0 && (this.textureUnit = e, t.activeTexture(33984 + e)), t.bindTexture(this.glTarget, this.handle), e;
        }
        unbind(e) {
            const { gl: t } = this;
            return e !== void 0 && (this.textureUnit = e, t.activeTexture(33984 + e)), t.bindTexture(this.glTarget, null), e;
        }
    }
    const lP = [
        1,
        2,
        4,
        8
    ];
    class cP extends vr {
        device;
        glParameters;
        constructor(e, t){
            super(e, t), this.device = e;
            let i;
            if (!t?.parameters?.viewport) if (t?.framebuffer) {
                const { width: a, height: l } = t.framebuffer;
                i = [
                    0,
                    0,
                    a,
                    l
                ];
            } else {
                const [a, l] = e.getCanvasContext().getDrawingBufferSize();
                i = [
                    0,
                    0,
                    a,
                    l
                ];
            }
            if (this.device.pushState(), this.setParameters({
                viewport: i,
                ...this.props.parameters
            }), this.props.framebuffer?.handle) if (this.props.framebuffer) {
                const a = this.props.framebuffer.colorAttachments.map((l, u)=>36064 + u);
                this.device.gl.drawBuffers(a);
            } else this.device.gl.drawBuffers([
                1029
            ]);
            this.clear();
        }
        end() {
            this.device.popState();
        }
        pushDebugGroup(e) {}
        popDebugGroup() {}
        insertDebugMarker(e) {}
        setParameters(e = {}) {
            const t = {
                ...this.glParameters
            };
            t.framebuffer = this.props.framebuffer || null, this.props.depthReadOnly && (t.depthMask = !this.props.depthReadOnly), t.stencilMask = this.props.stencilReadOnly ? 0 : 1, t[35977] = this.props.discard, e.viewport && (e.viewport.length >= 6 ? (t.viewport = e.viewport.slice(0, 4), t.depthRange = [
                e.viewport[4],
                e.viewport[5]
            ]) : t.viewport = e.viewport), e.scissorRect && (t.scissorTest = !0, t.scissor = e.scissorRect), e.blendConstant && (t.blendColor = e.blendConstant), e.stencilReference && (console.warn("RenderPassParameters.stencilReference not yet implemented in WebGL"), e[2967] = e.stencilReference), e.colorMask && (t.colorMask = lP.map((i)=>!!(i & e.colorMask))), this.glParameters = t, na(this.device.gl, t);
        }
        beginOcclusionQuery(e) {
            this.props.occlusionQuerySet?.beginOcclusionQuery();
        }
        endOcclusionQuery() {
            this.props.occlusionQuerySet?.endOcclusionQuery();
        }
        clear() {
            const e = {
                ...this.glParameters
            };
            let t = 0;
            this.props.clearColors && this.props.clearColors.forEach((i, r)=>{
                i && this.clearColorBuffer(r, i);
            }), this.props.clearColor !== !1 && this.props.clearColors === void 0 && (t |= 16384, e.clearColor = this.props.clearColor), this.props.clearDepth !== !1 && (t |= 256, e.clearDepth = this.props.clearDepth), this.props.clearStencil !== !1 && (t |= 1024, e.clearStencil = this.props.clearStencil), t !== 0 && Fc(this.device.gl, e, ()=>{
                this.device.gl.clear(t);
            });
        }
        clearColorBuffer(e = 0, t = [
            0,
            0,
            0,
            0
        ]) {
            Fc(this.device.gl, {
                framebuffer: this.props.framebuffer
            }, ()=>{
                switch(t.constructor){
                    case Int8Array:
                    case Int16Array:
                    case Int32Array:
                        this.device.gl.clearBufferiv(6144, e, t);
                        break;
                    case Uint8Array:
                    case Uint8ClampedArray:
                    case Uint16Array:
                    case Uint32Array:
                        this.device.gl.clearBufferuiv(6144, e, t);
                        break;
                    case Float32Array:
                        this.device.gl.clearBufferfv(6144, e, t);
                        break;
                    default:
                        throw new Error("clearColorBuffer: color must be typed array");
                }
            });
        }
    }
    function uP(n) {
        return fP.includes(n);
    }
    const fP = [
        35678,
        35680,
        35679,
        35682,
        36289,
        36292,
        36293,
        36298,
        36299,
        36300,
        36303,
        36306,
        36307,
        36308,
        36311
    ], o1 = {
        5126: [
            5126,
            1,
            "float",
            "f32",
            "float32"
        ],
        35664: [
            5126,
            2,
            "vec2",
            "vec2<f32>",
            "float32x2"
        ],
        35665: [
            5126,
            3,
            "vec3",
            "vec3<f32>",
            "float32x3"
        ],
        35666: [
            5126,
            4,
            "vec4",
            "vec4<f32>",
            "float32x4"
        ],
        5124: [
            5124,
            1,
            "int",
            "i32",
            "sint32"
        ],
        35667: [
            5124,
            2,
            "ivec2",
            "vec2<i32>",
            "sint32x2"
        ],
        35668: [
            5124,
            3,
            "ivec3",
            "vec3<i32>",
            "sint32x3"
        ],
        35669: [
            5124,
            4,
            "ivec4",
            "vec4<i32>",
            "sint32x4"
        ],
        5125: [
            5125,
            1,
            "uint",
            "u32",
            "uint32"
        ],
        36294: [
            5125,
            2,
            "uvec2",
            "vec2<u32>",
            "uint32x2"
        ],
        36295: [
            5125,
            3,
            "uvec3",
            "vec3<u32>",
            "uint32x3"
        ],
        36296: [
            5125,
            4,
            "uvec4",
            "vec4<u32>",
            "uint32x4"
        ],
        35670: [
            5126,
            1,
            "bool",
            "f32",
            "float32"
        ],
        35671: [
            5126,
            2,
            "bvec2",
            "vec2<f32>",
            "float32x2"
        ],
        35672: [
            5126,
            3,
            "bvec3",
            "vec3<f32>",
            "float32x3"
        ],
        35673: [
            5126,
            4,
            "bvec4",
            "vec4<f32>",
            "float32x4"
        ],
        35674: [
            5126,
            8,
            "mat2",
            "mat2x2<f32>"
        ],
        35685: [
            5126,
            8,
            "mat2x3",
            "mat2x3<f32>"
        ],
        35686: [
            5126,
            8,
            "mat2x4",
            "mat2x4<f32>"
        ],
        35687: [
            5126,
            12,
            "mat3x2",
            "mat3x2<f32>"
        ],
        35675: [
            5126,
            12,
            "mat3",
            "mat3x3<f32>"
        ],
        35688: [
            5126,
            12,
            "mat3x4",
            "mat3x4<f32>"
        ],
        35689: [
            5126,
            16,
            "mat4x2",
            "mat4x2<f32>"
        ],
        35690: [
            5126,
            16,
            "mat4x3",
            "mat4x3<f32>"
        ],
        35676: [
            5126,
            16,
            "mat4",
            "mat4x4<f32>"
        ]
    };
    function l1(n) {
        const e = o1[n];
        if (!e) throw new Error("uniform");
        const [t, i, , r] = e;
        return {
            format: r,
            components: i,
            glType: t
        };
    }
    function hP(n) {
        const e = o1[n];
        if (!e) throw new Error("attribute");
        const [, t, , i, r] = e;
        return {
            attributeType: i,
            vertexFormat: r,
            components: t
        };
    }
    function dP(n, e) {
        const t = {
            attributes: [],
            bindings: []
        };
        t.attributes = gP(n, e);
        const i = _P(n, e);
        for (const u of i){
            const h = u.uniforms.map((d)=>({
                    name: d.name,
                    format: d.format,
                    byteOffset: d.byteOffset,
                    byteStride: d.byteStride,
                    arrayLength: d.arrayLength
                }));
            t.bindings.push({
                type: "uniform",
                name: u.name,
                group: 0,
                location: u.location,
                visibility: (u.vertex ? 1 : 0) & (u.fragment ? 2 : 0),
                minBindingSize: u.byteLength,
                uniforms: h
            });
        }
        const r = mP(n, e);
        let a = 0;
        for (const u of r)if (uP(u.type)) {
            const { viewDimension: h, sampleType: d } = bP(u.type);
            t.bindings.push({
                type: "texture",
                name: u.name,
                group: 0,
                location: a,
                viewDimension: h,
                sampleType: d
            }), u.textureUnit = a, a += 1;
        }
        r.length && (t.uniforms = r);
        const l = pP(n, e);
        return l?.length && (t.varyings = l), t;
    }
    function gP(n, e) {
        const t = [], i = n.getProgramParameter(e, 35721);
        for(let r = 0; r < i; r++){
            const a = n.getActiveAttrib(e, r);
            if (!a) throw new Error("activeInfo");
            const { name: l, type: u } = a, h = n.getAttribLocation(e, l);
            if (h >= 0) {
                const { attributeType: d } = hP(u), p = /instance/i.test(l) ? "instance" : "vertex";
                t.push({
                    name: l,
                    location: h,
                    stepMode: p,
                    type: d
                });
            }
        }
        return t.sort((r, a)=>r.location - a.location), t;
    }
    function pP(n, e) {
        const t = [], i = n.getProgramParameter(e, 35971);
        for(let r = 0; r < i; r++){
            const a = n.getTransformFeedbackVarying(e, r);
            if (!a) throw new Error("activeInfo");
            const { name: l, type: u, size: h } = a, { glType: d, components: p } = l1(u), _ = {
                location: r,
                name: l,
                type: d,
                size: h * p
            };
            t.push(_);
        }
        return t.sort((r, a)=>r.location - a.location), t;
    }
    function mP(n, e) {
        const t = [], i = n.getProgramParameter(e, 35718);
        for(let r = 0; r < i; r++){
            const a = n.getActiveUniform(e, r);
            if (!a) throw new Error("activeInfo");
            const { name: l, size: u, type: h } = a, { name: d, isArray: p } = vP(l);
            let _ = n.getUniformLocation(e, d);
            const y = {
                location: _,
                name: d,
                size: u,
                type: h,
                isArray: p
            };
            if (t.push(y), y.size > 1) for(let v = 0; v < y.size; v++){
                const S = `${d}[${v}]`;
                _ = n.getUniformLocation(e, S);
                const E = {
                    ...y,
                    name: S,
                    location: _
                };
                t.push(E);
            }
        }
        return t;
    }
    function _P(n, e) {
        const t = (a, l)=>n.getActiveUniformBlockParameter(e, a, l), i = [], r = n.getProgramParameter(e, 35382);
        for(let a = 0; a < r; a++){
            const l = {
                name: n.getActiveUniformBlockName(e, a) || "",
                location: t(a, 35391),
                byteLength: t(a, 35392),
                vertex: t(a, 35396),
                fragment: t(a, 35398),
                uniformCount: t(a, 35394),
                uniforms: []
            }, u = t(a, 35395) || [], h = n.getActiveUniforms(e, u, 35383), d = n.getActiveUniforms(e, u, 35384), p = n.getActiveUniforms(e, u, 35387), _ = n.getActiveUniforms(e, u, 35388);
            for(let y = 0; y < l.uniformCount; ++y){
                const v = n.getActiveUniform(e, u[y]);
                if (!v) throw new Error("activeInfo");
                l.uniforms.push({
                    name: v.name,
                    format: l1(h[y]).format,
                    type: h[y],
                    arrayLength: d[y],
                    byteOffset: p[y],
                    byteStride: _[y]
                });
            }
            i.push(l);
        }
        return i.sort((a, l)=>a.location - l.location), i;
    }
    const yP = {
        35678: [
            "2d",
            "float"
        ],
        35680: [
            "cube",
            "float"
        ],
        35679: [
            "3d",
            "float"
        ],
        35682: [
            "3d",
            "depth"
        ],
        36289: [
            "2d-array",
            "float"
        ],
        36292: [
            "2d-array",
            "depth"
        ],
        36293: [
            "cube",
            "float"
        ],
        36298: [
            "2d",
            "sint"
        ],
        36299: [
            "3d",
            "sint"
        ],
        36300: [
            "cube",
            "sint"
        ],
        36303: [
            "2d-array",
            "uint"
        ],
        36306: [
            "2d",
            "uint"
        ],
        36307: [
            "3d",
            "uint"
        ],
        36308: [
            "cube",
            "uint"
        ],
        36311: [
            "2d-array",
            "uint"
        ]
    };
    function bP(n) {
        const e = yP[n];
        if (!e) throw new Error("sampler");
        const [t, i] = e;
        return {
            viewDimension: t,
            sampleType: i
        };
    }
    function vP(n) {
        if (n[n.length - 1] !== "]") return {
            name: n,
            length: 1,
            isArray: !1
        };
        const t = /([^[]*)(\[[0-9]+\])?/.exec(n);
        if (!t || t.length < 2) throw new Error(`Failed to parse GLSL uniform name ${n}`);
        return {
            name: t[1],
            length: t[2] ? 1 : 0,
            isArray: !!t[2]
        };
    }
    function TP(n, e, t, i) {
        const r = n;
        let a = i;
        a === !0 && (a = 1), a === !1 && (a = 0);
        const l = typeof a == "number" ? [
            a
        ] : a;
        switch(t){
            case 35678:
            case 35680:
            case 35679:
            case 35682:
            case 36289:
            case 36292:
            case 36293:
            case 36298:
            case 36299:
            case 36300:
            case 36303:
            case 36306:
            case 36307:
            case 36308:
            case 36311:
                if (typeof i != "number") throw new Error("samplers must be set to integers");
                return n.uniform1i(e, i);
            case 5126:
                return n.uniform1fv(e, l);
            case 35664:
                return n.uniform2fv(e, l);
            case 35665:
                return n.uniform3fv(e, l);
            case 35666:
                return n.uniform4fv(e, l);
            case 5124:
                return n.uniform1iv(e, l);
            case 35667:
                return n.uniform2iv(e, l);
            case 35668:
                return n.uniform3iv(e, l);
            case 35669:
                return n.uniform4iv(e, l);
            case 35670:
                return n.uniform1iv(e, l);
            case 35671:
                return n.uniform2iv(e, l);
            case 35672:
                return n.uniform3iv(e, l);
            case 35673:
                return n.uniform4iv(e, l);
            case 5125:
                return r.uniform1uiv(e, l, 1);
            case 36294:
                return r.uniform2uiv(e, l, 2);
            case 36295:
                return r.uniform3uiv(e, l, 3);
            case 36296:
                return r.uniform4uiv(e, l, 4);
            case 35674:
                return n.uniformMatrix2fv(e, !1, l);
            case 35675:
                return n.uniformMatrix3fv(e, !1, l);
            case 35676:
                return n.uniformMatrix4fv(e, !1, l);
            case 35685:
                return r.uniformMatrix2x3fv(e, !1, l);
            case 35686:
                return r.uniformMatrix2x4fv(e, !1, l);
            case 35687:
                return r.uniformMatrix3x2fv(e, !1, l);
            case 35688:
                return r.uniformMatrix3x4fv(e, !1, l);
            case 35689:
                return r.uniformMatrix4x2fv(e, !1, l);
            case 35690:
                return r.uniformMatrix4x3fv(e, !1, l);
        }
        throw new Error("Illegal uniform");
    }
    function xP(n) {
        return VT(n) !== null || typeof n == "number" || typeof n == "boolean";
    }
    function SP(n) {
        const e = {
            bindings: {},
            uniforms: {}
        };
        return Object.keys(n).forEach((t)=>{
            const i = n[t];
            xP(i) ? e.uniforms[t] = i : e.bindings[t] = i;
        }), e;
    }
    function AP(n) {
        switch(n){
            case "point-list":
                return 0;
            case "line-list":
                return 1;
            case "line-strip":
                return 3;
            case "triangle-list":
                return 4;
            case "triangle-strip":
                return 5;
            default:
                throw new Error(n);
        }
    }
    function wP(n) {
        switch(n){
            case "point-list":
                return 0;
            case "line-list":
                return 1;
            case "line-strip":
                return 1;
            case "triangle-list":
                return 4;
            case "triangle-strip":
                return 4;
            default:
                throw new Error(n);
        }
    }
    const G0 = 4;
    class EP extends $s {
        device;
        handle;
        vs;
        fs;
        introspectedLayout;
        uniforms = {};
        bindings = {};
        varyings = null;
        _uniformCount = 0;
        _uniformSetters = {};
        constructor(e, t){
            super(e, t), this.device = e, this.handle = this.props.handle || this.device.gl.createProgram(), this.device.setSpectorMetadata(this.handle, {
                id: this.props.id
            }), this.vs = t.vs, this.fs = t.fs;
            const { varyings: i, bufferMode: r = 35981 } = t;
            i && i.length > 0 && (this.varyings = i, this.device.gl.transformFeedbackVaryings(this.handle, i, r)), this._linkShaders(), J.time(1, `RenderPipeline ${this.id} - shaderLayout introspection`)(), this.introspectedLayout = dP(this.device.gl, this.handle), J.timeEnd(1, `RenderPipeline ${this.id} - shaderLayout introspection`)(), this.shaderLayout = RP(this.introspectedLayout, t.shaderLayout);
        }
        destroy() {
            this.handle && (this.device.gl.deleteProgram(this.handle), this.destroyed = !0);
        }
        setBindings(e, t) {
            for (const [i, r] of Object.entries(e)){
                const a = this.shaderLayout.bindings.find((l)=>l.name === i) || this.shaderLayout.bindings.find((l)=>l.name === `${i}Uniforms`);
                if (!a) {
                    const l = this.shaderLayout.bindings.map((u)=>`"${u.name}"`).join(", ");
                    t?.disableWarnings || J.warn(`No binding "${i}" in render pipeline "${this.id}", expected one of ${l}`, r)();
                    continue;
                }
                switch(r || J.warn(`Unsetting binding "${i}" in render pipeline "${this.id}"`)(), a.type){
                    case "uniform":
                        if (!(r instanceof yo) && !(r.buffer instanceof yo)) throw new Error("buffer value");
                        break;
                    case "texture":
                        if (!(r instanceof Ls || r instanceof bo || r instanceof _o)) throw new Error("texture value");
                        break;
                    case "sampler":
                        J.warn(`Ignoring sampler ${i}`)();
                        break;
                    default:
                        throw new Error(a.type);
                }
                this.bindings[i] = r;
            }
        }
        draw(e) {
            const { renderPass: t, parameters: i = this.props.parameters, topology: r = this.props.topology, vertexArray: a, vertexCount: l, instanceCount: u, isInstanced: h = !1, firstVertex: d = 0, transformFeedback: p } = e, _ = AP(r), y = !!a.indexBuffer, v = a.indexBuffer?.glIndexType;
            if (this.linkStatus !== "success") return J.info(2, `RenderPipeline:${this.id}.draw() aborted - waiting for shader linking`)(), !1;
            if (!this._areTexturesRenderable()) return J.info(2, `RenderPipeline:${this.id}.draw() aborted - textures not yet loaded`)(), !1;
            this.device.gl.useProgram(this.handle), a.bindBeforeRender(t), p && p.begin(this.props.topology), this._applyBindings(), this._applyUniforms();
            const S = t;
            return $N(this.device, i, S.glParameters, ()=>{
                y && h ? this.device.gl.drawElementsInstanced(_, l || 0, v, d, u || 0) : y ? this.device.gl.drawElements(_, l || 0, v, d) : h ? this.device.gl.drawArraysInstanced(_, d, l || 0, u || 0) : this.device.gl.drawArrays(_, d, l || 0), p && p.end();
            }), a.unbindAfterRender(t), !0;
        }
        setUniformsWebGL(e) {
            const { bindings: t } = SP(e);
            Object.keys(t).forEach((i)=>{
                J.warn(`Unsupported value "${JSON.stringify(t[i])}" used in setUniforms() for key ${i}. Use setBindings() instead?`)();
            }), Object.assign(this.uniforms, e);
        }
        async _linkShaders() {
            const { gl: e } = this.device;
            if (e.attachShader(this.handle, this.vs.handle), e.attachShader(this.handle, this.fs.handle), J.time(G0, `linkProgram for ${this.id}`)(), e.linkProgram(this.handle), J.timeEnd(G0, `linkProgram for ${this.id}`)(), J.level, !this.device.features.has("compilation-status-async-webgl")) {
                const i = this._getLinkStatus();
                this._reportLinkStatus(i);
                return;
            }
            J.once(1, "RenderPipeline linking is asynchronous")(), await this._waitForLinkComplete(), J.info(2, `RenderPipeline ${this.id} - async linking complete: ${this.linkStatus}`)();
            const t = this._getLinkStatus();
            this._reportLinkStatus(t);
        }
        async _reportLinkStatus(e) {
            switch(e){
                case "success":
                    return;
                default:
                    switch(this.vs.compilationStatus){
                        case "error":
                            throw this.vs.debugShader(), new Error(`Error during compilation of shader ${this.vs.id}`);
                        case "pending":
                            this.vs.asyncCompilationStatus.then(()=>this.vs.debugShader());
                            break;
                    }
                    switch(this.fs?.compilationStatus){
                        case "error":
                            throw this.fs.debugShader(), new Error(`Error during compilation of shader ${this.fs.id}`);
                        case "pending":
                            this.fs.asyncCompilationStatus.then(()=>this.fs.debugShader());
                            break;
                    }
                    const t = this.device.gl.getProgramInfoLog(this.handle);
                    throw new Error(`Error during ${e}: ${t}`);
            }
        }
        _getLinkStatus() {
            const { gl: e } = this.device;
            return e.getProgramParameter(this.handle, 35714) ? (e.validateProgram(this.handle), e.getProgramParameter(this.handle, 35715) ? (this.linkStatus = "success", "success") : (this.linkStatus = "error", "validation")) : (this.linkStatus = "error", "linking");
        }
        async _waitForLinkComplete() {
            const e = async (r)=>await new Promise((a)=>setTimeout(a, r));
            if (!this.device.features.has("compilation-status-async-webgl")) {
                await e(10);
                return;
            }
            const { gl: i } = this.device;
            for(;;){
                if (i.getProgramParameter(this.handle, 37297)) return;
                await e(10);
            }
        }
        _areTexturesRenderable() {
            let e = !0;
            for (const t of this.shaderLayout.bindings)!this.bindings[t.name] && !this.bindings[t.name.replace(/Uniforms$/, "")] && (J.warn(`Binding ${t.name} not found in ${this.id}`)(), e = !1);
            return e;
        }
        _applyBindings() {
            if (this.linkStatus !== "success") return;
            const { gl: e } = this.device;
            e.useProgram(this.handle);
            let t = 0, i = 0;
            for (const r of this.shaderLayout.bindings){
                const a = this.bindings[r.name] || this.bindings[r.name.replace(/Uniforms$/, "")];
                if (!a) throw new Error(`No value for binding ${r.name} in ${this.id}`);
                switch(r.type){
                    case "uniform":
                        const { name: l } = r, u = e.getUniformBlockIndex(this.handle, l);
                        if (u === 4294967295) throw new Error(`Invalid uniform block name ${l}`);
                        e.uniformBlockBinding(this.handle, i, u), a instanceof yo ? e.bindBufferBase(35345, i, a.handle) : e.bindBufferRange(35345, i, a.buffer.handle, a.offset || 0, a.size || a.buffer.byteLength - a.offset), i += 1;
                        break;
                    case "texture":
                        if (!(a instanceof Ls || a instanceof bo || a instanceof _o)) throw new Error("texture");
                        let h;
                        if (a instanceof Ls) h = a.texture;
                        else if (a instanceof bo) h = a;
                        else if (a instanceof _o && a.colorAttachments[0] instanceof Ls) J.warn("Passing framebuffer in texture binding may be deprecated. Use fbo.colorAttachments[0] instead")(), h = a.colorAttachments[0].texture;
                        else throw new Error("No texture");
                        e.activeTexture(33984 + t), e.bindTexture(h.glTarget, h.handle), t += 1;
                        break;
                    case "sampler":
                        break;
                    case "storage":
                    case "read-only-storage":
                        throw new Error(`binding type '${r.type}' not supported in WebGL`);
                }
            }
        }
        _applyUniforms() {
            for (const e of this.shaderLayout.uniforms || []){
                const { name: t, location: i, type: r, textureUnit: a } = e, l = this.uniforms[t] ?? a;
                l !== void 0 && TP(this.device.gl, i, r, l);
            }
        }
    }
    function RP(n, e) {
        const t = {
            ...n,
            attributes: n.attributes.map((i)=>({
                    ...i
                }))
        };
        for (const i of e?.attributes || []){
            const r = t.attributes.find((a)=>a.name === i.name);
            r ? (r.type = i.type || r.type, r.stepMode = i.stepMode || r.stepMode) : J.warn(`shader layout attribute ${i.name} not present in shader`);
        }
        return t;
    }
    class CP extends pg {
        device;
        commands = [];
        constructor(e){
            super(e, {}), this.device = e;
        }
        submitCommands(e = this.commands) {
            for (const t of e)switch(t.name){
                case "copy-buffer-to-buffer":
                    MP(this.device, t.options);
                    break;
                case "copy-buffer-to-texture":
                    OP(this.device, t.options);
                    break;
                case "copy-texture-to-buffer":
                    IP(this.device, t.options);
                    break;
                case "copy-texture-to-texture":
                    NP(this.device, t.options);
                    break;
                default:
                    throw new Error(t.name);
            }
        }
    }
    function MP(n, e) {
        const t = e.sourceBuffer, i = e.destinationBuffer;
        n.gl.bindBuffer(36662, t.handle), n.gl.bindBuffer(36663, i.handle), n.gl.copyBufferSubData(36662, 36663, e.sourceOffset ?? 0, e.destinationOffset ?? 0, e.size), n.gl.bindBuffer(36662, null), n.gl.bindBuffer(36663, null);
    }
    function OP(n, e) {
        throw new Error("Not implemented");
    }
    function IP(n, e) {
        const { sourceTexture: t, mipLevel: i = 0, aspect: r = "all", width: a = e.sourceTexture.width, height: l = e.sourceTexture.height, depthOrArrayLayers: u = 0, origin: h = [
            0,
            0
        ], destinationBuffer: d, byteOffset: p = 0, bytesPerRow: _, rowsPerImage: y } = e;
        if (r !== "all") throw new Error("aspect not supported in WebGL");
        if (i !== 0 || u !== 0 || _ || y) throw new Error("not implemented");
        const { framebuffer: v, destroyFramebuffer: S } = c1(t);
        let E;
        try {
            const M = d, B = a || v.width, H = l || v.height, O = e1(v.colorAttachments[0].texture.props.format), U = O.format, L = O.type;
            n.gl.bindBuffer(35051, M.handle), E = n.gl.bindFramebuffer(36160, v.handle), n.gl.readPixels(h[0], h[1], B, H, U, L, p);
        } finally{
            n.gl.bindBuffer(35051, null), E !== void 0 && n.gl.bindFramebuffer(36160, E), S && v.destroy();
        }
    }
    function NP(n, e) {
        const { sourceTexture: t, destinationMipLevel: i = 0, origin: r = [
            0,
            0
        ], destinationOrigin: a = [
            0,
            0
        ], destinationTexture: l } = e;
        let { width: u = e.destinationTexture.width, height: h = e.destinationTexture.height } = e;
        const { framebuffer: d, destroyFramebuffer: p } = c1(t), [_, y] = r, [v, S, E] = a, M = n.gl.bindFramebuffer(36160, d.handle);
        let B = null, H;
        if (l instanceof bo) B = l, u = Number.isFinite(u) ? u : B.width, h = Number.isFinite(h) ? h : B.height, B.bind(0), H = B.glTarget;
        else throw new Error("invalid destination");
        switch(H){
            case 3553:
            case 34067:
                n.gl.copyTexSubImage2D(H, i, v, S, _, y, u, h);
                break;
            case 35866:
            case 32879:
                n.gl.copyTexSubImage3D(H, i, v, S, E, _, y, u, h);
                break;
        }
        B && B.unbind(), n.gl.bindFramebuffer(36160, M), p && d.destroy();
    }
    function c1(n) {
        if (n instanceof Xe) {
            const { width: e, height: t, id: i } = n;
            return {
                framebuffer: n.device.createFramebuffer({
                    id: `framebuffer-for-${i}`,
                    width: e,
                    height: t,
                    colorAttachments: [
                        n
                    ]
                }),
                destroyFramebuffer: !0
            };
        }
        return {
            framebuffer: n,
            destroyFramebuffer: !1
        };
    }
    class PP extends gg {
        device;
        commandBuffer;
        constructor(e, t){
            super(e, t), this.device = e, this.commandBuffer = new CP(e);
        }
        destroy() {}
        finish() {
            this.commandBuffer.submitCommands();
        }
        copyBufferToBuffer(e) {
            this.commandBuffer.commands.push({
                name: "copy-buffer-to-buffer",
                options: e
            });
        }
        copyBufferToTexture(e) {
            this.commandBuffer.commands.push({
                name: "copy-buffer-to-texture",
                options: e
            });
        }
        copyTextureToBuffer(e) {
            this.commandBuffer.commands.push({
                name: "copy-texture-to-buffer",
                options: e
            });
        }
        copyTextureToTexture(e) {
            this.commandBuffer.commands.push({
                name: "copy-texture-to-texture",
                options: e
            });
        }
        pushDebugGroup(e) {}
        popDebugGroup() {}
        insertDebugMarker(e) {}
        resolveQuerySet(e, t, i) {}
    }
    function DP(n) {
        const { target: e, source: t, start: i = 0, count: r = 1 } = n, a = t.length, l = r * a;
        let u = 0;
        for(let h = i; u < a; u++)e[h++] = t[u];
        for(; u < l;)u < l - u ? (e.copyWithin(i + u, i, i + u), u *= 2) : (e.copyWithin(i + u, i, i + l - u), u = l);
        return n.target;
    }
    class Vg extends mg {
        get [Symbol.toStringTag]() {
            return "VertexArray";
        }
        device;
        handle;
        buffer = null;
        bufferValue = null;
        static isConstantAttributeZeroSupported(e) {
            return QS() === "Chrome";
        }
        constructor(e, t){
            super(e, t), this.device = e, this.handle = this.device.gl.createVertexArray();
        }
        destroy() {
            super.destroy(), this.buffer && this.buffer?.destroy(), this.handle && (this.device.gl.deleteVertexArray(this.handle), this.handle = void 0);
        }
        setIndexBuffer(e) {
            const t = e;
            if (t && t.glTarget !== 34963) throw new Error("Use .setBuffer()");
            this.device.gl.bindVertexArray(this.handle), this.device.gl.bindBuffer(34963, t ? t.handle : null), this.indexBuffer = t, this.device.gl.bindVertexArray(null);
        }
        setBuffer(e, t) {
            const i = t;
            if (i.glTarget === 34963) throw new Error("Use .setIndexBuffer()");
            const { size: r, type: a, stride: l, offset: u, normalized: h, integer: d, divisor: p } = this._getAccessor(e);
            this.device.gl.bindVertexArray(this.handle), this.device.gl.bindBuffer(34962, i.handle), d ? this.device.gl.vertexAttribIPointer(e, r, a, l, u) : this.device.gl.vertexAttribPointer(e, r, a, h, l, u), this.device.gl.bindBuffer(34962, null), this.device.gl.enableVertexAttribArray(e), this.device.gl.vertexAttribDivisor(e, p || 0), this.attributes[e] = i, this.device.gl.bindVertexArray(null);
        }
        setConstantWebGL(e, t) {
            this._enable(e, !1), this.attributes[e] = t;
        }
        bindBeforeRender() {
            this.device.gl.bindVertexArray(this.handle), this._applyConstantAttributes();
        }
        unbindAfterRender() {
            this.device.gl.bindVertexArray(null);
        }
        _applyConstantAttributes() {
            for(let e = 0; e < this.maxVertexAttributes; ++e){
                const t = this.attributes[e];
                ArrayBuffer.isView(t) && this.device.setConstantAttributeWebGL(e, t);
            }
        }
        _getAccessor(e) {
            const t = this.attributeInfos[e];
            if (!t) throw new Error(`Unknown attribute location ${e}`);
            const i = JT(t.bufferDataType);
            return {
                size: t.bufferComponents,
                type: i,
                stride: t.byteStride,
                offset: t.byteOffset,
                normalized: t.normalized,
                integer: t.integer,
                divisor: t.stepMode === "instance" ? 1 : 0
            };
        }
        _enable(e, t = !0) {
            const r = Vg.isConstantAttributeZeroSupported(this.device) || e !== 0;
            (t || r) && (e = Number(e), this.device.gl.bindVertexArray(this.handle), t ? this.device.gl.enableVertexAttribArray(e) : this.device.gl.disableVertexAttribArray(e), this.device.gl.bindVertexArray(null));
        }
        getConstantBuffer(e, t) {
            const i = kP(t), r = i.byteLength * e, a = i.length * e;
            if (this.buffer && r !== this.buffer.byteLength) throw new Error(`Buffer size is immutable, byte length ${r} !== ${this.buffer.byteLength}.`);
            let l = !this.buffer;
            if (this.buffer = this.buffer || this.device.createBuffer({
                byteLength: r
            }), l = l || !UP(i, this.bufferValue), l) {
                const u = UR(t.constructor, a);
                DP({
                    target: u,
                    source: i,
                    start: 0,
                    count: a
                }), this.buffer.write(u), this.bufferValue = t;
            }
            return this.buffer;
        }
    }
    function kP(n) {
        return Array.isArray(n) ? new Float32Array(n) : n;
    }
    function UP(n, e) {
        if (!n || !e || n.length !== e.length || n.constructor !== e.constructor) return !1;
        for(let t = 0; t < n.length; ++t)if (n[t] !== e[t]) return !1;
        return !0;
    }
    class BP extends _g {
        device;
        gl;
        handle;
        layout;
        buffers = {};
        unusedBuffers = {};
        bindOnUse = !0;
        _bound = !1;
        constructor(e, t){
            super(e, t), this.device = e, this.gl = e.gl, this.handle = this.props.handle || this.gl.createTransformFeedback(), this.layout = this.props.layout, t.buffers && this.setBuffers(t.buffers), Object.seal(this);
        }
        destroy() {
            this.gl.deleteTransformFeedback(this.handle), super.destroy();
        }
        begin(e = "point-list") {
            this.gl.bindTransformFeedback(36386, this.handle), this.bindOnUse && this._bindBuffers(), this.gl.beginTransformFeedback(wP(e));
        }
        end() {
            this.gl.endTransformFeedback(), this.bindOnUse && this._unbindBuffers(), this.gl.bindTransformFeedback(36386, null);
        }
        setBuffers(e) {
            this.buffers = {}, this.unusedBuffers = {}, this.bind(()=>{
                for(const t in e)this.setBuffer(t, e[t]);
            });
        }
        setBuffer(e, t) {
            const i = this._getVaryingIndex(e), { buffer: r, byteLength: a, byteOffset: l } = this._getBufferRange(t);
            if (i < 0) {
                this.unusedBuffers[e] = r, J.warn(`${this.id} unusedBuffers varying buffer ${e}`)();
                return;
            }
            this.buffers[i] = {
                buffer: r,
                byteLength: a,
                byteOffset: l
            }, this.bindOnUse || this._bindBuffer(i, r, l, a);
        }
        getBuffer(e) {
            if (J0(e)) return this.buffers[e] || null;
            const t = this._getVaryingIndex(e);
            return t >= 0 ? this.buffers[t] : null;
        }
        bind(e = this.handle) {
            if (typeof e != "function") return this.gl.bindTransformFeedback(36386, e), this;
            let t;
            return this._bound ? t = e() : (this.gl.bindTransformFeedback(36386, this.handle), this._bound = !0, t = e(), this._bound = !1, this.gl.bindTransformFeedback(36386, null)), t;
        }
        unbind() {
            this.bind(null);
        }
        _getBufferRange(e) {
            if (e instanceof yo) return {
                buffer: e,
                byteOffset: 0,
                byteLength: e.byteLength
            };
            const { buffer: t, byteOffset: i = 0, byteLength: r = e.buffer.byteLength } = e;
            return {
                buffer: t,
                byteOffset: i,
                byteLength: r
            };
        }
        _getVaryingIndex(e) {
            if (J0(e)) return Number(e);
            for (const t of this.layout.varyings)if (e === t.name) return t.location;
            return -1;
        }
        _bindBuffers() {
            for(const e in this.buffers){
                const { buffer: t, byteLength: i, byteOffset: r } = this._getBufferRange(this.buffers[e]);
                this._bindBuffer(Number(e), t, r, i);
            }
        }
        _unbindBuffers() {
            for(const e in this.buffers)this.gl.bindBufferBase(35982, Number(e), null);
        }
        _bindBuffer(e, t, i = 0, r) {
            const a = t && t.handle;
            !a || r === void 0 ? this.gl.bindBufferBase(35982, e, a) : this.gl.bindBufferRange(35982, e, a, i, r);
        }
    }
    function J0(n) {
        return typeof n == "number" ? Number.isInteger(n) : /^\d+$/.test(n);
    }
    class LP extends yg {
        device;
        handle;
        target = null;
        _queryPending = !1;
        _pollingPromise = null;
        get [Symbol.toStringTag]() {
            return "Query";
        }
        constructor(e, t){
            if (super(e, t), this.device = e, t.count > 1) throw new Error("WebGL QuerySet can only have one value");
            this.handle = this.device.gl.createQuery(), Object.seal(this);
        }
        destroy() {
            this.device.gl.deleteQuery(this.handle);
        }
        beginTimestampQuery() {
            return this._begin(35007);
        }
        endTimestampQuery() {
            this._end();
        }
        beginOcclusionQuery(e) {
            return this._begin(e?.conservative ? 36202 : 35887);
        }
        endOcclusionQuery() {
            this._end();
        }
        beginTransformFeedbackQuery() {
            return this._begin(35976);
        }
        endTransformFeedbackQuery() {
            this._end();
        }
        async resolveQuery() {
            return [
                await this.pollQuery()
            ];
        }
        _begin(e) {
            this._queryPending || (this.target = e, this.device.gl.beginQuery(this.target, this.handle));
        }
        _end() {
            this._queryPending || this.target && (this.device.gl.endQuery(this.target), this.target = null, this._queryPending = !0);
        }
        isResultAvailable() {
            if (!this._queryPending) return !1;
            const e = this.device.gl.getQueryParameter(this.handle, 34919);
            return e && (this._queryPending = !1), e;
        }
        isTimerDisjoint() {
            return this.device.gl.getParameter(36795);
        }
        getResult() {
            return this.device.gl.getQueryParameter(this.handle, 34918);
        }
        getTimerMilliseconds() {
            return this.getResult() / 1e6;
        }
        pollQuery(e = Number.POSITIVE_INFINITY) {
            if (this._pollingPromise) return this._pollingPromise;
            let t = 0;
            return this._pollingPromise = new Promise((i, r)=>{
                const a = ()=>{
                    this.isResultAvailable() ? (i(this.getResult()), this._pollingPromise = null) : t++ > e ? (r("Timed out"), this._pollingPromise = null) : requestAnimationFrame(a);
                };
                requestAnimationFrame(a);
            }), this._pollingPromise;
        }
    }
    class Fs extends qi {
        type = "webgl";
        handle;
        features;
        limits;
        info;
        canvasContext;
        lost;
        _resolveContextLost;
        gl;
        debug = !1;
        _canvasSizeInfo = {
            clientWidth: 0,
            clientHeight: 0,
            devicePixelRatio: 1
        };
        _extensions = {};
        _polyfilled = !1;
        spectorJS;
        constructor(e){
            super({
                ...e,
                id: e.id || zN("webgl-device")
            });
            const t = qi._getCanvasContextProps(e);
            if (!t) throw new Error("WebGLDevice requires props.createCanvasContext to be set");
            let i = t.canvas?.gl?.device;
            if (i) throw new Error(`WebGL context already attached to device ${i.id}`);
            this.canvasContext = new MN(this, t), this.lost = new Promise((p)=>{
                this._resolveContextLost = p;
            });
            const r = {
                ...e.webgl
            };
            t.alphaMode === "premultiplied" && (r.premultipliedAlpha = !0), e.powerPreference !== void 0 && (r.powerPreference = e.powerPreference);
            const l = this.props._handle || cN(this.canvasContext.canvas, {
                onContextLost: (p)=>this._resolveContextLost?.({
                        reason: "destroyed",
                        message: "Entered sleep mode, or too many apps or browser tabs are using the GPU."
                    }),
                onContextRestored: (p)=>console.log("WebGL context restored")
            }, r);
            if (!l) throw new Error("WebGL context creation failed");
            if (i = l.device, i) {
                if (e._reuseDevices) return J.log(1, `Not creating a new Device, instead returning a reference to Device ${i.id} already attached to WebGL context`, i)(), i._reused = !0, i;
                throw new Error(`WebGL context already attached to device ${i.id}`);
            }
            this.handle = l, this.gl = l, this.spectorJS = NN({
                ...this.props,
                gl: this.handle
            }), this.gl.device = this, this.gl._version = 2, this.info = uN(this.gl, this._extensions), this.limits = new EN(this.gl), this.features = new wN(this.gl, this._extensions, this.props._disabledFeatures), this.props._initializeFeatures && this.features.initializeFeatures(), t.autoResize !== !1 && this.canvasContext.resize(), new Er(this.gl, {
                log: (...p)=>J.log(1, ...p)()
            }).trackState(this.gl, {
                copyState: !1
            });
            const h = e.debugWebGL || e.debug, d = e.debugWebGL;
            h && (this.gl = kN(this.gl, {
                debugWebGL: h,
                traceWebGL: d
            }), J.warn("WebGL debug mode activated. Performance reduced.")(), e.debugWebGL && (J.level = Math.max(J.level, 1)));
        }
        destroy() {
            !this.props._reuseDevices && !this._reused && delete this.gl.device;
        }
        get isLost() {
            return this.gl.isContextLost();
        }
        createCanvasContext(e) {
            throw new Error("WebGL only supports a single canvas");
        }
        createBuffer(e) {
            const t = this._normalizeBufferProps(e);
            return new yo(this, t);
        }
        createTexture(e) {
            return new bo(this, e);
        }
        createExternalTexture(e) {
            throw new Error("createExternalTexture() not implemented");
        }
        createSampler(e) {
            return new Wd(this, e);
        }
        createShader(e) {
            return new WN(this, e);
        }
        createFramebuffer(e) {
            return new _o(this, e);
        }
        createVertexArray(e) {
            return new Vg(this, e);
        }
        createTransformFeedback(e) {
            return new BP(this, e);
        }
        createQuerySet(e) {
            return new LP(this, e);
        }
        createRenderPipeline(e) {
            return new EP(this, e);
        }
        beginRenderPass(e) {
            return new cP(this, e);
        }
        createComputePipeline(e) {
            throw new Error("ComputePipeline not supported in WebGL");
        }
        beginComputePass(e) {
            throw new Error("ComputePass not supported in WebGL");
        }
        renderPass = null;
        createCommandEncoder(e = {}) {
            return new PP(this, e);
        }
        submit() {
            this.renderPass?.end(), this.renderPass = null;
        }
        readPixelsToArrayWebGL(e, t) {
            return rP(e, t);
        }
        readPixelsToBufferWebGL(e, t) {
            return sP(e, t);
        }
        setParametersWebGL(e) {
            na(this.gl, e);
        }
        getParametersWebGL(e) {
            return QT(this.gl, e);
        }
        withParametersWebGL(e, t) {
            return Fc(this.gl, e, t);
        }
        resetWebGL() {
            J.warn("WebGLDevice.resetWebGL is deprecated, use only for debugging")(), rN(this.gl);
        }
        _getDeviceSpecificTextureFormatCapabilities(e) {
            return TN(this.gl, e, this._extensions);
        }
        loseDevice() {
            let e = !1;
            const i = this.getExtension("WEBGL_lose_context").WEBGL_lose_context;
            return i && (e = !0, i.loseContext()), this._resolveContextLost?.({
                reason: "destroyed",
                message: "Application triggered context loss"
            }), e;
        }
        pushState() {
            Er.get(this.gl).push();
        }
        popState() {
            Er.get(this.gl).pop();
        }
        setSpectorMetadata(e, t) {
            e.__SPECTOR_Metadata = t;
        }
        getGLKey(e, t) {
            const i = Number(e);
            for(const r in this.gl)if (this.gl[r] === i) return `GL.${r}`;
            return t?.emptyIfUnknown ? "" : String(e);
        }
        getGLKeys(e) {
            const t = {
                emptyIfUnknown: !0
            };
            return Object.entries(e).reduce((i, [r, a])=>(i[`${r}:${this.getGLKey(r, t)}`] = `${a}:${this.getGLKey(a, t)}`, i), {});
        }
        _constants;
        setConstantAttributeWebGL(e, t) {
            const i = this.limits.maxVertexAttributes;
            this._constants = this._constants || new Array(i).fill(null);
            const r = this._constants[e];
            switch(r && HP(r, t) && J.info(1, `setConstantAttributeWebGL(${e}) could have been skipped, value unchanged`)(), this._constants[e] = t, t.constructor){
                case Float32Array:
                    FP(this, e, t);
                    break;
                case Int32Array:
                    zP(this, e, t);
                    break;
                case Uint32Array:
                    VP(this, e, t);
                    break;
                default:
                    throw new Error("constant");
            }
        }
        getExtension(e) {
            return Js(this.gl, e, this._extensions), this._extensions;
        }
    }
    function FP(n, e, t) {
        switch(t.length){
            case 1:
                n.gl.vertexAttrib1fv(e, t);
                break;
            case 2:
                n.gl.vertexAttrib2fv(e, t);
                break;
            case 3:
                n.gl.vertexAttrib3fv(e, t);
                break;
            case 4:
                n.gl.vertexAttrib4fv(e, t);
                break;
        }
    }
    function zP(n, e, t) {
        n.gl.vertexAttribI4iv(e, t);
    }
    function VP(n, e, t) {
        n.gl.vertexAttribI4uiv(e, t);
    }
    function HP(n, e) {
        if (!n || !e || n.length !== e.length || n.constructor !== e.constructor) return !1;
        for(let t = 0; t < n.length; ++t)if (n[t] !== e[t]) return !1;
        return !0;
    }
    const jP = {
        WEBGL_depth_texture: {
            UNSIGNED_INT_24_8_WEBGL: 34042
        },
        OES_element_index_uint: {},
        OES_texture_float: {},
        OES_texture_half_float: {
            HALF_FLOAT_OES: 5131
        },
        EXT_color_buffer_float: {},
        OES_standard_derivatives: {
            FRAGMENT_SHADER_DERIVATIVE_HINT_OES: 35723
        },
        EXT_frag_depth: {},
        EXT_blend_minmax: {
            MIN_EXT: 32775,
            MAX_EXT: 32776
        },
        EXT_shader_texture_lod: {}
    }, WP = (n)=>({
            drawBuffersWEBGL (e) {
                return n.drawBuffers(e);
            },
            COLOR_ATTACHMENT0_WEBGL: 36064,
            COLOR_ATTACHMENT1_WEBGL: 36065,
            COLOR_ATTACHMENT2_WEBGL: 36066,
            COLOR_ATTACHMENT3_WEBGL: 36067
        }), $P = (n)=>({
            VERTEX_ARRAY_BINDING_OES: 34229,
            createVertexArrayOES () {
                return n.createVertexArray();
            },
            deleteVertexArrayOES (e) {
                return n.deleteVertexArray(e);
            },
            isVertexArrayOES (e) {
                return n.isVertexArray(e);
            },
            bindVertexArrayOES (e) {
                return n.bindVertexArray(e);
            }
        }), XP = (n)=>({
            VERTEX_ATTRIB_ARRAY_DIVISOR_ANGLE: 35070,
            drawArraysInstancedANGLE (...e) {
                return n.drawArraysInstanced(...e);
            },
            drawElementsInstancedANGLE (...e) {
                return n.drawElementsInstanced(...e);
            },
            vertexAttribDivisorANGLE (...e) {
                return n.vertexAttribDivisor(...e);
            }
        });
    function YP(n = !0) {
        const e = HTMLCanvasElement.prototype;
        if (!n && e.originalGetContext) {
            e.getContext = e.originalGetContext, e.originalGetContext = void 0;
            return;
        }
        e.originalGetContext = e.getContext, e.getContext = function(t, i) {
            if (t === "webgl" || t === "experimental-webgl") {
                const r = this.originalGetContext("webgl2", i);
                return r instanceof HTMLElement && qP(r), r;
            }
            return this.originalGetContext(t, i);
        };
    }
    function qP(n) {
        n.getExtension("EXT_color_buffer_float");
        const e = {
            ...jP,
            WEBGL_disjoint_timer_query: n.getExtension("EXT_disjoint_timer_query_webgl2"),
            WEBGL_draw_buffers: WP(n),
            OES_vertex_array_object: $P(n),
            ANGLE_instanced_arrays: XP(n)
        }, t = n.getExtension;
        n.getExtension = function(r) {
            const a = t.call(n, r);
            return a || (r in e ? e[r] : null);
        };
        const i = n.getSupportedExtensions;
        n.getSupportedExtensions = function() {
            return (i.apply(n) || [])?.concat(Object.keys(e));
        };
    }
    const oc = 1;
    class KP extends hR {
        type = "webgl";
        constructor(){
            super(), qi.defaultProps = {
                ...qi.defaultProps,
                ...zg
            }, Fs.adapter = this;
        }
        isSupported() {
            return typeof WebGL2RenderingContext < "u";
        }
        enforceWebGL2(e) {
            YP(e);
        }
        async attach(e) {
            if (e instanceof Fs) return e;
            if (e?.device instanceof qi) return e.device;
            if (!ZP(e)) throw new Error("Invalid WebGL2RenderingContext");
            return new Fs({
                _handle: e,
                createCanvasContext: {
                    canvas: e.canvas,
                    autoResize: !1
                }
            });
        }
        async create(e = {}) {
            J.groupCollapsed(oc, "WebGLDevice created")();
            const t = [];
            (e.debugWebGL || e.debug) && t.push(DN()), e.debugSpectorJS && t.push(IN(e));
            const i = await Promise.allSettled(t);
            for (const l of i)l.status === "rejected" && J.error(`Failed to initialize debug libraries ${l.reason}`)();
            const r = new Fs(e), a = `${r._reused ? "Reusing" : "Created"} device with WebGL2 ${r.debug ? "debug " : ""}context: ${r.info.vendor}, ${r.info.renderer} for canvas: ${r.canvasContext.id}`;
            return J.probe(oc, a)(), J.table(oc, r.info)(), J.groupEnd(oc)(), r;
        }
    }
    function ZP(n) {
        return typeof WebGL2RenderingContext < "u" && n instanceof WebGL2RenderingContext ? !0 : !!(n && Number.isFinite(n._version));
    }
    const ev = new KP;
    function Hi() {}
    const QP = ({ isDragging: n })=>n ? "grabbing" : "grab", u1 = {
        id: "",
        width: "100%",
        height: "100%",
        style: null,
        viewState: null,
        initialViewState: null,
        pickingRadius: 0,
        layerFilter: null,
        parameters: {},
        parent: null,
        device: null,
        deviceProps: {},
        gl: null,
        canvas: null,
        layers: [],
        effects: [],
        views: null,
        controller: null,
        useDevicePixels: !0,
        touchAction: "none",
        eventRecognizerOptions: {},
        _framebuffer: null,
        _animate: !1,
        _pickable: !0,
        _typedArrayManagerProps: {},
        _customRender: null,
        widgets: [],
        onDeviceInitialized: Hi,
        onWebGLInitialized: Hi,
        onResize: Hi,
        onViewStateChange: Hi,
        onInteractionStateChange: Hi,
        onBeforeRender: Hi,
        onAfterRender: Hi,
        onLoad: Hi,
        onError: (n)=>Fe.error(n.message, n.cause)(),
        onHover: null,
        onClick: null,
        onDragStart: null,
        onDrag: null,
        onDragEnd: null,
        _onMetrics: null,
        getCursor: QP,
        getTooltip: null,
        debug: !1,
        drawPickingColors: !1
    };
    class Hg {
        constructor(e){
            this.width = 0, this.height = 0, this.userData = {}, this.device = null, this.canvas = null, this.viewManager = null, this.layerManager = null, this.effectManager = null, this.deckRenderer = null, this.deckPicker = null, this.eventManager = null, this.widgetManager = null, this.tooltip = null, this.animationLoop = null, this.cursorState = {
                isHovering: !1,
                isDragging: !1
            }, this.stats = new Qc({
                id: "deck.gl"
            }), this.metrics = {
                fps: 0,
                setPropsTime: 0,
                updateAttributesTime: 0,
                framesRedrawn: 0,
                pickTime: 0,
                pickCount: 0,
                gpuTime: 0,
                gpuTimePerFrame: 0,
                cpuTime: 0,
                cpuTimePerFrame: 0,
                bufferMemory: 0,
                textureMemory: 0,
                renderbufferMemory: 0,
                gpuMemory: 0
            }, this._metricsCounter = 0, this._needsRedraw = "Initial render", this._pickRequest = {
                mode: "hover",
                x: -1,
                y: -1,
                radius: 0,
                event: null
            }, this._lastPointerDownInfo = null, this._onPointerMove = (i)=>{
                const { _pickRequest: r } = this;
                if (i.type === "pointerleave") r.x = -1, r.y = -1, r.radius = 0;
                else {
                    if (i.leftButton || i.rightButton) return;
                    {
                        const a = i.offsetCenter;
                        if (!a) return;
                        r.x = a.x, r.y = a.y, r.radius = this.props.pickingRadius;
                    }
                }
                this.layerManager && (this.layerManager.context.mousePosition = {
                    x: r.x,
                    y: r.y
                }), r.event = i;
            }, this._onEvent = (i)=>{
                const r = Dd[i.type], a = i.offsetCenter;
                if (!r || !a || !this.layerManager) return;
                const l = this.layerManager.getLayers(), u = this.deckPicker.getLastPickedObject({
                    x: a.x,
                    y: a.y,
                    layers: l,
                    viewports: this.getViewports(a)
                }, this._lastPointerDownInfo), { layer: h } = u, d = h && (h[r] || h.props[r]), p = this.props[r];
                let _ = !1;
                d && (_ = d.call(h, u, i)), _ || (p?.(u, i), this.widgetManager.onEvent(u, i));
            }, this._onPointerDown = (i)=>{
                if (this.device?.type === "webgpu") return;
                const r = i.offsetCenter, a = this._pick("pickObject", "pickObject Time", {
                    x: r.x,
                    y: r.y,
                    radius: this.props.pickingRadius
                });
                this._lastPointerDownInfo = a.result[0] || a.emptyInfo;
            }, this.props = {
                ...u1,
                ...e
            }, e = this.props, e.viewState && e.initialViewState && Fe.warn("View state tracking is disabled. Use either `initialViewState` for auto update or `viewState` for manual update.")(), this.viewState = this.props.initialViewState, e.device && (this.device = e.device);
            let t = this.device;
            !t && e.gl && (e.gl instanceof WebGLRenderingContext && Fe.error("WebGL1 context not supported.")(), t = ev.attach(e.gl)), t || (t = wd.createDevice({
                type: "best-available",
                _reuseDevices: !0,
                adapters: [
                    ev
                ],
                ...e.deviceProps,
                createCanvasContext: {
                    canvas: this._createCanvas(e),
                    useDevicePixels: this.props.useDevicePixels,
                    autoResize: !1
                }
            })), this.animationLoop = this._createAnimationLoop(t, e), this.setProps(e), e._typedArrayManagerProps && Ao.setOptions(e._typedArrayManagerProps), this.animationLoop.start();
        }
        finalize() {
            this.animationLoop?.stop(), this.animationLoop?.destroy(), this.animationLoop = null, this._lastPointerDownInfo = null, this.layerManager?.finalize(), this.layerManager = null, this.viewManager?.finalize(), this.viewManager = null, this.effectManager?.finalize(), this.effectManager = null, this.deckRenderer?.finalize(), this.deckRenderer = null, this.deckPicker?.finalize(), this.deckPicker = null, this.eventManager?.destroy(), this.eventManager = null, this.widgetManager?.finalize(), this.widgetManager = null, !this.props.canvas && !this.props.device && !this.props.gl && this.canvas && (this.canvas.parentElement?.removeChild(this.canvas), this.canvas = null);
        }
        setProps(e) {
            this.stats.get("setProps Time").timeStart(), "onLayerHover" in e && Fe.removed("onLayerHover", "onHover")(), "onLayerClick" in e && Fe.removed("onLayerClick", "onClick")(), e.initialViewState && !Ht(this.props.initialViewState, e.initialViewState, 3) && (this.viewState = e.initialViewState), Object.assign(this.props, e), this._setCanvasSize(this.props);
            const t = Object.create(this.props);
            Object.assign(t, {
                views: this._getViews(),
                width: this.width,
                height: this.height,
                viewState: this._getViewState()
            }), this.animationLoop?.setProps(t), this.layerManager && (this.viewManager.setProps(t), this.layerManager.activateViewport(this.getViewports()[0]), this.layerManager.setProps(t), this.effectManager.setProps(t), this.deckRenderer.setProps(t), this.deckPicker.setProps(t), this.widgetManager.setProps(t)), this.stats.get("setProps Time").timeEnd();
        }
        needsRedraw(e = {
            clearRedrawFlags: !1
        }) {
            if (!this.layerManager) return !1;
            if (this.props._animate) return "Deck._animate";
            let t = this._needsRedraw;
            e.clearRedrawFlags && (this._needsRedraw = !1);
            const i = this.viewManager.needsRedraw(e), r = this.layerManager.needsRedraw(e), a = this.effectManager.needsRedraw(e), l = this.deckRenderer.needsRedraw(e);
            return t = t || i || r || a || l, t;
        }
        redraw(e) {
            if (!this.layerManager) return;
            let t = this.needsRedraw({
                clearRedrawFlags: !0
            });
            t = e || t, t && (this.stats.get("Redraw Count").incrementCount(), this.props._customRender ? this.props._customRender(t) : this._drawLayers(t));
        }
        get isInitialized() {
            return this.viewManager !== null;
        }
        getViews() {
            return Nt(this.viewManager), this.viewManager.views;
        }
        getViewports(e) {
            return Nt(this.viewManager), this.viewManager.getViewports(e);
        }
        getCanvas() {
            return this.canvas;
        }
        pickObject(e) {
            const t = this._pick("pickObject", "pickObject Time", e).result;
            return t.length ? t[0] : null;
        }
        pickMultipleObjects(e) {
            return e.depth = e.depth || 10, this._pick("pickObject", "pickMultipleObjects Time", e).result;
        }
        pickObjects(e) {
            return this._pick("pickObjects", "pickObjects Time", e);
        }
        _addResources(e, t = !1) {
            for(const i in e)this.layerManager.resourceManager.add({
                resourceId: i,
                data: e[i],
                forceUpdate: t
            });
        }
        _removeResources(e) {
            for (const t of e)this.layerManager.resourceManager.remove(t);
        }
        _addDefaultEffect(e) {
            this.effectManager.addDefaultEffect(e);
        }
        _addDefaultShaderModule(e) {
            this.layerManager.addDefaultShaderModule(e);
        }
        _removeDefaultShaderModule(e) {
            this.layerManager?.removeDefaultShaderModule(e);
        }
        _pick(e, t, i) {
            Nt(this.deckPicker);
            const { stats: r } = this;
            r.get("Pick Count").incrementCount(), r.get(t).timeStart();
            const a = this.deckPicker[e]({
                layers: this.layerManager.getLayers(i),
                views: this.viewManager.getViews(),
                viewports: this.getViewports(i),
                onViewportActive: this.layerManager.activateViewport,
                effects: this.effectManager.getEffects(),
                ...i
            });
            return r.get(t).timeEnd(), a;
        }
        _createCanvas(e) {
            let t = e.canvas;
            return typeof t == "string" && (t = document.getElementById(t), Nt(t)), t || (t = document.createElement("canvas"), t.id = e.id || "deckgl-overlay", (e.parent || document.body).appendChild(t)), Object.assign(t.style, e.style), t;
        }
        _setCanvasSize(e) {
            if (!this.canvas) return;
            const { width: t, height: i } = e;
            if (t || t === 0) {
                const r = Number.isFinite(t) ? `${t}px` : t;
                this.canvas.style.width = r;
            }
            if (i || i === 0) {
                const r = Number.isFinite(i) ? `${i}px` : i;
                this.canvas.style.position = e.style?.position || "absolute", this.canvas.style.height = r;
            }
        }
        _updateCanvasSize() {
            const { canvas: e } = this;
            if (!e) return;
            const t = e.clientWidth ?? e.width, i = e.clientHeight ?? e.height;
            (t !== this.width || i !== this.height) && (this.width = t, this.height = i, this.viewManager?.setProps({
                width: t,
                height: i
            }), this.layerManager?.activateViewport(this.getViewports()[0]), this.props.onResize({
                width: t,
                height: i
            }));
        }
        _createAnimationLoop(e, t) {
            const { gl: i, onError: r, useDevicePixels: a } = t;
            return new JI({
                device: e,
                useDevicePixels: a,
                autoResizeDrawingBuffer: !i,
                autoResizeViewport: !1,
                onInitialize: (l)=>this._setDevice(l.device),
                onRender: this._onRenderFrame.bind(this),
                onError: r
            });
        }
        _getViewState() {
            return this.props.viewState || this.viewState;
        }
        _getViews() {
            const { views: e } = this.props, t = Array.isArray(e) ? e : e ? [
                e
            ] : [
                new qT({
                    id: "default-view"
                })
            ];
            return t.length && this.props.controller && (t[0].props.controller = this.props.controller), t;
        }
        _onContextLost() {
            const { onError: e } = this.props;
            this.animationLoop && e && e(new Error("WebGL context is lost"));
        }
        _pickAndCallback() {
            if (this.device?.type === "webgpu") return;
            const { _pickRequest: e } = this;
            if (e.event) {
                const { result: t, emptyInfo: i } = this._pick("pickObject", "pickObject Time", e);
                this.cursorState.isHovering = t.length > 0;
                let r = i, a = !1;
                for (const l of t)r = l, a = l.layer?.onHover(l, e.event) || a;
                a || (this.props.onHover?.(r, e.event), this.widgetManager.onHover(r, e.event)), e.event = null;
            }
        }
        _updateCursor() {
            const e = this.props.parent || this.canvas;
            e && (e.style.cursor = this.props.getCursor(this.cursorState));
        }
        _setDevice(e) {
            if (this.device = e, !this.animationLoop) return;
            this.canvas || (this.canvas = this.device.canvasContext?.canvas), this.device.type === "webgl" && this.device.setParametersWebGL({
                blend: !0,
                blendFunc: [
                    770,
                    771,
                    1,
                    771
                ],
                polygonOffsetFill: !0,
                depthTest: !0,
                depthFunc: 515
            }), this.props.onDeviceInitialized(this.device), this.device.type === "webgl" && this.props.onWebGLInitialized(this.device.gl);
            const t = new zT;
            t.play(), this.animationLoop.attachTimeline(t), this.eventManager = new wO(this.props.parent || this.canvas, {
                touchAction: this.props.touchAction,
                recognizers: Object.keys(v0).map((r)=>{
                    const [a, l, u, h] = v0[r], d = this.props.eventRecognizerOptions?.[r], p = {
                        ...l,
                        ...d,
                        event: r
                    };
                    return {
                        recognizer: new a(p),
                        recognizeWith: u,
                        requestFailure: h
                    };
                }),
                events: {
                    pointerdown: this._onPointerDown,
                    pointermove: this._onPointerMove,
                    pointerleave: this._onPointerMove
                }
            });
            for(const r in Dd)this.eventManager.on(r, this._onEvent);
            this.viewManager = new A4({
                timeline: t,
                eventManager: this.eventManager,
                onViewStateChange: this._onViewStateChange.bind(this),
                onInteractionStateChange: this._onInteractionStateChange.bind(this),
                views: this._getViews(),
                viewState: this._getViewState(),
                width: this.width,
                height: this.height
            });
            const i = this.viewManager.getViewports()[0];
            this.layerManager = new S4(this.device, {
                deck: this,
                stats: this.stats,
                viewport: i,
                timeline: t
            }), this.effectManager = new z4({
                deck: this,
                device: this.device
            }), this.deckRenderer = new j4(this.device), this.deckPicker = new K4(this.device), this.widgetManager = new G4({
                deck: this,
                parentElement: this.canvas?.parentElement
            }), this.widgetManager.addDefault(new eN), this.setProps(this.props), this._updateCanvasSize(), this.props.onLoad();
        }
        _drawLayers(e, t) {
            const { device: i, gl: r } = this.layerManager.context;
            this.props.onBeforeRender({
                device: i,
                gl: r
            });
            const a = {
                target: this.props._framebuffer,
                layers: this.layerManager.getLayers(),
                viewports: this.viewManager.getViewports(),
                onViewportActive: this.layerManager.activateViewport,
                views: this.viewManager.getViews(),
                pass: "screen",
                effects: this.effectManager.getEffects(),
                ...t
            };
            this.deckRenderer?.renderLayers(a), a.pass === "screen" && this.widgetManager.onRedraw({
                viewports: a.viewports,
                layers: a.layers
            }), this.props.onAfterRender({
                device: i,
                gl: r
            });
        }
        _onRenderFrame() {
            this._getFrameStats(), this._metricsCounter++ % 60 === 0 && (this._getMetrics(), this.stats.reset(), Fe.table(4, this.metrics)(), this.props._onMetrics && this.props._onMetrics(this.metrics)), this._updateCanvasSize(), this._updateCursor(), this.layerManager.updateLayers(), this.device?.type !== "webgpu" && this._pickAndCallback(), this.redraw(), this.viewManager && this.viewManager.updateViewStates();
        }
        _onViewStateChange(e) {
            const t = this.props.onViewStateChange(e) || e.viewState;
            this.viewState && (this.viewState = {
                ...this.viewState,
                [e.viewId]: t
            }, this.props.viewState || this.viewManager && this.viewManager.setProps({
                viewState: this.viewState
            }));
        }
        _onInteractionStateChange(e) {
            this.cursorState.isDragging = e.isDragging || !1, this.props.onInteractionStateChange(e);
        }
        _getFrameStats() {
            const { stats: e } = this;
            e.get("frameRate").timeEnd(), e.get("frameRate").timeStart();
            const t = this.animationLoop.stats;
            e.get("GPU Time").addTime(t.get("GPU Time").lastTiming), e.get("CPU Time").addTime(t.get("CPU Time").lastTiming);
        }
        _getMetrics() {
            const { metrics: e, stats: t } = this;
            e.fps = t.get("frameRate").getHz(), e.setPropsTime = t.get("setProps Time").time, e.updateAttributesTime = t.get("Update Attributes").time, e.framesRedrawn = t.get("Redraw Count").count, e.pickTime = t.get("pickObject Time").time + t.get("pickMultipleObjects Time").time + t.get("pickObjects Time").time, e.pickCount = t.get("Pick Count").count, e.gpuTime = t.get("GPU Time").time, e.cpuTime = t.get("CPU Time").time, e.gpuTimePerFrame = t.get("GPU Time").getAverageTime(), e.cpuTimePerFrame = t.get("CPU Time").getAverageTime();
            const i = wd.stats.get("Memory Usage");
            e.bufferMemory = i.get("Buffer Memory").count, e.textureMemory = i.get("Texture Memory").count, e.renderbufferMemory = i.get("Renderbuffer Memory").count, e.gpuMemory = i.get("GPU Memory").count;
        }
    }
    Hg.defaultProps = u1;
    Hg.VERSION = yE;
    function GP(n) {
        switch(n){
            case "float64":
                return Float64Array;
            case "uint8":
            case "unorm8":
                return Uint8ClampedArray;
            default:
                return L3(n);
        }
    }
    const JP = B3;
    function lc(n, e, t) {
        const i = t === "webgpu" && e.type === "uint8" ? "unorm8" : e.type;
        return {
            attribute: n,
            format: e.size > 1 ? `${i}x${e.size}` : e.type,
            byteOffset: e.offset || 0
        };
    }
    function xr(n) {
        return n.stride || n.size * n.bytesPerElement;
    }
    function eD(n, e) {
        return n.type === e.type && n.size === e.size && xr(n) === xr(e) && (n.offset || 0) === (e.offset || 0);
    }
    function $d(n, e) {
        e.offset && Fe.removed("shaderAttribute.offset", "vertexOffset, elementOffset")();
        const t = xr(n), i = e.vertexOffset !== void 0 ? e.vertexOffset : n.vertexOffset || 0, r = e.elementOffset || 0, a = i * t + r * n.bytesPerElement + (n.offset || 0);
        return {
            ...e,
            offset: a,
            stride: t
        };
    }
    function tD(n, e) {
        const t = $d(n, e);
        return {
            high: t,
            low: {
                ...t,
                offset: t.offset + n.size * 4
            }
        };
    }
    class nD {
        constructor(e, t, i){
            this._buffer = null, this.device = e, this.id = t.id || "", this.size = t.size || 1;
            const r = t.logicalType || t.type, a = r === "float64";
            let { defaultValue: l } = t;
            l = Number.isFinite(l) ? [
                l
            ] : l || new Array(this.size).fill(0);
            let u;
            a ? u = "float32" : !r && t.isIndexed ? u = "uint32" : u = r || "float32";
            let h = GP(r || u);
            this.doublePrecision = a, a && t.fp64 === !1 && (h = Float32Array), this.value = null, this.settings = {
                ...t,
                defaultType: h,
                defaultValue: l,
                logicalType: r,
                type: u,
                normalized: u.includes("norm"),
                size: this.size,
                bytesPerElement: h.BYTES_PER_ELEMENT
            }, this.state = {
                ...i,
                externalBuffer: null,
                bufferAccessor: this.settings,
                allocatedValue: null,
                numInstances: 0,
                bounds: null,
                constant: !1
            };
        }
        get isConstant() {
            return this.state.constant;
        }
        get buffer() {
            return this._buffer;
        }
        get byteOffset() {
            const e = this.getAccessor();
            return e.vertexOffset ? e.vertexOffset * xr(e) : 0;
        }
        get numInstances() {
            return this.state.numInstances;
        }
        set numInstances(e) {
            this.state.numInstances = e;
        }
        delete() {
            this._buffer && (this._buffer.delete(), this._buffer = null), Ao.release(this.state.allocatedValue);
        }
        getBuffer() {
            return this.state.constant ? null : this.state.externalBuffer || this._buffer;
        }
        getValue(e = this.id, t = null) {
            const i = {};
            if (this.state.constant) {
                const r = this.value;
                if (t) {
                    const a = $d(this.getAccessor(), t), l = a.offset / r.BYTES_PER_ELEMENT, u = a.size || this.size;
                    i[e] = r.subarray(l, l + u);
                } else i[e] = r;
            } else i[e] = this.getBuffer();
            return this.doublePrecision && (this.value instanceof Float64Array ? i[`${e}64Low`] = i[e] : i[`${e}64Low`] = new Float32Array(this.size)), i;
        }
        _getBufferLayout(e = this.id, t = null) {
            const i = this.getAccessor(), r = [], a = {
                name: this.id,
                byteStride: xr(i),
                attributes: r
            };
            if (this.doublePrecision) {
                const l = tD(i, t || {});
                r.push(lc(e, {
                    ...i,
                    ...l.high
                }, this.device.type), lc(`${e}64Low`, {
                    ...i,
                    ...l.low
                }, this.device.type));
            } else if (t) {
                const l = $d(i, t);
                r.push(lc(e, {
                    ...i,
                    ...l
                }, this.device.type));
            } else r.push(lc(e, i, this.device.type));
            return a;
        }
        setAccessor(e) {
            this.state.bufferAccessor = e;
        }
        getAccessor() {
            return this.state.bufferAccessor;
        }
        getBounds() {
            if (this.state.bounds) return this.state.bounds;
            let e = null;
            if (this.state.constant && this.value) {
                const t = Array.from(this.value);
                e = [
                    t,
                    t
                ];
            } else {
                const { value: t, numInstances: i, size: r } = this, a = i * r;
                if (t && a && t.length >= a) {
                    const l = new Array(r).fill(1 / 0), u = new Array(r).fill(-1 / 0);
                    for(let h = 0; h < a;)for(let d = 0; d < r; d++){
                        const p = t[h++];
                        p < l[d] && (l[d] = p), p > u[d] && (u[d] = p);
                    }
                    e = [
                        l,
                        u
                    ];
                }
            }
            return this.state.bounds = e, e;
        }
        setData(e) {
            const { state: t } = this;
            let i;
            ArrayBuffer.isView(e) ? i = {
                value: e
            } : e instanceof Ge ? i = {
                buffer: e
            } : i = e;
            const r = {
                ...this.settings,
                ...i
            };
            if (ArrayBuffer.isView(i.value)) {
                if (!i.type) if (this.doublePrecision && i.value instanceof Float64Array) r.type = "float32";
                else {
                    const l = JP(i.value);
                    r.type = r.normalized ? l.replace("int", "norm") : l;
                }
                r.bytesPerElement = i.value.BYTES_PER_ELEMENT, r.stride = xr(r);
            }
            if (t.bounds = null, i.constant) {
                let a = i.value;
                if (a = this._normalizeValue(a, [], 0), this.settings.normalized && (a = this.normalizeConstant(a)), !(!t.constant || !this._areValuesEqual(a, this.value))) return !1;
                t.externalBuffer = null, t.constant = !0, this.value = ArrayBuffer.isView(a) ? a : new Float32Array(a);
            } else if (i.buffer) {
                const a = i.buffer;
                t.externalBuffer = a, t.constant = !1, this.value = i.value || null;
            } else if (i.value) {
                this._checkExternalBuffer(i);
                let a = i.value;
                t.externalBuffer = null, t.constant = !1, this.value = a;
                let { buffer: l } = this;
                const u = xr(r), h = (r.vertexOffset || 0) * u;
                if (this.doublePrecision && a instanceof Float64Array && (a = Jh(a, r)), this.settings.isIndexed) {
                    const p = this.settings.defaultType;
                    a.constructor !== p && (a = new p(a));
                }
                const d = a.byteLength + h + u * 2;
                (!l || l.byteLength < d) && (l = this._createBuffer(d)), l.write(a, h);
            }
            return this.setAccessor(r), !0;
        }
        updateSubBuffer(e = {}) {
            this.state.bounds = null;
            const t = this.value, { startOffset: i = 0, endOffset: r } = e;
            this.buffer.write(this.doublePrecision && t instanceof Float64Array ? Jh(t, {
                size: this.size,
                startIndex: i,
                endIndex: r
            }) : t.subarray(i, r), i * t.BYTES_PER_ELEMENT + this.byteOffset);
        }
        allocate(e, t = !1) {
            const { state: i } = this, r = i.allocatedValue, a = Ao.allocate(r, e + 1, {
                size: this.size,
                type: this.settings.defaultType,
                copy: t
            });
            this.value = a;
            const { byteOffset: l } = this;
            let { buffer: u } = this;
            return (!u || u.byteLength < a.byteLength + l) && (u = this._createBuffer(a.byteLength + l), t && r && u.write(r instanceof Float64Array ? Jh(r, this) : r, l)), i.allocatedValue = a, i.constant = !1, i.externalBuffer = null, this.setAccessor(this.settings), !0;
        }
        _checkExternalBuffer(e) {
            const { value: t } = e;
            if (!ArrayBuffer.isView(t)) throw new Error(`Attribute ${this.id} value is not TypedArray`);
            const i = this.settings.defaultType;
            let r = !1;
            if (this.doublePrecision && (r = t.BYTES_PER_ELEMENT < 4), r) throw new Error(`Attribute ${this.id} does not support ${t.constructor.name}`);
            !(t instanceof i) && this.settings.normalized && !("normalized" in e) && Fe.warn(`Attribute ${this.id} is normalized`)();
        }
        normalizeConstant(e) {
            switch(this.settings.type){
                case "snorm8":
                    return new Float32Array(e).map((t)=>(t + 128) / 255 * 2 - 1);
                case "snorm16":
                    return new Float32Array(e).map((t)=>(t + 32768) / 65535 * 2 - 1);
                case "unorm8":
                    return new Float32Array(e).map((t)=>t / 255);
                case "unorm16":
                    return new Float32Array(e).map((t)=>t / 65535);
                default:
                    return e;
            }
        }
        _normalizeValue(e, t, i) {
            const { defaultValue: r, size: a } = this.settings;
            if (Number.isFinite(e)) return t[i] = e, t;
            if (!e) {
                let l = a;
                for(; --l >= 0;)t[i + l] = r[l];
                return t;
            }
            switch(a){
                case 4:
                    t[i + 3] = Number.isFinite(e[3]) ? e[3] : r[3];
                case 3:
                    t[i + 2] = Number.isFinite(e[2]) ? e[2] : r[2];
                case 2:
                    t[i + 1] = Number.isFinite(e[1]) ? e[1] : r[1];
                case 1:
                    t[i + 0] = Number.isFinite(e[0]) ? e[0] : r[0];
                    break;
                default:
                    let l = a;
                    for(; --l >= 0;)t[i + l] = Number.isFinite(e[l]) ? e[l] : r[l];
            }
            return t;
        }
        _areValuesEqual(e, t) {
            if (!e || !t) return !1;
            const { size: i } = this;
            for(let r = 0; r < i; r++)if (e[r] !== t[r]) return !1;
            return !0;
        }
        _createBuffer(e) {
            this._buffer && this._buffer.destroy();
            const { isIndexed: t, type: i } = this.settings;
            return this._buffer = this.device.createBuffer({
                ...this._buffer?.props,
                id: this.id,
                usage: (t ? Ge.INDEX : Ge.VERTEX) | Ge.COPY_DST,
                indexType: t ? i : void 0,
                byteLength: e
            }), this._buffer;
        }
    }
    const tv = [], nv = [];
    function f1(n, e = 0, t = 1 / 0) {
        let i = tv;
        const r = {
            index: -1,
            data: n,
            target: []
        };
        return n ? typeof n[Symbol.iterator] == "function" ? i = n : n.length > 0 && (nv.length = n.length, i = nv) : i = tv, (e > 0 || Number.isFinite(t)) && (i = (Array.isArray(i) ? i : Array.from(i)).slice(e, t), r.index = e - 1), {
            iterable: i,
            objectInfo: r
        };
    }
    function h1(n) {
        return n && n[Symbol.asyncIterator];
    }
    function iD(n, e) {
        const { size: t, stride: i, offset: r, startIndices: a, nested: l } = e, u = n.BYTES_PER_ELEMENT, h = i ? i / u : t, d = r ? r / u : 0, p = Math.floor((n.length - d) / h);
        return (_, { index: y, target: v })=>{
            if (!a) {
                const B = y * h + d;
                for(let H = 0; H < t; H++)v[H] = n[B + H];
                return v;
            }
            const S = a[y], E = a[y + 1] || p;
            let M;
            if (l) {
                M = new Array(E - S);
                for(let B = S; B < E; B++){
                    const H = B * h + d;
                    v = new Array(t);
                    for(let O = 0; O < t; O++)v[O] = n[H + O];
                    M[B - S] = v;
                }
            } else if (h === t) M = n.subarray(S * t + d, E * t + d);
            else {
                M = new n.constructor((E - S) * t);
                let B = 0;
                for(let H = S; H < E; H++){
                    const O = H * h + d;
                    for(let U = 0; U < t; U++)M[B++] = n[O + U];
                }
            }
            return M;
        };
    }
    const rD = [], _c = [
        [
            0,
            1 / 0
        ]
    ];
    function sD(n, e) {
        if (n === _c || (e[0] < 0 && (e[0] = 0), e[0] >= e[1])) return n;
        const t = [], i = n.length;
        let r = 0;
        for(let a = 0; a < i; a++){
            const l = n[a];
            l[1] < e[0] ? (t.push(l), r = a + 1) : l[0] > e[1] ? t.push(l) : e = [
                Math.min(l[0], e[0]),
                Math.max(l[1], e[1])
            ];
        }
        return t.splice(r, 0, e), t;
    }
    const aD = {
        interpolation: {
            duration: 0,
            easing: (n)=>n
        },
        spring: {
            stiffness: .05,
            damping: .5
        }
    };
    function d1(n, e) {
        if (!n) return null;
        Number.isFinite(n) && (n = {
            type: "interpolation",
            duration: n
        });
        const t = n.type || "interpolation";
        return {
            ...aD[t],
            ...e,
            ...n,
            type: t
        };
    }
    class g1 extends nD {
        constructor(e, t){
            super(e, t, {
                startIndices: null,
                lastExternalBuffer: null,
                binaryValue: null,
                binaryAccessor: null,
                needsUpdate: !0,
                needsRedraw: !1,
                layoutChanged: !1,
                updateRanges: _c
            }), this.constant = !1, this.settings.update = t.update || (t.accessor ? this._autoUpdater : void 0), Object.seal(this.settings), Object.seal(this.state), this._validateAttributeUpdaters();
        }
        get startIndices() {
            return this.state.startIndices;
        }
        set startIndices(e) {
            this.state.startIndices = e;
        }
        needsUpdate() {
            return this.state.needsUpdate;
        }
        needsRedraw({ clearChangedFlags: e = !1 } = {}) {
            const t = this.state.needsRedraw;
            return this.state.needsRedraw = t && !e, t;
        }
        layoutChanged() {
            return this.state.layoutChanged;
        }
        setAccessor(e) {
            var t;
            (t = this.state).layoutChanged || (t.layoutChanged = !eD(e, this.getAccessor())), super.setAccessor(e);
        }
        getUpdateTriggers() {
            const { accessor: e } = this.settings;
            return [
                this.id
            ].concat(typeof e != "function" && e || []);
        }
        supportsTransition() {
            return !!this.settings.transition;
        }
        getTransitionSetting(e) {
            if (!e || !this.supportsTransition()) return null;
            const { accessor: t } = this.settings, i = this.settings.transition, r = Array.isArray(t) ? e[t.find((a)=>e[a])] : e[t];
            return d1(r, i);
        }
        setNeedsUpdate(e = this.id, t) {
            if (this.state.needsUpdate = this.state.needsUpdate || e, this.setNeedsRedraw(e), t) {
                const { startRow: i = 0, endRow: r = 1 / 0 } = t;
                this.state.updateRanges = sD(this.state.updateRanges, [
                    i,
                    r
                ]);
            } else this.state.updateRanges = _c;
        }
        clearNeedsUpdate() {
            this.state.needsUpdate = !1, this.state.updateRanges = rD;
        }
        setNeedsRedraw(e = this.id) {
            this.state.needsRedraw = this.state.needsRedraw || e;
        }
        allocate(e) {
            const { state: t, settings: i } = this;
            return i.noAlloc ? !1 : i.update ? (super.allocate(e, t.updateRanges !== _c), !0) : !1;
        }
        updateBuffer({ numInstances: e, data: t, props: i, context: r }) {
            if (!this.needsUpdate()) return !1;
            const { state: { updateRanges: a }, settings: { update: l, noAlloc: u } } = this;
            let h = !0;
            if (l) {
                for (const [d, p] of a)l.call(r, this, {
                    data: t,
                    startRow: d,
                    endRow: p,
                    props: i,
                    numInstances: e
                });
                if (this.value) if (this.constant || !this.buffer || this.buffer.byteLength < this.value.byteLength + this.byteOffset) this.setData({
                    value: this.value,
                    constant: this.constant
                }), this.constant = !1;
                else for (const [d, p] of a){
                    const _ = Number.isFinite(d) ? this.getVertexOffset(d) : 0, y = Number.isFinite(p) ? this.getVertexOffset(p) : u || !Number.isFinite(e) ? this.value.length : e * this.size;
                    super.updateSubBuffer({
                        startOffset: _,
                        endOffset: y
                    });
                }
                this._checkAttributeArray();
            } else h = !1;
            return this.clearNeedsUpdate(), this.setNeedsRedraw(), h;
        }
        setConstantValue(e) {
            return this.device.type === "webgpu" || e === void 0 || typeof e == "function" ? !1 : (this.setData({
                constant: !0,
                value: e
            }) && this.setNeedsRedraw(), this.clearNeedsUpdate(), !0);
        }
        setExternalBuffer(e) {
            const { state: t } = this;
            return e ? (this.clearNeedsUpdate(), t.lastExternalBuffer === e || (t.lastExternalBuffer = e, this.setNeedsRedraw(), this.setData(e)), !0) : (t.lastExternalBuffer = null, !1);
        }
        setBinaryValue(e, t = null) {
            const { state: i, settings: r } = this;
            if (!e) return i.binaryValue = null, i.binaryAccessor = null, !1;
            if (r.noAlloc) return !1;
            if (i.binaryValue === e) return this.clearNeedsUpdate(), !0;
            if (i.binaryValue = e, this.setNeedsRedraw(), r.transform || t !== this.startIndices) {
                ArrayBuffer.isView(e) && (e = {
                    value: e
                });
                const l = e;
                Nt(ArrayBuffer.isView(l.value), `invalid ${r.accessor}`);
                const u = !!l.size && l.size !== this.size;
                return i.binaryAccessor = iD(l.value, {
                    size: l.size || this.size,
                    stride: l.stride,
                    offset: l.offset,
                    startIndices: t,
                    nested: u
                }), !1;
            }
            return this.clearNeedsUpdate(), this.setData(e), !0;
        }
        getVertexOffset(e) {
            const { startIndices: t } = this;
            return (t ? e < t.length ? t[e] : this.numInstances : e) * this.size;
        }
        getValue() {
            const e = this.settings.shaderAttributes, t = super.getValue();
            if (!e) return t;
            for(const i in e)Object.assign(t, super.getValue(i, e[i]));
            return t;
        }
        getBufferLayout(e) {
            this.state.layoutChanged = !1;
            const t = this.settings.shaderAttributes, i = super._getBufferLayout(), { stepMode: r } = this.settings;
            if (r === "dynamic" ? i.stepMode = e ? e.isInstanced ? "instance" : "vertex" : "instance" : i.stepMode = r ?? "vertex", !t) return i;
            for(const a in t){
                const l = super._getBufferLayout(a, t[a]);
                i.attributes.push(...l.attributes);
            }
            return i;
        }
        _autoUpdater(e, { data: t, startRow: i, endRow: r, props: a, numInstances: l }) {
            if (e.constant && this.context.device.type !== "webgpu") return;
            const { settings: u, state: h, value: d, size: p, startIndices: _ } = e, { accessor: y, transform: v } = u;
            let S = h.binaryAccessor || (typeof y == "function" ? y : a[y]);
            typeof S != "function" && (S = ()=>S), Nt(typeof S == "function", `accessor "${y}" is not a function`);
            let E = e.getVertexOffset(i);
            const { iterable: M, objectInfo: B } = f1(t, i, r);
            for (const H of M){
                B.index++;
                let O = S(H, B);
                if (v && (O = v.call(this, O)), _) {
                    const U = (B.index < _.length - 1 ? _[B.index + 1] : l) - _[B.index];
                    if (O && Array.isArray(O[0])) {
                        let L = E;
                        for (const Z of O)e._normalizeValue(Z, d, L), L += p;
                    } else O && O.length > p ? d.set(O, E) : (e._normalizeValue(O, B.target, 0), y4({
                        target: d,
                        source: B.target,
                        start: E,
                        count: U
                    }));
                    E += U * p;
                } else e._normalizeValue(O, d, E), E += p;
            }
        }
        _validateAttributeUpdaters() {
            const { settings: e } = this;
            if (!(e.noAlloc || typeof e.update == "function")) throw new Error(`Attribute ${this.id} missing update or accessor`);
        }
        _checkAttributeArray() {
            const { value: e } = this, t = Math.min(4, this.size);
            if (e && e.length >= t) {
                let i = !0;
                switch(t){
                    case 4:
                        i = i && Number.isFinite(e[3]);
                    case 3:
                        i = i && Number.isFinite(e[2]);
                    case 2:
                        i = i && Number.isFinite(e[1]);
                    case 1:
                        i = i && Number.isFinite(e[0]);
                        break;
                    default:
                        i = !1;
                }
                if (!i) throw new Error(`Illegal attribute generated for ${this.id}`);
            }
        }
    }
    function cd(n) {
        const { source: e, target: t, start: i = 0, size: r, getData: a } = n, l = n.end || t.length, u = e.length, h = l - i;
        if (u > h) {
            t.set(e.subarray(0, h), i);
            return;
        }
        if (t.set(e, i), !a) return;
        let d = u;
        for(; d < h;){
            const p = a(d, e);
            for(let _ = 0; _ < r; _++)t[i + d] = p[_] || 0, d++;
        }
    }
    function oD({ source: n, target: e, size: t, getData: i, sourceStartIndices: r, targetStartIndices: a }) {
        if (!r || !a) return cd({
            source: n,
            target: e,
            size: t,
            getData: i
        }), e;
        let l = 0, u = 0;
        const h = i && ((p, _)=>i(p + u, _)), d = Math.min(r.length, a.length);
        for(let p = 1; p < d; p++){
            const _ = r[p] * t, y = a[p] * t;
            cd({
                source: n.subarray(l, _),
                target: e,
                start: u,
                end: y,
                size: t,
                getData: h
            }), l = _, u = y;
        }
        return u < e.length && cd({
            source: [],
            target: e,
            start: u,
            size: t,
            getData: h
        }), e;
    }
    function lD(n) {
        const { device: e, settings: t, value: i } = n, r = new g1(e, t);
        return r.setData({
            value: i instanceof Float64Array ? new Float64Array(0) : new Float32Array(0),
            normalized: t.normalized
        }), r;
    }
    function p1(n) {
        switch(n){
            case 1:
                return "float";
            case 2:
                return "vec2";
            case 3:
                return "vec3";
            case 4:
                return "vec4";
            default:
                throw new Error(`No defined attribute type for size "${n}"`);
        }
    }
    function m1(n) {
        switch(n){
            case 1:
                return "float32";
            case 2:
                return "float32x2";
            case 3:
                return "float32x3";
            case 4:
                return "float32x4";
            default:
                throw new Error("invalid type size");
        }
    }
    function _1(n) {
        n.push(n.shift());
    }
    function cD(n, e) {
        const { doublePrecision: t, settings: i, value: r, size: a } = n, l = t && r instanceof Float64Array ? 2 : 1;
        let u = 0;
        const { shaderAttributes: h } = n.settings;
        if (h) for (const d of Object.values(h))u = Math.max(u, d.vertexOffset ?? 0);
        return (i.noAlloc ? r.length : (e + u) * a) * l;
    }
    function y1({ device: n, source: e, target: t }) {
        return (!t || t.byteLength < e.byteLength) && (t?.destroy(), t = n.createBuffer({
            byteLength: e.byteLength,
            usage: e.usage
        })), t;
    }
    function b1({ device: n, buffer: e, attribute: t, fromLength: i, toLength: r, fromStartIndices: a, getData: l = (u)=>u }) {
        const u = t.doublePrecision && t.value instanceof Float64Array ? 2 : 1, h = t.size * u, d = t.byteOffset, p = t.settings.bytesPerElement < 4 ? d / t.settings.bytesPerElement * 4 : d, _ = t.startIndices, y = a && _, v = t.isConstant;
        if (!y && e && i >= r) return e;
        const S = t.value instanceof Float64Array ? Float32Array : t.value.constructor, E = v ? t.value : new S(t.getBuffer().readSyncWebGL(d, r * S.BYTES_PER_ELEMENT).buffer);
        if (t.settings.normalized && !v) {
            const O = l;
            l = (U, L)=>t.normalizeConstant(O(U, L));
        }
        const M = v ? (O, U)=>l(E, U) : (O, U)=>l(E.subarray(O + d, O + d + h), U), B = e ? new Float32Array(e.readSyncWebGL(p, i * 4).buffer) : new Float32Array(0), H = new Float32Array(r);
        return oD({
            source: B,
            target: H,
            sourceStartIndices: a,
            targetStartIndices: _,
            size: h,
            getData: M
        }), (!e || e.byteLength < H.byteLength + p) && (e?.destroy(), e = n.createBuffer({
            byteLength: H.byteLength + p,
            usage: 35050
        })), e.write(H, p), e;
    }
    class v1 {
        constructor({ device: e, attribute: t, timeline: i }){
            this.buffers = [], this.currentLength = 0, this.device = e, this.transition = new su(i), this.attribute = t, this.attributeInTransition = lD(t), this.currentStartIndices = t.startIndices;
        }
        get inProgress() {
            return this.transition.inProgress;
        }
        start(e, t, i = 1 / 0) {
            this.settings = e, this.currentStartIndices = this.attribute.startIndices, this.currentLength = cD(this.attribute, t), this.transition.start({
                ...e,
                duration: i
            });
        }
        update() {
            const e = this.transition.update();
            return e && this.onUpdate(), e;
        }
        setBuffer(e) {
            this.attributeInTransition.setData({
                buffer: e,
                normalized: this.attribute.settings.normalized,
                value: this.attributeInTransition.value
            });
        }
        cancel() {
            this.transition.cancel();
        }
        delete() {
            this.cancel();
            for (const e of this.buffers)e.destroy();
            this.buffers.length = 0;
        }
    }
    class uD extends v1 {
        constructor({ device: e, attribute: t, timeline: i }){
            super({
                device: e,
                attribute: t,
                timeline: i
            }), this.type = "interpolation", this.transform = gD(e, t);
        }
        start(e, t) {
            const i = this.currentLength, r = this.currentStartIndices;
            if (super.start(e, t, e.duration), e.duration <= 0) {
                this.transition.cancel();
                return;
            }
            const { buffers: a, attribute: l } = this;
            _1(a), a[0] = b1({
                device: this.device,
                buffer: a[0],
                attribute: l,
                fromLength: i,
                toLength: this.currentLength,
                fromStartIndices: r,
                getData: e.enter
            }), a[1] = y1({
                device: this.device,
                source: a[0],
                target: a[1]
            }), this.setBuffer(a[1]);
            const { transform: u } = this, h = u.model;
            let d = Math.floor(this.currentLength / l.size);
            T1(l) && (d /= 2), h.setVertexCount(d), l.isConstant ? (h.setAttributes({
                aFrom: a[0]
            }), h.setConstantAttributes({
                aTo: l.value
            })) : h.setAttributes({
                aFrom: a[0],
                aTo: l.getBuffer()
            }), u.transformFeedback.setBuffers({
                vCurrent: a[1]
            });
        }
        onUpdate() {
            const { duration: e, easing: t } = this.settings, { time: i } = this.transition;
            let r = i / e;
            t && (r = t(r));
            const { model: a } = this.transform, l = {
                time: r
            };
            a.shaderInputs.setProps({
                interpolation: l
            }), this.transform.run({
                discard: !0
            });
        }
        delete() {
            super.delete(), this.transform.destroy();
        }
    }
    const fD = `uniform interpolationUniforms {
  float time;
} interpolation;
`, iv = {
        name: "interpolation",
        vs: fD,
        uniformTypes: {
            time: "f32"
        }
    }, hD = `#version 300 es
#define SHADER_NAME interpolation-transition-vertex-shader

in ATTRIBUTE_TYPE aFrom;
in ATTRIBUTE_TYPE aTo;
out ATTRIBUTE_TYPE vCurrent;

void main(void) {
  vCurrent = mix(aFrom, aTo, interpolation.time);
  gl_Position = vec4(0.0);
}
`, dD = `#version 300 es
#define SHADER_NAME interpolation-transition-vertex-shader

in ATTRIBUTE_TYPE aFrom;
in ATTRIBUTE_TYPE aFrom64Low;
in ATTRIBUTE_TYPE aTo;
in ATTRIBUTE_TYPE aTo64Low;
out ATTRIBUTE_TYPE vCurrent;
out ATTRIBUTE_TYPE vCurrent64Low;

vec2 mix_fp64(vec2 a, vec2 b, float x) {
  vec2 range = sub_fp64(b, a);
  return sum_fp64(a, mul_fp64(range, vec2(x, 0.0)));
}

void main(void) {
  for (int i=0; i<ATTRIBUTE_SIZE; i++) {
    vec2 value = mix_fp64(vec2(aFrom[i], aFrom64Low[i]), vec2(aTo[i], aTo64Low[i]), interpolation.time);
    vCurrent[i] = value.x;
    vCurrent64Low[i] = value.y;
  }
  gl_Position = vec4(0.0);
}
`;
    function T1(n) {
        return n.doublePrecision && n.value instanceof Float64Array;
    }
    function gD(n, e) {
        const t = e.size, i = p1(t), r = m1(t), a = e.getBufferLayout();
        return T1(e) ? new Ir(n, {
            vs: dD,
            bufferLayout: [
                {
                    name: "aFrom",
                    byteStride: 8 * t,
                    attributes: [
                        {
                            attribute: "aFrom",
                            format: r,
                            byteOffset: 0
                        },
                        {
                            attribute: "aFrom64Low",
                            format: r,
                            byteOffset: 4 * t
                        }
                    ]
                },
                {
                    name: "aTo",
                    byteStride: 8 * t,
                    attributes: [
                        {
                            attribute: "aTo",
                            format: r,
                            byteOffset: 0
                        },
                        {
                            attribute: "aTo64Low",
                            format: r,
                            byteOffset: 4 * t
                        }
                    ]
                }
            ],
            modules: [
                yM,
                iv
            ],
            defines: {
                ATTRIBUTE_TYPE: i,
                ATTRIBUTE_SIZE: t
            },
            moduleSettings: {},
            varyings: [
                "vCurrent",
                "vCurrent64Low"
            ],
            bufferMode: 35980,
            disableWarnings: !0
        }) : new Ir(n, {
            vs: hD,
            bufferLayout: [
                {
                    name: "aFrom",
                    format: r
                },
                {
                    name: "aTo",
                    format: a.attributes[0].format
                }
            ],
            modules: [
                iv
            ],
            defines: {
                ATTRIBUTE_TYPE: i
            },
            varyings: [
                "vCurrent"
            ],
            disableWarnings: !0
        });
    }
    class pD extends v1 {
        constructor({ device: e, attribute: t, timeline: i }){
            super({
                device: e,
                attribute: t,
                timeline: i
            }), this.type = "spring", this.texture = TD(e), this.framebuffer = xD(e, this.texture), this.transform = vD(e, t);
        }
        start(e, t) {
            const i = this.currentLength, r = this.currentStartIndices;
            super.start(e, t);
            const { buffers: a, attribute: l } = this;
            for(let h = 0; h < 2; h++)a[h] = b1({
                device: this.device,
                buffer: a[h],
                attribute: l,
                fromLength: i,
                toLength: this.currentLength,
                fromStartIndices: r,
                getData: e.enter
            });
            a[2] = y1({
                device: this.device,
                source: a[0],
                target: a[2]
            }), this.setBuffer(a[1]);
            const { model: u } = this.transform;
            u.setVertexCount(Math.floor(this.currentLength / l.size)), l.isConstant ? u.setConstantAttributes({
                aTo: l.value
            }) : u.setAttributes({
                aTo: l.getBuffer()
            });
        }
        onUpdate() {
            const { buffers: e, transform: t, framebuffer: i, transition: r } = this, a = this.settings;
            t.model.setAttributes({
                aPrev: e[0],
                aCur: e[1]
            }), t.transformFeedback.setBuffers({
                vNext: e[2]
            });
            const l = {
                stiffness: a.stiffness,
                damping: a.damping
            };
            t.model.shaderInputs.setProps({
                spring: l
            }), t.run({
                framebuffer: i,
                discard: !1,
                parameters: {
                    viewport: [
                        0,
                        0,
                        1,
                        1
                    ]
                },
                clearColor: [
                    0,
                    0,
                    0,
                    0
                ]
            }), _1(e), this.setBuffer(e[1]), this.device.readPixelsToArrayWebGL(i)[0] > 0 || r.end();
        }
        delete() {
            super.delete(), this.transform.destroy(), this.texture.destroy(), this.framebuffer.destroy();
        }
    }
    const mD = `uniform springUniforms {
  float damping;
  float stiffness;
} spring;
`, _D = {
        name: "spring",
        vs: mD,
        uniformTypes: {
            damping: "f32",
            stiffness: "f32"
        }
    }, yD = `#version 300 es
#define SHADER_NAME spring-transition-vertex-shader

#define EPSILON 0.00001

in ATTRIBUTE_TYPE aPrev;
in ATTRIBUTE_TYPE aCur;
in ATTRIBUTE_TYPE aTo;
out ATTRIBUTE_TYPE vNext;
out float vIsTransitioningFlag;

ATTRIBUTE_TYPE getNextValue(ATTRIBUTE_TYPE cur, ATTRIBUTE_TYPE prev, ATTRIBUTE_TYPE dest) {
  ATTRIBUTE_TYPE velocity = cur - prev;
  ATTRIBUTE_TYPE delta = dest - cur;
  ATTRIBUTE_TYPE force = delta * spring.stiffness;
  ATTRIBUTE_TYPE resistance = velocity * spring.damping;
  return force - resistance + velocity + cur;
}

void main(void) {
  bool isTransitioning = length(aCur - aPrev) > EPSILON || length(aTo - aCur) > EPSILON;
  vIsTransitioningFlag = isTransitioning ? 1.0 : 0.0;

  vNext = getNextValue(aCur, aPrev, aTo);
  gl_Position = vec4(0, 0, 0, 1);
  gl_PointSize = 100.0;
}
`, bD = `#version 300 es
#define SHADER_NAME spring-transition-is-transitioning-fragment-shader

in float vIsTransitioningFlag;

out vec4 fragColor;

void main(void) {
  if (vIsTransitioningFlag == 0.0) {
    discard;
  }
  fragColor = vec4(1.0);
}`;
    function vD(n, e) {
        const t = p1(e.size), i = m1(e.size);
        return new Ir(n, {
            vs: yD,
            fs: bD,
            bufferLayout: [
                {
                    name: "aPrev",
                    format: i
                },
                {
                    name: "aCur",
                    format: i
                },
                {
                    name: "aTo",
                    format: e.getBufferLayout().attributes[0].format
                }
            ],
            varyings: [
                "vNext"
            ],
            modules: [
                _D
            ],
            defines: {
                ATTRIBUTE_TYPE: t
            },
            parameters: {
                depthCompare: "always",
                blendColorOperation: "max",
                blendColorSrcFactor: "one",
                blendColorDstFactor: "one",
                blendAlphaOperation: "max",
                blendAlphaSrcFactor: "one",
                blendAlphaDstFactor: "one"
            }
        });
    }
    function TD(n) {
        return n.createTexture({
            data: new Uint8Array(4),
            format: "rgba8unorm",
            mipmaps: !1,
            width: 1,
            height: 1
        });
    }
    function xD(n, e) {
        return n.createFramebuffer({
            id: "spring-transition-is-transitioning-framebuffer",
            width: 1,
            height: 1,
            colorAttachments: [
                e
            ]
        });
    }
    const SD = {
        interpolation: uD,
        spring: pD
    };
    class AD {
        constructor(e, { id: t, timeline: i }){
            if (!e) throw new Error("AttributeTransitionManager is constructed without device");
            this.id = t, this.device = e, this.timeline = i, this.transitions = {}, this.needsRedraw = !1, this.numInstances = 1;
        }
        finalize() {
            for(const e in this.transitions)this._removeTransition(e);
        }
        update({ attributes: e, transitions: t, numInstances: i }) {
            this.numInstances = i || 1;
            for(const r in e){
                const a = e[r], l = a.getTransitionSetting(t);
                l && this._updateAttribute(r, a, l);
            }
            for(const r in this.transitions){
                const a = e[r];
                (!a || !a.getTransitionSetting(t)) && this._removeTransition(r);
            }
        }
        hasAttribute(e) {
            const t = this.transitions[e];
            return t && t.inProgress;
        }
        getAttributes() {
            const e = {};
            for(const t in this.transitions){
                const i = this.transitions[t];
                i.inProgress && (e[t] = i.attributeInTransition);
            }
            return e;
        }
        run() {
            if (this.numInstances === 0) return !1;
            for(const t in this.transitions)this.transitions[t].update() && (this.needsRedraw = !0);
            const e = this.needsRedraw;
            return this.needsRedraw = !1, e;
        }
        _removeTransition(e) {
            this.transitions[e].delete(), delete this.transitions[e];
        }
        _updateAttribute(e, t, i) {
            const r = this.transitions[e];
            let a = !r || r.type !== i.type;
            if (a) {
                r && this._removeTransition(e);
                const l = SD[i.type];
                l ? this.transitions[e] = new l({
                    attribute: t,
                    timeline: this.timeline,
                    device: this.device
                }) : (Fe.error(`unsupported transition type '${i.type}'`)(), a = !1);
            }
            (a || t.needsRedraw()) && (this.needsRedraw = !0, this.transitions[e].start(i, this.numInstances));
        }
    }
    const rv = "attributeManager.invalidate", wD = "attributeManager.updateStart", ED = "attributeManager.updateEnd", RD = "attribute.updateStart", CD = "attribute.allocate", MD = "attribute.updateEnd";
    class au {
        constructor(e, { id: t = "attribute-manager", stats: i, timeline: r } = {}){
            this.mergeBoundsMemoized = No(kI), this.id = t, this.device = e, this.attributes = {}, this.updateTriggers = {}, this.needsRedraw = !0, this.userData = {}, this.stats = i, this.attributeTransitionManager = new AD(e, {
                id: `${t}-transitions`,
                timeline: r
            }), Object.seal(this);
        }
        finalize() {
            for(const e in this.attributes)this.attributes[e].delete();
            this.attributeTransitionManager.finalize();
        }
        getNeedsRedraw(e = {
            clearRedrawFlags: !1
        }) {
            const t = this.needsRedraw;
            return this.needsRedraw = this.needsRedraw && !e.clearRedrawFlags, t && this.id;
        }
        setNeedsRedraw() {
            this.needsRedraw = !0;
        }
        add(e) {
            this._add(e);
        }
        addInstanced(e) {
            this._add(e, {
                stepMode: "instance"
            });
        }
        remove(e) {
            for (const t of e)this.attributes[t] !== void 0 && (this.attributes[t].delete(), delete this.attributes[t]);
        }
        invalidate(e, t) {
            const i = this._invalidateTrigger(e, t);
            It(rv, this, e, i);
        }
        invalidateAll(e) {
            for(const t in this.attributes)this.attributes[t].setNeedsUpdate(t, e);
            It(rv, this, "all");
        }
        update({ data: e, numInstances: t, startIndices: i = null, transitions: r, props: a = {}, buffers: l = {}, context: u = {} }) {
            let h = !1;
            It(wD, this), this.stats && this.stats.get("Update Attributes").timeStart();
            for(const d in this.attributes){
                const p = this.attributes[d], _ = p.settings.accessor;
                p.startIndices = i, p.numInstances = t, a[d] && Fe.removed(`props.${d}`, `data.attributes.${d}`)(), p.setExternalBuffer(l[d]) || p.setBinaryValue(typeof _ == "string" ? l[_] : void 0, e.startIndices) || typeof _ == "string" && !l[_] && p.setConstantValue(a[_]) || p.needsUpdate() && (h = !0, this._updateAttribute({
                    attribute: p,
                    numInstances: t,
                    data: e,
                    props: a,
                    context: u
                })), this.needsRedraw = this.needsRedraw || p.needsRedraw();
            }
            h && It(ED, this, t), this.stats && this.stats.get("Update Attributes").timeEnd(), this.attributeTransitionManager.update({
                attributes: this.attributes,
                numInstances: t,
                transitions: r
            });
        }
        updateTransition() {
            const { attributeTransitionManager: e } = this, t = e.run();
            return this.needsRedraw = this.needsRedraw || t, t;
        }
        getAttributes() {
            return {
                ...this.attributes,
                ...this.attributeTransitionManager.getAttributes()
            };
        }
        getBounds(e) {
            const t = e.map((i)=>this.attributes[i]?.getBounds());
            return this.mergeBoundsMemoized(t);
        }
        getChangedAttributes(e = {
            clearChangedFlags: !1
        }) {
            const { attributes: t, attributeTransitionManager: i } = this, r = {
                ...i.getAttributes()
            };
            for(const a in t){
                const l = t[a];
                l.needsRedraw(e) && !i.hasAttribute(a) && (r[a] = l);
            }
            return r;
        }
        getBufferLayouts(e) {
            return Object.values(this.getAttributes()).map((t)=>t.getBufferLayout(e));
        }
        _add(e, t) {
            for(const i in e){
                const r = e[i], a = {
                    ...r,
                    id: i,
                    size: r.isIndexed && 1 || r.size || 1,
                    ...t
                };
                this.attributes[i] = new g1(this.device, a);
            }
            this._mapUpdateTriggersToAttributes();
        }
        _mapUpdateTriggersToAttributes() {
            const e = {};
            for(const t in this.attributes)this.attributes[t].getUpdateTriggers().forEach((r)=>{
                e[r] || (e[r] = []), e[r].push(t);
            });
            this.updateTriggers = e;
        }
        _invalidateTrigger(e, t) {
            const { attributes: i, updateTriggers: r } = this, a = r[e];
            return a && a.forEach((l)=>{
                const u = i[l];
                u && u.setNeedsUpdate(u.id, t);
            }), a;
        }
        _updateAttribute(e) {
            const { attribute: t, numInstances: i } = e;
            if (It(RD, t), t.constant) {
                t.setConstantValue(t.value);
                return;
            }
            t.allocate(i) && It(CD, t, i), t.updateBuffer(e) && (this.needsRedraw = !0, It(MD, t, i));
        }
    }
    class OD extends su {
        get value() {
            return this._value;
        }
        _onUpdate() {
            const { time: e, settings: { fromValue: t, toValue: i, duration: r, easing: a } } = this, l = a(e / r);
            this._value = Nc(t, i, l);
        }
    }
    const sv = 1e-5;
    function av(n, e, t, i, r) {
        const a = e - n, u = (t - e) * r, h = -a * i;
        return u + h + a + e;
    }
    function ID(n, e, t, i, r) {
        if (Array.isArray(t)) {
            const a = [];
            for(let l = 0; l < t.length; l++)a[l] = av(n[l], e[l], t[l], i, r);
            return a;
        }
        return av(n, e, t, i, r);
    }
    function ov(n, e) {
        if (Array.isArray(n)) {
            let t = 0;
            for(let i = 0; i < n.length; i++){
                const r = n[i] - e[i];
                t += r * r;
            }
            return Math.sqrt(t);
        }
        return Math.abs(n - e);
    }
    class ND extends su {
        get value() {
            return this._currValue;
        }
        _onUpdate() {
            const { fromValue: e, toValue: t, damping: i, stiffness: r } = this.settings, { _prevValue: a = e, _currValue: l = e } = this;
            let u = ID(a, l, t, i, r);
            const h = ov(u, t), d = ov(u, l);
            h < sv && d < sv && (u = t, this.end()), this._prevValue = l, this._currValue = u;
        }
    }
    const PD = {
        interpolation: OD,
        spring: ND
    };
    class DD {
        constructor(e){
            this.transitions = new Map, this.timeline = e;
        }
        get active() {
            return this.transitions.size > 0;
        }
        add(e, t, i, r) {
            const { transitions: a } = this;
            if (a.has(e)) {
                const h = a.get(e), { value: d = h.settings.fromValue } = h;
                t = d, this.remove(e);
            }
            if (r = d1(r), !r) return;
            const l = PD[r.type];
            if (!l) {
                Fe.error(`unsupported transition type '${r.type}'`)();
                return;
            }
            const u = new l(this.timeline);
            u.start({
                ...r,
                fromValue: t,
                toValue: i
            }), a.set(e, u);
        }
        remove(e) {
            const { transitions: t } = this;
            t.has(e) && (t.get(e).cancel(), t.delete(e));
        }
        update() {
            const e = {};
            for (const [t, i] of this.transitions)i.update(), e[t] = i.value, i.inProgress || this.remove(t);
            return e;
        }
        clear() {
            for (const e of this.transitions.keys())this.remove(e);
        }
    }
    function kD(n) {
        const e = n[Zi];
        for(const t in e){
            const i = e[t], { validate: r } = i;
            if (r && !r(n[t], i)) throw new Error(`Invalid prop ${t}: ${n[t]}`);
        }
    }
    function UD(n, e) {
        const t = jg({
            newProps: n,
            oldProps: e,
            propTypes: n[Zi],
            ignoreProps: {
                data: null,
                updateTriggers: null,
                extensions: null,
                transitions: null
            }
        }), i = LD(n, e);
        let r = !1;
        return i || (r = FD(n, e)), {
            dataChanged: i,
            propsChanged: t,
            updateTriggersChanged: r,
            extensionsChanged: zD(n, e),
            transitionsChanged: BD(n, e)
        };
    }
    function BD(n, e) {
        if (!n.transitions) return !1;
        const t = {}, i = n[Zi];
        let r = !1;
        for(const a in n.transitions){
            const l = i[a], u = l && l.type;
            (u === "number" || u === "color" || u === "array") && Xd(n[a], e[a], l) && (t[a] = !0, r = !0);
        }
        return r ? t : !1;
    }
    function jg({ newProps: n, oldProps: e, ignoreProps: t = {}, propTypes: i = {}, triggerName: r = "props" }) {
        if (e === n) return !1;
        if (typeof n != "object" || n === null) return `${r} changed shallowly`;
        if (typeof e != "object" || e === null) return `${r} changed shallowly`;
        for (const a of Object.keys(n))if (!(a in t)) {
            if (!(a in e)) return `${r}.${a} added`;
            const l = Xd(n[a], e[a], i[a]);
            if (l) return `${r}.${a} ${l}`;
        }
        for (const a of Object.keys(e))if (!(a in t)) {
            if (!(a in n)) return `${r}.${a} dropped`;
            if (!Object.hasOwnProperty.call(n, a)) {
                const l = Xd(n[a], e[a], i[a]);
                if (l) return `${r}.${a} ${l}`;
            }
        }
        return !1;
    }
    function Xd(n, e, t) {
        let i = t && t.equal;
        return i && !i(n, e, t) || !i && (i = n && e && n.equals, i && !i.call(n, e)) ? "changed deeply" : !i && e !== n ? "changed shallowly" : null;
    }
    function LD(n, e) {
        if (e === null) return "oldProps is null, initial diff";
        let t = !1;
        const { dataComparator: i, _dataDiff: r } = n;
        return i ? i(n.data, e.data) || (t = "Data comparator detected a change") : n.data !== e.data && (t = "A new data container was supplied"), t && r && (t = r(n.data, e.data) || t), t;
    }
    function FD(n, e) {
        if (e === null) return {
            all: !0
        };
        if ("all" in n.updateTriggers && lv(n, e, "all")) return {
            all: !0
        };
        const t = {};
        let i = !1;
        for(const r in n.updateTriggers)r !== "all" && lv(n, e, r) && (t[r] = !0, i = !0);
        return i ? t : !1;
    }
    function zD(n, e) {
        if (e === null) return !0;
        const t = e.extensions, { extensions: i } = n;
        if (i === t) return !1;
        if (!t || !i || i.length !== t.length) return !0;
        for(let r = 0; r < i.length; r++)if (!i[r].equals(t[r])) return !0;
        return !1;
    }
    function lv(n, e, t) {
        let i = n.updateTriggers[t];
        i = i ?? {};
        let r = e.updateTriggers[t];
        return r = r ?? {}, jg({
            oldProps: r,
            newProps: i,
            triggerName: t
        });
    }
    const VD = "count(): argument not an object", HD = "count(): argument not a container";
    function jD(n) {
        if (!$D(n)) throw new Error(VD);
        if (typeof n.count == "function") return n.count();
        if (Number.isFinite(n.size)) return n.size;
        if (Number.isFinite(n.length)) return n.length;
        if (WD(n)) return Object.keys(n).length;
        throw new Error(HD);
    }
    function WD(n) {
        return n !== null && typeof n == "object" && n.constructor === Object;
    }
    function $D(n) {
        return n !== null && typeof n == "object";
    }
    function cv(n, e) {
        if (!e) return n;
        const t = {
            ...n,
            ...e
        };
        if ("defines" in e && (t.defines = {
            ...n.defines,
            ...e.defines
        }), "modules" in e && (t.modules = (n.modules || []).concat(e.modules), e.modules.some((i)=>i.name === "project64"))) {
            const i = t.modules.findIndex((r)=>r.name === "project32");
            i >= 0 && t.modules.splice(i, 1);
        }
        if ("inject" in e) if (!n.inject) t.inject = e.inject;
        else {
            const i = {
                ...n.inject
            };
            for(const r in e.inject)i[r] = (i[r] || "") + e.inject[r];
            t.inject = i;
        }
        return t;
    }
    const XD = {
        minFilter: "linear",
        mipmapFilter: "linear",
        magFilter: "linear",
        addressModeU: "clamp-to-edge",
        addressModeV: "clamp-to-edge"
    }, Yd = {};
    function YD(n, e, t, i) {
        if (t instanceof Xe) return t;
        t.constructor && t.constructor.name !== "Object" && (t = {
            data: t
        });
        let r = null;
        t.compressed && (r = {
            minFilter: "linear",
            mipmapFilter: t.data.length > 1 ? "nearest" : "linear"
        });
        const a = e.createTexture({
            ...t,
            sampler: {
                ...XD,
                ...r,
                ...i
            },
            mipmaps: !0
        });
        return Yd[a.id] = n, a;
    }
    function qD(n, e) {
        !e || !(e instanceof Xe) || Yd[e.id] === n && (e.delete(), delete Yd[e.id]);
    }
    const KD = {
        boolean: {
            validate (n, e) {
                return !0;
            },
            equal (n, e, t) {
                return !!n == !!e;
            }
        },
        number: {
            validate (n, e) {
                return Number.isFinite(n) && (!("max" in e) || n <= e.max) && (!("min" in e) || n >= e.min);
            }
        },
        color: {
            validate (n, e) {
                return e.optional && !n || qd(n) && (n.length === 3 || n.length === 4);
            },
            equal (n, e, t) {
                return Ht(n, e, 1);
            }
        },
        accessor: {
            validate (n, e) {
                const t = zc(n);
                return t === "function" || t === zc(e.value);
            },
            equal (n, e, t) {
                return typeof e == "function" ? !0 : Ht(n, e, 1);
            }
        },
        array: {
            validate (n, e) {
                return e.optional && !n || qd(n);
            },
            equal (n, e, t) {
                const { compare: i } = t, r = Number.isInteger(i) ? i : i ? 1 : 0;
                return i ? Ht(n, e, r) : n === e;
            }
        },
        object: {
            equal (n, e, t) {
                if (t.ignore) return !0;
                const { compare: i } = t, r = Number.isInteger(i) ? i : i ? 1 : 0;
                return i ? Ht(n, e, r) : n === e;
            }
        },
        function: {
            validate (n, e) {
                return e.optional && !n || typeof n == "function";
            },
            equal (n, e, t) {
                return !t.compare && t.ignore !== !1 || n === e;
            }
        },
        data: {
            transform: (n, e, t)=>{
                if (!n) return n;
                const { dataTransform: i } = t.props;
                return i ? i(n) : typeof n.shape == "string" && n.shape.endsWith("-table") && Array.isArray(n.data) ? n.data : n;
            }
        },
        image: {
            transform: (n, e, t)=>{
                const i = t.context;
                return !i || !i.device ? null : YD(t.id, i.device, n, {
                    ...e.parameters,
                    ...t.props.textureParameters
                });
            },
            release: (n, e, t)=>{
                qD(t.id, n);
            }
        }
    };
    function ZD(n) {
        const e = {}, t = {}, i = {};
        for (const [r, a] of Object.entries(n)){
            const l = a?.deprecatedFor;
            if (l) i[r] = Array.isArray(l) ? l : [
                l
            ];
            else {
                const u = QD(r, a);
                e[r] = u, t[r] = u.value;
            }
        }
        return {
            propTypes: e,
            defaultProps: t,
            deprecatedProps: i
        };
    }
    function QD(n, e) {
        switch(zc(e)){
            case "object":
                return so(n, e);
            case "array":
                return so(n, {
                    type: "array",
                    value: e,
                    compare: !1
                });
            case "boolean":
                return so(n, {
                    type: "boolean",
                    value: e
                });
            case "number":
                return so(n, {
                    type: "number",
                    value: e
                });
            case "function":
                return so(n, {
                    type: "function",
                    value: e,
                    compare: !0
                });
            default:
                return {
                    name: n,
                    type: "unknown",
                    value: e
                };
        }
    }
    function so(n, e) {
        return "type" in e ? {
            name: n,
            ...KD[e.type],
            ...e
        } : "value" in e ? {
            name: n,
            type: zc(e.value),
            ...e
        } : {
            name: n,
            type: "object",
            value: e
        };
    }
    function qd(n) {
        return Array.isArray(n) || ArrayBuffer.isView(n);
    }
    function zc(n) {
        return qd(n) ? "array" : n === null ? "null" : typeof n;
    }
    function GD(n, e) {
        let t;
        for(let a = e.length - 1; a >= 0; a--){
            const l = e[a];
            "extensions" in l && (t = l.extensions);
        }
        const i = Kd(n.constructor, t), r = Object.create(i);
        r[Lc] = n, r[Nr] = {}, r[Yi] = {};
        for(let a = 0; a < e.length; ++a){
            const l = e[a];
            for(const u in l)r[u] = l[u];
        }
        return Object.freeze(r), r;
    }
    const JD = "_mergedDefaultProps";
    function Kd(n, e) {
        if (!(n instanceof ou.constructor)) return {};
        let t = JD;
        if (e) for (const r of e){
            const a = r.constructor;
            a && (t += `:${a.extensionName || a.name}`);
        }
        const i = x1(n, t);
        return i || (n[t] = ek(n, e || []));
    }
    function ek(n, e) {
        if (!n.prototype) return null;
        const i = Object.getPrototypeOf(n), r = Kd(i), a = x1(n, "defaultProps") || {}, l = ZD(a), u = Object.assign(Object.create(null), r, l.defaultProps), h = Object.assign(Object.create(null), r?.[Zi], l.propTypes), d = Object.assign(Object.create(null), r?.[rd], l.deprecatedProps);
        for (const p of e){
            const _ = Kd(p.constructor);
            _ && (Object.assign(u, _), Object.assign(h, _[Zi]), Object.assign(d, _[rd]));
        }
        return tk(u, n), ik(u, h), nk(u, d), u[Zi] = h, u[rd] = d, e.length === 0 && !Wg(n, "_propTypes") && (n._propTypes = h), u;
    }
    function tk(n, e) {
        const t = sk(e);
        Object.defineProperties(n, {
            id: {
                writable: !0,
                value: t
            }
        });
    }
    function nk(n, e) {
        for(const t in e)Object.defineProperty(n, t, {
            enumerable: !1,
            set (i) {
                const r = `${this.id}: ${t}`;
                for (const a of e[t])Wg(this, a) || (this[a] = i);
                Fe.deprecated(r, e[t].join("/"))();
            }
        });
    }
    function ik(n, e) {
        const t = {}, i = {};
        for(const r in e){
            const a = e[r], { name: l, value: u } = a;
            a.async && (t[l] = u, i[l] = rk(l));
        }
        n[Hs] = t, n[Nr] = {}, Object.defineProperties(n, i);
    }
    function rk(n) {
        return {
            enumerable: !0,
            set (e) {
                typeof e == "string" || e instanceof Promise || h1(e) ? this[Nr][n] = e : this[Yi][n] = e;
            },
            get () {
                if (this[Yi]) {
                    if (n in this[Yi]) return this[Yi][n] || this[Hs][n];
                    if (n in this[Nr]) {
                        const e = this[Lc] && this[Lc].internalState;
                        if (e && e.hasAsyncProp(n)) return e.getAsyncProp(n) || this[Hs][n];
                    }
                }
                return this[Hs][n];
            }
        };
    }
    function Wg(n, e) {
        return Object.prototype.hasOwnProperty.call(n, e);
    }
    function x1(n, e) {
        return Wg(n, e) && n[e];
    }
    function sk(n) {
        const e = n.componentName;
        return e || Fe.warn(`${n.name}.componentName not specified`)(), e || n.name;
    }
    let ak = 0;
    class ou {
        constructor(...e){
            this.props = GD(this, e), this.id = this.props.id, this.count = ak++;
        }
        clone(e) {
            const { props: t } = this, i = {};
            for(const r in t[Hs])r in t[Yi] ? i[r] = t[Yi][r] : r in t[Nr] && (i[r] = t[Nr][r]);
            return new this.constructor({
                ...t,
                ...i,
                ...e
            });
        }
    }
    ou.componentName = "Component";
    ou.defaultProps = {};
    const ok = Object.freeze({});
    class lk {
        constructor(e){
            this.component = e, this.asyncProps = {}, this.onAsyncPropUpdated = ()=>{}, this.oldProps = null, this.oldAsyncProps = null;
        }
        finalize() {
            for(const e in this.asyncProps){
                const t = this.asyncProps[e];
                t && t.type && t.type.release && t.type.release(t.resolvedValue, t.type, this.component);
            }
            this.asyncProps = {}, this.component = null, this.resetOldProps();
        }
        getOldProps() {
            return this.oldAsyncProps || this.oldProps || ok;
        }
        resetOldProps() {
            this.oldAsyncProps = null, this.oldProps = this.component ? this.component.props : null;
        }
        hasAsyncProp(e) {
            return e in this.asyncProps;
        }
        getAsyncProp(e) {
            const t = this.asyncProps[e];
            return t && t.resolvedValue;
        }
        isAsyncPropLoading(e) {
            if (e) {
                const t = this.asyncProps[e];
                return !!(t && t.pendingLoadCount > 0 && t.pendingLoadCount !== t.resolvedLoadCount);
            }
            for(const t in this.asyncProps)if (this.isAsyncPropLoading(t)) return !0;
            return !1;
        }
        reloadAsyncProp(e, t) {
            this._watchPromise(e, Promise.resolve(t));
        }
        setAsyncProps(e) {
            this.component = e[Lc] || this.component;
            const t = e[Yi] || {}, i = e[Nr] || e, r = e[Hs] || {};
            for(const a in t){
                const l = t[a];
                this._createAsyncPropData(a, r[a]), this._updateAsyncProp(a, l), t[a] = this.getAsyncProp(a);
            }
            for(const a in i){
                const l = i[a];
                this._createAsyncPropData(a, r[a]), this._updateAsyncProp(a, l);
            }
        }
        _fetch(e, t) {
            return null;
        }
        _onResolve(e, t) {}
        _onError(e, t) {}
        _updateAsyncProp(e, t) {
            if (this._didAsyncInputValueChange(e, t)) {
                if (typeof t == "string" && (t = this._fetch(e, t)), t instanceof Promise) {
                    this._watchPromise(e, t);
                    return;
                }
                if (h1(t)) {
                    this._resolveAsyncIterable(e, t);
                    return;
                }
                this._setPropValue(e, t);
            }
        }
        _freezeAsyncOldProps() {
            if (!this.oldAsyncProps && this.oldProps) {
                this.oldAsyncProps = Object.create(this.oldProps);
                for(const e in this.asyncProps)Object.defineProperty(this.oldAsyncProps, e, {
                    enumerable: !0,
                    value: this.oldProps[e]
                });
            }
        }
        _didAsyncInputValueChange(e, t) {
            const i = this.asyncProps[e];
            return t === i.resolvedValue || t === i.lastValue ? !1 : (i.lastValue = t, !0);
        }
        _setPropValue(e, t) {
            this._freezeAsyncOldProps();
            const i = this.asyncProps[e];
            i && (t = this._postProcessValue(i, t), i.resolvedValue = t, i.pendingLoadCount++, i.resolvedLoadCount = i.pendingLoadCount);
        }
        _setAsyncPropValue(e, t, i) {
            const r = this.asyncProps[e];
            r && i >= r.resolvedLoadCount && t !== void 0 && (this._freezeAsyncOldProps(), r.resolvedValue = t, r.resolvedLoadCount = i, this.onAsyncPropUpdated(e, t));
        }
        _watchPromise(e, t) {
            const i = this.asyncProps[e];
            if (i) {
                i.pendingLoadCount++;
                const r = i.pendingLoadCount;
                t.then((a)=>{
                    this.component && (a = this._postProcessValue(i, a), this._setAsyncPropValue(e, a, r), this._onResolve(e, a));
                }).catch((a)=>{
                    this._onError(e, a);
                });
            }
        }
        async _resolveAsyncIterable(e, t) {
            if (e !== "data") {
                this._setPropValue(e, t);
                return;
            }
            const i = this.asyncProps[e];
            if (!i) return;
            i.pendingLoadCount++;
            const r = i.pendingLoadCount;
            let a = [], l = 0;
            for await (const u of t){
                if (!this.component) return;
                const { dataTransform: h } = this.component.props;
                h ? a = h(u, a) : a = a.concat(u), Object.defineProperty(a, "__diff", {
                    enumerable: !1,
                    value: [
                        {
                            startRow: l,
                            endRow: a.length
                        }
                    ]
                }), l = a.length, this._setAsyncPropValue(e, a, r);
            }
            this._onResolve(e, a);
        }
        _postProcessValue(e, t) {
            const i = e.type;
            return i && this.component && (i.release && i.release(e.resolvedValue, i, this.component), i.transform) ? i.transform(t, i, this.component) : t;
        }
        _createAsyncPropData(e, t) {
            if (!this.asyncProps[e]) {
                const r = this.component && this.component.props[Zi];
                this.asyncProps[e] = {
                    type: r && r[e],
                    lastValue: null,
                    resolvedValue: t,
                    pendingLoadCount: 0,
                    resolvedLoadCount: 0
                };
            }
        }
    }
    class ck extends lk {
        constructor({ attributeManager: e, layer: t }){
            super(t), this.attributeManager = e, this.needsRedraw = !0, this.needsUpdate = !0, this.subLayers = null, this.usesPickingColorCache = !1;
        }
        get layer() {
            return this.component;
        }
        _fetch(e, t) {
            const i = this.layer, r = i?.props.fetch;
            return r ? r(t, {
                propName: e,
                layer: i
            }) : super._fetch(e, t);
        }
        _onResolve(e, t) {
            const i = this.layer;
            if (i) {
                const r = i.props.onDataLoad;
                e === "data" && r && r(t, {
                    propName: e,
                    layer: i
                });
            }
        }
        _onError(e, t) {
            const i = this.layer;
            i && i.raiseError(t, `loading ${e} of ${this.layer}`);
        }
    }
    const uk = "layer.changeFlag", fk = "layer.initialize", hk = "layer.update", dk = "layer.finalize", gk = "layer.matched", uv = 2 ** 24 - 1, pk = Object.freeze([]), mk = No(({ oldViewport: n, viewport: e })=>n.equals(e));
    let wn = new Uint8ClampedArray(0);
    const _k = {
        data: {
            type: "data",
            value: pk,
            async: !0
        },
        dataComparator: {
            type: "function",
            value: null,
            optional: !0
        },
        _dataDiff: {
            type: "function",
            value: (n)=>n && n.__diff,
            optional: !0
        },
        dataTransform: {
            type: "function",
            value: null,
            optional: !0
        },
        onDataLoad: {
            type: "function",
            value: null,
            optional: !0
        },
        onError: {
            type: "function",
            value: null,
            optional: !0
        },
        fetch: {
            type: "function",
            value: (n, { propName: e, layer: t, loaders: i, loadOptions: r, signal: a })=>{
                const { resourceManager: l } = t.context;
                r = r || t.getLoadOptions(), i = i || t.props.loaders, a && (r = {
                    ...r,
                    fetch: {
                        ...r?.fetch,
                        signal: a
                    }
                });
                let u = l.contains(n);
                return !u && !r && (l.add({
                    resourceId: n,
                    data: bd(n, i),
                    persistent: !1
                }), u = !0), u ? l.subscribe({
                    resourceId: n,
                    onChange: (h)=>t.internalState?.reloadAsyncProp(e, h),
                    consumerId: t.id,
                    requestId: e
                }) : bd(n, i, r);
            }
        },
        updateTriggers: {},
        visible: !0,
        pickable: !1,
        opacity: {
            type: "number",
            min: 0,
            max: 1,
            value: 1
        },
        operation: "draw",
        onHover: {
            type: "function",
            value: null,
            optional: !0
        },
        onClick: {
            type: "function",
            value: null,
            optional: !0
        },
        onDragStart: {
            type: "function",
            value: null,
            optional: !0
        },
        onDrag: {
            type: "function",
            value: null,
            optional: !0
        },
        onDragEnd: {
            type: "function",
            value: null,
            optional: !0
        },
        coordinateSystem: Oe.DEFAULT,
        coordinateOrigin: {
            type: "array",
            value: [
                0,
                0,
                0
            ],
            compare: !0
        },
        modelMatrix: {
            type: "array",
            value: null,
            compare: !0,
            optional: !0
        },
        wrapLongitude: !1,
        positionFormat: "XYZ",
        colorFormat: "RGBA",
        parameters: {
            type: "object",
            value: {},
            optional: !0,
            compare: 2
        },
        loadOptions: {
            type: "object",
            value: null,
            optional: !0,
            ignore: !0
        },
        transitions: null,
        extensions: [],
        loaders: {
            type: "array",
            value: [],
            optional: !0,
            ignore: !0
        },
        getPolygonOffset: {
            type: "function",
            value: ({ layerIndex: n })=>[
                    0,
                    -n * 100
                ]
        },
        highlightedObjectIndex: null,
        autoHighlight: !1,
        highlightColor: {
            type: "accessor",
            value: [
                0,
                0,
                128,
                128
            ]
        }
    };
    class Br extends ou {
        constructor(){
            super(...arguments), this.internalState = null, this.lifecycle = Ns.NO_STATE, this.parent = null;
        }
        static get componentName() {
            return Object.prototype.hasOwnProperty.call(this, "layerName") ? this.layerName : "";
        }
        get root() {
            let e = this;
            for(; e.parent;)e = e.parent;
            return e;
        }
        toString() {
            return `${this.constructor.layerName || this.constructor.name}({id: '${this.props.id}'})`;
        }
        project(e) {
            Nt(this.internalState);
            const t = this.internalState.viewport || this.context.viewport, i = LT(e, {
                viewport: t,
                modelMatrix: this.props.modelMatrix,
                coordinateOrigin: this.props.coordinateOrigin,
                coordinateSystem: this.props.coordinateSystem
            }), [r, a, l] = PT(i, t.pixelProjectionMatrix);
            return e.length === 2 ? [
                r,
                a
            ] : [
                r,
                a,
                l
            ];
        }
        unproject(e) {
            return Nt(this.internalState), (this.internalState.viewport || this.context.viewport).unproject(e);
        }
        projectPosition(e, t) {
            Nt(this.internalState);
            const i = this.internalState.viewport || this.context.viewport;
            return FT(e, {
                viewport: i,
                modelMatrix: this.props.modelMatrix,
                coordinateOrigin: this.props.coordinateOrigin,
                coordinateSystem: this.props.coordinateSystem,
                ...t
            });
        }
        get isComposite() {
            return !1;
        }
        get isDrawable() {
            return !0;
        }
        setState(e) {
            this.setChangeFlags({
                stateChanged: !0
            }), Object.assign(this.state, e), this.setNeedsRedraw();
        }
        setNeedsRedraw() {
            this.internalState && (this.internalState.needsRedraw = !0);
        }
        setNeedsUpdate() {
            this.internalState && (this.context.layerManager.setNeedsUpdate(String(this)), this.internalState.needsUpdate = !0);
        }
        get isLoaded() {
            return this.internalState ? !this.internalState.isAsyncPropLoading() : !1;
        }
        get wrapLongitude() {
            return this.props.wrapLongitude;
        }
        isPickable() {
            return this.props.pickable && this.props.visible;
        }
        getModels() {
            const e = this.state;
            return e && (e.models || e.model && [
                e.model
            ]) || [];
        }
        setShaderModuleProps(...e) {
            for (const t of this.getModels())t.shaderInputs.setProps(...e);
        }
        getAttributeManager() {
            return this.internalState && this.internalState.attributeManager;
        }
        getCurrentLayer() {
            return this.internalState && this.internalState.layer;
        }
        getLoadOptions() {
            return this.props.loadOptions;
        }
        use64bitPositions() {
            const { coordinateSystem: e } = this.props;
            return e === Oe.DEFAULT || e === Oe.LNGLAT || e === Oe.CARTESIAN;
        }
        onHover(e, t) {
            return this.props.onHover && this.props.onHover(e, t) || !1;
        }
        onClick(e, t) {
            return this.props.onClick && this.props.onClick(e, t) || !1;
        }
        nullPickingColor() {
            return [
                0,
                0,
                0
            ];
        }
        encodePickingColor(e, t = []) {
            return t[0] = e + 1 & 255, t[1] = e + 1 >> 8 & 255, t[2] = e + 1 >> 8 >> 8 & 255, t;
        }
        decodePickingColor(e) {
            Nt(e instanceof Uint8Array);
            const [t, i, r] = e;
            return t + i * 256 + r * 65536 - 1;
        }
        getNumInstances() {
            return Number.isFinite(this.props.numInstances) ? this.props.numInstances : this.state && this.state.numInstances !== void 0 ? this.state.numInstances : jD(this.props.data);
        }
        getStartIndices() {
            return this.props.startIndices ? this.props.startIndices : this.state && this.state.startIndices ? this.state.startIndices : null;
        }
        getBounds() {
            return this.getAttributeManager()?.getBounds([
                "positions",
                "instancePositions"
            ]);
        }
        getShaders(e) {
            e = cv(e, {
                disableWarnings: !0,
                modules: this.context.defaultShaderModules
            });
            for (const t of this.props.extensions)e = cv(e, t.getShaders.call(this, t));
            return e;
        }
        shouldUpdateState(e) {
            return e.changeFlags.propsOrDataChanged;
        }
        updateState(e) {
            const t = this.getAttributeManager(), { dataChanged: i } = e.changeFlags;
            if (i && t) if (Array.isArray(i)) for (const r of i)t.invalidateAll(r);
            else t.invalidateAll();
            if (t) {
                const { props: r } = e, a = this.internalState.hasPickingBuffer, l = Number.isInteger(r.highlightedObjectIndex) || r.pickable || r.extensions.some((u)=>u.getNeedsPickingBuffer.call(this, u));
                if (a !== l) {
                    this.internalState.hasPickingBuffer = l;
                    const { pickingColors: u, instancePickingColors: h } = t.attributes, d = u || h;
                    d && (l && d.constant && (d.constant = !1, t.invalidate(d.id)), !d.value && !l && (d.constant = !0, d.value = [
                        0,
                        0,
                        0
                    ]));
                }
            }
        }
        finalizeState(e) {
            for (const i of this.getModels())i.destroy();
            const t = this.getAttributeManager();
            t && t.finalize(), this.context && this.context.resourceManager.unsubscribe({
                consumerId: this.id
            }), this.internalState && (this.internalState.uniformTransitions.clear(), this.internalState.finalize());
        }
        draw(e) {
            for (const t of this.getModels())t.draw(e.renderPass);
        }
        getPickingInfo({ info: e, mode: t, sourceLayer: i }) {
            const { index: r } = e;
            return r >= 0 && Array.isArray(this.props.data) && (e.object = this.props.data[r]), e;
        }
        raiseError(e, t) {
            t && (e = new Error(`${t}: ${e.message}`, {
                cause: e
            })), this.props.onError?.(e) || this.context?.onError?.(e, this);
        }
        getNeedsRedraw(e = {
            clearRedrawFlags: !1
        }) {
            return this._getNeedsRedraw(e);
        }
        needsUpdate() {
            return this.internalState ? this.internalState.needsUpdate || this.hasUniformTransition() || this.shouldUpdateState(this._getUpdateParams()) : !1;
        }
        hasUniformTransition() {
            return this.internalState?.uniformTransitions.active || !1;
        }
        activateViewport(e) {
            if (!this.internalState) return;
            const t = this.internalState.viewport;
            this.internalState.viewport = e, (!t || !mk({
                oldViewport: t,
                viewport: e
            })) && (this.setChangeFlags({
                viewportChanged: !0
            }), this.isComposite ? this.needsUpdate() && this.setNeedsUpdate() : this._update());
        }
        invalidateAttribute(e = "all") {
            const t = this.getAttributeManager();
            t && (e === "all" ? t.invalidateAll() : t.invalidate(e));
        }
        updateAttributes(e) {
            let t = !1;
            for(const i in e)e[i].layoutChanged() && (t = !0);
            for (const i of this.getModels())this._setModelAttributes(i, e, t);
        }
        _updateAttributes() {
            const e = this.getAttributeManager();
            if (!e) return;
            const t = this.props, i = this.getNumInstances(), r = this.getStartIndices();
            e.update({
                data: t.data,
                numInstances: i,
                startIndices: r,
                props: t,
                transitions: t.transitions,
                buffers: t.data.attributes,
                context: this
            });
            const a = e.getChangedAttributes({
                clearChangedFlags: !0
            });
            this.updateAttributes(a);
        }
        _updateAttributeTransition() {
            const e = this.getAttributeManager();
            e && e.updateTransition();
        }
        _updateUniformTransition() {
            const { uniformTransitions: e } = this.internalState;
            if (e.active) {
                const t = e.update(), i = Object.create(this.props);
                for(const r in t)Object.defineProperty(i, r, {
                    value: t[r]
                });
                return i;
            }
            return this.props;
        }
        calculateInstancePickingColors(e, { numInstances: t }) {
            if (e.constant) return;
            const i = Math.floor(wn.length / 4);
            if (this.internalState.usesPickingColorCache = !0, i < t) {
                t > uv && Fe.warn("Layer has too many data objects. Picking might not be able to distinguish all objects.")(), wn = Ao.allocate(wn, t, {
                    size: 4,
                    copy: !0,
                    maxCount: Math.max(t, uv)
                });
                const r = Math.floor(wn.length / 4), a = [
                    0,
                    0,
                    0
                ];
                for(let l = i; l < r; l++)this.encodePickingColor(l, a), wn[l * 4 + 0] = a[0], wn[l * 4 + 1] = a[1], wn[l * 4 + 2] = a[2], wn[l * 4 + 3] = 0;
            }
            e.value = wn.subarray(0, t * 4);
        }
        _setModelAttributes(e, t, i = !1) {
            if (!Object.keys(t).length) return;
            if (i) {
                const u = this.getAttributeManager();
                e.setBufferLayout(u.getBufferLayouts(e)), t = u.getAttributes();
            }
            const r = e.userData?.excludeAttributes || {}, a = {}, l = {};
            for(const u in t){
                if (r[u]) continue;
                const h = t[u].getValue();
                for(const d in h){
                    const p = h[d];
                    p instanceof Ge ? t[u].settings.isIndexed ? e.setIndexBuffer(p) : a[d] = p : p && (l[d] = p);
                }
            }
            e.setAttributes(a), e.setConstantAttributes(l);
        }
        disablePickingIndex(e) {
            const t = this.props.data;
            if (!("attributes" in t)) {
                this._disablePickingIndex(e);
                return;
            }
            const { pickingColors: i, instancePickingColors: r } = this.getAttributeManager().attributes, a = i || r, l = a && t.attributes && t.attributes[a.id];
            if (l && l.value) {
                const u = l.value, h = this.encodePickingColor(e);
                for(let d = 0; d < t.length; d++){
                    const p = a.getVertexOffset(d);
                    u[p] === h[0] && u[p + 1] === h[1] && u[p + 2] === h[2] && this._disablePickingIndex(d);
                }
            } else this._disablePickingIndex(e);
        }
        _disablePickingIndex(e) {
            const { pickingColors: t, instancePickingColors: i } = this.getAttributeManager().attributes, r = t || i;
            if (!r) return;
            const a = r.getVertexOffset(e), l = r.getVertexOffset(e + 1);
            r.buffer.write(new Uint8Array(l - a), a);
        }
        restorePickingColors() {
            const { pickingColors: e, instancePickingColors: t } = this.getAttributeManager().attributes, i = e || t;
            i && (this.internalState.usesPickingColorCache && i.value.buffer !== wn.buffer && (i.value = wn.subarray(0, i.value.length)), i.updateSubBuffer({
                startOffset: 0
            }));
        }
        _initialize() {
            Nt(!this.internalState), Nt(Number.isFinite(this.props.coordinateSystem)), It(fk, this);
            const e = this._getAttributeManager();
            e && e.addInstanced({
                instancePickingColors: {
                    type: "uint8",
                    size: 4,
                    noAlloc: !0,
                    update: this.calculateInstancePickingColors
                }
            }), this.internalState = new ck({
                attributeManager: e,
                layer: this
            }), this._clearChangeFlags(), this.state = {}, Object.defineProperty(this.state, "attributeManager", {
                get: ()=>(Fe.deprecated("layer.state.attributeManager", "layer.getAttributeManager()")(), e)
            }), this.internalState.uniformTransitions = new DD(this.context.timeline), this.internalState.onAsyncPropUpdated = this._onAsyncPropUpdated.bind(this), this.internalState.setAsyncProps(this.props), this.initializeState(this.context);
            for (const t of this.props.extensions)t.initializeState.call(this, this.context, t);
            this.setChangeFlags({
                dataChanged: "init",
                propsChanged: "init",
                viewportChanged: !0,
                extensionsChanged: !0
            }), this._update();
        }
        _transferState(e) {
            It(gk, this, this === e);
            const { state: t, internalState: i } = e;
            this !== e && (this.internalState = i, this.state = t, this.internalState.setAsyncProps(this.props), this._diffProps(this.props, this.internalState.getOldProps()));
        }
        _update() {
            const e = this.needsUpdate();
            if (It(hk, this, e), !e) return;
            const t = this.props, i = this.context, r = this.internalState, a = i.viewport, l = this._updateUniformTransition();
            r.propsInTransition = l, i.viewport = r.viewport || a, this.props = l;
            try {
                const u = this._getUpdateParams(), h = this.getModels();
                if (i.device) this.updateState(u);
                else try {
                    this.updateState(u);
                } catch  {}
                for (const p of this.props.extensions)p.updateState.call(this, u, p);
                this.setNeedsRedraw(), this._updateAttributes();
                const d = this.getModels()[0] !== h[0];
                this._postUpdate(u, d);
            } finally{
                i.viewport = a, this.props = t, this._clearChangeFlags(), r.needsUpdate = !1, r.resetOldProps();
            }
        }
        _finalize() {
            It(dk, this), this.finalizeState(this.context);
            for (const e of this.props.extensions)e.finalizeState.call(this, this.context, e);
        }
        _drawLayer({ renderPass: e, shaderModuleProps: t = null, uniforms: i = {}, parameters: r = {} }) {
            this._updateAttributeTransition();
            const a = this.props, l = this.context;
            this.props = this.internalState.propsInTransition || a;
            try {
                t && this.setShaderModuleProps(t);
                const { getPolygonOffset: u } = this.props, h = u && u(i) || [
                    0,
                    0
                ];
                l.device instanceof Fs && l.device.setParametersWebGL({
                    polygonOffset: h
                });
                for (const d of this.getModels())d.device.type === "webgpu" ? d.setParameters({
                    ...d.parameters,
                    ...r
                }) : d.setParameters(r);
                if (l.device instanceof Fs) l.device.withParametersWebGL(r, ()=>{
                    const d = {
                        renderPass: e,
                        shaderModuleProps: t,
                        uniforms: i,
                        parameters: r,
                        context: l
                    };
                    for (const p of this.props.extensions)p.draw.call(this, d, p);
                    this.draw(d);
                });
                else {
                    const d = {
                        renderPass: e,
                        shaderModuleProps: t,
                        uniforms: i,
                        parameters: r,
                        context: l
                    };
                    for (const p of this.props.extensions)p.draw.call(this, d, p);
                    this.draw(d);
                }
            } finally{
                this.props = a;
            }
        }
        getChangeFlags() {
            return this.internalState?.changeFlags;
        }
        setChangeFlags(e) {
            if (!this.internalState) return;
            const { changeFlags: t } = this.internalState;
            for(const r in e)if (e[r]) {
                let a = !1;
                switch(r){
                    case "dataChanged":
                        const l = e[r], u = t[r];
                        l && Array.isArray(u) && (t.dataChanged = Array.isArray(l) ? u.concat(l) : l, a = !0);
                    default:
                        t[r] || (t[r] = e[r], a = !0);
                }
                a && It(uk, this, r, e);
            }
            const i = !!(t.dataChanged || t.updateTriggersChanged || t.propsChanged || t.extensionsChanged);
            t.propsOrDataChanged = i, t.somethingChanged = i || t.viewportChanged || t.stateChanged;
        }
        _clearChangeFlags() {
            this.internalState.changeFlags = {
                dataChanged: !1,
                propsChanged: !1,
                updateTriggersChanged: !1,
                viewportChanged: !1,
                stateChanged: !1,
                extensionsChanged: !1,
                propsOrDataChanged: !1,
                somethingChanged: !1
            };
        }
        _diffProps(e, t) {
            const i = UD(e, t);
            if (i.updateTriggersChanged) for(const r in i.updateTriggersChanged)i.updateTriggersChanged[r] && this.invalidateAttribute(r);
            if (i.transitionsChanged) for(const r in i.transitionsChanged)this.internalState.uniformTransitions.add(r, t[r], e[r], e.transitions?.[r]);
            return this.setChangeFlags(i);
        }
        validateProps() {
            kD(this.props);
        }
        updateAutoHighlight(e) {
            this.props.autoHighlight && !Number.isInteger(this.props.highlightedObjectIndex) && this._updateAutoHighlight(e);
        }
        _updateAutoHighlight(e) {
            const t = {
                highlightedObjectColor: e.picked ? e.color : null
            }, { highlightColor: i } = this.props;
            e.picked && typeof i == "function" && (t.highlightColor = i(e)), this.setShaderModuleProps({
                picking: t
            }), this.setNeedsRedraw();
        }
        _getAttributeManager() {
            const e = this.context;
            return new au(e.device, {
                id: this.props.id,
                stats: e.stats,
                timeline: e.timeline
            });
        }
        _postUpdate(e, t) {
            const { props: i, oldProps: r } = e, a = this.state.model;
            a?.isInstanced && a.setInstanceCount(this.getNumInstances());
            const { autoHighlight: l, highlightedObjectIndex: u, highlightColor: h } = i;
            if (t || r.autoHighlight !== l || r.highlightedObjectIndex !== u || r.highlightColor !== h) {
                const d = {};
                Array.isArray(h) && (d.highlightColor = h), (t || r.autoHighlight !== l || u !== r.highlightedObjectIndex) && (d.highlightedObjectColor = Number.isFinite(u) && u >= 0 ? this.encodePickingColor(u) : null), this.setShaderModuleProps({
                    picking: d
                });
            }
        }
        _getUpdateParams() {
            return {
                props: this.props,
                oldProps: this.internalState.getOldProps(),
                context: this.context,
                changeFlags: this.internalState.changeFlags
            };
        }
        _getNeedsRedraw(e) {
            if (!this.internalState) return !1;
            let t = !1;
            t = t || this.internalState.needsRedraw && this.id;
            const i = this.getAttributeManager(), r = i ? i.getNeedsRedraw(e) : !1;
            if (t = t || r, t) for (const a of this.props.extensions)a.onNeedsRedraw.call(this, a);
            return this.internalState.needsRedraw = this.internalState.needsRedraw && !e.clearRedrawFlags, t;
        }
        _onAsyncPropUpdated() {
            this._diffProps(this.props, this.internalState.getOldProps()), this.setNeedsUpdate();
        }
    }
    Br.defaultProps = _k;
    Br.layerName = "Layer";
    const yk = "compositeLayer.renderLayers";
    class $g extends Br {
        get isComposite() {
            return !0;
        }
        get isDrawable() {
            return !1;
        }
        get isLoaded() {
            return super.isLoaded && this.getSubLayers().every((e)=>e.isLoaded);
        }
        getSubLayers() {
            return this.internalState && this.internalState.subLayers || [];
        }
        initializeState(e) {}
        setState(e) {
            super.setState(e), this.setNeedsUpdate();
        }
        getPickingInfo({ info: e }) {
            const { object: t } = e;
            return t && t.__source && t.__source.parent && t.__source.parent.id === this.id && (e.object = t.__source.object, e.index = t.__source.index), e;
        }
        filterSubLayer(e) {
            return !0;
        }
        shouldRenderSubLayer(e, t) {
            return t && t.length;
        }
        getSubLayerClass(e, t) {
            const { _subLayerProps: i } = this.props;
            return i && i[e] && i[e].type || t;
        }
        getSubLayerRow(e, t, i) {
            return e.__source = {
                parent: this,
                object: t,
                index: i
            }, e;
        }
        getSubLayerAccessor(e) {
            if (typeof e == "function") {
                const t = {
                    index: -1,
                    data: this.props.data,
                    target: []
                };
                return (i, r)=>i && i.__source ? (t.index = i.__source.index, e(i.__source.object, t)) : e(i, r);
            }
            return e;
        }
        getSubLayerProps(e = {}) {
            const { opacity: t, pickable: i, visible: r, parameters: a, getPolygonOffset: l, highlightedObjectIndex: u, autoHighlight: h, highlightColor: d, coordinateSystem: p, coordinateOrigin: _, wrapLongitude: y, positionFormat: v, modelMatrix: S, extensions: E, fetch: M, operation: B, _subLayerProps: H } = this.props, O = {
                id: "",
                updateTriggers: {},
                opacity: t,
                pickable: i,
                visible: r,
                parameters: a,
                getPolygonOffset: l,
                highlightedObjectIndex: u,
                autoHighlight: h,
                highlightColor: d,
                coordinateSystem: p,
                coordinateOrigin: _,
                wrapLongitude: y,
                positionFormat: v,
                modelMatrix: S,
                extensions: E,
                fetch: M,
                operation: B
            }, U = H && e.id && H[e.id], L = U && U.updateTriggers, Z = e.id || "sublayer";
            if (U) {
                const se = this.props[Zi], ae = e.type ? e.type._propTypes : {};
                for(const te in U){
                    const fe = ae[te] || se[te];
                    fe && fe.type === "accessor" && (U[te] = this.getSubLayerAccessor(U[te]));
                }
            }
            Object.assign(O, e, U), O.id = `${this.props.id}-${Z}`, O.updateTriggers = {
                all: this.props.updateTriggers?.all,
                ...e.updateTriggers,
                ...L
            };
            for (const se of E){
                const ae = se.getSubLayerProps.call(this, se);
                ae && Object.assign(O, ae, {
                    updateTriggers: Object.assign(O.updateTriggers, ae.updateTriggers)
                });
            }
            return O;
        }
        _updateAutoHighlight(e) {
            for (const t of this.getSubLayers())t.updateAutoHighlight(e);
        }
        _getAttributeManager() {
            return null;
        }
        _postUpdate(e, t) {
            let i = this.internalState.subLayers;
            const r = !i || this.needsUpdate();
            if (r) {
                const a = this.renderLayers();
                i = Ug(a, Boolean), this.internalState.subLayers = i;
            }
            It(yk, this, r, i);
            for (const a of i)a.parent = this;
        }
    }
    $g.layerName = "CompositeLayer";
    const bk = typeof window < "u" ? Q.useLayoutEffect : Q.useEffect;
    function Vc(n, e) {
        for(; n;){
            if (n === e) return !0;
            n = Object.getPrototypeOf(n);
        }
        return !1;
    }
    const vk = {
        position: "absolute",
        zIndex: -1
    };
    function S1(n, e) {
        if (typeof n == "function") return n(e);
        if (Array.isArray(n)) return n.map((t)=>S1(t, e));
        if (lu(n)) {
            if (Tk(n)) return e.style = vk, Q.cloneElement(n, e);
            if (xk(n)) return Q.cloneElement(n, e);
        }
        return n;
    }
    function lu(n) {
        return n && typeof n == "object" && "type" in n || !1;
    }
    function Tk(n) {
        return n.props?.mapStyle;
    }
    function xk(n) {
        const e = n.type;
        return e && e.deckGLViewProps;
    }
    function Zd(n) {
        if (typeof n == "function") return Q.createElement(Gs, {}, n);
        if (Array.isArray(n)) return n.map(Zd);
        if (lu(n)) {
            if (n.type === Q.Fragment) return Zd(n.props.children);
            if (Vc(n.type, Gs)) return n;
        }
        return n;
    }
    function Sk({ children: n, layers: e = [], views: t = null }) {
        const i = [], r = [], a = {};
        return Q.Children.forEach(Zd(n), (l)=>{
            if (lu(l)) {
                const u = l.type;
                if (Vc(u, Br)) {
                    const h = Ak(u, l.props);
                    r.push(h);
                } else i.push(l);
                if (Vc(u, Gs) && u !== Gs && l.props.id) {
                    const h = new u(l.props);
                    a[h.id] = h;
                }
            } else l && i.push(l);
        }), Object.keys(a).length > 0 && (Array.isArray(t) ? t.forEach((l)=>{
            a[l.id] = l;
        }) : t && (a[t.id] = t), t = Object.values(a)), e = r.length > 0 ? [
            ...r,
            ...e
        ] : e, {
            layers: e,
            children: i,
            views: t
        };
    }
    function Ak(n, e) {
        const t = {}, i = n.defaultProps || {};
        for(const r in e)i[r] !== e[r] && (t[r] = e[r]);
        return new n(t);
    }
    const wk = Q.createContext();
    function Ek({ children: n, deck: e, ContextProvider: t = wk.Provider }) {
        const { viewManager: i } = e || {};
        if (!i || !i.views.length) return [];
        const r = {}, a = i.views[0].id;
        for (const l of n){
            let u = a, h = l;
            lu(l) && Vc(l.type, Gs) && (u = l.props.id || a, h = l.props.children);
            const d = i.getViewport(u), p = i.getViewState(u);
            if (d) {
                p.padding = d.padding;
                const { x: _, y, width: v, height: S } = d;
                h = S1(h, {
                    x: _,
                    y,
                    width: v,
                    height: S,
                    viewport: d,
                    viewState: p
                }), r[u] || (r[u] = {
                    viewport: d,
                    children: []
                }), r[u].children.push(h);
            }
        }
        return Object.keys(r).map((l)=>{
            const { viewport: u, children: h } = r[l], { x: d, y: p, width: _, height: y } = u, v = {
                position: "absolute",
                left: d,
                top: p,
                width: _,
                height: y
            }, S = `view-${l}`, E = Q.createElement("div", {
                key: S,
                id: S,
                style: v
            }, ...h), M = {
                deck: e,
                viewport: u,
                container: e.canvas.offsetParent,
                eventManager: e.eventManager,
                onViewStateChange: (H)=>{
                    H.viewId = l, e._onViewStateChange(H);
                },
                widgets: []
            }, B = `view-${l}-context`;
            return Q.createElement(t, {
                key: B,
                value: M
            }, E);
        });
    }
    const Rk = {
        mixBlendMode: null
    };
    function Ck({ width: n, height: e, style: t }) {
        const i = {
            position: "absolute",
            zIndex: 0,
            left: 0,
            top: 0,
            width: n,
            height: e
        }, r = {
            left: 0,
            top: 0
        };
        if (t) for(const a in t)a in Rk ? r[a] = t[a] : i[a] = t[a];
        return {
            containerStyle: i,
            canvasStyle: r
        };
    }
    function Mk(n) {
        return {
            get deck () {
                return n.deck;
            },
            pickObject: (e)=>n.deck.pickObject(e),
            pickMultipleObjects: (e)=>n.deck.pickMultipleObjects(e),
            pickObjects: (e)=>n.deck.pickObjects(e)
        };
    }
    function A1(n) {
        n.redrawReason && (n.deck._drawLayers(n.redrawReason), n.redrawReason = null);
    }
    function Ok(n, e, t) {
        const i = new e({
            ...t,
            _customRender: t.deviceProps?.adapters?.[0]?.type === "webgpu" ? void 0 : (r)=>{
                n.redrawReason = r;
                const a = i.getViewports();
                n.lastRenderedViewports !== a ? n.forceUpdate() : A1(n);
            }
        });
        return i;
    }
    function Ik(n, e) {
        const [t, i] = Q.useState(0), a = Q.useRef({
            control: null,
            version: t,
            forceUpdate: ()=>i((L)=>L + 1)
        }).current, l = Q.useRef(null), u = Q.useRef(null), h = Q.useMemo(()=>Sk(n), [
            n.layers,
            n.views,
            n.children
        ]);
        let d = !0;
        const p = (L)=>d && n.viewState ? (a.viewStateUpdateRequested = L, null) : (a.viewStateUpdateRequested = null, n.onViewStateChange?.(L)), _ = (L)=>{
            d ? a.interactionStateUpdateRequested = L : (a.interactionStateUpdateRequested = null, n.onInteractionStateChange?.(L));
        }, y = Q.useMemo(()=>{
            const L = {
                widgets: [],
                ...n,
                style: null,
                width: "100%",
                height: "100%",
                parent: l.current,
                canvas: u.current,
                layers: h.layers,
                views: h.views,
                onViewStateChange: p,
                onInteractionStateChange: _
            };
            return delete L._customRender, a.deck && a.deck.setProps(L), L;
        }, [
            n
        ]);
        Q.useEffect(()=>{
            const L = n.Deck || Hg;
            return a.deck = Ok(a, L, {
                ...y,
                parent: l.current,
                canvas: u.current
            }), ()=>a.deck?.finalize();
        }, []), bk(()=>{
            A1(a);
            const { viewStateUpdateRequested: L, interactionStateUpdateRequested: Z } = a;
            L && p(L), Z && _(Z);
        }), Q.useImperativeHandle(e, ()=>Mk(a), []);
        const v = a.deck && a.deck.isInitialized ? a.deck.getViewports() : void 0, { ContextProvider: S, width: E = "100%", height: M = "100%", id: B, style: H } = n, { containerStyle: O, canvasStyle: U } = Q.useMemo(()=>Ck({
                width: E,
                height: M,
                style: H
            }), [
            E,
            M,
            H
        ]);
        if (!a.viewStateUpdateRequested && a.lastRenderedViewports === v || a.version !== t) {
            a.lastRenderedViewports = v, a.version = t;
            const L = Ek({
                children: h.children,
                deck: a.deck,
                ContextProvider: S
            }), Z = Q.createElement("canvas", {
                key: "canvas",
                id: B || "deckgl-overlay",
                ref: u,
                style: U
            });
            a.control = Q.createElement("div", {
                id: `${B || "deckgl"}-wrapper`,
                ref: l,
                style: O
            }, [
                Z,
                L
            ]);
        }
        return d = !1, a.control;
    }
    const Nk = Q.forwardRef(Ik), fv = `uniform scatterplotUniforms {
  float radiusScale;
  float radiusMinPixels;
  float radiusMaxPixels;
  float lineWidthScale;
  float lineWidthMinPixels;
  float lineWidthMaxPixels;
  float stroked;
  float filled;
  bool antialiasing;
  bool billboard;
  highp int radiusUnits;
  highp int lineWidthUnits;
} scatterplot;
`, Pk = {
        name: "scatterplot",
        vs: fv,
        fs: fv,
        source: "",
        uniformTypes: {
            radiusScale: "f32",
            radiusMinPixels: "f32",
            radiusMaxPixels: "f32",
            lineWidthScale: "f32",
            lineWidthMinPixels: "f32",
            lineWidthMaxPixels: "f32",
            stroked: "f32",
            filled: "f32",
            antialiasing: "f32",
            billboard: "f32",
            radiusUnits: "i32",
            lineWidthUnits: "i32"
        }
    }, Dk = `#version 300 es
#define SHADER_NAME scatterplot-layer-vertex-shader
in vec3 positions;
in vec3 instancePositions;
in vec3 instancePositions64Low;
in float instanceRadius;
in float instanceLineWidths;
in vec4 instanceFillColors;
in vec4 instanceLineColors;
in vec3 instancePickingColors;
out vec4 vFillColor;
out vec4 vLineColor;
out vec2 unitPosition;
out float innerUnitRadius;
out float outerRadiusPixels;
void main(void) {
geometry.worldPosition = instancePositions;
outerRadiusPixels = clamp(
project_size_to_pixel(scatterplot.radiusScale * instanceRadius, scatterplot.radiusUnits),
scatterplot.radiusMinPixels, scatterplot.radiusMaxPixels
);
float lineWidthPixels = clamp(
project_size_to_pixel(scatterplot.lineWidthScale * instanceLineWidths, scatterplot.lineWidthUnits),
scatterplot.lineWidthMinPixels, scatterplot.lineWidthMaxPixels
);
outerRadiusPixels += scatterplot.stroked * lineWidthPixels / 2.0;
float edgePadding = scatterplot.antialiasing ? (outerRadiusPixels + SMOOTH_EDGE_RADIUS) / outerRadiusPixels : 1.0;
unitPosition = edgePadding * positions.xy;
geometry.uv = unitPosition;
geometry.pickingColor = instancePickingColors;
innerUnitRadius = 1.0 - scatterplot.stroked * lineWidthPixels / outerRadiusPixels;
if (scatterplot.billboard) {
gl_Position = project_position_to_clipspace(instancePositions, instancePositions64Low, vec3(0.0), geometry.position);
DECKGL_FILTER_GL_POSITION(gl_Position, geometry);
vec3 offset = edgePadding * positions * outerRadiusPixels;
DECKGL_FILTER_SIZE(offset, geometry);
gl_Position.xy += project_pixel_size_to_clipspace(offset.xy);
} else {
vec3 offset = edgePadding * positions * project_pixel_size(outerRadiusPixels);
DECKGL_FILTER_SIZE(offset, geometry);
gl_Position = project_position_to_clipspace(instancePositions, instancePositions64Low, offset, geometry.position);
DECKGL_FILTER_GL_POSITION(gl_Position, geometry);
}
vFillColor = vec4(instanceFillColors.rgb, instanceFillColors.a * layer.opacity);
DECKGL_FILTER_COLOR(vFillColor, geometry);
vLineColor = vec4(instanceLineColors.rgb, instanceLineColors.a * layer.opacity);
DECKGL_FILTER_COLOR(vLineColor, geometry);
}
`, kk = `#version 300 es
#define SHADER_NAME scatterplot-layer-fragment-shader
precision highp float;
in vec4 vFillColor;
in vec4 vLineColor;
in vec2 unitPosition;
in float innerUnitRadius;
in float outerRadiusPixels;
out vec4 fragColor;
void main(void) {
geometry.uv = unitPosition;
float distToCenter = length(unitPosition) * outerRadiusPixels;
float inCircle = scatterplot.antialiasing ?
smoothedge(distToCenter, outerRadiusPixels) :
step(distToCenter, outerRadiusPixels);
if (inCircle == 0.0) {
discard;
}
if (scatterplot.stroked > 0.5) {
float isLine = scatterplot.antialiasing ?
smoothedge(innerUnitRadius * outerRadiusPixels, distToCenter) :
step(innerUnitRadius * outerRadiusPixels, distToCenter);
if (scatterplot.filled > 0.5) {
fragColor = mix(vFillColor, vLineColor, isLine);
} else {
if (isLine == 0.0) {
discard;
}
fragColor = vec4(vLineColor.rgb, vLineColor.a * isLine);
}
} else if (scatterplot.filled < 0.5) {
discard;
} else {
fragColor = vFillColor;
}
fragColor.a *= inCircle;
DECKGL_FILTER_COLOR(fragColor, geometry);
}
`, Uk = `// TODO(ibgreen): Hack for Layer uniforms (move to new "color" module?)

struct LayerUniforms {
  opacity: f32,
};

var<private> layer: LayerUniforms = LayerUniforms(1.0);
// @group(0) @binding(1) var<uniform> layer: LayerUniforms;

// Main shaders

struct ScatterplotUniforms {
  radiusScale: f32,
  radiusMinPixels: f32,
  radiusMaxPixels: f32,
  lineWidthScale: f32,
  lineWidthMinPixels: f32,
  lineWidthMaxPixels: f32,
  stroked: f32,
  filled: i32,
  antialiasing: i32,
  billboard: i32,
  radiusUnits: i32,
  lineWidthUnits: i32,
};

struct ConstantAttributeUniforms {
 instancePositions: vec3<f32>,
 instancePositions64Low: vec3<f32>,
 instanceRadius: f32,
 instanceLineWidths: f32,
 instanceFillColors: vec4<f32>,
 instanceLineColors: vec4<f32>,
 instancePickingColors: vec3<f32>,

 instancePositionsConstant: i32,
 instancePositions64LowConstant: i32,
 instanceRadiusConstant: i32,
 instanceLineWidthsConstant: i32,
 instanceFillColorsConstant: i32,
 instanceLineColorsConstant: i32,
 instancePickingColorsConstant: i32
};

@group(0) @binding(2) var<uniform> scatterplot: ScatterplotUniforms;

struct ConstantAttributes {
  instancePositions: vec3<f32>,
  instancePositions64Low: vec3<f32>,
  instanceRadius: f32,
  instanceLineWidths: f32,
  instanceFillColors: vec4<f32>,
  instanceLineColors: vec4<f32>,
  instancePickingColors: vec3<f32>
};

const constants = ConstantAttributes(
  vec3<f32>(0.0),
  vec3<f32>(0.0),
  0.0,
  0.0,
  vec4<f32>(0.0, 0.0, 0.0, 1.0),
  vec4<f32>(0.0, 0.0, 0.0, 1.0),
  vec3<f32>(0.0)
);

struct Attributes {
  @builtin(instance_index) instanceIndex : u32,
  @builtin(vertex_index) vertexIndex : u32,
  @location(0) positions: vec3<f32>,
  @location(1) instancePositions: vec3<f32>,
  @location(2) instancePositions64Low: vec3<f32>,
  @location(3) instanceRadius: f32,
  @location(4) instanceLineWidths: f32,
  @location(5) instanceFillColors: vec4<f32>,
  @location(6) instanceLineColors: vec4<f32>,
  @location(7) instancePickingColors: vec3<f32>
};

struct Varyings {
  @builtin(position) position: vec4<f32>,
  @location(0) vFillColor: vec4<f32>,
  @location(1) vLineColor: vec4<f32>,
  @location(2) unitPosition: vec2<f32>,
  @location(3) innerUnitRadius: f32,
  @location(4) outerRadiusPixels: f32,
};

@vertex
fn vertexMain(attributes: Attributes) -> Varyings {
  var varyings: Varyings;

  // Draw an inline geometry constant array clip space triangle to verify that rendering works.
  // var positions = array<vec2<f32>, 3>(vec2(0.0, 0.5), vec2(-0.5, -0.5), vec2(0.5, -0.5));
  // if (attributes.instanceIndex == 0) {
  //   varyings.position = vec4<f32>(positions[attributes.vertexIndex], 0.0, 1.0);
  //   return varyings;
  // }

  // var geometry: Geometry;
  // geometry.worldPosition = instancePositions;

  // Multiply out radius and clamp to limits
  varyings.outerRadiusPixels = clamp(
    project_unit_size_to_pixel(scatterplot.radiusScale * attributes.instanceRadius, scatterplot.radiusUnits),
    scatterplot.radiusMinPixels, scatterplot.radiusMaxPixels
  );

  // Multiply out line width and clamp to limits
  let lineWidthPixels = clamp(
    project_unit_size_to_pixel(scatterplot.lineWidthScale * attributes.instanceLineWidths, scatterplot.lineWidthUnits),
    scatterplot.lineWidthMinPixels, scatterplot.lineWidthMaxPixels
  );

  // outer radius needs to offset by half stroke width
  varyings.outerRadiusPixels += scatterplot.stroked * lineWidthPixels / 2.0;
  // Expand geometry to accommodate edge smoothing
  let edgePadding = select(
    (varyings.outerRadiusPixels + SMOOTH_EDGE_RADIUS) / varyings.outerRadiusPixels,
    1.0,
    scatterplot.antialiasing != 0
  );

  // position on the containing square in [-1, 1] space
  varyings.unitPosition = edgePadding * attributes.positions.xy;
  geometry.uv = varyings.unitPosition;
  geometry.pickingColor = attributes.instancePickingColors;

  varyings.innerUnitRadius = 1.0 - scatterplot.stroked * lineWidthPixels / varyings.outerRadiusPixels;

  if (scatterplot.billboard != 0) {
    varyings.position = project_position_to_clipspace(attributes.instancePositions, attributes.instancePositions64Low, vec3<f32>(0.0)); // TODO , geometry.position);
    // DECKGL_FILTER_GL_POSITION(varyings.position, geometry);
    let offset = attributes.positions; // * edgePadding * varyings.outerRadiusPixels;
    // DECKGL_FILTER_SIZE(offset, geometry);
    let clipPixels = project_pixel_size_to_clipspace(offset.xy);
    varyings.position.x = clipPixels.x;
    varyings.position.y = clipPixels.y;
  } else {
    let offset = edgePadding * attributes.positions * project_pixel_size_float(varyings.outerRadiusPixels);
    // DECKGL_FILTER_SIZE(offset, geometry);
    varyings.position = project_position_to_clipspace(attributes.instancePositions, attributes.instancePositions64Low, offset); // TODO , geometry.position);
    // DECKGL_FILTER_GL_POSITION(varyings.position, geometry);
  }

  // Apply opacity to instance color, or return instance picking color
  varyings.vFillColor = vec4<f32>(attributes.instanceFillColors.rgb, attributes.instanceFillColors.a * layer.opacity);
  // DECKGL_FILTER_COLOR(varyings.vFillColor, geometry);
  varyings.vLineColor = vec4<f32>(attributes.instanceLineColors.rgb, attributes.instanceLineColors.a * layer.opacity);
  // DECKGL_FILTER_COLOR(varyings.vLineColor, geometry);

  return varyings;
}

@fragment
fn fragmentMain(varyings: Varyings) -> @location(0) vec4<f32> {
  // var geometry: Geometry;
  // geometry.uv = unitPosition;

  let distToCenter = length(varyings.unitPosition) * varyings.outerRadiusPixels;
  let inCircle = select(
    smoothedge(distToCenter, varyings.outerRadiusPixels),
    step(distToCenter, varyings.outerRadiusPixels),
    scatterplot.antialiasing != 0
  );

  if (inCircle == 0.0) {
    // discard;
  }

  var fragColor: vec4<f32>;

  if (scatterplot.stroked != 0) {
    let isLine = select(
      smoothedge(varyings.innerUnitRadius * varyings.outerRadiusPixels, distToCenter),
      step(varyings.innerUnitRadius * varyings.outerRadiusPixels, distToCenter),
      scatterplot.antialiasing != 0
    );

    if (scatterplot.filled != 0) {
      fragColor = mix(varyings.vFillColor, varyings.vLineColor, isLine);
    } else {
      if (isLine == 0.0) {
        // discard;
      }
      fragColor = vec4<f32>(varyings.vLineColor.rgb, varyings.vLineColor.a * isLine);
    }
  } else if (scatterplot.filled == 0) {
    // discard;
  } else {
    fragColor = varyings.vFillColor;
  }

  fragColor.a *= inCircle;
  // DECKGL_FILTER_COLOR(fragColor, geometry);

  return fragColor;
  // return vec4<f32>(0, 0, 1, 1);
}
`, hv = [
        0,
        0,
        0,
        255
    ], Bk = {
        radiusUnits: "meters",
        radiusScale: {
            type: "number",
            min: 0,
            value: 1
        },
        radiusMinPixels: {
            type: "number",
            min: 0,
            value: 0
        },
        radiusMaxPixels: {
            type: "number",
            min: 0,
            value: Number.MAX_SAFE_INTEGER
        },
        lineWidthUnits: "meters",
        lineWidthScale: {
            type: "number",
            min: 0,
            value: 1
        },
        lineWidthMinPixels: {
            type: "number",
            min: 0,
            value: 0
        },
        lineWidthMaxPixels: {
            type: "number",
            min: 0,
            value: Number.MAX_SAFE_INTEGER
        },
        stroked: !1,
        filled: !0,
        billboard: !1,
        antialiasing: !0,
        getPosition: {
            type: "accessor",
            value: (n)=>n.position
        },
        getRadius: {
            type: "accessor",
            value: 1
        },
        getFillColor: {
            type: "accessor",
            value: hv
        },
        getLineColor: {
            type: "accessor",
            value: hv
        },
        getLineWidth: {
            type: "accessor",
            value: 1
        },
        strokeWidth: {
            deprecatedFor: "getLineWidth"
        },
        outline: {
            deprecatedFor: "stroked"
        },
        getColor: {
            deprecatedFor: [
                "getFillColor",
                "getLineColor"
            ]
        }
    };
    class Xg extends Br {
        getShaders() {
            return super.getShaders({
                vs: Dk,
                fs: kk,
                source: Uk,
                modules: [
                    Po,
                    kT,
                    Pk
                ]
            });
        }
        initializeState() {
            this.getAttributeManager().addInstanced({
                instancePositions: {
                    size: 3,
                    type: "float64",
                    fp64: this.use64bitPositions(),
                    transition: !0,
                    accessor: "getPosition"
                },
                instanceRadius: {
                    size: 1,
                    transition: !0,
                    accessor: "getRadius",
                    defaultValue: 1
                },
                instanceFillColors: {
                    size: this.props.colorFormat.length,
                    transition: !0,
                    type: "unorm8",
                    accessor: "getFillColor",
                    defaultValue: [
                        0,
                        0,
                        0,
                        255
                    ]
                },
                instanceLineColors: {
                    size: this.props.colorFormat.length,
                    transition: !0,
                    type: "unorm8",
                    accessor: "getLineColor",
                    defaultValue: [
                        0,
                        0,
                        0,
                        255
                    ]
                },
                instanceLineWidths: {
                    size: 1,
                    transition: !0,
                    accessor: "getLineWidth",
                    defaultValue: 1
                }
            });
        }
        updateState(e) {
            super.updateState(e), e.changeFlags.extensionsChanged && (this.state.model?.destroy(), this.state.model = this._getModel(), this.getAttributeManager().invalidateAll());
        }
        draw({ uniforms: e }) {
            const { radiusUnits: t, radiusScale: i, radiusMinPixels: r, radiusMaxPixels: a, stroked: l, filled: u, billboard: h, antialiasing: d, lineWidthUnits: p, lineWidthScale: _, lineWidthMinPixels: y, lineWidthMaxPixels: v } = this.props, S = {
                stroked: l,
                filled: u,
                billboard: h,
                antialiasing: d,
                radiusUnits: Gi[t],
                radiusScale: i,
                radiusMinPixels: r,
                radiusMaxPixels: a,
                lineWidthUnits: Gi[p],
                lineWidthScale: _,
                lineWidthMinPixels: y,
                lineWidthMaxPixels: v
            }, E = this.state.model;
            E.shaderInputs.setProps({
                scatterplot: S
            }), E.draw(this.context.renderPass);
        }
        _getModel() {
            const e = [
                -1,
                -1,
                0,
                1,
                -1,
                0,
                -1,
                1,
                0,
                1,
                1,
                0
            ];
            return new $n(this.context.device, {
                ...this.getShaders(),
                id: this.props.id,
                bufferLayout: this.getAttributeManager().getBufferLayouts(),
                geometry: new WT({
                    topology: "triangle-strip",
                    attributes: {
                        positions: {
                            size: 3,
                            value: new Float32Array(e)
                        }
                    }
                }),
                isInstanced: !0
            });
        }
    }
    Xg.defaultProps = Bk;
    Xg.layerName = "ScatterplotLayer";
    const Lk = {
        COUNTER_CLOCKWISE: -1
    };
    function Fk(n, e, t = {}) {
        return zk(n, t) !== e ? (Hk(n, t), !0) : !1;
    }
    function zk(n, e = {}) {
        return Math.sign(Vk(n, e));
    }
    const dv = {
        x: 0,
        y: 1,
        z: 2
    };
    function Vk(n, e = {}) {
        const { start: t = 0, end: i = n.length, plane: r = "xy" } = e, a = e.size || 2;
        let l = 0;
        const u = dv[r[0]], h = dv[r[1]];
        for(let d = t, p = i - a; d < i; d += a)l += (n[d + u] - n[p + u]) * (n[d + h] + n[p + h]), p = d;
        return l / 2;
    }
    function Hk(n, e) {
        const { start: t = 0, end: i = n.length, size: r = 2 } = e, a = (i - t) / r, l = Math.floor(a / 2);
        for(let u = 0; u < l; ++u){
            const h = t + u * r, d = t + (a - 1 - u) * r;
            for(let p = 0; p < r; ++p){
                const _ = n[h + p];
                n[h + p] = n[d + p], n[d + p] = _;
            }
        }
    }
    class jk extends WT {
        constructor(e){
            const { indices: t, attributes: i } = Wk(e);
            super({
                ...e,
                indices: t,
                attributes: i
            });
        }
    }
    function Wk(n) {
        const { radius: e, height: t = 1, nradial: i = 10 } = n;
        let { vertices: r } = n;
        r && (Fe.assert(r.length >= i), r = r.flatMap((v)=>[
                v[0],
                v[1]
            ]), Fk(r, Lk.COUNTER_CLOCKWISE));
        const a = t > 0, l = i + 1, u = a ? l * 3 + 1 : i, h = Math.PI * 2 / i, d = new Uint16Array(a ? i * 3 * 2 : 0), p = new Float32Array(u * 3), _ = new Float32Array(u * 3);
        let y = 0;
        if (a) {
            for(let v = 0; v < l; v++){
                const S = v * h, E = v % i, M = Math.sin(S), B = Math.cos(S);
                for(let H = 0; H < 2; H++)p[y + 0] = r ? r[E * 2] : B * e, p[y + 1] = r ? r[E * 2 + 1] : M * e, p[y + 2] = (1 / 2 - H) * t, _[y + 0] = r ? r[E * 2] : B, _[y + 1] = r ? r[E * 2 + 1] : M, y += 3;
            }
            p[y + 0] = p[y - 3], p[y + 1] = p[y - 2], p[y + 2] = p[y - 1], y += 3;
        }
        for(let v = a ? 0 : 1; v < l; v++){
            const S = Math.floor(v / 2) * Math.sign(.5 - v % 2), E = S * h, M = (S + i) % i, B = Math.sin(E), H = Math.cos(E);
            p[y + 0] = r ? r[M * 2] : H * e, p[y + 1] = r ? r[M * 2 + 1] : B * e, p[y + 2] = t / 2, _[y + 2] = 1, y += 3;
        }
        if (a) {
            let v = 0;
            for(let S = 0; S < i; S++)d[v++] = S * 2 + 0, d[v++] = S * 2 + 2, d[v++] = S * 2 + 0, d[v++] = S * 2 + 1, d[v++] = S * 2 + 1, d[v++] = S * 2 + 3;
        }
        return {
            indices: d,
            attributes: {
                POSITION: {
                    size: 3,
                    value: p
                },
                NORMAL: {
                    size: 3,
                    value: _
                }
            }
        };
    }
    const gv = `uniform columnUniforms {
  float radius;
  float angle;
  vec2 offset;
  bool extruded;
  bool stroked;
  bool isStroke;
  float coverage;
  float elevationScale;
  float edgeDistance;
  float widthScale;
  float widthMinPixels;
  float widthMaxPixels;
  highp int radiusUnits;
  highp int widthUnits;
} column;
`, $k = {
        name: "column",
        vs: gv,
        fs: gv,
        uniformTypes: {
            radius: "f32",
            angle: "f32",
            offset: "vec2<f32>",
            extruded: "f32",
            stroked: "f32",
            isStroke: "f32",
            coverage: "f32",
            elevationScale: "f32",
            edgeDistance: "f32",
            widthScale: "f32",
            widthMinPixels: "f32",
            widthMaxPixels: "f32",
            radiusUnits: "i32",
            widthUnits: "i32"
        }
    }, Xk = `#version 300 es
#define SHADER_NAME column-layer-vertex-shader
in vec3 positions;
in vec3 normals;
in vec3 instancePositions;
in float instanceElevations;
in vec3 instancePositions64Low;
in vec4 instanceFillColors;
in vec4 instanceLineColors;
in float instanceStrokeWidths;
in vec3 instancePickingColors;
out vec4 vColor;
#ifdef FLAT_SHADING
out vec3 cameraPosition;
out vec4 position_commonspace;
#endif
void main(void) {
geometry.worldPosition = instancePositions;
vec4 color = column.isStroke ? instanceLineColors : instanceFillColors;
mat2 rotationMatrix = mat2(cos(column.angle), sin(column.angle), -sin(column.angle), cos(column.angle));
float elevation = 0.0;
float strokeOffsetRatio = 1.0;
if (column.extruded) {
elevation = instanceElevations * (positions.z + 1.0) / 2.0 * column.elevationScale;
} else if (column.stroked) {
float widthPixels = clamp(
project_size_to_pixel(instanceStrokeWidths * column.widthScale, column.widthUnits),
column.widthMinPixels, column.widthMaxPixels) / 2.0;
float halfOffset = project_pixel_size(widthPixels) / project_size(column.edgeDistance * column.coverage * column.radius);
if (column.isStroke) {
strokeOffsetRatio -= sign(positions.z) * halfOffset;
} else {
strokeOffsetRatio -= halfOffset;
}
}
float shouldRender = float(color.a > 0.0 && instanceElevations >= 0.0);
float dotRadius = column.radius * column.coverage * shouldRender;
geometry.pickingColor = instancePickingColors;
vec3 centroidPosition = vec3(instancePositions.xy, instancePositions.z + elevation);
vec3 centroidPosition64Low = instancePositions64Low;
vec2 offset = (rotationMatrix * positions.xy * strokeOffsetRatio + column.offset) * dotRadius;
if (column.radiusUnits == UNIT_METERS) {
offset = project_size(offset);
}
vec3 pos = vec3(offset, 0.);
DECKGL_FILTER_SIZE(pos, geometry);
gl_Position = project_position_to_clipspace(centroidPosition, centroidPosition64Low, pos, geometry.position);
geometry.normal = project_normal(vec3(rotationMatrix * normals.xy, normals.z));
DECKGL_FILTER_GL_POSITION(gl_Position, geometry);
if (column.extruded && !column.isStroke) {
#ifdef FLAT_SHADING
cameraPosition = project.cameraPosition;
position_commonspace = geometry.position;
vColor = vec4(color.rgb, color.a * layer.opacity);
#else
vec3 lightColor = lighting_getLightColor(color.rgb, project.cameraPosition, geometry.position.xyz, geometry.normal);
vColor = vec4(lightColor, color.a * layer.opacity);
#endif
} else {
vColor = vec4(color.rgb, color.a * layer.opacity);
}
DECKGL_FILTER_COLOR(vColor, geometry);
}
`, Yk = `#version 300 es
#define SHADER_NAME column-layer-fragment-shader
precision highp float;
out vec4 fragColor;
in vec4 vColor;
#ifdef FLAT_SHADING
in vec3 cameraPosition;
in vec4 position_commonspace;
#endif
void main(void) {
fragColor = vColor;
geometry.uv = vec2(0.);
#ifdef FLAT_SHADING
if (column.extruded && !column.isStroke && !bool(picking.isActive)) {
vec3 normal = normalize(cross(dFdx(position_commonspace.xyz), dFdy(position_commonspace.xyz)));
fragColor.rgb = lighting_getLightColor(vColor.rgb, cameraPosition, position_commonspace.xyz, normal);
}
#endif
DECKGL_FILTER_COLOR(fragColor, geometry);
}
`, Hc = [
        0,
        0,
        0,
        255
    ], qk = {
        diskResolution: {
            type: "number",
            min: 4,
            value: 20
        },
        vertices: null,
        radius: {
            type: "number",
            min: 0,
            value: 1e3
        },
        angle: {
            type: "number",
            value: 0
        },
        offset: {
            type: "array",
            value: [
                0,
                0
            ]
        },
        coverage: {
            type: "number",
            min: 0,
            max: 1,
            value: 1
        },
        elevationScale: {
            type: "number",
            min: 0,
            value: 1
        },
        radiusUnits: "meters",
        lineWidthUnits: "meters",
        lineWidthScale: 1,
        lineWidthMinPixels: 0,
        lineWidthMaxPixels: Number.MAX_SAFE_INTEGER,
        extruded: !0,
        wireframe: !1,
        filled: !0,
        stroked: !1,
        flatShading: !1,
        getPosition: {
            type: "accessor",
            value: (n)=>n.position
        },
        getFillColor: {
            type: "accessor",
            value: Hc
        },
        getLineColor: {
            type: "accessor",
            value: Hc
        },
        getLineWidth: {
            type: "accessor",
            value: 1
        },
        getElevation: {
            type: "accessor",
            value: 1e3
        },
        material: !0,
        getColor: {
            deprecatedFor: [
                "getFillColor",
                "getLineColor"
            ]
        }
    };
    class Yg extends Br {
        getShaders() {
            const e = {}, { flatShading: t } = this.props;
            return t && (e.FLAT_SHADING = 1), super.getShaders({
                vs: Xk,
                fs: Yk,
                defines: e,
                modules: [
                    Po,
                    t ? yT : _T,
                    kT,
                    $k
                ]
            });
        }
        initializeState() {
            this.getAttributeManager().addInstanced({
                instancePositions: {
                    size: 3,
                    type: "float64",
                    fp64: this.use64bitPositions(),
                    transition: !0,
                    accessor: "getPosition"
                },
                instanceElevations: {
                    size: 1,
                    transition: !0,
                    accessor: "getElevation"
                },
                instanceFillColors: {
                    size: this.props.colorFormat.length,
                    type: "unorm8",
                    transition: !0,
                    accessor: "getFillColor",
                    defaultValue: Hc
                },
                instanceLineColors: {
                    size: this.props.colorFormat.length,
                    type: "unorm8",
                    transition: !0,
                    accessor: "getLineColor",
                    defaultValue: Hc
                },
                instanceStrokeWidths: {
                    size: 1,
                    accessor: "getLineWidth",
                    transition: !0
                }
            });
        }
        updateState(e) {
            super.updateState(e);
            const { props: t, oldProps: i, changeFlags: r } = e, a = r.extensionsChanged || t.flatShading !== i.flatShading;
            a && (this.state.models?.forEach((u)=>u.destroy()), this.setState(this._getModels()), this.getAttributeManager().invalidateAll());
            const l = this.getNumInstances();
            this.state.fillModel.setInstanceCount(l), this.state.wireframeModel.setInstanceCount(l), (a || t.diskResolution !== i.diskResolution || t.vertices !== i.vertices || (t.extruded || t.stroked) !== (i.extruded || i.stroked)) && this._updateGeometry(t);
        }
        getGeometry(e, t, i) {
            const r = new jk({
                radius: 1,
                height: i ? 2 : 0,
                vertices: t,
                nradial: e
            });
            let a = 0;
            if (t) for(let l = 0; l < e; l++){
                const u = t[l], h = Math.sqrt(u[0] * u[0] + u[1] * u[1]);
                a += h / e;
            }
            else a = 1;
            return this.setState({
                edgeDistance: Math.cos(Math.PI / e) * a
            }), r;
        }
        _getModels() {
            const e = this.getShaders(), t = this.getAttributeManager().getBufferLayouts(), i = new $n(this.context.device, {
                ...e,
                id: `${this.props.id}-fill`,
                bufferLayout: t,
                isInstanced: !0
            }), r = new $n(this.context.device, {
                ...e,
                id: `${this.props.id}-wireframe`,
                bufferLayout: t,
                isInstanced: !0
            });
            return {
                fillModel: i,
                wireframeModel: r,
                models: [
                    r,
                    i
                ]
            };
        }
        _updateGeometry({ diskResolution: e, vertices: t, extruded: i, stroked: r }) {
            const a = this.getGeometry(e, t, i || r);
            this.setState({
                fillVertexCount: a.attributes.POSITION.value.length / 3
            });
            const l = this.state.fillModel, u = this.state.wireframeModel;
            l.setGeometry(a), l.setTopology("triangle-strip"), l.setIndexBuffer(null), u.setGeometry(a), u.setTopology("line-list");
        }
        draw({ uniforms: e }) {
            const { lineWidthUnits: t, lineWidthScale: i, lineWidthMinPixels: r, lineWidthMaxPixels: a, radiusUnits: l, elevationScale: u, extruded: h, filled: d, stroked: p, wireframe: _, offset: y, coverage: v, radius: S, angle: E } = this.props, M = this.state.fillModel, B = this.state.wireframeModel, { fillVertexCount: H, edgeDistance: O } = this.state, U = {
                radius: S,
                angle: E / 180 * Math.PI,
                offset: y,
                extruded: h,
                stroked: p,
                coverage: v,
                elevationScale: u,
                edgeDistance: O,
                radiusUnits: Gi[l],
                widthUnits: Gi[t],
                widthScale: i,
                widthMinPixels: r,
                widthMaxPixels: a
            };
            h && _ && (B.shaderInputs.setProps({
                column: {
                    ...U,
                    isStroke: !0
                }
            }), B.draw(this.context.renderPass)), d && (M.setVertexCount(H), M.shaderInputs.setProps({
                column: {
                    ...U,
                    isStroke: !1
                }
            }), M.draw(this.context.renderPass)), !h && p && (M.setVertexCount(H * 2 / 3), M.shaderInputs.setProps({
                column: {
                    ...U,
                    isStroke: !0
                }
            }), M.draw(this.context.renderPass));
        }
    }
    Yg.layerName = "ColumnLayer";
    Yg.defaultProps = qk;
    function Kk({ pointCount: n, getBinId: e }) {
        const t = new Map;
        for(let i = 0; i < n; i++){
            const r = e(i);
            if (r === null) continue;
            let a = t.get(String(r));
            a ? a.points.push(i) : (a = {
                id: r,
                index: t.size,
                points: [
                    i
                ]
            }, t.set(String(r), a));
        }
        return Array.from(t.values());
    }
    function Zk({ bins: n, dimensions: e, target: t }) {
        const i = n.length * e;
        (!t || t.length < i) && (t = new Float32Array(i));
        for(let r = 0; r < n.length; r++){
            const { id: a } = n[r];
            Array.isArray(a) ? t.set(a, r * e) : t[r] = a;
        }
        return t;
    }
    const Qk = (n)=>n.length, w1 = (n, e)=>{
        let t = 0;
        for (const i of n)t += e(i);
        return t;
    }, Gk = (n, e)=>n.length === 0 ? NaN : w1(n, e) / n.length, Jk = (n, e)=>{
        let t = 1 / 0;
        for (const i of n){
            const r = e(i);
            r < t && (t = r);
        }
        return t;
    }, e6 = (n, e)=>{
        let t = -1 / 0;
        for (const i of n){
            const r = e(i);
            r > t && (t = r);
        }
        return t;
    }, t6 = {
        COUNT: Qk,
        SUM: w1,
        MEAN: Gk,
        MIN: Jk,
        MAX: e6
    };
    function n6({ bins: n, getValue: e, operation: t, target: i }) {
        (!i || i.length < n.length) && (i = new Float32Array(n.length));
        let r = 1 / 0, a = -1 / 0;
        for(let l = 0; l < n.length; l++){
            const { points: u } = n[l];
            i[l] = t(u, e), i[l] < r && (r = i[l]), i[l] > a && (a = i[l]);
        }
        return {
            value: i,
            domain: [
                r,
                a
            ]
        };
    }
    function pv(n, e, t) {
        const i = {};
        for (const a of n.sources || []){
            const l = e[a];
            if (l) i[a] = i6(l);
            else throw new Error(`Cannot find attribute ${a}`);
        }
        const r = {};
        return (a)=>{
            for(const l in i)r[l] = i[l](a);
            return n.getValue(r, a, t);
        };
    }
    function i6(n) {
        const e = n.value, { offset: t = 0, stride: i, size: r } = n.getAccessor(), a = e.BYTES_PER_ELEMENT, l = t / a, u = i ? i / a : r;
        if (r === 1) return n.isConstant ? ()=>e[0] : (d)=>{
            const p = l + u * d;
            return e[p];
        };
        let h;
        return n.isConstant ? (h = Array.from(e), ()=>h) : (h = new Array(r), (d)=>{
            const p = l + u * d;
            for(let _ = 0; _ < r; _++)h[_] = e[p + _];
            return h;
        });
    }
    class r6 {
        constructor(e){
            this.bins = [], this.binIds = null, this.results = [], this.dimensions = e.dimensions, this.channelCount = e.getValue.length, this.props = {
                ...e,
                binOptions: {},
                pointCount: 0,
                operations: [],
                customOperations: [],
                attributes: {}
            }, this.needsUpdate = !0, this.setProps(e);
        }
        destroy() {}
        get binCount() {
            return this.bins.length;
        }
        setProps(e) {
            const t = this.props;
            if (e.binOptions && (Ht(e.binOptions, t.binOptions, 2) || this.setNeedsUpdate()), e.operations) for(let i = 0; i < this.channelCount; i++)e.operations[i] !== t.operations[i] && this.setNeedsUpdate(i);
            if (e.customOperations) for(let i = 0; i < this.channelCount; i++)!!e.customOperations[i] != !!t.customOperations[i] && this.setNeedsUpdate(i);
            e.pointCount !== void 0 && e.pointCount !== t.pointCount && this.setNeedsUpdate(), e.attributes && (e.attributes = {
                ...t.attributes,
                ...e.attributes
            }), Object.assign(this.props, e);
        }
        setNeedsUpdate(e) {
            e === void 0 ? this.needsUpdate = !0 : this.needsUpdate !== !0 && (this.needsUpdate = this.needsUpdate || [], this.needsUpdate[e] = !0);
        }
        update() {
            if (this.needsUpdate === !0) {
                this.bins = Kk({
                    pointCount: this.props.pointCount,
                    getBinId: pv(this.props.getBin, this.props.attributes, this.props.binOptions)
                });
                const e = Zk({
                    bins: this.bins,
                    dimensions: this.dimensions,
                    target: this.binIds?.value
                });
                this.binIds = {
                    value: e,
                    type: "float32",
                    size: this.dimensions
                };
            }
            for(let e = 0; e < this.channelCount; e++)if (this.needsUpdate === !0 || this.needsUpdate[e]) {
                const t = this.props.customOperations[e] || t6[this.props.operations[e]], { value: i, domain: r } = n6({
                    bins: this.bins,
                    getValue: pv(this.props.getValue[e], this.props.attributes, void 0),
                    operation: t,
                    target: this.results[e]?.value
                });
                this.results[e] = {
                    value: i,
                    domain: r,
                    type: "float32",
                    size: 1
                }, this.props.onUpdate?.({
                    channel: e
                });
            }
            this.needsUpdate = !1;
        }
        preDraw() {}
        getBins() {
            return this.binIds;
        }
        getResult(e) {
            return this.results[e];
        }
        getResultDomain(e) {
            return this.results[e]?.domain ?? [
                1 / 0,
                -1 / 0
            ];
        }
        getBin(e) {
            const t = this.bins[e];
            if (!t) return null;
            const i = new Array(this.channelCount);
            for(let r = 0; r < i.length; r++){
                const a = this.results[r];
                i[r] = a?.value[e];
            }
            return {
                id: t.id,
                value: i,
                count: t.points.length,
                pointIndices: t.points
            };
        }
    }
    function E1(n, e, t) {
        return n.createFramebuffer({
            width: e,
            height: t,
            colorAttachments: [
                n.createTexture({
                    width: e,
                    height: t,
                    format: "rgba32float",
                    mipmaps: !1,
                    sampler: {
                        minFilter: "nearest",
                        magFilter: "nearest"
                    }
                })
            ]
        });
    }
    const s6 = `uniform binSorterUniforms {
  ivec4 binIdRange;
  ivec2 targetSize;
} binSorter;
`, a6 = {
        name: "binSorter",
        vs: s6,
        uniformTypes: {
            binIdRange: "vec4<i32>",
            targetSize: "vec2<i32>"
        }
    }, R1 = [
        1,
        2,
        4,
        8
    ], o6 = 3e38, l6 = {
        SUM: 0,
        MEAN: 0,
        MIN: 0,
        MAX: 0,
        COUNT: 0
    }, yc = 1024;
    class c6 {
        constructor(e, t){
            this.binsFBO = null, this.device = e, this.model = f6(e, t);
        }
        get texture() {
            return this.binsFBO ? this.binsFBO.colorAttachments[0].texture : null;
        }
        destroy() {
            this.model.destroy(), this.binsFBO?.colorAttachments[0].texture.destroy(), this.binsFBO?.destroy();
        }
        getBinValues(e) {
            if (!this.binsFBO) return null;
            const t = e % yc, i = Math.floor(e / yc), r = this.device.readPixelsToArrayWebGL(this.binsFBO, {
                sourceX: t,
                sourceY: i,
                sourceWidth: 1,
                sourceHeight: 1
            }).buffer;
            return new Float32Array(r);
        }
        setDimensions(e, t) {
            const i = yc, r = Math.ceil(e / i);
            this.binsFBO ? this.binsFBO.height < r && this.binsFBO.resize({
                width: i,
                height: r
            }) : this.binsFBO = E1(this.device, i, r);
            const a = {
                binIdRange: [
                    t[0][0],
                    t[0][1],
                    t[1]?.[0] || 0,
                    t[1]?.[1] || 0
                ],
                targetSize: [
                    this.binsFBO.width,
                    this.binsFBO.height
                ]
            };
            this.model.shaderInputs.setProps({
                binSorter: a
            });
        }
        setModelProps(e) {
            const t = this.model;
            e.attributes && t.setAttributes(e.attributes), e.constantAttributes && t.setConstantAttributes(e.constantAttributes), e.vertexCount !== void 0 && t.setVertexCount(e.vertexCount), e.shaderModuleProps && t.shaderInputs.setProps(e.shaderModuleProps);
        }
        update(e) {
            if (!this.binsFBO) return;
            const t = u6(e);
            this._updateBins("SUM", t.SUM + t.MEAN), this._updateBins("MIN", t.MIN), this._updateBins("MAX", t.MAX);
        }
        _updateBins(e, t) {
            if (t === 0) return;
            t |= R1[3];
            const i = this.model, r = this.binsFBO, a = e === "MAX" ? -3e38 : e === "MIN" ? o6 : 0, l = this.device.beginRenderPass({
                id: `gpu-aggregation-${e}`,
                framebuffer: r,
                parameters: {
                    viewport: [
                        0,
                        0,
                        r.width,
                        r.height
                    ],
                    colorMask: t
                },
                clearColor: [
                    a,
                    a,
                    a,
                    0
                ],
                clearDepth: !1,
                clearStencil: !1
            });
            i.setParameters({
                blend: !0,
                blendColorSrcFactor: "one",
                blendColorDstFactor: "one",
                blendAlphaSrcFactor: "one",
                blendAlphaDstFactor: "one",
                blendColorOperation: e === "MAX" ? "max" : e === "MIN" ? "min" : "add",
                blendAlphaOperation: "add"
            }), i.draw(l), l.end();
        }
    }
    function u6(n) {
        const e = {
            ...l6
        };
        for(let t = 0; t < n.length; t++){
            const i = n[t];
            i && (e[i] += R1[t]);
        }
        return e;
    }
    function f6(n, e) {
        let t = e.vs;
        e.dimensions === 2 && (t += `
void getBin(out int binId) {
  ivec2 binId2;
  getBin(binId2);
  if (binId2.x < binSorter.binIdRange.x || binId2.x >= binSorter.binIdRange.y) {
    binId = -1;
  } else {
    binId = (binId2.y - binSorter.binIdRange.z) * (binSorter.binIdRange.y - binSorter.binIdRange.x) + binId2.x;
  }
}
`);
        const i = `#version 300 es
#define SHADER_NAME gpu-aggregation-sort-bins-vertex

${t}

out vec3 v_Value;

void main() {
  int binIndex;
  getBin(binIndex);
  binIndex = binIndex - binSorter.binIdRange.x;
  if (binIndex < 0) {
    gl_Position = vec4(0.);
    return;
  }
  int row = binIndex / binSorter.targetSize.x;
  int col = binIndex - row * binSorter.targetSize.x;
  vec2 position = (vec2(col, row) + 0.5) / vec2(binSorter.targetSize) * 2.0 - 1.0;
  gl_Position = vec4(position, 0.0, 1.0);
  gl_PointSize = 1.0;

#if NUM_CHANNELS == 3
  getValue(v_Value);
#elif NUM_CHANNELS == 2
  getValue(v_Value.xy);
#else
  getValue(v_Value.x);
#endif
}
`, r = `#version 300 es
#define SHADER_NAME gpu-aggregation-sort-bins-fragment

precision highp float;

in vec3 v_Value;
out vec4 fragColor;

void main() {
  fragColor.xyz = v_Value;

  #ifdef MODULE_GEOMETRY
  geometry.uv = vec2(0.);
  DECKGL_FILTER_COLOR(fragColor, geometry);
  #endif

  fragColor.w = 1.0;
}
`;
        return new $n(n, {
            bufferLayout: e.bufferLayout,
            modules: [
                ...e.modules || [],
                a6
            ],
            defines: {
                ...e.defines,
                NON_INSTANCED_MODEL: 1,
                NUM_CHANNELS: e.channelCount
            },
            isInstanced: !1,
            vs: i,
            fs: r,
            topology: "point-list",
            disableWarnings: !0
        });
    }
    const h6 = `uniform aggregatorTransformUniforms {
  ivec4 binIdRange;
  bvec3 isCount;
  bvec3 isMean;
  float naN;
} aggregatorTransform;
`, d6 = {
        name: "aggregatorTransform",
        vs: h6,
        uniformTypes: {
            binIdRange: "vec4<i32>",
            isCount: "vec3<f32>",
            isMean: "vec3<f32>"
        }
    };
    class g6 {
        constructor(e, t){
            this.binBuffer = null, this.valueBuffer = null, this._domains = null, this.device = e, this.channelCount = t.channelCount, this.transform = p6(e, t), this.domainFBO = E1(e, 2, 1);
        }
        destroy() {
            this.transform.destroy(), this.binBuffer?.destroy(), this.valueBuffer?.destroy(), this.domainFBO.colorAttachments[0].texture.destroy(), this.domainFBO.destroy();
        }
        get domains() {
            if (!this._domains) {
                const e = this.device.readPixelsToArrayWebGL(this.domainFBO).buffer, t = new Float32Array(e);
                this._domains = [
                    [
                        -t[4],
                        t[0]
                    ],
                    [
                        -t[5],
                        t[1]
                    ],
                    [
                        -t[6],
                        t[2]
                    ]
                ].slice(0, this.channelCount);
            }
            return this._domains;
        }
        setDimensions(e, t) {
            const { model: i, transformFeedback: r } = this.transform;
            i.setVertexCount(e);
            const a = {
                binIdRange: [
                    t[0][0],
                    t[0][1],
                    t[1]?.[0] || 0,
                    t[1]?.[1] || 0
                ]
            };
            i.shaderInputs.setProps({
                aggregatorTransform: a
            });
            const l = e * t.length * 4;
            (!this.binBuffer || this.binBuffer.byteLength < l) && (this.binBuffer?.destroy(), this.binBuffer = this.device.createBuffer({
                byteLength: l
            }), r.setBuffer("binIds", this.binBuffer));
            const u = e * this.channelCount * 4;
            (!this.valueBuffer || this.valueBuffer.byteLength < u) && (this.valueBuffer?.destroy(), this.valueBuffer = this.device.createBuffer({
                byteLength: u
            }), r.setBuffer("values", this.valueBuffer));
        }
        update(e, t) {
            if (!e) return;
            const i = this.transform, r = this.domainFBO, a = [
                0,
                1,
                2
            ].map((h)=>t[h] === "COUNT" ? 1 : 0), l = [
                0,
                1,
                2
            ].map((h)=>t[h] === "MEAN" ? 1 : 0), u = {
                isCount: a,
                isMean: l,
                bins: e
            };
            i.model.shaderInputs.setProps({
                aggregatorTransform: u
            }), i.run({
                id: "gpu-aggregation-domain",
                framebuffer: r,
                parameters: {
                    viewport: [
                        0,
                        0,
                        2,
                        1
                    ]
                },
                clearColor: [
                    -3e38,
                    -3e38,
                    -3e38,
                    0
                ],
                clearDepth: !1,
                clearStencil: !1
            }), this._domains = null;
        }
    }
    function p6(n, e) {
        const t = `#version 300 es
#define SHADER_NAME gpu-aggregation-domain-vertex

uniform sampler2D bins;

#if NUM_DIMS == 1
out float binIds;
#else
out vec2 binIds;
#endif

#if NUM_CHANNELS == 1
flat out float values;
#elif NUM_CHANNELS == 2
flat out vec2 values;
#else
flat out vec3 values;
#endif

const float NAN = intBitsToFloat(-1);

void main() {
  int row = gl_VertexID / SAMPLER_WIDTH;
  int col = gl_VertexID - row * SAMPLER_WIDTH;
  vec4 weights = texelFetch(bins, ivec2(col, row), 0);
  vec3 value3 = mix(
    mix(weights.rgb, vec3(weights.a), aggregatorTransform.isCount),
    weights.rgb / max(weights.a, 1.0),
    aggregatorTransform.isMean
  );
  if (weights.a == 0.0) {
    value3 = vec3(NAN);
  }

#if NUM_DIMS == 1
  binIds = float(gl_VertexID + aggregatorTransform.binIdRange.x);
#else
  int y = gl_VertexID / (aggregatorTransform.binIdRange.y - aggregatorTransform.binIdRange.x);
  int x = gl_VertexID - y * (aggregatorTransform.binIdRange.y - aggregatorTransform.binIdRange.x);
  binIds.y = float(y + aggregatorTransform.binIdRange.z);
  binIds.x = float(x + aggregatorTransform.binIdRange.x);
#endif

#if NUM_CHANNELS == 3
  values = value3;
#elif NUM_CHANNELS == 2
  values = value3.xy;
#else
  values = value3.x;
#endif

  gl_Position = vec4(0., 0., 0., 1.);
  // This model renders into a 2x1 texture to obtain min and max simultaneously.
  // See comments in fragment shader
  gl_PointSize = 2.0;
}
`, i = `#version 300 es
#define SHADER_NAME gpu-aggregation-domain-fragment

precision highp float;

#if NUM_CHANNELS == 1
flat in float values;
#elif NUM_CHANNELS == 2
flat in vec2 values;
#else
flat in vec3 values;
#endif

out vec4 fragColor;

void main() {
  vec3 value3;
#if NUM_CHANNELS == 3
  value3 = values;
#elif NUM_CHANNELS == 2
  value3.xy = values;
#else
  value3.x = values;
#endif
  if (isnan(value3.x)) discard;
  // This shader renders into a 2x1 texture with blending=max
  // The left pixel yields the max value of each channel
  // The right pixel yields the min value of each channel
  if (gl_FragCoord.x < 1.0) {
    fragColor = vec4(value3, 1.0);
  } else {
    fragColor = vec4(-value3, 1.0);
  }
}
`;
        return new Ir(n, {
            vs: t,
            fs: i,
            topology: "point-list",
            modules: [
                d6
            ],
            parameters: {
                blend: !0,
                blendColorSrcFactor: "one",
                blendColorDstFactor: "one",
                blendColorOperation: "max",
                blendAlphaSrcFactor: "one",
                blendAlphaDstFactor: "one",
                blendAlphaOperation: "max"
            },
            defines: {
                NUM_DIMS: e.dimensions,
                NUM_CHANNELS: e.channelCount,
                SAMPLER_WIDTH: yc
            },
            varyings: [
                "binIds",
                "values"
            ],
            disableWarnings: !0
        });
    }
    class mv {
        static isSupported(e) {
            return e.features.has("float32-renderable-webgl") && e.features.has("texture-blend-float-webgl");
        }
        constructor(e, t){
            this.binCount = 0, this.binIds = null, this.results = [], this.device = e, this.dimensions = t.dimensions, this.channelCount = t.channelCount, this.props = {
                ...t,
                pointCount: 0,
                binIdRange: [
                    [
                        0,
                        0
                    ]
                ],
                operations: [],
                attributes: {},
                binOptions: {}
            }, this.needsUpdate = new Array(this.channelCount).fill(!0), this.binSorter = new c6(e, t), this.aggregationTransform = new g6(e, t), this.setProps(t);
        }
        getBins() {
            const e = this.aggregationTransform.binBuffer;
            return e ? (this.binIds?.buffer !== e && (this.binIds = {
                buffer: e,
                type: "float32",
                size: this.dimensions
            }), this.binIds) : null;
        }
        getResult(e) {
            const t = this.aggregationTransform.valueBuffer;
            return !t || e >= this.channelCount ? null : (this.results[e]?.buffer !== t && (this.results[e] = {
                buffer: t,
                type: "float32",
                size: 1,
                stride: this.channelCount * 4,
                offset: e * 4
            }), this.results[e]);
        }
        getResultDomain(e) {
            return this.aggregationTransform.domains[e];
        }
        getBin(e) {
            if (e < 0 || e >= this.binCount) return null;
            const { binIdRange: t } = this.props;
            let i;
            if (this.dimensions === 1) i = [
                e + t[0][0]
            ];
            else {
                const [[u, h], [d]] = t, p = h - u;
                i = [
                    e % p + u,
                    Math.floor(e / p) + d
                ];
            }
            const r = this.binSorter.getBinValues(e);
            if (!r) return null;
            const a = r[3], l = [];
            for(let u = 0; u < this.channelCount; u++){
                const h = this.props.operations[u];
                h === "COUNT" ? l[u] = a : a === 0 ? l[u] = NaN : l[u] = h === "MEAN" ? r[u] / a : r[u];
            }
            return {
                id: i,
                value: l,
                count: a
            };
        }
        destroy() {
            this.binSorter.destroy(), this.aggregationTransform.destroy();
        }
        setProps(e) {
            const t = this.props;
            if ("binIdRange" in e && !Ht(e.binIdRange, t.binIdRange, 2)) {
                const i = e.binIdRange;
                if (Fe.assert(i.length === this.dimensions), this.dimensions === 1) {
                    const [[r, a]] = i;
                    this.binCount = a - r;
                } else {
                    const [[r, a], [l, u]] = i;
                    this.binCount = (a - r) * (u - l);
                }
                this.binSorter.setDimensions(this.binCount, i), this.aggregationTransform.setDimensions(this.binCount, i), this.setNeedsUpdate();
            }
            if (e.operations) for(let i = 0; i < this.channelCount; i++)e.operations[i] !== t.operations[i] && this.setNeedsUpdate(i);
            if (e.pointCount !== void 0 && e.pointCount !== t.pointCount && (this.binSorter.setModelProps({
                vertexCount: e.pointCount
            }), this.setNeedsUpdate()), e.binOptions && (Ht(e.binOptions, t.binOptions, 2) || this.setNeedsUpdate(), this.binSorter.model.shaderInputs.setProps({
                binOptions: e.binOptions
            })), e.attributes) {
                const i = {}, r = {};
                for (const a of Object.values(e.attributes))for (const [l, u] of Object.entries(a.getValue()))ArrayBuffer.isView(u) ? r[l] = u : u && (i[l] = u);
                this.binSorter.setModelProps({
                    attributes: i,
                    constantAttributes: r
                });
            }
            e.shaderModuleProps && this.binSorter.setModelProps({
                shaderModuleProps: e.shaderModuleProps
            }), Object.assign(this.props, e);
        }
        setNeedsUpdate(e) {
            e === void 0 ? this.needsUpdate.fill(!0) : this.needsUpdate[e] = !0;
        }
        update() {}
        preDraw() {
            if (!this.needsUpdate.some(Boolean)) return;
            const { operations: e } = this.props, t = this.needsUpdate.map((i, r)=>i ? e[r] : null);
            this.binSorter.update(t), this.aggregationTransform.update(this.binSorter.texture, e);
            for(let i = 0; i < this.channelCount; i++)this.needsUpdate[i] && (this.needsUpdate[i] = !1, this.props.onUpdate?.({
                channel: i
            }));
        }
    }
    let C1 = class extends $g {
        get isDrawable() {
            return !0;
        }
        initializeState() {
            this.getAttributeManager().remove([
                "instancePickingColors"
            ]);
        }
        updateState(e) {
            super.updateState(e);
            const t = this.getAggregatorType();
            if (e.changeFlags.extensionsChanged || this.state.aggregatorType !== t) {
                this.state.aggregator?.destroy();
                const i = this.createAggregator(t);
                return i.setProps({
                    attributes: this.getAttributeManager()?.attributes
                }), this.setState({
                    aggregator: i,
                    aggregatorType: t
                }), !0;
            }
            return !1;
        }
        finalizeState(e) {
            super.finalizeState(e), this.state.aggregator.destroy();
        }
        updateAttributes(e) {
            const { aggregator: t } = this.state;
            t.setProps({
                attributes: e
            });
            for(const i in e)this.onAttributeChange(i);
            t.update();
        }
        draw({ shaderModuleProps: e }) {
            const { aggregator: t } = this.state;
            t.setProps({
                shaderModuleProps: e
            }), t.preDraw();
        }
        _getAttributeManager() {
            return new au(this.context.device, {
                id: this.props.id,
                stats: this.context.stats
            });
        }
    };
    C1.layerName = "AggregationLayer";
    const M1 = [
        [
            255,
            255,
            178
        ],
        [
            254,
            217,
            118
        ],
        [
            254,
            178,
            76
        ],
        [
            253,
            141,
            60
        ],
        [
            240,
            59,
            32
        ],
        [
            189,
            0,
            38
        ]
    ];
    function O1(n, e = !1, t = Float32Array) {
        let i;
        if (Number.isFinite(n[0])) i = new t(n);
        else {
            i = new t(n.length * 4);
            let r = 0;
            for(let a = 0; a < n.length; a++){
                const l = n[a];
                i[r++] = l[0], i[r++] = l[1], i[r++] = l[2], i[r++] = Number.isFinite(l[3]) ? l[3] : 255;
            }
        }
        if (e) for(let r = 0; r < i.length; r++)i[r] /= 255;
        return i;
    }
    const jc = {
        linear: "linear",
        quantile: "nearest",
        quantize: "nearest",
        ordinal: "nearest"
    };
    function m6(n, e) {
        n.setSampler({
            minFilter: jc[e],
            magFilter: jc[e]
        });
    }
    function _6(n, e, t = "linear") {
        const i = O1(e, !1, Uint8Array);
        return n.createTexture({
            format: "rgba8unorm",
            mipmaps: !1,
            sampler: {
                minFilter: jc[t],
                magFilter: jc[t],
                addressModeU: "clamp-to-edge",
                addressModeV: "clamp-to-edge"
            },
            data: i,
            width: i.length / 4,
            height: 1
        });
    }
    class _v {
        constructor(e, t){
            this.props = {
                scaleType: "linear",
                lowerPercentile: 0,
                upperPercentile: 100
            }, this.domain = null, this.cutoff = null, this.input = e, this.inputLength = t, this.attribute = e;
        }
        getScalePercentile() {
            if (!this._percentile) {
                const e = yv(this.input, this.inputLength);
                this._percentile = b6(e);
            }
            return this._percentile;
        }
        getScaleOrdinal() {
            if (!this._ordinal) {
                const e = yv(this.input, this.inputLength);
                this._ordinal = y6(e);
            }
            return this._ordinal;
        }
        getCutoff({ scaleType: e, lowerPercentile: t, upperPercentile: i }) {
            if (e === "quantile") return [
                t,
                i - 1
            ];
            if (t > 0 || i < 100) {
                const { domain: r } = this.getScalePercentile();
                let a = r[Math.floor(t) - 1] ?? -1 / 0, l = r[Math.floor(i) - 1] ?? 1 / 0;
                if (e === "ordinal") {
                    const { domain: u } = this.getScaleOrdinal();
                    a = u.findIndex((h)=>h >= a), l = u.findIndex((h)=>h > l) - 1, l === -2 && (l = u.length - 1);
                }
                return [
                    a,
                    l
                ];
            }
            return null;
        }
        update(e) {
            const t = this.props;
            if (e.scaleType !== t.scaleType) switch(e.scaleType){
                case "quantile":
                    {
                        const { attribute: i } = this.getScalePercentile();
                        this.attribute = i, this.domain = [
                            0,
                            99
                        ];
                        break;
                    }
                case "ordinal":
                    {
                        const { attribute: i, domain: r } = this.getScaleOrdinal();
                        this.attribute = i, this.domain = [
                            0,
                            r.length - 1
                        ];
                        break;
                    }
                default:
                    this.attribute = this.input, this.domain = null;
            }
            return (e.scaleType !== t.scaleType || e.lowerPercentile !== t.lowerPercentile || e.upperPercentile !== t.upperPercentile) && (this.cutoff = this.getCutoff(e)), this.props = e, this;
        }
    }
    function y6(n) {
        const e = new Set;
        for (const r of n)Number.isFinite(r) && e.add(r);
        const t = Array.from(e).sort(), i = new Map;
        for(let r = 0; r < t.length; r++)i.set(t[r], r);
        return {
            attribute: {
                value: n.map((r)=>Number.isFinite(r) ? i.get(r) : NaN),
                type: "float32",
                size: 1
            },
            domain: t
        };
    }
    function b6(n, e = 100) {
        const t = Array.from(n).filter(Number.isFinite).sort(v6);
        let i = 0;
        const r = Math.max(1, e), a = new Array(r - 1);
        for(; ++i < r;)a[i - 1] = T6(t, i / r);
        return {
            attribute: {
                value: n.map((l)=>Number.isFinite(l) ? x6(a, l) : NaN),
                type: "float32",
                size: 1
            },
            domain: a
        };
    }
    function yv(n, e) {
        const t = (n.stride ?? 4) / 4, i = (n.offset ?? 0) / 4;
        let r = n.value;
        if (!r) {
            const l = n.buffer?.readSyncWebGL(0, t * 4 * e);
            l && (r = new Float32Array(l.buffer), n.value = r);
        }
        if (t === 1) return r.subarray(0, e);
        const a = new Float32Array(e);
        for(let l = 0; l < e; l++)a[l] = r[l * t + i];
        return a;
    }
    function v6(n, e) {
        return n - e;
    }
    function T6(n, e) {
        const t = n.length;
        if (e <= 0 || t < 2) return n[0];
        if (e >= 1) return n[t - 1];
        const i = (t - 1) * e, r = Math.floor(i), a = n[r], l = n[r + 1];
        return a + (l - a) * (i - r);
    }
    function x6(n, e) {
        let t = 0, i = n.length;
        for(; t < i;){
            const r = t + i >>> 1;
            n[r] > e ? i = r : t = r + 1;
        }
        return t;
    }
    function S6({ dataBounds: n, getBinId: e, padding: t = 0 }) {
        const i = [
            n[0],
            n[1],
            [
                n[0][0],
                n[1][1]
            ],
            [
                n[1][0],
                n[0][1]
            ]
        ].map((h)=>e(h)), r = Math.min(...i.map((h)=>h[0])) - t, a = Math.min(...i.map((h)=>h[1])) - t, l = Math.max(...i.map((h)=>h[0])) + t + 1, u = Math.max(...i.map((h)=>h[1])) + t + 1;
        return [
            [
                r,
                l
            ],
            [
                a,
                u
            ]
        ];
    }
    const I1 = Math.PI / 3, cu = 2 * Math.sin(I1), uu = 1.5, A6 = Array.from({
        length: 6
    }, (n, e)=>{
        const t = e * I1;
        return [
            Math.sin(t),
            -Math.cos(t)
        ];
    });
    function ud([n, e], t) {
        let i = Math.round(e = e / t / uu), r = Math.round(n = n / t / cu - (i & 1) / 2);
        const a = e - i;
        if (Math.abs(a) * 3 > 1) {
            const l = n - r, u = r + (n < r ? -1 : 1) / 2, h = i + (e < i ? -1 : 1), d = n - u, p = e - h;
            l * l + a * a > d * d + p * p && (r = u + (i & 1 ? 1 : -1) / 2, i = h);
        }
        return [
            r,
            i
        ];
    }
    const w6 = `
const vec2 DIST = vec2(${cu}, ${uu});

ivec2 pointToHexbin(vec2 p, float radius) {
  p /= radius * DIST;
  float pj = round(p.y);
  float pjm2 = mod(pj, 2.0);
  p.x -= pjm2 * 0.5;
  float pi = round(p.x);
  vec2 d1 = p - vec2(pi, pj);

  if (abs(d1.y) * 3. > 1.) {
    vec2 v2 = step(0.0, d1) - 0.5;
    v2.y *= 2.0;
    vec2 d2 = d1 - v2;
    if (dot(d1, d1) > dot(d2, d2)) {
      pi += v2.x + pjm2 - 0.5;
      pj += v2.y;
    }
  }
  return ivec2(pi, pj);
}
`;
    function bv([n, e], t) {
        return [
            (n + (e & 1) / 2) * t * cu,
            e * t * uu
        ];
    }
    const E6 = `
const vec2 DIST = vec2(${cu}, ${uu});

vec2 hexbinCentroid(vec2 binId, float radius) {
  binId.x += fract(binId.y * 0.5);
  return binId * DIST * radius;
}
`, R6 = `#version 300 es
#define SHADER_NAME hexagon-cell-layer-vertex-shader
in vec3 positions;
in vec3 normals;
in vec2 instancePositions;
in float instanceElevationValues;
in float instanceColorValues;
in vec3 instancePickingColors;
uniform sampler2D colorRange;
out vec4 vColor;
${E6}
float interp(float value, vec2 domain, vec2 range) {
float r = min(max((value - domain.x) / (domain.y - domain.x), 0.), 1.);
return mix(range.x, range.y, r);
}
vec4 interp(float value, vec2 domain, sampler2D range) {
float r = (value - domain.x) / (domain.y - domain.x);
return texture(range, vec2(r, 0.5));
}
void main(void) {
geometry.pickingColor = instancePickingColors;
if (isnan(instanceColorValues) ||
instanceColorValues < hexagon.colorDomain.z ||
instanceColorValues > hexagon.colorDomain.w ||
instanceElevationValues < hexagon.elevationDomain.z ||
instanceElevationValues > hexagon.elevationDomain.w
) {
gl_Position = vec4(0.);
return;
}
vec2 commonPosition = hexbinCentroid(instancePositions, column.radius) + (hexagon.originCommon - project.commonOrigin.xy);
commonPosition += positions.xy * column.radius * column.coverage;
geometry.position = vec4(commonPosition, 0.0, 1.0);
geometry.normal = project_normal(normals);
float elevation = 0.0;
if (column.extruded) {
elevation = interp(instanceElevationValues, hexagon.elevationDomain.xy, hexagon.elevationRange);
elevation = project_size(elevation);
geometry.position.z = (positions.z + 1.0) / 2.0 * elevation;
}
gl_Position = project_common_position_to_clipspace(geometry.position);
DECKGL_FILTER_GL_POSITION(gl_Position, geometry);
vColor = interp(instanceColorValues, hexagon.colorDomain.xy, colorRange);
vColor.a *= layer.opacity;
if (column.extruded) {
vColor.rgb = lighting_getLightColor(vColor.rgb, project.cameraPosition, geometry.position.xyz, geometry.normal);
}
DECKGL_FILTER_COLOR(vColor, geometry);
}
`, C6 = `uniform hexagonUniforms {
  vec4 colorDomain;
  vec4 elevationDomain;
  vec2 elevationRange;
  vec2 originCommon;
} hexagon;
`, M6 = {
        name: "hexagon",
        vs: C6,
        uniformTypes: {
            colorDomain: "vec4<f32>",
            elevationDomain: "vec4<f32>",
            elevationRange: "vec2<f32>",
            originCommon: "vec2<f32>"
        }
    };
    class N1 extends Yg {
        getShaders() {
            const e = super.getShaders();
            return e.modules.push(M6), {
                ...e,
                vs: R6
            };
        }
        initializeState() {
            super.initializeState();
            const e = this.getAttributeManager();
            e.remove([
                "instanceElevations",
                "instanceFillColors",
                "instanceLineColors",
                "instanceStrokeWidths"
            ]), e.addInstanced({
                instancePositions: {
                    size: 2,
                    type: "float32",
                    accessor: "getBin"
                },
                instanceColorValues: {
                    size: 1,
                    type: "float32",
                    accessor: "getColorValue"
                },
                instanceElevationValues: {
                    size: 1,
                    type: "float32",
                    accessor: "getElevationValue"
                }
            });
        }
        updateState(e) {
            super.updateState(e);
            const { props: t, oldProps: i } = e, r = this.state.fillModel;
            if (i.colorRange !== t.colorRange) {
                this.state.colorTexture?.destroy(), this.state.colorTexture = _6(this.context.device, t.colorRange, t.colorScaleType);
                const a = {
                    colorRange: this.state.colorTexture
                };
                r.shaderInputs.setProps({
                    hexagon: a
                });
            } else i.colorScaleType !== t.colorScaleType && m6(this.state.colorTexture, t.colorScaleType);
        }
        finalizeState(e) {
            super.finalizeState(e), this.state.colorTexture?.destroy();
        }
        draw({ uniforms: e }) {
            const { radius: t, hexOriginCommon: i, elevationRange: r, elevationScale: a, extruded: l, coverage: u, colorDomain: h, elevationDomain: d } = this.props, p = this.props.colorCutoff || [
                -1 / 0,
                1 / 0
            ], _ = this.props.elevationCutoff || [
                -1 / 0,
                1 / 0
            ], y = this.state.fillModel;
            y.vertexArray.indexBuffer && y.setIndexBuffer(null), y.setVertexCount(this.state.fillVertexCount);
            const v = {
                colorDomain: [
                    Math.max(h[0], p[0]),
                    Math.min(h[1], p[1]),
                    Math.max(h[0] - 1, p[0]),
                    Math.min(h[1] + 1, p[1])
                ],
                elevationDomain: [
                    Math.max(d[0], _[0]),
                    Math.min(d[1], _[1]),
                    Math.max(d[0] - 1, _[0]),
                    Math.min(d[1] + 1, _[1])
                ],
                elevationRange: [
                    r[0] * a,
                    r[1] * a
                ],
                originCommon: i
            };
            y.shaderInputs.setProps({
                column: {
                    extruded: l,
                    coverage: u,
                    radius: t
                },
                hexagon: v
            }), y.draw(this.context.renderPass);
        }
    }
    N1.layerName = "HexagonCellLayer";
    const O6 = `uniform binOptionsUniforms {
  vec2 hexOriginCommon;
  float radiusCommon;
} binOptions;
`, I6 = {
        name: "binOptions",
        vs: O6,
        uniformTypes: {
            hexOriginCommon: "vec2<f32>",
            radiusCommon: "f32"
        }
    };
    function vv() {}
    const N6 = {
        gpuAggregation: !0,
        colorDomain: null,
        colorRange: M1,
        getColorValue: {
            type: "accessor",
            value: null
        },
        getColorWeight: {
            type: "accessor",
            value: 1
        },
        colorAggregation: "SUM",
        lowerPercentile: {
            type: "number",
            min: 0,
            max: 100,
            value: 0
        },
        upperPercentile: {
            type: "number",
            min: 0,
            max: 100,
            value: 100
        },
        colorScaleType: "quantize",
        onSetColorDomain: vv,
        elevationDomain: null,
        elevationRange: [
            0,
            1e3
        ],
        getElevationValue: {
            type: "accessor",
            value: null
        },
        getElevationWeight: {
            type: "accessor",
            value: 1
        },
        elevationAggregation: "SUM",
        elevationScale: {
            type: "number",
            min: 0,
            value: 1
        },
        elevationLowerPercentile: {
            type: "number",
            min: 0,
            max: 100,
            value: 0
        },
        elevationUpperPercentile: {
            type: "number",
            min: 0,
            max: 100,
            value: 100
        },
        elevationScaleType: "linear",
        onSetElevationDomain: vv,
        radius: {
            type: "number",
            min: 1,
            value: 1e3
        },
        coverage: {
            type: "number",
            min: 0,
            max: 1,
            value: 1
        },
        getPosition: {
            type: "accessor",
            value: (n)=>n.position
        },
        hexagonAggregator: {
            type: "function",
            optional: !0,
            value: null
        },
        extruded: !1,
        material: !0
    };
    class qg extends C1 {
        getAggregatorType() {
            const { gpuAggregation: e, hexagonAggregator: t, getColorValue: i, getElevationValue: r } = this.props;
            return e && (t || i || r) ? (Fe.warn("Features not supported by GPU aggregation, falling back to CPU")(), "cpu") : e && mv.isSupported(this.context.device) ? "gpu" : "cpu";
        }
        createAggregator(e) {
            if (e === "cpu") {
                const { hexagonAggregator: t, radius: i } = this.props;
                return new r6({
                    dimensions: 2,
                    getBin: {
                        sources: [
                            "positions"
                        ],
                        getValue: ({ positions: r }, a, l)=>{
                            if (t) return t(r, i);
                            const h = this.state.aggregatorViewport.projectPosition(r), { radiusCommon: d, hexOriginCommon: p } = l;
                            return ud([
                                h[0] - p[0],
                                h[1] - p[1]
                            ], d);
                        }
                    },
                    getValue: [
                        {
                            sources: [
                                "colorWeights"
                            ],
                            getValue: ({ colorWeights: r })=>r
                        },
                        {
                            sources: [
                                "elevationWeights"
                            ],
                            getValue: ({ elevationWeights: r })=>r
                        }
                    ]
                });
            }
            return new mv(this.context.device, {
                dimensions: 2,
                channelCount: 2,
                bufferLayout: this.getAttributeManager().getBufferLayouts({
                    isInstanced: !1
                }),
                ...super.getShaders({
                    modules: [
                        Po,
                        I6
                    ],
                    vs: `
  in vec3 positions;
  in vec3 positions64Low;
  in float colorWeights;
  in float elevationWeights;
  
  ${w6}

  void getBin(out ivec2 binId) {
    vec3 positionCommon = project_position(positions, positions64Low);
    binId = pointToHexbin(positionCommon.xy, binOptions.radiusCommon);
  }
  void getValue(out vec2 value) {
    value = vec2(colorWeights, elevationWeights);
  }
  `
                })
            });
        }
        initializeState() {
            super.initializeState(), this.getAttributeManager().add({
                positions: {
                    size: 3,
                    accessor: "getPosition",
                    type: "float64",
                    fp64: this.use64bitPositions()
                },
                colorWeights: {
                    size: 1,
                    accessor: "getColorWeight"
                },
                elevationWeights: {
                    size: 1,
                    accessor: "getElevationWeight"
                }
            });
        }
        updateState(e) {
            const t = super.updateState(e), { props: i, oldProps: r, changeFlags: a } = e, { aggregator: l } = this.state;
            if ((a.dataChanged || !this.state.dataAsArray) && (i.getColorValue || i.getElevationValue) && (this.state.dataAsArray = Array.from(f1(i.data).iterable)), t || a.dataChanged || i.radius !== r.radius || i.getColorValue !== r.getColorValue || i.getElevationValue !== r.getElevationValue || i.colorAggregation !== r.colorAggregation || i.elevationAggregation !== r.elevationAggregation) {
                this._updateBinOptions();
                const { radiusCommon: u, hexOriginCommon: h, binIdRange: d, dataAsArray: p } = this.state;
                if (l.setProps({
                    binIdRange: d,
                    pointCount: this.getNumInstances(),
                    operations: [
                        i.colorAggregation,
                        i.elevationAggregation
                    ],
                    binOptions: {
                        radiusCommon: u,
                        hexOriginCommon: h
                    },
                    onUpdate: this._onAggregationUpdate.bind(this)
                }), p) {
                    const { getColorValue: _, getElevationValue: y } = this.props;
                    l.setProps({
                        customOperations: [
                            _ && ((v)=>_(v.map((S)=>p[S]), {
                                    indices: v,
                                    data: i.data
                                })),
                            y && ((v)=>y(v.map((S)=>p[S]), {
                                    indices: v,
                                    data: i.data
                                }))
                        ]
                    });
                }
            }
            return a.updateTriggersChanged && a.updateTriggersChanged.getColorValue && l.setNeedsUpdate(0), a.updateTriggersChanged && a.updateTriggersChanged.getElevationValue && l.setNeedsUpdate(1), t;
        }
        _updateBinOptions() {
            const e = this.getBounds();
            let t = 1, i = [
                0,
                0
            ], r = [
                [
                    0,
                    1
                ],
                [
                    0,
                    1
                ]
            ], a = this.context.viewport;
            if (e && Number.isFinite(e[0][0])) {
                let l = [
                    (e[0][0] + e[1][0]) / 2,
                    (e[0][1] + e[1][1]) / 2
                ];
                const { radius: u } = this.props, { unitsPerMeter: h } = a.getDistanceScales(l);
                t = h[0] * u;
                const d = ud(a.projectFlat(l), t);
                l = a.unprojectFlat(bv(d, t));
                const p = a.constructor;
                a = a.isGeospatial ? new p({
                    longitude: l[0],
                    latitude: l[1],
                    zoom: 12
                }) : new ta({
                    position: [
                        l[0],
                        l[1],
                        0
                    ],
                    zoom: 12
                }), i = [
                    Math.fround(a.center[0]),
                    Math.fround(a.center[1])
                ], r = S6({
                    dataBounds: e,
                    getBinId: (_)=>{
                        const y = a.projectFlat(_);
                        return y[0] -= i[0], y[1] -= i[1], ud(y, t);
                    },
                    padding: 1
                });
            }
            this.setState({
                radiusCommon: t,
                hexOriginCommon: i,
                binIdRange: r,
                aggregatorViewport: a
            });
        }
        draw(e) {
            e.shaderModuleProps.project && (e.shaderModuleProps.project.viewport = this.state.aggregatorViewport), super.draw(e);
        }
        _onAggregationUpdate({ channel: e }) {
            const t = this.getCurrentLayer().props, { aggregator: i } = this.state;
            if (e === 0) {
                const r = i.getResult(0);
                this.setState({
                    colors: new _v(r, i.binCount)
                }), t.onSetColorDomain(i.getResultDomain(0));
            } else if (e === 1) {
                const r = i.getResult(1);
                this.setState({
                    elevations: new _v(r, i.binCount)
                }), t.onSetElevationDomain(i.getResultDomain(1));
            }
        }
        onAttributeChange(e) {
            const { aggregator: t } = this.state;
            switch(e){
                case "positions":
                    t.setNeedsUpdate(), this._updateBinOptions();
                    const { radiusCommon: i, hexOriginCommon: r, binIdRange: a } = this.state;
                    t.setProps({
                        binIdRange: a,
                        binOptions: {
                            radiusCommon: i,
                            hexOriginCommon: r
                        }
                    });
                    break;
                case "colorWeights":
                    t.setNeedsUpdate(0);
                    break;
                case "elevationWeights":
                    t.setNeedsUpdate(1);
                    break;
            }
        }
        renderLayers() {
            const { aggregator: e, radiusCommon: t, hexOriginCommon: i } = this.state, { elevationScale: r, colorRange: a, elevationRange: l, extruded: u, coverage: h, material: d, transitions: p, colorScaleType: _, lowerPercentile: y, upperPercentile: v, colorDomain: S, elevationScaleType: E, elevationLowerPercentile: M, elevationUpperPercentile: B, elevationDomain: H } = this.props, O = this.getSubLayerClass("cells", N1), U = e.getBins(), L = this.state.colors?.update({
                scaleType: _,
                lowerPercentile: y,
                upperPercentile: v
            }), Z = this.state.elevations?.update({
                scaleType: E,
                lowerPercentile: M,
                upperPercentile: B
            });
            return !L || !Z ? null : new O(this.getSubLayerProps({
                id: "cells"
            }), {
                data: {
                    length: e.binCount,
                    attributes: {
                        getBin: U,
                        getColorValue: L.attribute,
                        getElevationValue: Z.attribute
                    }
                },
                dataComparator: (se, ae)=>se.length === ae.length,
                updateTriggers: {
                    getBin: [
                        U
                    ],
                    getColorValue: [
                        L.attribute
                    ],
                    getElevationValue: [
                        Z.attribute
                    ]
                },
                diskResolution: 6,
                vertices: A6,
                radius: t,
                hexOriginCommon: i,
                elevationScale: r,
                colorRange: a,
                colorScaleType: _,
                elevationRange: l,
                extruded: u,
                coverage: h,
                material: d,
                colorDomain: L.domain || S || e.getResultDomain(0),
                elevationDomain: Z.domain || H || e.getResultDomain(1),
                colorCutoff: L.cutoff,
                elevationCutoff: Z.cutoff,
                transitions: p && {
                    getFillColor: p.getColorValue || p.getColorWeight,
                    getElevation: p.getElevationValue || p.getElevationWeight
                },
                extensions: []
            });
        }
        getPickingInfo(e) {
            const t = e.info, { index: i } = t;
            if (i >= 0) {
                const r = this.state.aggregator.getBin(i);
                let a;
                if (r) {
                    const l = bv(r.id, this.state.radiusCommon), u = this.context.viewport.unprojectFlat(l);
                    a = {
                        col: r.id[0],
                        row: r.id[1],
                        position: u,
                        colorValue: r.value[0],
                        elevationValue: r.value[1],
                        count: r.count
                    }, r.pointIndices && (a.pointIndices = r.pointIndices, a.points = Array.isArray(this.props.data) ? r.pointIndices.map((h)=>this.props.data[h]) : []);
                }
                t.object = a;
            }
            return t;
        }
    }
    qg.layerName = "HexagonLayer";
    qg.defaultProps = N6;
    function P6(n) {
        const e = n.map((u)=>u[0]), t = n.map((u)=>u[1]), i = Math.min.apply(null, e), r = Math.max.apply(null, e), a = Math.min.apply(null, t), l = Math.max.apply(null, t);
        return [
            i,
            a,
            r,
            l
        ];
    }
    function D6(n, e) {
        return e[0] >= n[0] && e[2] <= n[2] && e[1] >= n[1] && e[3] <= n[3];
    }
    const Tv = new Float32Array(12);
    function xv(n, e = 2) {
        let t = 0;
        for (const i of n)for(let r = 0; r < e; r++)Tv[t++] = i[r] || 0;
        return Tv;
    }
    function k6(n, e, t) {
        const [i, r, a, l] = n, u = a - i, h = l - r;
        let d = u, p = h;
        u / h < e / t ? d = e / t * h : p = t / e * u, d < e && (d = e, p = t);
        const _ = (a + i) / 2, y = (l + r) / 2;
        return [
            _ - d / 2,
            y - p / 2,
            _ + d / 2,
            y + p / 2
        ];
    }
    function U6(n, e) {
        const [t, i, r, a] = e;
        return [
            (n[0] - t) / (r - t),
            (n[1] - i) / (a - i)
        ];
    }
    const B6 = `#version 300 es
#define SHADER_NAME heatp-map-layer-vertex-shader
uniform sampler2D maxTexture;
in vec3 positions;
in vec2 texCoords;
out vec2 vTexCoords;
out float vIntensityMin;
out float vIntensityMax;
void main(void) {
gl_Position = project_position_to_clipspace(positions, vec3(0.0), vec3(0.0));
vTexCoords = texCoords;
vec4 maxTexture = texture(maxTexture, vec2(0.5));
float maxValue = triangle.aggregationMode < 0.5 ? maxTexture.r : maxTexture.g;
float minValue = maxValue * triangle.threshold;
if (triangle.colorDomain[1] > 0.) {
maxValue = triangle.colorDomain[1];
minValue = triangle.colorDomain[0];
}
vIntensityMax = triangle.intensity / maxValue;
vIntensityMin = triangle.intensity / minValue;
}
`, L6 = `#version 300 es
#define SHADER_NAME triangle-layer-fragment-shader
precision highp float;
uniform sampler2D weightsTexture;
uniform sampler2D colorTexture;
in vec2 vTexCoords;
in float vIntensityMin;
in float vIntensityMax;
out vec4 fragColor;
vec4 getLinearColor(float value) {
float factor = clamp(value * vIntensityMax, 0., 1.);
vec4 color = texture(colorTexture, vec2(factor, 0.5));
color.a *= min(value * vIntensityMin, 1.0);
return color;
}
void main(void) {
vec4 weights = texture(weightsTexture, vTexCoords);
float weight = weights.r;
if (triangle.aggregationMode > 0.5) {
weight /= max(1.0, weights.a);
}
if (weight <= 0.) {
discard;
}
vec4 linearColor = getLinearColor(weight);
linearColor.a *= layer.opacity;
fragColor = linearColor;
}
`, Sv = `uniform triangleUniforms {
  float aggregationMode;
  vec2 colorDomain;
  float intensity;
  float threshold;
} triangle;
`, F6 = {
        name: "triangle",
        vs: Sv,
        fs: Sv,
        uniformTypes: {
            aggregationMode: "f32",
            colorDomain: "vec2<f32>",
            intensity: "f32",
            threshold: "f32"
        }
    };
    class P1 extends Br {
        getShaders() {
            return super.getShaders({
                vs: B6,
                fs: L6,
                modules: [
                    Po,
                    F6
                ]
            });
        }
        initializeState({ device: e }) {
            this.setState({
                model: this._getModel(e)
            });
        }
        _getModel(e) {
            const { vertexCount: t, data: i } = this.props;
            return new $n(e, {
                ...this.getShaders(),
                id: this.props.id,
                attributes: i.attributes,
                bufferLayout: [
                    {
                        name: "positions",
                        format: "float32x3"
                    },
                    {
                        name: "texCoords",
                        format: "float32x2"
                    }
                ],
                topology: "triangle-strip",
                vertexCount: t
            });
        }
        draw() {
            const { model: e } = this.state, { aggregationMode: t, colorDomain: i, intensity: r, threshold: a, colorTexture: l, maxTexture: u, weightsTexture: h } = this.props, d = {
                aggregationMode: t,
                colorDomain: i,
                intensity: r,
                threshold: a,
                colorTexture: l,
                maxTexture: u,
                weightsTexture: h
            };
            e.shaderInputs.setProps({
                triangle: d
            }), e.draw(this.context.renderPass);
        }
    }
    P1.layerName = "TriangleLayer";
    function z6(n, e) {
        const t = {};
        for(const i in n)e.includes(i) || (t[i] = n[i]);
        return t;
    }
    class D1 extends $g {
        initializeAggregationLayer(e) {
            super.initializeState(this.context), this.setState({
                ignoreProps: z6(this.constructor._propTypes, e.data.props),
                dimensions: e
            });
        }
        updateState(e) {
            super.updateState(e);
            const { changeFlags: t } = e;
            if (t.extensionsChanged) {
                const i = this.getShaders({});
                i && i.defines && (i.defines.NON_INSTANCED_MODEL = 1), this.updateShaders(i);
            }
            this._updateAttributes();
        }
        updateAttributes(e) {
            this.setState({
                changedAttributes: e
            });
        }
        getAttributes() {
            return this.getAttributeManager().getAttributes();
        }
        getModuleSettings() {
            const { viewport: e, mousePosition: t, device: i } = this.context;
            return Object.assign(Object.create(this.props), {
                viewport: e,
                mousePosition: t,
                picking: {
                    isActive: 0
                },
                devicePixelRatio: i.canvasContext.cssToDeviceRatio()
            });
        }
        updateShaders(e) {}
        isAggregationDirty(e, t = {}) {
            const { props: i, oldProps: r, changeFlags: a } = e, { compareAll: l = !1, dimension: u } = t, { ignoreProps: h } = this.state, { props: d, accessors: p = [] } = u, { updateTriggersChanged: _ } = a;
            if (a.dataChanged) return !0;
            if (_) {
                if (_.all) return !0;
                for (const y of p)if (_[y]) return !0;
            }
            if (l) return a.extensionsChanged ? !0 : jg({
                oldProps: r,
                newProps: i,
                ignoreProps: h,
                propTypes: this.constructor._propTypes
            });
            for (const y of d)if (i[y] !== r[y]) return !0;
            return !1;
        }
        isAttributeChanged(e) {
            const { changedAttributes: t } = this.state;
            return e ? t && t[e] !== void 0 : !V6(t);
        }
        _getAttributeManager() {
            return new au(this.context.device, {
                id: this.props.id,
                stats: this.context.stats
            });
        }
    }
    D1.layerName = "AggregationLayer";
    function V6(n) {
        let e = !0;
        for(const t in n){
            e = !1;
            break;
        }
        return e;
    }
    const Av = `#version 300 es
in vec3 positions;
in vec3 positions64Low;
in float weights;
out vec4 weightsTexture;
void main()
{
weightsTexture = vec4(weights * weight.weightsScale, 0., 0., 1.);
float radiusTexels = project_pixel_size(weight.radiusPixels) * weight.textureWidth / (weight.commonBounds.z - weight.commonBounds.x);
gl_PointSize = radiusTexels * 2.;
vec3 commonPosition = project_position(positions, positions64Low);
gl_Position.xy = (commonPosition.xy - weight.commonBounds.xy) / (weight.commonBounds.zw - weight.commonBounds.xy) ;
gl_Position.xy = (gl_Position.xy * 2.) - (1.);
gl_Position.w = 1.0;
}
`, wv = `#version 300 es
in vec4 weightsTexture;
out vec4 fragColor;
float gaussianKDE(float u){
return pow(2.71828, -u*u/0.05555)/(1.77245385*0.166666);
}
void main()
{
float dist = length(gl_PointCoord - vec2(0.5, 0.5));
if (dist > 0.5) {
discard;
}
fragColor = weightsTexture * gaussianKDE(2. * dist);
DECKGL_FILTER_COLOR(fragColor, geometry);
}
`, H6 = `#version 300 es
uniform sampler2D inTexture;
out vec4 outTexture;
void main()
{
int yIndex = gl_VertexID / int(maxWeight.textureSize);
int xIndex = gl_VertexID - (yIndex * int(maxWeight.textureSize));
vec2 uv = (0.5 + vec2(float(xIndex), float(yIndex))) / maxWeight.textureSize;
outTexture = texture(inTexture, uv);
gl_Position = vec4(0.0, 0.0, 0.0, 1.0);
gl_PointSize = 1.0;
}
`, j6 = `#version 300 es
in vec4 outTexture;
out vec4 fragColor;
void main() {
fragColor = outTexture;
fragColor.g = outTexture.r / max(1.0, outTexture.a);
}
`, W6 = `uniform weightUniforms {
  vec4 commonBounds;
  float radiusPixels;
  float textureWidth;
  float weightsScale;
} weight;
`, $6 = {
        name: "weight",
        vs: W6,
        uniformTypes: {
            commonBounds: "vec4<f32>",
            radiusPixels: "f32",
            textureWidth: "f32",
            weightsScale: "f32"
        }
    }, X6 = {
        name: "maxWeight",
        vs: `uniform maxWeightUniforms {
  float textureSize;
} maxWeight;
`,
        uniformTypes: {
            textureSize: "f32"
        }
    }, Y6 = 2, fd = {
        format: "rgba8unorm",
        mipmaps: !1,
        sampler: {
            minFilter: "linear",
            magFilter: "linear",
            addressModeU: "clamp-to-edge",
            addressModeV: "clamp-to-edge"
        }
    }, Ev = [
        0,
        0
    ], q6 = {
        SUM: 0,
        MEAN: 1
    }, K6 = {
        getPosition: {
            type: "accessor",
            value: (n)=>n.position
        },
        getWeight: {
            type: "accessor",
            value: 1
        },
        intensity: {
            type: "number",
            min: 0,
            value: 1
        },
        radiusPixels: {
            type: "number",
            min: 1,
            max: 100,
            value: 50
        },
        colorRange: M1,
        threshold: {
            type: "number",
            min: 0,
            max: 1,
            value: .05
        },
        colorDomain: {
            type: "array",
            value: null,
            optional: !0
        },
        aggregation: "SUM",
        weightsTextureSize: {
            type: "number",
            min: 128,
            max: 2048,
            value: 2048
        },
        debounceTimeout: {
            type: "number",
            min: 0,
            max: 1e3,
            value: 500
        }
    }, Z6 = [
        "float32-renderable-webgl",
        "texture-blend-float-webgl"
    ], Q6 = {
        data: {
            props: [
                "radiusPixels"
            ]
        }
    };
    class Kg extends D1 {
        getShaders(e) {
            let t = [
                Po
            ];
            return e.modules && (t = [
                ...t,
                ...e.modules
            ]), super.getShaders({
                ...e,
                modules: t
            });
        }
        initializeState() {
            super.initializeAggregationLayer(Q6), this.setState({
                colorDomain: Ev
            }), this._setupTextureParams(), this._setupAttributes(), this._setupResources();
        }
        shouldUpdateState({ changeFlags: e }) {
            return e.somethingChanged;
        }
        updateState(e) {
            super.updateState(e), this._updateHeatmapState(e);
        }
        _updateHeatmapState(e) {
            const { props: t, oldProps: i } = e, r = this._getChangeFlags(e);
            (r.dataChanged || r.viewportChanged) && (r.boundsChanged = this._updateBounds(r.dataChanged), this._updateTextureRenderingBounds()), r.dataChanged || r.boundsChanged ? (clearTimeout(this.state.updateTimer), this.setState({
                isWeightMapDirty: !0
            })) : r.viewportZoomChanged && this._debouncedUpdateWeightmap(), t.colorRange !== i.colorRange && this._updateColorTexture(e), this.state.isWeightMapDirty && this._updateWeightmap(), this.setState({
                zoom: e.context.viewport.zoom
            });
        }
        renderLayers() {
            const { weightsTexture: e, triPositionBuffer: t, triTexCoordBuffer: i, maxWeightsTexture: r, colorTexture: a, colorDomain: l } = this.state, { updateTriggers: u, intensity: h, threshold: d, aggregation: p } = this.props, _ = this.getSubLayerClass("triangle", P1);
            return new _(this.getSubLayerProps({
                id: "triangle-layer",
                updateTriggers: u
            }), {
                coordinateSystem: Oe.DEFAULT,
                data: {
                    attributes: {
                        positions: t,
                        texCoords: i
                    }
                },
                vertexCount: 4,
                maxTexture: r,
                colorTexture: a,
                aggregationMode: q6[p] || 0,
                weightsTexture: e,
                intensity: h,
                threshold: d,
                colorDomain: l
            });
        }
        finalizeState(e) {
            super.finalizeState(e);
            const { weightsTransform: t, weightsTexture: i, maxWeightTransform: r, maxWeightsTexture: a, triPositionBuffer: l, triTexCoordBuffer: u, colorTexture: h, updateTimer: d } = this.state;
            t?.destroy(), i?.destroy(), r?.destroy(), a?.destroy(), l?.destroy(), u?.destroy(), h?.destroy(), d && clearTimeout(d);
        }
        _getAttributeManager() {
            return new au(this.context.device, {
                id: this.props.id,
                stats: this.context.stats
            });
        }
        _getChangeFlags(e) {
            const t = {}, { dimensions: i } = this.state;
            t.dataChanged = this.isAttributeChanged() && "attribute changed" || this.isAggregationDirty(e, {
                compareAll: !0,
                dimension: i.data
            }) && "aggregation is dirty", t.viewportChanged = e.changeFlags.viewportChanged;
            const { zoom: r } = this.state;
            return (!e.context.viewport || e.context.viewport.zoom !== r) && (t.viewportZoomChanged = !0), t;
        }
        _createTextures() {
            const { textureSize: e, format: t } = this.state;
            this.setState({
                weightsTexture: this.context.device.createTexture({
                    ...fd,
                    width: e,
                    height: e,
                    format: t
                }),
                maxWeightsTexture: this.context.device.createTexture({
                    ...fd,
                    width: 1,
                    height: 1,
                    format: t
                })
            });
        }
        _setupAttributes() {
            this.getAttributeManager().add({
                positions: {
                    size: 3,
                    type: "float64",
                    accessor: "getPosition"
                },
                weights: {
                    size: 1,
                    accessor: "getWeight"
                }
            }), this.setState({
                positionAttributeName: "positions"
            });
        }
        _setupTextureParams() {
            const { device: e } = this.context, { weightsTextureSize: t } = this.props, i = Math.min(t, e.limits.maxTextureDimension2D), r = Z6.every((u)=>e.features.has(u)), a = r ? "rgba32float" : "rgba8unorm", l = r ? 1 : 1 / 255;
            this.setState({
                textureSize: i,
                format: a,
                weightsScale: l
            }), r || Fe.warn(`HeatmapLayer: ${this.id} rendering to float texture not supported, falling back to low precision format`)();
        }
        _createWeightsTransform(e) {
            let { weightsTransform: t } = this.state;
            const { weightsTexture: i } = this.state, r = this.getAttributeManager();
            t?.destroy(), t = new D0(this.context.device, {
                id: `${this.id}-weights-transform`,
                bufferLayout: r.getBufferLayouts(),
                vertexCount: 1,
                targetTexture: i,
                parameters: {
                    depthWriteEnabled: !1,
                    blendColorOperation: "add",
                    blendColorSrcFactor: "one",
                    blendColorDstFactor: "one",
                    blendAlphaSrcFactor: "one",
                    blendAlphaDstFactor: "one"
                },
                topology: "point-list",
                ...e,
                modules: [
                    ...e.modules,
                    $6
                ]
            }), this.setState({
                weightsTransform: t
            });
        }
        _setupResources() {
            this._createTextures();
            const { device: e } = this.context, { textureSize: t, weightsTexture: i, maxWeightsTexture: r } = this.state, a = this.getShaders({
                vs: Av,
                fs: wv
            });
            this._createWeightsTransform(a);
            const l = this.getShaders({
                vs: H6,
                fs: j6,
                modules: [
                    X6
                ]
            }), u = new D0(e, {
                id: `${this.id}-max-weights-transform`,
                targetTexture: r,
                ...l,
                vertexCount: t * t,
                topology: "point-list",
                parameters: {
                    depthWriteEnabled: !1,
                    blendColorOperation: "max",
                    blendAlphaOperation: "max",
                    blendColorSrcFactor: "one",
                    blendColorDstFactor: "one",
                    blendAlphaSrcFactor: "one",
                    blendAlphaDstFactor: "one"
                }
            }), h = {
                inTexture: i,
                textureSize: t
            };
            u.model.shaderInputs.setProps({
                maxWeight: h
            }), this.setState({
                weightsTexture: i,
                maxWeightsTexture: r,
                maxWeightTransform: u,
                zoom: null,
                triPositionBuffer: e.createBuffer({
                    byteLength: 48
                }),
                triTexCoordBuffer: e.createBuffer({
                    byteLength: 48
                })
            });
        }
        updateShaders(e) {
            this._createWeightsTransform({
                vs: Av,
                fs: wv,
                ...e
            });
        }
        _updateMaxWeightValue() {
            const { maxWeightTransform: e } = this.state;
            e.run({
                parameters: {
                    viewport: [
                        0,
                        0,
                        1,
                        1
                    ]
                },
                clearColor: [
                    0,
                    0,
                    0,
                    0
                ]
            });
        }
        _updateBounds(e = !1) {
            const { viewport: t } = this.context, i = [
                t.unproject([
                    0,
                    0
                ]),
                t.unproject([
                    t.width,
                    0
                ]),
                t.unproject([
                    0,
                    t.height
                ]),
                t.unproject([
                    t.width,
                    t.height
                ])
            ].map((u)=>u.map(Math.fround)), r = P6(i), a = {
                visibleWorldBounds: r,
                viewportCorners: i
            };
            let l = !1;
            if (e || !this.state.worldBounds || !D6(this.state.worldBounds, r)) {
                const u = this._worldToCommonBounds(r), h = this._commonToWorldBounds(u);
                this.props.coordinateSystem === Oe.LNGLAT && (h[1] = Math.max(h[1], -85.051129), h[3] = Math.min(h[3], 85.051129), h[0] = Math.max(h[0], -360), h[2] = Math.min(h[2], 360));
                const d = this._worldToCommonBounds(h);
                a.worldBounds = h, a.normalizedCommonBounds = d, l = !0;
            }
            return this.setState(a), l;
        }
        _updateTextureRenderingBounds() {
            const { triPositionBuffer: e, triTexCoordBuffer: t, normalizedCommonBounds: i, viewportCorners: r } = this.state, { viewport: a } = this.context;
            e.write(xv(r, 3));
            const l = r.map((u)=>U6(a.projectPosition(u), i));
            t.write(xv(l, 2));
        }
        _updateColorTexture(e) {
            const { colorRange: t } = e.props;
            let { colorTexture: i } = this.state;
            const r = O1(t, !1, Uint8Array);
            i && i?.width === t.length ? i.setTexture2DData({
                data: r
            }) : (i?.destroy(), i = this.context.device.createTexture({
                ...fd,
                data: r,
                width: t.length,
                height: 1
            })), this.setState({
                colorTexture: i
            });
        }
        _updateWeightmap() {
            const { radiusPixels: e, colorDomain: t, aggregation: i } = this.props, { worldBounds: r, textureSize: a, weightsScale: l, weightsTexture: u } = this.state, h = this.state.weightsTransform;
            this.state.isWeightMapDirty = !1;
            const d = this._worldToCommonBounds(r, {
                useLayerCoordinateSystem: !0
            });
            if (t && i === "SUM") {
                const { viewport: O } = this.context, U = O.distanceScales.metersPerUnit[2] * (d[2] - d[0]) / a;
                this.state.colorDomain = t.map((L)=>L * U * l);
            } else this.state.colorDomain = t || Ev;
            const _ = this.getAttributeManager().getAttributes(), y = this.getModuleSettings();
            this._setModelAttributes(h.model, _), h.model.setVertexCount(this.getNumInstances());
            const v = {
                radiusPixels: e,
                commonBounds: d,
                textureWidth: a,
                weightsScale: l,
                weightsTexture: u
            }, { viewport: S, devicePixelRatio: E, coordinateSystem: M, coordinateOrigin: B } = y, { modelMatrix: H } = this.props;
            h.model.shaderInputs.setProps({
                project: {
                    viewport: S,
                    devicePixelRatio: E,
                    modelMatrix: H,
                    coordinateSystem: M,
                    coordinateOrigin: B
                },
                weight: v
            }), h.run({
                parameters: {
                    viewport: [
                        0,
                        0,
                        a,
                        a
                    ]
                },
                clearColor: [
                    0,
                    0,
                    0,
                    0
                ]
            }), this._updateMaxWeightValue();
        }
        _debouncedUpdateWeightmap(e = !1) {
            let { updateTimer: t } = this.state;
            const { debounceTimeout: i } = this.props;
            e ? (t = null, this._updateBounds(!0), this._updateTextureRenderingBounds(), this.setState({
                isWeightMapDirty: !0
            })) : (this.setState({
                isWeightMapDirty: !1
            }), clearTimeout(t), t = setTimeout(this._debouncedUpdateWeightmap.bind(this, !0), i)), this.setState({
                updateTimer: t
            });
        }
        _worldToCommonBounds(e, t = {}) {
            const { useLayerCoordinateSystem: i = !1 } = t, [r, a, l, u] = e, { viewport: h } = this.context, { textureSize: d } = this.state, { coordinateSystem: p } = this.props, _ = i && (p === Oe.LNGLAT_OFFSETS || p === Oe.METER_OFFSETS), y = _ ? h.projectPosition(this.props.coordinateOrigin) : [
                0,
                0
            ], v = d * Y6 / h.scale;
            let S, E;
            return i && !_ ? (S = this.projectPosition([
                r,
                a,
                0
            ]), E = this.projectPosition([
                l,
                u,
                0
            ])) : (S = h.projectPosition([
                r,
                a,
                0
            ]), E = h.projectPosition([
                l,
                u,
                0
            ])), k6([
                S[0] - y[0],
                S[1] - y[1],
                E[0] - y[0],
                E[1] - y[1]
            ], v, v);
        }
        _commonToWorldBounds(e) {
            const [t, i, r, a] = e, { viewport: l } = this.context, u = l.unprojectPosition([
                t,
                i
            ]), h = l.unprojectPosition([
                r,
                a
            ]);
            return u.slice(0, 2).concat(h.slice(0, 2));
        }
    }
    Kg.layerName = "HeatmapLayer";
    Kg.defaultProps = K6;
    const G6 = new UT({
        color: [
            12,
            204,
            238,
            250
        ],
        intensity: 1
    }), J6 = new Pg({
        color: [
            255,
            255,
            255,
            155
        ],
        intensity: 2.2,
        position: [
            -.144528,
            49.739968,
            1e5
        ]
    }), eU = new Pg({
        color: [
            70,
            130,
            230
        ],
        intensity: 1,
        position: [
            -3.807751,
            54.104682,
            8e4
        ]
    }), tU = new Pg({
        color: [
            130,
            225,
            255
        ],
        intensity: .5,
        position: [
            5,
            52.5,
            6e5
        ]
    }), nU = new Ld({
        color: [
            255,
            255,
            255
        ],
        direction: [
            0,
            0,
            -1
        ],
        intensity: 1
    }), iU = new Ng({
        ambientLight: G6,
        pointLight1: J6,
        pointLight2: eU,
        pointLight3: tU,
        directionalLight: nU
    });
    function bc(n, e) {
        return n == null || e == null ? NaN : n < e ? -1 : n > e ? 1 : n >= e ? 0 : NaN;
    }
    function rU(n, e) {
        return n == null || e == null ? NaN : e < n ? -1 : e > n ? 1 : e >= n ? 0 : NaN;
    }
    function k1(n) {
        let e, t, i;
        n.length !== 2 ? (e = bc, t = (u, h)=>bc(n(u), h), i = (u, h)=>n(u) - h) : (e = n === bc || n === rU ? n : sU, t = n, i = n);
        function r(u, h, d = 0, p = u.length) {
            if (d < p) {
                if (e(h, h) !== 0) return p;
                do {
                    const _ = d + p >>> 1;
                    t(u[_], h) < 0 ? d = _ + 1 : p = _;
                }while (d < p);
            }
            return d;
        }
        function a(u, h, d = 0, p = u.length) {
            if (d < p) {
                if (e(h, h) !== 0) return p;
                do {
                    const _ = d + p >>> 1;
                    t(u[_], h) <= 0 ? d = _ + 1 : p = _;
                }while (d < p);
            }
            return d;
        }
        function l(u, h, d = 0, p = u.length) {
            const _ = r(u, h, d, p - 1);
            return _ > d && i(u[_ - 1], h) > -i(u[_], h) ? _ - 1 : _;
        }
        return {
            left: r,
            center: l,
            right: a
        };
    }
    function sU() {
        return 0;
    }
    function aU(n) {
        return n === null ? NaN : +n;
    }
    const oU = k1(bc), lU = oU.right;
    k1(aU).center;
    const cU = Math.sqrt(50), uU = Math.sqrt(10), fU = Math.sqrt(2);
    function Wc(n, e, t) {
        const i = (e - n) / Math.max(0, t), r = Math.floor(Math.log10(i)), a = i / Math.pow(10, r), l = a >= cU ? 10 : a >= uU ? 5 : a >= fU ? 2 : 1;
        let u, h, d;
        return r < 0 ? (d = Math.pow(10, -r) / l, u = Math.round(n * d), h = Math.round(e * d), u / d < n && ++u, h / d > e && --h, d = -d) : (d = Math.pow(10, r) * l, u = Math.round(n / d), h = Math.round(e / d), u * d < n && ++u, h * d > e && --h), h < u && .5 <= t && t < 2 ? Wc(n, e, t * 2) : [
            u,
            h,
            d
        ];
    }
    function hU(n, e, t) {
        if (e = +e, n = +n, t = +t, !(t > 0)) return [];
        if (n === e) return [
            n
        ];
        const i = e < n, [r, a, l] = i ? Wc(e, n, t) : Wc(n, e, t);
        if (!(a >= r)) return [];
        const u = a - r + 1, h = new Array(u);
        if (i) if (l < 0) for(let d = 0; d < u; ++d)h[d] = (a - d) / -l;
        else for(let d = 0; d < u; ++d)h[d] = (a - d) * l;
        else if (l < 0) for(let d = 0; d < u; ++d)h[d] = (r + d) / -l;
        else for(let d = 0; d < u; ++d)h[d] = (r + d) * l;
        return h;
    }
    function Qd(n, e, t) {
        return e = +e, n = +n, t = +t, Wc(n, e, t)[2];
    }
    function dU(n, e, t) {
        e = +e, n = +n, t = +t;
        const i = e < n, r = i ? Qd(e, n, t) : Qd(n, e, t);
        return (i ? -1 : 1) * (r < 0 ? 1 / -r : r);
    }
    function gU(n, e) {
        switch(arguments.length){
            case 0:
                break;
            case 1:
                this.range(n);
                break;
            default:
                this.range(e).domain(n);
                break;
        }
        return this;
    }
    function Zg(n, e, t) {
        n.prototype = e.prototype = t, t.constructor = n;
    }
    function U1(n, e) {
        var t = Object.create(n.prototype);
        for(var i in e)t[i] = e[i];
        return t;
    }
    function Do() {}
    var wo = .7, $c = 1 / wo, js = "\\s*([+-]?\\d+)\\s*", Eo = "\\s*([+-]?(?:\\d*\\.)?\\d+(?:[eE][+-]?\\d+)?)\\s*", Hn = "\\s*([+-]?(?:\\d*\\.)?\\d+(?:[eE][+-]?\\d+)?)%\\s*", pU = /^#([0-9a-f]{3,8})$/, mU = new RegExp(`^rgb\\(${js},${js},${js}\\)$`), _U = new RegExp(`^rgb\\(${Hn},${Hn},${Hn}\\)$`), yU = new RegExp(`^rgba\\(${js},${js},${js},${Eo}\\)$`), bU = new RegExp(`^rgba\\(${Hn},${Hn},${Hn},${Eo}\\)$`), vU = new RegExp(`^hsl\\(${Eo},${Hn},${Hn}\\)$`), TU = new RegExp(`^hsla\\(${Eo},${Hn},${Hn},${Eo}\\)$`), Rv = {
        aliceblue: 15792383,
        antiquewhite: 16444375,
        aqua: 65535,
        aquamarine: 8388564,
        azure: 15794175,
        beige: 16119260,
        bisque: 16770244,
        black: 0,
        blanchedalmond: 16772045,
        blue: 255,
        blueviolet: 9055202,
        brown: 10824234,
        burlywood: 14596231,
        cadetblue: 6266528,
        chartreuse: 8388352,
        chocolate: 13789470,
        coral: 16744272,
        cornflowerblue: 6591981,
        cornsilk: 16775388,
        crimson: 14423100,
        cyan: 65535,
        darkblue: 139,
        darkcyan: 35723,
        darkgoldenrod: 12092939,
        darkgray: 11119017,
        darkgreen: 25600,
        darkgrey: 11119017,
        darkkhaki: 12433259,
        darkmagenta: 9109643,
        darkolivegreen: 5597999,
        darkorange: 16747520,
        darkorchid: 10040012,
        darkred: 9109504,
        darksalmon: 15308410,
        darkseagreen: 9419919,
        darkslateblue: 4734347,
        darkslategray: 3100495,
        darkslategrey: 3100495,
        darkturquoise: 52945,
        darkviolet: 9699539,
        deeppink: 16716947,
        deepskyblue: 49151,
        dimgray: 6908265,
        dimgrey: 6908265,
        dodgerblue: 2003199,
        firebrick: 11674146,
        floralwhite: 16775920,
        forestgreen: 2263842,
        fuchsia: 16711935,
        gainsboro: 14474460,
        ghostwhite: 16316671,
        gold: 16766720,
        goldenrod: 14329120,
        gray: 8421504,
        green: 32768,
        greenyellow: 11403055,
        grey: 8421504,
        honeydew: 15794160,
        hotpink: 16738740,
        indianred: 13458524,
        indigo: 4915330,
        ivory: 16777200,
        khaki: 15787660,
        lavender: 15132410,
        lavenderblush: 16773365,
        lawngreen: 8190976,
        lemonchiffon: 16775885,
        lightblue: 11393254,
        lightcoral: 15761536,
        lightcyan: 14745599,
        lightgoldenrodyellow: 16448210,
        lightgray: 13882323,
        lightgreen: 9498256,
        lightgrey: 13882323,
        lightpink: 16758465,
        lightsalmon: 16752762,
        lightseagreen: 2142890,
        lightskyblue: 8900346,
        lightslategray: 7833753,
        lightslategrey: 7833753,
        lightsteelblue: 11584734,
        lightyellow: 16777184,
        lime: 65280,
        limegreen: 3329330,
        linen: 16445670,
        magenta: 16711935,
        maroon: 8388608,
        mediumaquamarine: 6737322,
        mediumblue: 205,
        mediumorchid: 12211667,
        mediumpurple: 9662683,
        mediumseagreen: 3978097,
        mediumslateblue: 8087790,
        mediumspringgreen: 64154,
        mediumturquoise: 4772300,
        mediumvioletred: 13047173,
        midnightblue: 1644912,
        mintcream: 16121850,
        mistyrose: 16770273,
        moccasin: 16770229,
        navajowhite: 16768685,
        navy: 128,
        oldlace: 16643558,
        olive: 8421376,
        olivedrab: 7048739,
        orange: 16753920,
        orangered: 16729344,
        orchid: 14315734,
        palegoldenrod: 15657130,
        palegreen: 10025880,
        paleturquoise: 11529966,
        palevioletred: 14381203,
        papayawhip: 16773077,
        peachpuff: 16767673,
        peru: 13468991,
        pink: 16761035,
        plum: 14524637,
        powderblue: 11591910,
        purple: 8388736,
        rebeccapurple: 6697881,
        red: 16711680,
        rosybrown: 12357519,
        royalblue: 4286945,
        saddlebrown: 9127187,
        salmon: 16416882,
        sandybrown: 16032864,
        seagreen: 3050327,
        seashell: 16774638,
        sienna: 10506797,
        silver: 12632256,
        skyblue: 8900331,
        slateblue: 6970061,
        slategray: 7372944,
        slategrey: 7372944,
        snow: 16775930,
        springgreen: 65407,
        steelblue: 4620980,
        tan: 13808780,
        teal: 32896,
        thistle: 14204888,
        tomato: 16737095,
        turquoise: 4251856,
        violet: 15631086,
        wheat: 16113331,
        white: 16777215,
        whitesmoke: 16119285,
        yellow: 16776960,
        yellowgreen: 10145074
    };
    Zg(Do, Ro, {
        copy (n) {
            return Object.assign(new this.constructor, this, n);
        },
        displayable () {
            return this.rgb().displayable();
        },
        hex: Cv,
        formatHex: Cv,
        formatHex8: xU,
        formatHsl: SU,
        formatRgb: Mv,
        toString: Mv
    });
    function Cv() {
        return this.rgb().formatHex();
    }
    function xU() {
        return this.rgb().formatHex8();
    }
    function SU() {
        return B1(this).formatHsl();
    }
    function Mv() {
        return this.rgb().formatRgb();
    }
    function Ro(n) {
        var e, t;
        return n = (n + "").trim().toLowerCase(), (e = pU.exec(n)) ? (t = e[1].length, e = parseInt(e[1], 16), t === 6 ? Ov(e) : t === 3 ? new jt(e >> 8 & 15 | e >> 4 & 240, e >> 4 & 15 | e & 240, (e & 15) << 4 | e & 15, 1) : t === 8 ? cc(e >> 24 & 255, e >> 16 & 255, e >> 8 & 255, (e & 255) / 255) : t === 4 ? cc(e >> 12 & 15 | e >> 8 & 240, e >> 8 & 15 | e >> 4 & 240, e >> 4 & 15 | e & 240, ((e & 15) << 4 | e & 15) / 255) : null) : (e = mU.exec(n)) ? new jt(e[1], e[2], e[3], 1) : (e = _U.exec(n)) ? new jt(e[1] * 255 / 100, e[2] * 255 / 100, e[3] * 255 / 100, 1) : (e = yU.exec(n)) ? cc(e[1], e[2], e[3], e[4]) : (e = bU.exec(n)) ? cc(e[1] * 255 / 100, e[2] * 255 / 100, e[3] * 255 / 100, e[4]) : (e = vU.exec(n)) ? Pv(e[1], e[2] / 100, e[3] / 100, 1) : (e = TU.exec(n)) ? Pv(e[1], e[2] / 100, e[3] / 100, e[4]) : Rv.hasOwnProperty(n) ? Ov(Rv[n]) : n === "transparent" ? new jt(NaN, NaN, NaN, 0) : null;
    }
    function Ov(n) {
        return new jt(n >> 16 & 255, n >> 8 & 255, n & 255, 1);
    }
    function cc(n, e, t, i) {
        return i <= 0 && (n = e = t = NaN), new jt(n, e, t, i);
    }
    function AU(n) {
        return n instanceof Do || (n = Ro(n)), n ? (n = n.rgb(), new jt(n.r, n.g, n.b, n.opacity)) : new jt;
    }
    function Gd(n, e, t, i) {
        return arguments.length === 1 ? AU(n) : new jt(n, e, t, i ?? 1);
    }
    function jt(n, e, t, i) {
        this.r = +n, this.g = +e, this.b = +t, this.opacity = +i;
    }
    Zg(jt, Gd, U1(Do, {
        brighter (n) {
            return n = n == null ? $c : Math.pow($c, n), new jt(this.r * n, this.g * n, this.b * n, this.opacity);
        },
        darker (n) {
            return n = n == null ? wo : Math.pow(wo, n), new jt(this.r * n, this.g * n, this.b * n, this.opacity);
        },
        rgb () {
            return this;
        },
        clamp () {
            return new jt(Cr(this.r), Cr(this.g), Cr(this.b), Xc(this.opacity));
        },
        displayable () {
            return -.5 <= this.r && this.r < 255.5 && -.5 <= this.g && this.g < 255.5 && -.5 <= this.b && this.b < 255.5 && 0 <= this.opacity && this.opacity <= 1;
        },
        hex: Iv,
        formatHex: Iv,
        formatHex8: wU,
        formatRgb: Nv,
        toString: Nv
    }));
    function Iv() {
        return `#${Sr(this.r)}${Sr(this.g)}${Sr(this.b)}`;
    }
    function wU() {
        return `#${Sr(this.r)}${Sr(this.g)}${Sr(this.b)}${Sr((isNaN(this.opacity) ? 1 : this.opacity) * 255)}`;
    }
    function Nv() {
        const n = Xc(this.opacity);
        return `${n === 1 ? "rgb(" : "rgba("}${Cr(this.r)}, ${Cr(this.g)}, ${Cr(this.b)}${n === 1 ? ")" : `, ${n})`}`;
    }
    function Xc(n) {
        return isNaN(n) ? 1 : Math.max(0, Math.min(1, n));
    }
    function Cr(n) {
        return Math.max(0, Math.min(255, Math.round(n) || 0));
    }
    function Sr(n) {
        return n = Cr(n), (n < 16 ? "0" : "") + n.toString(16);
    }
    function Pv(n, e, t, i) {
        return i <= 0 ? n = e = t = NaN : t <= 0 || t >= 1 ? n = e = NaN : e <= 0 && (n = NaN), new Rn(n, e, t, i);
    }
    function B1(n) {
        if (n instanceof Rn) return new Rn(n.h, n.s, n.l, n.opacity);
        if (n instanceof Do || (n = Ro(n)), !n) return new Rn;
        if (n instanceof Rn) return n;
        n = n.rgb();
        var e = n.r / 255, t = n.g / 255, i = n.b / 255, r = Math.min(e, t, i), a = Math.max(e, t, i), l = NaN, u = a - r, h = (a + r) / 2;
        return u ? (e === a ? l = (t - i) / u + (t < i) * 6 : t === a ? l = (i - e) / u + 2 : l = (e - t) / u + 4, u /= h < .5 ? a + r : 2 - a - r, l *= 60) : u = h > 0 && h < 1 ? 0 : l, new Rn(l, u, h, n.opacity);
    }
    function EU(n, e, t, i) {
        return arguments.length === 1 ? B1(n) : new Rn(n, e, t, i ?? 1);
    }
    function Rn(n, e, t, i) {
        this.h = +n, this.s = +e, this.l = +t, this.opacity = +i;
    }
    Zg(Rn, EU, U1(Do, {
        brighter (n) {
            return n = n == null ? $c : Math.pow($c, n), new Rn(this.h, this.s, this.l * n, this.opacity);
        },
        darker (n) {
            return n = n == null ? wo : Math.pow(wo, n), new Rn(this.h, this.s, this.l * n, this.opacity);
        },
        rgb () {
            var n = this.h % 360 + (this.h < 0) * 360, e = isNaN(n) || isNaN(this.s) ? 0 : this.s, t = this.l, i = t + (t < .5 ? t : 1 - t) * e, r = 2 * t - i;
            return new jt(hd(n >= 240 ? n - 240 : n + 120, r, i), hd(n, r, i), hd(n < 120 ? n + 240 : n - 120, r, i), this.opacity);
        },
        clamp () {
            return new Rn(Dv(this.h), uc(this.s), uc(this.l), Xc(this.opacity));
        },
        displayable () {
            return (0 <= this.s && this.s <= 1 || isNaN(this.s)) && 0 <= this.l && this.l <= 1 && 0 <= this.opacity && this.opacity <= 1;
        },
        formatHsl () {
            const n = Xc(this.opacity);
            return `${n === 1 ? "hsl(" : "hsla("}${Dv(this.h)}, ${uc(this.s) * 100}%, ${uc(this.l) * 100}%${n === 1 ? ")" : `, ${n})`}`;
        }
    }));
    function Dv(n) {
        return n = (n || 0) % 360, n < 0 ? n + 360 : n;
    }
    function uc(n) {
        return Math.max(0, Math.min(1, n || 0));
    }
    function hd(n, e, t) {
        return (n < 60 ? e + (t - e) * n / 60 : n < 180 ? t : n < 240 ? e + (t - e) * (240 - n) / 60 : e) * 255;
    }
    const Qg = (n)=>()=>n;
    function RU(n, e) {
        return function(t) {
            return n + t * e;
        };
    }
    function CU(n, e, t) {
        return n = Math.pow(n, t), e = Math.pow(e, t) - n, t = 1 / t, function(i) {
            return Math.pow(n + i * e, t);
        };
    }
    function MU(n) {
        return (n = +n) == 1 ? L1 : function(e, t) {
            return t - e ? CU(e, t, n) : Qg(isNaN(e) ? t : e);
        };
    }
    function L1(n, e) {
        var t = e - n;
        return t ? RU(n, t) : Qg(isNaN(n) ? e : n);
    }
    const kv = function n(e) {
        var t = MU(e);
        function i(r, a) {
            var l = t((r = Gd(r)).r, (a = Gd(a)).r), u = t(r.g, a.g), h = t(r.b, a.b), d = L1(r.opacity, a.opacity);
            return function(p) {
                return r.r = l(p), r.g = u(p), r.b = h(p), r.opacity = d(p), r + "";
            };
        }
        return i.gamma = n, i;
    }(1);
    function OU(n, e) {
        e || (e = []);
        var t = n ? Math.min(e.length, n.length) : 0, i = e.slice(), r;
        return function(a) {
            for(r = 0; r < t; ++r)i[r] = n[r] * (1 - a) + e[r] * a;
            return i;
        };
    }
    function IU(n) {
        return ArrayBuffer.isView(n) && !(n instanceof DataView);
    }
    function NU(n, e) {
        var t = e ? e.length : 0, i = n ? Math.min(t, n.length) : 0, r = new Array(i), a = new Array(t), l;
        for(l = 0; l < i; ++l)r[l] = Gg(n[l], e[l]);
        for(; l < t; ++l)a[l] = e[l];
        return function(u) {
            for(l = 0; l < i; ++l)a[l] = r[l](u);
            return a;
        };
    }
    function PU(n, e) {
        var t = new Date;
        return n = +n, e = +e, function(i) {
            return t.setTime(n * (1 - i) + e * i), t;
        };
    }
    function Yc(n, e) {
        return n = +n, e = +e, function(t) {
            return n * (1 - t) + e * t;
        };
    }
    function DU(n, e) {
        var t = {}, i = {}, r;
        (n === null || typeof n != "object") && (n = {}), (e === null || typeof e != "object") && (e = {});
        for(r in e)r in n ? t[r] = Gg(n[r], e[r]) : i[r] = e[r];
        return function(a) {
            for(r in t)i[r] = t[r](a);
            return i;
        };
    }
    var Jd = /[-+]?(?:\d+\.?\d*|\.?\d+)(?:[eE][-+]?\d+)?/g, dd = new RegExp(Jd.source, "g");
    function kU(n) {
        return function() {
            return n;
        };
    }
    function UU(n) {
        return function(e) {
            return n(e) + "";
        };
    }
    function BU(n, e) {
        var t = Jd.lastIndex = dd.lastIndex = 0, i, r, a, l = -1, u = [], h = [];
        for(n = n + "", e = e + ""; (i = Jd.exec(n)) && (r = dd.exec(e));)(a = r.index) > t && (a = e.slice(t, a), u[l] ? u[l] += a : u[++l] = a), (i = i[0]) === (r = r[0]) ? u[l] ? u[l] += r : u[++l] = r : (u[++l] = null, h.push({
            i: l,
            x: Yc(i, r)
        })), t = dd.lastIndex;
        return t < e.length && (a = e.slice(t), u[l] ? u[l] += a : u[++l] = a), u.length < 2 ? h[0] ? UU(h[0].x) : kU(e) : (e = h.length, function(d) {
            for(var p = 0, _; p < e; ++p)u[(_ = h[p]).i] = _.x(d);
            return u.join("");
        });
    }
    function Gg(n, e) {
        var t = typeof e, i;
        return e == null || t === "boolean" ? Qg(e) : (t === "number" ? Yc : t === "string" ? (i = Ro(e)) ? (e = i, kv) : BU : e instanceof Ro ? kv : e instanceof Date ? PU : IU(e) ? OU : Array.isArray(e) ? NU : typeof e.valueOf != "function" && typeof e.toString != "function" || isNaN(e) ? DU : Yc)(n, e);
    }
    function LU(n, e) {
        return n = +n, e = +e, function(t) {
            return Math.round(n * (1 - t) + e * t);
        };
    }
    function FU(n) {
        return function() {
            return n;
        };
    }
    function zU(n) {
        return +n;
    }
    var Uv = [
        0,
        1
    ];
    function zs(n) {
        return n;
    }
    function eg(n, e) {
        return (e -= n = +n) ? function(t) {
            return (t - n) / e;
        } : FU(isNaN(e) ? NaN : .5);
    }
    function VU(n, e) {
        var t;
        return n > e && (t = n, n = e, e = t), function(i) {
            return Math.max(n, Math.min(e, i));
        };
    }
    function HU(n, e, t) {
        var i = n[0], r = n[1], a = e[0], l = e[1];
        return r < i ? (i = eg(r, i), a = t(l, a)) : (i = eg(i, r), a = t(a, l)), function(u) {
            return a(i(u));
        };
    }
    function jU(n, e, t) {
        var i = Math.min(n.length, e.length) - 1, r = new Array(i), a = new Array(i), l = -1;
        for(n[i] < n[0] && (n = n.slice().reverse(), e = e.slice().reverse()); ++l < i;)r[l] = eg(n[l], n[l + 1]), a[l] = t(e[l], e[l + 1]);
        return function(u) {
            var h = lU(n, u, 1, i) - 1;
            return a[h](r[h](u));
        };
    }
    function WU(n, e) {
        return e.domain(n.domain()).range(n.range()).interpolate(n.interpolate()).clamp(n.clamp()).unknown(n.unknown());
    }
    function $U() {
        var n = Uv, e = Uv, t = Gg, i, r, a, l = zs, u, h, d;
        function p() {
            var y = Math.min(n.length, e.length);
            return l !== zs && (l = VU(n[0], n[y - 1])), u = y > 2 ? jU : HU, h = d = null, _;
        }
        function _(y) {
            return y == null || isNaN(y = +y) ? a : (h || (h = u(n.map(i), e, t)))(i(l(y)));
        }
        return _.invert = function(y) {
            return l(r((d || (d = u(e, n.map(i), Yc)))(y)));
        }, _.domain = function(y) {
            return arguments.length ? (n = Array.from(y, zU), p()) : n.slice();
        }, _.range = function(y) {
            return arguments.length ? (e = Array.from(y), p()) : e.slice();
        }, _.rangeRound = function(y) {
            return e = Array.from(y), t = LU, p();
        }, _.clamp = function(y) {
            return arguments.length ? (l = y ? !0 : zs, p()) : l !== zs;
        }, _.interpolate = function(y) {
            return arguments.length ? (t = y, p()) : t;
        }, _.unknown = function(y) {
            return arguments.length ? (a = y, _) : a;
        }, function(y, v) {
            return i = y, r = v, p();
        };
    }
    function XU() {
        return $U()(zs, zs);
    }
    function YU(n) {
        return Math.abs(n = Math.round(n)) >= 1e21 ? n.toLocaleString("en").replace(/,/g, "") : n.toString(10);
    }
    function qc(n, e) {
        if ((t = (n = e ? n.toExponential(e - 1) : n.toExponential()).indexOf("e")) < 0) return null;
        var t, i = n.slice(0, t);
        return [
            i.length > 1 ? i[0] + i.slice(2) : i,
            +n.slice(t + 1)
        ];
    }
    function ea(n) {
        return n = qc(Math.abs(n)), n ? n[1] : NaN;
    }
    function qU(n, e) {
        return function(t, i) {
            for(var r = t.length, a = [], l = 0, u = n[0], h = 0; r > 0 && u > 0 && (h + u + 1 > i && (u = Math.max(1, i - h)), a.push(t.substring(r -= u, r + u)), !((h += u + 1) > i));)u = n[l = (l + 1) % n.length];
            return a.reverse().join(e);
        };
    }
    function KU(n) {
        return function(e) {
            return e.replace(/[0-9]/g, function(t) {
                return n[+t];
            });
        };
    }
    var ZU = /^(?:(.)?([<>=^]))?([+\-( ])?([$#])?(0)?(\d+)?(,)?(\.\d+)?(~)?([a-z%])?$/i;
    function Kc(n) {
        if (!(e = ZU.exec(n))) throw new Error("invalid format: " + n);
        var e;
        return new Jg({
            fill: e[1],
            align: e[2],
            sign: e[3],
            symbol: e[4],
            zero: e[5],
            width: e[6],
            comma: e[7],
            precision: e[8] && e[8].slice(1),
            trim: e[9],
            type: e[10]
        });
    }
    Kc.prototype = Jg.prototype;
    function Jg(n) {
        this.fill = n.fill === void 0 ? " " : n.fill + "", this.align = n.align === void 0 ? ">" : n.align + "", this.sign = n.sign === void 0 ? "-" : n.sign + "", this.symbol = n.symbol === void 0 ? "" : n.symbol + "", this.zero = !!n.zero, this.width = n.width === void 0 ? void 0 : +n.width, this.comma = !!n.comma, this.precision = n.precision === void 0 ? void 0 : +n.precision, this.trim = !!n.trim, this.type = n.type === void 0 ? "" : n.type + "";
    }
    Jg.prototype.toString = function() {
        return this.fill + this.align + this.sign + this.symbol + (this.zero ? "0" : "") + (this.width === void 0 ? "" : Math.max(1, this.width | 0)) + (this.comma ? "," : "") + (this.precision === void 0 ? "" : "." + Math.max(0, this.precision | 0)) + (this.trim ? "~" : "") + this.type;
    };
    function QU(n) {
        e: for(var e = n.length, t = 1, i = -1, r; t < e; ++t)switch(n[t]){
            case ".":
                i = r = t;
                break;
            case "0":
                i === 0 && (i = t), r = t;
                break;
            default:
                if (!+n[t]) break e;
                i > 0 && (i = 0);
                break;
        }
        return i > 0 ? n.slice(0, i) + n.slice(r + 1) : n;
    }
    var F1;
    function GU(n, e) {
        var t = qc(n, e);
        if (!t) return n + "";
        var i = t[0], r = t[1], a = r - (F1 = Math.max(-8, Math.min(8, Math.floor(r / 3))) * 3) + 1, l = i.length;
        return a === l ? i : a > l ? i + new Array(a - l + 1).join("0") : a > 0 ? i.slice(0, a) + "." + i.slice(a) : "0." + new Array(1 - a).join("0") + qc(n, Math.max(0, e + a - 1))[0];
    }
    function Bv(n, e) {
        var t = qc(n, e);
        if (!t) return n + "";
        var i = t[0], r = t[1];
        return r < 0 ? "0." + new Array(-r).join("0") + i : i.length > r + 1 ? i.slice(0, r + 1) + "." + i.slice(r + 1) : i + new Array(r - i.length + 2).join("0");
    }
    const Lv = {
        "%": (n, e)=>(n * 100).toFixed(e),
        b: (n)=>Math.round(n).toString(2),
        c: (n)=>n + "",
        d: YU,
        e: (n, e)=>n.toExponential(e),
        f: (n, e)=>n.toFixed(e),
        g: (n, e)=>n.toPrecision(e),
        o: (n)=>Math.round(n).toString(8),
        p: (n, e)=>Bv(n * 100, e),
        r: Bv,
        s: GU,
        X: (n)=>Math.round(n).toString(16).toUpperCase(),
        x: (n)=>Math.round(n).toString(16)
    };
    function Fv(n) {
        return n;
    }
    var zv = Array.prototype.map, Vv = [
        "y",
        "z",
        "a",
        "f",
        "p",
        "n",
        "",
        "m",
        "",
        "k",
        "M",
        "G",
        "T",
        "P",
        "E",
        "Z",
        "Y"
    ];
    function JU(n) {
        var e = n.grouping === void 0 || n.thousands === void 0 ? Fv : qU(zv.call(n.grouping, Number), n.thousands + ""), t = n.currency === void 0 ? "" : n.currency[0] + "", i = n.currency === void 0 ? "" : n.currency[1] + "", r = n.decimal === void 0 ? "." : n.decimal + "", a = n.numerals === void 0 ? Fv : KU(zv.call(n.numerals, String)), l = n.percent === void 0 ? "%" : n.percent + "", u = n.minus === void 0 ? "" : n.minus + "", h = n.nan === void 0 ? "NaN" : n.nan + "";
        function d(_) {
            _ = Kc(_);
            var y = _.fill, v = _.align, S = _.sign, E = _.symbol, M = _.zero, B = _.width, H = _.comma, O = _.precision, U = _.trim, L = _.type;
            L === "n" ? (H = !0, L = "g") : Lv[L] || (O === void 0 && (O = 12), U = !0, L = "g"), (M || y === "0" && v === "=") && (M = !0, y = "0", v = "=");
            var Z = E === "$" ? t : E === "#" && /[boxX]/.test(L) ? "0" + L.toLowerCase() : "", se = E === "$" ? i : /[%p]/.test(L) ? l : "", ae = Lv[L], te = /[defgprs%]/.test(L);
            O = O === void 0 ? 6 : /[gprs]/.test(L) ? Math.max(1, Math.min(21, O)) : Math.max(0, Math.min(20, O));
            function fe(ne) {
                var ve = Z, Te = se, ue, Ie, $;
                if (L === "c") Te = ae(ne) + Te, ne = "";
                else {
                    ne = +ne;
                    var ee = ne < 0 || 1 / ne < 0;
                    if (ne = isNaN(ne) ? h : ae(Math.abs(ne), O), U && (ne = QU(ne)), ee && +ne == 0 && S !== "+" && (ee = !1), ve = (ee ? S === "(" ? S : u : S === "-" || S === "(" ? "" : S) + ve, Te = (L === "s" ? Vv[8 + F1 / 3] : "") + Te + (ee && S === "(" ? ")" : ""), te) {
                        for(ue = -1, Ie = ne.length; ++ue < Ie;)if ($ = ne.charCodeAt(ue), 48 > $ || $ > 57) {
                            Te = ($ === 46 ? r + ne.slice(ue + 1) : ne.slice(ue)) + Te, ne = ne.slice(0, ue);
                            break;
                        }
                    }
                }
                H && !M && (ne = e(ne, 1 / 0));
                var ce = ve.length + ne.length + Te.length, Ae = ce < B ? new Array(B - ce + 1).join(y) : "";
                switch(H && M && (ne = e(Ae + ne, Ae.length ? B - Te.length : 1 / 0), Ae = ""), v){
                    case "<":
                        ne = ve + ne + Te + Ae;
                        break;
                    case "=":
                        ne = ve + Ae + ne + Te;
                        break;
                    case "^":
                        ne = Ae.slice(0, ce = Ae.length >> 1) + ve + ne + Te + Ae.slice(ce);
                        break;
                    default:
                        ne = Ae + ve + ne + Te;
                        break;
                }
                return a(ne);
            }
            return fe.toString = function() {
                return _ + "";
            }, fe;
        }
        function p(_, y) {
            var v = d((_ = Kc(_), _.type = "f", _)), S = Math.max(-8, Math.min(8, Math.floor(ea(y) / 3))) * 3, E = Math.pow(10, -S), M = Vv[8 + S / 3];
            return function(B) {
                return v(E * B) + M;
            };
        }
        return {
            format: d,
            formatPrefix: p
        };
    }
    var fc, z1, V1;
    eB({
        thousands: ",",
        grouping: [
            3
        ],
        currency: [
            "$",
            ""
        ]
    });
    function eB(n) {
        return fc = JU(n), z1 = fc.format, V1 = fc.formatPrefix, fc;
    }
    function tB(n) {
        return Math.max(0, -ea(Math.abs(n)));
    }
    function nB(n, e) {
        return Math.max(0, Math.max(-8, Math.min(8, Math.floor(ea(e) / 3))) * 3 - ea(Math.abs(n)));
    }
    function iB(n, e) {
        return n = Math.abs(n), e = Math.abs(e) - n, Math.max(0, ea(e) - ea(n)) + 1;
    }
    function rB(n, e, t, i) {
        var r = dU(n, e, t), a;
        switch(i = Kc(i ?? ",f"), i.type){
            case "s":
                {
                    var l = Math.max(Math.abs(n), Math.abs(e));
                    return i.precision == null && !isNaN(a = nB(r, l)) && (i.precision = a), V1(i, l);
                }
            case "":
            case "e":
            case "g":
            case "p":
            case "r":
                {
                    i.precision == null && !isNaN(a = iB(r, Math.max(Math.abs(n), Math.abs(e)))) && (i.precision = a - (i.type === "e"));
                    break;
                }
            case "f":
            case "%":
                {
                    i.precision == null && !isNaN(a = tB(r)) && (i.precision = a - (i.type === "%") * 2);
                    break;
                }
        }
        return z1(i);
    }
    function sB(n) {
        var e = n.domain;
        return n.ticks = function(t) {
            var i = e();
            return hU(i[0], i[i.length - 1], t ?? 10);
        }, n.tickFormat = function(t, i) {
            var r = e();
            return rB(r[0], r[r.length - 1], t ?? 10, i);
        }, n.nice = function(t) {
            t == null && (t = 10);
            var i = e(), r = 0, a = i.length - 1, l = i[r], u = i[a], h, d, p = 10;
            for(u < l && (d = l, l = u, u = d, d = r, r = a, a = d); p-- > 0;){
                if (d = Qd(l, u, t), d === h) return i[r] = l, i[a] = u, e(i);
                if (d > 0) l = Math.floor(l / d) * d, u = Math.ceil(u / d) * d;
                else if (d < 0) l = Math.ceil(l * d) / d, u = Math.floor(u * d) / d;
                else break;
                h = d;
            }
            return n;
        }, n;
    }
    function ko() {
        var n = XU();
        return n.copy = function() {
            return WU(n, ko());
        }, gU.apply(n, arguments), sB(n);
    }
    const pn = [
        1,
        25e4,
        5e5,
        7e5,
        9e5,
        15e5,
        2e6
    ], H1 = [
        [
            26,
            35,
            126,
            250
        ],
        [
            40,
            53,
            147,
            250
        ],
        [
            48,
            63,
            159,
            250
        ],
        [
            57,
            73,
            171,
            250
        ],
        [
            67,
            160,
            71,
            250
        ],
        [
            139,
            195,
            74,
            250
        ]
    ], j1 = [
        [
            247,
            37,
            133,
            250
        ],
        [
            114,
            9,
            183,
            250
        ],
        [
            58,
            12,
            163,
            250
        ],
        [
            67,
            97,
            238,
            250
        ],
        [
            76,
            201,
            240,
            250
        ],
        [
            136,
            220,
            235,
            250
        ]
    ], W1 = [
        [
            105,
            47,
            221,
            250
        ],
        [
            79,
            37,
            151,
            250
        ],
        [
            158,
            0,
            89,
            250
        ],
        [
            255,
            0,
            84,
            250
        ],
        [
            255,
            84,
            0,
            250
        ],
        [
            255,
            189,
            0,
            250
        ]
    ], $1 = [
        [
            106,
            90,
            156,
            250
        ],
        [
            145,
            101,
            202,
            250
        ],
        [
            113,
            104,
            168,
            250
        ],
        [
            141,
            137,
            184,
            250
        ],
        [
            169,
            180,
            202,
            250
        ],
        [
            202,
            196,
            217,
            250
        ]
    ], hi = {
        BrightSpectrum: [
            [
                1,
                152,
                189,
                180
            ],
            [
                73,
                227,
                206,
                180
            ],
            [
                216,
                254,
                181,
                180
            ],
            [
                254,
                237,
                177,
                180
            ],
            [
                254,
                173,
                84,
                180
            ],
            [
                209,
                55,
                78,
                180
            ]
        ],
        DeepMauve: [
            [
                221,
                28,
                119,
                250
            ],
            [
                152,
                0,
                67,
                250
            ],
            [
                223,
                101,
                176,
                250
            ],
            [
                201,
                148,
                199,
                250
            ],
            [
                212,
                185,
                218,
                250
            ],
            [
                241,
                238,
                246,
                250
            ]
        ],
        TwilightBlue: [
            [
                136,
                86,
                167,
                250
            ],
            [
                129,
                15,
                124,
                250
            ],
            [
                140,
                150,
                198,
                250
            ],
            [
                158,
                188,
                218,
                250
            ],
            [
                191,
                211,
                230,
                250
            ],
            [
                237,
                248,
                251,
                250
            ]
        ],
        MarineTeal: [
            [
                37,
                52,
                148,
                250
            ],
            [
                44,
                127,
                184,
                250
            ],
            [
                65,
                182,
                196,
                250
            ],
            [
                127,
                205,
                187,
                250
            ],
            [
                199,
                233,
                180,
                250
            ],
            [
                255,
                255,
                204,
                250
            ]
        ]
    }, tg = ko().domain(pn).range(H1), X1 = ko().domain(pn).range(j1), Y1 = ko().domain(pn).range(W1), q1 = ko().domain(pn).range($1), Is = {
        ElectricViolet: {
            displayName: "Speed Cinema",
            domain: pn,
            colorRange: H1,
            scaleFunction: tg,
            layerType: "scatterplot"
        },
        VividGem: {
            displayName: "Vivid Gem",
            domain: pn,
            colorRange: j1,
            scaleFunction: X1,
            layerType: "scatterplot"
        },
        InfernoLava: {
            displayName: "Inferno Lava",
            domain: pn,
            colorRange: W1,
            scaleFunction: Y1,
            layerType: "scatterplot"
        },
        MutedStone: {
            displayName: "Muted Stone",
            domain: pn,
            colorRange: $1,
            scaleFunction: q1,
            layerType: "scatterplot"
        },
        BrightSpectrum: {
            displayName: "Bright Spectrum",
            domain: pn,
            colorRange: hi.BrightSpectrum,
            layerType: "hexagon-heatmap"
        },
        DeepMauve: {
            displayName: "Deep Mauve",
            domain: pn,
            colorRange: hi.DeepMauve,
            layerType: "hexagon-heatmap"
        },
        TwilightBlue: {
            displayName: "Twilight Blue",
            domain: pn,
            colorRange: hi.TwilightBlue,
            layerType: "hexagon-heatmap"
        },
        MarineTeal: {
            displayName: "Marine Teal",
            domain: pn,
            colorRange: hi.MarineTeal,
            layerType: "hexagon-heatmap"
        }
    }, aB = ()=>Q.useMemo(()=>{
            const n = "https://raw.githubusercontent.com/Kirman442/deckgl/main/ookla/";
            return [
                `${n}albania_data_zstd10.parquet`,
                `${n}andorra_data_zstd10.parquet`,
                `${n}austria_data_zstd10.parquet`,
                `${n}belgium_data_zstd10.parquet`,
                `${n}bosnia_and_herzegovina_data_zstd10.parquet`,
                `${n}bulgaria_data_zstd10.parquet`,
                `${n}croatia_data_zstd10.parquet`,
                `${n}cyprus_data_zstd10.parquet`,
                `${n}czechia_data_zstd10.parquet`,
                `${n}france_data_zstd10.parquet`,
                `${n}germany_data_zstd10.parquet`,
                `${n}iceland_data_zstd10.parquet`,
                `${n}ireland_data_zstd10.parquet`,
                `${n}italy_data_zstd10.parquet`,
                `${n}liechtenstein_data_zstd10.parquet`,
                `${n}norway_data_zstd10.parquet`,
                `${n}switzerland_data_zstd10.parquet`,
                `${n}turkiye_data_zstd10.parquet`,
                `${n}united_kingdom_data_zstd10.parquet`
            ];
        }, []);
    class oB {
        constructor(e, t = navigator.hardwareConcurrency - 1 || 3, i = {}, r){
            if (this.taskQueue = [], this.workers = [], this.poolSize = Math.max(2, t), typeof e != "function" || !e.prototype) throw console.error("WorkerPool: Invalid Worker constructor provided:", e), new Error("WorkerPool requires a valid Worker constructor function.");
            if (this.workerConstructor = e, this.workerOptions = i, this.taskPromises = new Map, this.nextTaskId = 0, typeof r != "function") throw new Error("WorkerPool requires a valid wasmProcessor function.");
            this.wasmProcessor = r, this.initialize();
        }
        initialize() {
            for(let e = 0; e < this.poolSize; e++){
                const t = `worker-${e}`;
                try {
                    const i = new this.workerConstructor(this.workerOptions), r = {
                        worker: i,
                        busy: !1,
                        id: t,
                        currentTaskId: null
                    };
                    this.workers.push(r), i.onmessage = async (a)=>{
                        const l = a.data;
                        if (!l || typeof l.taskId > "u") {
                            console.error(`WorkerPool (${r.id}): Received message without taskId`, l);
                            return;
                        }
                        const u = l.taskId, h = this.taskPromises.get(u);
                        try {
                            if (l.type === "WASM_REQUEST") if (this.wasmProcessor) {
                                const d = await this.wasmProcessor(l.payload);
                                if (!d?.buffer) throw new Error("WASM processor did not return an object with a transferable buffer.");
                                i.postMessage({
                                    taskId: u,
                                    type: "WASM_RESPONSE",
                                    payload: d
                                }, [
                                    d.buffer
                                ]);
                            } else throw new Error("WASM Processor not configured or available.");
                            else l.success && l.type === "FINAL_RESULT" ? (h && (h.resolve(l), this.taskPromises.delete(u)), r.busy = !1, r.currentTaskId = null, this.processNextTask()) : l.success ? (h && (h.reject(new Error(`Unknown message type received from worker: ${l.type}`)), this.taskPromises.delete(u)), r.busy = !1, r.currentTaskId = null, this.processNextTask()) : (h && (h.reject(new Error(l.error || `Worker task ${u} failed without specific error message.`)), this.taskPromises.delete(u)), r.busy = !1, r.currentTaskId = null, this.processNextTask());
                        } catch (d) {
                            console.error(`WorkerPool (${r.id}): Error handling message for task ${u}:`, d), h && (h.reject(d instanceof Error ? d : new Error(String(d))), this.taskPromises.delete(u)), r.busy = !1, r.currentTaskId = null, this.processNextTask();
                        }
                    }, i.onerror = (a)=>{
                        console.error(`WorkerPool (${r.id}): Fatal Error EVENT received:`, a);
                        let l = "Unknown fatal error (event logged above).";
                        a.message ? l = a.message : a.error ? (l = a.error.message || a.error.toString(), console.error(`WorkerPool (${r.id}): Nested error object:`, a.error)) : typeof a == "string" && (l = a);
                        const u = r.currentTaskId;
                        if (u !== null) {
                            const h = this.taskPromises.get(u);
                            h && (h.reject(new Error(`Fatal error in worker ${r.id} while processing task ${u}. Message: ${l}`)), this.taskPromises.delete(u));
                        }
                        r.busy = !1, r.currentTaskId = null, this.processNextTask();
                    };
                } catch (i) {
                    console.error(`WorkerPool: Failed to instantiate worker ${t}:`, i);
                }
            }
            this.workers.length === 0 && this.poolSize > 0 && console.error("WorkerPool: Failed to initialize ANY workers!");
        }
        enqueueTask(e) {
            return new Promise((t, i)=>{
                const r = this.nextTaskId++;
                this.taskQueue.push({
                    taskId: r,
                    data: e,
                    resolve: t,
                    reject: i
                }), this.taskPromises.set(r, {
                    resolve: t,
                    reject: i
                }), this.processNextTask();
            });
        }
        processNextTask() {
            if (this.taskQueue.length === 0) return;
            const e = this.workers.find((i)=>!i.busy);
            if (!e) return;
            const t = this.taskQueue.shift();
            e.busy = !0, e.currentTaskId = t.taskId, e.worker.postMessage({
                taskId: t.taskId,
                type: "INITIAL_TASK",
                data: t.data
            });
        }
        terminate() {
            this.workers.forEach(({ worker: e, id: t })=>{
                try {
                    e.terminate();
                } catch (i) {
                    console.error(`WorkerPool: Error terminating worker ${t}:`, i);
                }
            }), this.workers = [], this.taskQueue = [], this.taskPromises.forEach((e)=>e.reject(new Error("WorkerPool terminated"))), this.taskPromises.clear();
        }
    }
    let Hv = !1;
    async function lB(n = 3, e = 500) {
        if (Hv) return console.log("Parquet-wasm already initialized."), !0;
        for(let t = 1; t <= n + 1; t++)try {
            return await pS(), Hv = !0, !0;
        } catch (i) {
            if (console.error(`Attempt ${t} to initialize parquet-wasm failed:`, i), t <= n) console.log(`Waiting ${e}ms before next attempt...`), await new Promise((r)=>setTimeout(r, e));
            else throw console.error("Max retries reached. Failed to initialize parquet-wasm."), i;
        }
        return !1;
    }
    var gd = {
        exports: {}
    }, pd, jv;
    function cB() {
        if (jv) return pd;
        jv = 1;
        var n = "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED";
        return pd = n, pd;
    }
    var md, Wv;
    function uB() {
        if (Wv) return md;
        Wv = 1;
        var n = cB();
        function e() {}
        function t() {}
        return t.resetWarningCache = e, md = function() {
            function i(l, u, h, d, p, _) {
                if (_ !== n) {
                    var y = new Error("Calling PropTypes validators directly is not supported by the `prop-types` package. Use PropTypes.checkPropTypes() to call them. Read more at http://fb.me/use-check-prop-types");
                    throw y.name = "Invariant Violation", y;
                }
            }
            i.isRequired = i;
            function r() {
                return i;
            }
            var a = {
                array: i,
                bigint: i,
                bool: i,
                func: i,
                number: i,
                object: i,
                string: i,
                symbol: i,
                any: i,
                arrayOf: r,
                element: i,
                elementType: i,
                instanceOf: r,
                node: i,
                objectOf: r,
                oneOf: r,
                oneOfType: r,
                shape: r,
                exact: r,
                checkPropTypes: t,
                resetWarningCache: e
            };
            return a.PropTypes = a, a;
        }, md;
    }
    var $v;
    function fB() {
        return $v || ($v = 1, gd.exports = uB()()), gd.exports;
    }
    var hB = fB();
    const li = Xv(hB), K1 = ({ schemeDefinition: n, activeLayerKey: e })=>{
        if (!n || !n.domain || !n.colorRange || n.domain.length !== n.colorRange.length + 1) return null;
        const { displayName: t, domain: i, colorRange: r } = n;
        let a = "Legend";
        (e === "scatterplot" || e === "hexagon" || e === "heatmap") && (a = "Speed Gradient");
        const u = `linear-gradient(to right, ${r.map((h, d)=>{
            const p = h && h.length > 3 ? h[3] / 255 : 1, _ = `rgba(${h[0]}, ${h[1]}, ${h[2]}, ${p})`, y = d / (r.length - 1) * 100;
            return `${_} ${y}%`;
        }).join(", ")})`;
        return be.jsxs("div", {
            className: "color-legend",
            children: [
                " ",
                be.jsxs("p", {
                    className: "dataset text-center",
                    children: [
                        a,
                        " - ",
                        t
                    ]
                }),
                " ",
                be.jsxs("div", {
                    className: "legend-bar-container",
                    children: [
                        be.jsx("div", {
                            className: "legend-gradient-bar",
                            style: {
                                background: u
                            }
                        }),
                        be.jsxs("span", {
                            className: "legend-label-min",
                            children: [
                                i[0],
                                " Mb"
                            ]
                        }),
                        " ",
                        be.jsxs("span", {
                            className: "legend-label-max",
                            children: [
                                i[i.length - 1] / 1e3,
                                " Mb"
                            ]
                        }),
                        " "
                    ]
                })
            ]
        });
    };
    K1.propTypes = {
        schemeDefinition: li.shape({
            displayName: li.string,
            domain: li.arrayOf(li.number).isRequired,
            colorRange: li.arrayOf(li.arrayOf(li.number)).isRequired,
            layerType: li.string
        }),
        activeLayerKey: li.string
    };
    const dB = ({ mapStyle: n, setMapStyle: e, activeColorSchemeKey: t, setActiveColorSchemeKey: i, activeColorHexagonSchemeKey: r, setActiveColorHexagonSchemeKey: a, activeLayerKey: l, setActiveLayerKey: u, totalDataLenght: h })=>{
        const [d, p] = Q.useState(!0), [_, y] = Q.useState(!1), v = (te)=>te ? te >= 1e3 ? `${(te / 1e3).toFixed(1)}K` : te.toString() : "0", S = [
            "hexagon",
            "heatmap",
            "scatterplot"
        ], E = ()=>be.jsx("div", {
                className: "color-scheme-buttons",
                children: S.map((te)=>be.jsx("button", {
                        className: `legend-button ${l === te ? "active" : ""}`,
                        onClick: ()=>H(te),
                        children: te.charAt(0).toUpperCase() + te.slice(1)
                    }, te))
            }), M = ()=>{
            p(!d), d || y(!1);
        }, B = ()=>{
            y(!_), _ || p(!1);
        }, H = (te)=>{
            u(te);
        };
        let O = [], U = null, L = null;
        l === "scatterplot" ? (O = Object.keys(Is).filter((te)=>Is[te].layerType === "scatterplot"), U = i, L = t) : (l === "hexagon" || l === "heatmap") && (O = Object.keys(Is).filter((te)=>Is[te].layerType === "hexagon-heatmap"), U = a, L = r);
        const Z = ()=>O.length === 0 ? null : be.jsx("div", {
                className: "color-scheme-buttons",
                children: O.map((te)=>{
                    const fe = Is[te];
                    return fe ? be.jsx("button", {
                        className: `legend-button ${L === te ? "active" : ""}`,
                        onClick: ()=>U(te),
                        children: fe.displayName
                    }, te) : null;
                })
            });
        let se = null;
        l === "scatterplot" ? se = t : (l === "hexagon" || l === "heatmap") && (se = r);
        const ae = Is[se];
        return be.jsxs("div", {
            className: "panel-container",
            children: [
                be.jsxs("div", {
                    className: "panel-block",
                    children: [
                        be.jsxs("div", {
                            className: "panel-header",
                            onClick: M,
                            children: [
                                be.jsx("div", {
                                    className: "panel-title",
                                    children: "Internet Speed Map"
                                }),
                                be.jsx("div", {
                                    className: "panel-expander",
                                    children: d ? "" : "i"
                                })
                            ]
                        }),
                        d && be.jsxs("div", {
                            className: "panel-content",
                            children: [
                                be.jsxs("div", {
                                    className: "stat-item",
                                    children: [
                                        be.jsx("div", {
                                            className: "stat-label",
                                            children: "Total number of measurements "
                                        }),
                                        be.jsx("div", {
                                            className: "stat-value",
                                            children: v(h)
                                        })
                                    ]
                                }),
                                be.jsxs("div", {
                                    className: "description-block",
                                    children: [
                                        be.jsx("p", {
                                            className: "dataset text-center",
                                            children: "Change color map palette:"
                                        }),
                                        Z(),
                                        be.jsx("p", {
                                            className: "dataset text-center",
                                            children: "Select the layer:"
                                        }),
                                        E(),
                                        be.jsx("p", {
                                            className: "dataset text-center",
                                            children: "Select a map style:"
                                        }),
                                        be.jsx("button", {
                                            className: "legend-button button-center mb-10",
                                            onClick: ()=>e(!n),
                                            children: n ? "With Labels" : "No Labels"
                                        }),
                                        be.jsx(K1, {
                                            schemeDefinition: ae,
                                            activeLayerKey: l
                                        })
                                    ]
                                })
                            ]
                        })
                    ]
                }),
                be.jsxs("div", {
                    className: "panel-block",
                    children: [
                        be.jsxs("div", {
                            className: "panel-header",
                            onClick: B,
                            children: [
                                be.jsx("div", {
                                    className: "panel-title",
                                    children: "Infos zum Datensatz"
                                }),
                                be.jsx("div", {
                                    className: "panel-expander",
                                    children: _ ? "" : "i"
                                })
                            ]
                        }),
                        _ && be.jsx("div", {
                            className: "panel-content",
                            children: be.jsxs("div", {
                                className: "description-block",
                                children: [
                                    be.jsx("h4", {
                                        children: "ber den Datensatz"
                                    }),
                                    be.jsxs("p", {
                                        className: "dataset",
                                        children: [
                                            "Dieser Datensatz enthlt Leistungskennzahlen fr globale mobile Breitbandnetze in Form von Mercator-Kacheln auf Skalenebene 16 (etwa 610,8 Meter mal 610,8 Meter am quator). Upload- und Download-Geschwindigkeiten sowie Latenzzeiten werden mit den Speedtest by Ookla-Apps fr Android und iOS erfasst und fr jede Kachel gemittelt. Die Messungen werden gefiltert, um Ergebnisse mit einer Standortgenauigkeit in GPS-Qualitt zu erhalten.",
                                            be.jsx("br", {}),
                                            be.jsx("br", {}),
                                            " "
                                        ]
                                    }),
                                    be.jsxs("p", {
                                        children: [
                                            "Datenquelle: ",
                                            be.jsx("a", {
                                                href: "https://github.com/teamookla/ookla-open-data",
                                                target: "_blank",
                                                rel: "noopener noreferrer",
                                                children: "Ookla Global Mobile Network"
                                            })
                                        ]
                                    })
                                ]
                            })
                        })
                    ]
                })
            ]
        });
    };
    function gB(n) {
        return new Worker("/mobile-network-map/assets/parquetWorker-BhRC5lqB.js", {
            type: "module",
            name: n?.name
        });
    }
    const pB = {
        longitude: 15.1,
        latitude: 48.9,
        zoom: 4,
        maxZoom: 12,
        minZoom: 4,
        pitch: 30,
        bearing: 0
    };
    function mB() {
        const [n, e] = Q.useState(!0), [t, i] = Q.useState(!1), [r, a] = Q.useState(!0), [l, u] = Q.useState([]), [h, d] = Q.useState(!0), [p, _] = Q.useState(0), [y, v] = Q.useState(0), [S, E] = Q.useState(null), [M, B] = Q.useState(null), [H, O] = Q.useState(0), [U, L] = Q.useState(!0), [Z, se] = Q.useState("scatterplot"), [ae, te] = Q.useState("ElectricViolet"), [fe, ne] = Q.useState("BrightSpectrum"), [ve, Te] = Q.useState(), ue = Q.useRef(!0), Ie = Q.useRef(!1), $ = aB(), ee = Q.useRef(null), ce = Q.useRef({
            src: new Float32Array(0),
            length: 0
        }), Ae = "https://basemaps.cartocdn.com/gl/dark-matter-gl-style/style.json", R = "https://basemaps.cartocdn.com/gl/dark-matter-nolabels-gl-style/style.json", G = Q.useMemo(()=>n ? R : Ae, [
            n
        ]), oe = Q.useMemo(()=>{
            const Pe = {
                ElectricViolet: tg,
                VividGem: X1,
                InfernoLava: Y1,
                MutedStone: q1
            }[ae];
            return Pe || (console.warn(`Unknown color scheme key: ${ae}. Using the default 'blues' scheme.`), tg);
        }, [
            ae
        ]), re = Q.useMemo(()=>{
            const Pe = {
                BrightSpectrum: hi.BrightSpectrum,
                DeepMauve: hi.DeepMauve,
                TwilightBlue: hi.TwilightBlue,
                MarineTeal: hi.MarineTeal
            }[fe];
            return Pe || (console.warn(`Unknown color scheme key: ${fe}. Using the default 'blues' scheme.`), hi.MarineTeal);
        }, [
            fe
        ]), de = Q.useMemo(()=>{
            if (l.length === 0 || l[0].length === 0) return [];
            const Re = {
                data: l[0],
                getPosition: (qe, { index: Wt, data: Mn, target: $t })=>($t[0] = Mn.src[Wt * 6], $t[1] = Mn.src[Wt * 6 + 1], $t[2] = 0, $t),
                colorRange: re,
                updateTriggers: {
                    elevationScale: [
                        H
                    ],
                    colorRange: re
                }
            }, Pe = [];
            return Z === "hexagon" ? Pe.push(new qg({
                id: "hexagon-layer",
                ...Re,
                coverage: .9,
                gpuAggregation: !0,
                radius: 1e3,
                upperPercentile: 1e3,
                material: {
                    ambient: .94,
                    diffuse: .4,
                    shininess: 32
                }
            })) : Z === "heatmap" ? Pe.push(new Kg({
                id: "heatmap-layer",
                ...Re,
                radiusPixels: 3,
                intensity: .7,
                threshold: .5
            })) : Z === "scatterplot" && Pe.push(new Xg({
                id: "scatterplot-layer",
                ...Re,
                gpuAggregation: !0,
                filled: !0,
                opacity: 1,
                radiusScale: 200,
                parameters: {
                    depthTest: !1
                },
                getFillColor: (qe, { index: Wt, data: Mn, target: $t })=>($t[0] = Mn.src[Wt * 6 + 3], oe($t * 5)),
                updateTriggers: {
                    getFillColor: [
                        Re.data,
                        oe
                    ]
                }
            })), Pe;
        }, [
            l,
            H,
            Z,
            oe,
            re
        ]), Ne = Q.useCallback(async (Re)=>{
            if (!t) throw new Error("Parquet-WASM module is not initialized yet.");
            try {
                return mS(Re).intoIPCStream();
            } catch (Pe) {
                throw console.error("Main thread: Error during readParquet:", Pe), Pe;
            }
        }, [
            t
        ]);
        Q.useEffect(()=>(ue.current = !0, lB().then((Re)=>{
                Re && ue.current ? (i(!0), E(null)) : ue.current && (console.error("WASM initialization failed after retries."), E("Failed to initialize WASM module. Data cannot be loaded."), i(!1));
            }).catch((Re)=>{
                ue.current && (console.error("WASM initialization threw an error:", Re), E(`WASM Initialization Error: ${Re.message}`), i(!1));
            }), ()=>{
                ue.current = !1, ee.current && (ee.current.terminate(), ee.current = null, console.log("WorkerPool terminated on unmount.")), Ie.current = !1;
            }), []), Q.useEffect(()=>{
            $.length > 0 ? (u([]), ce.current = {
                src: new Float32Array(0),
                length: 0
            }, Te(0), _(0), v($.length), d(!0), E(null), B(null), a(!0), Ie.current = !1, ee.current && (ee.current.terminate(), ee.current = null)) : (u([]), ce.current = {
                src: new Float32Array(0),
                length: 0
            }, Te(0), _(0), v(0), d(!1), E(null), B(null), a(!0), Ie.current = !1, ee.current && (ee.current.terminate(), ee.current = null));
        }, [
            $
        ]), Q.useEffect(()=>{
            if (!t || Ie.current || $.length === 0) return;
            async function Re() {
                if (ue.current) {
                    if (Ie.current = !0, d(!0), _(0), v($.length), E(null), B(null), !ee.current) try {
                        ee.current = new oB(gB, 10, {
                            type: "module"
                        }, Ne);
                    } catch (qe) {
                        console.error("Failed to create WorkerPool:", qe), ue.current && (E(`Failed to create worker pool: ${qe.message}`), d(!1), Ie.current = !1);
                        return;
                    }
                    ce.current = {
                        src: new Float32Array(0),
                        length: 0
                    }, u([]), console.time(" Full Feature Load Time");
                    try {
                        await Pt($), console.timeEnd(" Full Feature Load Time"), ue.current && (console.log(`Finished processing all files. Total records: ${ce.current.length}`), a(!0));
                    } catch (qe) {
                        console.error("Error during file processing:", qe), console.timeEnd(" Full Feature Load Time"), ue.current && (E(`Error processing files: ${qe.message}`), a(!1));
                    } finally{
                        ue.current && d(!1);
                    }
                }
            }
            Re();
            const Pe = setTimeout(()=>{
                ue.current;
            }, 2500);
            return ()=>{
                clearTimeout(Pe);
            };
        }, [
            t,
            $,
            Ne
        ]);
        const _e = Q.useCallback((Re, Pe)=>{
            if (!Pe || Pe.length === 0) return Re;
            if (!Re || Re.length === 0) return Te(Pe.length), Pe;
            const qe = Re.length + Pe.length, Wt = new Float32Array(qe * 6);
            return Wt.set(Re.src), Wt.set(Pe.src, Re.length * 6), Te(qe), {
                src: Wt,
                length: qe
            };
        }, []), Pt = Q.useCallback(async (Re)=>{
            if (!ee.current) throw new Error("Worker pool is not available.");
            const Pe = 8;
            for(let qe = 0; qe < Re.length && ue.current; qe += Pe){
                const Mn = Re.slice(qe, qe + Pe).map((On)=>ee.current.enqueueTask({
                        url: On
                    }).then((Dt)=>ue.current ? (_((Fr)=>Fr + 1), Dt.data) : null).catch((Dt)=>{
                        if (!ue.current) return null;
                        const Fr = Dt.message?.includes("URL:") ? Dt.message.split("URL: ")[1] : On;
                        return _((Ji)=>Ji + 1), B((Ji)=>Ji ? `${Ji}
Failed: ${Fr}` : `Failed: ${Fr}`), null;
                    })), $t = await Promise.all(Mn);
                let Lr = {
                    src: new Float32Array(0),
                    length: 0
                };
                for (const On of $t)On && (Lr = _e(Lr, On));
                if (Lr.length > 0 && ue.current) {
                    const On = _e(ce.current, Lr);
                    ce.current = On, u([
                        On
                    ]);
                } else ue.current && console.log("Batch completed with no new data (or only errors).");
            }
        }, [
            _e
        ]);
        Q.useCallback(({ index: Re })=>{
            if (Re === -1 || !l.length) return null;
            const { src: Pe } = l[0], qe = Re * 6;
            return qe + 5 >= Pe.length ? null : {
                html: `
        <div class="custom-tooltip">
          <b>Download:</b> ${(Pe[qe + 3] / 1e3).toFixed(2)} Mbps<br>
          <b>Upload:</b>  ${(Pe[qe + 4] / 1e3).toFixed(2)} Mbps<br>
          <b>Country Code:</b> ${Pe[qe + 5]}
        </div>
      `,
                style: {
                    backgroundColor: "#1a1a1a",
                    fontSize: "14px",
                    padding: "10px",
                    borderRadius: "4px"
                }
            };
        }, [
            l
        ]);
        const Ze = Q.useMemo(()=>({
                initialViewState: pB,
                controller: !0,
                layers: de,
                useDevicePixels: !1
            }), [
            de
        ]);
        return be.jsxs("div", {
            children: [
                r && be.jsxs(Nk, {
                    ...Ze,
                    effects: [
                        iU
                    ],
                    children: [
                        " ",
                        be.jsx(VS, {
                            mapStyle: G
                        }),
                        be.jsxs("div", {
                            className: "rotate-shift",
                            children: [
                                "Hold down shift to rotate ",
                                be.jsx("br", {}),
                                "Zum Drehen Umschalttaste gedrckt halten"
                            ]
                        }),
                        be.jsx(dB, {
                            showHex: U,
                            setShowHex: L,
                            mapStyle: n,
                            setMapStyle: e,
                            activeColorHexagonSchemeKey: fe,
                            setActiveColorHexagonSchemeKey: ne,
                            activeColorSchemeKey: ae,
                            setActiveColorSchemeKey: te,
                            activeLayerKey: Z,
                            setActiveLayerKey: se,
                            totalDataLenght: ve
                        })
                    ]
                }),
                h && be.jsxs("div", {
                    style: {
                        position: "absolute",
                        top: "20px",
                        left: "50%",
                        transform: "translateX(-50%)",
                        background: "rgba(0,0,0,0.7)",
                        color: "white",
                        padding: "10px",
                        borderRadius: "5px",
                        zIndex: 100
                    },
                    children: [
                        "Downloaded ",
                        p,
                        " of ",
                        y,
                        " files (",
                        Math.round(p / y * 100),
                        "%)"
                    ]
                }),
                S && be.jsxs("div", {
                    style: {
                        position: "absolute",
                        bottom: "10px",
                        left: "10px",
                        background: "rgba(255,0,0,0.7)",
                        color: "white",
                        padding: "10px",
                        borderRadius: "4px",
                        zIndex: 10
                    },
                    children: [
                        "Loading Error: ",
                        S.message
                    ]
                })
            ]
        });
    }
    function _B() {
        return be.jsx(mB, {});
    }
    const yB = ES.createRoot(document.getElementById("root"));
    yB.render(be.jsx(_B, {}));
})();
export { Xv as g, __tla };

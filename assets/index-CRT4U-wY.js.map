{"version":3,"mappings":";;;;;;;;;;;;;;;;;;;;;;;;qDAWA,cAAoBA,KAClB,EAAIC,GAAQC,OAAK,EACjBA,EAAK,UACLC,CAAG;;;;;;;;;;;;;;;;;ACkxBwB,OAAU,EAC3B,iBACA;AAIH,EAAOC,GAASC,EAAOC,EAChC,CACA,IAAIC,MACJ;AAmE0C,CAAI,EACtCC,EAAeC,EAAa,MAAM;AAAA,CAAI,EACxC,IACEC,EAAqBC,EAAiB,EACtCA,EAAiBC,IAAY,MAC7B,CAACA,KAA4B,SAAS;AA0C5B,EACAA,EAAYD,CAAc,EAAE,QAAQ;AAoD3C;AAA2C,EAAOE,EAAE;AA4vWxB,CAAI,EACtC,WAA8C,GACnD,CACA,SAASC,GAAsBC,EAAYC,EAAY,CACrD,OAAAA,EAAaC,GAAkCD,IACxCC,EAAkCF,CAAU,KACrD;ACnpYW;AAEiB;AAAA;AAAA;AAAA,EAK5B,CCzDO;ACVuC;AAAA;AAAA,EAKjCG,GAAiC;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,ECFxCC,GAAmB,CACrB,aACA,iBAEwB,8BACtBC,QAAoB;AAmDuB,CAAI,CAAC;AAAA,EAC9C,OAAQC,EAAG,CAEP,IAAK,wBAEmB,KAAQC,CAA2BC,CAAc,GAErE,YAEC;AChEa;AAAA;AAAA;AAAA;AAAA;AAAA,EAQtB,IAAK,UACD,KAAkB;AAAA;AAAA;AAAA,EAKtB,IAAK,QACD,aAAkB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAStB,IAAK,MAED;AAAkB,EAGtB,QAII,WAAkB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,CAS9B,CACA,CCvCO,SAASC,GAAoBC,MAEhC,EAD0B;AAoBsB,CAAmB,EAEnE,CAAC;AC1B2C,EACpCC,EAAa;AAOyB,CAElD,CACYA,EAAa,YACH,KAAKA,EAAa;AAEtB,CAClB,CACI,OAAOC,CACX,CAKO,UAASC,EAAqBC,KACjC,IAAMF,KAAW,QAAY,SAAU,EAAI,EAC3C;ACrB+B;AAAA,EAAOL,EAAyB;AAAA,EAK7DQ,GAAsC;AAAA,EAMrC;AAkJ8B,CAAI,EAEN,aAAS,CAAK;AAAA,CAAI,EAE3CC,EAAa,CAAE,EACrBC,EAAQ,QAAQC;AAcI;AAAA;AAAA,EAGtBC,GAAoB,CAAE,GAAAC,EAAI;AAAgB,EAC1C,uBAAuBC,EAAM,YAAW,CAAE,EAAE;AAAA;AAAA,EAE5CC,GAAyBC,CAAY,CAAC;AAAA,EACtCF,IAAU;AAA0C;AAAA;AAAA;AAAA,EAIpDG,GAAsBR,CAAU,CAAC;AAAA;AAAA,EAGjB,GAAGS,CAAsB;AAAA,EAE/B,KACZ,CACI,UAAwBZ,CAAqBC,CAAa,OAGpDY;AA0FA,sBACYN,SACZ;AAQkE,EAE5E,CACI,OAAOO,CACX,CAEO,cAAuCN,EAAO,CACjD,KAAIO;AAmBqB;AAAA,EAGzB,OAAIP,IAAU,YACA;AAA4B,GAE1CX,GAAU,GAAGkB,CAAY;AAAA,EAClBlB,CACX,CCnVA,MAAMmB,GAAe,wCACA,oBACd,UAASC,EAAWpB,EAAQqB,OAC/B,EAAMC,EAAQtB,KAAO,SAAM;AAAA,CAAI,EACzBuB,EAAS,CAAE,EACjB,IAAIC,EAAc,GACdC,EAAgB,KACpB,UAAWC,WACP,GAAMC,EAAUD,EAAK,OAAMP,CAAY,EACjCS,UAAsBC,EAAY,EACpCF,MACgBA,CAAQ,CAAC,EACzBH;AASW,CAAI,CAC3B,CCfO,MAAMM,EAAgB,CAEzB,OAAO;ACTgB;AAAA;AAAA,GAKrBC,GAAQ;AAAA,EAAoBC,EAAO,GAiBlC,SAASC,GAAiBZ,EAAS,CACtC,KAAM,CAAE,MAAAa,EAAO;AAUR,KAENC,CAAS,IAAID,CAAK;AAAA,WACZX,CAAM;AAAA;AAAA,IAEbA,CAAM,MAAMa,CAAW;AAAA,EAE3B,CAyBA,SAASC,KAA6B,CAElC;AC9BsF,EAAU,GAC5F;AAAO,EACbC,CAAa,GAAGC,CAAiB,SAAW,CAAK,YAAa,OAAKC,CAAQ;AAAO;AAAA,CAGpF,CACI,MAAMC,EAAQD,EAAQ,OAAS,WAAU,GAAQ,UACjD,OAAOnB,GAAS,KACV;AAe4E,CAAI,EAC1F,CAOA,WAASqB,CAAQC,EAAQC,EAAc,CACnC;ACgBuB,kCACOC,CAAW;AAAA;AAAA,EAE3CC,CAAO;AAAA,eAEDC,KAAO,QAAY;AC7Fg7pE,EAAQ,OAAO,KAAK,QAAQ,MAAM;AAA0E,GAAS,CAAC,GAAG,KAAK,UAAQ,CAAG;AAAiK,EAAQ,KAAK,kBAAqB;AAA8jE,GAAiB,IAAP,MAAiB,OAAP,EAAiB,MAAP;ACIr1uE;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EA2JjBC,GAAO,CAChB,KAAM;AC7JqC;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,ECGzCC,GAAkB,CAEpB,IAAK,CACT,EAIaC,GAAiB,EAC1B,MAAM,eACN,IAAIC,EACJ;ACXkB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAyEhBC,GAAgB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAiETC,GAAU,CACnB,MAAO,CAAE,EACT;AC9I2C;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,ECAlCC,GAAkC;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,ECIzCC,GAAa,EAEbC,GAAe,IAGd,IAAIC,SACV,KAAUA,CAAY,CACnBA,EAAWA,OAAW,CAAW,CAAC,EAAI,UAC3BA;ACZoB;AAAA;AAAA;AAAA;AAAA;AAAA,EAQtBC,GAAsB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,ECRtBC,GAAwB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,ECIxBC,GAAkB,CAC3B,MAAO,CAAE,EACT,QAAM;ACNW;AAAA;AAAA,EAKRC,GAAgB,CACzB,UAAM,GACN,GAAIC;ACPkB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EA+BpBC,GAAU;AAEP;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAkBHX,GAAgB,GACpBW,QAAO;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAUMC,GAAA,CACX,KAAM,eACV;ACpDkC,EAChCC,EAA8B;AAAA,EAC9BC,EAAmB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAsDRC,GAAyB,GACpCC,EAAiB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,ECnEbC,GAAmC;AAUP,EAChCC,EAA8B;AAAA,EAC9BC,EAAmB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,ECTfC,GAAyB,CAAE,EACjC,mBACI,KAAI,eACOC,GAAwBC,EAAI,CAEhC,CAAE,CACb,CACA;ACX0B;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EA6CpBC,GAAgB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAsBPC,GAAA,CACX,KAAM,YACN;ACjE4B;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAa1BC,GAAoB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EA2BpBF,GAAK;AAAA,EACTb,EAAY;AAAA,EACZe,EAAM;AAAA,EAEFC,GAAsB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAyCtB1B,GAAK;AAAA,EACTU,EAAY;AAAA,EACZgB,EAAQ;AAAA,EAEJC,GAAoCC,GAAQC,EAAyB,EACrEC;AA6GkC;AAAA,MAGhC;AAA0B;AAAA,KAG7B,EACD;AC9MoC;AAAA;AAAA,IAIhC;AAA0B;AAAA,IAG1B;AAEe;AAAA;AAAA;AAAA;AAAA;AAAA,KAOvB,CACA,CACA,ECfMC,GAAkB,CAACnB,EAAQ,EAC3BoB,KACF;ACyCuD,EAAoBpF,CAAM,GAC7E,KAAM,CAAE;ACuBK;AAAA;AAAA,EAKfqF,GAAwB,CAC1B,KAAM,mBACFvB;AAKG;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAaLwB,GAAO;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAyBb,SAASC;AClDY;AAAA;AAAA;AAAA,EAMfC,GAAiB,CACnB,KAAM;AAOC;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EA6BLpC,GAAK;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,GAcX,SAASqC;ACpIgB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAgBZC,GAAsB,CAC/B,KAAM,eACN;AClBsB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,ECA1BC,GAA0B;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,ECA1B3F,GAA0B;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,ECMpB4F,GAAgB,CAAC,EAAG,EAAG,EAAG,GAAG,EAC7BC,GAAe,CACjB,sBACA,oBAAqB,WAAe,CAAG,cACvC,YAAmB,KAAM,eAAkB,MAAO,CAAG,KACrD,qBAAyB;ACXR;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAkBRC,GAAiB,CAC1B,KAAM;ACnBK;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,ECAfC,GAAe;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,ECOTH,GAAgB,CAAC,EAAG,EAAG,EAAG,GAAG,EAC7BC,IACF;ACT4B;AAAA;AAAA;AAAA,EAMnBG,GAAoB,CAC7B,KAAM,iBACFlC,CACJ;ACyIyB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,GAYzB,MAAMa,EAAK;AAAA;AAAA;AAAA,EAIbsB,CAAM;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EA2BE7C,EAAgB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EA8BtB,OAVc,UACV;AClNwB;AAAA;AAAA;AAAA;AAAA;AAAA,EAQnB8C,GAA8B,CACvC,KAAM;ACsFgB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EA0DhB9C,EAAgB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAoCtB,cAA2B+C,GACvB,GAAAxB,EACA,GAAAvB,EACA;AChKoC,yBACnBgD,IAAM,GAAKC,EAAM;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAsBnC,SAASC,GAAkB,CAACC,GAAI,EAAGC;AAGL,yBACZJ,QAAWC,CAAM;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EC1D1CI,GAA0B;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAWxBC,EAAqB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,ECZjB5C,GAA0B;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAQnB6C,GAAkB,CAC3B,KAAM,YACN,CAAI7C,GACJ;ACX4B;AAAA;AAAA;AAAA,EAMnB8C,GAAqB,CAC9B,KAAM,aACN;ACmF2B;AAAA;AAAA;AAAA;AAAA;AAAA,IAM3BC,EAAiB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,GAUR,EACb,CAAS,CACT,CACI,iBAAkB,CACd,QAAM,gBACmB,SAAK,gBAAqB;AC/G5C;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,ECDfzD,GAAe;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,ECATU,GAAe;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAQRgD,GAAmB,CAC5B,KAAM;ACTK;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,ECAfC,GAAe;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,ECAfC,GAAe;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,ECAfC,GAAe;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,ECATnD,GAAe;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAQRoD,GAAiB,CAC1B,KAAM,SACN,GAAIpD,OACJ,SAAc,EACV,cAAc;AAQd;AAAA;AAAA,EAKJ;ACqL2B;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAwJbqD,GAAa,IAAI,KAAK,CAACC,EAAU,EAAG,CAAE,KAAM;AAyF5C;AAAA;AAEyC;AACD;AACf;AAAA,QAG/B,MAAO,CACH","names":["node","index","heap","a","prefix","name","suffix","reentry","controlLines","controlStack","namePropDescriptor","RunInRootFrame","sampleLines","x","checkForUnmatchedText","serverText","clientText","normalizeMarkupForTextOrAttribute","MODULE_INJECTORS_FS","MODULE_INJECTORS","REGEX_END_OF_MAIN","key","DECLARATION_INJECT_MARKER","fragmentString","transpileGLSLShader","source","hookFunction","result","normalizeShaderHooks","hookFunctions","FRAGMENT_SHADER_PROLOGUE","allDefines","modules","module","getShaderNameDefine","id","stage","getPlatformShaderDefines","platformInfo","getApplicationDefines","sourceVersionDirective","declInjections","sourceText","moduleSource","IFDEF_REGEXP","preprocess","options","lines","output","conditional","currentDefine","line","matchIf","matchEnd","ENDIF_REGEXP","ShaderAssembler","FS300","FS_GLES","getPassthroughFS","input","inputType","outputValue","channelCountToType","numberedLines","positionIndicator","message","color","padLeft","string","paddedLength","shaderTitle","htmlLog","button","fp32","defaultUniforms","fp64arithmetic","fp64arithmeticShader","fs","picking","lightingUniformsWGSL","MAX_LIGHTS","COLOR_FACTOR","LIGHT_TYPE","PHONG_FS","PHONG_WGSL","gouraudMaterial","layerUniforms","uniformBlock","defines","geometry","PROJECTION_MODE_WGSL_CONSTANTS","UNIT_WGSL_CONSTANTS","projectWGSL","projectWGSLHeader","COORDINATE_SYSTEM_GLSL_CONSTANTS","PROJECTION_MODE_GLSL_CONSTANTS","UNIT_GLSL_CONSTANTS","INITIAL_MODULE_OPTIONS","getUniformsFromViewport","opts","vs","project32","vertex","fragment","getMemoizedViewportCenterPosition","memoize","getViewportCenterPosition","getMemoizedViewProjectionMatrices","DEFAULT_MODULES","SHADER_HOOKS_GLSL","interpolationUniforms","vs64","useFp64","springUniforms","getTransform","scatterplotUniforms","fs$2","DEFAULT_COLOR","defaultProps","columnUniforms","fs$1","binSorterUniforms","userVs","aggregatorTransformUniforms","device","DIST_X","DIST_Y","getHexbinCentroid","i","radius","vs$1","getHexbinCentroidGLSL","hexagonUniforms","binOptionsUniforms","pointToHexbinGLSL","triangleUniforms","weightsFs","maxVs","maxFs","weightUniforms","workerBlob","workerCode"],"ignoreList":[0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63],"sources":["../../node_modules/scheduler/cjs/scheduler.production.js","../../node_modules/react-dom/cjs/react-dom-client.production.js","../../node_modules/@loaders.gl/worker-utils/dist/lib/worker-utils/get-loadable-worker-url.js","../../node_modules/@loaders.gl/worker-utils/dist/lib/worker-utils/get-transfer-list.js","../../node_modules/@luma.gl/shadertools/dist/module-injectors.js","../../node_modules/@luma.gl/shadertools/dist/lib/shader-assembly/shader-injections.js","../../node_modules/@luma.gl/shadertools/dist/lib/shader-assembly/platform-defines.js","../../node_modules/@luma.gl/shadertools/dist/lib/shader-transpiler/transpile-glsl-shader.js","../../node_modules/@luma.gl/shadertools/dist/lib/shader-assembly/shader-hooks.js","../../node_modules/@luma.gl/shadertools/dist/lib/shader-assembly/assemble-shaders.js","../../node_modules/@luma.gl/shadertools/dist/lib/preprocessor/preprocessor.js","../../node_modules/@luma.gl/shadertools/dist/lib/shader-assembler.js","../../node_modules/@luma.gl/shadertools/dist/lib/glsl-utils/shader-utils.js","../../node_modules/@luma.gl/core/dist/adapter-utils/format-compiler-log.js","../../node_modules/@luma.gl/core/dist/adapter/resources/shader.js","../../node_modules/wgsl_reflect/wgsl_reflect.module.js","../../node_modules/@luma.gl/shadertools/dist/modules/math/fp32/fp32.js","../../node_modules/@luma.gl/shadertools/dist/modules/math/fp64/fp64-arithmetic-glsl.js","../../node_modules/@luma.gl/shadertools/dist/modules/math/fp64/fp64.js","../../node_modules/@luma.gl/shadertools/dist/modules/engine/picking/picking.js","../../node_modules/@luma.gl/shadertools/dist/modules/lighting/lights/lighting-uniforms-glsl.js","../../node_modules/@luma.gl/shadertools/dist/modules/lighting/lights/lighting-uniforms-wgsl.js","../../node_modules/@luma.gl/shadertools/dist/modules/lighting/lights/lighting.js","../../node_modules/@luma.gl/shadertools/dist/modules/lighting/phong-material/phong-shaders-glsl.js","../../node_modules/@luma.gl/shadertools/dist/modules/lighting/phong-material/phong-shaders-wgsl.js","../../node_modules/@luma.gl/shadertools/dist/modules/lighting/gouraud-material/gouraud-material.js","../../node_modules/@deck.gl/core/dist/shaderlib/misc/layer-uniforms.js","../../node_modules/@deck.gl/core/dist/shaderlib/misc/geometry.js","../../node_modules/@deck.gl/core/dist/shaderlib/project/project.wgsl.js","../../node_modules/@deck.gl/core/dist/shaderlib/project/project.glsl.js","../../node_modules/@deck.gl/core/dist/shaderlib/project/project.js","../../node_modules/@deck.gl/core/dist/shaderlib/project32/project32.js","../../node_modules/@deck.gl/core/dist/shaderlib/shadow/shadow.js","../../node_modules/@deck.gl/core/dist/shaderlib/picking/picking.js","../../node_modules/@deck.gl/core/dist/shaderlib/index.js","../../node_modules/@luma.gl/webgl/dist/adapter/resources/webgl-shader.js","../../node_modules/@deck.gl/core/dist/transitions/gpu-interpolation-transition.js","../../node_modules/@deck.gl/core/dist/transitions/gpu-spring-transition.js","../../node_modules/@deck.gl/layers/dist/scatterplot-layer/scatterplot-layer-uniforms.js","../../node_modules/@deck.gl/layers/dist/scatterplot-layer/scatterplot-layer-vertex.glsl.js","../../node_modules/@deck.gl/layers/dist/scatterplot-layer/scatterplot-layer-fragment.glsl.js","../../node_modules/@deck.gl/layers/dist/scatterplot-layer/scatterplot-layer.wgsl.js","../../node_modules/@deck.gl/layers/dist/scatterplot-layer/scatterplot-layer.js","../../node_modules/@deck.gl/layers/dist/column-layer/column-layer-uniforms.js","../../node_modules/@deck.gl/layers/dist/column-layer/column-layer-vertex.glsl.js","../../node_modules/@deck.gl/layers/dist/column-layer/column-layer-fragment.glsl.js","../../node_modules/@deck.gl/layers/dist/column-layer/column-layer.js","../../node_modules/@deck.gl/aggregation-layers/dist/common/aggregator/gpu-aggregator/bin-sorter-uniforms.js","../../node_modules/@deck.gl/aggregation-layers/dist/common/aggregator/gpu-aggregator/webgl-bin-sorter.js","../../node_modules/@deck.gl/aggregation-layers/dist/common/aggregator/gpu-aggregator/aggregation-transform-uniforms.js","../../node_modules/@deck.gl/aggregation-layers/dist/common/aggregator/gpu-aggregator/webgl-aggregation-transform.js","../../node_modules/@deck.gl/aggregation-layers/dist/hexagon-layer/hexbin.js","../../node_modules/@deck.gl/aggregation-layers/dist/hexagon-layer/hexagon-cell-layer-vertex.glsl.js","../../node_modules/@deck.gl/aggregation-layers/dist/hexagon-layer/hexagon-layer-uniforms.js","../../node_modules/@deck.gl/aggregation-layers/dist/hexagon-layer/bin-options-uniforms.js","../../node_modules/@deck.gl/aggregation-layers/dist/hexagon-layer/hexagon-layer.js","../../node_modules/@deck.gl/aggregation-layers/dist/heatmap-layer/triangle-layer-vertex.glsl.js","../../node_modules/@deck.gl/aggregation-layers/dist/heatmap-layer/triangle-layer-fragment.glsl.js","../../node_modules/@deck.gl/aggregation-layers/dist/heatmap-layer/triangle-layer-uniforms.js","../../node_modules/@deck.gl/aggregation-layers/dist/heatmap-layer/weights-vs.glsl.js","../../node_modules/@deck.gl/aggregation-layers/dist/heatmap-layer/weights-fs.glsl.js","../../node_modules/@deck.gl/aggregation-layers/dist/heatmap-layer/max-vs.glsl.js","../../node_modules/@deck.gl/aggregation-layers/dist/heatmap-layer/max-fs.glsl.js","../../node_modules/@deck.gl/aggregation-layers/dist/heatmap-layer/heatmap-layer-uniforms.js","../../src/components/ParquetBinaryMap.jsx"],"sourcesContent":["/**\n * @license React\n * scheduler.production.js\n *\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n\"use strict\";\nfunction push(heap, node) {\n  var index = heap.length;\n  heap.push(node);\n  a: for (; 0 < index; ) {\n    var parentIndex = (index - 1) >>> 1,\n      parent = heap[parentIndex];\n    if (0 < compare(parent, node))\n      (heap[parentIndex] = node), (heap[index] = parent), (index = parentIndex);\n    else break a;\n  }\n}\nfunction peek(heap) {\n  return 0 === heap.length ? null : heap[0];\n}\nfunction pop(heap) {\n  if (0 === heap.length) return null;\n  var first = heap[0],\n    last = heap.pop();\n  if (last !== first) {\n    heap[0] = last;\n    a: for (\n      var index = 0, length = heap.length, halfLength = length >>> 1;\n      index < halfLength;\n\n    ) {\n      var leftIndex = 2 * (index + 1) - 1,\n        left = heap[leftIndex],\n        rightIndex = leftIndex + 1,\n        right = heap[rightIndex];\n      if (0 > compare(left, last))\n        rightIndex < length && 0 > compare(right, left)\n          ? ((heap[index] = right),\n            (heap[rightIndex] = last),\n            (index = rightIndex))\n          : ((heap[index] = left),\n            (heap[leftIndex] = last),\n            (index = leftIndex));\n      else if (rightIndex < length && 0 > compare(right, last))\n        (heap[index] = right), (heap[rightIndex] = last), (index = rightIndex);\n      else break a;\n    }\n  }\n  return first;\n}\nfunction compare(a, b) {\n  var diff = a.sortIndex - b.sortIndex;\n  return 0 !== diff ? diff : a.id - b.id;\n}\nexports.unstable_now = void 0;\nif (\"object\" === typeof performance && \"function\" === typeof performance.now) {\n  var localPerformance = performance;\n  exports.unstable_now = function () {\n    return localPerformance.now();\n  };\n} else {\n  var localDate = Date,\n    initialTime = localDate.now();\n  exports.unstable_now = function () {\n    return localDate.now() - initialTime;\n  };\n}\nvar taskQueue = [],\n  timerQueue = [],\n  taskIdCounter = 1,\n  currentTask = null,\n  currentPriorityLevel = 3,\n  isPerformingWork = !1,\n  isHostCallbackScheduled = !1,\n  isHostTimeoutScheduled = !1,\n  needsPaint = !1,\n  localSetTimeout = \"function\" === typeof setTimeout ? setTimeout : null,\n  localClearTimeout = \"function\" === typeof clearTimeout ? clearTimeout : null,\n  localSetImmediate = \"undefined\" !== typeof setImmediate ? setImmediate : null;\nfunction advanceTimers(currentTime) {\n  for (var timer = peek(timerQueue); null !== timer; ) {\n    if (null === timer.callback) pop(timerQueue);\n    else if (timer.startTime <= currentTime)\n      pop(timerQueue),\n        (timer.sortIndex = timer.expirationTime),\n        push(taskQueue, timer);\n    else break;\n    timer = peek(timerQueue);\n  }\n}\nfunction handleTimeout(currentTime) {\n  isHostTimeoutScheduled = !1;\n  advanceTimers(currentTime);\n  if (!isHostCallbackScheduled)\n    if (null !== peek(taskQueue))\n      (isHostCallbackScheduled = !0),\n        isMessageLoopRunning ||\n          ((isMessageLoopRunning = !0), schedulePerformWorkUntilDeadline());\n    else {\n      var firstTimer = peek(timerQueue);\n      null !== firstTimer &&\n        requestHostTimeout(handleTimeout, firstTimer.startTime - currentTime);\n    }\n}\nvar isMessageLoopRunning = !1,\n  taskTimeoutID = -1,\n  frameInterval = 5,\n  startTime = -1;\nfunction shouldYieldToHost() {\n  return needsPaint\n    ? !0\n    : exports.unstable_now() - startTime < frameInterval\n      ? !1\n      : !0;\n}\nfunction performWorkUntilDeadline() {\n  needsPaint = !1;\n  if (isMessageLoopRunning) {\n    var currentTime = exports.unstable_now();\n    startTime = currentTime;\n    var hasMoreWork = !0;\n    try {\n      a: {\n        isHostCallbackScheduled = !1;\n        isHostTimeoutScheduled &&\n          ((isHostTimeoutScheduled = !1),\n          localClearTimeout(taskTimeoutID),\n          (taskTimeoutID = -1));\n        isPerformingWork = !0;\n        var previousPriorityLevel = currentPriorityLevel;\n        try {\n          b: {\n            advanceTimers(currentTime);\n            for (\n              currentTask = peek(taskQueue);\n              null !== currentTask &&\n              !(\n                currentTask.expirationTime > currentTime && shouldYieldToHost()\n              );\n\n            ) {\n              var callback = currentTask.callback;\n              if (\"function\" === typeof callback) {\n                currentTask.callback = null;\n                currentPriorityLevel = currentTask.priorityLevel;\n                var continuationCallback = callback(\n                  currentTask.expirationTime <= currentTime\n                );\n                currentTime = exports.unstable_now();\n                if (\"function\" === typeof continuationCallback) {\n                  currentTask.callback = continuationCallback;\n                  advanceTimers(currentTime);\n                  hasMoreWork = !0;\n                  break b;\n                }\n                currentTask === peek(taskQueue) && pop(taskQueue);\n                advanceTimers(currentTime);\n              } else pop(taskQueue);\n              currentTask = peek(taskQueue);\n            }\n            if (null !== currentTask) hasMoreWork = !0;\n            else {\n              var firstTimer = peek(timerQueue);\n              null !== firstTimer &&\n                requestHostTimeout(\n                  handleTimeout,\n                  firstTimer.startTime - currentTime\n                );\n              hasMoreWork = !1;\n            }\n          }\n          break a;\n        } finally {\n          (currentTask = null),\n            (currentPriorityLevel = previousPriorityLevel),\n            (isPerformingWork = !1);\n        }\n        hasMoreWork = void 0;\n      }\n    } finally {\n      hasMoreWork\n        ? schedulePerformWorkUntilDeadline()\n        : (isMessageLoopRunning = !1);\n    }\n  }\n}\nvar schedulePerformWorkUntilDeadline;\nif (\"function\" === typeof localSetImmediate)\n  schedulePerformWorkUntilDeadline = function () {\n    localSetImmediate(performWorkUntilDeadline);\n  };\nelse if (\"undefined\" !== typeof MessageChannel) {\n  var channel = new MessageChannel(),\n    port = channel.port2;\n  channel.port1.onmessage = performWorkUntilDeadline;\n  schedulePerformWorkUntilDeadline = function () {\n    port.postMessage(null);\n  };\n} else\n  schedulePerformWorkUntilDeadline = function () {\n    localSetTimeout(performWorkUntilDeadline, 0);\n  };\nfunction requestHostTimeout(callback, ms) {\n  taskTimeoutID = localSetTimeout(function () {\n    callback(exports.unstable_now());\n  }, ms);\n}\nexports.unstable_IdlePriority = 5;\nexports.unstable_ImmediatePriority = 1;\nexports.unstable_LowPriority = 4;\nexports.unstable_NormalPriority = 3;\nexports.unstable_Profiling = null;\nexports.unstable_UserBlockingPriority = 2;\nexports.unstable_cancelCallback = function (task) {\n  task.callback = null;\n};\nexports.unstable_forceFrameRate = function (fps) {\n  0 > fps || 125 < fps\n    ? console.error(\n        \"forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported\"\n      )\n    : (frameInterval = 0 < fps ? Math.floor(1e3 / fps) : 5);\n};\nexports.unstable_getCurrentPriorityLevel = function () {\n  return currentPriorityLevel;\n};\nexports.unstable_next = function (eventHandler) {\n  switch (currentPriorityLevel) {\n    case 1:\n    case 2:\n    case 3:\n      var priorityLevel = 3;\n      break;\n    default:\n      priorityLevel = currentPriorityLevel;\n  }\n  var previousPriorityLevel = currentPriorityLevel;\n  currentPriorityLevel = priorityLevel;\n  try {\n    return eventHandler();\n  } finally {\n    currentPriorityLevel = previousPriorityLevel;\n  }\n};\nexports.unstable_requestPaint = function () {\n  needsPaint = !0;\n};\nexports.unstable_runWithPriority = function (priorityLevel, eventHandler) {\n  switch (priorityLevel) {\n    case 1:\n    case 2:\n    case 3:\n    case 4:\n    case 5:\n      break;\n    default:\n      priorityLevel = 3;\n  }\n  var previousPriorityLevel = currentPriorityLevel;\n  currentPriorityLevel = priorityLevel;\n  try {\n    return eventHandler();\n  } finally {\n    currentPriorityLevel = previousPriorityLevel;\n  }\n};\nexports.unstable_scheduleCallback = function (\n  priorityLevel,\n  callback,\n  options\n) {\n  var currentTime = exports.unstable_now();\n  \"object\" === typeof options && null !== options\n    ? ((options = options.delay),\n      (options =\n        \"number\" === typeof options && 0 < options\n          ? currentTime + options\n          : currentTime))\n    : (options = currentTime);\n  switch (priorityLevel) {\n    case 1:\n      var timeout = -1;\n      break;\n    case 2:\n      timeout = 250;\n      break;\n    case 5:\n      timeout = 1073741823;\n      break;\n    case 4:\n      timeout = 1e4;\n      break;\n    default:\n      timeout = 5e3;\n  }\n  timeout = options + timeout;\n  priorityLevel = {\n    id: taskIdCounter++,\n    callback: callback,\n    priorityLevel: priorityLevel,\n    startTime: options,\n    expirationTime: timeout,\n    sortIndex: -1\n  };\n  options > currentTime\n    ? ((priorityLevel.sortIndex = options),\n      push(timerQueue, priorityLevel),\n      null === peek(taskQueue) &&\n        priorityLevel === peek(timerQueue) &&\n        (isHostTimeoutScheduled\n          ? (localClearTimeout(taskTimeoutID), (taskTimeoutID = -1))\n          : (isHostTimeoutScheduled = !0),\n        requestHostTimeout(handleTimeout, options - currentTime)))\n    : ((priorityLevel.sortIndex = timeout),\n      push(taskQueue, priorityLevel),\n      isHostCallbackScheduled ||\n        isPerformingWork ||\n        ((isHostCallbackScheduled = !0),\n        isMessageLoopRunning ||\n          ((isMessageLoopRunning = !0), schedulePerformWorkUntilDeadline())));\n  return priorityLevel;\n};\nexports.unstable_shouldYield = shouldYieldToHost;\nexports.unstable_wrapCallback = function (callback) {\n  var parentPriorityLevel = currentPriorityLevel;\n  return function () {\n    var previousPriorityLevel = currentPriorityLevel;\n    currentPriorityLevel = parentPriorityLevel;\n    try {\n      return callback.apply(this, arguments);\n    } finally {\n      currentPriorityLevel = previousPriorityLevel;\n    }\n  };\n};\n","/**\n * @license React\n * react-dom-client.production.js\n *\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n/*\n Modernizr 3.0.0pre (Custom Build) | MIT\n*/\n\"use strict\";\nvar Scheduler = require(\"scheduler\"),\n  React = require(\"react\"),\n  ReactDOM = require(\"react-dom\");\nfunction formatProdErrorMessage(code) {\n  var url = \"https://react.dev/errors/\" + code;\n  if (1 < arguments.length) {\n    url += \"?args[]=\" + encodeURIComponent(arguments[1]);\n    for (var i = 2; i < arguments.length; i++)\n      url += \"&args[]=\" + encodeURIComponent(arguments[i]);\n  }\n  return (\n    \"Minified React error #\" +\n    code +\n    \"; visit \" +\n    url +\n    \" for the full message or use the non-minified dev environment for full errors and additional helpful warnings.\"\n  );\n}\nfunction isValidContainer(node) {\n  return !(\n    !node ||\n    (1 !== node.nodeType && 9 !== node.nodeType && 11 !== node.nodeType)\n  );\n}\nfunction getNearestMountedFiber(fiber) {\n  var node = fiber,\n    nearestMounted = fiber;\n  if (fiber.alternate) for (; node.return; ) node = node.return;\n  else {\n    fiber = node;\n    do\n      (node = fiber),\n        0 !== (node.flags & 4098) && (nearestMounted = node.return),\n        (fiber = node.return);\n    while (fiber);\n  }\n  return 3 === node.tag ? nearestMounted : null;\n}\nfunction getSuspenseInstanceFromFiber(fiber) {\n  if (13 === fiber.tag) {\n    var suspenseState = fiber.memoizedState;\n    null === suspenseState &&\n      ((fiber = fiber.alternate),\n      null !== fiber && (suspenseState = fiber.memoizedState));\n    if (null !== suspenseState) return suspenseState.dehydrated;\n  }\n  return null;\n}\nfunction assertIsMounted(fiber) {\n  if (getNearestMountedFiber(fiber) !== fiber)\n    throw Error(formatProdErrorMessage(188));\n}\nfunction findCurrentFiberUsingSlowPath(fiber) {\n  var alternate = fiber.alternate;\n  if (!alternate) {\n    alternate = getNearestMountedFiber(fiber);\n    if (null === alternate) throw Error(formatProdErrorMessage(188));\n    return alternate !== fiber ? null : fiber;\n  }\n  for (var a = fiber, b = alternate; ; ) {\n    var parentA = a.return;\n    if (null === parentA) break;\n    var parentB = parentA.alternate;\n    if (null === parentB) {\n      b = parentA.return;\n      if (null !== b) {\n        a = b;\n        continue;\n      }\n      break;\n    }\n    if (parentA.child === parentB.child) {\n      for (parentB = parentA.child; parentB; ) {\n        if (parentB === a) return assertIsMounted(parentA), fiber;\n        if (parentB === b) return assertIsMounted(parentA), alternate;\n        parentB = parentB.sibling;\n      }\n      throw Error(formatProdErrorMessage(188));\n    }\n    if (a.return !== b.return) (a = parentA), (b = parentB);\n    else {\n      for (var didFindChild = !1, child$0 = parentA.child; child$0; ) {\n        if (child$0 === a) {\n          didFindChild = !0;\n          a = parentA;\n          b = parentB;\n          break;\n        }\n        if (child$0 === b) {\n          didFindChild = !0;\n          b = parentA;\n          a = parentB;\n          break;\n        }\n        child$0 = child$0.sibling;\n      }\n      if (!didFindChild) {\n        for (child$0 = parentB.child; child$0; ) {\n          if (child$0 === a) {\n            didFindChild = !0;\n            a = parentB;\n            b = parentA;\n            break;\n          }\n          if (child$0 === b) {\n            didFindChild = !0;\n            b = parentB;\n            a = parentA;\n            break;\n          }\n          child$0 = child$0.sibling;\n        }\n        if (!didFindChild) throw Error(formatProdErrorMessage(189));\n      }\n    }\n    if (a.alternate !== b) throw Error(formatProdErrorMessage(190));\n  }\n  if (3 !== a.tag) throw Error(formatProdErrorMessage(188));\n  return a.stateNode.current === a ? fiber : alternate;\n}\nfunction findCurrentHostFiberImpl(node) {\n  var tag = node.tag;\n  if (5 === tag || 26 === tag || 27 === tag || 6 === tag) return node;\n  for (node = node.child; null !== node; ) {\n    tag = findCurrentHostFiberImpl(node);\n    if (null !== tag) return tag;\n    node = node.sibling;\n  }\n  return null;\n}\nvar assign = Object.assign,\n  REACT_LEGACY_ELEMENT_TYPE = Symbol.for(\"react.element\"),\n  REACT_ELEMENT_TYPE = Symbol.for(\"react.transitional.element\"),\n  REACT_PORTAL_TYPE = Symbol.for(\"react.portal\"),\n  REACT_FRAGMENT_TYPE = Symbol.for(\"react.fragment\"),\n  REACT_STRICT_MODE_TYPE = Symbol.for(\"react.strict_mode\"),\n  REACT_PROFILER_TYPE = Symbol.for(\"react.profiler\"),\n  REACT_PROVIDER_TYPE = Symbol.for(\"react.provider\"),\n  REACT_CONSUMER_TYPE = Symbol.for(\"react.consumer\"),\n  REACT_CONTEXT_TYPE = Symbol.for(\"react.context\"),\n  REACT_FORWARD_REF_TYPE = Symbol.for(\"react.forward_ref\"),\n  REACT_SUSPENSE_TYPE = Symbol.for(\"react.suspense\"),\n  REACT_SUSPENSE_LIST_TYPE = Symbol.for(\"react.suspense_list\"),\n  REACT_MEMO_TYPE = Symbol.for(\"react.memo\"),\n  REACT_LAZY_TYPE = Symbol.for(\"react.lazy\");\nSymbol.for(\"react.scope\");\nvar REACT_ACTIVITY_TYPE = Symbol.for(\"react.activity\");\nSymbol.for(\"react.legacy_hidden\");\nSymbol.for(\"react.tracing_marker\");\nvar REACT_MEMO_CACHE_SENTINEL = Symbol.for(\"react.memo_cache_sentinel\");\nSymbol.for(\"react.view_transition\");\nvar MAYBE_ITERATOR_SYMBOL = Symbol.iterator;\nfunction getIteratorFn(maybeIterable) {\n  if (null === maybeIterable || \"object\" !== typeof maybeIterable) return null;\n  maybeIterable =\n    (MAYBE_ITERATOR_SYMBOL && maybeIterable[MAYBE_ITERATOR_SYMBOL]) ||\n    maybeIterable[\"@@iterator\"];\n  return \"function\" === typeof maybeIterable ? maybeIterable : null;\n}\nvar REACT_CLIENT_REFERENCE = Symbol.for(\"react.client.reference\");\nfunction getComponentNameFromType(type) {\n  if (null == type) return null;\n  if (\"function\" === typeof type)\n    return type.$$typeof === REACT_CLIENT_REFERENCE\n      ? null\n      : type.displayName || type.name || null;\n  if (\"string\" === typeof type) return type;\n  switch (type) {\n    case REACT_FRAGMENT_TYPE:\n      return \"Fragment\";\n    case REACT_PROFILER_TYPE:\n      return \"Profiler\";\n    case REACT_STRICT_MODE_TYPE:\n      return \"StrictMode\";\n    case REACT_SUSPENSE_TYPE:\n      return \"Suspense\";\n    case REACT_SUSPENSE_LIST_TYPE:\n      return \"SuspenseList\";\n    case REACT_ACTIVITY_TYPE:\n      return \"Activity\";\n  }\n  if (\"object\" === typeof type)\n    switch (type.$$typeof) {\n      case REACT_PORTAL_TYPE:\n        return \"Portal\";\n      case REACT_CONTEXT_TYPE:\n        return (type.displayName || \"Context\") + \".Provider\";\n      case REACT_CONSUMER_TYPE:\n        return (type._context.displayName || \"Context\") + \".Consumer\";\n      case REACT_FORWARD_REF_TYPE:\n        var innerType = type.render;\n        type = type.displayName;\n        type ||\n          ((type = innerType.displayName || innerType.name || \"\"),\n          (type = \"\" !== type ? \"ForwardRef(\" + type + \")\" : \"ForwardRef\"));\n        return type;\n      case REACT_MEMO_TYPE:\n        return (\n          (innerType = type.displayName || null),\n          null !== innerType\n            ? innerType\n            : getComponentNameFromType(type.type) || \"Memo\"\n        );\n      case REACT_LAZY_TYPE:\n        innerType = type._payload;\n        type = type._init;\n        try {\n          return getComponentNameFromType(type(innerType));\n        } catch (x) {}\n    }\n  return null;\n}\nvar isArrayImpl = Array.isArray,\n  ReactSharedInternals =\n    React.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE,\n  ReactDOMSharedInternals =\n    ReactDOM.__DOM_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE,\n  sharedNotPendingObject = {\n    pending: !1,\n    data: null,\n    method: null,\n    action: null\n  },\n  valueStack = [],\n  index = -1;\nfunction createCursor(defaultValue) {\n  return { current: defaultValue };\n}\nfunction pop(cursor) {\n  0 > index ||\n    ((cursor.current = valueStack[index]), (valueStack[index] = null), index--);\n}\nfunction push(cursor, value) {\n  index++;\n  valueStack[index] = cursor.current;\n  cursor.current = value;\n}\nvar contextStackCursor = createCursor(null),\n  contextFiberStackCursor = createCursor(null),\n  rootInstanceStackCursor = createCursor(null),\n  hostTransitionProviderCursor = createCursor(null);\nfunction pushHostContainer(fiber, nextRootInstance) {\n  push(rootInstanceStackCursor, nextRootInstance);\n  push(contextFiberStackCursor, fiber);\n  push(contextStackCursor, null);\n  switch (nextRootInstance.nodeType) {\n    case 9:\n    case 11:\n      fiber = (fiber = nextRootInstance.documentElement)\n        ? (fiber = fiber.namespaceURI)\n          ? getOwnHostContext(fiber)\n          : 0\n        : 0;\n      break;\n    default:\n      if (\n        ((fiber = nextRootInstance.tagName),\n        (nextRootInstance = nextRootInstance.namespaceURI))\n      )\n        (nextRootInstance = getOwnHostContext(nextRootInstance)),\n          (fiber = getChildHostContextProd(nextRootInstance, fiber));\n      else\n        switch (fiber) {\n          case \"svg\":\n            fiber = 1;\n            break;\n          case \"math\":\n            fiber = 2;\n            break;\n          default:\n            fiber = 0;\n        }\n  }\n  pop(contextStackCursor);\n  push(contextStackCursor, fiber);\n}\nfunction popHostContainer() {\n  pop(contextStackCursor);\n  pop(contextFiberStackCursor);\n  pop(rootInstanceStackCursor);\n}\nfunction pushHostContext(fiber) {\n  null !== fiber.memoizedState && push(hostTransitionProviderCursor, fiber);\n  var context = contextStackCursor.current;\n  var JSCompiler_inline_result = getChildHostContextProd(context, fiber.type);\n  context !== JSCompiler_inline_result &&\n    (push(contextFiberStackCursor, fiber),\n    push(contextStackCursor, JSCompiler_inline_result));\n}\nfunction popHostContext(fiber) {\n  contextFiberStackCursor.current === fiber &&\n    (pop(contextStackCursor), pop(contextFiberStackCursor));\n  hostTransitionProviderCursor.current === fiber &&\n    (pop(hostTransitionProviderCursor),\n    (HostTransitionContext._currentValue = sharedNotPendingObject));\n}\nvar hasOwnProperty = Object.prototype.hasOwnProperty,\n  scheduleCallback$3 = Scheduler.unstable_scheduleCallback,\n  cancelCallback$1 = Scheduler.unstable_cancelCallback,\n  shouldYield = Scheduler.unstable_shouldYield,\n  requestPaint = Scheduler.unstable_requestPaint,\n  now = Scheduler.unstable_now,\n  getCurrentPriorityLevel = Scheduler.unstable_getCurrentPriorityLevel,\n  ImmediatePriority = Scheduler.unstable_ImmediatePriority,\n  UserBlockingPriority = Scheduler.unstable_UserBlockingPriority,\n  NormalPriority$1 = Scheduler.unstable_NormalPriority,\n  LowPriority = Scheduler.unstable_LowPriority,\n  IdlePriority = Scheduler.unstable_IdlePriority,\n  log$1 = Scheduler.log,\n  unstable_setDisableYieldValue = Scheduler.unstable_setDisableYieldValue,\n  rendererID = null,\n  injectedHook = null;\nfunction setIsStrictModeForDevtools(newIsStrictMode) {\n  \"function\" === typeof log$1 && unstable_setDisableYieldValue(newIsStrictMode);\n  if (injectedHook && \"function\" === typeof injectedHook.setStrictMode)\n    try {\n      injectedHook.setStrictMode(rendererID, newIsStrictMode);\n    } catch (err) {}\n}\nvar clz32 = Math.clz32 ? Math.clz32 : clz32Fallback,\n  log = Math.log,\n  LN2 = Math.LN2;\nfunction clz32Fallback(x) {\n  x >>>= 0;\n  return 0 === x ? 32 : (31 - ((log(x) / LN2) | 0)) | 0;\n}\nvar nextTransitionLane = 256,\n  nextRetryLane = 4194304;\nfunction getHighestPriorityLanes(lanes) {\n  var pendingSyncLanes = lanes & 42;\n  if (0 !== pendingSyncLanes) return pendingSyncLanes;\n  switch (lanes & -lanes) {\n    case 1:\n      return 1;\n    case 2:\n      return 2;\n    case 4:\n      return 4;\n    case 8:\n      return 8;\n    case 16:\n      return 16;\n    case 32:\n      return 32;\n    case 64:\n      return 64;\n    case 128:\n      return 128;\n    case 256:\n    case 512:\n    case 1024:\n    case 2048:\n    case 4096:\n    case 8192:\n    case 16384:\n    case 32768:\n    case 65536:\n    case 131072:\n    case 262144:\n    case 524288:\n    case 1048576:\n    case 2097152:\n      return lanes & 4194048;\n    case 4194304:\n    case 8388608:\n    case 16777216:\n    case 33554432:\n      return lanes & 62914560;\n    case 67108864:\n      return 67108864;\n    case 134217728:\n      return 134217728;\n    case 268435456:\n      return 268435456;\n    case 536870912:\n      return 536870912;\n    case 1073741824:\n      return 0;\n    default:\n      return lanes;\n  }\n}\nfunction getNextLanes(root, wipLanes, rootHasPendingCommit) {\n  var pendingLanes = root.pendingLanes;\n  if (0 === pendingLanes) return 0;\n  var nextLanes = 0,\n    suspendedLanes = root.suspendedLanes,\n    pingedLanes = root.pingedLanes;\n  root = root.warmLanes;\n  var nonIdlePendingLanes = pendingLanes & 134217727;\n  0 !== nonIdlePendingLanes\n    ? ((pendingLanes = nonIdlePendingLanes & ~suspendedLanes),\n      0 !== pendingLanes\n        ? (nextLanes = getHighestPriorityLanes(pendingLanes))\n        : ((pingedLanes &= nonIdlePendingLanes),\n          0 !== pingedLanes\n            ? (nextLanes = getHighestPriorityLanes(pingedLanes))\n            : rootHasPendingCommit ||\n              ((rootHasPendingCommit = nonIdlePendingLanes & ~root),\n              0 !== rootHasPendingCommit &&\n                (nextLanes = getHighestPriorityLanes(rootHasPendingCommit)))))\n    : ((nonIdlePendingLanes = pendingLanes & ~suspendedLanes),\n      0 !== nonIdlePendingLanes\n        ? (nextLanes = getHighestPriorityLanes(nonIdlePendingLanes))\n        : 0 !== pingedLanes\n          ? (nextLanes = getHighestPriorityLanes(pingedLanes))\n          : rootHasPendingCommit ||\n            ((rootHasPendingCommit = pendingLanes & ~root),\n            0 !== rootHasPendingCommit &&\n              (nextLanes = getHighestPriorityLanes(rootHasPendingCommit))));\n  return 0 === nextLanes\n    ? 0\n    : 0 !== wipLanes &&\n        wipLanes !== nextLanes &&\n        0 === (wipLanes & suspendedLanes) &&\n        ((suspendedLanes = nextLanes & -nextLanes),\n        (rootHasPendingCommit = wipLanes & -wipLanes),\n        suspendedLanes >= rootHasPendingCommit ||\n          (32 === suspendedLanes && 0 !== (rootHasPendingCommit & 4194048)))\n      ? wipLanes\n      : nextLanes;\n}\nfunction checkIfRootIsPrerendering(root, renderLanes) {\n  return (\n    0 ===\n    (root.pendingLanes &\n      ~(root.suspendedLanes & ~root.pingedLanes) &\n      renderLanes)\n  );\n}\nfunction computeExpirationTime(lane, currentTime) {\n  switch (lane) {\n    case 1:\n    case 2:\n    case 4:\n    case 8:\n    case 64:\n      return currentTime + 250;\n    case 16:\n    case 32:\n    case 128:\n    case 256:\n    case 512:\n    case 1024:\n    case 2048:\n    case 4096:\n    case 8192:\n    case 16384:\n    case 32768:\n    case 65536:\n    case 131072:\n    case 262144:\n    case 524288:\n    case 1048576:\n    case 2097152:\n      return currentTime + 5e3;\n    case 4194304:\n    case 8388608:\n    case 16777216:\n    case 33554432:\n      return -1;\n    case 67108864:\n    case 134217728:\n    case 268435456:\n    case 536870912:\n    case 1073741824:\n      return -1;\n    default:\n      return -1;\n  }\n}\nfunction claimNextTransitionLane() {\n  var lane = nextTransitionLane;\n  nextTransitionLane <<= 1;\n  0 === (nextTransitionLane & 4194048) && (nextTransitionLane = 256);\n  return lane;\n}\nfunction claimNextRetryLane() {\n  var lane = nextRetryLane;\n  nextRetryLane <<= 1;\n  0 === (nextRetryLane & 62914560) && (nextRetryLane = 4194304);\n  return lane;\n}\nfunction createLaneMap(initial) {\n  for (var laneMap = [], i = 0; 31 > i; i++) laneMap.push(initial);\n  return laneMap;\n}\nfunction markRootUpdated$1(root, updateLane) {\n  root.pendingLanes |= updateLane;\n  268435456 !== updateLane &&\n    ((root.suspendedLanes = 0), (root.pingedLanes = 0), (root.warmLanes = 0));\n}\nfunction markRootFinished(\n  root,\n  finishedLanes,\n  remainingLanes,\n  spawnedLane,\n  updatedLanes,\n  suspendedRetryLanes\n) {\n  var previouslyPendingLanes = root.pendingLanes;\n  root.pendingLanes = remainingLanes;\n  root.suspendedLanes = 0;\n  root.pingedLanes = 0;\n  root.warmLanes = 0;\n  root.expiredLanes &= remainingLanes;\n  root.entangledLanes &= remainingLanes;\n  root.errorRecoveryDisabledLanes &= remainingLanes;\n  root.shellSuspendCounter = 0;\n  var entanglements = root.entanglements,\n    expirationTimes = root.expirationTimes,\n    hiddenUpdates = root.hiddenUpdates;\n  for (\n    remainingLanes = previouslyPendingLanes & ~remainingLanes;\n    0 < remainingLanes;\n\n  ) {\n    var index$5 = 31 - clz32(remainingLanes),\n      lane = 1 << index$5;\n    entanglements[index$5] = 0;\n    expirationTimes[index$5] = -1;\n    var hiddenUpdatesForLane = hiddenUpdates[index$5];\n    if (null !== hiddenUpdatesForLane)\n      for (\n        hiddenUpdates[index$5] = null, index$5 = 0;\n        index$5 < hiddenUpdatesForLane.length;\n        index$5++\n      ) {\n        var update = hiddenUpdatesForLane[index$5];\n        null !== update && (update.lane &= -536870913);\n      }\n    remainingLanes &= ~lane;\n  }\n  0 !== spawnedLane && markSpawnedDeferredLane(root, spawnedLane, 0);\n  0 !== suspendedRetryLanes &&\n    0 === updatedLanes &&\n    0 !== root.tag &&\n    (root.suspendedLanes |=\n      suspendedRetryLanes & ~(previouslyPendingLanes & ~finishedLanes));\n}\nfunction markSpawnedDeferredLane(root, spawnedLane, entangledLanes) {\n  root.pendingLanes |= spawnedLane;\n  root.suspendedLanes &= ~spawnedLane;\n  var spawnedLaneIndex = 31 - clz32(spawnedLane);\n  root.entangledLanes |= spawnedLane;\n  root.entanglements[spawnedLaneIndex] =\n    root.entanglements[spawnedLaneIndex] |\n    1073741824 |\n    (entangledLanes & 4194090);\n}\nfunction markRootEntangled(root, entangledLanes) {\n  var rootEntangledLanes = (root.entangledLanes |= entangledLanes);\n  for (root = root.entanglements; rootEntangledLanes; ) {\n    var index$6 = 31 - clz32(rootEntangledLanes),\n      lane = 1 << index$6;\n    (lane & entangledLanes) | (root[index$6] & entangledLanes) &&\n      (root[index$6] |= entangledLanes);\n    rootEntangledLanes &= ~lane;\n  }\n}\nfunction getBumpedLaneForHydrationByLane(lane) {\n  switch (lane) {\n    case 2:\n      lane = 1;\n      break;\n    case 8:\n      lane = 4;\n      break;\n    case 32:\n      lane = 16;\n      break;\n    case 256:\n    case 512:\n    case 1024:\n    case 2048:\n    case 4096:\n    case 8192:\n    case 16384:\n    case 32768:\n    case 65536:\n    case 131072:\n    case 262144:\n    case 524288:\n    case 1048576:\n    case 2097152:\n    case 4194304:\n    case 8388608:\n    case 16777216:\n    case 33554432:\n      lane = 128;\n      break;\n    case 268435456:\n      lane = 134217728;\n      break;\n    default:\n      lane = 0;\n  }\n  return lane;\n}\nfunction lanesToEventPriority(lanes) {\n  lanes &= -lanes;\n  return 2 < lanes\n    ? 8 < lanes\n      ? 0 !== (lanes & 134217727)\n        ? 32\n        : 268435456\n      : 8\n    : 2;\n}\nfunction resolveUpdatePriority() {\n  var updatePriority = ReactDOMSharedInternals.p;\n  if (0 !== updatePriority) return updatePriority;\n  updatePriority = window.event;\n  return void 0 === updatePriority ? 32 : getEventPriority(updatePriority.type);\n}\nfunction runWithPriority(priority, fn) {\n  var previousPriority = ReactDOMSharedInternals.p;\n  try {\n    return (ReactDOMSharedInternals.p = priority), fn();\n  } finally {\n    ReactDOMSharedInternals.p = previousPriority;\n  }\n}\nvar randomKey = Math.random().toString(36).slice(2),\n  internalInstanceKey = \"__reactFiber$\" + randomKey,\n  internalPropsKey = \"__reactProps$\" + randomKey,\n  internalContainerInstanceKey = \"__reactContainer$\" + randomKey,\n  internalEventHandlersKey = \"__reactEvents$\" + randomKey,\n  internalEventHandlerListenersKey = \"__reactListeners$\" + randomKey,\n  internalEventHandlesSetKey = \"__reactHandles$\" + randomKey,\n  internalRootNodeResourcesKey = \"__reactResources$\" + randomKey,\n  internalHoistableMarker = \"__reactMarker$\" + randomKey;\nfunction detachDeletedInstance(node) {\n  delete node[internalInstanceKey];\n  delete node[internalPropsKey];\n  delete node[internalEventHandlersKey];\n  delete node[internalEventHandlerListenersKey];\n  delete node[internalEventHandlesSetKey];\n}\nfunction getClosestInstanceFromNode(targetNode) {\n  var targetInst = targetNode[internalInstanceKey];\n  if (targetInst) return targetInst;\n  for (var parentNode = targetNode.parentNode; parentNode; ) {\n    if (\n      (targetInst =\n        parentNode[internalContainerInstanceKey] ||\n        parentNode[internalInstanceKey])\n    ) {\n      parentNode = targetInst.alternate;\n      if (\n        null !== targetInst.child ||\n        (null !== parentNode && null !== parentNode.child)\n      )\n        for (\n          targetNode = getParentSuspenseInstance(targetNode);\n          null !== targetNode;\n\n        ) {\n          if ((parentNode = targetNode[internalInstanceKey])) return parentNode;\n          targetNode = getParentSuspenseInstance(targetNode);\n        }\n      return targetInst;\n    }\n    targetNode = parentNode;\n    parentNode = targetNode.parentNode;\n  }\n  return null;\n}\nfunction getInstanceFromNode(node) {\n  if (\n    (node = node[internalInstanceKey] || node[internalContainerInstanceKey])\n  ) {\n    var tag = node.tag;\n    if (\n      5 === tag ||\n      6 === tag ||\n      13 === tag ||\n      26 === tag ||\n      27 === tag ||\n      3 === tag\n    )\n      return node;\n  }\n  return null;\n}\nfunction getNodeFromInstance(inst) {\n  var tag = inst.tag;\n  if (5 === tag || 26 === tag || 27 === tag || 6 === tag) return inst.stateNode;\n  throw Error(formatProdErrorMessage(33));\n}\nfunction getResourcesFromRoot(root) {\n  var resources = root[internalRootNodeResourcesKey];\n  resources ||\n    (resources = root[internalRootNodeResourcesKey] =\n      { hoistableStyles: new Map(), hoistableScripts: new Map() });\n  return resources;\n}\nfunction markNodeAsHoistable(node) {\n  node[internalHoistableMarker] = !0;\n}\nvar allNativeEvents = new Set(),\n  registrationNameDependencies = {};\nfunction registerTwoPhaseEvent(registrationName, dependencies) {\n  registerDirectEvent(registrationName, dependencies);\n  registerDirectEvent(registrationName + \"Capture\", dependencies);\n}\nfunction registerDirectEvent(registrationName, dependencies) {\n  registrationNameDependencies[registrationName] = dependencies;\n  for (\n    registrationName = 0;\n    registrationName < dependencies.length;\n    registrationName++\n  )\n    allNativeEvents.add(dependencies[registrationName]);\n}\nvar VALID_ATTRIBUTE_NAME_REGEX = RegExp(\n    \"^[:A-Z_a-z\\\\u00C0-\\\\u00D6\\\\u00D8-\\\\u00F6\\\\u00F8-\\\\u02FF\\\\u0370-\\\\u037D\\\\u037F-\\\\u1FFF\\\\u200C-\\\\u200D\\\\u2070-\\\\u218F\\\\u2C00-\\\\u2FEF\\\\u3001-\\\\uD7FF\\\\uF900-\\\\uFDCF\\\\uFDF0-\\\\uFFFD][:A-Z_a-z\\\\u00C0-\\\\u00D6\\\\u00D8-\\\\u00F6\\\\u00F8-\\\\u02FF\\\\u0370-\\\\u037D\\\\u037F-\\\\u1FFF\\\\u200C-\\\\u200D\\\\u2070-\\\\u218F\\\\u2C00-\\\\u2FEF\\\\u3001-\\\\uD7FF\\\\uF900-\\\\uFDCF\\\\uFDF0-\\\\uFFFD\\\\-.0-9\\\\u00B7\\\\u0300-\\\\u036F\\\\u203F-\\\\u2040]*$\"\n  ),\n  illegalAttributeNameCache = {},\n  validatedAttributeNameCache = {};\nfunction isAttributeNameSafe(attributeName) {\n  if (hasOwnProperty.call(validatedAttributeNameCache, attributeName))\n    return !0;\n  if (hasOwnProperty.call(illegalAttributeNameCache, attributeName)) return !1;\n  if (VALID_ATTRIBUTE_NAME_REGEX.test(attributeName))\n    return (validatedAttributeNameCache[attributeName] = !0);\n  illegalAttributeNameCache[attributeName] = !0;\n  return !1;\n}\nfunction setValueForAttribute(node, name, value) {\n  if (isAttributeNameSafe(name))\n    if (null === value) node.removeAttribute(name);\n    else {\n      switch (typeof value) {\n        case \"undefined\":\n        case \"function\":\n        case \"symbol\":\n          node.removeAttribute(name);\n          return;\n        case \"boolean\":\n          var prefix$8 = name.toLowerCase().slice(0, 5);\n          if (\"data-\" !== prefix$8 && \"aria-\" !== prefix$8) {\n            node.removeAttribute(name);\n            return;\n          }\n      }\n      node.setAttribute(name, \"\" + value);\n    }\n}\nfunction setValueForKnownAttribute(node, name, value) {\n  if (null === value) node.removeAttribute(name);\n  else {\n    switch (typeof value) {\n      case \"undefined\":\n      case \"function\":\n      case \"symbol\":\n      case \"boolean\":\n        node.removeAttribute(name);\n        return;\n    }\n    node.setAttribute(name, \"\" + value);\n  }\n}\nfunction setValueForNamespacedAttribute(node, namespace, name, value) {\n  if (null === value) node.removeAttribute(name);\n  else {\n    switch (typeof value) {\n      case \"undefined\":\n      case \"function\":\n      case \"symbol\":\n      case \"boolean\":\n        node.removeAttribute(name);\n        return;\n    }\n    node.setAttributeNS(namespace, name, \"\" + value);\n  }\n}\nvar prefix, suffix;\nfunction describeBuiltInComponentFrame(name) {\n  if (void 0 === prefix)\n    try {\n      throw Error();\n    } catch (x) {\n      var match = x.stack.trim().match(/\\n( *(at )?)/);\n      prefix = (match && match[1]) || \"\";\n      suffix =\n        -1 < x.stack.indexOf(\"\\n    at\")\n          ? \" (<anonymous>)\"\n          : -1 < x.stack.indexOf(\"@\")\n            ? \"@unknown:0:0\"\n            : \"\";\n    }\n  return \"\\n\" + prefix + name + suffix;\n}\nvar reentry = !1;\nfunction describeNativeComponentFrame(fn, construct) {\n  if (!fn || reentry) return \"\";\n  reentry = !0;\n  var previousPrepareStackTrace = Error.prepareStackTrace;\n  Error.prepareStackTrace = void 0;\n  try {\n    var RunInRootFrame = {\n      DetermineComponentFrameRoot: function () {\n        try {\n          if (construct) {\n            var Fake = function () {\n              throw Error();\n            };\n            Object.defineProperty(Fake.prototype, \"props\", {\n              set: function () {\n                throw Error();\n              }\n            });\n            if (\"object\" === typeof Reflect && Reflect.construct) {\n              try {\n                Reflect.construct(Fake, []);\n              } catch (x) {\n                var control = x;\n              }\n              Reflect.construct(fn, [], Fake);\n            } else {\n              try {\n                Fake.call();\n              } catch (x$9) {\n                control = x$9;\n              }\n              fn.call(Fake.prototype);\n            }\n          } else {\n            try {\n              throw Error();\n            } catch (x$10) {\n              control = x$10;\n            }\n            (Fake = fn()) &&\n              \"function\" === typeof Fake.catch &&\n              Fake.catch(function () {});\n          }\n        } catch (sample) {\n          if (sample && control && \"string\" === typeof sample.stack)\n            return [sample.stack, control.stack];\n        }\n        return [null, null];\n      }\n    };\n    RunInRootFrame.DetermineComponentFrameRoot.displayName =\n      \"DetermineComponentFrameRoot\";\n    var namePropDescriptor = Object.getOwnPropertyDescriptor(\n      RunInRootFrame.DetermineComponentFrameRoot,\n      \"name\"\n    );\n    namePropDescriptor &&\n      namePropDescriptor.configurable &&\n      Object.defineProperty(\n        RunInRootFrame.DetermineComponentFrameRoot,\n        \"name\",\n        { value: \"DetermineComponentFrameRoot\" }\n      );\n    var _RunInRootFrame$Deter = RunInRootFrame.DetermineComponentFrameRoot(),\n      sampleStack = _RunInRootFrame$Deter[0],\n      controlStack = _RunInRootFrame$Deter[1];\n    if (sampleStack && controlStack) {\n      var sampleLines = sampleStack.split(\"\\n\"),\n        controlLines = controlStack.split(\"\\n\");\n      for (\n        namePropDescriptor = RunInRootFrame = 0;\n        RunInRootFrame < sampleLines.length &&\n        !sampleLines[RunInRootFrame].includes(\"DetermineComponentFrameRoot\");\n\n      )\n        RunInRootFrame++;\n      for (\n        ;\n        namePropDescriptor < controlLines.length &&\n        !controlLines[namePropDescriptor].includes(\n          \"DetermineComponentFrameRoot\"\n        );\n\n      )\n        namePropDescriptor++;\n      if (\n        RunInRootFrame === sampleLines.length ||\n        namePropDescriptor === controlLines.length\n      )\n        for (\n          RunInRootFrame = sampleLines.length - 1,\n            namePropDescriptor = controlLines.length - 1;\n          1 <= RunInRootFrame &&\n          0 <= namePropDescriptor &&\n          sampleLines[RunInRootFrame] !== controlLines[namePropDescriptor];\n\n        )\n          namePropDescriptor--;\n      for (\n        ;\n        1 <= RunInRootFrame && 0 <= namePropDescriptor;\n        RunInRootFrame--, namePropDescriptor--\n      )\n        if (sampleLines[RunInRootFrame] !== controlLines[namePropDescriptor]) {\n          if (1 !== RunInRootFrame || 1 !== namePropDescriptor) {\n            do\n              if (\n                (RunInRootFrame--,\n                namePropDescriptor--,\n                0 > namePropDescriptor ||\n                  sampleLines[RunInRootFrame] !==\n                    controlLines[namePropDescriptor])\n              ) {\n                var frame =\n                  \"\\n\" +\n                  sampleLines[RunInRootFrame].replace(\" at new \", \" at \");\n                fn.displayName &&\n                  frame.includes(\"<anonymous>\") &&\n                  (frame = frame.replace(\"<anonymous>\", fn.displayName));\n                return frame;\n              }\n            while (1 <= RunInRootFrame && 0 <= namePropDescriptor);\n          }\n          break;\n        }\n    }\n  } finally {\n    (reentry = !1), (Error.prepareStackTrace = previousPrepareStackTrace);\n  }\n  return (previousPrepareStackTrace = fn ? fn.displayName || fn.name : \"\")\n    ? describeBuiltInComponentFrame(previousPrepareStackTrace)\n    : \"\";\n}\nfunction describeFiber(fiber) {\n  switch (fiber.tag) {\n    case 26:\n    case 27:\n    case 5:\n      return describeBuiltInComponentFrame(fiber.type);\n    case 16:\n      return describeBuiltInComponentFrame(\"Lazy\");\n    case 13:\n      return describeBuiltInComponentFrame(\"Suspense\");\n    case 19:\n      return describeBuiltInComponentFrame(\"SuspenseList\");\n    case 0:\n    case 15:\n      return describeNativeComponentFrame(fiber.type, !1);\n    case 11:\n      return describeNativeComponentFrame(fiber.type.render, !1);\n    case 1:\n      return describeNativeComponentFrame(fiber.type, !0);\n    case 31:\n      return describeBuiltInComponentFrame(\"Activity\");\n    default:\n      return \"\";\n  }\n}\nfunction getStackByFiberInDevAndProd(workInProgress) {\n  try {\n    var info = \"\";\n    do\n      (info += describeFiber(workInProgress)),\n        (workInProgress = workInProgress.return);\n    while (workInProgress);\n    return info;\n  } catch (x) {\n    return \"\\nError generating stack: \" + x.message + \"\\n\" + x.stack;\n  }\n}\nfunction getToStringValue(value) {\n  switch (typeof value) {\n    case \"bigint\":\n    case \"boolean\":\n    case \"number\":\n    case \"string\":\n    case \"undefined\":\n      return value;\n    case \"object\":\n      return value;\n    default:\n      return \"\";\n  }\n}\nfunction isCheckable(elem) {\n  var type = elem.type;\n  return (\n    (elem = elem.nodeName) &&\n    \"input\" === elem.toLowerCase() &&\n    (\"checkbox\" === type || \"radio\" === type)\n  );\n}\nfunction trackValueOnNode(node) {\n  var valueField = isCheckable(node) ? \"checked\" : \"value\",\n    descriptor = Object.getOwnPropertyDescriptor(\n      node.constructor.prototype,\n      valueField\n    ),\n    currentValue = \"\" + node[valueField];\n  if (\n    !node.hasOwnProperty(valueField) &&\n    \"undefined\" !== typeof descriptor &&\n    \"function\" === typeof descriptor.get &&\n    \"function\" === typeof descriptor.set\n  ) {\n    var get = descriptor.get,\n      set = descriptor.set;\n    Object.defineProperty(node, valueField, {\n      configurable: !0,\n      get: function () {\n        return get.call(this);\n      },\n      set: function (value) {\n        currentValue = \"\" + value;\n        set.call(this, value);\n      }\n    });\n    Object.defineProperty(node, valueField, {\n      enumerable: descriptor.enumerable\n    });\n    return {\n      getValue: function () {\n        return currentValue;\n      },\n      setValue: function (value) {\n        currentValue = \"\" + value;\n      },\n      stopTracking: function () {\n        node._valueTracker = null;\n        delete node[valueField];\n      }\n    };\n  }\n}\nfunction track(node) {\n  node._valueTracker || (node._valueTracker = trackValueOnNode(node));\n}\nfunction updateValueIfChanged(node) {\n  if (!node) return !1;\n  var tracker = node._valueTracker;\n  if (!tracker) return !0;\n  var lastValue = tracker.getValue();\n  var value = \"\";\n  node &&\n    (value = isCheckable(node)\n      ? node.checked\n        ? \"true\"\n        : \"false\"\n      : node.value);\n  node = value;\n  return node !== lastValue ? (tracker.setValue(node), !0) : !1;\n}\nfunction getActiveElement(doc) {\n  doc = doc || (\"undefined\" !== typeof document ? document : void 0);\n  if (\"undefined\" === typeof doc) return null;\n  try {\n    return doc.activeElement || doc.body;\n  } catch (e) {\n    return doc.body;\n  }\n}\nvar escapeSelectorAttributeValueInsideDoubleQuotesRegex = /[\\n\"\\\\]/g;\nfunction escapeSelectorAttributeValueInsideDoubleQuotes(value) {\n  return value.replace(\n    escapeSelectorAttributeValueInsideDoubleQuotesRegex,\n    function (ch) {\n      return \"\\\\\" + ch.charCodeAt(0).toString(16) + \" \";\n    }\n  );\n}\nfunction updateInput(\n  element,\n  value,\n  defaultValue,\n  lastDefaultValue,\n  checked,\n  defaultChecked,\n  type,\n  name\n) {\n  element.name = \"\";\n  null != type &&\n  \"function\" !== typeof type &&\n  \"symbol\" !== typeof type &&\n  \"boolean\" !== typeof type\n    ? (element.type = type)\n    : element.removeAttribute(\"type\");\n  if (null != value)\n    if (\"number\" === type) {\n      if ((0 === value && \"\" === element.value) || element.value != value)\n        element.value = \"\" + getToStringValue(value);\n    } else\n      element.value !== \"\" + getToStringValue(value) &&\n        (element.value = \"\" + getToStringValue(value));\n  else\n    (\"submit\" !== type && \"reset\" !== type) || element.removeAttribute(\"value\");\n  null != value\n    ? setDefaultValue(element, type, getToStringValue(value))\n    : null != defaultValue\n      ? setDefaultValue(element, type, getToStringValue(defaultValue))\n      : null != lastDefaultValue && element.removeAttribute(\"value\");\n  null == checked &&\n    null != defaultChecked &&\n    (element.defaultChecked = !!defaultChecked);\n  null != checked &&\n    (element.checked =\n      checked && \"function\" !== typeof checked && \"symbol\" !== typeof checked);\n  null != name &&\n  \"function\" !== typeof name &&\n  \"symbol\" !== typeof name &&\n  \"boolean\" !== typeof name\n    ? (element.name = \"\" + getToStringValue(name))\n    : element.removeAttribute(\"name\");\n}\nfunction initInput(\n  element,\n  value,\n  defaultValue,\n  checked,\n  defaultChecked,\n  type,\n  name,\n  isHydrating\n) {\n  null != type &&\n    \"function\" !== typeof type &&\n    \"symbol\" !== typeof type &&\n    \"boolean\" !== typeof type &&\n    (element.type = type);\n  if (null != value || null != defaultValue) {\n    if (\n      !(\n        (\"submit\" !== type && \"reset\" !== type) ||\n        (void 0 !== value && null !== value)\n      )\n    )\n      return;\n    defaultValue =\n      null != defaultValue ? \"\" + getToStringValue(defaultValue) : \"\";\n    value = null != value ? \"\" + getToStringValue(value) : defaultValue;\n    isHydrating || value === element.value || (element.value = value);\n    element.defaultValue = value;\n  }\n  checked = null != checked ? checked : defaultChecked;\n  checked =\n    \"function\" !== typeof checked && \"symbol\" !== typeof checked && !!checked;\n  element.checked = isHydrating ? element.checked : !!checked;\n  element.defaultChecked = !!checked;\n  null != name &&\n    \"function\" !== typeof name &&\n    \"symbol\" !== typeof name &&\n    \"boolean\" !== typeof name &&\n    (element.name = name);\n}\nfunction setDefaultValue(node, type, value) {\n  (\"number\" === type && getActiveElement(node.ownerDocument) === node) ||\n    node.defaultValue === \"\" + value ||\n    (node.defaultValue = \"\" + value);\n}\nfunction updateOptions(node, multiple, propValue, setDefaultSelected) {\n  node = node.options;\n  if (multiple) {\n    multiple = {};\n    for (var i = 0; i < propValue.length; i++)\n      multiple[\"$\" + propValue[i]] = !0;\n    for (propValue = 0; propValue < node.length; propValue++)\n      (i = multiple.hasOwnProperty(\"$\" + node[propValue].value)),\n        node[propValue].selected !== i && (node[propValue].selected = i),\n        i && setDefaultSelected && (node[propValue].defaultSelected = !0);\n  } else {\n    propValue = \"\" + getToStringValue(propValue);\n    multiple = null;\n    for (i = 0; i < node.length; i++) {\n      if (node[i].value === propValue) {\n        node[i].selected = !0;\n        setDefaultSelected && (node[i].defaultSelected = !0);\n        return;\n      }\n      null !== multiple || node[i].disabled || (multiple = node[i]);\n    }\n    null !== multiple && (multiple.selected = !0);\n  }\n}\nfunction updateTextarea(element, value, defaultValue) {\n  if (\n    null != value &&\n    ((value = \"\" + getToStringValue(value)),\n    value !== element.value && (element.value = value),\n    null == defaultValue)\n  ) {\n    element.defaultValue !== value && (element.defaultValue = value);\n    return;\n  }\n  element.defaultValue =\n    null != defaultValue ? \"\" + getToStringValue(defaultValue) : \"\";\n}\nfunction initTextarea(element, value, defaultValue, children) {\n  if (null == value) {\n    if (null != children) {\n      if (null != defaultValue) throw Error(formatProdErrorMessage(92));\n      if (isArrayImpl(children)) {\n        if (1 < children.length) throw Error(formatProdErrorMessage(93));\n        children = children[0];\n      }\n      defaultValue = children;\n    }\n    null == defaultValue && (defaultValue = \"\");\n    value = defaultValue;\n  }\n  defaultValue = getToStringValue(value);\n  element.defaultValue = defaultValue;\n  children = element.textContent;\n  children === defaultValue &&\n    \"\" !== children &&\n    null !== children &&\n    (element.value = children);\n}\nfunction setTextContent(node, text) {\n  if (text) {\n    var firstChild = node.firstChild;\n    if (\n      firstChild &&\n      firstChild === node.lastChild &&\n      3 === firstChild.nodeType\n    ) {\n      firstChild.nodeValue = text;\n      return;\n    }\n  }\n  node.textContent = text;\n}\nvar unitlessNumbers = new Set(\n  \"animationIterationCount aspectRatio borderImageOutset borderImageSlice borderImageWidth boxFlex boxFlexGroup boxOrdinalGroup columnCount columns flex flexGrow flexPositive flexShrink flexNegative flexOrder gridArea gridRow gridRowEnd gridRowSpan gridRowStart gridColumn gridColumnEnd gridColumnSpan gridColumnStart fontWeight lineClamp lineHeight opacity order orphans scale tabSize widows zIndex zoom fillOpacity floodOpacity stopOpacity strokeDasharray strokeDashoffset strokeMiterlimit strokeOpacity strokeWidth MozAnimationIterationCount MozBoxFlex MozBoxFlexGroup MozLineClamp msAnimationIterationCount msFlex msZoom msFlexGrow msFlexNegative msFlexOrder msFlexPositive msFlexShrink msGridColumn msGridColumnSpan msGridRow msGridRowSpan WebkitAnimationIterationCount WebkitBoxFlex WebKitBoxFlexGroup WebkitBoxOrdinalGroup WebkitColumnCount WebkitColumns WebkitFlex WebkitFlexGrow WebkitFlexPositive WebkitFlexShrink WebkitLineClamp\".split(\n    \" \"\n  )\n);\nfunction setValueForStyle(style, styleName, value) {\n  var isCustomProperty = 0 === styleName.indexOf(\"--\");\n  null == value || \"boolean\" === typeof value || \"\" === value\n    ? isCustomProperty\n      ? style.setProperty(styleName, \"\")\n      : \"float\" === styleName\n        ? (style.cssFloat = \"\")\n        : (style[styleName] = \"\")\n    : isCustomProperty\n      ? style.setProperty(styleName, value)\n      : \"number\" !== typeof value ||\n          0 === value ||\n          unitlessNumbers.has(styleName)\n        ? \"float\" === styleName\n          ? (style.cssFloat = value)\n          : (style[styleName] = (\"\" + value).trim())\n        : (style[styleName] = value + \"px\");\n}\nfunction setValueForStyles(node, styles, prevStyles) {\n  if (null != styles && \"object\" !== typeof styles)\n    throw Error(formatProdErrorMessage(62));\n  node = node.style;\n  if (null != prevStyles) {\n    for (var styleName in prevStyles)\n      !prevStyles.hasOwnProperty(styleName) ||\n        (null != styles && styles.hasOwnProperty(styleName)) ||\n        (0 === styleName.indexOf(\"--\")\n          ? node.setProperty(styleName, \"\")\n          : \"float\" === styleName\n            ? (node.cssFloat = \"\")\n            : (node[styleName] = \"\"));\n    for (var styleName$16 in styles)\n      (styleName = styles[styleName$16]),\n        styles.hasOwnProperty(styleName$16) &&\n          prevStyles[styleName$16] !== styleName &&\n          setValueForStyle(node, styleName$16, styleName);\n  } else\n    for (var styleName$17 in styles)\n      styles.hasOwnProperty(styleName$17) &&\n        setValueForStyle(node, styleName$17, styles[styleName$17]);\n}\nfunction isCustomElement(tagName) {\n  if (-1 === tagName.indexOf(\"-\")) return !1;\n  switch (tagName) {\n    case \"annotation-xml\":\n    case \"color-profile\":\n    case \"font-face\":\n    case \"font-face-src\":\n    case \"font-face-uri\":\n    case \"font-face-format\":\n    case \"font-face-name\":\n    case \"missing-glyph\":\n      return !1;\n    default:\n      return !0;\n  }\n}\nvar aliases = new Map([\n    [\"acceptCharset\", \"accept-charset\"],\n    [\"htmlFor\", \"for\"],\n    [\"httpEquiv\", \"http-equiv\"],\n    [\"crossOrigin\", \"crossorigin\"],\n    [\"accentHeight\", \"accent-height\"],\n    [\"alignmentBaseline\", \"alignment-baseline\"],\n    [\"arabicForm\", \"arabic-form\"],\n    [\"baselineShift\", \"baseline-shift\"],\n    [\"capHeight\", \"cap-height\"],\n    [\"clipPath\", \"clip-path\"],\n    [\"clipRule\", \"clip-rule\"],\n    [\"colorInterpolation\", \"color-interpolation\"],\n    [\"colorInterpolationFilters\", \"color-interpolation-filters\"],\n    [\"colorProfile\", \"color-profile\"],\n    [\"colorRendering\", \"color-rendering\"],\n    [\"dominantBaseline\", \"dominant-baseline\"],\n    [\"enableBackground\", \"enable-background\"],\n    [\"fillOpacity\", \"fill-opacity\"],\n    [\"fillRule\", \"fill-rule\"],\n    [\"floodColor\", \"flood-color\"],\n    [\"floodOpacity\", \"flood-opacity\"],\n    [\"fontFamily\", \"font-family\"],\n    [\"fontSize\", \"font-size\"],\n    [\"fontSizeAdjust\", \"font-size-adjust\"],\n    [\"fontStretch\", \"font-stretch\"],\n    [\"fontStyle\", \"font-style\"],\n    [\"fontVariant\", \"font-variant\"],\n    [\"fontWeight\", \"font-weight\"],\n    [\"glyphName\", \"glyph-name\"],\n    [\"glyphOrientationHorizontal\", \"glyph-orientation-horizontal\"],\n    [\"glyphOrientationVertical\", \"glyph-orientation-vertical\"],\n    [\"horizAdvX\", \"horiz-adv-x\"],\n    [\"horizOriginX\", \"horiz-origin-x\"],\n    [\"imageRendering\", \"image-rendering\"],\n    [\"letterSpacing\", \"letter-spacing\"],\n    [\"lightingColor\", \"lighting-color\"],\n    [\"markerEnd\", \"marker-end\"],\n    [\"markerMid\", \"marker-mid\"],\n    [\"markerStart\", \"marker-start\"],\n    [\"overlinePosition\", \"overline-position\"],\n    [\"overlineThickness\", \"overline-thickness\"],\n    [\"paintOrder\", \"paint-order\"],\n    [\"panose-1\", \"panose-1\"],\n    [\"pointerEvents\", \"pointer-events\"],\n    [\"renderingIntent\", \"rendering-intent\"],\n    [\"shapeRendering\", \"shape-rendering\"],\n    [\"stopColor\", \"stop-color\"],\n    [\"stopOpacity\", \"stop-opacity\"],\n    [\"strikethroughPosition\", \"strikethrough-position\"],\n    [\"strikethroughThickness\", \"strikethrough-thickness\"],\n    [\"strokeDasharray\", \"stroke-dasharray\"],\n    [\"strokeDashoffset\", \"stroke-dashoffset\"],\n    [\"strokeLinecap\", \"stroke-linecap\"],\n    [\"strokeLinejoin\", \"stroke-linejoin\"],\n    [\"strokeMiterlimit\", \"stroke-miterlimit\"],\n    [\"strokeOpacity\", \"stroke-opacity\"],\n    [\"strokeWidth\", \"stroke-width\"],\n    [\"textAnchor\", \"text-anchor\"],\n    [\"textDecoration\", \"text-decoration\"],\n    [\"textRendering\", \"text-rendering\"],\n    [\"transformOrigin\", \"transform-origin\"],\n    [\"underlinePosition\", \"underline-position\"],\n    [\"underlineThickness\", \"underline-thickness\"],\n    [\"unicodeBidi\", \"unicode-bidi\"],\n    [\"unicodeRange\", \"unicode-range\"],\n    [\"unitsPerEm\", \"units-per-em\"],\n    [\"vAlphabetic\", \"v-alphabetic\"],\n    [\"vHanging\", \"v-hanging\"],\n    [\"vIdeographic\", \"v-ideographic\"],\n    [\"vMathematical\", \"v-mathematical\"],\n    [\"vectorEffect\", \"vector-effect\"],\n    [\"vertAdvY\", \"vert-adv-y\"],\n    [\"vertOriginX\", \"vert-origin-x\"],\n    [\"vertOriginY\", \"vert-origin-y\"],\n    [\"wordSpacing\", \"word-spacing\"],\n    [\"writingMode\", \"writing-mode\"],\n    [\"xmlnsXlink\", \"xmlns:xlink\"],\n    [\"xHeight\", \"x-height\"]\n  ]),\n  isJavaScriptProtocol =\n    /^[\\u0000-\\u001F ]*j[\\r\\n\\t]*a[\\r\\n\\t]*v[\\r\\n\\t]*a[\\r\\n\\t]*s[\\r\\n\\t]*c[\\r\\n\\t]*r[\\r\\n\\t]*i[\\r\\n\\t]*p[\\r\\n\\t]*t[\\r\\n\\t]*:/i;\nfunction sanitizeURL(url) {\n  return isJavaScriptProtocol.test(\"\" + url)\n    ? \"javascript:throw new Error('React has blocked a javascript: URL as a security precaution.')\"\n    : url;\n}\nvar currentReplayingEvent = null;\nfunction getEventTarget(nativeEvent) {\n  nativeEvent = nativeEvent.target || nativeEvent.srcElement || window;\n  nativeEvent.correspondingUseElement &&\n    (nativeEvent = nativeEvent.correspondingUseElement);\n  return 3 === nativeEvent.nodeType ? nativeEvent.parentNode : nativeEvent;\n}\nvar restoreTarget = null,\n  restoreQueue = null;\nfunction restoreStateOfTarget(target) {\n  var internalInstance = getInstanceFromNode(target);\n  if (internalInstance && (target = internalInstance.stateNode)) {\n    var props = target[internalPropsKey] || null;\n    a: switch (((target = internalInstance.stateNode), internalInstance.type)) {\n      case \"input\":\n        updateInput(\n          target,\n          props.value,\n          props.defaultValue,\n          props.defaultValue,\n          props.checked,\n          props.defaultChecked,\n          props.type,\n          props.name\n        );\n        internalInstance = props.name;\n        if (\"radio\" === props.type && null != internalInstance) {\n          for (props = target; props.parentNode; ) props = props.parentNode;\n          props = props.querySelectorAll(\n            'input[name=\"' +\n              escapeSelectorAttributeValueInsideDoubleQuotes(\n                \"\" + internalInstance\n              ) +\n              '\"][type=\"radio\"]'\n          );\n          for (\n            internalInstance = 0;\n            internalInstance < props.length;\n            internalInstance++\n          ) {\n            var otherNode = props[internalInstance];\n            if (otherNode !== target && otherNode.form === target.form) {\n              var otherProps = otherNode[internalPropsKey] || null;\n              if (!otherProps) throw Error(formatProdErrorMessage(90));\n              updateInput(\n                otherNode,\n                otherProps.value,\n                otherProps.defaultValue,\n                otherProps.defaultValue,\n                otherProps.checked,\n                otherProps.defaultChecked,\n                otherProps.type,\n                otherProps.name\n              );\n            }\n          }\n          for (\n            internalInstance = 0;\n            internalInstance < props.length;\n            internalInstance++\n          )\n            (otherNode = props[internalInstance]),\n              otherNode.form === target.form && updateValueIfChanged(otherNode);\n        }\n        break a;\n      case \"textarea\":\n        updateTextarea(target, props.value, props.defaultValue);\n        break a;\n      case \"select\":\n        (internalInstance = props.value),\n          null != internalInstance &&\n            updateOptions(target, !!props.multiple, internalInstance, !1);\n    }\n  }\n}\nvar isInsideEventHandler = !1;\nfunction batchedUpdates$1(fn, a, b) {\n  if (isInsideEventHandler) return fn(a, b);\n  isInsideEventHandler = !0;\n  try {\n    var JSCompiler_inline_result = fn(a);\n    return JSCompiler_inline_result;\n  } finally {\n    if (\n      ((isInsideEventHandler = !1),\n      null !== restoreTarget || null !== restoreQueue)\n    )\n      if (\n        (flushSyncWork$1(),\n        restoreTarget &&\n          ((a = restoreTarget),\n          (fn = restoreQueue),\n          (restoreQueue = restoreTarget = null),\n          restoreStateOfTarget(a),\n          fn))\n      )\n        for (a = 0; a < fn.length; a++) restoreStateOfTarget(fn[a]);\n  }\n}\nfunction getListener(inst, registrationName) {\n  var stateNode = inst.stateNode;\n  if (null === stateNode) return null;\n  var props = stateNode[internalPropsKey] || null;\n  if (null === props) return null;\n  stateNode = props[registrationName];\n  a: switch (registrationName) {\n    case \"onClick\":\n    case \"onClickCapture\":\n    case \"onDoubleClick\":\n    case \"onDoubleClickCapture\":\n    case \"onMouseDown\":\n    case \"onMouseDownCapture\":\n    case \"onMouseMove\":\n    case \"onMouseMoveCapture\":\n    case \"onMouseUp\":\n    case \"onMouseUpCapture\":\n    case \"onMouseEnter\":\n      (props = !props.disabled) ||\n        ((inst = inst.type),\n        (props = !(\n          \"button\" === inst ||\n          \"input\" === inst ||\n          \"select\" === inst ||\n          \"textarea\" === inst\n        )));\n      inst = !props;\n      break a;\n    default:\n      inst = !1;\n  }\n  if (inst) return null;\n  if (stateNode && \"function\" !== typeof stateNode)\n    throw Error(\n      formatProdErrorMessage(231, registrationName, typeof stateNode)\n    );\n  return stateNode;\n}\nvar canUseDOM = !(\n    \"undefined\" === typeof window ||\n    \"undefined\" === typeof window.document ||\n    \"undefined\" === typeof window.document.createElement\n  ),\n  passiveBrowserEventsSupported = !1;\nif (canUseDOM)\n  try {\n    var options = {};\n    Object.defineProperty(options, \"passive\", {\n      get: function () {\n        passiveBrowserEventsSupported = !0;\n      }\n    });\n    window.addEventListener(\"test\", options, options);\n    window.removeEventListener(\"test\", options, options);\n  } catch (e) {\n    passiveBrowserEventsSupported = !1;\n  }\nvar root = null,\n  startText = null,\n  fallbackText = null;\nfunction getData() {\n  if (fallbackText) return fallbackText;\n  var start,\n    startValue = startText,\n    startLength = startValue.length,\n    end,\n    endValue = \"value\" in root ? root.value : root.textContent,\n    endLength = endValue.length;\n  for (\n    start = 0;\n    start < startLength && startValue[start] === endValue[start];\n    start++\n  );\n  var minEnd = startLength - start;\n  for (\n    end = 1;\n    end <= minEnd &&\n    startValue[startLength - end] === endValue[endLength - end];\n    end++\n  );\n  return (fallbackText = endValue.slice(start, 1 < end ? 1 - end : void 0));\n}\nfunction getEventCharCode(nativeEvent) {\n  var keyCode = nativeEvent.keyCode;\n  \"charCode\" in nativeEvent\n    ? ((nativeEvent = nativeEvent.charCode),\n      0 === nativeEvent && 13 === keyCode && (nativeEvent = 13))\n    : (nativeEvent = keyCode);\n  10 === nativeEvent && (nativeEvent = 13);\n  return 32 <= nativeEvent || 13 === nativeEvent ? nativeEvent : 0;\n}\nfunction functionThatReturnsTrue() {\n  return !0;\n}\nfunction functionThatReturnsFalse() {\n  return !1;\n}\nfunction createSyntheticEvent(Interface) {\n  function SyntheticBaseEvent(\n    reactName,\n    reactEventType,\n    targetInst,\n    nativeEvent,\n    nativeEventTarget\n  ) {\n    this._reactName = reactName;\n    this._targetInst = targetInst;\n    this.type = reactEventType;\n    this.nativeEvent = nativeEvent;\n    this.target = nativeEventTarget;\n    this.currentTarget = null;\n    for (var propName in Interface)\n      Interface.hasOwnProperty(propName) &&\n        ((reactName = Interface[propName]),\n        (this[propName] = reactName\n          ? reactName(nativeEvent)\n          : nativeEvent[propName]));\n    this.isDefaultPrevented = (\n      null != nativeEvent.defaultPrevented\n        ? nativeEvent.defaultPrevented\n        : !1 === nativeEvent.returnValue\n    )\n      ? functionThatReturnsTrue\n      : functionThatReturnsFalse;\n    this.isPropagationStopped = functionThatReturnsFalse;\n    return this;\n  }\n  assign(SyntheticBaseEvent.prototype, {\n    preventDefault: function () {\n      this.defaultPrevented = !0;\n      var event = this.nativeEvent;\n      event &&\n        (event.preventDefault\n          ? event.preventDefault()\n          : \"unknown\" !== typeof event.returnValue && (event.returnValue = !1),\n        (this.isDefaultPrevented = functionThatReturnsTrue));\n    },\n    stopPropagation: function () {\n      var event = this.nativeEvent;\n      event &&\n        (event.stopPropagation\n          ? event.stopPropagation()\n          : \"unknown\" !== typeof event.cancelBubble &&\n            (event.cancelBubble = !0),\n        (this.isPropagationStopped = functionThatReturnsTrue));\n    },\n    persist: function () {},\n    isPersistent: functionThatReturnsTrue\n  });\n  return SyntheticBaseEvent;\n}\nvar EventInterface = {\n    eventPhase: 0,\n    bubbles: 0,\n    cancelable: 0,\n    timeStamp: function (event) {\n      return event.timeStamp || Date.now();\n    },\n    defaultPrevented: 0,\n    isTrusted: 0\n  },\n  SyntheticEvent = createSyntheticEvent(EventInterface),\n  UIEventInterface = assign({}, EventInterface, { view: 0, detail: 0 }),\n  SyntheticUIEvent = createSyntheticEvent(UIEventInterface),\n  lastMovementX,\n  lastMovementY,\n  lastMouseEvent,\n  MouseEventInterface = assign({}, UIEventInterface, {\n    screenX: 0,\n    screenY: 0,\n    clientX: 0,\n    clientY: 0,\n    pageX: 0,\n    pageY: 0,\n    ctrlKey: 0,\n    shiftKey: 0,\n    altKey: 0,\n    metaKey: 0,\n    getModifierState: getEventModifierState,\n    button: 0,\n    buttons: 0,\n    relatedTarget: function (event) {\n      return void 0 === event.relatedTarget\n        ? event.fromElement === event.srcElement\n          ? event.toElement\n          : event.fromElement\n        : event.relatedTarget;\n    },\n    movementX: function (event) {\n      if (\"movementX\" in event) return event.movementX;\n      event !== lastMouseEvent &&\n        (lastMouseEvent && \"mousemove\" === event.type\n          ? ((lastMovementX = event.screenX - lastMouseEvent.screenX),\n            (lastMovementY = event.screenY - lastMouseEvent.screenY))\n          : (lastMovementY = lastMovementX = 0),\n        (lastMouseEvent = event));\n      return lastMovementX;\n    },\n    movementY: function (event) {\n      return \"movementY\" in event ? event.movementY : lastMovementY;\n    }\n  }),\n  SyntheticMouseEvent = createSyntheticEvent(MouseEventInterface),\n  DragEventInterface = assign({}, MouseEventInterface, { dataTransfer: 0 }),\n  SyntheticDragEvent = createSyntheticEvent(DragEventInterface),\n  FocusEventInterface = assign({}, UIEventInterface, { relatedTarget: 0 }),\n  SyntheticFocusEvent = createSyntheticEvent(FocusEventInterface),\n  AnimationEventInterface = assign({}, EventInterface, {\n    animationName: 0,\n    elapsedTime: 0,\n    pseudoElement: 0\n  }),\n  SyntheticAnimationEvent = createSyntheticEvent(AnimationEventInterface),\n  ClipboardEventInterface = assign({}, EventInterface, {\n    clipboardData: function (event) {\n      return \"clipboardData\" in event\n        ? event.clipboardData\n        : window.clipboardData;\n    }\n  }),\n  SyntheticClipboardEvent = createSyntheticEvent(ClipboardEventInterface),\n  CompositionEventInterface = assign({}, EventInterface, { data: 0 }),\n  SyntheticCompositionEvent = createSyntheticEvent(CompositionEventInterface),\n  normalizeKey = {\n    Esc: \"Escape\",\n    Spacebar: \" \",\n    Left: \"ArrowLeft\",\n    Up: \"ArrowUp\",\n    Right: \"ArrowRight\",\n    Down: \"ArrowDown\",\n    Del: \"Delete\",\n    Win: \"OS\",\n    Menu: \"ContextMenu\",\n    Apps: \"ContextMenu\",\n    Scroll: \"ScrollLock\",\n    MozPrintableKey: \"Unidentified\"\n  },\n  translateToKey = {\n    8: \"Backspace\",\n    9: \"Tab\",\n    12: \"Clear\",\n    13: \"Enter\",\n    16: \"Shift\",\n    17: \"Control\",\n    18: \"Alt\",\n    19: \"Pause\",\n    20: \"CapsLock\",\n    27: \"Escape\",\n    32: \" \",\n    33: \"PageUp\",\n    34: \"PageDown\",\n    35: \"End\",\n    36: \"Home\",\n    37: \"ArrowLeft\",\n    38: \"ArrowUp\",\n    39: \"ArrowRight\",\n    40: \"ArrowDown\",\n    45: \"Insert\",\n    46: \"Delete\",\n    112: \"F1\",\n    113: \"F2\",\n    114: \"F3\",\n    115: \"F4\",\n    116: \"F5\",\n    117: \"F6\",\n    118: \"F7\",\n    119: \"F8\",\n    120: \"F9\",\n    121: \"F10\",\n    122: \"F11\",\n    123: \"F12\",\n    144: \"NumLock\",\n    145: \"ScrollLock\",\n    224: \"Meta\"\n  },\n  modifierKeyToProp = {\n    Alt: \"altKey\",\n    Control: \"ctrlKey\",\n    Meta: \"metaKey\",\n    Shift: \"shiftKey\"\n  };\nfunction modifierStateGetter(keyArg) {\n  var nativeEvent = this.nativeEvent;\n  return nativeEvent.getModifierState\n    ? nativeEvent.getModifierState(keyArg)\n    : (keyArg = modifierKeyToProp[keyArg])\n      ? !!nativeEvent[keyArg]\n      : !1;\n}\nfunction getEventModifierState() {\n  return modifierStateGetter;\n}\nvar KeyboardEventInterface = assign({}, UIEventInterface, {\n    key: function (nativeEvent) {\n      if (nativeEvent.key) {\n        var key = normalizeKey[nativeEvent.key] || nativeEvent.key;\n        if (\"Unidentified\" !== key) return key;\n      }\n      return \"keypress\" === nativeEvent.type\n        ? ((nativeEvent = getEventCharCode(nativeEvent)),\n          13 === nativeEvent ? \"Enter\" : String.fromCharCode(nativeEvent))\n        : \"keydown\" === nativeEvent.type || \"keyup\" === nativeEvent.type\n          ? translateToKey[nativeEvent.keyCode] || \"Unidentified\"\n          : \"\";\n    },\n    code: 0,\n    location: 0,\n    ctrlKey: 0,\n    shiftKey: 0,\n    altKey: 0,\n    metaKey: 0,\n    repeat: 0,\n    locale: 0,\n    getModifierState: getEventModifierState,\n    charCode: function (event) {\n      return \"keypress\" === event.type ? getEventCharCode(event) : 0;\n    },\n    keyCode: function (event) {\n      return \"keydown\" === event.type || \"keyup\" === event.type\n        ? event.keyCode\n        : 0;\n    },\n    which: function (event) {\n      return \"keypress\" === event.type\n        ? getEventCharCode(event)\n        : \"keydown\" === event.type || \"keyup\" === event.type\n          ? event.keyCode\n          : 0;\n    }\n  }),\n  SyntheticKeyboardEvent = createSyntheticEvent(KeyboardEventInterface),\n  PointerEventInterface = assign({}, MouseEventInterface, {\n    pointerId: 0,\n    width: 0,\n    height: 0,\n    pressure: 0,\n    tangentialPressure: 0,\n    tiltX: 0,\n    tiltY: 0,\n    twist: 0,\n    pointerType: 0,\n    isPrimary: 0\n  }),\n  SyntheticPointerEvent = createSyntheticEvent(PointerEventInterface),\n  TouchEventInterface = assign({}, UIEventInterface, {\n    touches: 0,\n    targetTouches: 0,\n    changedTouches: 0,\n    altKey: 0,\n    metaKey: 0,\n    ctrlKey: 0,\n    shiftKey: 0,\n    getModifierState: getEventModifierState\n  }),\n  SyntheticTouchEvent = createSyntheticEvent(TouchEventInterface),\n  TransitionEventInterface = assign({}, EventInterface, {\n    propertyName: 0,\n    elapsedTime: 0,\n    pseudoElement: 0\n  }),\n  SyntheticTransitionEvent = createSyntheticEvent(TransitionEventInterface),\n  WheelEventInterface = assign({}, MouseEventInterface, {\n    deltaX: function (event) {\n      return \"deltaX\" in event\n        ? event.deltaX\n        : \"wheelDeltaX\" in event\n          ? -event.wheelDeltaX\n          : 0;\n    },\n    deltaY: function (event) {\n      return \"deltaY\" in event\n        ? event.deltaY\n        : \"wheelDeltaY\" in event\n          ? -event.wheelDeltaY\n          : \"wheelDelta\" in event\n            ? -event.wheelDelta\n            : 0;\n    },\n    deltaZ: 0,\n    deltaMode: 0\n  }),\n  SyntheticWheelEvent = createSyntheticEvent(WheelEventInterface),\n  ToggleEventInterface = assign({}, EventInterface, {\n    newState: 0,\n    oldState: 0\n  }),\n  SyntheticToggleEvent = createSyntheticEvent(ToggleEventInterface),\n  END_KEYCODES = [9, 13, 27, 32],\n  canUseCompositionEvent = canUseDOM && \"CompositionEvent\" in window,\n  documentMode = null;\ncanUseDOM &&\n  \"documentMode\" in document &&\n  (documentMode = document.documentMode);\nvar canUseTextInputEvent = canUseDOM && \"TextEvent\" in window && !documentMode,\n  useFallbackCompositionData =\n    canUseDOM &&\n    (!canUseCompositionEvent ||\n      (documentMode && 8 < documentMode && 11 >= documentMode)),\n  SPACEBAR_CHAR = String.fromCharCode(32),\n  hasSpaceKeypress = !1;\nfunction isFallbackCompositionEnd(domEventName, nativeEvent) {\n  switch (domEventName) {\n    case \"keyup\":\n      return -1 !== END_KEYCODES.indexOf(nativeEvent.keyCode);\n    case \"keydown\":\n      return 229 !== nativeEvent.keyCode;\n    case \"keypress\":\n    case \"mousedown\":\n    case \"focusout\":\n      return !0;\n    default:\n      return !1;\n  }\n}\nfunction getDataFromCustomEvent(nativeEvent) {\n  nativeEvent = nativeEvent.detail;\n  return \"object\" === typeof nativeEvent && \"data\" in nativeEvent\n    ? nativeEvent.data\n    : null;\n}\nvar isComposing = !1;\nfunction getNativeBeforeInputChars(domEventName, nativeEvent) {\n  switch (domEventName) {\n    case \"compositionend\":\n      return getDataFromCustomEvent(nativeEvent);\n    case \"keypress\":\n      if (32 !== nativeEvent.which) return null;\n      hasSpaceKeypress = !0;\n      return SPACEBAR_CHAR;\n    case \"textInput\":\n      return (\n        (domEventName = nativeEvent.data),\n        domEventName === SPACEBAR_CHAR && hasSpaceKeypress ? null : domEventName\n      );\n    default:\n      return null;\n  }\n}\nfunction getFallbackBeforeInputChars(domEventName, nativeEvent) {\n  if (isComposing)\n    return \"compositionend\" === domEventName ||\n      (!canUseCompositionEvent &&\n        isFallbackCompositionEnd(domEventName, nativeEvent))\n      ? ((domEventName = getData()),\n        (fallbackText = startText = root = null),\n        (isComposing = !1),\n        domEventName)\n      : null;\n  switch (domEventName) {\n    case \"paste\":\n      return null;\n    case \"keypress\":\n      if (\n        !(nativeEvent.ctrlKey || nativeEvent.altKey || nativeEvent.metaKey) ||\n        (nativeEvent.ctrlKey && nativeEvent.altKey)\n      ) {\n        if (nativeEvent.char && 1 < nativeEvent.char.length)\n          return nativeEvent.char;\n        if (nativeEvent.which) return String.fromCharCode(nativeEvent.which);\n      }\n      return null;\n    case \"compositionend\":\n      return useFallbackCompositionData && \"ko\" !== nativeEvent.locale\n        ? null\n        : nativeEvent.data;\n    default:\n      return null;\n  }\n}\nvar supportedInputTypes = {\n  color: !0,\n  date: !0,\n  datetime: !0,\n  \"datetime-local\": !0,\n  email: !0,\n  month: !0,\n  number: !0,\n  password: !0,\n  range: !0,\n  search: !0,\n  tel: !0,\n  text: !0,\n  time: !0,\n  url: !0,\n  week: !0\n};\nfunction isTextInputElement(elem) {\n  var nodeName = elem && elem.nodeName && elem.nodeName.toLowerCase();\n  return \"input\" === nodeName\n    ? !!supportedInputTypes[elem.type]\n    : \"textarea\" === nodeName\n      ? !0\n      : !1;\n}\nfunction createAndAccumulateChangeEvent(\n  dispatchQueue,\n  inst,\n  nativeEvent,\n  target\n) {\n  restoreTarget\n    ? restoreQueue\n      ? restoreQueue.push(target)\n      : (restoreQueue = [target])\n    : (restoreTarget = target);\n  inst = accumulateTwoPhaseListeners(inst, \"onChange\");\n  0 < inst.length &&\n    ((nativeEvent = new SyntheticEvent(\n      \"onChange\",\n      \"change\",\n      null,\n      nativeEvent,\n      target\n    )),\n    dispatchQueue.push({ event: nativeEvent, listeners: inst }));\n}\nvar activeElement$1 = null,\n  activeElementInst$1 = null;\nfunction runEventInBatch(dispatchQueue) {\n  processDispatchQueue(dispatchQueue, 0);\n}\nfunction getInstIfValueChanged(targetInst) {\n  var targetNode = getNodeFromInstance(targetInst);\n  if (updateValueIfChanged(targetNode)) return targetInst;\n}\nfunction getTargetInstForChangeEvent(domEventName, targetInst) {\n  if (\"change\" === domEventName) return targetInst;\n}\nvar isInputEventSupported = !1;\nif (canUseDOM) {\n  var JSCompiler_inline_result$jscomp$282;\n  if (canUseDOM) {\n    var isSupported$jscomp$inline_417 = \"oninput\" in document;\n    if (!isSupported$jscomp$inline_417) {\n      var element$jscomp$inline_418 = document.createElement(\"div\");\n      element$jscomp$inline_418.setAttribute(\"oninput\", \"return;\");\n      isSupported$jscomp$inline_417 =\n        \"function\" === typeof element$jscomp$inline_418.oninput;\n    }\n    JSCompiler_inline_result$jscomp$282 = isSupported$jscomp$inline_417;\n  } else JSCompiler_inline_result$jscomp$282 = !1;\n  isInputEventSupported =\n    JSCompiler_inline_result$jscomp$282 &&\n    (!document.documentMode || 9 < document.documentMode);\n}\nfunction stopWatchingForValueChange() {\n  activeElement$1 &&\n    (activeElement$1.detachEvent(\"onpropertychange\", handlePropertyChange),\n    (activeElementInst$1 = activeElement$1 = null));\n}\nfunction handlePropertyChange(nativeEvent) {\n  if (\n    \"value\" === nativeEvent.propertyName &&\n    getInstIfValueChanged(activeElementInst$1)\n  ) {\n    var dispatchQueue = [];\n    createAndAccumulateChangeEvent(\n      dispatchQueue,\n      activeElementInst$1,\n      nativeEvent,\n      getEventTarget(nativeEvent)\n    );\n    batchedUpdates$1(runEventInBatch, dispatchQueue);\n  }\n}\nfunction handleEventsForInputEventPolyfill(domEventName, target, targetInst) {\n  \"focusin\" === domEventName\n    ? (stopWatchingForValueChange(),\n      (activeElement$1 = target),\n      (activeElementInst$1 = targetInst),\n      activeElement$1.attachEvent(\"onpropertychange\", handlePropertyChange))\n    : \"focusout\" === domEventName && stopWatchingForValueChange();\n}\nfunction getTargetInstForInputEventPolyfill(domEventName) {\n  if (\n    \"selectionchange\" === domEventName ||\n    \"keyup\" === domEventName ||\n    \"keydown\" === domEventName\n  )\n    return getInstIfValueChanged(activeElementInst$1);\n}\nfunction getTargetInstForClickEvent(domEventName, targetInst) {\n  if (\"click\" === domEventName) return getInstIfValueChanged(targetInst);\n}\nfunction getTargetInstForInputOrChangeEvent(domEventName, targetInst) {\n  if (\"input\" === domEventName || \"change\" === domEventName)\n    return getInstIfValueChanged(targetInst);\n}\nfunction is(x, y) {\n  return (x === y && (0 !== x || 1 / x === 1 / y)) || (x !== x && y !== y);\n}\nvar objectIs = \"function\" === typeof Object.is ? Object.is : is;\nfunction shallowEqual(objA, objB) {\n  if (objectIs(objA, objB)) return !0;\n  if (\n    \"object\" !== typeof objA ||\n    null === objA ||\n    \"object\" !== typeof objB ||\n    null === objB\n  )\n    return !1;\n  var keysA = Object.keys(objA),\n    keysB = Object.keys(objB);\n  if (keysA.length !== keysB.length) return !1;\n  for (keysB = 0; keysB < keysA.length; keysB++) {\n    var currentKey = keysA[keysB];\n    if (\n      !hasOwnProperty.call(objB, currentKey) ||\n      !objectIs(objA[currentKey], objB[currentKey])\n    )\n      return !1;\n  }\n  return !0;\n}\nfunction getLeafNode(node) {\n  for (; node && node.firstChild; ) node = node.firstChild;\n  return node;\n}\nfunction getNodeForCharacterOffset(root, offset) {\n  var node = getLeafNode(root);\n  root = 0;\n  for (var nodeEnd; node; ) {\n    if (3 === node.nodeType) {\n      nodeEnd = root + node.textContent.length;\n      if (root <= offset && nodeEnd >= offset)\n        return { node: node, offset: offset - root };\n      root = nodeEnd;\n    }\n    a: {\n      for (; node; ) {\n        if (node.nextSibling) {\n          node = node.nextSibling;\n          break a;\n        }\n        node = node.parentNode;\n      }\n      node = void 0;\n    }\n    node = getLeafNode(node);\n  }\n}\nfunction containsNode(outerNode, innerNode) {\n  return outerNode && innerNode\n    ? outerNode === innerNode\n      ? !0\n      : outerNode && 3 === outerNode.nodeType\n        ? !1\n        : innerNode && 3 === innerNode.nodeType\n          ? containsNode(outerNode, innerNode.parentNode)\n          : \"contains\" in outerNode\n            ? outerNode.contains(innerNode)\n            : outerNode.compareDocumentPosition\n              ? !!(outerNode.compareDocumentPosition(innerNode) & 16)\n              : !1\n    : !1;\n}\nfunction getActiveElementDeep(containerInfo) {\n  containerInfo =\n    null != containerInfo &&\n    null != containerInfo.ownerDocument &&\n    null != containerInfo.ownerDocument.defaultView\n      ? containerInfo.ownerDocument.defaultView\n      : window;\n  for (\n    var element = getActiveElement(containerInfo.document);\n    element instanceof containerInfo.HTMLIFrameElement;\n\n  ) {\n    try {\n      var JSCompiler_inline_result =\n        \"string\" === typeof element.contentWindow.location.href;\n    } catch (err) {\n      JSCompiler_inline_result = !1;\n    }\n    if (JSCompiler_inline_result) containerInfo = element.contentWindow;\n    else break;\n    element = getActiveElement(containerInfo.document);\n  }\n  return element;\n}\nfunction hasSelectionCapabilities(elem) {\n  var nodeName = elem && elem.nodeName && elem.nodeName.toLowerCase();\n  return (\n    nodeName &&\n    ((\"input\" === nodeName &&\n      (\"text\" === elem.type ||\n        \"search\" === elem.type ||\n        \"tel\" === elem.type ||\n        \"url\" === elem.type ||\n        \"password\" === elem.type)) ||\n      \"textarea\" === nodeName ||\n      \"true\" === elem.contentEditable)\n  );\n}\nvar skipSelectionChangeEvent =\n    canUseDOM && \"documentMode\" in document && 11 >= document.documentMode,\n  activeElement = null,\n  activeElementInst = null,\n  lastSelection = null,\n  mouseDown = !1;\nfunction constructSelectEvent(dispatchQueue, nativeEvent, nativeEventTarget) {\n  var doc =\n    nativeEventTarget.window === nativeEventTarget\n      ? nativeEventTarget.document\n      : 9 === nativeEventTarget.nodeType\n        ? nativeEventTarget\n        : nativeEventTarget.ownerDocument;\n  mouseDown ||\n    null == activeElement ||\n    activeElement !== getActiveElement(doc) ||\n    ((doc = activeElement),\n    \"selectionStart\" in doc && hasSelectionCapabilities(doc)\n      ? (doc = { start: doc.selectionStart, end: doc.selectionEnd })\n      : ((doc = (\n          (doc.ownerDocument && doc.ownerDocument.defaultView) ||\n          window\n        ).getSelection()),\n        (doc = {\n          anchorNode: doc.anchorNode,\n          anchorOffset: doc.anchorOffset,\n          focusNode: doc.focusNode,\n          focusOffset: doc.focusOffset\n        })),\n    (lastSelection && shallowEqual(lastSelection, doc)) ||\n      ((lastSelection = doc),\n      (doc = accumulateTwoPhaseListeners(activeElementInst, \"onSelect\")),\n      0 < doc.length &&\n        ((nativeEvent = new SyntheticEvent(\n          \"onSelect\",\n          \"select\",\n          null,\n          nativeEvent,\n          nativeEventTarget\n        )),\n        dispatchQueue.push({ event: nativeEvent, listeners: doc }),\n        (nativeEvent.target = activeElement))));\n}\nfunction makePrefixMap(styleProp, eventName) {\n  var prefixes = {};\n  prefixes[styleProp.toLowerCase()] = eventName.toLowerCase();\n  prefixes[\"Webkit\" + styleProp] = \"webkit\" + eventName;\n  prefixes[\"Moz\" + styleProp] = \"moz\" + eventName;\n  return prefixes;\n}\nvar vendorPrefixes = {\n    animationend: makePrefixMap(\"Animation\", \"AnimationEnd\"),\n    animationiteration: makePrefixMap(\"Animation\", \"AnimationIteration\"),\n    animationstart: makePrefixMap(\"Animation\", \"AnimationStart\"),\n    transitionrun: makePrefixMap(\"Transition\", \"TransitionRun\"),\n    transitionstart: makePrefixMap(\"Transition\", \"TransitionStart\"),\n    transitioncancel: makePrefixMap(\"Transition\", \"TransitionCancel\"),\n    transitionend: makePrefixMap(\"Transition\", \"TransitionEnd\")\n  },\n  prefixedEventNames = {},\n  style = {};\ncanUseDOM &&\n  ((style = document.createElement(\"div\").style),\n  \"AnimationEvent\" in window ||\n    (delete vendorPrefixes.animationend.animation,\n    delete vendorPrefixes.animationiteration.animation,\n    delete vendorPrefixes.animationstart.animation),\n  \"TransitionEvent\" in window ||\n    delete vendorPrefixes.transitionend.transition);\nfunction getVendorPrefixedEventName(eventName) {\n  if (prefixedEventNames[eventName]) return prefixedEventNames[eventName];\n  if (!vendorPrefixes[eventName]) return eventName;\n  var prefixMap = vendorPrefixes[eventName],\n    styleProp;\n  for (styleProp in prefixMap)\n    if (prefixMap.hasOwnProperty(styleProp) && styleProp in style)\n      return (prefixedEventNames[eventName] = prefixMap[styleProp]);\n  return eventName;\n}\nvar ANIMATION_END = getVendorPrefixedEventName(\"animationend\"),\n  ANIMATION_ITERATION = getVendorPrefixedEventName(\"animationiteration\"),\n  ANIMATION_START = getVendorPrefixedEventName(\"animationstart\"),\n  TRANSITION_RUN = getVendorPrefixedEventName(\"transitionrun\"),\n  TRANSITION_START = getVendorPrefixedEventName(\"transitionstart\"),\n  TRANSITION_CANCEL = getVendorPrefixedEventName(\"transitioncancel\"),\n  TRANSITION_END = getVendorPrefixedEventName(\"transitionend\"),\n  topLevelEventsToReactNames = new Map(),\n  simpleEventPluginEvents =\n    \"abort auxClick beforeToggle cancel canPlay canPlayThrough click close contextMenu copy cut drag dragEnd dragEnter dragExit dragLeave dragOver dragStart drop durationChange emptied encrypted ended error gotPointerCapture input invalid keyDown keyPress keyUp load loadedData loadedMetadata loadStart lostPointerCapture mouseDown mouseMove mouseOut mouseOver mouseUp paste pause play playing pointerCancel pointerDown pointerMove pointerOut pointerOver pointerUp progress rateChange reset resize seeked seeking stalled submit suspend timeUpdate touchCancel touchEnd touchStart volumeChange scroll toggle touchMove waiting wheel\".split(\n      \" \"\n    );\nsimpleEventPluginEvents.push(\"scrollEnd\");\nfunction registerSimpleEvent(domEventName, reactName) {\n  topLevelEventsToReactNames.set(domEventName, reactName);\n  registerTwoPhaseEvent(reactName, [domEventName]);\n}\nvar CapturedStacks = new WeakMap();\nfunction createCapturedValueAtFiber(value, source) {\n  if (\"object\" === typeof value && null !== value) {\n    var existing = CapturedStacks.get(value);\n    if (void 0 !== existing) return existing;\n    source = {\n      value: value,\n      source: source,\n      stack: getStackByFiberInDevAndProd(source)\n    };\n    CapturedStacks.set(value, source);\n    return source;\n  }\n  return {\n    value: value,\n    source: source,\n    stack: getStackByFiberInDevAndProd(source)\n  };\n}\nvar concurrentQueues = [],\n  concurrentQueuesIndex = 0,\n  concurrentlyUpdatedLanes = 0;\nfunction finishQueueingConcurrentUpdates() {\n  for (\n    var endIndex = concurrentQueuesIndex,\n      i = (concurrentlyUpdatedLanes = concurrentQueuesIndex = 0);\n    i < endIndex;\n\n  ) {\n    var fiber = concurrentQueues[i];\n    concurrentQueues[i++] = null;\n    var queue = concurrentQueues[i];\n    concurrentQueues[i++] = null;\n    var update = concurrentQueues[i];\n    concurrentQueues[i++] = null;\n    var lane = concurrentQueues[i];\n    concurrentQueues[i++] = null;\n    if (null !== queue && null !== update) {\n      var pending = queue.pending;\n      null === pending\n        ? (update.next = update)\n        : ((update.next = pending.next), (pending.next = update));\n      queue.pending = update;\n    }\n    0 !== lane && markUpdateLaneFromFiberToRoot(fiber, update, lane);\n  }\n}\nfunction enqueueUpdate$1(fiber, queue, update, lane) {\n  concurrentQueues[concurrentQueuesIndex++] = fiber;\n  concurrentQueues[concurrentQueuesIndex++] = queue;\n  concurrentQueues[concurrentQueuesIndex++] = update;\n  concurrentQueues[concurrentQueuesIndex++] = lane;\n  concurrentlyUpdatedLanes |= lane;\n  fiber.lanes |= lane;\n  fiber = fiber.alternate;\n  null !== fiber && (fiber.lanes |= lane);\n}\nfunction enqueueConcurrentHookUpdate(fiber, queue, update, lane) {\n  enqueueUpdate$1(fiber, queue, update, lane);\n  return getRootForUpdatedFiber(fiber);\n}\nfunction enqueueConcurrentRenderForLane(fiber, lane) {\n  enqueueUpdate$1(fiber, null, null, lane);\n  return getRootForUpdatedFiber(fiber);\n}\nfunction markUpdateLaneFromFiberToRoot(sourceFiber, update, lane) {\n  sourceFiber.lanes |= lane;\n  var alternate = sourceFiber.alternate;\n  null !== alternate && (alternate.lanes |= lane);\n  for (var isHidden = !1, parent = sourceFiber.return; null !== parent; )\n    (parent.childLanes |= lane),\n      (alternate = parent.alternate),\n      null !== alternate && (alternate.childLanes |= lane),\n      22 === parent.tag &&\n        ((sourceFiber = parent.stateNode),\n        null === sourceFiber || sourceFiber._visibility & 1 || (isHidden = !0)),\n      (sourceFiber = parent),\n      (parent = parent.return);\n  return 3 === sourceFiber.tag\n    ? ((parent = sourceFiber.stateNode),\n      isHidden &&\n        null !== update &&\n        ((isHidden = 31 - clz32(lane)),\n        (sourceFiber = parent.hiddenUpdates),\n        (alternate = sourceFiber[isHidden]),\n        null === alternate\n          ? (sourceFiber[isHidden] = [update])\n          : alternate.push(update),\n        (update.lane = lane | 536870912)),\n      parent)\n    : null;\n}\nfunction getRootForUpdatedFiber(sourceFiber) {\n  if (50 < nestedUpdateCount)\n    throw (\n      ((nestedUpdateCount = 0),\n      (rootWithNestedUpdates = null),\n      Error(formatProdErrorMessage(185)))\n    );\n  for (var parent = sourceFiber.return; null !== parent; )\n    (sourceFiber = parent), (parent = sourceFiber.return);\n  return 3 === sourceFiber.tag ? sourceFiber.stateNode : null;\n}\nvar emptyContextObject = {};\nfunction FiberNode(tag, pendingProps, key, mode) {\n  this.tag = tag;\n  this.key = key;\n  this.sibling =\n    this.child =\n    this.return =\n    this.stateNode =\n    this.type =\n    this.elementType =\n      null;\n  this.index = 0;\n  this.refCleanup = this.ref = null;\n  this.pendingProps = pendingProps;\n  this.dependencies =\n    this.memoizedState =\n    this.updateQueue =\n    this.memoizedProps =\n      null;\n  this.mode = mode;\n  this.subtreeFlags = this.flags = 0;\n  this.deletions = null;\n  this.childLanes = this.lanes = 0;\n  this.alternate = null;\n}\nfunction createFiberImplClass(tag, pendingProps, key, mode) {\n  return new FiberNode(tag, pendingProps, key, mode);\n}\nfunction shouldConstruct(Component) {\n  Component = Component.prototype;\n  return !(!Component || !Component.isReactComponent);\n}\nfunction createWorkInProgress(current, pendingProps) {\n  var workInProgress = current.alternate;\n  null === workInProgress\n    ? ((workInProgress = createFiberImplClass(\n        current.tag,\n        pendingProps,\n        current.key,\n        current.mode\n      )),\n      (workInProgress.elementType = current.elementType),\n      (workInProgress.type = current.type),\n      (workInProgress.stateNode = current.stateNode),\n      (workInProgress.alternate = current),\n      (current.alternate = workInProgress))\n    : ((workInProgress.pendingProps = pendingProps),\n      (workInProgress.type = current.type),\n      (workInProgress.flags = 0),\n      (workInProgress.subtreeFlags = 0),\n      (workInProgress.deletions = null));\n  workInProgress.flags = current.flags & 65011712;\n  workInProgress.childLanes = current.childLanes;\n  workInProgress.lanes = current.lanes;\n  workInProgress.child = current.child;\n  workInProgress.memoizedProps = current.memoizedProps;\n  workInProgress.memoizedState = current.memoizedState;\n  workInProgress.updateQueue = current.updateQueue;\n  pendingProps = current.dependencies;\n  workInProgress.dependencies =\n    null === pendingProps\n      ? null\n      : { lanes: pendingProps.lanes, firstContext: pendingProps.firstContext };\n  workInProgress.sibling = current.sibling;\n  workInProgress.index = current.index;\n  workInProgress.ref = current.ref;\n  workInProgress.refCleanup = current.refCleanup;\n  return workInProgress;\n}\nfunction resetWorkInProgress(workInProgress, renderLanes) {\n  workInProgress.flags &= 65011714;\n  var current = workInProgress.alternate;\n  null === current\n    ? ((workInProgress.childLanes = 0),\n      (workInProgress.lanes = renderLanes),\n      (workInProgress.child = null),\n      (workInProgress.subtreeFlags = 0),\n      (workInProgress.memoizedProps = null),\n      (workInProgress.memoizedState = null),\n      (workInProgress.updateQueue = null),\n      (workInProgress.dependencies = null),\n      (workInProgress.stateNode = null))\n    : ((workInProgress.childLanes = current.childLanes),\n      (workInProgress.lanes = current.lanes),\n      (workInProgress.child = current.child),\n      (workInProgress.subtreeFlags = 0),\n      (workInProgress.deletions = null),\n      (workInProgress.memoizedProps = current.memoizedProps),\n      (workInProgress.memoizedState = current.memoizedState),\n      (workInProgress.updateQueue = current.updateQueue),\n      (workInProgress.type = current.type),\n      (renderLanes = current.dependencies),\n      (workInProgress.dependencies =\n        null === renderLanes\n          ? null\n          : {\n              lanes: renderLanes.lanes,\n              firstContext: renderLanes.firstContext\n            }));\n  return workInProgress;\n}\nfunction createFiberFromTypeAndProps(\n  type,\n  key,\n  pendingProps,\n  owner,\n  mode,\n  lanes\n) {\n  var fiberTag = 0;\n  owner = type;\n  if (\"function\" === typeof type) shouldConstruct(type) && (fiberTag = 1);\n  else if (\"string\" === typeof type)\n    fiberTag = isHostHoistableType(\n      type,\n      pendingProps,\n      contextStackCursor.current\n    )\n      ? 26\n      : \"html\" === type || \"head\" === type || \"body\" === type\n        ? 27\n        : 5;\n  else\n    a: switch (type) {\n      case REACT_ACTIVITY_TYPE:\n        return (\n          (type = createFiberImplClass(31, pendingProps, key, mode)),\n          (type.elementType = REACT_ACTIVITY_TYPE),\n          (type.lanes = lanes),\n          type\n        );\n      case REACT_FRAGMENT_TYPE:\n        return createFiberFromFragment(pendingProps.children, mode, lanes, key);\n      case REACT_STRICT_MODE_TYPE:\n        fiberTag = 8;\n        mode |= 24;\n        break;\n      case REACT_PROFILER_TYPE:\n        return (\n          (type = createFiberImplClass(12, pendingProps, key, mode | 2)),\n          (type.elementType = REACT_PROFILER_TYPE),\n          (type.lanes = lanes),\n          type\n        );\n      case REACT_SUSPENSE_TYPE:\n        return (\n          (type = createFiberImplClass(13, pendingProps, key, mode)),\n          (type.elementType = REACT_SUSPENSE_TYPE),\n          (type.lanes = lanes),\n          type\n        );\n      case REACT_SUSPENSE_LIST_TYPE:\n        return (\n          (type = createFiberImplClass(19, pendingProps, key, mode)),\n          (type.elementType = REACT_SUSPENSE_LIST_TYPE),\n          (type.lanes = lanes),\n          type\n        );\n      default:\n        if (\"object\" === typeof type && null !== type)\n          switch (type.$$typeof) {\n            case REACT_PROVIDER_TYPE:\n            case REACT_CONTEXT_TYPE:\n              fiberTag = 10;\n              break a;\n            case REACT_CONSUMER_TYPE:\n              fiberTag = 9;\n              break a;\n            case REACT_FORWARD_REF_TYPE:\n              fiberTag = 11;\n              break a;\n            case REACT_MEMO_TYPE:\n              fiberTag = 14;\n              break a;\n            case REACT_LAZY_TYPE:\n              fiberTag = 16;\n              owner = null;\n              break a;\n          }\n        fiberTag = 29;\n        pendingProps = Error(\n          formatProdErrorMessage(130, null === type ? \"null\" : typeof type, \"\")\n        );\n        owner = null;\n    }\n  key = createFiberImplClass(fiberTag, pendingProps, key, mode);\n  key.elementType = type;\n  key.type = owner;\n  key.lanes = lanes;\n  return key;\n}\nfunction createFiberFromFragment(elements, mode, lanes, key) {\n  elements = createFiberImplClass(7, elements, key, mode);\n  elements.lanes = lanes;\n  return elements;\n}\nfunction createFiberFromText(content, mode, lanes) {\n  content = createFiberImplClass(6, content, null, mode);\n  content.lanes = lanes;\n  return content;\n}\nfunction createFiberFromPortal(portal, mode, lanes) {\n  mode = createFiberImplClass(\n    4,\n    null !== portal.children ? portal.children : [],\n    portal.key,\n    mode\n  );\n  mode.lanes = lanes;\n  mode.stateNode = {\n    containerInfo: portal.containerInfo,\n    pendingChildren: null,\n    implementation: portal.implementation\n  };\n  return mode;\n}\nvar forkStack = [],\n  forkStackIndex = 0,\n  treeForkProvider = null,\n  treeForkCount = 0,\n  idStack = [],\n  idStackIndex = 0,\n  treeContextProvider = null,\n  treeContextId = 1,\n  treeContextOverflow = \"\";\nfunction pushTreeFork(workInProgress, totalChildren) {\n  forkStack[forkStackIndex++] = treeForkCount;\n  forkStack[forkStackIndex++] = treeForkProvider;\n  treeForkProvider = workInProgress;\n  treeForkCount = totalChildren;\n}\nfunction pushTreeId(workInProgress, totalChildren, index) {\n  idStack[idStackIndex++] = treeContextId;\n  idStack[idStackIndex++] = treeContextOverflow;\n  idStack[idStackIndex++] = treeContextProvider;\n  treeContextProvider = workInProgress;\n  var baseIdWithLeadingBit = treeContextId;\n  workInProgress = treeContextOverflow;\n  var baseLength = 32 - clz32(baseIdWithLeadingBit) - 1;\n  baseIdWithLeadingBit &= ~(1 << baseLength);\n  index += 1;\n  var length = 32 - clz32(totalChildren) + baseLength;\n  if (30 < length) {\n    var numberOfOverflowBits = baseLength - (baseLength % 5);\n    length = (\n      baseIdWithLeadingBit &\n      ((1 << numberOfOverflowBits) - 1)\n    ).toString(32);\n    baseIdWithLeadingBit >>= numberOfOverflowBits;\n    baseLength -= numberOfOverflowBits;\n    treeContextId =\n      (1 << (32 - clz32(totalChildren) + baseLength)) |\n      (index << baseLength) |\n      baseIdWithLeadingBit;\n    treeContextOverflow = length + workInProgress;\n  } else\n    (treeContextId =\n      (1 << length) | (index << baseLength) | baseIdWithLeadingBit),\n      (treeContextOverflow = workInProgress);\n}\nfunction pushMaterializedTreeId(workInProgress) {\n  null !== workInProgress.return &&\n    (pushTreeFork(workInProgress, 1), pushTreeId(workInProgress, 1, 0));\n}\nfunction popTreeContext(workInProgress) {\n  for (; workInProgress === treeForkProvider; )\n    (treeForkProvider = forkStack[--forkStackIndex]),\n      (forkStack[forkStackIndex] = null),\n      (treeForkCount = forkStack[--forkStackIndex]),\n      (forkStack[forkStackIndex] = null);\n  for (; workInProgress === treeContextProvider; )\n    (treeContextProvider = idStack[--idStackIndex]),\n      (idStack[idStackIndex] = null),\n      (treeContextOverflow = idStack[--idStackIndex]),\n      (idStack[idStackIndex] = null),\n      (treeContextId = idStack[--idStackIndex]),\n      (idStack[idStackIndex] = null);\n}\nvar hydrationParentFiber = null,\n  nextHydratableInstance = null,\n  isHydrating = !1,\n  hydrationErrors = null,\n  rootOrSingletonContext = !1,\n  HydrationMismatchException = Error(formatProdErrorMessage(519));\nfunction throwOnHydrationMismatch(fiber) {\n  var error = Error(formatProdErrorMessage(418, \"\"));\n  queueHydrationError(createCapturedValueAtFiber(error, fiber));\n  throw HydrationMismatchException;\n}\nfunction prepareToHydrateHostInstance(fiber) {\n  var instance = fiber.stateNode,\n    type = fiber.type,\n    props = fiber.memoizedProps;\n  instance[internalInstanceKey] = fiber;\n  instance[internalPropsKey] = props;\n  switch (type) {\n    case \"dialog\":\n      listenToNonDelegatedEvent(\"cancel\", instance);\n      listenToNonDelegatedEvent(\"close\", instance);\n      break;\n    case \"iframe\":\n    case \"object\":\n    case \"embed\":\n      listenToNonDelegatedEvent(\"load\", instance);\n      break;\n    case \"video\":\n    case \"audio\":\n      for (type = 0; type < mediaEventTypes.length; type++)\n        listenToNonDelegatedEvent(mediaEventTypes[type], instance);\n      break;\n    case \"source\":\n      listenToNonDelegatedEvent(\"error\", instance);\n      break;\n    case \"img\":\n    case \"image\":\n    case \"link\":\n      listenToNonDelegatedEvent(\"error\", instance);\n      listenToNonDelegatedEvent(\"load\", instance);\n      break;\n    case \"details\":\n      listenToNonDelegatedEvent(\"toggle\", instance);\n      break;\n    case \"input\":\n      listenToNonDelegatedEvent(\"invalid\", instance);\n      initInput(\n        instance,\n        props.value,\n        props.defaultValue,\n        props.checked,\n        props.defaultChecked,\n        props.type,\n        props.name,\n        !0\n      );\n      track(instance);\n      break;\n    case \"select\":\n      listenToNonDelegatedEvent(\"invalid\", instance);\n      break;\n    case \"textarea\":\n      listenToNonDelegatedEvent(\"invalid\", instance),\n        initTextarea(instance, props.value, props.defaultValue, props.children),\n        track(instance);\n  }\n  type = props.children;\n  (\"string\" !== typeof type &&\n    \"number\" !== typeof type &&\n    \"bigint\" !== typeof type) ||\n  instance.textContent === \"\" + type ||\n  !0 === props.suppressHydrationWarning ||\n  checkForUnmatchedText(instance.textContent, type)\n    ? (null != props.popover &&\n        (listenToNonDelegatedEvent(\"beforetoggle\", instance),\n        listenToNonDelegatedEvent(\"toggle\", instance)),\n      null != props.onScroll && listenToNonDelegatedEvent(\"scroll\", instance),\n      null != props.onScrollEnd &&\n        listenToNonDelegatedEvent(\"scrollend\", instance),\n      null != props.onClick && (instance.onclick = noop$1),\n      (instance = !0))\n    : (instance = !1);\n  instance || throwOnHydrationMismatch(fiber);\n}\nfunction popToNextHostParent(fiber) {\n  for (hydrationParentFiber = fiber.return; hydrationParentFiber; )\n    switch (hydrationParentFiber.tag) {\n      case 5:\n      case 13:\n        rootOrSingletonContext = !1;\n        return;\n      case 27:\n      case 3:\n        rootOrSingletonContext = !0;\n        return;\n      default:\n        hydrationParentFiber = hydrationParentFiber.return;\n    }\n}\nfunction popHydrationState(fiber) {\n  if (fiber !== hydrationParentFiber) return !1;\n  if (!isHydrating) return popToNextHostParent(fiber), (isHydrating = !0), !1;\n  var tag = fiber.tag,\n    JSCompiler_temp;\n  if ((JSCompiler_temp = 3 !== tag && 27 !== tag)) {\n    if ((JSCompiler_temp = 5 === tag))\n      (JSCompiler_temp = fiber.type),\n        (JSCompiler_temp =\n          !(\"form\" !== JSCompiler_temp && \"button\" !== JSCompiler_temp) ||\n          shouldSetTextContent(fiber.type, fiber.memoizedProps));\n    JSCompiler_temp = !JSCompiler_temp;\n  }\n  JSCompiler_temp && nextHydratableInstance && throwOnHydrationMismatch(fiber);\n  popToNextHostParent(fiber);\n  if (13 === tag) {\n    fiber = fiber.memoizedState;\n    fiber = null !== fiber ? fiber.dehydrated : null;\n    if (!fiber) throw Error(formatProdErrorMessage(317));\n    a: {\n      fiber = fiber.nextSibling;\n      for (tag = 0; fiber; ) {\n        if (8 === fiber.nodeType)\n          if (((JSCompiler_temp = fiber.data), \"/$\" === JSCompiler_temp)) {\n            if (0 === tag) {\n              nextHydratableInstance = getNextHydratable(fiber.nextSibling);\n              break a;\n            }\n            tag--;\n          } else\n            (\"$\" !== JSCompiler_temp &&\n              \"$!\" !== JSCompiler_temp &&\n              \"$?\" !== JSCompiler_temp) ||\n              tag++;\n        fiber = fiber.nextSibling;\n      }\n      nextHydratableInstance = null;\n    }\n  } else\n    27 === tag\n      ? ((tag = nextHydratableInstance),\n        isSingletonScope(fiber.type)\n          ? ((fiber = previousHydratableOnEnteringScopedSingleton),\n            (previousHydratableOnEnteringScopedSingleton = null),\n            (nextHydratableInstance = fiber))\n          : (nextHydratableInstance = tag))\n      : (nextHydratableInstance = hydrationParentFiber\n          ? getNextHydratable(fiber.stateNode.nextSibling)\n          : null);\n  return !0;\n}\nfunction resetHydrationState() {\n  nextHydratableInstance = hydrationParentFiber = null;\n  isHydrating = !1;\n}\nfunction upgradeHydrationErrorsToRecoverable() {\n  var queuedErrors = hydrationErrors;\n  null !== queuedErrors &&\n    (null === workInProgressRootRecoverableErrors\n      ? (workInProgressRootRecoverableErrors = queuedErrors)\n      : workInProgressRootRecoverableErrors.push.apply(\n          workInProgressRootRecoverableErrors,\n          queuedErrors\n        ),\n    (hydrationErrors = null));\n  return queuedErrors;\n}\nfunction queueHydrationError(error) {\n  null === hydrationErrors\n    ? (hydrationErrors = [error])\n    : hydrationErrors.push(error);\n}\nvar valueCursor = createCursor(null),\n  currentlyRenderingFiber$1 = null,\n  lastContextDependency = null;\nfunction pushProvider(providerFiber, context, nextValue) {\n  push(valueCursor, context._currentValue);\n  context._currentValue = nextValue;\n}\nfunction popProvider(context) {\n  context._currentValue = valueCursor.current;\n  pop(valueCursor);\n}\nfunction scheduleContextWorkOnParentPath(parent, renderLanes, propagationRoot) {\n  for (; null !== parent; ) {\n    var alternate = parent.alternate;\n    (parent.childLanes & renderLanes) !== renderLanes\n      ? ((parent.childLanes |= renderLanes),\n        null !== alternate && (alternate.childLanes |= renderLanes))\n      : null !== alternate &&\n        (alternate.childLanes & renderLanes) !== renderLanes &&\n        (alternate.childLanes |= renderLanes);\n    if (parent === propagationRoot) break;\n    parent = parent.return;\n  }\n}\nfunction propagateContextChanges(\n  workInProgress,\n  contexts,\n  renderLanes,\n  forcePropagateEntireTree\n) {\n  var fiber = workInProgress.child;\n  null !== fiber && (fiber.return = workInProgress);\n  for (; null !== fiber; ) {\n    var list = fiber.dependencies;\n    if (null !== list) {\n      var nextFiber = fiber.child;\n      list = list.firstContext;\n      a: for (; null !== list; ) {\n        var dependency = list;\n        list = fiber;\n        for (var i = 0; i < contexts.length; i++)\n          if (dependency.context === contexts[i]) {\n            list.lanes |= renderLanes;\n            dependency = list.alternate;\n            null !== dependency && (dependency.lanes |= renderLanes);\n            scheduleContextWorkOnParentPath(\n              list.return,\n              renderLanes,\n              workInProgress\n            );\n            forcePropagateEntireTree || (nextFiber = null);\n            break a;\n          }\n        list = dependency.next;\n      }\n    } else if (18 === fiber.tag) {\n      nextFiber = fiber.return;\n      if (null === nextFiber) throw Error(formatProdErrorMessage(341));\n      nextFiber.lanes |= renderLanes;\n      list = nextFiber.alternate;\n      null !== list && (list.lanes |= renderLanes);\n      scheduleContextWorkOnParentPath(nextFiber, renderLanes, workInProgress);\n      nextFiber = null;\n    } else nextFiber = fiber.child;\n    if (null !== nextFiber) nextFiber.return = fiber;\n    else\n      for (nextFiber = fiber; null !== nextFiber; ) {\n        if (nextFiber === workInProgress) {\n          nextFiber = null;\n          break;\n        }\n        fiber = nextFiber.sibling;\n        if (null !== fiber) {\n          fiber.return = nextFiber.return;\n          nextFiber = fiber;\n          break;\n        }\n        nextFiber = nextFiber.return;\n      }\n    fiber = nextFiber;\n  }\n}\nfunction propagateParentContextChanges(\n  current,\n  workInProgress,\n  renderLanes,\n  forcePropagateEntireTree\n) {\n  current = null;\n  for (\n    var parent = workInProgress, isInsidePropagationBailout = !1;\n    null !== parent;\n\n  ) {\n    if (!isInsidePropagationBailout)\n      if (0 !== (parent.flags & 524288)) isInsidePropagationBailout = !0;\n      else if (0 !== (parent.flags & 262144)) break;\n    if (10 === parent.tag) {\n      var currentParent = parent.alternate;\n      if (null === currentParent) throw Error(formatProdErrorMessage(387));\n      currentParent = currentParent.memoizedProps;\n      if (null !== currentParent) {\n        var context = parent.type;\n        objectIs(parent.pendingProps.value, currentParent.value) ||\n          (null !== current ? current.push(context) : (current = [context]));\n      }\n    } else if (parent === hostTransitionProviderCursor.current) {\n      currentParent = parent.alternate;\n      if (null === currentParent) throw Error(formatProdErrorMessage(387));\n      currentParent.memoizedState.memoizedState !==\n        parent.memoizedState.memoizedState &&\n        (null !== current\n          ? current.push(HostTransitionContext)\n          : (current = [HostTransitionContext]));\n    }\n    parent = parent.return;\n  }\n  null !== current &&\n    propagateContextChanges(\n      workInProgress,\n      current,\n      renderLanes,\n      forcePropagateEntireTree\n    );\n  workInProgress.flags |= 262144;\n}\nfunction checkIfContextChanged(currentDependencies) {\n  for (\n    currentDependencies = currentDependencies.firstContext;\n    null !== currentDependencies;\n\n  ) {\n    if (\n      !objectIs(\n        currentDependencies.context._currentValue,\n        currentDependencies.memoizedValue\n      )\n    )\n      return !0;\n    currentDependencies = currentDependencies.next;\n  }\n  return !1;\n}\nfunction prepareToReadContext(workInProgress) {\n  currentlyRenderingFiber$1 = workInProgress;\n  lastContextDependency = null;\n  workInProgress = workInProgress.dependencies;\n  null !== workInProgress && (workInProgress.firstContext = null);\n}\nfunction readContext(context) {\n  return readContextForConsumer(currentlyRenderingFiber$1, context);\n}\nfunction readContextDuringReconciliation(consumer, context) {\n  null === currentlyRenderingFiber$1 && prepareToReadContext(consumer);\n  return readContextForConsumer(consumer, context);\n}\nfunction readContextForConsumer(consumer, context) {\n  var value = context._currentValue;\n  context = { context: context, memoizedValue: value, next: null };\n  if (null === lastContextDependency) {\n    if (null === consumer) throw Error(formatProdErrorMessage(308));\n    lastContextDependency = context;\n    consumer.dependencies = { lanes: 0, firstContext: context };\n    consumer.flags |= 524288;\n  } else lastContextDependency = lastContextDependency.next = context;\n  return value;\n}\nvar AbortControllerLocal =\n    \"undefined\" !== typeof AbortController\n      ? AbortController\n      : function () {\n          var listeners = [],\n            signal = (this.signal = {\n              aborted: !1,\n              addEventListener: function (type, listener) {\n                listeners.push(listener);\n              }\n            });\n          this.abort = function () {\n            signal.aborted = !0;\n            listeners.forEach(function (listener) {\n              return listener();\n            });\n          };\n        },\n  scheduleCallback$2 = Scheduler.unstable_scheduleCallback,\n  NormalPriority = Scheduler.unstable_NormalPriority,\n  CacheContext = {\n    $$typeof: REACT_CONTEXT_TYPE,\n    Consumer: null,\n    Provider: null,\n    _currentValue: null,\n    _currentValue2: null,\n    _threadCount: 0\n  };\nfunction createCache() {\n  return {\n    controller: new AbortControllerLocal(),\n    data: new Map(),\n    refCount: 0\n  };\n}\nfunction releaseCache(cache) {\n  cache.refCount--;\n  0 === cache.refCount &&\n    scheduleCallback$2(NormalPriority, function () {\n      cache.controller.abort();\n    });\n}\nvar currentEntangledListeners = null,\n  currentEntangledPendingCount = 0,\n  currentEntangledLane = 0,\n  currentEntangledActionThenable = null;\nfunction entangleAsyncAction(transition, thenable) {\n  if (null === currentEntangledListeners) {\n    var entangledListeners = (currentEntangledListeners = []);\n    currentEntangledPendingCount = 0;\n    currentEntangledLane = requestTransitionLane();\n    currentEntangledActionThenable = {\n      status: \"pending\",\n      value: void 0,\n      then: function (resolve) {\n        entangledListeners.push(resolve);\n      }\n    };\n  }\n  currentEntangledPendingCount++;\n  thenable.then(pingEngtangledActionScope, pingEngtangledActionScope);\n  return thenable;\n}\nfunction pingEngtangledActionScope() {\n  if (\n    0 === --currentEntangledPendingCount &&\n    null !== currentEntangledListeners\n  ) {\n    null !== currentEntangledActionThenable &&\n      (currentEntangledActionThenable.status = \"fulfilled\");\n    var listeners = currentEntangledListeners;\n    currentEntangledListeners = null;\n    currentEntangledLane = 0;\n    currentEntangledActionThenable = null;\n    for (var i = 0; i < listeners.length; i++) (0, listeners[i])();\n  }\n}\nfunction chainThenableValue(thenable, result) {\n  var listeners = [],\n    thenableWithOverride = {\n      status: \"pending\",\n      value: null,\n      reason: null,\n      then: function (resolve) {\n        listeners.push(resolve);\n      }\n    };\n  thenable.then(\n    function () {\n      thenableWithOverride.status = \"fulfilled\";\n      thenableWithOverride.value = result;\n      for (var i = 0; i < listeners.length; i++) (0, listeners[i])(result);\n    },\n    function (error) {\n      thenableWithOverride.status = \"rejected\";\n      thenableWithOverride.reason = error;\n      for (error = 0; error < listeners.length; error++)\n        (0, listeners[error])(void 0);\n    }\n  );\n  return thenableWithOverride;\n}\nvar prevOnStartTransitionFinish = ReactSharedInternals.S;\nReactSharedInternals.S = function (transition, returnValue) {\n  \"object\" === typeof returnValue &&\n    null !== returnValue &&\n    \"function\" === typeof returnValue.then &&\n    entangleAsyncAction(transition, returnValue);\n  null !== prevOnStartTransitionFinish &&\n    prevOnStartTransitionFinish(transition, returnValue);\n};\nvar resumedCache = createCursor(null);\nfunction peekCacheFromPool() {\n  var cacheResumedFromPreviousRender = resumedCache.current;\n  return null !== cacheResumedFromPreviousRender\n    ? cacheResumedFromPreviousRender\n    : workInProgressRoot.pooledCache;\n}\nfunction pushTransition(offscreenWorkInProgress, prevCachePool) {\n  null === prevCachePool\n    ? push(resumedCache, resumedCache.current)\n    : push(resumedCache, prevCachePool.pool);\n}\nfunction getSuspendedCache() {\n  var cacheFromPool = peekCacheFromPool();\n  return null === cacheFromPool\n    ? null\n    : { parent: CacheContext._currentValue, pool: cacheFromPool };\n}\nvar SuspenseException = Error(formatProdErrorMessage(460)),\n  SuspenseyCommitException = Error(formatProdErrorMessage(474)),\n  SuspenseActionException = Error(formatProdErrorMessage(542)),\n  noopSuspenseyCommitThenable = { then: function () {} };\nfunction isThenableResolved(thenable) {\n  thenable = thenable.status;\n  return \"fulfilled\" === thenable || \"rejected\" === thenable;\n}\nfunction noop$3() {}\nfunction trackUsedThenable(thenableState, thenable, index) {\n  index = thenableState[index];\n  void 0 === index\n    ? thenableState.push(thenable)\n    : index !== thenable && (thenable.then(noop$3, noop$3), (thenable = index));\n  switch (thenable.status) {\n    case \"fulfilled\":\n      return thenable.value;\n    case \"rejected\":\n      throw (\n        ((thenableState = thenable.reason),\n        checkIfUseWrappedInAsyncCatch(thenableState),\n        thenableState)\n      );\n    default:\n      if (\"string\" === typeof thenable.status) thenable.then(noop$3, noop$3);\n      else {\n        thenableState = workInProgressRoot;\n        if (null !== thenableState && 100 < thenableState.shellSuspendCounter)\n          throw Error(formatProdErrorMessage(482));\n        thenableState = thenable;\n        thenableState.status = \"pending\";\n        thenableState.then(\n          function (fulfilledValue) {\n            if (\"pending\" === thenable.status) {\n              var fulfilledThenable = thenable;\n              fulfilledThenable.status = \"fulfilled\";\n              fulfilledThenable.value = fulfilledValue;\n            }\n          },\n          function (error) {\n            if (\"pending\" === thenable.status) {\n              var rejectedThenable = thenable;\n              rejectedThenable.status = \"rejected\";\n              rejectedThenable.reason = error;\n            }\n          }\n        );\n      }\n      switch (thenable.status) {\n        case \"fulfilled\":\n          return thenable.value;\n        case \"rejected\":\n          throw (\n            ((thenableState = thenable.reason),\n            checkIfUseWrappedInAsyncCatch(thenableState),\n            thenableState)\n          );\n      }\n      suspendedThenable = thenable;\n      throw SuspenseException;\n  }\n}\nvar suspendedThenable = null;\nfunction getSuspendedThenable() {\n  if (null === suspendedThenable) throw Error(formatProdErrorMessage(459));\n  var thenable = suspendedThenable;\n  suspendedThenable = null;\n  return thenable;\n}\nfunction checkIfUseWrappedInAsyncCatch(rejectedReason) {\n  if (\n    rejectedReason === SuspenseException ||\n    rejectedReason === SuspenseActionException\n  )\n    throw Error(formatProdErrorMessage(483));\n}\nvar hasForceUpdate = !1;\nfunction initializeUpdateQueue(fiber) {\n  fiber.updateQueue = {\n    baseState: fiber.memoizedState,\n    firstBaseUpdate: null,\n    lastBaseUpdate: null,\n    shared: { pending: null, lanes: 0, hiddenCallbacks: null },\n    callbacks: null\n  };\n}\nfunction cloneUpdateQueue(current, workInProgress) {\n  current = current.updateQueue;\n  workInProgress.updateQueue === current &&\n    (workInProgress.updateQueue = {\n      baseState: current.baseState,\n      firstBaseUpdate: current.firstBaseUpdate,\n      lastBaseUpdate: current.lastBaseUpdate,\n      shared: current.shared,\n      callbacks: null\n    });\n}\nfunction createUpdate(lane) {\n  return { lane: lane, tag: 0, payload: null, callback: null, next: null };\n}\nfunction enqueueUpdate(fiber, update, lane) {\n  var updateQueue = fiber.updateQueue;\n  if (null === updateQueue) return null;\n  updateQueue = updateQueue.shared;\n  if (0 !== (executionContext & 2)) {\n    var pending = updateQueue.pending;\n    null === pending\n      ? (update.next = update)\n      : ((update.next = pending.next), (pending.next = update));\n    updateQueue.pending = update;\n    update = getRootForUpdatedFiber(fiber);\n    markUpdateLaneFromFiberToRoot(fiber, null, lane);\n    return update;\n  }\n  enqueueUpdate$1(fiber, updateQueue, update, lane);\n  return getRootForUpdatedFiber(fiber);\n}\nfunction entangleTransitions(root, fiber, lane) {\n  fiber = fiber.updateQueue;\n  if (null !== fiber && ((fiber = fiber.shared), 0 !== (lane & 4194048))) {\n    var queueLanes = fiber.lanes;\n    queueLanes &= root.pendingLanes;\n    lane |= queueLanes;\n    fiber.lanes = lane;\n    markRootEntangled(root, lane);\n  }\n}\nfunction enqueueCapturedUpdate(workInProgress, capturedUpdate) {\n  var queue = workInProgress.updateQueue,\n    current = workInProgress.alternate;\n  if (\n    null !== current &&\n    ((current = current.updateQueue), queue === current)\n  ) {\n    var newFirst = null,\n      newLast = null;\n    queue = queue.firstBaseUpdate;\n    if (null !== queue) {\n      do {\n        var clone = {\n          lane: queue.lane,\n          tag: queue.tag,\n          payload: queue.payload,\n          callback: null,\n          next: null\n        };\n        null === newLast\n          ? (newFirst = newLast = clone)\n          : (newLast = newLast.next = clone);\n        queue = queue.next;\n      } while (null !== queue);\n      null === newLast\n        ? (newFirst = newLast = capturedUpdate)\n        : (newLast = newLast.next = capturedUpdate);\n    } else newFirst = newLast = capturedUpdate;\n    queue = {\n      baseState: current.baseState,\n      firstBaseUpdate: newFirst,\n      lastBaseUpdate: newLast,\n      shared: current.shared,\n      callbacks: current.callbacks\n    };\n    workInProgress.updateQueue = queue;\n    return;\n  }\n  workInProgress = queue.lastBaseUpdate;\n  null === workInProgress\n    ? (queue.firstBaseUpdate = capturedUpdate)\n    : (workInProgress.next = capturedUpdate);\n  queue.lastBaseUpdate = capturedUpdate;\n}\nvar didReadFromEntangledAsyncAction = !1;\nfunction suspendIfUpdateReadFromEntangledAsyncAction() {\n  if (didReadFromEntangledAsyncAction) {\n    var entangledActionThenable = currentEntangledActionThenable;\n    if (null !== entangledActionThenable) throw entangledActionThenable;\n  }\n}\nfunction processUpdateQueue(\n  workInProgress$jscomp$0,\n  props,\n  instance$jscomp$0,\n  renderLanes\n) {\n  didReadFromEntangledAsyncAction = !1;\n  var queue = workInProgress$jscomp$0.updateQueue;\n  hasForceUpdate = !1;\n  var firstBaseUpdate = queue.firstBaseUpdate,\n    lastBaseUpdate = queue.lastBaseUpdate,\n    pendingQueue = queue.shared.pending;\n  if (null !== pendingQueue) {\n    queue.shared.pending = null;\n    var lastPendingUpdate = pendingQueue,\n      firstPendingUpdate = lastPendingUpdate.next;\n    lastPendingUpdate.next = null;\n    null === lastBaseUpdate\n      ? (firstBaseUpdate = firstPendingUpdate)\n      : (lastBaseUpdate.next = firstPendingUpdate);\n    lastBaseUpdate = lastPendingUpdate;\n    var current = workInProgress$jscomp$0.alternate;\n    null !== current &&\n      ((current = current.updateQueue),\n      (pendingQueue = current.lastBaseUpdate),\n      pendingQueue !== lastBaseUpdate &&\n        (null === pendingQueue\n          ? (current.firstBaseUpdate = firstPendingUpdate)\n          : (pendingQueue.next = firstPendingUpdate),\n        (current.lastBaseUpdate = lastPendingUpdate)));\n  }\n  if (null !== firstBaseUpdate) {\n    var newState = queue.baseState;\n    lastBaseUpdate = 0;\n    current = firstPendingUpdate = lastPendingUpdate = null;\n    pendingQueue = firstBaseUpdate;\n    do {\n      var updateLane = pendingQueue.lane & -536870913,\n        isHiddenUpdate = updateLane !== pendingQueue.lane;\n      if (\n        isHiddenUpdate\n          ? (workInProgressRootRenderLanes & updateLane) === updateLane\n          : (renderLanes & updateLane) === updateLane\n      ) {\n        0 !== updateLane &&\n          updateLane === currentEntangledLane &&\n          (didReadFromEntangledAsyncAction = !0);\n        null !== current &&\n          (current = current.next =\n            {\n              lane: 0,\n              tag: pendingQueue.tag,\n              payload: pendingQueue.payload,\n              callback: null,\n              next: null\n            });\n        a: {\n          var workInProgress = workInProgress$jscomp$0,\n            update = pendingQueue;\n          updateLane = props;\n          var instance = instance$jscomp$0;\n          switch (update.tag) {\n            case 1:\n              workInProgress = update.payload;\n              if (\"function\" === typeof workInProgress) {\n                newState = workInProgress.call(instance, newState, updateLane);\n                break a;\n              }\n              newState = workInProgress;\n              break a;\n            case 3:\n              workInProgress.flags = (workInProgress.flags & -65537) | 128;\n            case 0:\n              workInProgress = update.payload;\n              updateLane =\n                \"function\" === typeof workInProgress\n                  ? workInProgress.call(instance, newState, updateLane)\n                  : workInProgress;\n              if (null === updateLane || void 0 === updateLane) break a;\n              newState = assign({}, newState, updateLane);\n              break a;\n            case 2:\n              hasForceUpdate = !0;\n          }\n        }\n        updateLane = pendingQueue.callback;\n        null !== updateLane &&\n          ((workInProgress$jscomp$0.flags |= 64),\n          isHiddenUpdate && (workInProgress$jscomp$0.flags |= 8192),\n          (isHiddenUpdate = queue.callbacks),\n          null === isHiddenUpdate\n            ? (queue.callbacks = [updateLane])\n            : isHiddenUpdate.push(updateLane));\n      } else\n        (isHiddenUpdate = {\n          lane: updateLane,\n          tag: pendingQueue.tag,\n          payload: pendingQueue.payload,\n          callback: pendingQueue.callback,\n          next: null\n        }),\n          null === current\n            ? ((firstPendingUpdate = current = isHiddenUpdate),\n              (lastPendingUpdate = newState))\n            : (current = current.next = isHiddenUpdate),\n          (lastBaseUpdate |= updateLane);\n      pendingQueue = pendingQueue.next;\n      if (null === pendingQueue)\n        if (((pendingQueue = queue.shared.pending), null === pendingQueue))\n          break;\n        else\n          (isHiddenUpdate = pendingQueue),\n            (pendingQueue = isHiddenUpdate.next),\n            (isHiddenUpdate.next = null),\n            (queue.lastBaseUpdate = isHiddenUpdate),\n            (queue.shared.pending = null);\n    } while (1);\n    null === current && (lastPendingUpdate = newState);\n    queue.baseState = lastPendingUpdate;\n    queue.firstBaseUpdate = firstPendingUpdate;\n    queue.lastBaseUpdate = current;\n    null === firstBaseUpdate && (queue.shared.lanes = 0);\n    workInProgressRootSkippedLanes |= lastBaseUpdate;\n    workInProgress$jscomp$0.lanes = lastBaseUpdate;\n    workInProgress$jscomp$0.memoizedState = newState;\n  }\n}\nfunction callCallback(callback, context) {\n  if (\"function\" !== typeof callback)\n    throw Error(formatProdErrorMessage(191, callback));\n  callback.call(context);\n}\nfunction commitCallbacks(updateQueue, context) {\n  var callbacks = updateQueue.callbacks;\n  if (null !== callbacks)\n    for (\n      updateQueue.callbacks = null, updateQueue = 0;\n      updateQueue < callbacks.length;\n      updateQueue++\n    )\n      callCallback(callbacks[updateQueue], context);\n}\nvar currentTreeHiddenStackCursor = createCursor(null),\n  prevEntangledRenderLanesCursor = createCursor(0);\nfunction pushHiddenContext(fiber, context) {\n  fiber = entangledRenderLanes;\n  push(prevEntangledRenderLanesCursor, fiber);\n  push(currentTreeHiddenStackCursor, context);\n  entangledRenderLanes = fiber | context.baseLanes;\n}\nfunction reuseHiddenContextOnStack() {\n  push(prevEntangledRenderLanesCursor, entangledRenderLanes);\n  push(currentTreeHiddenStackCursor, currentTreeHiddenStackCursor.current);\n}\nfunction popHiddenContext() {\n  entangledRenderLanes = prevEntangledRenderLanesCursor.current;\n  pop(currentTreeHiddenStackCursor);\n  pop(prevEntangledRenderLanesCursor);\n}\nvar renderLanes = 0,\n  currentlyRenderingFiber = null,\n  currentHook = null,\n  workInProgressHook = null,\n  didScheduleRenderPhaseUpdate = !1,\n  didScheduleRenderPhaseUpdateDuringThisPass = !1,\n  shouldDoubleInvokeUserFnsInHooksDEV = !1,\n  localIdCounter = 0,\n  thenableIndexCounter$1 = 0,\n  thenableState$1 = null,\n  globalClientIdCounter = 0;\nfunction throwInvalidHookError() {\n  throw Error(formatProdErrorMessage(321));\n}\nfunction areHookInputsEqual(nextDeps, prevDeps) {\n  if (null === prevDeps) return !1;\n  for (var i = 0; i < prevDeps.length && i < nextDeps.length; i++)\n    if (!objectIs(nextDeps[i], prevDeps[i])) return !1;\n  return !0;\n}\nfunction renderWithHooks(\n  current,\n  workInProgress,\n  Component,\n  props,\n  secondArg,\n  nextRenderLanes\n) {\n  renderLanes = nextRenderLanes;\n  currentlyRenderingFiber = workInProgress;\n  workInProgress.memoizedState = null;\n  workInProgress.updateQueue = null;\n  workInProgress.lanes = 0;\n  ReactSharedInternals.H =\n    null === current || null === current.memoizedState\n      ? HooksDispatcherOnMount\n      : HooksDispatcherOnUpdate;\n  shouldDoubleInvokeUserFnsInHooksDEV = !1;\n  nextRenderLanes = Component(props, secondArg);\n  shouldDoubleInvokeUserFnsInHooksDEV = !1;\n  didScheduleRenderPhaseUpdateDuringThisPass &&\n    (nextRenderLanes = renderWithHooksAgain(\n      workInProgress,\n      Component,\n      props,\n      secondArg\n    ));\n  finishRenderingHooks(current);\n  return nextRenderLanes;\n}\nfunction finishRenderingHooks(current) {\n  ReactSharedInternals.H = ContextOnlyDispatcher;\n  var didRenderTooFewHooks = null !== currentHook && null !== currentHook.next;\n  renderLanes = 0;\n  workInProgressHook = currentHook = currentlyRenderingFiber = null;\n  didScheduleRenderPhaseUpdate = !1;\n  thenableIndexCounter$1 = 0;\n  thenableState$1 = null;\n  if (didRenderTooFewHooks) throw Error(formatProdErrorMessage(300));\n  null === current ||\n    didReceiveUpdate ||\n    ((current = current.dependencies),\n    null !== current &&\n      checkIfContextChanged(current) &&\n      (didReceiveUpdate = !0));\n}\nfunction renderWithHooksAgain(workInProgress, Component, props, secondArg) {\n  currentlyRenderingFiber = workInProgress;\n  var numberOfReRenders = 0;\n  do {\n    didScheduleRenderPhaseUpdateDuringThisPass && (thenableState$1 = null);\n    thenableIndexCounter$1 = 0;\n    didScheduleRenderPhaseUpdateDuringThisPass = !1;\n    if (25 <= numberOfReRenders) throw Error(formatProdErrorMessage(301));\n    numberOfReRenders += 1;\n    workInProgressHook = currentHook = null;\n    if (null != workInProgress.updateQueue) {\n      var children = workInProgress.updateQueue;\n      children.lastEffect = null;\n      children.events = null;\n      children.stores = null;\n      null != children.memoCache && (children.memoCache.index = 0);\n    }\n    ReactSharedInternals.H = HooksDispatcherOnRerender;\n    children = Component(props, secondArg);\n  } while (didScheduleRenderPhaseUpdateDuringThisPass);\n  return children;\n}\nfunction TransitionAwareHostComponent() {\n  var dispatcher = ReactSharedInternals.H,\n    maybeThenable = dispatcher.useState()[0];\n  maybeThenable =\n    \"function\" === typeof maybeThenable.then\n      ? useThenable(maybeThenable)\n      : maybeThenable;\n  dispatcher = dispatcher.useState()[0];\n  (null !== currentHook ? currentHook.memoizedState : null) !== dispatcher &&\n    (currentlyRenderingFiber.flags |= 1024);\n  return maybeThenable;\n}\nfunction checkDidRenderIdHook() {\n  var didRenderIdHook = 0 !== localIdCounter;\n  localIdCounter = 0;\n  return didRenderIdHook;\n}\nfunction bailoutHooks(current, workInProgress, lanes) {\n  workInProgress.updateQueue = current.updateQueue;\n  workInProgress.flags &= -2053;\n  current.lanes &= ~lanes;\n}\nfunction resetHooksOnUnwind(workInProgress) {\n  if (didScheduleRenderPhaseUpdate) {\n    for (\n      workInProgress = workInProgress.memoizedState;\n      null !== workInProgress;\n\n    ) {\n      var queue = workInProgress.queue;\n      null !== queue && (queue.pending = null);\n      workInProgress = workInProgress.next;\n    }\n    didScheduleRenderPhaseUpdate = !1;\n  }\n  renderLanes = 0;\n  workInProgressHook = currentHook = currentlyRenderingFiber = null;\n  didScheduleRenderPhaseUpdateDuringThisPass = !1;\n  thenableIndexCounter$1 = localIdCounter = 0;\n  thenableState$1 = null;\n}\nfunction mountWorkInProgressHook() {\n  var hook = {\n    memoizedState: null,\n    baseState: null,\n    baseQueue: null,\n    queue: null,\n    next: null\n  };\n  null === workInProgressHook\n    ? (currentlyRenderingFiber.memoizedState = workInProgressHook = hook)\n    : (workInProgressHook = workInProgressHook.next = hook);\n  return workInProgressHook;\n}\nfunction updateWorkInProgressHook() {\n  if (null === currentHook) {\n    var nextCurrentHook = currentlyRenderingFiber.alternate;\n    nextCurrentHook =\n      null !== nextCurrentHook ? nextCurrentHook.memoizedState : null;\n  } else nextCurrentHook = currentHook.next;\n  var nextWorkInProgressHook =\n    null === workInProgressHook\n      ? currentlyRenderingFiber.memoizedState\n      : workInProgressHook.next;\n  if (null !== nextWorkInProgressHook)\n    (workInProgressHook = nextWorkInProgressHook),\n      (currentHook = nextCurrentHook);\n  else {\n    if (null === nextCurrentHook) {\n      if (null === currentlyRenderingFiber.alternate)\n        throw Error(formatProdErrorMessage(467));\n      throw Error(formatProdErrorMessage(310));\n    }\n    currentHook = nextCurrentHook;\n    nextCurrentHook = {\n      memoizedState: currentHook.memoizedState,\n      baseState: currentHook.baseState,\n      baseQueue: currentHook.baseQueue,\n      queue: currentHook.queue,\n      next: null\n    };\n    null === workInProgressHook\n      ? (currentlyRenderingFiber.memoizedState = workInProgressHook =\n          nextCurrentHook)\n      : (workInProgressHook = workInProgressHook.next = nextCurrentHook);\n  }\n  return workInProgressHook;\n}\nfunction createFunctionComponentUpdateQueue() {\n  return { lastEffect: null, events: null, stores: null, memoCache: null };\n}\nfunction useThenable(thenable) {\n  var index = thenableIndexCounter$1;\n  thenableIndexCounter$1 += 1;\n  null === thenableState$1 && (thenableState$1 = []);\n  thenable = trackUsedThenable(thenableState$1, thenable, index);\n  index = currentlyRenderingFiber;\n  null ===\n    (null === workInProgressHook\n      ? index.memoizedState\n      : workInProgressHook.next) &&\n    ((index = index.alternate),\n    (ReactSharedInternals.H =\n      null === index || null === index.memoizedState\n        ? HooksDispatcherOnMount\n        : HooksDispatcherOnUpdate));\n  return thenable;\n}\nfunction use(usable) {\n  if (null !== usable && \"object\" === typeof usable) {\n    if (\"function\" === typeof usable.then) return useThenable(usable);\n    if (usable.$$typeof === REACT_CONTEXT_TYPE) return readContext(usable);\n  }\n  throw Error(formatProdErrorMessage(438, String(usable)));\n}\nfunction useMemoCache(size) {\n  var memoCache = null,\n    updateQueue = currentlyRenderingFiber.updateQueue;\n  null !== updateQueue && (memoCache = updateQueue.memoCache);\n  if (null == memoCache) {\n    var current = currentlyRenderingFiber.alternate;\n    null !== current &&\n      ((current = current.updateQueue),\n      null !== current &&\n        ((current = current.memoCache),\n        null != current &&\n          (memoCache = {\n            data: current.data.map(function (array) {\n              return array.slice();\n            }),\n            index: 0\n          })));\n  }\n  null == memoCache && (memoCache = { data: [], index: 0 });\n  null === updateQueue &&\n    ((updateQueue = createFunctionComponentUpdateQueue()),\n    (currentlyRenderingFiber.updateQueue = updateQueue));\n  updateQueue.memoCache = memoCache;\n  updateQueue = memoCache.data[memoCache.index];\n  if (void 0 === updateQueue)\n    for (\n      updateQueue = memoCache.data[memoCache.index] = Array(size), current = 0;\n      current < size;\n      current++\n    )\n      updateQueue[current] = REACT_MEMO_CACHE_SENTINEL;\n  memoCache.index++;\n  return updateQueue;\n}\nfunction basicStateReducer(state, action) {\n  return \"function\" === typeof action ? action(state) : action;\n}\nfunction updateReducer(reducer) {\n  var hook = updateWorkInProgressHook();\n  return updateReducerImpl(hook, currentHook, reducer);\n}\nfunction updateReducerImpl(hook, current, reducer) {\n  var queue = hook.queue;\n  if (null === queue) throw Error(formatProdErrorMessage(311));\n  queue.lastRenderedReducer = reducer;\n  var baseQueue = hook.baseQueue,\n    pendingQueue = queue.pending;\n  if (null !== pendingQueue) {\n    if (null !== baseQueue) {\n      var baseFirst = baseQueue.next;\n      baseQueue.next = pendingQueue.next;\n      pendingQueue.next = baseFirst;\n    }\n    current.baseQueue = baseQueue = pendingQueue;\n    queue.pending = null;\n  }\n  pendingQueue = hook.baseState;\n  if (null === baseQueue) hook.memoizedState = pendingQueue;\n  else {\n    current = baseQueue.next;\n    var newBaseQueueFirst = (baseFirst = null),\n      newBaseQueueLast = null,\n      update = current,\n      didReadFromEntangledAsyncAction$32 = !1;\n    do {\n      var updateLane = update.lane & -536870913;\n      if (\n        updateLane !== update.lane\n          ? (workInProgressRootRenderLanes & updateLane) === updateLane\n          : (renderLanes & updateLane) === updateLane\n      ) {\n        var revertLane = update.revertLane;\n        if (0 === revertLane)\n          null !== newBaseQueueLast &&\n            (newBaseQueueLast = newBaseQueueLast.next =\n              {\n                lane: 0,\n                revertLane: 0,\n                action: update.action,\n                hasEagerState: update.hasEagerState,\n                eagerState: update.eagerState,\n                next: null\n              }),\n            updateLane === currentEntangledLane &&\n              (didReadFromEntangledAsyncAction$32 = !0);\n        else if ((renderLanes & revertLane) === revertLane) {\n          update = update.next;\n          revertLane === currentEntangledLane &&\n            (didReadFromEntangledAsyncAction$32 = !0);\n          continue;\n        } else\n          (updateLane = {\n            lane: 0,\n            revertLane: update.revertLane,\n            action: update.action,\n            hasEagerState: update.hasEagerState,\n            eagerState: update.eagerState,\n            next: null\n          }),\n            null === newBaseQueueLast\n              ? ((newBaseQueueFirst = newBaseQueueLast = updateLane),\n                (baseFirst = pendingQueue))\n              : (newBaseQueueLast = newBaseQueueLast.next = updateLane),\n            (currentlyRenderingFiber.lanes |= revertLane),\n            (workInProgressRootSkippedLanes |= revertLane);\n        updateLane = update.action;\n        shouldDoubleInvokeUserFnsInHooksDEV &&\n          reducer(pendingQueue, updateLane);\n        pendingQueue = update.hasEagerState\n          ? update.eagerState\n          : reducer(pendingQueue, updateLane);\n      } else\n        (revertLane = {\n          lane: updateLane,\n          revertLane: update.revertLane,\n          action: update.action,\n          hasEagerState: update.hasEagerState,\n          eagerState: update.eagerState,\n          next: null\n        }),\n          null === newBaseQueueLast\n            ? ((newBaseQueueFirst = newBaseQueueLast = revertLane),\n              (baseFirst = pendingQueue))\n            : (newBaseQueueLast = newBaseQueueLast.next = revertLane),\n          (currentlyRenderingFiber.lanes |= updateLane),\n          (workInProgressRootSkippedLanes |= updateLane);\n      update = update.next;\n    } while (null !== update && update !== current);\n    null === newBaseQueueLast\n      ? (baseFirst = pendingQueue)\n      : (newBaseQueueLast.next = newBaseQueueFirst);\n    if (\n      !objectIs(pendingQueue, hook.memoizedState) &&\n      ((didReceiveUpdate = !0),\n      didReadFromEntangledAsyncAction$32 &&\n        ((reducer = currentEntangledActionThenable), null !== reducer))\n    )\n      throw reducer;\n    hook.memoizedState = pendingQueue;\n    hook.baseState = baseFirst;\n    hook.baseQueue = newBaseQueueLast;\n    queue.lastRenderedState = pendingQueue;\n  }\n  null === baseQueue && (queue.lanes = 0);\n  return [hook.memoizedState, queue.dispatch];\n}\nfunction rerenderReducer(reducer) {\n  var hook = updateWorkInProgressHook(),\n    queue = hook.queue;\n  if (null === queue) throw Error(formatProdErrorMessage(311));\n  queue.lastRenderedReducer = reducer;\n  var dispatch = queue.dispatch,\n    lastRenderPhaseUpdate = queue.pending,\n    newState = hook.memoizedState;\n  if (null !== lastRenderPhaseUpdate) {\n    queue.pending = null;\n    var update = (lastRenderPhaseUpdate = lastRenderPhaseUpdate.next);\n    do (newState = reducer(newState, update.action)), (update = update.next);\n    while (update !== lastRenderPhaseUpdate);\n    objectIs(newState, hook.memoizedState) || (didReceiveUpdate = !0);\n    hook.memoizedState = newState;\n    null === hook.baseQueue && (hook.baseState = newState);\n    queue.lastRenderedState = newState;\n  }\n  return [newState, dispatch];\n}\nfunction updateSyncExternalStore(subscribe, getSnapshot, getServerSnapshot) {\n  var fiber = currentlyRenderingFiber,\n    hook = updateWorkInProgressHook(),\n    isHydrating$jscomp$0 = isHydrating;\n  if (isHydrating$jscomp$0) {\n    if (void 0 === getServerSnapshot) throw Error(formatProdErrorMessage(407));\n    getServerSnapshot = getServerSnapshot();\n  } else getServerSnapshot = getSnapshot();\n  var snapshotChanged = !objectIs(\n    (currentHook || hook).memoizedState,\n    getServerSnapshot\n  );\n  snapshotChanged &&\n    ((hook.memoizedState = getServerSnapshot), (didReceiveUpdate = !0));\n  hook = hook.queue;\n  var create = subscribeToStore.bind(null, fiber, hook, subscribe);\n  updateEffectImpl(2048, 8, create, [subscribe]);\n  if (\n    hook.getSnapshot !== getSnapshot ||\n    snapshotChanged ||\n    (null !== workInProgressHook && workInProgressHook.memoizedState.tag & 1)\n  ) {\n    fiber.flags |= 2048;\n    pushSimpleEffect(\n      9,\n      createEffectInstance(),\n      updateStoreInstance.bind(\n        null,\n        fiber,\n        hook,\n        getServerSnapshot,\n        getSnapshot\n      ),\n      null\n    );\n    if (null === workInProgressRoot) throw Error(formatProdErrorMessage(349));\n    isHydrating$jscomp$0 ||\n      0 !== (renderLanes & 124) ||\n      pushStoreConsistencyCheck(fiber, getSnapshot, getServerSnapshot);\n  }\n  return getServerSnapshot;\n}\nfunction pushStoreConsistencyCheck(fiber, getSnapshot, renderedSnapshot) {\n  fiber.flags |= 16384;\n  fiber = { getSnapshot: getSnapshot, value: renderedSnapshot };\n  getSnapshot = currentlyRenderingFiber.updateQueue;\n  null === getSnapshot\n    ? ((getSnapshot = createFunctionComponentUpdateQueue()),\n      (currentlyRenderingFiber.updateQueue = getSnapshot),\n      (getSnapshot.stores = [fiber]))\n    : ((renderedSnapshot = getSnapshot.stores),\n      null === renderedSnapshot\n        ? (getSnapshot.stores = [fiber])\n        : renderedSnapshot.push(fiber));\n}\nfunction updateStoreInstance(fiber, inst, nextSnapshot, getSnapshot) {\n  inst.value = nextSnapshot;\n  inst.getSnapshot = getSnapshot;\n  checkIfSnapshotChanged(inst) && forceStoreRerender(fiber);\n}\nfunction subscribeToStore(fiber, inst, subscribe) {\n  return subscribe(function () {\n    checkIfSnapshotChanged(inst) && forceStoreRerender(fiber);\n  });\n}\nfunction checkIfSnapshotChanged(inst) {\n  var latestGetSnapshot = inst.getSnapshot;\n  inst = inst.value;\n  try {\n    var nextValue = latestGetSnapshot();\n    return !objectIs(inst, nextValue);\n  } catch (error) {\n    return !0;\n  }\n}\nfunction forceStoreRerender(fiber) {\n  var root = enqueueConcurrentRenderForLane(fiber, 2);\n  null !== root && scheduleUpdateOnFiber(root, fiber, 2);\n}\nfunction mountStateImpl(initialState) {\n  var hook = mountWorkInProgressHook();\n  if (\"function\" === typeof initialState) {\n    var initialStateInitializer = initialState;\n    initialState = initialStateInitializer();\n    if (shouldDoubleInvokeUserFnsInHooksDEV) {\n      setIsStrictModeForDevtools(!0);\n      try {\n        initialStateInitializer();\n      } finally {\n        setIsStrictModeForDevtools(!1);\n      }\n    }\n  }\n  hook.memoizedState = hook.baseState = initialState;\n  hook.queue = {\n    pending: null,\n    lanes: 0,\n    dispatch: null,\n    lastRenderedReducer: basicStateReducer,\n    lastRenderedState: initialState\n  };\n  return hook;\n}\nfunction updateOptimisticImpl(hook, current, passthrough, reducer) {\n  hook.baseState = passthrough;\n  return updateReducerImpl(\n    hook,\n    currentHook,\n    \"function\" === typeof reducer ? reducer : basicStateReducer\n  );\n}\nfunction dispatchActionState(\n  fiber,\n  actionQueue,\n  setPendingState,\n  setState,\n  payload\n) {\n  if (isRenderPhaseUpdate(fiber)) throw Error(formatProdErrorMessage(485));\n  fiber = actionQueue.action;\n  if (null !== fiber) {\n    var actionNode = {\n      payload: payload,\n      action: fiber,\n      next: null,\n      isTransition: !0,\n      status: \"pending\",\n      value: null,\n      reason: null,\n      listeners: [],\n      then: function (listener) {\n        actionNode.listeners.push(listener);\n      }\n    };\n    null !== ReactSharedInternals.T\n      ? setPendingState(!0)\n      : (actionNode.isTransition = !1);\n    setState(actionNode);\n    setPendingState = actionQueue.pending;\n    null === setPendingState\n      ? ((actionNode.next = actionQueue.pending = actionNode),\n        runActionStateAction(actionQueue, actionNode))\n      : ((actionNode.next = setPendingState.next),\n        (actionQueue.pending = setPendingState.next = actionNode));\n  }\n}\nfunction runActionStateAction(actionQueue, node) {\n  var action = node.action,\n    payload = node.payload,\n    prevState = actionQueue.state;\n  if (node.isTransition) {\n    var prevTransition = ReactSharedInternals.T,\n      currentTransition = {};\n    ReactSharedInternals.T = currentTransition;\n    try {\n      var returnValue = action(prevState, payload),\n        onStartTransitionFinish = ReactSharedInternals.S;\n      null !== onStartTransitionFinish &&\n        onStartTransitionFinish(currentTransition, returnValue);\n      handleActionReturnValue(actionQueue, node, returnValue);\n    } catch (error) {\n      onActionError(actionQueue, node, error);\n    } finally {\n      ReactSharedInternals.T = prevTransition;\n    }\n  } else\n    try {\n      (prevTransition = action(prevState, payload)),\n        handleActionReturnValue(actionQueue, node, prevTransition);\n    } catch (error$38) {\n      onActionError(actionQueue, node, error$38);\n    }\n}\nfunction handleActionReturnValue(actionQueue, node, returnValue) {\n  null !== returnValue &&\n  \"object\" === typeof returnValue &&\n  \"function\" === typeof returnValue.then\n    ? returnValue.then(\n        function (nextState) {\n          onActionSuccess(actionQueue, node, nextState);\n        },\n        function (error) {\n          return onActionError(actionQueue, node, error);\n        }\n      )\n    : onActionSuccess(actionQueue, node, returnValue);\n}\nfunction onActionSuccess(actionQueue, actionNode, nextState) {\n  actionNode.status = \"fulfilled\";\n  actionNode.value = nextState;\n  notifyActionListeners(actionNode);\n  actionQueue.state = nextState;\n  actionNode = actionQueue.pending;\n  null !== actionNode &&\n    ((nextState = actionNode.next),\n    nextState === actionNode\n      ? (actionQueue.pending = null)\n      : ((nextState = nextState.next),\n        (actionNode.next = nextState),\n        runActionStateAction(actionQueue, nextState)));\n}\nfunction onActionError(actionQueue, actionNode, error) {\n  var last = actionQueue.pending;\n  actionQueue.pending = null;\n  if (null !== last) {\n    last = last.next;\n    do\n      (actionNode.status = \"rejected\"),\n        (actionNode.reason = error),\n        notifyActionListeners(actionNode),\n        (actionNode = actionNode.next);\n    while (actionNode !== last);\n  }\n  actionQueue.action = null;\n}\nfunction notifyActionListeners(actionNode) {\n  actionNode = actionNode.listeners;\n  for (var i = 0; i < actionNode.length; i++) (0, actionNode[i])();\n}\nfunction actionStateReducer(oldState, newState) {\n  return newState;\n}\nfunction mountActionState(action, initialStateProp) {\n  if (isHydrating) {\n    var ssrFormState = workInProgressRoot.formState;\n    if (null !== ssrFormState) {\n      a: {\n        var JSCompiler_inline_result = currentlyRenderingFiber;\n        if (isHydrating) {\n          if (nextHydratableInstance) {\n            b: {\n              var JSCompiler_inline_result$jscomp$0 = nextHydratableInstance;\n              for (\n                var inRootOrSingleton = rootOrSingletonContext;\n                8 !== JSCompiler_inline_result$jscomp$0.nodeType;\n\n              ) {\n                if (!inRootOrSingleton) {\n                  JSCompiler_inline_result$jscomp$0 = null;\n                  break b;\n                }\n                JSCompiler_inline_result$jscomp$0 = getNextHydratable(\n                  JSCompiler_inline_result$jscomp$0.nextSibling\n                );\n                if (null === JSCompiler_inline_result$jscomp$0) {\n                  JSCompiler_inline_result$jscomp$0 = null;\n                  break b;\n                }\n              }\n              inRootOrSingleton = JSCompiler_inline_result$jscomp$0.data;\n              JSCompiler_inline_result$jscomp$0 =\n                \"F!\" === inRootOrSingleton || \"F\" === inRootOrSingleton\n                  ? JSCompiler_inline_result$jscomp$0\n                  : null;\n            }\n            if (JSCompiler_inline_result$jscomp$0) {\n              nextHydratableInstance = getNextHydratable(\n                JSCompiler_inline_result$jscomp$0.nextSibling\n              );\n              JSCompiler_inline_result =\n                \"F!\" === JSCompiler_inline_result$jscomp$0.data;\n              break a;\n            }\n          }\n          throwOnHydrationMismatch(JSCompiler_inline_result);\n        }\n        JSCompiler_inline_result = !1;\n      }\n      JSCompiler_inline_result && (initialStateProp = ssrFormState[0]);\n    }\n  }\n  ssrFormState = mountWorkInProgressHook();\n  ssrFormState.memoizedState = ssrFormState.baseState = initialStateProp;\n  JSCompiler_inline_result = {\n    pending: null,\n    lanes: 0,\n    dispatch: null,\n    lastRenderedReducer: actionStateReducer,\n    lastRenderedState: initialStateProp\n  };\n  ssrFormState.queue = JSCompiler_inline_result;\n  ssrFormState = dispatchSetState.bind(\n    null,\n    currentlyRenderingFiber,\n    JSCompiler_inline_result\n  );\n  JSCompiler_inline_result.dispatch = ssrFormState;\n  JSCompiler_inline_result = mountStateImpl(!1);\n  inRootOrSingleton = dispatchOptimisticSetState.bind(\n    null,\n    currentlyRenderingFiber,\n    !1,\n    JSCompiler_inline_result.queue\n  );\n  JSCompiler_inline_result = mountWorkInProgressHook();\n  JSCompiler_inline_result$jscomp$0 = {\n    state: initialStateProp,\n    dispatch: null,\n    action: action,\n    pending: null\n  };\n  JSCompiler_inline_result.queue = JSCompiler_inline_result$jscomp$0;\n  ssrFormState = dispatchActionState.bind(\n    null,\n    currentlyRenderingFiber,\n    JSCompiler_inline_result$jscomp$0,\n    inRootOrSingleton,\n    ssrFormState\n  );\n  JSCompiler_inline_result$jscomp$0.dispatch = ssrFormState;\n  JSCompiler_inline_result.memoizedState = action;\n  return [initialStateProp, ssrFormState, !1];\n}\nfunction updateActionState(action) {\n  var stateHook = updateWorkInProgressHook();\n  return updateActionStateImpl(stateHook, currentHook, action);\n}\nfunction updateActionStateImpl(stateHook, currentStateHook, action) {\n  currentStateHook = updateReducerImpl(\n    stateHook,\n    currentStateHook,\n    actionStateReducer\n  )[0];\n  stateHook = updateReducer(basicStateReducer)[0];\n  if (\n    \"object\" === typeof currentStateHook &&\n    null !== currentStateHook &&\n    \"function\" === typeof currentStateHook.then\n  )\n    try {\n      var state = useThenable(currentStateHook);\n    } catch (x) {\n      if (x === SuspenseException) throw SuspenseActionException;\n      throw x;\n    }\n  else state = currentStateHook;\n  currentStateHook = updateWorkInProgressHook();\n  var actionQueue = currentStateHook.queue,\n    dispatch = actionQueue.dispatch;\n  action !== currentStateHook.memoizedState &&\n    ((currentlyRenderingFiber.flags |= 2048),\n    pushSimpleEffect(\n      9,\n      createEffectInstance(),\n      actionStateActionEffect.bind(null, actionQueue, action),\n      null\n    ));\n  return [state, dispatch, stateHook];\n}\nfunction actionStateActionEffect(actionQueue, action) {\n  actionQueue.action = action;\n}\nfunction rerenderActionState(action) {\n  var stateHook = updateWorkInProgressHook(),\n    currentStateHook = currentHook;\n  if (null !== currentStateHook)\n    return updateActionStateImpl(stateHook, currentStateHook, action);\n  updateWorkInProgressHook();\n  stateHook = stateHook.memoizedState;\n  currentStateHook = updateWorkInProgressHook();\n  var dispatch = currentStateHook.queue.dispatch;\n  currentStateHook.memoizedState = action;\n  return [stateHook, dispatch, !1];\n}\nfunction pushSimpleEffect(tag, inst, create, createDeps) {\n  tag = { tag: tag, create: create, deps: createDeps, inst: inst, next: null };\n  inst = currentlyRenderingFiber.updateQueue;\n  null === inst &&\n    ((inst = createFunctionComponentUpdateQueue()),\n    (currentlyRenderingFiber.updateQueue = inst));\n  create = inst.lastEffect;\n  null === create\n    ? (inst.lastEffect = tag.next = tag)\n    : ((createDeps = create.next),\n      (create.next = tag),\n      (tag.next = createDeps),\n      (inst.lastEffect = tag));\n  return tag;\n}\nfunction createEffectInstance() {\n  return { destroy: void 0, resource: void 0 };\n}\nfunction updateRef() {\n  return updateWorkInProgressHook().memoizedState;\n}\nfunction mountEffectImpl(fiberFlags, hookFlags, create, createDeps) {\n  var hook = mountWorkInProgressHook();\n  createDeps = void 0 === createDeps ? null : createDeps;\n  currentlyRenderingFiber.flags |= fiberFlags;\n  hook.memoizedState = pushSimpleEffect(\n    1 | hookFlags,\n    createEffectInstance(),\n    create,\n    createDeps\n  );\n}\nfunction updateEffectImpl(fiberFlags, hookFlags, create, deps) {\n  var hook = updateWorkInProgressHook();\n  deps = void 0 === deps ? null : deps;\n  var inst = hook.memoizedState.inst;\n  null !== currentHook &&\n  null !== deps &&\n  areHookInputsEqual(deps, currentHook.memoizedState.deps)\n    ? (hook.memoizedState = pushSimpleEffect(hookFlags, inst, create, deps))\n    : ((currentlyRenderingFiber.flags |= fiberFlags),\n      (hook.memoizedState = pushSimpleEffect(\n        1 | hookFlags,\n        inst,\n        create,\n        deps\n      )));\n}\nfunction mountEffect(create, createDeps) {\n  mountEffectImpl(8390656, 8, create, createDeps);\n}\nfunction updateEffect(create, createDeps) {\n  updateEffectImpl(2048, 8, create, createDeps);\n}\nfunction updateInsertionEffect(create, deps) {\n  return updateEffectImpl(4, 2, create, deps);\n}\nfunction updateLayoutEffect(create, deps) {\n  return updateEffectImpl(4, 4, create, deps);\n}\nfunction imperativeHandleEffect(create, ref) {\n  if (\"function\" === typeof ref) {\n    create = create();\n    var refCleanup = ref(create);\n    return function () {\n      \"function\" === typeof refCleanup ? refCleanup() : ref(null);\n    };\n  }\n  if (null !== ref && void 0 !== ref)\n    return (\n      (create = create()),\n      (ref.current = create),\n      function () {\n        ref.current = null;\n      }\n    );\n}\nfunction updateImperativeHandle(ref, create, deps) {\n  deps = null !== deps && void 0 !== deps ? deps.concat([ref]) : null;\n  updateEffectImpl(4, 4, imperativeHandleEffect.bind(null, create, ref), deps);\n}\nfunction mountDebugValue() {}\nfunction updateCallback(callback, deps) {\n  var hook = updateWorkInProgressHook();\n  deps = void 0 === deps ? null : deps;\n  var prevState = hook.memoizedState;\n  if (null !== deps && areHookInputsEqual(deps, prevState[1]))\n    return prevState[0];\n  hook.memoizedState = [callback, deps];\n  return callback;\n}\nfunction updateMemo(nextCreate, deps) {\n  var hook = updateWorkInProgressHook();\n  deps = void 0 === deps ? null : deps;\n  var prevState = hook.memoizedState;\n  if (null !== deps && areHookInputsEqual(deps, prevState[1]))\n    return prevState[0];\n  prevState = nextCreate();\n  if (shouldDoubleInvokeUserFnsInHooksDEV) {\n    setIsStrictModeForDevtools(!0);\n    try {\n      nextCreate();\n    } finally {\n      setIsStrictModeForDevtools(!1);\n    }\n  }\n  hook.memoizedState = [prevState, deps];\n  return prevState;\n}\nfunction mountDeferredValueImpl(hook, value, initialValue) {\n  if (void 0 === initialValue || 0 !== (renderLanes & 1073741824))\n    return (hook.memoizedState = value);\n  hook.memoizedState = initialValue;\n  hook = requestDeferredLane();\n  currentlyRenderingFiber.lanes |= hook;\n  workInProgressRootSkippedLanes |= hook;\n  return initialValue;\n}\nfunction updateDeferredValueImpl(hook, prevValue, value, initialValue) {\n  if (objectIs(value, prevValue)) return value;\n  if (null !== currentTreeHiddenStackCursor.current)\n    return (\n      (hook = mountDeferredValueImpl(hook, value, initialValue)),\n      objectIs(hook, prevValue) || (didReceiveUpdate = !0),\n      hook\n    );\n  if (0 === (renderLanes & 42))\n    return (didReceiveUpdate = !0), (hook.memoizedState = value);\n  hook = requestDeferredLane();\n  currentlyRenderingFiber.lanes |= hook;\n  workInProgressRootSkippedLanes |= hook;\n  return prevValue;\n}\nfunction startTransition(fiber, queue, pendingState, finishedState, callback) {\n  var previousPriority = ReactDOMSharedInternals.p;\n  ReactDOMSharedInternals.p =\n    0 !== previousPriority && 8 > previousPriority ? previousPriority : 8;\n  var prevTransition = ReactSharedInternals.T,\n    currentTransition = {};\n  ReactSharedInternals.T = currentTransition;\n  dispatchOptimisticSetState(fiber, !1, queue, pendingState);\n  try {\n    var returnValue = callback(),\n      onStartTransitionFinish = ReactSharedInternals.S;\n    null !== onStartTransitionFinish &&\n      onStartTransitionFinish(currentTransition, returnValue);\n    if (\n      null !== returnValue &&\n      \"object\" === typeof returnValue &&\n      \"function\" === typeof returnValue.then\n    ) {\n      var thenableForFinishedState = chainThenableValue(\n        returnValue,\n        finishedState\n      );\n      dispatchSetStateInternal(\n        fiber,\n        queue,\n        thenableForFinishedState,\n        requestUpdateLane(fiber)\n      );\n    } else\n      dispatchSetStateInternal(\n        fiber,\n        queue,\n        finishedState,\n        requestUpdateLane(fiber)\n      );\n  } catch (error) {\n    dispatchSetStateInternal(\n      fiber,\n      queue,\n      { then: function () {}, status: \"rejected\", reason: error },\n      requestUpdateLane()\n    );\n  } finally {\n    (ReactDOMSharedInternals.p = previousPriority),\n      (ReactSharedInternals.T = prevTransition);\n  }\n}\nfunction noop$2() {}\nfunction startHostTransition(formFiber, pendingState, action, formData) {\n  if (5 !== formFiber.tag) throw Error(formatProdErrorMessage(476));\n  var queue = ensureFormComponentIsStateful(formFiber).queue;\n  startTransition(\n    formFiber,\n    queue,\n    pendingState,\n    sharedNotPendingObject,\n    null === action\n      ? noop$2\n      : function () {\n          requestFormReset$1(formFiber);\n          return action(formData);\n        }\n  );\n}\nfunction ensureFormComponentIsStateful(formFiber) {\n  var existingStateHook = formFiber.memoizedState;\n  if (null !== existingStateHook) return existingStateHook;\n  existingStateHook = {\n    memoizedState: sharedNotPendingObject,\n    baseState: sharedNotPendingObject,\n    baseQueue: null,\n    queue: {\n      pending: null,\n      lanes: 0,\n      dispatch: null,\n      lastRenderedReducer: basicStateReducer,\n      lastRenderedState: sharedNotPendingObject\n    },\n    next: null\n  };\n  var initialResetState = {};\n  existingStateHook.next = {\n    memoizedState: initialResetState,\n    baseState: initialResetState,\n    baseQueue: null,\n    queue: {\n      pending: null,\n      lanes: 0,\n      dispatch: null,\n      lastRenderedReducer: basicStateReducer,\n      lastRenderedState: initialResetState\n    },\n    next: null\n  };\n  formFiber.memoizedState = existingStateHook;\n  formFiber = formFiber.alternate;\n  null !== formFiber && (formFiber.memoizedState = existingStateHook);\n  return existingStateHook;\n}\nfunction requestFormReset$1(formFiber) {\n  var resetStateQueue = ensureFormComponentIsStateful(formFiber).next.queue;\n  dispatchSetStateInternal(formFiber, resetStateQueue, {}, requestUpdateLane());\n}\nfunction useHostTransitionStatus() {\n  return readContext(HostTransitionContext);\n}\nfunction updateId() {\n  return updateWorkInProgressHook().memoizedState;\n}\nfunction updateRefresh() {\n  return updateWorkInProgressHook().memoizedState;\n}\nfunction refreshCache(fiber) {\n  for (var provider = fiber.return; null !== provider; ) {\n    switch (provider.tag) {\n      case 24:\n      case 3:\n        var lane = requestUpdateLane();\n        fiber = createUpdate(lane);\n        var root$41 = enqueueUpdate(provider, fiber, lane);\n        null !== root$41 &&\n          (scheduleUpdateOnFiber(root$41, provider, lane),\n          entangleTransitions(root$41, provider, lane));\n        provider = { cache: createCache() };\n        fiber.payload = provider;\n        return;\n    }\n    provider = provider.return;\n  }\n}\nfunction dispatchReducerAction(fiber, queue, action) {\n  var lane = requestUpdateLane();\n  action = {\n    lane: lane,\n    revertLane: 0,\n    action: action,\n    hasEagerState: !1,\n    eagerState: null,\n    next: null\n  };\n  isRenderPhaseUpdate(fiber)\n    ? enqueueRenderPhaseUpdate(queue, action)\n    : ((action = enqueueConcurrentHookUpdate(fiber, queue, action, lane)),\n      null !== action &&\n        (scheduleUpdateOnFiber(action, fiber, lane),\n        entangleTransitionUpdate(action, queue, lane)));\n}\nfunction dispatchSetState(fiber, queue, action) {\n  var lane = requestUpdateLane();\n  dispatchSetStateInternal(fiber, queue, action, lane);\n}\nfunction dispatchSetStateInternal(fiber, queue, action, lane) {\n  var update = {\n    lane: lane,\n    revertLane: 0,\n    action: action,\n    hasEagerState: !1,\n    eagerState: null,\n    next: null\n  };\n  if (isRenderPhaseUpdate(fiber)) enqueueRenderPhaseUpdate(queue, update);\n  else {\n    var alternate = fiber.alternate;\n    if (\n      0 === fiber.lanes &&\n      (null === alternate || 0 === alternate.lanes) &&\n      ((alternate = queue.lastRenderedReducer), null !== alternate)\n    )\n      try {\n        var currentState = queue.lastRenderedState,\n          eagerState = alternate(currentState, action);\n        update.hasEagerState = !0;\n        update.eagerState = eagerState;\n        if (objectIs(eagerState, currentState))\n          return (\n            enqueueUpdate$1(fiber, queue, update, 0),\n            null === workInProgressRoot && finishQueueingConcurrentUpdates(),\n            !1\n          );\n      } catch (error) {\n      } finally {\n      }\n    action = enqueueConcurrentHookUpdate(fiber, queue, update, lane);\n    if (null !== action)\n      return (\n        scheduleUpdateOnFiber(action, fiber, lane),\n        entangleTransitionUpdate(action, queue, lane),\n        !0\n      );\n  }\n  return !1;\n}\nfunction dispatchOptimisticSetState(fiber, throwIfDuringRender, queue, action) {\n  action = {\n    lane: 2,\n    revertLane: requestTransitionLane(),\n    action: action,\n    hasEagerState: !1,\n    eagerState: null,\n    next: null\n  };\n  if (isRenderPhaseUpdate(fiber)) {\n    if (throwIfDuringRender) throw Error(formatProdErrorMessage(479));\n  } else\n    (throwIfDuringRender = enqueueConcurrentHookUpdate(\n      fiber,\n      queue,\n      action,\n      2\n    )),\n      null !== throwIfDuringRender &&\n        scheduleUpdateOnFiber(throwIfDuringRender, fiber, 2);\n}\nfunction isRenderPhaseUpdate(fiber) {\n  var alternate = fiber.alternate;\n  return (\n    fiber === currentlyRenderingFiber ||\n    (null !== alternate && alternate === currentlyRenderingFiber)\n  );\n}\nfunction enqueueRenderPhaseUpdate(queue, update) {\n  didScheduleRenderPhaseUpdateDuringThisPass = didScheduleRenderPhaseUpdate =\n    !0;\n  var pending = queue.pending;\n  null === pending\n    ? (update.next = update)\n    : ((update.next = pending.next), (pending.next = update));\n  queue.pending = update;\n}\nfunction entangleTransitionUpdate(root, queue, lane) {\n  if (0 !== (lane & 4194048)) {\n    var queueLanes = queue.lanes;\n    queueLanes &= root.pendingLanes;\n    lane |= queueLanes;\n    queue.lanes = lane;\n    markRootEntangled(root, lane);\n  }\n}\nvar ContextOnlyDispatcher = {\n    readContext: readContext,\n    use: use,\n    useCallback: throwInvalidHookError,\n    useContext: throwInvalidHookError,\n    useEffect: throwInvalidHookError,\n    useImperativeHandle: throwInvalidHookError,\n    useLayoutEffect: throwInvalidHookError,\n    useInsertionEffect: throwInvalidHookError,\n    useMemo: throwInvalidHookError,\n    useReducer: throwInvalidHookError,\n    useRef: throwInvalidHookError,\n    useState: throwInvalidHookError,\n    useDebugValue: throwInvalidHookError,\n    useDeferredValue: throwInvalidHookError,\n    useTransition: throwInvalidHookError,\n    useSyncExternalStore: throwInvalidHookError,\n    useId: throwInvalidHookError,\n    useHostTransitionStatus: throwInvalidHookError,\n    useFormState: throwInvalidHookError,\n    useActionState: throwInvalidHookError,\n    useOptimistic: throwInvalidHookError,\n    useMemoCache: throwInvalidHookError,\n    useCacheRefresh: throwInvalidHookError\n  },\n  HooksDispatcherOnMount = {\n    readContext: readContext,\n    use: use,\n    useCallback: function (callback, deps) {\n      mountWorkInProgressHook().memoizedState = [\n        callback,\n        void 0 === deps ? null : deps\n      ];\n      return callback;\n    },\n    useContext: readContext,\n    useEffect: mountEffect,\n    useImperativeHandle: function (ref, create, deps) {\n      deps = null !== deps && void 0 !== deps ? deps.concat([ref]) : null;\n      mountEffectImpl(\n        4194308,\n        4,\n        imperativeHandleEffect.bind(null, create, ref),\n        deps\n      );\n    },\n    useLayoutEffect: function (create, deps) {\n      return mountEffectImpl(4194308, 4, create, deps);\n    },\n    useInsertionEffect: function (create, deps) {\n      mountEffectImpl(4, 2, create, deps);\n    },\n    useMemo: function (nextCreate, deps) {\n      var hook = mountWorkInProgressHook();\n      deps = void 0 === deps ? null : deps;\n      var nextValue = nextCreate();\n      if (shouldDoubleInvokeUserFnsInHooksDEV) {\n        setIsStrictModeForDevtools(!0);\n        try {\n          nextCreate();\n        } finally {\n          setIsStrictModeForDevtools(!1);\n        }\n      }\n      hook.memoizedState = [nextValue, deps];\n      return nextValue;\n    },\n    useReducer: function (reducer, initialArg, init) {\n      var hook = mountWorkInProgressHook();\n      if (void 0 !== init) {\n        var initialState = init(initialArg);\n        if (shouldDoubleInvokeUserFnsInHooksDEV) {\n          setIsStrictModeForDevtools(!0);\n          try {\n            init(initialArg);\n          } finally {\n            setIsStrictModeForDevtools(!1);\n          }\n        }\n      } else initialState = initialArg;\n      hook.memoizedState = hook.baseState = initialState;\n      reducer = {\n        pending: null,\n        lanes: 0,\n        dispatch: null,\n        lastRenderedReducer: reducer,\n        lastRenderedState: initialState\n      };\n      hook.queue = reducer;\n      reducer = reducer.dispatch = dispatchReducerAction.bind(\n        null,\n        currentlyRenderingFiber,\n        reducer\n      );\n      return [hook.memoizedState, reducer];\n    },\n    useRef: function (initialValue) {\n      var hook = mountWorkInProgressHook();\n      initialValue = { current: initialValue };\n      return (hook.memoizedState = initialValue);\n    },\n    useState: function (initialState) {\n      initialState = mountStateImpl(initialState);\n      var queue = initialState.queue,\n        dispatch = dispatchSetState.bind(null, currentlyRenderingFiber, queue);\n      queue.dispatch = dispatch;\n      return [initialState.memoizedState, dispatch];\n    },\n    useDebugValue: mountDebugValue,\n    useDeferredValue: function (value, initialValue) {\n      var hook = mountWorkInProgressHook();\n      return mountDeferredValueImpl(hook, value, initialValue);\n    },\n    useTransition: function () {\n      var stateHook = mountStateImpl(!1);\n      stateHook = startTransition.bind(\n        null,\n        currentlyRenderingFiber,\n        stateHook.queue,\n        !0,\n        !1\n      );\n      mountWorkInProgressHook().memoizedState = stateHook;\n      return [!1, stateHook];\n    },\n    useSyncExternalStore: function (subscribe, getSnapshot, getServerSnapshot) {\n      var fiber = currentlyRenderingFiber,\n        hook = mountWorkInProgressHook();\n      if (isHydrating) {\n        if (void 0 === getServerSnapshot)\n          throw Error(formatProdErrorMessage(407));\n        getServerSnapshot = getServerSnapshot();\n      } else {\n        getServerSnapshot = getSnapshot();\n        if (null === workInProgressRoot)\n          throw Error(formatProdErrorMessage(349));\n        0 !== (workInProgressRootRenderLanes & 124) ||\n          pushStoreConsistencyCheck(fiber, getSnapshot, getServerSnapshot);\n      }\n      hook.memoizedState = getServerSnapshot;\n      var inst = { value: getServerSnapshot, getSnapshot: getSnapshot };\n      hook.queue = inst;\n      mountEffect(subscribeToStore.bind(null, fiber, inst, subscribe), [\n        subscribe\n      ]);\n      fiber.flags |= 2048;\n      pushSimpleEffect(\n        9,\n        createEffectInstance(),\n        updateStoreInstance.bind(\n          null,\n          fiber,\n          inst,\n          getServerSnapshot,\n          getSnapshot\n        ),\n        null\n      );\n      return getServerSnapshot;\n    },\n    useId: function () {\n      var hook = mountWorkInProgressHook(),\n        identifierPrefix = workInProgressRoot.identifierPrefix;\n      if (isHydrating) {\n        var JSCompiler_inline_result = treeContextOverflow;\n        var idWithLeadingBit = treeContextId;\n        JSCompiler_inline_result =\n          (\n            idWithLeadingBit & ~(1 << (32 - clz32(idWithLeadingBit) - 1))\n          ).toString(32) + JSCompiler_inline_result;\n        identifierPrefix =\n          \"\\u00ab\" + identifierPrefix + \"R\" + JSCompiler_inline_result;\n        JSCompiler_inline_result = localIdCounter++;\n        0 < JSCompiler_inline_result &&\n          (identifierPrefix += \"H\" + JSCompiler_inline_result.toString(32));\n        identifierPrefix += \"\\u00bb\";\n      } else\n        (JSCompiler_inline_result = globalClientIdCounter++),\n          (identifierPrefix =\n            \"\\u00ab\" +\n            identifierPrefix +\n            \"r\" +\n            JSCompiler_inline_result.toString(32) +\n            \"\\u00bb\");\n      return (hook.memoizedState = identifierPrefix);\n    },\n    useHostTransitionStatus: useHostTransitionStatus,\n    useFormState: mountActionState,\n    useActionState: mountActionState,\n    useOptimistic: function (passthrough) {\n      var hook = mountWorkInProgressHook();\n      hook.memoizedState = hook.baseState = passthrough;\n      var queue = {\n        pending: null,\n        lanes: 0,\n        dispatch: null,\n        lastRenderedReducer: null,\n        lastRenderedState: null\n      };\n      hook.queue = queue;\n      hook = dispatchOptimisticSetState.bind(\n        null,\n        currentlyRenderingFiber,\n        !0,\n        queue\n      );\n      queue.dispatch = hook;\n      return [passthrough, hook];\n    },\n    useMemoCache: useMemoCache,\n    useCacheRefresh: function () {\n      return (mountWorkInProgressHook().memoizedState = refreshCache.bind(\n        null,\n        currentlyRenderingFiber\n      ));\n    }\n  },\n  HooksDispatcherOnUpdate = {\n    readContext: readContext,\n    use: use,\n    useCallback: updateCallback,\n    useContext: readContext,\n    useEffect: updateEffect,\n    useImperativeHandle: updateImperativeHandle,\n    useInsertionEffect: updateInsertionEffect,\n    useLayoutEffect: updateLayoutEffect,\n    useMemo: updateMemo,\n    useReducer: updateReducer,\n    useRef: updateRef,\n    useState: function () {\n      return updateReducer(basicStateReducer);\n    },\n    useDebugValue: mountDebugValue,\n    useDeferredValue: function (value, initialValue) {\n      var hook = updateWorkInProgressHook();\n      return updateDeferredValueImpl(\n        hook,\n        currentHook.memoizedState,\n        value,\n        initialValue\n      );\n    },\n    useTransition: function () {\n      var booleanOrThenable = updateReducer(basicStateReducer)[0],\n        start = updateWorkInProgressHook().memoizedState;\n      return [\n        \"boolean\" === typeof booleanOrThenable\n          ? booleanOrThenable\n          : useThenable(booleanOrThenable),\n        start\n      ];\n    },\n    useSyncExternalStore: updateSyncExternalStore,\n    useId: updateId,\n    useHostTransitionStatus: useHostTransitionStatus,\n    useFormState: updateActionState,\n    useActionState: updateActionState,\n    useOptimistic: function (passthrough, reducer) {\n      var hook = updateWorkInProgressHook();\n      return updateOptimisticImpl(hook, currentHook, passthrough, reducer);\n    },\n    useMemoCache: useMemoCache,\n    useCacheRefresh: updateRefresh\n  },\n  HooksDispatcherOnRerender = {\n    readContext: readContext,\n    use: use,\n    useCallback: updateCallback,\n    useContext: readContext,\n    useEffect: updateEffect,\n    useImperativeHandle: updateImperativeHandle,\n    useInsertionEffect: updateInsertionEffect,\n    useLayoutEffect: updateLayoutEffect,\n    useMemo: updateMemo,\n    useReducer: rerenderReducer,\n    useRef: updateRef,\n    useState: function () {\n      return rerenderReducer(basicStateReducer);\n    },\n    useDebugValue: mountDebugValue,\n    useDeferredValue: function (value, initialValue) {\n      var hook = updateWorkInProgressHook();\n      return null === currentHook\n        ? mountDeferredValueImpl(hook, value, initialValue)\n        : updateDeferredValueImpl(\n            hook,\n            currentHook.memoizedState,\n            value,\n            initialValue\n          );\n    },\n    useTransition: function () {\n      var booleanOrThenable = rerenderReducer(basicStateReducer)[0],\n        start = updateWorkInProgressHook().memoizedState;\n      return [\n        \"boolean\" === typeof booleanOrThenable\n          ? booleanOrThenable\n          : useThenable(booleanOrThenable),\n        start\n      ];\n    },\n    useSyncExternalStore: updateSyncExternalStore,\n    useId: updateId,\n    useHostTransitionStatus: useHostTransitionStatus,\n    useFormState: rerenderActionState,\n    useActionState: rerenderActionState,\n    useOptimistic: function (passthrough, reducer) {\n      var hook = updateWorkInProgressHook();\n      if (null !== currentHook)\n        return updateOptimisticImpl(hook, currentHook, passthrough, reducer);\n      hook.baseState = passthrough;\n      return [passthrough, hook.queue.dispatch];\n    },\n    useMemoCache: useMemoCache,\n    useCacheRefresh: updateRefresh\n  },\n  thenableState = null,\n  thenableIndexCounter = 0;\nfunction unwrapThenable(thenable) {\n  var index = thenableIndexCounter;\n  thenableIndexCounter += 1;\n  null === thenableState && (thenableState = []);\n  return trackUsedThenable(thenableState, thenable, index);\n}\nfunction coerceRef(workInProgress, element) {\n  element = element.props.ref;\n  workInProgress.ref = void 0 !== element ? element : null;\n}\nfunction throwOnInvalidObjectType(returnFiber, newChild) {\n  if (newChild.$$typeof === REACT_LEGACY_ELEMENT_TYPE)\n    throw Error(formatProdErrorMessage(525));\n  returnFiber = Object.prototype.toString.call(newChild);\n  throw Error(\n    formatProdErrorMessage(\n      31,\n      \"[object Object]\" === returnFiber\n        ? \"object with keys {\" + Object.keys(newChild).join(\", \") + \"}\"\n        : returnFiber\n    )\n  );\n}\nfunction resolveLazy(lazyType) {\n  var init = lazyType._init;\n  return init(lazyType._payload);\n}\nfunction createChildReconciler(shouldTrackSideEffects) {\n  function deleteChild(returnFiber, childToDelete) {\n    if (shouldTrackSideEffects) {\n      var deletions = returnFiber.deletions;\n      null === deletions\n        ? ((returnFiber.deletions = [childToDelete]), (returnFiber.flags |= 16))\n        : deletions.push(childToDelete);\n    }\n  }\n  function deleteRemainingChildren(returnFiber, currentFirstChild) {\n    if (!shouldTrackSideEffects) return null;\n    for (; null !== currentFirstChild; )\n      deleteChild(returnFiber, currentFirstChild),\n        (currentFirstChild = currentFirstChild.sibling);\n    return null;\n  }\n  function mapRemainingChildren(currentFirstChild) {\n    for (var existingChildren = new Map(); null !== currentFirstChild; )\n      null !== currentFirstChild.key\n        ? existingChildren.set(currentFirstChild.key, currentFirstChild)\n        : existingChildren.set(currentFirstChild.index, currentFirstChild),\n        (currentFirstChild = currentFirstChild.sibling);\n    return existingChildren;\n  }\n  function useFiber(fiber, pendingProps) {\n    fiber = createWorkInProgress(fiber, pendingProps);\n    fiber.index = 0;\n    fiber.sibling = null;\n    return fiber;\n  }\n  function placeChild(newFiber, lastPlacedIndex, newIndex) {\n    newFiber.index = newIndex;\n    if (!shouldTrackSideEffects)\n      return (newFiber.flags |= 1048576), lastPlacedIndex;\n    newIndex = newFiber.alternate;\n    if (null !== newIndex)\n      return (\n        (newIndex = newIndex.index),\n        newIndex < lastPlacedIndex\n          ? ((newFiber.flags |= 67108866), lastPlacedIndex)\n          : newIndex\n      );\n    newFiber.flags |= 67108866;\n    return lastPlacedIndex;\n  }\n  function placeSingleChild(newFiber) {\n    shouldTrackSideEffects &&\n      null === newFiber.alternate &&\n      (newFiber.flags |= 67108866);\n    return newFiber;\n  }\n  function updateTextNode(returnFiber, current, textContent, lanes) {\n    if (null === current || 6 !== current.tag)\n      return (\n        (current = createFiberFromText(textContent, returnFiber.mode, lanes)),\n        (current.return = returnFiber),\n        current\n      );\n    current = useFiber(current, textContent);\n    current.return = returnFiber;\n    return current;\n  }\n  function updateElement(returnFiber, current, element, lanes) {\n    var elementType = element.type;\n    if (elementType === REACT_FRAGMENT_TYPE)\n      return updateFragment(\n        returnFiber,\n        current,\n        element.props.children,\n        lanes,\n        element.key\n      );\n    if (\n      null !== current &&\n      (current.elementType === elementType ||\n        (\"object\" === typeof elementType &&\n          null !== elementType &&\n          elementType.$$typeof === REACT_LAZY_TYPE &&\n          resolveLazy(elementType) === current.type))\n    )\n      return (\n        (current = useFiber(current, element.props)),\n        coerceRef(current, element),\n        (current.return = returnFiber),\n        current\n      );\n    current = createFiberFromTypeAndProps(\n      element.type,\n      element.key,\n      element.props,\n      null,\n      returnFiber.mode,\n      lanes\n    );\n    coerceRef(current, element);\n    current.return = returnFiber;\n    return current;\n  }\n  function updatePortal(returnFiber, current, portal, lanes) {\n    if (\n      null === current ||\n      4 !== current.tag ||\n      current.stateNode.containerInfo !== portal.containerInfo ||\n      current.stateNode.implementation !== portal.implementation\n    )\n      return (\n        (current = createFiberFromPortal(portal, returnFiber.mode, lanes)),\n        (current.return = returnFiber),\n        current\n      );\n    current = useFiber(current, portal.children || []);\n    current.return = returnFiber;\n    return current;\n  }\n  function updateFragment(returnFiber, current, fragment, lanes, key) {\n    if (null === current || 7 !== current.tag)\n      return (\n        (current = createFiberFromFragment(\n          fragment,\n          returnFiber.mode,\n          lanes,\n          key\n        )),\n        (current.return = returnFiber),\n        current\n      );\n    current = useFiber(current, fragment);\n    current.return = returnFiber;\n    return current;\n  }\n  function createChild(returnFiber, newChild, lanes) {\n    if (\n      (\"string\" === typeof newChild && \"\" !== newChild) ||\n      \"number\" === typeof newChild ||\n      \"bigint\" === typeof newChild\n    )\n      return (\n        (newChild = createFiberFromText(\n          \"\" + newChild,\n          returnFiber.mode,\n          lanes\n        )),\n        (newChild.return = returnFiber),\n        newChild\n      );\n    if (\"object\" === typeof newChild && null !== newChild) {\n      switch (newChild.$$typeof) {\n        case REACT_ELEMENT_TYPE:\n          return (\n            (lanes = createFiberFromTypeAndProps(\n              newChild.type,\n              newChild.key,\n              newChild.props,\n              null,\n              returnFiber.mode,\n              lanes\n            )),\n            coerceRef(lanes, newChild),\n            (lanes.return = returnFiber),\n            lanes\n          );\n        case REACT_PORTAL_TYPE:\n          return (\n            (newChild = createFiberFromPortal(\n              newChild,\n              returnFiber.mode,\n              lanes\n            )),\n            (newChild.return = returnFiber),\n            newChild\n          );\n        case REACT_LAZY_TYPE:\n          var init = newChild._init;\n          newChild = init(newChild._payload);\n          return createChild(returnFiber, newChild, lanes);\n      }\n      if (isArrayImpl(newChild) || getIteratorFn(newChild))\n        return (\n          (newChild = createFiberFromFragment(\n            newChild,\n            returnFiber.mode,\n            lanes,\n            null\n          )),\n          (newChild.return = returnFiber),\n          newChild\n        );\n      if (\"function\" === typeof newChild.then)\n        return createChild(returnFiber, unwrapThenable(newChild), lanes);\n      if (newChild.$$typeof === REACT_CONTEXT_TYPE)\n        return createChild(\n          returnFiber,\n          readContextDuringReconciliation(returnFiber, newChild),\n          lanes\n        );\n      throwOnInvalidObjectType(returnFiber, newChild);\n    }\n    return null;\n  }\n  function updateSlot(returnFiber, oldFiber, newChild, lanes) {\n    var key = null !== oldFiber ? oldFiber.key : null;\n    if (\n      (\"string\" === typeof newChild && \"\" !== newChild) ||\n      \"number\" === typeof newChild ||\n      \"bigint\" === typeof newChild\n    )\n      return null !== key\n        ? null\n        : updateTextNode(returnFiber, oldFiber, \"\" + newChild, lanes);\n    if (\"object\" === typeof newChild && null !== newChild) {\n      switch (newChild.$$typeof) {\n        case REACT_ELEMENT_TYPE:\n          return newChild.key === key\n            ? updateElement(returnFiber, oldFiber, newChild, lanes)\n            : null;\n        case REACT_PORTAL_TYPE:\n          return newChild.key === key\n            ? updatePortal(returnFiber, oldFiber, newChild, lanes)\n            : null;\n        case REACT_LAZY_TYPE:\n          return (\n            (key = newChild._init),\n            (newChild = key(newChild._payload)),\n            updateSlot(returnFiber, oldFiber, newChild, lanes)\n          );\n      }\n      if (isArrayImpl(newChild) || getIteratorFn(newChild))\n        return null !== key\n          ? null\n          : updateFragment(returnFiber, oldFiber, newChild, lanes, null);\n      if (\"function\" === typeof newChild.then)\n        return updateSlot(\n          returnFiber,\n          oldFiber,\n          unwrapThenable(newChild),\n          lanes\n        );\n      if (newChild.$$typeof === REACT_CONTEXT_TYPE)\n        return updateSlot(\n          returnFiber,\n          oldFiber,\n          readContextDuringReconciliation(returnFiber, newChild),\n          lanes\n        );\n      throwOnInvalidObjectType(returnFiber, newChild);\n    }\n    return null;\n  }\n  function updateFromMap(\n    existingChildren,\n    returnFiber,\n    newIdx,\n    newChild,\n    lanes\n  ) {\n    if (\n      (\"string\" === typeof newChild && \"\" !== newChild) ||\n      \"number\" === typeof newChild ||\n      \"bigint\" === typeof newChild\n    )\n      return (\n        (existingChildren = existingChildren.get(newIdx) || null),\n        updateTextNode(returnFiber, existingChildren, \"\" + newChild, lanes)\n      );\n    if (\"object\" === typeof newChild && null !== newChild) {\n      switch (newChild.$$typeof) {\n        case REACT_ELEMENT_TYPE:\n          return (\n            (existingChildren =\n              existingChildren.get(\n                null === newChild.key ? newIdx : newChild.key\n              ) || null),\n            updateElement(returnFiber, existingChildren, newChild, lanes)\n          );\n        case REACT_PORTAL_TYPE:\n          return (\n            (existingChildren =\n              existingChildren.get(\n                null === newChild.key ? newIdx : newChild.key\n              ) || null),\n            updatePortal(returnFiber, existingChildren, newChild, lanes)\n          );\n        case REACT_LAZY_TYPE:\n          var init = newChild._init;\n          newChild = init(newChild._payload);\n          return updateFromMap(\n            existingChildren,\n            returnFiber,\n            newIdx,\n            newChild,\n            lanes\n          );\n      }\n      if (isArrayImpl(newChild) || getIteratorFn(newChild))\n        return (\n          (existingChildren = existingChildren.get(newIdx) || null),\n          updateFragment(returnFiber, existingChildren, newChild, lanes, null)\n        );\n      if (\"function\" === typeof newChild.then)\n        return updateFromMap(\n          existingChildren,\n          returnFiber,\n          newIdx,\n          unwrapThenable(newChild),\n          lanes\n        );\n      if (newChild.$$typeof === REACT_CONTEXT_TYPE)\n        return updateFromMap(\n          existingChildren,\n          returnFiber,\n          newIdx,\n          readContextDuringReconciliation(returnFiber, newChild),\n          lanes\n        );\n      throwOnInvalidObjectType(returnFiber, newChild);\n    }\n    return null;\n  }\n  function reconcileChildrenArray(\n    returnFiber,\n    currentFirstChild,\n    newChildren,\n    lanes\n  ) {\n    for (\n      var resultingFirstChild = null,\n        previousNewFiber = null,\n        oldFiber = currentFirstChild,\n        newIdx = (currentFirstChild = 0),\n        nextOldFiber = null;\n      null !== oldFiber && newIdx < newChildren.length;\n      newIdx++\n    ) {\n      oldFiber.index > newIdx\n        ? ((nextOldFiber = oldFiber), (oldFiber = null))\n        : (nextOldFiber = oldFiber.sibling);\n      var newFiber = updateSlot(\n        returnFiber,\n        oldFiber,\n        newChildren[newIdx],\n        lanes\n      );\n      if (null === newFiber) {\n        null === oldFiber && (oldFiber = nextOldFiber);\n        break;\n      }\n      shouldTrackSideEffects &&\n        oldFiber &&\n        null === newFiber.alternate &&\n        deleteChild(returnFiber, oldFiber);\n      currentFirstChild = placeChild(newFiber, currentFirstChild, newIdx);\n      null === previousNewFiber\n        ? (resultingFirstChild = newFiber)\n        : (previousNewFiber.sibling = newFiber);\n      previousNewFiber = newFiber;\n      oldFiber = nextOldFiber;\n    }\n    if (newIdx === newChildren.length)\n      return (\n        deleteRemainingChildren(returnFiber, oldFiber),\n        isHydrating && pushTreeFork(returnFiber, newIdx),\n        resultingFirstChild\n      );\n    if (null === oldFiber) {\n      for (; newIdx < newChildren.length; newIdx++)\n        (oldFiber = createChild(returnFiber, newChildren[newIdx], lanes)),\n          null !== oldFiber &&\n            ((currentFirstChild = placeChild(\n              oldFiber,\n              currentFirstChild,\n              newIdx\n            )),\n            null === previousNewFiber\n              ? (resultingFirstChild = oldFiber)\n              : (previousNewFiber.sibling = oldFiber),\n            (previousNewFiber = oldFiber));\n      isHydrating && pushTreeFork(returnFiber, newIdx);\n      return resultingFirstChild;\n    }\n    for (\n      oldFiber = mapRemainingChildren(oldFiber);\n      newIdx < newChildren.length;\n      newIdx++\n    )\n      (nextOldFiber = updateFromMap(\n        oldFiber,\n        returnFiber,\n        newIdx,\n        newChildren[newIdx],\n        lanes\n      )),\n        null !== nextOldFiber &&\n          (shouldTrackSideEffects &&\n            null !== nextOldFiber.alternate &&\n            oldFiber.delete(\n              null === nextOldFiber.key ? newIdx : nextOldFiber.key\n            ),\n          (currentFirstChild = placeChild(\n            nextOldFiber,\n            currentFirstChild,\n            newIdx\n          )),\n          null === previousNewFiber\n            ? (resultingFirstChild = nextOldFiber)\n            : (previousNewFiber.sibling = nextOldFiber),\n          (previousNewFiber = nextOldFiber));\n    shouldTrackSideEffects &&\n      oldFiber.forEach(function (child) {\n        return deleteChild(returnFiber, child);\n      });\n    isHydrating && pushTreeFork(returnFiber, newIdx);\n    return resultingFirstChild;\n  }\n  function reconcileChildrenIterator(\n    returnFiber,\n    currentFirstChild,\n    newChildren,\n    lanes\n  ) {\n    if (null == newChildren) throw Error(formatProdErrorMessage(151));\n    for (\n      var resultingFirstChild = null,\n        previousNewFiber = null,\n        oldFiber = currentFirstChild,\n        newIdx = (currentFirstChild = 0),\n        nextOldFiber = null,\n        step = newChildren.next();\n      null !== oldFiber && !step.done;\n      newIdx++, step = newChildren.next()\n    ) {\n      oldFiber.index > newIdx\n        ? ((nextOldFiber = oldFiber), (oldFiber = null))\n        : (nextOldFiber = oldFiber.sibling);\n      var newFiber = updateSlot(returnFiber, oldFiber, step.value, lanes);\n      if (null === newFiber) {\n        null === oldFiber && (oldFiber = nextOldFiber);\n        break;\n      }\n      shouldTrackSideEffects &&\n        oldFiber &&\n        null === newFiber.alternate &&\n        deleteChild(returnFiber, oldFiber);\n      currentFirstChild = placeChild(newFiber, currentFirstChild, newIdx);\n      null === previousNewFiber\n        ? (resultingFirstChild = newFiber)\n        : (previousNewFiber.sibling = newFiber);\n      previousNewFiber = newFiber;\n      oldFiber = nextOldFiber;\n    }\n    if (step.done)\n      return (\n        deleteRemainingChildren(returnFiber, oldFiber),\n        isHydrating && pushTreeFork(returnFiber, newIdx),\n        resultingFirstChild\n      );\n    if (null === oldFiber) {\n      for (; !step.done; newIdx++, step = newChildren.next())\n        (step = createChild(returnFiber, step.value, lanes)),\n          null !== step &&\n            ((currentFirstChild = placeChild(step, currentFirstChild, newIdx)),\n            null === previousNewFiber\n              ? (resultingFirstChild = step)\n              : (previousNewFiber.sibling = step),\n            (previousNewFiber = step));\n      isHydrating && pushTreeFork(returnFiber, newIdx);\n      return resultingFirstChild;\n    }\n    for (\n      oldFiber = mapRemainingChildren(oldFiber);\n      !step.done;\n      newIdx++, step = newChildren.next()\n    )\n      (step = updateFromMap(oldFiber, returnFiber, newIdx, step.value, lanes)),\n        null !== step &&\n          (shouldTrackSideEffects &&\n            null !== step.alternate &&\n            oldFiber.delete(null === step.key ? newIdx : step.key),\n          (currentFirstChild = placeChild(step, currentFirstChild, newIdx)),\n          null === previousNewFiber\n            ? (resultingFirstChild = step)\n            : (previousNewFiber.sibling = step),\n          (previousNewFiber = step));\n    shouldTrackSideEffects &&\n      oldFiber.forEach(function (child) {\n        return deleteChild(returnFiber, child);\n      });\n    isHydrating && pushTreeFork(returnFiber, newIdx);\n    return resultingFirstChild;\n  }\n  function reconcileChildFibersImpl(\n    returnFiber,\n    currentFirstChild,\n    newChild,\n    lanes\n  ) {\n    \"object\" === typeof newChild &&\n      null !== newChild &&\n      newChild.type === REACT_FRAGMENT_TYPE &&\n      null === newChild.key &&\n      (newChild = newChild.props.children);\n    if (\"object\" === typeof newChild && null !== newChild) {\n      switch (newChild.$$typeof) {\n        case REACT_ELEMENT_TYPE:\n          a: {\n            for (var key = newChild.key; null !== currentFirstChild; ) {\n              if (currentFirstChild.key === key) {\n                key = newChild.type;\n                if (key === REACT_FRAGMENT_TYPE) {\n                  if (7 === currentFirstChild.tag) {\n                    deleteRemainingChildren(\n                      returnFiber,\n                      currentFirstChild.sibling\n                    );\n                    lanes = useFiber(\n                      currentFirstChild,\n                      newChild.props.children\n                    );\n                    lanes.return = returnFiber;\n                    returnFiber = lanes;\n                    break a;\n                  }\n                } else if (\n                  currentFirstChild.elementType === key ||\n                  (\"object\" === typeof key &&\n                    null !== key &&\n                    key.$$typeof === REACT_LAZY_TYPE &&\n                    resolveLazy(key) === currentFirstChild.type)\n                ) {\n                  deleteRemainingChildren(\n                    returnFiber,\n                    currentFirstChild.sibling\n                  );\n                  lanes = useFiber(currentFirstChild, newChild.props);\n                  coerceRef(lanes, newChild);\n                  lanes.return = returnFiber;\n                  returnFiber = lanes;\n                  break a;\n                }\n                deleteRemainingChildren(returnFiber, currentFirstChild);\n                break;\n              } else deleteChild(returnFiber, currentFirstChild);\n              currentFirstChild = currentFirstChild.sibling;\n            }\n            newChild.type === REACT_FRAGMENT_TYPE\n              ? ((lanes = createFiberFromFragment(\n                  newChild.props.children,\n                  returnFiber.mode,\n                  lanes,\n                  newChild.key\n                )),\n                (lanes.return = returnFiber),\n                (returnFiber = lanes))\n              : ((lanes = createFiberFromTypeAndProps(\n                  newChild.type,\n                  newChild.key,\n                  newChild.props,\n                  null,\n                  returnFiber.mode,\n                  lanes\n                )),\n                coerceRef(lanes, newChild),\n                (lanes.return = returnFiber),\n                (returnFiber = lanes));\n          }\n          return placeSingleChild(returnFiber);\n        case REACT_PORTAL_TYPE:\n          a: {\n            for (key = newChild.key; null !== currentFirstChild; ) {\n              if (currentFirstChild.key === key)\n                if (\n                  4 === currentFirstChild.tag &&\n                  currentFirstChild.stateNode.containerInfo ===\n                    newChild.containerInfo &&\n                  currentFirstChild.stateNode.implementation ===\n                    newChild.implementation\n                ) {\n                  deleteRemainingChildren(\n                    returnFiber,\n                    currentFirstChild.sibling\n                  );\n                  lanes = useFiber(currentFirstChild, newChild.children || []);\n                  lanes.return = returnFiber;\n                  returnFiber = lanes;\n                  break a;\n                } else {\n                  deleteRemainingChildren(returnFiber, currentFirstChild);\n                  break;\n                }\n              else deleteChild(returnFiber, currentFirstChild);\n              currentFirstChild = currentFirstChild.sibling;\n            }\n            lanes = createFiberFromPortal(newChild, returnFiber.mode, lanes);\n            lanes.return = returnFiber;\n            returnFiber = lanes;\n          }\n          return placeSingleChild(returnFiber);\n        case REACT_LAZY_TYPE:\n          return (\n            (key = newChild._init),\n            (newChild = key(newChild._payload)),\n            reconcileChildFibersImpl(\n              returnFiber,\n              currentFirstChild,\n              newChild,\n              lanes\n            )\n          );\n      }\n      if (isArrayImpl(newChild))\n        return reconcileChildrenArray(\n          returnFiber,\n          currentFirstChild,\n          newChild,\n          lanes\n        );\n      if (getIteratorFn(newChild)) {\n        key = getIteratorFn(newChild);\n        if (\"function\" !== typeof key) throw Error(formatProdErrorMessage(150));\n        newChild = key.call(newChild);\n        return reconcileChildrenIterator(\n          returnFiber,\n          currentFirstChild,\n          newChild,\n          lanes\n        );\n      }\n      if (\"function\" === typeof newChild.then)\n        return reconcileChildFibersImpl(\n          returnFiber,\n          currentFirstChild,\n          unwrapThenable(newChild),\n          lanes\n        );\n      if (newChild.$$typeof === REACT_CONTEXT_TYPE)\n        return reconcileChildFibersImpl(\n          returnFiber,\n          currentFirstChild,\n          readContextDuringReconciliation(returnFiber, newChild),\n          lanes\n        );\n      throwOnInvalidObjectType(returnFiber, newChild);\n    }\n    return (\"string\" === typeof newChild && \"\" !== newChild) ||\n      \"number\" === typeof newChild ||\n      \"bigint\" === typeof newChild\n      ? ((newChild = \"\" + newChild),\n        null !== currentFirstChild && 6 === currentFirstChild.tag\n          ? (deleteRemainingChildren(returnFiber, currentFirstChild.sibling),\n            (lanes = useFiber(currentFirstChild, newChild)),\n            (lanes.return = returnFiber),\n            (returnFiber = lanes))\n          : (deleteRemainingChildren(returnFiber, currentFirstChild),\n            (lanes = createFiberFromText(newChild, returnFiber.mode, lanes)),\n            (lanes.return = returnFiber),\n            (returnFiber = lanes)),\n        placeSingleChild(returnFiber))\n      : deleteRemainingChildren(returnFiber, currentFirstChild);\n  }\n  return function (returnFiber, currentFirstChild, newChild, lanes) {\n    try {\n      thenableIndexCounter = 0;\n      var firstChildFiber = reconcileChildFibersImpl(\n        returnFiber,\n        currentFirstChild,\n        newChild,\n        lanes\n      );\n      thenableState = null;\n      return firstChildFiber;\n    } catch (x) {\n      if (x === SuspenseException || x === SuspenseActionException) throw x;\n      var fiber = createFiberImplClass(29, x, null, returnFiber.mode);\n      fiber.lanes = lanes;\n      fiber.return = returnFiber;\n      return fiber;\n    } finally {\n    }\n  };\n}\nvar reconcileChildFibers = createChildReconciler(!0),\n  mountChildFibers = createChildReconciler(!1),\n  suspenseHandlerStackCursor = createCursor(null),\n  shellBoundary = null;\nfunction pushPrimaryTreeSuspenseHandler(handler) {\n  var current = handler.alternate;\n  push(suspenseStackCursor, suspenseStackCursor.current & 1);\n  push(suspenseHandlerStackCursor, handler);\n  null === shellBoundary &&\n    (null === current || null !== currentTreeHiddenStackCursor.current\n      ? (shellBoundary = handler)\n      : null !== current.memoizedState && (shellBoundary = handler));\n}\nfunction pushOffscreenSuspenseHandler(fiber) {\n  if (22 === fiber.tag) {\n    if (\n      (push(suspenseStackCursor, suspenseStackCursor.current),\n      push(suspenseHandlerStackCursor, fiber),\n      null === shellBoundary)\n    ) {\n      var current = fiber.alternate;\n      null !== current &&\n        null !== current.memoizedState &&\n        (shellBoundary = fiber);\n    }\n  } else reuseSuspenseHandlerOnStack(fiber);\n}\nfunction reuseSuspenseHandlerOnStack() {\n  push(suspenseStackCursor, suspenseStackCursor.current);\n  push(suspenseHandlerStackCursor, suspenseHandlerStackCursor.current);\n}\nfunction popSuspenseHandler(fiber) {\n  pop(suspenseHandlerStackCursor);\n  shellBoundary === fiber && (shellBoundary = null);\n  pop(suspenseStackCursor);\n}\nvar suspenseStackCursor = createCursor(0);\nfunction findFirstSuspended(row) {\n  for (var node = row; null !== node; ) {\n    if (13 === node.tag) {\n      var state = node.memoizedState;\n      if (\n        null !== state &&\n        ((state = state.dehydrated),\n        null === state ||\n          \"$?\" === state.data ||\n          isSuspenseInstanceFallback(state))\n      )\n        return node;\n    } else if (19 === node.tag && void 0 !== node.memoizedProps.revealOrder) {\n      if (0 !== (node.flags & 128)) return node;\n    } else if (null !== node.child) {\n      node.child.return = node;\n      node = node.child;\n      continue;\n    }\n    if (node === row) break;\n    for (; null === node.sibling; ) {\n      if (null === node.return || node.return === row) return null;\n      node = node.return;\n    }\n    node.sibling.return = node.return;\n    node = node.sibling;\n  }\n  return null;\n}\nfunction applyDerivedStateFromProps(\n  workInProgress,\n  ctor,\n  getDerivedStateFromProps,\n  nextProps\n) {\n  ctor = workInProgress.memoizedState;\n  getDerivedStateFromProps = getDerivedStateFromProps(nextProps, ctor);\n  getDerivedStateFromProps =\n    null === getDerivedStateFromProps || void 0 === getDerivedStateFromProps\n      ? ctor\n      : assign({}, ctor, getDerivedStateFromProps);\n  workInProgress.memoizedState = getDerivedStateFromProps;\n  0 === workInProgress.lanes &&\n    (workInProgress.updateQueue.baseState = getDerivedStateFromProps);\n}\nvar classComponentUpdater = {\n  enqueueSetState: function (inst, payload, callback) {\n    inst = inst._reactInternals;\n    var lane = requestUpdateLane(),\n      update = createUpdate(lane);\n    update.payload = payload;\n    void 0 !== callback && null !== callback && (update.callback = callback);\n    payload = enqueueUpdate(inst, update, lane);\n    null !== payload &&\n      (scheduleUpdateOnFiber(payload, inst, lane),\n      entangleTransitions(payload, inst, lane));\n  },\n  enqueueReplaceState: function (inst, payload, callback) {\n    inst = inst._reactInternals;\n    var lane = requestUpdateLane(),\n      update = createUpdate(lane);\n    update.tag = 1;\n    update.payload = payload;\n    void 0 !== callback && null !== callback && (update.callback = callback);\n    payload = enqueueUpdate(inst, update, lane);\n    null !== payload &&\n      (scheduleUpdateOnFiber(payload, inst, lane),\n      entangleTransitions(payload, inst, lane));\n  },\n  enqueueForceUpdate: function (inst, callback) {\n    inst = inst._reactInternals;\n    var lane = requestUpdateLane(),\n      update = createUpdate(lane);\n    update.tag = 2;\n    void 0 !== callback && null !== callback && (update.callback = callback);\n    callback = enqueueUpdate(inst, update, lane);\n    null !== callback &&\n      (scheduleUpdateOnFiber(callback, inst, lane),\n      entangleTransitions(callback, inst, lane));\n  }\n};\nfunction checkShouldComponentUpdate(\n  workInProgress,\n  ctor,\n  oldProps,\n  newProps,\n  oldState,\n  newState,\n  nextContext\n) {\n  workInProgress = workInProgress.stateNode;\n  return \"function\" === typeof workInProgress.shouldComponentUpdate\n    ? workInProgress.shouldComponentUpdate(newProps, newState, nextContext)\n    : ctor.prototype && ctor.prototype.isPureReactComponent\n      ? !shallowEqual(oldProps, newProps) || !shallowEqual(oldState, newState)\n      : !0;\n}\nfunction callComponentWillReceiveProps(\n  workInProgress,\n  instance,\n  newProps,\n  nextContext\n) {\n  workInProgress = instance.state;\n  \"function\" === typeof instance.componentWillReceiveProps &&\n    instance.componentWillReceiveProps(newProps, nextContext);\n  \"function\" === typeof instance.UNSAFE_componentWillReceiveProps &&\n    instance.UNSAFE_componentWillReceiveProps(newProps, nextContext);\n  instance.state !== workInProgress &&\n    classComponentUpdater.enqueueReplaceState(instance, instance.state, null);\n}\nfunction resolveClassComponentProps(Component, baseProps) {\n  var newProps = baseProps;\n  if (\"ref\" in baseProps) {\n    newProps = {};\n    for (var propName in baseProps)\n      \"ref\" !== propName && (newProps[propName] = baseProps[propName]);\n  }\n  if ((Component = Component.defaultProps)) {\n    newProps === baseProps && (newProps = assign({}, newProps));\n    for (var propName$73 in Component)\n      void 0 === newProps[propName$73] &&\n        (newProps[propName$73] = Component[propName$73]);\n  }\n  return newProps;\n}\nvar reportGlobalError =\n  \"function\" === typeof reportError\n    ? reportError\n    : function (error) {\n        if (\n          \"object\" === typeof window &&\n          \"function\" === typeof window.ErrorEvent\n        ) {\n          var event = new window.ErrorEvent(\"error\", {\n            bubbles: !0,\n            cancelable: !0,\n            message:\n              \"object\" === typeof error &&\n              null !== error &&\n              \"string\" === typeof error.message\n                ? String(error.message)\n                : String(error),\n            error: error\n          });\n          if (!window.dispatchEvent(event)) return;\n        } else if (\n          \"object\" === typeof process &&\n          \"function\" === typeof process.emit\n        ) {\n          process.emit(\"uncaughtException\", error);\n          return;\n        }\n        console.error(error);\n      };\nfunction defaultOnUncaughtError(error) {\n  reportGlobalError(error);\n}\nfunction defaultOnCaughtError(error) {\n  console.error(error);\n}\nfunction defaultOnRecoverableError(error) {\n  reportGlobalError(error);\n}\nfunction logUncaughtError(root, errorInfo) {\n  try {\n    var onUncaughtError = root.onUncaughtError;\n    onUncaughtError(errorInfo.value, { componentStack: errorInfo.stack });\n  } catch (e$74) {\n    setTimeout(function () {\n      throw e$74;\n    });\n  }\n}\nfunction logCaughtError(root, boundary, errorInfo) {\n  try {\n    var onCaughtError = root.onCaughtError;\n    onCaughtError(errorInfo.value, {\n      componentStack: errorInfo.stack,\n      errorBoundary: 1 === boundary.tag ? boundary.stateNode : null\n    });\n  } catch (e$75) {\n    setTimeout(function () {\n      throw e$75;\n    });\n  }\n}\nfunction createRootErrorUpdate(root, errorInfo, lane) {\n  lane = createUpdate(lane);\n  lane.tag = 3;\n  lane.payload = { element: null };\n  lane.callback = function () {\n    logUncaughtError(root, errorInfo);\n  };\n  return lane;\n}\nfunction createClassErrorUpdate(lane) {\n  lane = createUpdate(lane);\n  lane.tag = 3;\n  return lane;\n}\nfunction initializeClassErrorUpdate(update, root, fiber, errorInfo) {\n  var getDerivedStateFromError = fiber.type.getDerivedStateFromError;\n  if (\"function\" === typeof getDerivedStateFromError) {\n    var error = errorInfo.value;\n    update.payload = function () {\n      return getDerivedStateFromError(error);\n    };\n    update.callback = function () {\n      logCaughtError(root, fiber, errorInfo);\n    };\n  }\n  var inst = fiber.stateNode;\n  null !== inst &&\n    \"function\" === typeof inst.componentDidCatch &&\n    (update.callback = function () {\n      logCaughtError(root, fiber, errorInfo);\n      \"function\" !== typeof getDerivedStateFromError &&\n        (null === legacyErrorBoundariesThatAlreadyFailed\n          ? (legacyErrorBoundariesThatAlreadyFailed = new Set([this]))\n          : legacyErrorBoundariesThatAlreadyFailed.add(this));\n      var stack = errorInfo.stack;\n      this.componentDidCatch(errorInfo.value, {\n        componentStack: null !== stack ? stack : \"\"\n      });\n    });\n}\nfunction throwException(\n  root,\n  returnFiber,\n  sourceFiber,\n  value,\n  rootRenderLanes\n) {\n  sourceFiber.flags |= 32768;\n  if (\n    null !== value &&\n    \"object\" === typeof value &&\n    \"function\" === typeof value.then\n  ) {\n    returnFiber = sourceFiber.alternate;\n    null !== returnFiber &&\n      propagateParentContextChanges(\n        returnFiber,\n        sourceFiber,\n        rootRenderLanes,\n        !0\n      );\n    sourceFiber = suspenseHandlerStackCursor.current;\n    if (null !== sourceFiber) {\n      switch (sourceFiber.tag) {\n        case 13:\n          return (\n            null === shellBoundary\n              ? renderDidSuspendDelayIfPossible()\n              : null === sourceFiber.alternate &&\n                0 === workInProgressRootExitStatus &&\n                (workInProgressRootExitStatus = 3),\n            (sourceFiber.flags &= -257),\n            (sourceFiber.flags |= 65536),\n            (sourceFiber.lanes = rootRenderLanes),\n            value === noopSuspenseyCommitThenable\n              ? (sourceFiber.flags |= 16384)\n              : ((returnFiber = sourceFiber.updateQueue),\n                null === returnFiber\n                  ? (sourceFiber.updateQueue = new Set([value]))\n                  : returnFiber.add(value),\n                attachPingListener(root, value, rootRenderLanes)),\n            !1\n          );\n        case 22:\n          return (\n            (sourceFiber.flags |= 65536),\n            value === noopSuspenseyCommitThenable\n              ? (sourceFiber.flags |= 16384)\n              : ((returnFiber = sourceFiber.updateQueue),\n                null === returnFiber\n                  ? ((returnFiber = {\n                      transitions: null,\n                      markerInstances: null,\n                      retryQueue: new Set([value])\n                    }),\n                    (sourceFiber.updateQueue = returnFiber))\n                  : ((sourceFiber = returnFiber.retryQueue),\n                    null === sourceFiber\n                      ? (returnFiber.retryQueue = new Set([value]))\n                      : sourceFiber.add(value)),\n                attachPingListener(root, value, rootRenderLanes)),\n            !1\n          );\n      }\n      throw Error(formatProdErrorMessage(435, sourceFiber.tag));\n    }\n    attachPingListener(root, value, rootRenderLanes);\n    renderDidSuspendDelayIfPossible();\n    return !1;\n  }\n  if (isHydrating)\n    return (\n      (returnFiber = suspenseHandlerStackCursor.current),\n      null !== returnFiber\n        ? (0 === (returnFiber.flags & 65536) && (returnFiber.flags |= 256),\n          (returnFiber.flags |= 65536),\n          (returnFiber.lanes = rootRenderLanes),\n          value !== HydrationMismatchException &&\n            ((root = Error(formatProdErrorMessage(422), { cause: value })),\n            queueHydrationError(createCapturedValueAtFiber(root, sourceFiber))))\n        : (value !== HydrationMismatchException &&\n            ((returnFiber = Error(formatProdErrorMessage(423), {\n              cause: value\n            })),\n            queueHydrationError(\n              createCapturedValueAtFiber(returnFiber, sourceFiber)\n            )),\n          (root = root.current.alternate),\n          (root.flags |= 65536),\n          (rootRenderLanes &= -rootRenderLanes),\n          (root.lanes |= rootRenderLanes),\n          (value = createCapturedValueAtFiber(value, sourceFiber)),\n          (rootRenderLanes = createRootErrorUpdate(\n            root.stateNode,\n            value,\n            rootRenderLanes\n          )),\n          enqueueCapturedUpdate(root, rootRenderLanes),\n          4 !== workInProgressRootExitStatus &&\n            (workInProgressRootExitStatus = 2)),\n      !1\n    );\n  var wrapperError = Error(formatProdErrorMessage(520), { cause: value });\n  wrapperError = createCapturedValueAtFiber(wrapperError, sourceFiber);\n  null === workInProgressRootConcurrentErrors\n    ? (workInProgressRootConcurrentErrors = [wrapperError])\n    : workInProgressRootConcurrentErrors.push(wrapperError);\n  4 !== workInProgressRootExitStatus && (workInProgressRootExitStatus = 2);\n  if (null === returnFiber) return !0;\n  value = createCapturedValueAtFiber(value, sourceFiber);\n  sourceFiber = returnFiber;\n  do {\n    switch (sourceFiber.tag) {\n      case 3:\n        return (\n          (sourceFiber.flags |= 65536),\n          (root = rootRenderLanes & -rootRenderLanes),\n          (sourceFiber.lanes |= root),\n          (root = createRootErrorUpdate(sourceFiber.stateNode, value, root)),\n          enqueueCapturedUpdate(sourceFiber, root),\n          !1\n        );\n      case 1:\n        if (\n          ((returnFiber = sourceFiber.type),\n          (wrapperError = sourceFiber.stateNode),\n          0 === (sourceFiber.flags & 128) &&\n            (\"function\" === typeof returnFiber.getDerivedStateFromError ||\n              (null !== wrapperError &&\n                \"function\" === typeof wrapperError.componentDidCatch &&\n                (null === legacyErrorBoundariesThatAlreadyFailed ||\n                  !legacyErrorBoundariesThatAlreadyFailed.has(wrapperError)))))\n        )\n          return (\n            (sourceFiber.flags |= 65536),\n            (rootRenderLanes &= -rootRenderLanes),\n            (sourceFiber.lanes |= rootRenderLanes),\n            (rootRenderLanes = createClassErrorUpdate(rootRenderLanes)),\n            initializeClassErrorUpdate(\n              rootRenderLanes,\n              root,\n              sourceFiber,\n              value\n            ),\n            enqueueCapturedUpdate(sourceFiber, rootRenderLanes),\n            !1\n          );\n    }\n    sourceFiber = sourceFiber.return;\n  } while (null !== sourceFiber);\n  return !1;\n}\nvar SelectiveHydrationException = Error(formatProdErrorMessage(461)),\n  didReceiveUpdate = !1;\nfunction reconcileChildren(current, workInProgress, nextChildren, renderLanes) {\n  workInProgress.child =\n    null === current\n      ? mountChildFibers(workInProgress, null, nextChildren, renderLanes)\n      : reconcileChildFibers(\n          workInProgress,\n          current.child,\n          nextChildren,\n          renderLanes\n        );\n}\nfunction updateForwardRef(\n  current,\n  workInProgress,\n  Component,\n  nextProps,\n  renderLanes\n) {\n  Component = Component.render;\n  var ref = workInProgress.ref;\n  if (\"ref\" in nextProps) {\n    var propsWithoutRef = {};\n    for (var key in nextProps)\n      \"ref\" !== key && (propsWithoutRef[key] = nextProps[key]);\n  } else propsWithoutRef = nextProps;\n  prepareToReadContext(workInProgress);\n  nextProps = renderWithHooks(\n    current,\n    workInProgress,\n    Component,\n    propsWithoutRef,\n    ref,\n    renderLanes\n  );\n  key = checkDidRenderIdHook();\n  if (null !== current && !didReceiveUpdate)\n    return (\n      bailoutHooks(current, workInProgress, renderLanes),\n      bailoutOnAlreadyFinishedWork(current, workInProgress, renderLanes)\n    );\n  isHydrating && key && pushMaterializedTreeId(workInProgress);\n  workInProgress.flags |= 1;\n  reconcileChildren(current, workInProgress, nextProps, renderLanes);\n  return workInProgress.child;\n}\nfunction updateMemoComponent(\n  current,\n  workInProgress,\n  Component,\n  nextProps,\n  renderLanes\n) {\n  if (null === current) {\n    var type = Component.type;\n    if (\n      \"function\" === typeof type &&\n      !shouldConstruct(type) &&\n      void 0 === type.defaultProps &&\n      null === Component.compare\n    )\n      return (\n        (workInProgress.tag = 15),\n        (workInProgress.type = type),\n        updateSimpleMemoComponent(\n          current,\n          workInProgress,\n          type,\n          nextProps,\n          renderLanes\n        )\n      );\n    current = createFiberFromTypeAndProps(\n      Component.type,\n      null,\n      nextProps,\n      workInProgress,\n      workInProgress.mode,\n      renderLanes\n    );\n    current.ref = workInProgress.ref;\n    current.return = workInProgress;\n    return (workInProgress.child = current);\n  }\n  type = current.child;\n  if (!checkScheduledUpdateOrContext(current, renderLanes)) {\n    var prevProps = type.memoizedProps;\n    Component = Component.compare;\n    Component = null !== Component ? Component : shallowEqual;\n    if (Component(prevProps, nextProps) && current.ref === workInProgress.ref)\n      return bailoutOnAlreadyFinishedWork(current, workInProgress, renderLanes);\n  }\n  workInProgress.flags |= 1;\n  current = createWorkInProgress(type, nextProps);\n  current.ref = workInProgress.ref;\n  current.return = workInProgress;\n  return (workInProgress.child = current);\n}\nfunction updateSimpleMemoComponent(\n  current,\n  workInProgress,\n  Component,\n  nextProps,\n  renderLanes\n) {\n  if (null !== current) {\n    var prevProps = current.memoizedProps;\n    if (\n      shallowEqual(prevProps, nextProps) &&\n      current.ref === workInProgress.ref\n    )\n      if (\n        ((didReceiveUpdate = !1),\n        (workInProgress.pendingProps = nextProps = prevProps),\n        checkScheduledUpdateOrContext(current, renderLanes))\n      )\n        0 !== (current.flags & 131072) && (didReceiveUpdate = !0);\n      else\n        return (\n          (workInProgress.lanes = current.lanes),\n          bailoutOnAlreadyFinishedWork(current, workInProgress, renderLanes)\n        );\n  }\n  return updateFunctionComponent(\n    current,\n    workInProgress,\n    Component,\n    nextProps,\n    renderLanes\n  );\n}\nfunction updateOffscreenComponent(current, workInProgress, renderLanes) {\n  var nextProps = workInProgress.pendingProps,\n    nextChildren = nextProps.children,\n    prevState = null !== current ? current.memoizedState : null;\n  if (\"hidden\" === nextProps.mode) {\n    if (0 !== (workInProgress.flags & 128)) {\n      nextProps =\n        null !== prevState ? prevState.baseLanes | renderLanes : renderLanes;\n      if (null !== current) {\n        nextChildren = workInProgress.child = current.child;\n        for (prevState = 0; null !== nextChildren; )\n          (prevState =\n            prevState | nextChildren.lanes | nextChildren.childLanes),\n            (nextChildren = nextChildren.sibling);\n        workInProgress.childLanes = prevState & ~nextProps;\n      } else (workInProgress.childLanes = 0), (workInProgress.child = null);\n      return deferHiddenOffscreenComponent(\n        current,\n        workInProgress,\n        nextProps,\n        renderLanes\n      );\n    }\n    if (0 !== (renderLanes & 536870912))\n      (workInProgress.memoizedState = { baseLanes: 0, cachePool: null }),\n        null !== current &&\n          pushTransition(\n            workInProgress,\n            null !== prevState ? prevState.cachePool : null\n          ),\n        null !== prevState\n          ? pushHiddenContext(workInProgress, prevState)\n          : reuseHiddenContextOnStack(),\n        pushOffscreenSuspenseHandler(workInProgress);\n    else\n      return (\n        (workInProgress.lanes = workInProgress.childLanes = 536870912),\n        deferHiddenOffscreenComponent(\n          current,\n          workInProgress,\n          null !== prevState ? prevState.baseLanes | renderLanes : renderLanes,\n          renderLanes\n        )\n      );\n  } else\n    null !== prevState\n      ? (pushTransition(workInProgress, prevState.cachePool),\n        pushHiddenContext(workInProgress, prevState),\n        reuseSuspenseHandlerOnStack(workInProgress),\n        (workInProgress.memoizedState = null))\n      : (null !== current && pushTransition(workInProgress, null),\n        reuseHiddenContextOnStack(),\n        reuseSuspenseHandlerOnStack(workInProgress));\n  reconcileChildren(current, workInProgress, nextChildren, renderLanes);\n  return workInProgress.child;\n}\nfunction deferHiddenOffscreenComponent(\n  current,\n  workInProgress,\n  nextBaseLanes,\n  renderLanes\n) {\n  var JSCompiler_inline_result = peekCacheFromPool();\n  JSCompiler_inline_result =\n    null === JSCompiler_inline_result\n      ? null\n      : { parent: CacheContext._currentValue, pool: JSCompiler_inline_result };\n  workInProgress.memoizedState = {\n    baseLanes: nextBaseLanes,\n    cachePool: JSCompiler_inline_result\n  };\n  null !== current && pushTransition(workInProgress, null);\n  reuseHiddenContextOnStack();\n  pushOffscreenSuspenseHandler(workInProgress);\n  null !== current &&\n    propagateParentContextChanges(current, workInProgress, renderLanes, !0);\n  return null;\n}\nfunction markRef(current, workInProgress) {\n  var ref = workInProgress.ref;\n  if (null === ref)\n    null !== current &&\n      null !== current.ref &&\n      (workInProgress.flags |= 4194816);\n  else {\n    if (\"function\" !== typeof ref && \"object\" !== typeof ref)\n      throw Error(formatProdErrorMessage(284));\n    if (null === current || current.ref !== ref)\n      workInProgress.flags |= 4194816;\n  }\n}\nfunction updateFunctionComponent(\n  current,\n  workInProgress,\n  Component,\n  nextProps,\n  renderLanes\n) {\n  prepareToReadContext(workInProgress);\n  Component = renderWithHooks(\n    current,\n    workInProgress,\n    Component,\n    nextProps,\n    void 0,\n    renderLanes\n  );\n  nextProps = checkDidRenderIdHook();\n  if (null !== current && !didReceiveUpdate)\n    return (\n      bailoutHooks(current, workInProgress, renderLanes),\n      bailoutOnAlreadyFinishedWork(current, workInProgress, renderLanes)\n    );\n  isHydrating && nextProps && pushMaterializedTreeId(workInProgress);\n  workInProgress.flags |= 1;\n  reconcileChildren(current, workInProgress, Component, renderLanes);\n  return workInProgress.child;\n}\nfunction replayFunctionComponent(\n  current,\n  workInProgress,\n  nextProps,\n  Component,\n  secondArg,\n  renderLanes\n) {\n  prepareToReadContext(workInProgress);\n  workInProgress.updateQueue = null;\n  nextProps = renderWithHooksAgain(\n    workInProgress,\n    Component,\n    nextProps,\n    secondArg\n  );\n  finishRenderingHooks(current);\n  Component = checkDidRenderIdHook();\n  if (null !== current && !didReceiveUpdate)\n    return (\n      bailoutHooks(current, workInProgress, renderLanes),\n      bailoutOnAlreadyFinishedWork(current, workInProgress, renderLanes)\n    );\n  isHydrating && Component && pushMaterializedTreeId(workInProgress);\n  workInProgress.flags |= 1;\n  reconcileChildren(current, workInProgress, nextProps, renderLanes);\n  return workInProgress.child;\n}\nfunction updateClassComponent(\n  current,\n  workInProgress,\n  Component,\n  nextProps,\n  renderLanes\n) {\n  prepareToReadContext(workInProgress);\n  if (null === workInProgress.stateNode) {\n    var context = emptyContextObject,\n      contextType = Component.contextType;\n    \"object\" === typeof contextType &&\n      null !== contextType &&\n      (context = readContext(contextType));\n    context = new Component(nextProps, context);\n    workInProgress.memoizedState =\n      null !== context.state && void 0 !== context.state ? context.state : null;\n    context.updater = classComponentUpdater;\n    workInProgress.stateNode = context;\n    context._reactInternals = workInProgress;\n    context = workInProgress.stateNode;\n    context.props = nextProps;\n    context.state = workInProgress.memoizedState;\n    context.refs = {};\n    initializeUpdateQueue(workInProgress);\n    contextType = Component.contextType;\n    context.context =\n      \"object\" === typeof contextType && null !== contextType\n        ? readContext(contextType)\n        : emptyContextObject;\n    context.state = workInProgress.memoizedState;\n    contextType = Component.getDerivedStateFromProps;\n    \"function\" === typeof contextType &&\n      (applyDerivedStateFromProps(\n        workInProgress,\n        Component,\n        contextType,\n        nextProps\n      ),\n      (context.state = workInProgress.memoizedState));\n    \"function\" === typeof Component.getDerivedStateFromProps ||\n      \"function\" === typeof context.getSnapshotBeforeUpdate ||\n      (\"function\" !== typeof context.UNSAFE_componentWillMount &&\n        \"function\" !== typeof context.componentWillMount) ||\n      ((contextType = context.state),\n      \"function\" === typeof context.componentWillMount &&\n        context.componentWillMount(),\n      \"function\" === typeof context.UNSAFE_componentWillMount &&\n        context.UNSAFE_componentWillMount(),\n      contextType !== context.state &&\n        classComponentUpdater.enqueueReplaceState(context, context.state, null),\n      processUpdateQueue(workInProgress, nextProps, context, renderLanes),\n      suspendIfUpdateReadFromEntangledAsyncAction(),\n      (context.state = workInProgress.memoizedState));\n    \"function\" === typeof context.componentDidMount &&\n      (workInProgress.flags |= 4194308);\n    nextProps = !0;\n  } else if (null === current) {\n    context = workInProgress.stateNode;\n    var unresolvedOldProps = workInProgress.memoizedProps,\n      oldProps = resolveClassComponentProps(Component, unresolvedOldProps);\n    context.props = oldProps;\n    var oldContext = context.context,\n      contextType$jscomp$0 = Component.contextType;\n    contextType = emptyContextObject;\n    \"object\" === typeof contextType$jscomp$0 &&\n      null !== contextType$jscomp$0 &&\n      (contextType = readContext(contextType$jscomp$0));\n    var getDerivedStateFromProps = Component.getDerivedStateFromProps;\n    contextType$jscomp$0 =\n      \"function\" === typeof getDerivedStateFromProps ||\n      \"function\" === typeof context.getSnapshotBeforeUpdate;\n    unresolvedOldProps = workInProgress.pendingProps !== unresolvedOldProps;\n    contextType$jscomp$0 ||\n      (\"function\" !== typeof context.UNSAFE_componentWillReceiveProps &&\n        \"function\" !== typeof context.componentWillReceiveProps) ||\n      ((unresolvedOldProps || oldContext !== contextType) &&\n        callComponentWillReceiveProps(\n          workInProgress,\n          context,\n          nextProps,\n          contextType\n        ));\n    hasForceUpdate = !1;\n    var oldState = workInProgress.memoizedState;\n    context.state = oldState;\n    processUpdateQueue(workInProgress, nextProps, context, renderLanes);\n    suspendIfUpdateReadFromEntangledAsyncAction();\n    oldContext = workInProgress.memoizedState;\n    unresolvedOldProps || oldState !== oldContext || hasForceUpdate\n      ? (\"function\" === typeof getDerivedStateFromProps &&\n          (applyDerivedStateFromProps(\n            workInProgress,\n            Component,\n            getDerivedStateFromProps,\n            nextProps\n          ),\n          (oldContext = workInProgress.memoizedState)),\n        (oldProps =\n          hasForceUpdate ||\n          checkShouldComponentUpdate(\n            workInProgress,\n            Component,\n            oldProps,\n            nextProps,\n            oldState,\n            oldContext,\n            contextType\n          ))\n          ? (contextType$jscomp$0 ||\n              (\"function\" !== typeof context.UNSAFE_componentWillMount &&\n                \"function\" !== typeof context.componentWillMount) ||\n              (\"function\" === typeof context.componentWillMount &&\n                context.componentWillMount(),\n              \"function\" === typeof context.UNSAFE_componentWillMount &&\n                context.UNSAFE_componentWillMount()),\n            \"function\" === typeof context.componentDidMount &&\n              (workInProgress.flags |= 4194308))\n          : (\"function\" === typeof context.componentDidMount &&\n              (workInProgress.flags |= 4194308),\n            (workInProgress.memoizedProps = nextProps),\n            (workInProgress.memoizedState = oldContext)),\n        (context.props = nextProps),\n        (context.state = oldContext),\n        (context.context = contextType),\n        (nextProps = oldProps))\n      : (\"function\" === typeof context.componentDidMount &&\n          (workInProgress.flags |= 4194308),\n        (nextProps = !1));\n  } else {\n    context = workInProgress.stateNode;\n    cloneUpdateQueue(current, workInProgress);\n    contextType = workInProgress.memoizedProps;\n    contextType$jscomp$0 = resolveClassComponentProps(Component, contextType);\n    context.props = contextType$jscomp$0;\n    getDerivedStateFromProps = workInProgress.pendingProps;\n    oldState = context.context;\n    oldContext = Component.contextType;\n    oldProps = emptyContextObject;\n    \"object\" === typeof oldContext &&\n      null !== oldContext &&\n      (oldProps = readContext(oldContext));\n    unresolvedOldProps = Component.getDerivedStateFromProps;\n    (oldContext =\n      \"function\" === typeof unresolvedOldProps ||\n      \"function\" === typeof context.getSnapshotBeforeUpdate) ||\n      (\"function\" !== typeof context.UNSAFE_componentWillReceiveProps &&\n        \"function\" !== typeof context.componentWillReceiveProps) ||\n      ((contextType !== getDerivedStateFromProps || oldState !== oldProps) &&\n        callComponentWillReceiveProps(\n          workInProgress,\n          context,\n          nextProps,\n          oldProps\n        ));\n    hasForceUpdate = !1;\n    oldState = workInProgress.memoizedState;\n    context.state = oldState;\n    processUpdateQueue(workInProgress, nextProps, context, renderLanes);\n    suspendIfUpdateReadFromEntangledAsyncAction();\n    var newState = workInProgress.memoizedState;\n    contextType !== getDerivedStateFromProps ||\n    oldState !== newState ||\n    hasForceUpdate ||\n    (null !== current &&\n      null !== current.dependencies &&\n      checkIfContextChanged(current.dependencies))\n      ? (\"function\" === typeof unresolvedOldProps &&\n          (applyDerivedStateFromProps(\n            workInProgress,\n            Component,\n            unresolvedOldProps,\n            nextProps\n          ),\n          (newState = workInProgress.memoizedState)),\n        (contextType$jscomp$0 =\n          hasForceUpdate ||\n          checkShouldComponentUpdate(\n            workInProgress,\n            Component,\n            contextType$jscomp$0,\n            nextProps,\n            oldState,\n            newState,\n            oldProps\n          ) ||\n          (null !== current &&\n            null !== current.dependencies &&\n            checkIfContextChanged(current.dependencies)))\n          ? (oldContext ||\n              (\"function\" !== typeof context.UNSAFE_componentWillUpdate &&\n                \"function\" !== typeof context.componentWillUpdate) ||\n              (\"function\" === typeof context.componentWillUpdate &&\n                context.componentWillUpdate(nextProps, newState, oldProps),\n              \"function\" === typeof context.UNSAFE_componentWillUpdate &&\n                context.UNSAFE_componentWillUpdate(\n                  nextProps,\n                  newState,\n                  oldProps\n                )),\n            \"function\" === typeof context.componentDidUpdate &&\n              (workInProgress.flags |= 4),\n            \"function\" === typeof context.getSnapshotBeforeUpdate &&\n              (workInProgress.flags |= 1024))\n          : (\"function\" !== typeof context.componentDidUpdate ||\n              (contextType === current.memoizedProps &&\n                oldState === current.memoizedState) ||\n              (workInProgress.flags |= 4),\n            \"function\" !== typeof context.getSnapshotBeforeUpdate ||\n              (contextType === current.memoizedProps &&\n                oldState === current.memoizedState) ||\n              (workInProgress.flags |= 1024),\n            (workInProgress.memoizedProps = nextProps),\n            (workInProgress.memoizedState = newState)),\n        (context.props = nextProps),\n        (context.state = newState),\n        (context.context = oldProps),\n        (nextProps = contextType$jscomp$0))\n      : (\"function\" !== typeof context.componentDidUpdate ||\n          (contextType === current.memoizedProps &&\n            oldState === current.memoizedState) ||\n          (workInProgress.flags |= 4),\n        \"function\" !== typeof context.getSnapshotBeforeUpdate ||\n          (contextType === current.memoizedProps &&\n            oldState === current.memoizedState) ||\n          (workInProgress.flags |= 1024),\n        (nextProps = !1));\n  }\n  context = nextProps;\n  markRef(current, workInProgress);\n  nextProps = 0 !== (workInProgress.flags & 128);\n  context || nextProps\n    ? ((context = workInProgress.stateNode),\n      (Component =\n        nextProps && \"function\" !== typeof Component.getDerivedStateFromError\n          ? null\n          : context.render()),\n      (workInProgress.flags |= 1),\n      null !== current && nextProps\n        ? ((workInProgress.child = reconcileChildFibers(\n            workInProgress,\n            current.child,\n            null,\n            renderLanes\n          )),\n          (workInProgress.child = reconcileChildFibers(\n            workInProgress,\n            null,\n            Component,\n            renderLanes\n          )))\n        : reconcileChildren(current, workInProgress, Component, renderLanes),\n      (workInProgress.memoizedState = context.state),\n      (current = workInProgress.child))\n    : (current = bailoutOnAlreadyFinishedWork(\n        current,\n        workInProgress,\n        renderLanes\n      ));\n  return current;\n}\nfunction mountHostRootWithoutHydrating(\n  current,\n  workInProgress,\n  nextChildren,\n  renderLanes\n) {\n  resetHydrationState();\n  workInProgress.flags |= 256;\n  reconcileChildren(current, workInProgress, nextChildren, renderLanes);\n  return workInProgress.child;\n}\nvar SUSPENDED_MARKER = {\n  dehydrated: null,\n  treeContext: null,\n  retryLane: 0,\n  hydrationErrors: null\n};\nfunction mountSuspenseOffscreenState(renderLanes) {\n  return { baseLanes: renderLanes, cachePool: getSuspendedCache() };\n}\nfunction getRemainingWorkInPrimaryTree(\n  current,\n  primaryTreeDidDefer,\n  renderLanes\n) {\n  current = null !== current ? current.childLanes & ~renderLanes : 0;\n  primaryTreeDidDefer && (current |= workInProgressDeferredLane);\n  return current;\n}\nfunction updateSuspenseComponent(current, workInProgress, renderLanes) {\n  var nextProps = workInProgress.pendingProps,\n    showFallback = !1,\n    didSuspend = 0 !== (workInProgress.flags & 128),\n    JSCompiler_temp;\n  (JSCompiler_temp = didSuspend) ||\n    (JSCompiler_temp =\n      null !== current && null === current.memoizedState\n        ? !1\n        : 0 !== (suspenseStackCursor.current & 2));\n  JSCompiler_temp && ((showFallback = !0), (workInProgress.flags &= -129));\n  JSCompiler_temp = 0 !== (workInProgress.flags & 32);\n  workInProgress.flags &= -33;\n  if (null === current) {\n    if (isHydrating) {\n      showFallback\n        ? pushPrimaryTreeSuspenseHandler(workInProgress)\n        : reuseSuspenseHandlerOnStack(workInProgress);\n      if (isHydrating) {\n        var nextInstance = nextHydratableInstance,\n          JSCompiler_temp$jscomp$0;\n        if ((JSCompiler_temp$jscomp$0 = nextInstance)) {\n          c: {\n            JSCompiler_temp$jscomp$0 = nextInstance;\n            for (\n              nextInstance = rootOrSingletonContext;\n              8 !== JSCompiler_temp$jscomp$0.nodeType;\n\n            ) {\n              if (!nextInstance) {\n                nextInstance = null;\n                break c;\n              }\n              JSCompiler_temp$jscomp$0 = getNextHydratable(\n                JSCompiler_temp$jscomp$0.nextSibling\n              );\n              if (null === JSCompiler_temp$jscomp$0) {\n                nextInstance = null;\n                break c;\n              }\n            }\n            nextInstance = JSCompiler_temp$jscomp$0;\n          }\n          null !== nextInstance\n            ? ((workInProgress.memoizedState = {\n                dehydrated: nextInstance,\n                treeContext:\n                  null !== treeContextProvider\n                    ? { id: treeContextId, overflow: treeContextOverflow }\n                    : null,\n                retryLane: 536870912,\n                hydrationErrors: null\n              }),\n              (JSCompiler_temp$jscomp$0 = createFiberImplClass(\n                18,\n                null,\n                null,\n                0\n              )),\n              (JSCompiler_temp$jscomp$0.stateNode = nextInstance),\n              (JSCompiler_temp$jscomp$0.return = workInProgress),\n              (workInProgress.child = JSCompiler_temp$jscomp$0),\n              (hydrationParentFiber = workInProgress),\n              (nextHydratableInstance = null),\n              (JSCompiler_temp$jscomp$0 = !0))\n            : (JSCompiler_temp$jscomp$0 = !1);\n        }\n        JSCompiler_temp$jscomp$0 || throwOnHydrationMismatch(workInProgress);\n      }\n      nextInstance = workInProgress.memoizedState;\n      if (\n        null !== nextInstance &&\n        ((nextInstance = nextInstance.dehydrated), null !== nextInstance)\n      )\n        return (\n          isSuspenseInstanceFallback(nextInstance)\n            ? (workInProgress.lanes = 32)\n            : (workInProgress.lanes = 536870912),\n          null\n        );\n      popSuspenseHandler(workInProgress);\n    }\n    nextInstance = nextProps.children;\n    nextProps = nextProps.fallback;\n    if (showFallback)\n      return (\n        reuseSuspenseHandlerOnStack(workInProgress),\n        (showFallback = workInProgress.mode),\n        (nextInstance = mountWorkInProgressOffscreenFiber(\n          { mode: \"hidden\", children: nextInstance },\n          showFallback\n        )),\n        (nextProps = createFiberFromFragment(\n          nextProps,\n          showFallback,\n          renderLanes,\n          null\n        )),\n        (nextInstance.return = workInProgress),\n        (nextProps.return = workInProgress),\n        (nextInstance.sibling = nextProps),\n        (workInProgress.child = nextInstance),\n        (showFallback = workInProgress.child),\n        (showFallback.memoizedState = mountSuspenseOffscreenState(renderLanes)),\n        (showFallback.childLanes = getRemainingWorkInPrimaryTree(\n          current,\n          JSCompiler_temp,\n          renderLanes\n        )),\n        (workInProgress.memoizedState = SUSPENDED_MARKER),\n        nextProps\n      );\n    pushPrimaryTreeSuspenseHandler(workInProgress);\n    return mountSuspensePrimaryChildren(workInProgress, nextInstance);\n  }\n  JSCompiler_temp$jscomp$0 = current.memoizedState;\n  if (\n    null !== JSCompiler_temp$jscomp$0 &&\n    ((nextInstance = JSCompiler_temp$jscomp$0.dehydrated),\n    null !== nextInstance)\n  ) {\n    if (didSuspend)\n      workInProgress.flags & 256\n        ? (pushPrimaryTreeSuspenseHandler(workInProgress),\n          (workInProgress.flags &= -257),\n          (workInProgress = retrySuspenseComponentWithoutHydrating(\n            current,\n            workInProgress,\n            renderLanes\n          )))\n        : null !== workInProgress.memoizedState\n          ? (reuseSuspenseHandlerOnStack(workInProgress),\n            (workInProgress.child = current.child),\n            (workInProgress.flags |= 128),\n            (workInProgress = null))\n          : (reuseSuspenseHandlerOnStack(workInProgress),\n            (showFallback = nextProps.fallback),\n            (nextInstance = workInProgress.mode),\n            (nextProps = mountWorkInProgressOffscreenFiber(\n              { mode: \"visible\", children: nextProps.children },\n              nextInstance\n            )),\n            (showFallback = createFiberFromFragment(\n              showFallback,\n              nextInstance,\n              renderLanes,\n              null\n            )),\n            (showFallback.flags |= 2),\n            (nextProps.return = workInProgress),\n            (showFallback.return = workInProgress),\n            (nextProps.sibling = showFallback),\n            (workInProgress.child = nextProps),\n            reconcileChildFibers(\n              workInProgress,\n              current.child,\n              null,\n              renderLanes\n            ),\n            (nextProps = workInProgress.child),\n            (nextProps.memoizedState =\n              mountSuspenseOffscreenState(renderLanes)),\n            (nextProps.childLanes = getRemainingWorkInPrimaryTree(\n              current,\n              JSCompiler_temp,\n              renderLanes\n            )),\n            (workInProgress.memoizedState = SUSPENDED_MARKER),\n            (workInProgress = showFallback));\n    else if (\n      (pushPrimaryTreeSuspenseHandler(workInProgress),\n      isSuspenseInstanceFallback(nextInstance))\n    ) {\n      JSCompiler_temp =\n        nextInstance.nextSibling && nextInstance.nextSibling.dataset;\n      if (JSCompiler_temp) var digest = JSCompiler_temp.dgst;\n      JSCompiler_temp = digest;\n      nextProps = Error(formatProdErrorMessage(419));\n      nextProps.stack = \"\";\n      nextProps.digest = JSCompiler_temp;\n      queueHydrationError({ value: nextProps, source: null, stack: null });\n      workInProgress = retrySuspenseComponentWithoutHydrating(\n        current,\n        workInProgress,\n        renderLanes\n      );\n    } else if (\n      (didReceiveUpdate ||\n        propagateParentContextChanges(current, workInProgress, renderLanes, !1),\n      (JSCompiler_temp = 0 !== (renderLanes & current.childLanes)),\n      didReceiveUpdate || JSCompiler_temp)\n    ) {\n      JSCompiler_temp = workInProgressRoot;\n      if (\n        null !== JSCompiler_temp &&\n        ((nextProps = renderLanes & -renderLanes),\n        (nextProps =\n          0 !== (nextProps & 42)\n            ? 1\n            : getBumpedLaneForHydrationByLane(nextProps)),\n        (nextProps =\n          0 !== (nextProps & (JSCompiler_temp.suspendedLanes | renderLanes))\n            ? 0\n            : nextProps),\n        0 !== nextProps && nextProps !== JSCompiler_temp$jscomp$0.retryLane)\n      )\n        throw (\n          ((JSCompiler_temp$jscomp$0.retryLane = nextProps),\n          enqueueConcurrentRenderForLane(current, nextProps),\n          scheduleUpdateOnFiber(JSCompiler_temp, current, nextProps),\n          SelectiveHydrationException)\n        );\n      \"$?\" === nextInstance.data || renderDidSuspendDelayIfPossible();\n      workInProgress = retrySuspenseComponentWithoutHydrating(\n        current,\n        workInProgress,\n        renderLanes\n      );\n    } else\n      \"$?\" === nextInstance.data\n        ? ((workInProgress.flags |= 192),\n          (workInProgress.child = current.child),\n          (workInProgress = null))\n        : ((current = JSCompiler_temp$jscomp$0.treeContext),\n          (nextHydratableInstance = getNextHydratable(\n            nextInstance.nextSibling\n          )),\n          (hydrationParentFiber = workInProgress),\n          (isHydrating = !0),\n          (hydrationErrors = null),\n          (rootOrSingletonContext = !1),\n          null !== current &&\n            ((idStack[idStackIndex++] = treeContextId),\n            (idStack[idStackIndex++] = treeContextOverflow),\n            (idStack[idStackIndex++] = treeContextProvider),\n            (treeContextId = current.id),\n            (treeContextOverflow = current.overflow),\n            (treeContextProvider = workInProgress)),\n          (workInProgress = mountSuspensePrimaryChildren(\n            workInProgress,\n            nextProps.children\n          )),\n          (workInProgress.flags |= 4096));\n    return workInProgress;\n  }\n  if (showFallback)\n    return (\n      reuseSuspenseHandlerOnStack(workInProgress),\n      (showFallback = nextProps.fallback),\n      (nextInstance = workInProgress.mode),\n      (JSCompiler_temp$jscomp$0 = current.child),\n      (digest = JSCompiler_temp$jscomp$0.sibling),\n      (nextProps = createWorkInProgress(JSCompiler_temp$jscomp$0, {\n        mode: \"hidden\",\n        children: nextProps.children\n      })),\n      (nextProps.subtreeFlags =\n        JSCompiler_temp$jscomp$0.subtreeFlags & 65011712),\n      null !== digest\n        ? (showFallback = createWorkInProgress(digest, showFallback))\n        : ((showFallback = createFiberFromFragment(\n            showFallback,\n            nextInstance,\n            renderLanes,\n            null\n          )),\n          (showFallback.flags |= 2)),\n      (showFallback.return = workInProgress),\n      (nextProps.return = workInProgress),\n      (nextProps.sibling = showFallback),\n      (workInProgress.child = nextProps),\n      (nextProps = showFallback),\n      (showFallback = workInProgress.child),\n      (nextInstance = current.child.memoizedState),\n      null === nextInstance\n        ? (nextInstance = mountSuspenseOffscreenState(renderLanes))\n        : ((JSCompiler_temp$jscomp$0 = nextInstance.cachePool),\n          null !== JSCompiler_temp$jscomp$0\n            ? ((digest = CacheContext._currentValue),\n              (JSCompiler_temp$jscomp$0 =\n                JSCompiler_temp$jscomp$0.parent !== digest\n                  ? { parent: digest, pool: digest }\n                  : JSCompiler_temp$jscomp$0))\n            : (JSCompiler_temp$jscomp$0 = getSuspendedCache()),\n          (nextInstance = {\n            baseLanes: nextInstance.baseLanes | renderLanes,\n            cachePool: JSCompiler_temp$jscomp$0\n          })),\n      (showFallback.memoizedState = nextInstance),\n      (showFallback.childLanes = getRemainingWorkInPrimaryTree(\n        current,\n        JSCompiler_temp,\n        renderLanes\n      )),\n      (workInProgress.memoizedState = SUSPENDED_MARKER),\n      nextProps\n    );\n  pushPrimaryTreeSuspenseHandler(workInProgress);\n  renderLanes = current.child;\n  current = renderLanes.sibling;\n  renderLanes = createWorkInProgress(renderLanes, {\n    mode: \"visible\",\n    children: nextProps.children\n  });\n  renderLanes.return = workInProgress;\n  renderLanes.sibling = null;\n  null !== current &&\n    ((JSCompiler_temp = workInProgress.deletions),\n    null === JSCompiler_temp\n      ? ((workInProgress.deletions = [current]), (workInProgress.flags |= 16))\n      : JSCompiler_temp.push(current));\n  workInProgress.child = renderLanes;\n  workInProgress.memoizedState = null;\n  return renderLanes;\n}\nfunction mountSuspensePrimaryChildren(workInProgress, primaryChildren) {\n  primaryChildren = mountWorkInProgressOffscreenFiber(\n    { mode: \"visible\", children: primaryChildren },\n    workInProgress.mode\n  );\n  primaryChildren.return = workInProgress;\n  return (workInProgress.child = primaryChildren);\n}\nfunction mountWorkInProgressOffscreenFiber(offscreenProps, mode) {\n  offscreenProps = createFiberImplClass(22, offscreenProps, null, mode);\n  offscreenProps.lanes = 0;\n  offscreenProps.stateNode = {\n    _visibility: 1,\n    _pendingMarkers: null,\n    _retryCache: null,\n    _transitions: null\n  };\n  return offscreenProps;\n}\nfunction retrySuspenseComponentWithoutHydrating(\n  current,\n  workInProgress,\n  renderLanes\n) {\n  reconcileChildFibers(workInProgress, current.child, null, renderLanes);\n  current = mountSuspensePrimaryChildren(\n    workInProgress,\n    workInProgress.pendingProps.children\n  );\n  current.flags |= 2;\n  workInProgress.memoizedState = null;\n  return current;\n}\nfunction scheduleSuspenseWorkOnFiber(fiber, renderLanes, propagationRoot) {\n  fiber.lanes |= renderLanes;\n  var alternate = fiber.alternate;\n  null !== alternate && (alternate.lanes |= renderLanes);\n  scheduleContextWorkOnParentPath(fiber.return, renderLanes, propagationRoot);\n}\nfunction initSuspenseListRenderState(\n  workInProgress,\n  isBackwards,\n  tail,\n  lastContentRow,\n  tailMode\n) {\n  var renderState = workInProgress.memoizedState;\n  null === renderState\n    ? (workInProgress.memoizedState = {\n        isBackwards: isBackwards,\n        rendering: null,\n        renderingStartTime: 0,\n        last: lastContentRow,\n        tail: tail,\n        tailMode: tailMode\n      })\n    : ((renderState.isBackwards = isBackwards),\n      (renderState.rendering = null),\n      (renderState.renderingStartTime = 0),\n      (renderState.last = lastContentRow),\n      (renderState.tail = tail),\n      (renderState.tailMode = tailMode));\n}\nfunction updateSuspenseListComponent(current, workInProgress, renderLanes) {\n  var nextProps = workInProgress.pendingProps,\n    revealOrder = nextProps.revealOrder,\n    tailMode = nextProps.tail;\n  reconcileChildren(current, workInProgress, nextProps.children, renderLanes);\n  nextProps = suspenseStackCursor.current;\n  if (0 !== (nextProps & 2))\n    (nextProps = (nextProps & 1) | 2), (workInProgress.flags |= 128);\n  else {\n    if (null !== current && 0 !== (current.flags & 128))\n      a: for (current = workInProgress.child; null !== current; ) {\n        if (13 === current.tag)\n          null !== current.memoizedState &&\n            scheduleSuspenseWorkOnFiber(current, renderLanes, workInProgress);\n        else if (19 === current.tag)\n          scheduleSuspenseWorkOnFiber(current, renderLanes, workInProgress);\n        else if (null !== current.child) {\n          current.child.return = current;\n          current = current.child;\n          continue;\n        }\n        if (current === workInProgress) break a;\n        for (; null === current.sibling; ) {\n          if (null === current.return || current.return === workInProgress)\n            break a;\n          current = current.return;\n        }\n        current.sibling.return = current.return;\n        current = current.sibling;\n      }\n    nextProps &= 1;\n  }\n  push(suspenseStackCursor, nextProps);\n  switch (revealOrder) {\n    case \"forwards\":\n      renderLanes = workInProgress.child;\n      for (revealOrder = null; null !== renderLanes; )\n        (current = renderLanes.alternate),\n          null !== current &&\n            null === findFirstSuspended(current) &&\n            (revealOrder = renderLanes),\n          (renderLanes = renderLanes.sibling);\n      renderLanes = revealOrder;\n      null === renderLanes\n        ? ((revealOrder = workInProgress.child), (workInProgress.child = null))\n        : ((revealOrder = renderLanes.sibling), (renderLanes.sibling = null));\n      initSuspenseListRenderState(\n        workInProgress,\n        !1,\n        revealOrder,\n        renderLanes,\n        tailMode\n      );\n      break;\n    case \"backwards\":\n      renderLanes = null;\n      revealOrder = workInProgress.child;\n      for (workInProgress.child = null; null !== revealOrder; ) {\n        current = revealOrder.alternate;\n        if (null !== current && null === findFirstSuspended(current)) {\n          workInProgress.child = revealOrder;\n          break;\n        }\n        current = revealOrder.sibling;\n        revealOrder.sibling = renderLanes;\n        renderLanes = revealOrder;\n        revealOrder = current;\n      }\n      initSuspenseListRenderState(\n        workInProgress,\n        !0,\n        renderLanes,\n        null,\n        tailMode\n      );\n      break;\n    case \"together\":\n      initSuspenseListRenderState(workInProgress, !1, null, null, void 0);\n      break;\n    default:\n      workInProgress.memoizedState = null;\n  }\n  return workInProgress.child;\n}\nfunction bailoutOnAlreadyFinishedWork(current, workInProgress, renderLanes) {\n  null !== current && (workInProgress.dependencies = current.dependencies);\n  workInProgressRootSkippedLanes |= workInProgress.lanes;\n  if (0 === (renderLanes & workInProgress.childLanes))\n    if (null !== current) {\n      if (\n        (propagateParentContextChanges(\n          current,\n          workInProgress,\n          renderLanes,\n          !1\n        ),\n        0 === (renderLanes & workInProgress.childLanes))\n      )\n        return null;\n    } else return null;\n  if (null !== current && workInProgress.child !== current.child)\n    throw Error(formatProdErrorMessage(153));\n  if (null !== workInProgress.child) {\n    current = workInProgress.child;\n    renderLanes = createWorkInProgress(current, current.pendingProps);\n    workInProgress.child = renderLanes;\n    for (renderLanes.return = workInProgress; null !== current.sibling; )\n      (current = current.sibling),\n        (renderLanes = renderLanes.sibling =\n          createWorkInProgress(current, current.pendingProps)),\n        (renderLanes.return = workInProgress);\n    renderLanes.sibling = null;\n  }\n  return workInProgress.child;\n}\nfunction checkScheduledUpdateOrContext(current, renderLanes) {\n  if (0 !== (current.lanes & renderLanes)) return !0;\n  current = current.dependencies;\n  return null !== current && checkIfContextChanged(current) ? !0 : !1;\n}\nfunction attemptEarlyBailoutIfNoScheduledUpdate(\n  current,\n  workInProgress,\n  renderLanes\n) {\n  switch (workInProgress.tag) {\n    case 3:\n      pushHostContainer(workInProgress, workInProgress.stateNode.containerInfo);\n      pushProvider(workInProgress, CacheContext, current.memoizedState.cache);\n      resetHydrationState();\n      break;\n    case 27:\n    case 5:\n      pushHostContext(workInProgress);\n      break;\n    case 4:\n      pushHostContainer(workInProgress, workInProgress.stateNode.containerInfo);\n      break;\n    case 10:\n      pushProvider(\n        workInProgress,\n        workInProgress.type,\n        workInProgress.memoizedProps.value\n      );\n      break;\n    case 13:\n      var state = workInProgress.memoizedState;\n      if (null !== state) {\n        if (null !== state.dehydrated)\n          return (\n            pushPrimaryTreeSuspenseHandler(workInProgress),\n            (workInProgress.flags |= 128),\n            null\n          );\n        if (0 !== (renderLanes & workInProgress.child.childLanes))\n          return updateSuspenseComponent(current, workInProgress, renderLanes);\n        pushPrimaryTreeSuspenseHandler(workInProgress);\n        current = bailoutOnAlreadyFinishedWork(\n          current,\n          workInProgress,\n          renderLanes\n        );\n        return null !== current ? current.sibling : null;\n      }\n      pushPrimaryTreeSuspenseHandler(workInProgress);\n      break;\n    case 19:\n      var didSuspendBefore = 0 !== (current.flags & 128);\n      state = 0 !== (renderLanes & workInProgress.childLanes);\n      state ||\n        (propagateParentContextChanges(\n          current,\n          workInProgress,\n          renderLanes,\n          !1\n        ),\n        (state = 0 !== (renderLanes & workInProgress.childLanes)));\n      if (didSuspendBefore) {\n        if (state)\n          return updateSuspenseListComponent(\n            current,\n            workInProgress,\n            renderLanes\n          );\n        workInProgress.flags |= 128;\n      }\n      didSuspendBefore = workInProgress.memoizedState;\n      null !== didSuspendBefore &&\n        ((didSuspendBefore.rendering = null),\n        (didSuspendBefore.tail = null),\n        (didSuspendBefore.lastEffect = null));\n      push(suspenseStackCursor, suspenseStackCursor.current);\n      if (state) break;\n      else return null;\n    case 22:\n    case 23:\n      return (\n        (workInProgress.lanes = 0),\n        updateOffscreenComponent(current, workInProgress, renderLanes)\n      );\n    case 24:\n      pushProvider(workInProgress, CacheContext, current.memoizedState.cache);\n  }\n  return bailoutOnAlreadyFinishedWork(current, workInProgress, renderLanes);\n}\nfunction beginWork(current, workInProgress, renderLanes) {\n  if (null !== current)\n    if (current.memoizedProps !== workInProgress.pendingProps)\n      didReceiveUpdate = !0;\n    else {\n      if (\n        !checkScheduledUpdateOrContext(current, renderLanes) &&\n        0 === (workInProgress.flags & 128)\n      )\n        return (\n          (didReceiveUpdate = !1),\n          attemptEarlyBailoutIfNoScheduledUpdate(\n            current,\n            workInProgress,\n            renderLanes\n          )\n        );\n      didReceiveUpdate = 0 !== (current.flags & 131072) ? !0 : !1;\n    }\n  else\n    (didReceiveUpdate = !1),\n      isHydrating &&\n        0 !== (workInProgress.flags & 1048576) &&\n        pushTreeId(workInProgress, treeForkCount, workInProgress.index);\n  workInProgress.lanes = 0;\n  switch (workInProgress.tag) {\n    case 16:\n      a: {\n        current = workInProgress.pendingProps;\n        var lazyComponent = workInProgress.elementType,\n          init = lazyComponent._init;\n        lazyComponent = init(lazyComponent._payload);\n        workInProgress.type = lazyComponent;\n        if (\"function\" === typeof lazyComponent)\n          shouldConstruct(lazyComponent)\n            ? ((current = resolveClassComponentProps(lazyComponent, current)),\n              (workInProgress.tag = 1),\n              (workInProgress = updateClassComponent(\n                null,\n                workInProgress,\n                lazyComponent,\n                current,\n                renderLanes\n              )))\n            : ((workInProgress.tag = 0),\n              (workInProgress = updateFunctionComponent(\n                null,\n                workInProgress,\n                lazyComponent,\n                current,\n                renderLanes\n              )));\n        else {\n          if (void 0 !== lazyComponent && null !== lazyComponent)\n            if (\n              ((init = lazyComponent.$$typeof), init === REACT_FORWARD_REF_TYPE)\n            ) {\n              workInProgress.tag = 11;\n              workInProgress = updateForwardRef(\n                null,\n                workInProgress,\n                lazyComponent,\n                current,\n                renderLanes\n              );\n              break a;\n            } else if (init === REACT_MEMO_TYPE) {\n              workInProgress.tag = 14;\n              workInProgress = updateMemoComponent(\n                null,\n                workInProgress,\n                lazyComponent,\n                current,\n                renderLanes\n              );\n              break a;\n            }\n          workInProgress =\n            getComponentNameFromType(lazyComponent) || lazyComponent;\n          throw Error(formatProdErrorMessage(306, workInProgress, \"\"));\n        }\n      }\n      return workInProgress;\n    case 0:\n      return updateFunctionComponent(\n        current,\n        workInProgress,\n        workInProgress.type,\n        workInProgress.pendingProps,\n        renderLanes\n      );\n    case 1:\n      return (\n        (lazyComponent = workInProgress.type),\n        (init = resolveClassComponentProps(\n          lazyComponent,\n          workInProgress.pendingProps\n        )),\n        updateClassComponent(\n          current,\n          workInProgress,\n          lazyComponent,\n          init,\n          renderLanes\n        )\n      );\n    case 3:\n      a: {\n        pushHostContainer(\n          workInProgress,\n          workInProgress.stateNode.containerInfo\n        );\n        if (null === current) throw Error(formatProdErrorMessage(387));\n        lazyComponent = workInProgress.pendingProps;\n        var prevState = workInProgress.memoizedState;\n        init = prevState.element;\n        cloneUpdateQueue(current, workInProgress);\n        processUpdateQueue(workInProgress, lazyComponent, null, renderLanes);\n        var nextState = workInProgress.memoizedState;\n        lazyComponent = nextState.cache;\n        pushProvider(workInProgress, CacheContext, lazyComponent);\n        lazyComponent !== prevState.cache &&\n          propagateContextChanges(\n            workInProgress,\n            [CacheContext],\n            renderLanes,\n            !0\n          );\n        suspendIfUpdateReadFromEntangledAsyncAction();\n        lazyComponent = nextState.element;\n        if (prevState.isDehydrated)\n          if (\n            ((prevState = {\n              element: lazyComponent,\n              isDehydrated: !1,\n              cache: nextState.cache\n            }),\n            (workInProgress.updateQueue.baseState = prevState),\n            (workInProgress.memoizedState = prevState),\n            workInProgress.flags & 256)\n          ) {\n            workInProgress = mountHostRootWithoutHydrating(\n              current,\n              workInProgress,\n              lazyComponent,\n              renderLanes\n            );\n            break a;\n          } else if (lazyComponent !== init) {\n            init = createCapturedValueAtFiber(\n              Error(formatProdErrorMessage(424)),\n              workInProgress\n            );\n            queueHydrationError(init);\n            workInProgress = mountHostRootWithoutHydrating(\n              current,\n              workInProgress,\n              lazyComponent,\n              renderLanes\n            );\n            break a;\n          } else {\n            current = workInProgress.stateNode.containerInfo;\n            switch (current.nodeType) {\n              case 9:\n                current = current.body;\n                break;\n              default:\n                current =\n                  \"HTML\" === current.nodeName\n                    ? current.ownerDocument.body\n                    : current;\n            }\n            nextHydratableInstance = getNextHydratable(current.firstChild);\n            hydrationParentFiber = workInProgress;\n            isHydrating = !0;\n            hydrationErrors = null;\n            rootOrSingletonContext = !0;\n            renderLanes = mountChildFibers(\n              workInProgress,\n              null,\n              lazyComponent,\n              renderLanes\n            );\n            for (workInProgress.child = renderLanes; renderLanes; )\n              (renderLanes.flags = (renderLanes.flags & -3) | 4096),\n                (renderLanes = renderLanes.sibling);\n          }\n        else {\n          resetHydrationState();\n          if (lazyComponent === init) {\n            workInProgress = bailoutOnAlreadyFinishedWork(\n              current,\n              workInProgress,\n              renderLanes\n            );\n            break a;\n          }\n          reconcileChildren(\n            current,\n            workInProgress,\n            lazyComponent,\n            renderLanes\n          );\n        }\n        workInProgress = workInProgress.child;\n      }\n      return workInProgress;\n    case 26:\n      return (\n        markRef(current, workInProgress),\n        null === current\n          ? (renderLanes = getResource(\n              workInProgress.type,\n              null,\n              workInProgress.pendingProps,\n              null\n            ))\n            ? (workInProgress.memoizedState = renderLanes)\n            : isHydrating ||\n              ((renderLanes = workInProgress.type),\n              (current = workInProgress.pendingProps),\n              (lazyComponent = getOwnerDocumentFromRootContainer(\n                rootInstanceStackCursor.current\n              ).createElement(renderLanes)),\n              (lazyComponent[internalInstanceKey] = workInProgress),\n              (lazyComponent[internalPropsKey] = current),\n              setInitialProperties(lazyComponent, renderLanes, current),\n              markNodeAsHoistable(lazyComponent),\n              (workInProgress.stateNode = lazyComponent))\n          : (workInProgress.memoizedState = getResource(\n              workInProgress.type,\n              current.memoizedProps,\n              workInProgress.pendingProps,\n              current.memoizedState\n            )),\n        null\n      );\n    case 27:\n      return (\n        pushHostContext(workInProgress),\n        null === current &&\n          isHydrating &&\n          ((lazyComponent = workInProgress.stateNode =\n            resolveSingletonInstance(\n              workInProgress.type,\n              workInProgress.pendingProps,\n              rootInstanceStackCursor.current\n            )),\n          (hydrationParentFiber = workInProgress),\n          (rootOrSingletonContext = !0),\n          (init = nextHydratableInstance),\n          isSingletonScope(workInProgress.type)\n            ? ((previousHydratableOnEnteringScopedSingleton = init),\n              (nextHydratableInstance = getNextHydratable(\n                lazyComponent.firstChild\n              )))\n            : (nextHydratableInstance = init)),\n        reconcileChildren(\n          current,\n          workInProgress,\n          workInProgress.pendingProps.children,\n          renderLanes\n        ),\n        markRef(current, workInProgress),\n        null === current && (workInProgress.flags |= 4194304),\n        workInProgress.child\n      );\n    case 5:\n      if (null === current && isHydrating) {\n        if ((init = lazyComponent = nextHydratableInstance))\n          (lazyComponent = canHydrateInstance(\n            lazyComponent,\n            workInProgress.type,\n            workInProgress.pendingProps,\n            rootOrSingletonContext\n          )),\n            null !== lazyComponent\n              ? ((workInProgress.stateNode = lazyComponent),\n                (hydrationParentFiber = workInProgress),\n                (nextHydratableInstance = getNextHydratable(\n                  lazyComponent.firstChild\n                )),\n                (rootOrSingletonContext = !1),\n                (init = !0))\n              : (init = !1);\n        init || throwOnHydrationMismatch(workInProgress);\n      }\n      pushHostContext(workInProgress);\n      init = workInProgress.type;\n      prevState = workInProgress.pendingProps;\n      nextState = null !== current ? current.memoizedProps : null;\n      lazyComponent = prevState.children;\n      shouldSetTextContent(init, prevState)\n        ? (lazyComponent = null)\n        : null !== nextState &&\n          shouldSetTextContent(init, nextState) &&\n          (workInProgress.flags |= 32);\n      null !== workInProgress.memoizedState &&\n        ((init = renderWithHooks(\n          current,\n          workInProgress,\n          TransitionAwareHostComponent,\n          null,\n          null,\n          renderLanes\n        )),\n        (HostTransitionContext._currentValue = init));\n      markRef(current, workInProgress);\n      reconcileChildren(current, workInProgress, lazyComponent, renderLanes);\n      return workInProgress.child;\n    case 6:\n      if (null === current && isHydrating) {\n        if ((current = renderLanes = nextHydratableInstance))\n          (renderLanes = canHydrateTextInstance(\n            renderLanes,\n            workInProgress.pendingProps,\n            rootOrSingletonContext\n          )),\n            null !== renderLanes\n              ? ((workInProgress.stateNode = renderLanes),\n                (hydrationParentFiber = workInProgress),\n                (nextHydratableInstance = null),\n                (current = !0))\n              : (current = !1);\n        current || throwOnHydrationMismatch(workInProgress);\n      }\n      return null;\n    case 13:\n      return updateSuspenseComponent(current, workInProgress, renderLanes);\n    case 4:\n      return (\n        pushHostContainer(\n          workInProgress,\n          workInProgress.stateNode.containerInfo\n        ),\n        (lazyComponent = workInProgress.pendingProps),\n        null === current\n          ? (workInProgress.child = reconcileChildFibers(\n              workInProgress,\n              null,\n              lazyComponent,\n              renderLanes\n            ))\n          : reconcileChildren(\n              current,\n              workInProgress,\n              lazyComponent,\n              renderLanes\n            ),\n        workInProgress.child\n      );\n    case 11:\n      return updateForwardRef(\n        current,\n        workInProgress,\n        workInProgress.type,\n        workInProgress.pendingProps,\n        renderLanes\n      );\n    case 7:\n      return (\n        reconcileChildren(\n          current,\n          workInProgress,\n          workInProgress.pendingProps,\n          renderLanes\n        ),\n        workInProgress.child\n      );\n    case 8:\n      return (\n        reconcileChildren(\n          current,\n          workInProgress,\n          workInProgress.pendingProps.children,\n          renderLanes\n        ),\n        workInProgress.child\n      );\n    case 12:\n      return (\n        reconcileChildren(\n          current,\n          workInProgress,\n          workInProgress.pendingProps.children,\n          renderLanes\n        ),\n        workInProgress.child\n      );\n    case 10:\n      return (\n        (lazyComponent = workInProgress.pendingProps),\n        pushProvider(workInProgress, workInProgress.type, lazyComponent.value),\n        reconcileChildren(\n          current,\n          workInProgress,\n          lazyComponent.children,\n          renderLanes\n        ),\n        workInProgress.child\n      );\n    case 9:\n      return (\n        (init = workInProgress.type._context),\n        (lazyComponent = workInProgress.pendingProps.children),\n        prepareToReadContext(workInProgress),\n        (init = readContext(init)),\n        (lazyComponent = lazyComponent(init)),\n        (workInProgress.flags |= 1),\n        reconcileChildren(current, workInProgress, lazyComponent, renderLanes),\n        workInProgress.child\n      );\n    case 14:\n      return updateMemoComponent(\n        current,\n        workInProgress,\n        workInProgress.type,\n        workInProgress.pendingProps,\n        renderLanes\n      );\n    case 15:\n      return updateSimpleMemoComponent(\n        current,\n        workInProgress,\n        workInProgress.type,\n        workInProgress.pendingProps,\n        renderLanes\n      );\n    case 19:\n      return updateSuspenseListComponent(current, workInProgress, renderLanes);\n    case 31:\n      return (\n        (lazyComponent = workInProgress.pendingProps),\n        (renderLanes = workInProgress.mode),\n        (lazyComponent = {\n          mode: lazyComponent.mode,\n          children: lazyComponent.children\n        }),\n        null === current\n          ? ((renderLanes = mountWorkInProgressOffscreenFiber(\n              lazyComponent,\n              renderLanes\n            )),\n            (renderLanes.ref = workInProgress.ref),\n            (workInProgress.child = renderLanes),\n            (renderLanes.return = workInProgress),\n            (workInProgress = renderLanes))\n          : ((renderLanes = createWorkInProgress(current.child, lazyComponent)),\n            (renderLanes.ref = workInProgress.ref),\n            (workInProgress.child = renderLanes),\n            (renderLanes.return = workInProgress),\n            (workInProgress = renderLanes)),\n        workInProgress\n      );\n    case 22:\n      return updateOffscreenComponent(current, workInProgress, renderLanes);\n    case 24:\n      return (\n        prepareToReadContext(workInProgress),\n        (lazyComponent = readContext(CacheContext)),\n        null === current\n          ? ((init = peekCacheFromPool()),\n            null === init &&\n              ((init = workInProgressRoot),\n              (prevState = createCache()),\n              (init.pooledCache = prevState),\n              prevState.refCount++,\n              null !== prevState && (init.pooledCacheLanes |= renderLanes),\n              (init = prevState)),\n            (workInProgress.memoizedState = {\n              parent: lazyComponent,\n              cache: init\n            }),\n            initializeUpdateQueue(workInProgress),\n            pushProvider(workInProgress, CacheContext, init))\n          : (0 !== (current.lanes & renderLanes) &&\n              (cloneUpdateQueue(current, workInProgress),\n              processUpdateQueue(workInProgress, null, null, renderLanes),\n              suspendIfUpdateReadFromEntangledAsyncAction()),\n            (init = current.memoizedState),\n            (prevState = workInProgress.memoizedState),\n            init.parent !== lazyComponent\n              ? ((init = { parent: lazyComponent, cache: lazyComponent }),\n                (workInProgress.memoizedState = init),\n                0 === workInProgress.lanes &&\n                  (workInProgress.memoizedState =\n                    workInProgress.updateQueue.baseState =\n                      init),\n                pushProvider(workInProgress, CacheContext, lazyComponent))\n              : ((lazyComponent = prevState.cache),\n                pushProvider(workInProgress, CacheContext, lazyComponent),\n                lazyComponent !== init.cache &&\n                  propagateContextChanges(\n                    workInProgress,\n                    [CacheContext],\n                    renderLanes,\n                    !0\n                  ))),\n        reconcileChildren(\n          current,\n          workInProgress,\n          workInProgress.pendingProps.children,\n          renderLanes\n        ),\n        workInProgress.child\n      );\n    case 29:\n      throw workInProgress.pendingProps;\n  }\n  throw Error(formatProdErrorMessage(156, workInProgress.tag));\n}\nfunction markUpdate(workInProgress) {\n  workInProgress.flags |= 4;\n}\nfunction preloadResourceAndSuspendIfNeeded(workInProgress, resource) {\n  if (\"stylesheet\" !== resource.type || 0 !== (resource.state.loading & 4))\n    workInProgress.flags &= -16777217;\n  else if (((workInProgress.flags |= 16777216), !preloadResource(resource))) {\n    resource = suspenseHandlerStackCursor.current;\n    if (\n      null !== resource &&\n      ((workInProgressRootRenderLanes & 4194048) ===\n      workInProgressRootRenderLanes\n        ? null !== shellBoundary\n        : ((workInProgressRootRenderLanes & 62914560) !==\n            workInProgressRootRenderLanes &&\n            0 === (workInProgressRootRenderLanes & 536870912)) ||\n          resource !== shellBoundary)\n    )\n      throw (\n        ((suspendedThenable = noopSuspenseyCommitThenable),\n        SuspenseyCommitException)\n      );\n    workInProgress.flags |= 8192;\n  }\n}\nfunction scheduleRetryEffect(workInProgress, retryQueue) {\n  null !== retryQueue && (workInProgress.flags |= 4);\n  workInProgress.flags & 16384 &&\n    ((retryQueue =\n      22 !== workInProgress.tag ? claimNextRetryLane() : 536870912),\n    (workInProgress.lanes |= retryQueue),\n    (workInProgressSuspendedRetryLanes |= retryQueue));\n}\nfunction cutOffTailIfNeeded(renderState, hasRenderedATailFallback) {\n  if (!isHydrating)\n    switch (renderState.tailMode) {\n      case \"hidden\":\n        hasRenderedATailFallback = renderState.tail;\n        for (var lastTailNode = null; null !== hasRenderedATailFallback; )\n          null !== hasRenderedATailFallback.alternate &&\n            (lastTailNode = hasRenderedATailFallback),\n            (hasRenderedATailFallback = hasRenderedATailFallback.sibling);\n        null === lastTailNode\n          ? (renderState.tail = null)\n          : (lastTailNode.sibling = null);\n        break;\n      case \"collapsed\":\n        lastTailNode = renderState.tail;\n        for (var lastTailNode$113 = null; null !== lastTailNode; )\n          null !== lastTailNode.alternate && (lastTailNode$113 = lastTailNode),\n            (lastTailNode = lastTailNode.sibling);\n        null === lastTailNode$113\n          ? hasRenderedATailFallback || null === renderState.tail\n            ? (renderState.tail = null)\n            : (renderState.tail.sibling = null)\n          : (lastTailNode$113.sibling = null);\n    }\n}\nfunction bubbleProperties(completedWork) {\n  var didBailout =\n      null !== completedWork.alternate &&\n      completedWork.alternate.child === completedWork.child,\n    newChildLanes = 0,\n    subtreeFlags = 0;\n  if (didBailout)\n    for (var child$114 = completedWork.child; null !== child$114; )\n      (newChildLanes |= child$114.lanes | child$114.childLanes),\n        (subtreeFlags |= child$114.subtreeFlags & 65011712),\n        (subtreeFlags |= child$114.flags & 65011712),\n        (child$114.return = completedWork),\n        (child$114 = child$114.sibling);\n  else\n    for (child$114 = completedWork.child; null !== child$114; )\n      (newChildLanes |= child$114.lanes | child$114.childLanes),\n        (subtreeFlags |= child$114.subtreeFlags),\n        (subtreeFlags |= child$114.flags),\n        (child$114.return = completedWork),\n        (child$114 = child$114.sibling);\n  completedWork.subtreeFlags |= subtreeFlags;\n  completedWork.childLanes = newChildLanes;\n  return didBailout;\n}\nfunction completeWork(current, workInProgress, renderLanes) {\n  var newProps = workInProgress.pendingProps;\n  popTreeContext(workInProgress);\n  switch (workInProgress.tag) {\n    case 31:\n    case 16:\n    case 15:\n    case 0:\n    case 11:\n    case 7:\n    case 8:\n    case 12:\n    case 9:\n    case 14:\n      return bubbleProperties(workInProgress), null;\n    case 1:\n      return bubbleProperties(workInProgress), null;\n    case 3:\n      renderLanes = workInProgress.stateNode;\n      newProps = null;\n      null !== current && (newProps = current.memoizedState.cache);\n      workInProgress.memoizedState.cache !== newProps &&\n        (workInProgress.flags |= 2048);\n      popProvider(CacheContext);\n      popHostContainer();\n      renderLanes.pendingContext &&\n        ((renderLanes.context = renderLanes.pendingContext),\n        (renderLanes.pendingContext = null));\n      if (null === current || null === current.child)\n        popHydrationState(workInProgress)\n          ? markUpdate(workInProgress)\n          : null === current ||\n            (current.memoizedState.isDehydrated &&\n              0 === (workInProgress.flags & 256)) ||\n            ((workInProgress.flags |= 1024),\n            upgradeHydrationErrorsToRecoverable());\n      bubbleProperties(workInProgress);\n      return null;\n    case 26:\n      return (\n        (renderLanes = workInProgress.memoizedState),\n        null === current\n          ? (markUpdate(workInProgress),\n            null !== renderLanes\n              ? (bubbleProperties(workInProgress),\n                preloadResourceAndSuspendIfNeeded(workInProgress, renderLanes))\n              : (bubbleProperties(workInProgress),\n                (workInProgress.flags &= -16777217)))\n          : renderLanes\n            ? renderLanes !== current.memoizedState\n              ? (markUpdate(workInProgress),\n                bubbleProperties(workInProgress),\n                preloadResourceAndSuspendIfNeeded(workInProgress, renderLanes))\n              : (bubbleProperties(workInProgress),\n                (workInProgress.flags &= -16777217))\n            : (current.memoizedProps !== newProps && markUpdate(workInProgress),\n              bubbleProperties(workInProgress),\n              (workInProgress.flags &= -16777217)),\n        null\n      );\n    case 27:\n      popHostContext(workInProgress);\n      renderLanes = rootInstanceStackCursor.current;\n      var type = workInProgress.type;\n      if (null !== current && null != workInProgress.stateNode)\n        current.memoizedProps !== newProps && markUpdate(workInProgress);\n      else {\n        if (!newProps) {\n          if (null === workInProgress.stateNode)\n            throw Error(formatProdErrorMessage(166));\n          bubbleProperties(workInProgress);\n          return null;\n        }\n        current = contextStackCursor.current;\n        popHydrationState(workInProgress)\n          ? prepareToHydrateHostInstance(workInProgress, current)\n          : ((current = resolveSingletonInstance(type, newProps, renderLanes)),\n            (workInProgress.stateNode = current),\n            markUpdate(workInProgress));\n      }\n      bubbleProperties(workInProgress);\n      return null;\n    case 5:\n      popHostContext(workInProgress);\n      renderLanes = workInProgress.type;\n      if (null !== current && null != workInProgress.stateNode)\n        current.memoizedProps !== newProps && markUpdate(workInProgress);\n      else {\n        if (!newProps) {\n          if (null === workInProgress.stateNode)\n            throw Error(formatProdErrorMessage(166));\n          bubbleProperties(workInProgress);\n          return null;\n        }\n        current = contextStackCursor.current;\n        if (popHydrationState(workInProgress))\n          prepareToHydrateHostInstance(workInProgress, current);\n        else {\n          type = getOwnerDocumentFromRootContainer(\n            rootInstanceStackCursor.current\n          );\n          switch (current) {\n            case 1:\n              current = type.createElementNS(\n                \"http://www.w3.org/2000/svg\",\n                renderLanes\n              );\n              break;\n            case 2:\n              current = type.createElementNS(\n                \"http://www.w3.org/1998/Math/MathML\",\n                renderLanes\n              );\n              break;\n            default:\n              switch (renderLanes) {\n                case \"svg\":\n                  current = type.createElementNS(\n                    \"http://www.w3.org/2000/svg\",\n                    renderLanes\n                  );\n                  break;\n                case \"math\":\n                  current = type.createElementNS(\n                    \"http://www.w3.org/1998/Math/MathML\",\n                    renderLanes\n                  );\n                  break;\n                case \"script\":\n                  current = type.createElement(\"div\");\n                  current.innerHTML = \"<script>\\x3c/script>\";\n                  current = current.removeChild(current.firstChild);\n                  break;\n                case \"select\":\n                  current =\n                    \"string\" === typeof newProps.is\n                      ? type.createElement(\"select\", { is: newProps.is })\n                      : type.createElement(\"select\");\n                  newProps.multiple\n                    ? (current.multiple = !0)\n                    : newProps.size && (current.size = newProps.size);\n                  break;\n                default:\n                  current =\n                    \"string\" === typeof newProps.is\n                      ? type.createElement(renderLanes, { is: newProps.is })\n                      : type.createElement(renderLanes);\n              }\n          }\n          current[internalInstanceKey] = workInProgress;\n          current[internalPropsKey] = newProps;\n          a: for (type = workInProgress.child; null !== type; ) {\n            if (5 === type.tag || 6 === type.tag)\n              current.appendChild(type.stateNode);\n            else if (4 !== type.tag && 27 !== type.tag && null !== type.child) {\n              type.child.return = type;\n              type = type.child;\n              continue;\n            }\n            if (type === workInProgress) break a;\n            for (; null === type.sibling; ) {\n              if (null === type.return || type.return === workInProgress)\n                break a;\n              type = type.return;\n            }\n            type.sibling.return = type.return;\n            type = type.sibling;\n          }\n          workInProgress.stateNode = current;\n          a: switch (\n            (setInitialProperties(current, renderLanes, newProps), renderLanes)\n          ) {\n            case \"button\":\n            case \"input\":\n            case \"select\":\n            case \"textarea\":\n              current = !!newProps.autoFocus;\n              break a;\n            case \"img\":\n              current = !0;\n              break a;\n            default:\n              current = !1;\n          }\n          current && markUpdate(workInProgress);\n        }\n      }\n      bubbleProperties(workInProgress);\n      workInProgress.flags &= -16777217;\n      return null;\n    case 6:\n      if (current && null != workInProgress.stateNode)\n        current.memoizedProps !== newProps && markUpdate(workInProgress);\n      else {\n        if (\"string\" !== typeof newProps && null === workInProgress.stateNode)\n          throw Error(formatProdErrorMessage(166));\n        current = rootInstanceStackCursor.current;\n        if (popHydrationState(workInProgress)) {\n          current = workInProgress.stateNode;\n          renderLanes = workInProgress.memoizedProps;\n          newProps = null;\n          type = hydrationParentFiber;\n          if (null !== type)\n            switch (type.tag) {\n              case 27:\n              case 5:\n                newProps = type.memoizedProps;\n            }\n          current[internalInstanceKey] = workInProgress;\n          current =\n            current.nodeValue === renderLanes ||\n            (null !== newProps && !0 === newProps.suppressHydrationWarning) ||\n            checkForUnmatchedText(current.nodeValue, renderLanes)\n              ? !0\n              : !1;\n          current || throwOnHydrationMismatch(workInProgress);\n        } else\n          (current =\n            getOwnerDocumentFromRootContainer(current).createTextNode(\n              newProps\n            )),\n            (current[internalInstanceKey] = workInProgress),\n            (workInProgress.stateNode = current);\n      }\n      bubbleProperties(workInProgress);\n      return null;\n    case 13:\n      newProps = workInProgress.memoizedState;\n      if (\n        null === current ||\n        (null !== current.memoizedState &&\n          null !== current.memoizedState.dehydrated)\n      ) {\n        type = popHydrationState(workInProgress);\n        if (null !== newProps && null !== newProps.dehydrated) {\n          if (null === current) {\n            if (!type) throw Error(formatProdErrorMessage(318));\n            type = workInProgress.memoizedState;\n            type = null !== type ? type.dehydrated : null;\n            if (!type) throw Error(formatProdErrorMessage(317));\n            type[internalInstanceKey] = workInProgress;\n          } else\n            resetHydrationState(),\n              0 === (workInProgress.flags & 128) &&\n                (workInProgress.memoizedState = null),\n              (workInProgress.flags |= 4);\n          bubbleProperties(workInProgress);\n          type = !1;\n        } else\n          (type = upgradeHydrationErrorsToRecoverable()),\n            null !== current &&\n              null !== current.memoizedState &&\n              (current.memoizedState.hydrationErrors = type),\n            (type = !0);\n        if (!type) {\n          if (workInProgress.flags & 256)\n            return popSuspenseHandler(workInProgress), workInProgress;\n          popSuspenseHandler(workInProgress);\n          return null;\n        }\n      }\n      popSuspenseHandler(workInProgress);\n      if (0 !== (workInProgress.flags & 128))\n        return (workInProgress.lanes = renderLanes), workInProgress;\n      renderLanes = null !== newProps;\n      current = null !== current && null !== current.memoizedState;\n      if (renderLanes) {\n        newProps = workInProgress.child;\n        type = null;\n        null !== newProps.alternate &&\n          null !== newProps.alternate.memoizedState &&\n          null !== newProps.alternate.memoizedState.cachePool &&\n          (type = newProps.alternate.memoizedState.cachePool.pool);\n        var cache$127 = null;\n        null !== newProps.memoizedState &&\n          null !== newProps.memoizedState.cachePool &&\n          (cache$127 = newProps.memoizedState.cachePool.pool);\n        cache$127 !== type && (newProps.flags |= 2048);\n      }\n      renderLanes !== current &&\n        renderLanes &&\n        (workInProgress.child.flags |= 8192);\n      scheduleRetryEffect(workInProgress, workInProgress.updateQueue);\n      bubbleProperties(workInProgress);\n      return null;\n    case 4:\n      return (\n        popHostContainer(),\n        null === current &&\n          listenToAllSupportedEvents(workInProgress.stateNode.containerInfo),\n        bubbleProperties(workInProgress),\n        null\n      );\n    case 10:\n      return (\n        popProvider(workInProgress.type), bubbleProperties(workInProgress), null\n      );\n    case 19:\n      pop(suspenseStackCursor);\n      type = workInProgress.memoizedState;\n      if (null === type) return bubbleProperties(workInProgress), null;\n      newProps = 0 !== (workInProgress.flags & 128);\n      cache$127 = type.rendering;\n      if (null === cache$127)\n        if (newProps) cutOffTailIfNeeded(type, !1);\n        else {\n          if (\n            0 !== workInProgressRootExitStatus ||\n            (null !== current && 0 !== (current.flags & 128))\n          )\n            for (current = workInProgress.child; null !== current; ) {\n              cache$127 = findFirstSuspended(current);\n              if (null !== cache$127) {\n                workInProgress.flags |= 128;\n                cutOffTailIfNeeded(type, !1);\n                current = cache$127.updateQueue;\n                workInProgress.updateQueue = current;\n                scheduleRetryEffect(workInProgress, current);\n                workInProgress.subtreeFlags = 0;\n                current = renderLanes;\n                for (renderLanes = workInProgress.child; null !== renderLanes; )\n                  resetWorkInProgress(renderLanes, current),\n                    (renderLanes = renderLanes.sibling);\n                push(\n                  suspenseStackCursor,\n                  (suspenseStackCursor.current & 1) | 2\n                );\n                return workInProgress.child;\n              }\n              current = current.sibling;\n            }\n          null !== type.tail &&\n            now() > workInProgressRootRenderTargetTime &&\n            ((workInProgress.flags |= 128),\n            (newProps = !0),\n            cutOffTailIfNeeded(type, !1),\n            (workInProgress.lanes = 4194304));\n        }\n      else {\n        if (!newProps)\n          if (((current = findFirstSuspended(cache$127)), null !== current)) {\n            if (\n              ((workInProgress.flags |= 128),\n              (newProps = !0),\n              (current = current.updateQueue),\n              (workInProgress.updateQueue = current),\n              scheduleRetryEffect(workInProgress, current),\n              cutOffTailIfNeeded(type, !0),\n              null === type.tail &&\n                \"hidden\" === type.tailMode &&\n                !cache$127.alternate &&\n                !isHydrating)\n            )\n              return bubbleProperties(workInProgress), null;\n          } else\n            2 * now() - type.renderingStartTime >\n              workInProgressRootRenderTargetTime &&\n              536870912 !== renderLanes &&\n              ((workInProgress.flags |= 128),\n              (newProps = !0),\n              cutOffTailIfNeeded(type, !1),\n              (workInProgress.lanes = 4194304));\n        type.isBackwards\n          ? ((cache$127.sibling = workInProgress.child),\n            (workInProgress.child = cache$127))\n          : ((current = type.last),\n            null !== current\n              ? (current.sibling = cache$127)\n              : (workInProgress.child = cache$127),\n            (type.last = cache$127));\n      }\n      if (null !== type.tail)\n        return (\n          (workInProgress = type.tail),\n          (type.rendering = workInProgress),\n          (type.tail = workInProgress.sibling),\n          (type.renderingStartTime = now()),\n          (workInProgress.sibling = null),\n          (current = suspenseStackCursor.current),\n          push(suspenseStackCursor, newProps ? (current & 1) | 2 : current & 1),\n          workInProgress\n        );\n      bubbleProperties(workInProgress);\n      return null;\n    case 22:\n    case 23:\n      return (\n        popSuspenseHandler(workInProgress),\n        popHiddenContext(),\n        (newProps = null !== workInProgress.memoizedState),\n        null !== current\n          ? (null !== current.memoizedState) !== newProps &&\n            (workInProgress.flags |= 8192)\n          : newProps && (workInProgress.flags |= 8192),\n        newProps\n          ? 0 !== (renderLanes & 536870912) &&\n            0 === (workInProgress.flags & 128) &&\n            (bubbleProperties(workInProgress),\n            workInProgress.subtreeFlags & 6 && (workInProgress.flags |= 8192))\n          : bubbleProperties(workInProgress),\n        (renderLanes = workInProgress.updateQueue),\n        null !== renderLanes &&\n          scheduleRetryEffect(workInProgress, renderLanes.retryQueue),\n        (renderLanes = null),\n        null !== current &&\n          null !== current.memoizedState &&\n          null !== current.memoizedState.cachePool &&\n          (renderLanes = current.memoizedState.cachePool.pool),\n        (newProps = null),\n        null !== workInProgress.memoizedState &&\n          null !== workInProgress.memoizedState.cachePool &&\n          (newProps = workInProgress.memoizedState.cachePool.pool),\n        newProps !== renderLanes && (workInProgress.flags |= 2048),\n        null !== current && pop(resumedCache),\n        null\n      );\n    case 24:\n      return (\n        (renderLanes = null),\n        null !== current && (renderLanes = current.memoizedState.cache),\n        workInProgress.memoizedState.cache !== renderLanes &&\n          (workInProgress.flags |= 2048),\n        popProvider(CacheContext),\n        bubbleProperties(workInProgress),\n        null\n      );\n    case 25:\n      return null;\n    case 30:\n      return null;\n  }\n  throw Error(formatProdErrorMessage(156, workInProgress.tag));\n}\nfunction unwindWork(current, workInProgress) {\n  popTreeContext(workInProgress);\n  switch (workInProgress.tag) {\n    case 1:\n      return (\n        (current = workInProgress.flags),\n        current & 65536\n          ? ((workInProgress.flags = (current & -65537) | 128), workInProgress)\n          : null\n      );\n    case 3:\n      return (\n        popProvider(CacheContext),\n        popHostContainer(),\n        (current = workInProgress.flags),\n        0 !== (current & 65536) && 0 === (current & 128)\n          ? ((workInProgress.flags = (current & -65537) | 128), workInProgress)\n          : null\n      );\n    case 26:\n    case 27:\n    case 5:\n      return popHostContext(workInProgress), null;\n    case 13:\n      popSuspenseHandler(workInProgress);\n      current = workInProgress.memoizedState;\n      if (null !== current && null !== current.dehydrated) {\n        if (null === workInProgress.alternate)\n          throw Error(formatProdErrorMessage(340));\n        resetHydrationState();\n      }\n      current = workInProgress.flags;\n      return current & 65536\n        ? ((workInProgress.flags = (current & -65537) | 128), workInProgress)\n        : null;\n    case 19:\n      return pop(suspenseStackCursor), null;\n    case 4:\n      return popHostContainer(), null;\n    case 10:\n      return popProvider(workInProgress.type), null;\n    case 22:\n    case 23:\n      return (\n        popSuspenseHandler(workInProgress),\n        popHiddenContext(),\n        null !== current && pop(resumedCache),\n        (current = workInProgress.flags),\n        current & 65536\n          ? ((workInProgress.flags = (current & -65537) | 128), workInProgress)\n          : null\n      );\n    case 24:\n      return popProvider(CacheContext), null;\n    case 25:\n      return null;\n    default:\n      return null;\n  }\n}\nfunction unwindInterruptedWork(current, interruptedWork) {\n  popTreeContext(interruptedWork);\n  switch (interruptedWork.tag) {\n    case 3:\n      popProvider(CacheContext);\n      popHostContainer();\n      break;\n    case 26:\n    case 27:\n    case 5:\n      popHostContext(interruptedWork);\n      break;\n    case 4:\n      popHostContainer();\n      break;\n    case 13:\n      popSuspenseHandler(interruptedWork);\n      break;\n    case 19:\n      pop(suspenseStackCursor);\n      break;\n    case 10:\n      popProvider(interruptedWork.type);\n      break;\n    case 22:\n    case 23:\n      popSuspenseHandler(interruptedWork);\n      popHiddenContext();\n      null !== current && pop(resumedCache);\n      break;\n    case 24:\n      popProvider(CacheContext);\n  }\n}\nfunction commitHookEffectListMount(flags, finishedWork) {\n  try {\n    var updateQueue = finishedWork.updateQueue,\n      lastEffect = null !== updateQueue ? updateQueue.lastEffect : null;\n    if (null !== lastEffect) {\n      var firstEffect = lastEffect.next;\n      updateQueue = firstEffect;\n      do {\n        if ((updateQueue.tag & flags) === flags) {\n          lastEffect = void 0;\n          var create = updateQueue.create,\n            inst = updateQueue.inst;\n          lastEffect = create();\n          inst.destroy = lastEffect;\n        }\n        updateQueue = updateQueue.next;\n      } while (updateQueue !== firstEffect);\n    }\n  } catch (error) {\n    captureCommitPhaseError(finishedWork, finishedWork.return, error);\n  }\n}\nfunction commitHookEffectListUnmount(\n  flags,\n  finishedWork,\n  nearestMountedAncestor$jscomp$0\n) {\n  try {\n    var updateQueue = finishedWork.updateQueue,\n      lastEffect = null !== updateQueue ? updateQueue.lastEffect : null;\n    if (null !== lastEffect) {\n      var firstEffect = lastEffect.next;\n      updateQueue = firstEffect;\n      do {\n        if ((updateQueue.tag & flags) === flags) {\n          var inst = updateQueue.inst,\n            destroy = inst.destroy;\n          if (void 0 !== destroy) {\n            inst.destroy = void 0;\n            lastEffect = finishedWork;\n            var nearestMountedAncestor = nearestMountedAncestor$jscomp$0,\n              destroy_ = destroy;\n            try {\n              destroy_();\n            } catch (error) {\n              captureCommitPhaseError(\n                lastEffect,\n                nearestMountedAncestor,\n                error\n              );\n            }\n          }\n        }\n        updateQueue = updateQueue.next;\n      } while (updateQueue !== firstEffect);\n    }\n  } catch (error) {\n    captureCommitPhaseError(finishedWork, finishedWork.return, error);\n  }\n}\nfunction commitClassCallbacks(finishedWork) {\n  var updateQueue = finishedWork.updateQueue;\n  if (null !== updateQueue) {\n    var instance = finishedWork.stateNode;\n    try {\n      commitCallbacks(updateQueue, instance);\n    } catch (error) {\n      captureCommitPhaseError(finishedWork, finishedWork.return, error);\n    }\n  }\n}\nfunction safelyCallComponentWillUnmount(\n  current,\n  nearestMountedAncestor,\n  instance\n) {\n  instance.props = resolveClassComponentProps(\n    current.type,\n    current.memoizedProps\n  );\n  instance.state = current.memoizedState;\n  try {\n    instance.componentWillUnmount();\n  } catch (error) {\n    captureCommitPhaseError(current, nearestMountedAncestor, error);\n  }\n}\nfunction safelyAttachRef(current, nearestMountedAncestor) {\n  try {\n    var ref = current.ref;\n    if (null !== ref) {\n      switch (current.tag) {\n        case 26:\n        case 27:\n        case 5:\n          var instanceToUse = current.stateNode;\n          break;\n        case 30:\n          instanceToUse = current.stateNode;\n          break;\n        default:\n          instanceToUse = current.stateNode;\n      }\n      \"function\" === typeof ref\n        ? (current.refCleanup = ref(instanceToUse))\n        : (ref.current = instanceToUse);\n    }\n  } catch (error) {\n    captureCommitPhaseError(current, nearestMountedAncestor, error);\n  }\n}\nfunction safelyDetachRef(current, nearestMountedAncestor) {\n  var ref = current.ref,\n    refCleanup = current.refCleanup;\n  if (null !== ref)\n    if (\"function\" === typeof refCleanup)\n      try {\n        refCleanup();\n      } catch (error) {\n        captureCommitPhaseError(current, nearestMountedAncestor, error);\n      } finally {\n        (current.refCleanup = null),\n          (current = current.alternate),\n          null != current && (current.refCleanup = null);\n      }\n    else if (\"function\" === typeof ref)\n      try {\n        ref(null);\n      } catch (error$143) {\n        captureCommitPhaseError(current, nearestMountedAncestor, error$143);\n      }\n    else ref.current = null;\n}\nfunction commitHostMount(finishedWork) {\n  var type = finishedWork.type,\n    props = finishedWork.memoizedProps,\n    instance = finishedWork.stateNode;\n  try {\n    a: switch (type) {\n      case \"button\":\n      case \"input\":\n      case \"select\":\n      case \"textarea\":\n        props.autoFocus && instance.focus();\n        break a;\n      case \"img\":\n        props.src\n          ? (instance.src = props.src)\n          : props.srcSet && (instance.srcset = props.srcSet);\n    }\n  } catch (error) {\n    captureCommitPhaseError(finishedWork, finishedWork.return, error);\n  }\n}\nfunction commitHostUpdate(finishedWork, newProps, oldProps) {\n  try {\n    var domElement = finishedWork.stateNode;\n    updateProperties(domElement, finishedWork.type, oldProps, newProps);\n    domElement[internalPropsKey] = newProps;\n  } catch (error) {\n    captureCommitPhaseError(finishedWork, finishedWork.return, error);\n  }\n}\nfunction isHostParent(fiber) {\n  return (\n    5 === fiber.tag ||\n    3 === fiber.tag ||\n    26 === fiber.tag ||\n    (27 === fiber.tag && isSingletonScope(fiber.type)) ||\n    4 === fiber.tag\n  );\n}\nfunction getHostSibling(fiber) {\n  a: for (;;) {\n    for (; null === fiber.sibling; ) {\n      if (null === fiber.return || isHostParent(fiber.return)) return null;\n      fiber = fiber.return;\n    }\n    fiber.sibling.return = fiber.return;\n    for (\n      fiber = fiber.sibling;\n      5 !== fiber.tag && 6 !== fiber.tag && 18 !== fiber.tag;\n\n    ) {\n      if (27 === fiber.tag && isSingletonScope(fiber.type)) continue a;\n      if (fiber.flags & 2) continue a;\n      if (null === fiber.child || 4 === fiber.tag) continue a;\n      else (fiber.child.return = fiber), (fiber = fiber.child);\n    }\n    if (!(fiber.flags & 2)) return fiber.stateNode;\n  }\n}\nfunction insertOrAppendPlacementNodeIntoContainer(node, before, parent) {\n  var tag = node.tag;\n  if (5 === tag || 6 === tag)\n    (node = node.stateNode),\n      before\n        ? (9 === parent.nodeType\n            ? parent.body\n            : \"HTML\" === parent.nodeName\n              ? parent.ownerDocument.body\n              : parent\n          ).insertBefore(node, before)\n        : ((before =\n            9 === parent.nodeType\n              ? parent.body\n              : \"HTML\" === parent.nodeName\n                ? parent.ownerDocument.body\n                : parent),\n          before.appendChild(node),\n          (parent = parent._reactRootContainer),\n          (null !== parent && void 0 !== parent) ||\n            null !== before.onclick ||\n            (before.onclick = noop$1));\n  else if (\n    4 !== tag &&\n    (27 === tag &&\n      isSingletonScope(node.type) &&\n      ((parent = node.stateNode), (before = null)),\n    (node = node.child),\n    null !== node)\n  )\n    for (\n      insertOrAppendPlacementNodeIntoContainer(node, before, parent),\n        node = node.sibling;\n      null !== node;\n\n    )\n      insertOrAppendPlacementNodeIntoContainer(node, before, parent),\n        (node = node.sibling);\n}\nfunction insertOrAppendPlacementNode(node, before, parent) {\n  var tag = node.tag;\n  if (5 === tag || 6 === tag)\n    (node = node.stateNode),\n      before ? parent.insertBefore(node, before) : parent.appendChild(node);\n  else if (\n    4 !== tag &&\n    (27 === tag && isSingletonScope(node.type) && (parent = node.stateNode),\n    (node = node.child),\n    null !== node)\n  )\n    for (\n      insertOrAppendPlacementNode(node, before, parent), node = node.sibling;\n      null !== node;\n\n    )\n      insertOrAppendPlacementNode(node, before, parent), (node = node.sibling);\n}\nfunction commitHostSingletonAcquisition(finishedWork) {\n  var singleton = finishedWork.stateNode,\n    props = finishedWork.memoizedProps;\n  try {\n    for (\n      var type = finishedWork.type, attributes = singleton.attributes;\n      attributes.length;\n\n    )\n      singleton.removeAttributeNode(attributes[0]);\n    setInitialProperties(singleton, type, props);\n    singleton[internalInstanceKey] = finishedWork;\n    singleton[internalPropsKey] = props;\n  } catch (error) {\n    captureCommitPhaseError(finishedWork, finishedWork.return, error);\n  }\n}\nvar offscreenSubtreeIsHidden = !1,\n  offscreenSubtreeWasHidden = !1,\n  needsFormReset = !1,\n  PossiblyWeakSet = \"function\" === typeof WeakSet ? WeakSet : Set,\n  nextEffect = null;\nfunction commitBeforeMutationEffects(root, firstChild) {\n  root = root.containerInfo;\n  eventsEnabled = _enabled;\n  root = getActiveElementDeep(root);\n  if (hasSelectionCapabilities(root)) {\n    if (\"selectionStart\" in root)\n      var JSCompiler_temp = {\n        start: root.selectionStart,\n        end: root.selectionEnd\n      };\n    else\n      a: {\n        JSCompiler_temp =\n          ((JSCompiler_temp = root.ownerDocument) &&\n            JSCompiler_temp.defaultView) ||\n          window;\n        var selection =\n          JSCompiler_temp.getSelection && JSCompiler_temp.getSelection();\n        if (selection && 0 !== selection.rangeCount) {\n          JSCompiler_temp = selection.anchorNode;\n          var anchorOffset = selection.anchorOffset,\n            focusNode = selection.focusNode;\n          selection = selection.focusOffset;\n          try {\n            JSCompiler_temp.nodeType, focusNode.nodeType;\n          } catch (e$20) {\n            JSCompiler_temp = null;\n            break a;\n          }\n          var length = 0,\n            start = -1,\n            end = -1,\n            indexWithinAnchor = 0,\n            indexWithinFocus = 0,\n            node = root,\n            parentNode = null;\n          b: for (;;) {\n            for (var next; ; ) {\n              node !== JSCompiler_temp ||\n                (0 !== anchorOffset && 3 !== node.nodeType) ||\n                (start = length + anchorOffset);\n              node !== focusNode ||\n                (0 !== selection && 3 !== node.nodeType) ||\n                (end = length + selection);\n              3 === node.nodeType && (length += node.nodeValue.length);\n              if (null === (next = node.firstChild)) break;\n              parentNode = node;\n              node = next;\n            }\n            for (;;) {\n              if (node === root) break b;\n              parentNode === JSCompiler_temp &&\n                ++indexWithinAnchor === anchorOffset &&\n                (start = length);\n              parentNode === focusNode &&\n                ++indexWithinFocus === selection &&\n                (end = length);\n              if (null !== (next = node.nextSibling)) break;\n              node = parentNode;\n              parentNode = node.parentNode;\n            }\n            node = next;\n          }\n          JSCompiler_temp =\n            -1 === start || -1 === end ? null : { start: start, end: end };\n        } else JSCompiler_temp = null;\n      }\n    JSCompiler_temp = JSCompiler_temp || { start: 0, end: 0 };\n  } else JSCompiler_temp = null;\n  selectionInformation = { focusedElem: root, selectionRange: JSCompiler_temp };\n  _enabled = !1;\n  for (nextEffect = firstChild; null !== nextEffect; )\n    if (\n      ((firstChild = nextEffect),\n      (root = firstChild.child),\n      0 !== (firstChild.subtreeFlags & 1024) && null !== root)\n    )\n      (root.return = firstChild), (nextEffect = root);\n    else\n      for (; null !== nextEffect; ) {\n        firstChild = nextEffect;\n        focusNode = firstChild.alternate;\n        root = firstChild.flags;\n        switch (firstChild.tag) {\n          case 0:\n            break;\n          case 11:\n          case 15:\n            break;\n          case 1:\n            if (0 !== (root & 1024) && null !== focusNode) {\n              root = void 0;\n              JSCompiler_temp = firstChild;\n              anchorOffset = focusNode.memoizedProps;\n              focusNode = focusNode.memoizedState;\n              selection = JSCompiler_temp.stateNode;\n              try {\n                var resolvedPrevProps = resolveClassComponentProps(\n                  JSCompiler_temp.type,\n                  anchorOffset,\n                  JSCompiler_temp.elementType === JSCompiler_temp.type\n                );\n                root = selection.getSnapshotBeforeUpdate(\n                  resolvedPrevProps,\n                  focusNode\n                );\n                selection.__reactInternalSnapshotBeforeUpdate = root;\n              } catch (error) {\n                captureCommitPhaseError(\n                  JSCompiler_temp,\n                  JSCompiler_temp.return,\n                  error\n                );\n              }\n            }\n            break;\n          case 3:\n            if (0 !== (root & 1024))\n              if (\n                ((root = firstChild.stateNode.containerInfo),\n                (JSCompiler_temp = root.nodeType),\n                9 === JSCompiler_temp)\n              )\n                clearContainerSparingly(root);\n              else if (1 === JSCompiler_temp)\n                switch (root.nodeName) {\n                  case \"HEAD\":\n                  case \"HTML\":\n                  case \"BODY\":\n                    clearContainerSparingly(root);\n                    break;\n                  default:\n                    root.textContent = \"\";\n                }\n            break;\n          case 5:\n          case 26:\n          case 27:\n          case 6:\n          case 4:\n          case 17:\n            break;\n          default:\n            if (0 !== (root & 1024)) throw Error(formatProdErrorMessage(163));\n        }\n        root = firstChild.sibling;\n        if (null !== root) {\n          root.return = firstChild.return;\n          nextEffect = root;\n          break;\n        }\n        nextEffect = firstChild.return;\n      }\n}\nfunction commitLayoutEffectOnFiber(finishedRoot, current, finishedWork) {\n  var flags = finishedWork.flags;\n  switch (finishedWork.tag) {\n    case 0:\n    case 11:\n    case 15:\n      recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);\n      flags & 4 && commitHookEffectListMount(5, finishedWork);\n      break;\n    case 1:\n      recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);\n      if (flags & 4)\n        if (((finishedRoot = finishedWork.stateNode), null === current))\n          try {\n            finishedRoot.componentDidMount();\n          } catch (error) {\n            captureCommitPhaseError(finishedWork, finishedWork.return, error);\n          }\n        else {\n          var prevProps = resolveClassComponentProps(\n            finishedWork.type,\n            current.memoizedProps\n          );\n          current = current.memoizedState;\n          try {\n            finishedRoot.componentDidUpdate(\n              prevProps,\n              current,\n              finishedRoot.__reactInternalSnapshotBeforeUpdate\n            );\n          } catch (error$142) {\n            captureCommitPhaseError(\n              finishedWork,\n              finishedWork.return,\n              error$142\n            );\n          }\n        }\n      flags & 64 && commitClassCallbacks(finishedWork);\n      flags & 512 && safelyAttachRef(finishedWork, finishedWork.return);\n      break;\n    case 3:\n      recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);\n      if (\n        flags & 64 &&\n        ((finishedRoot = finishedWork.updateQueue), null !== finishedRoot)\n      ) {\n        current = null;\n        if (null !== finishedWork.child)\n          switch (finishedWork.child.tag) {\n            case 27:\n            case 5:\n              current = finishedWork.child.stateNode;\n              break;\n            case 1:\n              current = finishedWork.child.stateNode;\n          }\n        try {\n          commitCallbacks(finishedRoot, current);\n        } catch (error) {\n          captureCommitPhaseError(finishedWork, finishedWork.return, error);\n        }\n      }\n      break;\n    case 27:\n      null === current &&\n        flags & 4 &&\n        commitHostSingletonAcquisition(finishedWork);\n    case 26:\n    case 5:\n      recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);\n      null === current && flags & 4 && commitHostMount(finishedWork);\n      flags & 512 && safelyAttachRef(finishedWork, finishedWork.return);\n      break;\n    case 12:\n      recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);\n      break;\n    case 13:\n      recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);\n      flags & 4 && commitSuspenseHydrationCallbacks(finishedRoot, finishedWork);\n      flags & 64 &&\n        ((finishedRoot = finishedWork.memoizedState),\n        null !== finishedRoot &&\n          ((finishedRoot = finishedRoot.dehydrated),\n          null !== finishedRoot &&\n            ((finishedWork = retryDehydratedSuspenseBoundary.bind(\n              null,\n              finishedWork\n            )),\n            registerSuspenseInstanceRetry(finishedRoot, finishedWork))));\n      break;\n    case 22:\n      flags = null !== finishedWork.memoizedState || offscreenSubtreeIsHidden;\n      if (!flags) {\n        current =\n          (null !== current && null !== current.memoizedState) ||\n          offscreenSubtreeWasHidden;\n        prevProps = offscreenSubtreeIsHidden;\n        var prevOffscreenSubtreeWasHidden = offscreenSubtreeWasHidden;\n        offscreenSubtreeIsHidden = flags;\n        (offscreenSubtreeWasHidden = current) && !prevOffscreenSubtreeWasHidden\n          ? recursivelyTraverseReappearLayoutEffects(\n              finishedRoot,\n              finishedWork,\n              0 !== (finishedWork.subtreeFlags & 8772)\n            )\n          : recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);\n        offscreenSubtreeIsHidden = prevProps;\n        offscreenSubtreeWasHidden = prevOffscreenSubtreeWasHidden;\n      }\n      break;\n    case 30:\n      break;\n    default:\n      recursivelyTraverseLayoutEffects(finishedRoot, finishedWork);\n  }\n}\nfunction detachFiberAfterEffects(fiber) {\n  var alternate = fiber.alternate;\n  null !== alternate &&\n    ((fiber.alternate = null), detachFiberAfterEffects(alternate));\n  fiber.child = null;\n  fiber.deletions = null;\n  fiber.sibling = null;\n  5 === fiber.tag &&\n    ((alternate = fiber.stateNode),\n    null !== alternate && detachDeletedInstance(alternate));\n  fiber.stateNode = null;\n  fiber.return = null;\n  fiber.dependencies = null;\n  fiber.memoizedProps = null;\n  fiber.memoizedState = null;\n  fiber.pendingProps = null;\n  fiber.stateNode = null;\n  fiber.updateQueue = null;\n}\nvar hostParent = null,\n  hostParentIsContainer = !1;\nfunction recursivelyTraverseDeletionEffects(\n  finishedRoot,\n  nearestMountedAncestor,\n  parent\n) {\n  for (parent = parent.child; null !== parent; )\n    commitDeletionEffectsOnFiber(finishedRoot, nearestMountedAncestor, parent),\n      (parent = parent.sibling);\n}\nfunction commitDeletionEffectsOnFiber(\n  finishedRoot,\n  nearestMountedAncestor,\n  deletedFiber\n) {\n  if (injectedHook && \"function\" === typeof injectedHook.onCommitFiberUnmount)\n    try {\n      injectedHook.onCommitFiberUnmount(rendererID, deletedFiber);\n    } catch (err) {}\n  switch (deletedFiber.tag) {\n    case 26:\n      offscreenSubtreeWasHidden ||\n        safelyDetachRef(deletedFiber, nearestMountedAncestor);\n      recursivelyTraverseDeletionEffects(\n        finishedRoot,\n        nearestMountedAncestor,\n        deletedFiber\n      );\n      deletedFiber.memoizedState\n        ? deletedFiber.memoizedState.count--\n        : deletedFiber.stateNode &&\n          ((deletedFiber = deletedFiber.stateNode),\n          deletedFiber.parentNode.removeChild(deletedFiber));\n      break;\n    case 27:\n      offscreenSubtreeWasHidden ||\n        safelyDetachRef(deletedFiber, nearestMountedAncestor);\n      var prevHostParent = hostParent,\n        prevHostParentIsContainer = hostParentIsContainer;\n      isSingletonScope(deletedFiber.type) &&\n        ((hostParent = deletedFiber.stateNode), (hostParentIsContainer = !1));\n      recursivelyTraverseDeletionEffects(\n        finishedRoot,\n        nearestMountedAncestor,\n        deletedFiber\n      );\n      releaseSingletonInstance(deletedFiber.stateNode);\n      hostParent = prevHostParent;\n      hostParentIsContainer = prevHostParentIsContainer;\n      break;\n    case 5:\n      offscreenSubtreeWasHidden ||\n        safelyDetachRef(deletedFiber, nearestMountedAncestor);\n    case 6:\n      prevHostParent = hostParent;\n      prevHostParentIsContainer = hostParentIsContainer;\n      hostParent = null;\n      recursivelyTraverseDeletionEffects(\n        finishedRoot,\n        nearestMountedAncestor,\n        deletedFiber\n      );\n      hostParent = prevHostParent;\n      hostParentIsContainer = prevHostParentIsContainer;\n      if (null !== hostParent)\n        if (hostParentIsContainer)\n          try {\n            (9 === hostParent.nodeType\n              ? hostParent.body\n              : \"HTML\" === hostParent.nodeName\n                ? hostParent.ownerDocument.body\n                : hostParent\n            ).removeChild(deletedFiber.stateNode);\n          } catch (error) {\n            captureCommitPhaseError(\n              deletedFiber,\n              nearestMountedAncestor,\n              error\n            );\n          }\n        else\n          try {\n            hostParent.removeChild(deletedFiber.stateNode);\n          } catch (error) {\n            captureCommitPhaseError(\n              deletedFiber,\n              nearestMountedAncestor,\n              error\n            );\n          }\n      break;\n    case 18:\n      null !== hostParent &&\n        (hostParentIsContainer\n          ? ((finishedRoot = hostParent),\n            clearSuspenseBoundary(\n              9 === finishedRoot.nodeType\n                ? finishedRoot.body\n                : \"HTML\" === finishedRoot.nodeName\n                  ? finishedRoot.ownerDocument.body\n                  : finishedRoot,\n              deletedFiber.stateNode\n            ),\n            retryIfBlockedOn(finishedRoot))\n          : clearSuspenseBoundary(hostParent, deletedFiber.stateNode));\n      break;\n    case 4:\n      prevHostParent = hostParent;\n      prevHostParentIsContainer = hostParentIsContainer;\n      hostParent = deletedFiber.stateNode.containerInfo;\n      hostParentIsContainer = !0;\n      recursivelyTraverseDeletionEffects(\n        finishedRoot,\n        nearestMountedAncestor,\n        deletedFiber\n      );\n      hostParent = prevHostParent;\n      hostParentIsContainer = prevHostParentIsContainer;\n      break;\n    case 0:\n    case 11:\n    case 14:\n    case 15:\n      offscreenSubtreeWasHidden ||\n        commitHookEffectListUnmount(2, deletedFiber, nearestMountedAncestor);\n      offscreenSubtreeWasHidden ||\n        commitHookEffectListUnmount(4, deletedFiber, nearestMountedAncestor);\n      recursivelyTraverseDeletionEffects(\n        finishedRoot,\n        nearestMountedAncestor,\n        deletedFiber\n      );\n      break;\n    case 1:\n      offscreenSubtreeWasHidden ||\n        (safelyDetachRef(deletedFiber, nearestMountedAncestor),\n        (prevHostParent = deletedFiber.stateNode),\n        \"function\" === typeof prevHostParent.componentWillUnmount &&\n          safelyCallComponentWillUnmount(\n            deletedFiber,\n            nearestMountedAncestor,\n            prevHostParent\n          ));\n      recursivelyTraverseDeletionEffects(\n        finishedRoot,\n        nearestMountedAncestor,\n        deletedFiber\n      );\n      break;\n    case 21:\n      recursivelyTraverseDeletionEffects(\n        finishedRoot,\n        nearestMountedAncestor,\n        deletedFiber\n      );\n      break;\n    case 22:\n      offscreenSubtreeWasHidden =\n        (prevHostParent = offscreenSubtreeWasHidden) ||\n        null !== deletedFiber.memoizedState;\n      recursivelyTraverseDeletionEffects(\n        finishedRoot,\n        nearestMountedAncestor,\n        deletedFiber\n      );\n      offscreenSubtreeWasHidden = prevHostParent;\n      break;\n    default:\n      recursivelyTraverseDeletionEffects(\n        finishedRoot,\n        nearestMountedAncestor,\n        deletedFiber\n      );\n  }\n}\nfunction commitSuspenseHydrationCallbacks(finishedRoot, finishedWork) {\n  if (\n    null === finishedWork.memoizedState &&\n    ((finishedRoot = finishedWork.alternate),\n    null !== finishedRoot &&\n      ((finishedRoot = finishedRoot.memoizedState),\n      null !== finishedRoot &&\n        ((finishedRoot = finishedRoot.dehydrated), null !== finishedRoot)))\n  )\n    try {\n      retryIfBlockedOn(finishedRoot);\n    } catch (error) {\n      captureCommitPhaseError(finishedWork, finishedWork.return, error);\n    }\n}\nfunction getRetryCache(finishedWork) {\n  switch (finishedWork.tag) {\n    case 13:\n    case 19:\n      var retryCache = finishedWork.stateNode;\n      null === retryCache &&\n        (retryCache = finishedWork.stateNode = new PossiblyWeakSet());\n      return retryCache;\n    case 22:\n      return (\n        (finishedWork = finishedWork.stateNode),\n        (retryCache = finishedWork._retryCache),\n        null === retryCache &&\n          (retryCache = finishedWork._retryCache = new PossiblyWeakSet()),\n        retryCache\n      );\n    default:\n      throw Error(formatProdErrorMessage(435, finishedWork.tag));\n  }\n}\nfunction attachSuspenseRetryListeners(finishedWork, wakeables) {\n  var retryCache = getRetryCache(finishedWork);\n  wakeables.forEach(function (wakeable) {\n    var retry = resolveRetryWakeable.bind(null, finishedWork, wakeable);\n    retryCache.has(wakeable) ||\n      (retryCache.add(wakeable), wakeable.then(retry, retry));\n  });\n}\nfunction recursivelyTraverseMutationEffects(root$jscomp$0, parentFiber) {\n  var deletions = parentFiber.deletions;\n  if (null !== deletions)\n    for (var i = 0; i < deletions.length; i++) {\n      var childToDelete = deletions[i],\n        root = root$jscomp$0,\n        returnFiber = parentFiber,\n        parent = returnFiber;\n      a: for (; null !== parent; ) {\n        switch (parent.tag) {\n          case 27:\n            if (isSingletonScope(parent.type)) {\n              hostParent = parent.stateNode;\n              hostParentIsContainer = !1;\n              break a;\n            }\n            break;\n          case 5:\n            hostParent = parent.stateNode;\n            hostParentIsContainer = !1;\n            break a;\n          case 3:\n          case 4:\n            hostParent = parent.stateNode.containerInfo;\n            hostParentIsContainer = !0;\n            break a;\n        }\n        parent = parent.return;\n      }\n      if (null === hostParent) throw Error(formatProdErrorMessage(160));\n      commitDeletionEffectsOnFiber(root, returnFiber, childToDelete);\n      hostParent = null;\n      hostParentIsContainer = !1;\n      root = childToDelete.alternate;\n      null !== root && (root.return = null);\n      childToDelete.return = null;\n    }\n  if (parentFiber.subtreeFlags & 13878)\n    for (parentFiber = parentFiber.child; null !== parentFiber; )\n      commitMutationEffectsOnFiber(parentFiber, root$jscomp$0),\n        (parentFiber = parentFiber.sibling);\n}\nvar currentHoistableRoot = null;\nfunction commitMutationEffectsOnFiber(finishedWork, root) {\n  var current = finishedWork.alternate,\n    flags = finishedWork.flags;\n  switch (finishedWork.tag) {\n    case 0:\n    case 11:\n    case 14:\n    case 15:\n      recursivelyTraverseMutationEffects(root, finishedWork);\n      commitReconciliationEffects(finishedWork);\n      flags & 4 &&\n        (commitHookEffectListUnmount(3, finishedWork, finishedWork.return),\n        commitHookEffectListMount(3, finishedWork),\n        commitHookEffectListUnmount(5, finishedWork, finishedWork.return));\n      break;\n    case 1:\n      recursivelyTraverseMutationEffects(root, finishedWork);\n      commitReconciliationEffects(finishedWork);\n      flags & 512 &&\n        (offscreenSubtreeWasHidden ||\n          null === current ||\n          safelyDetachRef(current, current.return));\n      flags & 64 &&\n        offscreenSubtreeIsHidden &&\n        ((finishedWork = finishedWork.updateQueue),\n        null !== finishedWork &&\n          ((flags = finishedWork.callbacks),\n          null !== flags &&\n            ((current = finishedWork.shared.hiddenCallbacks),\n            (finishedWork.shared.hiddenCallbacks =\n              null === current ? flags : current.concat(flags)))));\n      break;\n    case 26:\n      var hoistableRoot = currentHoistableRoot;\n      recursivelyTraverseMutationEffects(root, finishedWork);\n      commitReconciliationEffects(finishedWork);\n      flags & 512 &&\n        (offscreenSubtreeWasHidden ||\n          null === current ||\n          safelyDetachRef(current, current.return));\n      if (flags & 4) {\n        var currentResource = null !== current ? current.memoizedState : null;\n        flags = finishedWork.memoizedState;\n        if (null === current)\n          if (null === flags)\n            if (null === finishedWork.stateNode) {\n              a: {\n                flags = finishedWork.type;\n                current = finishedWork.memoizedProps;\n                hoistableRoot = hoistableRoot.ownerDocument || hoistableRoot;\n                b: switch (flags) {\n                  case \"title\":\n                    currentResource =\n                      hoistableRoot.getElementsByTagName(\"title\")[0];\n                    if (\n                      !currentResource ||\n                      currentResource[internalHoistableMarker] ||\n                      currentResource[internalInstanceKey] ||\n                      \"http://www.w3.org/2000/svg\" ===\n                        currentResource.namespaceURI ||\n                      currentResource.hasAttribute(\"itemprop\")\n                    )\n                      (currentResource = hoistableRoot.createElement(flags)),\n                        hoistableRoot.head.insertBefore(\n                          currentResource,\n                          hoistableRoot.querySelector(\"head > title\")\n                        );\n                    setInitialProperties(currentResource, flags, current);\n                    currentResource[internalInstanceKey] = finishedWork;\n                    markNodeAsHoistable(currentResource);\n                    flags = currentResource;\n                    break a;\n                  case \"link\":\n                    var maybeNodes = getHydratableHoistableCache(\n                      \"link\",\n                      \"href\",\n                      hoistableRoot\n                    ).get(flags + (current.href || \"\"));\n                    if (maybeNodes)\n                      for (var i = 0; i < maybeNodes.length; i++)\n                        if (\n                          ((currentResource = maybeNodes[i]),\n                          currentResource.getAttribute(\"href\") ===\n                            (null == current.href || \"\" === current.href\n                              ? null\n                              : current.href) &&\n                            currentResource.getAttribute(\"rel\") ===\n                              (null == current.rel ? null : current.rel) &&\n                            currentResource.getAttribute(\"title\") ===\n                              (null == current.title ? null : current.title) &&\n                            currentResource.getAttribute(\"crossorigin\") ===\n                              (null == current.crossOrigin\n                                ? null\n                                : current.crossOrigin))\n                        ) {\n                          maybeNodes.splice(i, 1);\n                          break b;\n                        }\n                    currentResource = hoistableRoot.createElement(flags);\n                    setInitialProperties(currentResource, flags, current);\n                    hoistableRoot.head.appendChild(currentResource);\n                    break;\n                  case \"meta\":\n                    if (\n                      (maybeNodes = getHydratableHoistableCache(\n                        \"meta\",\n                        \"content\",\n                        hoistableRoot\n                      ).get(flags + (current.content || \"\")))\n                    )\n                      for (i = 0; i < maybeNodes.length; i++)\n                        if (\n                          ((currentResource = maybeNodes[i]),\n                          currentResource.getAttribute(\"content\") ===\n                            (null == current.content\n                              ? null\n                              : \"\" + current.content) &&\n                            currentResource.getAttribute(\"name\") ===\n                              (null == current.name ? null : current.name) &&\n                            currentResource.getAttribute(\"property\") ===\n                              (null == current.property\n                                ? null\n                                : current.property) &&\n                            currentResource.getAttribute(\"http-equiv\") ===\n                              (null == current.httpEquiv\n                                ? null\n                                : current.httpEquiv) &&\n                            currentResource.getAttribute(\"charset\") ===\n                              (null == current.charSet\n                                ? null\n                                : current.charSet))\n                        ) {\n                          maybeNodes.splice(i, 1);\n                          break b;\n                        }\n                    currentResource = hoistableRoot.createElement(flags);\n                    setInitialProperties(currentResource, flags, current);\n                    hoistableRoot.head.appendChild(currentResource);\n                    break;\n                  default:\n                    throw Error(formatProdErrorMessage(468, flags));\n                }\n                currentResource[internalInstanceKey] = finishedWork;\n                markNodeAsHoistable(currentResource);\n                flags = currentResource;\n              }\n              finishedWork.stateNode = flags;\n            } else\n              mountHoistable(\n                hoistableRoot,\n                finishedWork.type,\n                finishedWork.stateNode\n              );\n          else\n            finishedWork.stateNode = acquireResource(\n              hoistableRoot,\n              flags,\n              finishedWork.memoizedProps\n            );\n        else\n          currentResource !== flags\n            ? (null === currentResource\n                ? null !== current.stateNode &&\n                  ((current = current.stateNode),\n                  current.parentNode.removeChild(current))\n                : currentResource.count--,\n              null === flags\n                ? mountHoistable(\n                    hoistableRoot,\n                    finishedWork.type,\n                    finishedWork.stateNode\n                  )\n                : acquireResource(\n                    hoistableRoot,\n                    flags,\n                    finishedWork.memoizedProps\n                  ))\n            : null === flags &&\n              null !== finishedWork.stateNode &&\n              commitHostUpdate(\n                finishedWork,\n                finishedWork.memoizedProps,\n                current.memoizedProps\n              );\n      }\n      break;\n    case 27:\n      recursivelyTraverseMutationEffects(root, finishedWork);\n      commitReconciliationEffects(finishedWork);\n      flags & 512 &&\n        (offscreenSubtreeWasHidden ||\n          null === current ||\n          safelyDetachRef(current, current.return));\n      null !== current &&\n        flags & 4 &&\n        commitHostUpdate(\n          finishedWork,\n          finishedWork.memoizedProps,\n          current.memoizedProps\n        );\n      break;\n    case 5:\n      recursivelyTraverseMutationEffects(root, finishedWork);\n      commitReconciliationEffects(finishedWork);\n      flags & 512 &&\n        (offscreenSubtreeWasHidden ||\n          null === current ||\n          safelyDetachRef(current, current.return));\n      if (finishedWork.flags & 32) {\n        hoistableRoot = finishedWork.stateNode;\n        try {\n          setTextContent(hoistableRoot, \"\");\n        } catch (error) {\n          captureCommitPhaseError(finishedWork, finishedWork.return, error);\n        }\n      }\n      flags & 4 &&\n        null != finishedWork.stateNode &&\n        ((hoistableRoot = finishedWork.memoizedProps),\n        commitHostUpdate(\n          finishedWork,\n          hoistableRoot,\n          null !== current ? current.memoizedProps : hoistableRoot\n        ));\n      flags & 1024 && (needsFormReset = !0);\n      break;\n    case 6:\n      recursivelyTraverseMutationEffects(root, finishedWork);\n      commitReconciliationEffects(finishedWork);\n      if (flags & 4) {\n        if (null === finishedWork.stateNode)\n          throw Error(formatProdErrorMessage(162));\n        flags = finishedWork.memoizedProps;\n        current = finishedWork.stateNode;\n        try {\n          current.nodeValue = flags;\n        } catch (error) {\n          captureCommitPhaseError(finishedWork, finishedWork.return, error);\n        }\n      }\n      break;\n    case 3:\n      tagCaches = null;\n      hoistableRoot = currentHoistableRoot;\n      currentHoistableRoot = getHoistableRoot(root.containerInfo);\n      recursivelyTraverseMutationEffects(root, finishedWork);\n      currentHoistableRoot = hoistableRoot;\n      commitReconciliationEffects(finishedWork);\n      if (flags & 4 && null !== current && current.memoizedState.isDehydrated)\n        try {\n          retryIfBlockedOn(root.containerInfo);\n        } catch (error) {\n          captureCommitPhaseError(finishedWork, finishedWork.return, error);\n        }\n      needsFormReset &&\n        ((needsFormReset = !1), recursivelyResetForms(finishedWork));\n      break;\n    case 4:\n      flags = currentHoistableRoot;\n      currentHoistableRoot = getHoistableRoot(\n        finishedWork.stateNode.containerInfo\n      );\n      recursivelyTraverseMutationEffects(root, finishedWork);\n      commitReconciliationEffects(finishedWork);\n      currentHoistableRoot = flags;\n      break;\n    case 12:\n      recursivelyTraverseMutationEffects(root, finishedWork);\n      commitReconciliationEffects(finishedWork);\n      break;\n    case 13:\n      recursivelyTraverseMutationEffects(root, finishedWork);\n      commitReconciliationEffects(finishedWork);\n      finishedWork.child.flags & 8192 &&\n        (null !== finishedWork.memoizedState) !==\n          (null !== current && null !== current.memoizedState) &&\n        (globalMostRecentFallbackTime = now());\n      flags & 4 &&\n        ((flags = finishedWork.updateQueue),\n        null !== flags &&\n          ((finishedWork.updateQueue = null),\n          attachSuspenseRetryListeners(finishedWork, flags)));\n      break;\n    case 22:\n      hoistableRoot = null !== finishedWork.memoizedState;\n      var wasHidden = null !== current && null !== current.memoizedState,\n        prevOffscreenSubtreeIsHidden = offscreenSubtreeIsHidden,\n        prevOffscreenSubtreeWasHidden = offscreenSubtreeWasHidden;\n      offscreenSubtreeIsHidden = prevOffscreenSubtreeIsHidden || hoistableRoot;\n      offscreenSubtreeWasHidden = prevOffscreenSubtreeWasHidden || wasHidden;\n      recursivelyTraverseMutationEffects(root, finishedWork);\n      offscreenSubtreeWasHidden = prevOffscreenSubtreeWasHidden;\n      offscreenSubtreeIsHidden = prevOffscreenSubtreeIsHidden;\n      commitReconciliationEffects(finishedWork);\n      if (flags & 8192)\n        a: for (\n          root = finishedWork.stateNode,\n            root._visibility = hoistableRoot\n              ? root._visibility & -2\n              : root._visibility | 1,\n            hoistableRoot &&\n              (null === current ||\n                wasHidden ||\n                offscreenSubtreeIsHidden ||\n                offscreenSubtreeWasHidden ||\n                recursivelyTraverseDisappearLayoutEffects(finishedWork)),\n            current = null,\n            root = finishedWork;\n          ;\n\n        ) {\n          if (5 === root.tag || 26 === root.tag) {\n            if (null === current) {\n              wasHidden = current = root;\n              try {\n                if (((currentResource = wasHidden.stateNode), hoistableRoot))\n                  (maybeNodes = currentResource.style),\n                    \"function\" === typeof maybeNodes.setProperty\n                      ? maybeNodes.setProperty(\"display\", \"none\", \"important\")\n                      : (maybeNodes.display = \"none\");\n                else {\n                  i = wasHidden.stateNode;\n                  var styleProp = wasHidden.memoizedProps.style,\n                    display =\n                      void 0 !== styleProp &&\n                      null !== styleProp &&\n                      styleProp.hasOwnProperty(\"display\")\n                        ? styleProp.display\n                        : null;\n                  i.style.display =\n                    null == display || \"boolean\" === typeof display\n                      ? \"\"\n                      : (\"\" + display).trim();\n                }\n              } catch (error) {\n                captureCommitPhaseError(wasHidden, wasHidden.return, error);\n              }\n            }\n          } else if (6 === root.tag) {\n            if (null === current) {\n              wasHidden = root;\n              try {\n                wasHidden.stateNode.nodeValue = hoistableRoot\n                  ? \"\"\n                  : wasHidden.memoizedProps;\n              } catch (error) {\n                captureCommitPhaseError(wasHidden, wasHidden.return, error);\n              }\n            }\n          } else if (\n            ((22 !== root.tag && 23 !== root.tag) ||\n              null === root.memoizedState ||\n              root === finishedWork) &&\n            null !== root.child\n          ) {\n            root.child.return = root;\n            root = root.child;\n            continue;\n          }\n          if (root === finishedWork) break a;\n          for (; null === root.sibling; ) {\n            if (null === root.return || root.return === finishedWork) break a;\n            current === root && (current = null);\n            root = root.return;\n          }\n          current === root && (current = null);\n          root.sibling.return = root.return;\n          root = root.sibling;\n        }\n      flags & 4 &&\n        ((flags = finishedWork.updateQueue),\n        null !== flags &&\n          ((current = flags.retryQueue),\n          null !== current &&\n            ((flags.retryQueue = null),\n            attachSuspenseRetryListeners(finishedWork, current))));\n      break;\n    case 19:\n      recursivelyTraverseMutationEffects(root, finishedWork);\n      commitReconciliationEffects(finishedWork);\n      flags & 4 &&\n        ((flags = finishedWork.updateQueue),\n        null !== flags &&\n          ((finishedWork.updateQueue = null),\n          attachSuspenseRetryListeners(finishedWork, flags)));\n      break;\n    case 30:\n      break;\n    case 21:\n      break;\n    default:\n      recursivelyTraverseMutationEffects(root, finishedWork),\n        commitReconciliationEffects(finishedWork);\n  }\n}\nfunction commitReconciliationEffects(finishedWork) {\n  var flags = finishedWork.flags;\n  if (flags & 2) {\n    try {\n      for (\n        var hostParentFiber, parentFiber = finishedWork.return;\n        null !== parentFiber;\n\n      ) {\n        if (isHostParent(parentFiber)) {\n          hostParentFiber = parentFiber;\n          break;\n        }\n        parentFiber = parentFiber.return;\n      }\n      if (null == hostParentFiber) throw Error(formatProdErrorMessage(160));\n      switch (hostParentFiber.tag) {\n        case 27:\n          var parent = hostParentFiber.stateNode,\n            before = getHostSibling(finishedWork);\n          insertOrAppendPlacementNode(finishedWork, before, parent);\n          break;\n        case 5:\n          var parent$144 = hostParentFiber.stateNode;\n          hostParentFiber.flags & 32 &&\n            (setTextContent(parent$144, \"\"), (hostParentFiber.flags &= -33));\n          var before$145 = getHostSibling(finishedWork);\n          insertOrAppendPlacementNode(finishedWork, before$145, parent$144);\n          break;\n        case 3:\n        case 4:\n          var parent$146 = hostParentFiber.stateNode.containerInfo,\n            before$147 = getHostSibling(finishedWork);\n          insertOrAppendPlacementNodeIntoContainer(\n            finishedWork,\n            before$147,\n            parent$146\n          );\n          break;\n        default:\n          throw Error(formatProdErrorMessage(161));\n      }\n    } catch (error) {\n      captureCommitPhaseError(finishedWork, finishedWork.return, error);\n    }\n    finishedWork.flags &= -3;\n  }\n  flags & 4096 && (finishedWork.flags &= -4097);\n}\nfunction recursivelyResetForms(parentFiber) {\n  if (parentFiber.subtreeFlags & 1024)\n    for (parentFiber = parentFiber.child; null !== parentFiber; ) {\n      var fiber = parentFiber;\n      recursivelyResetForms(fiber);\n      5 === fiber.tag && fiber.flags & 1024 && fiber.stateNode.reset();\n      parentFiber = parentFiber.sibling;\n    }\n}\nfunction recursivelyTraverseLayoutEffects(root, parentFiber) {\n  if (parentFiber.subtreeFlags & 8772)\n    for (parentFiber = parentFiber.child; null !== parentFiber; )\n      commitLayoutEffectOnFiber(root, parentFiber.alternate, parentFiber),\n        (parentFiber = parentFiber.sibling);\n}\nfunction recursivelyTraverseDisappearLayoutEffects(parentFiber) {\n  for (parentFiber = parentFiber.child; null !== parentFiber; ) {\n    var finishedWork = parentFiber;\n    switch (finishedWork.tag) {\n      case 0:\n      case 11:\n      case 14:\n      case 15:\n        commitHookEffectListUnmount(4, finishedWork, finishedWork.return);\n        recursivelyTraverseDisappearLayoutEffects(finishedWork);\n        break;\n      case 1:\n        safelyDetachRef(finishedWork, finishedWork.return);\n        var instance = finishedWork.stateNode;\n        \"function\" === typeof instance.componentWillUnmount &&\n          safelyCallComponentWillUnmount(\n            finishedWork,\n            finishedWork.return,\n            instance\n          );\n        recursivelyTraverseDisappearLayoutEffects(finishedWork);\n        break;\n      case 27:\n        releaseSingletonInstance(finishedWork.stateNode);\n      case 26:\n      case 5:\n        safelyDetachRef(finishedWork, finishedWork.return);\n        recursivelyTraverseDisappearLayoutEffects(finishedWork);\n        break;\n      case 22:\n        null === finishedWork.memoizedState &&\n          recursivelyTraverseDisappearLayoutEffects(finishedWork);\n        break;\n      case 30:\n        recursivelyTraverseDisappearLayoutEffects(finishedWork);\n        break;\n      default:\n        recursivelyTraverseDisappearLayoutEffects(finishedWork);\n    }\n    parentFiber = parentFiber.sibling;\n  }\n}\nfunction recursivelyTraverseReappearLayoutEffects(\n  finishedRoot$jscomp$0,\n  parentFiber,\n  includeWorkInProgressEffects\n) {\n  includeWorkInProgressEffects =\n    includeWorkInProgressEffects && 0 !== (parentFiber.subtreeFlags & 8772);\n  for (parentFiber = parentFiber.child; null !== parentFiber; ) {\n    var current = parentFiber.alternate,\n      finishedRoot = finishedRoot$jscomp$0,\n      finishedWork = parentFiber,\n      flags = finishedWork.flags;\n    switch (finishedWork.tag) {\n      case 0:\n      case 11:\n      case 15:\n        recursivelyTraverseReappearLayoutEffects(\n          finishedRoot,\n          finishedWork,\n          includeWorkInProgressEffects\n        );\n        commitHookEffectListMount(4, finishedWork);\n        break;\n      case 1:\n        recursivelyTraverseReappearLayoutEffects(\n          finishedRoot,\n          finishedWork,\n          includeWorkInProgressEffects\n        );\n        current = finishedWork;\n        finishedRoot = current.stateNode;\n        if (\"function\" === typeof finishedRoot.componentDidMount)\n          try {\n            finishedRoot.componentDidMount();\n          } catch (error) {\n            captureCommitPhaseError(current, current.return, error);\n          }\n        current = finishedWork;\n        finishedRoot = current.updateQueue;\n        if (null !== finishedRoot) {\n          var instance = current.stateNode;\n          try {\n            var hiddenCallbacks = finishedRoot.shared.hiddenCallbacks;\n            if (null !== hiddenCallbacks)\n              for (\n                finishedRoot.shared.hiddenCallbacks = null, finishedRoot = 0;\n                finishedRoot < hiddenCallbacks.length;\n                finishedRoot++\n              )\n                callCallback(hiddenCallbacks[finishedRoot], instance);\n          } catch (error) {\n            captureCommitPhaseError(current, current.return, error);\n          }\n        }\n        includeWorkInProgressEffects &&\n          flags & 64 &&\n          commitClassCallbacks(finishedWork);\n        safelyAttachRef(finishedWork, finishedWork.return);\n        break;\n      case 27:\n        commitHostSingletonAcquisition(finishedWork);\n      case 26:\n      case 5:\n        recursivelyTraverseReappearLayoutEffects(\n          finishedRoot,\n          finishedWork,\n          includeWorkInProgressEffects\n        );\n        includeWorkInProgressEffects &&\n          null === current &&\n          flags & 4 &&\n          commitHostMount(finishedWork);\n        safelyAttachRef(finishedWork, finishedWork.return);\n        break;\n      case 12:\n        recursivelyTraverseReappearLayoutEffects(\n          finishedRoot,\n          finishedWork,\n          includeWorkInProgressEffects\n        );\n        break;\n      case 13:\n        recursivelyTraverseReappearLayoutEffects(\n          finishedRoot,\n          finishedWork,\n          includeWorkInProgressEffects\n        );\n        includeWorkInProgressEffects &&\n          flags & 4 &&\n          commitSuspenseHydrationCallbacks(finishedRoot, finishedWork);\n        break;\n      case 22:\n        null === finishedWork.memoizedState &&\n          recursivelyTraverseReappearLayoutEffects(\n            finishedRoot,\n            finishedWork,\n            includeWorkInProgressEffects\n          );\n        safelyAttachRef(finishedWork, finishedWork.return);\n        break;\n      case 30:\n        break;\n      default:\n        recursivelyTraverseReappearLayoutEffects(\n          finishedRoot,\n          finishedWork,\n          includeWorkInProgressEffects\n        );\n    }\n    parentFiber = parentFiber.sibling;\n  }\n}\nfunction commitOffscreenPassiveMountEffects(current, finishedWork) {\n  var previousCache = null;\n  null !== current &&\n    null !== current.memoizedState &&\n    null !== current.memoizedState.cachePool &&\n    (previousCache = current.memoizedState.cachePool.pool);\n  current = null;\n  null !== finishedWork.memoizedState &&\n    null !== finishedWork.memoizedState.cachePool &&\n    (current = finishedWork.memoizedState.cachePool.pool);\n  current !== previousCache &&\n    (null != current && current.refCount++,\n    null != previousCache && releaseCache(previousCache));\n}\nfunction commitCachePassiveMountEffect(current, finishedWork) {\n  current = null;\n  null !== finishedWork.alternate &&\n    (current = finishedWork.alternate.memoizedState.cache);\n  finishedWork = finishedWork.memoizedState.cache;\n  finishedWork !== current &&\n    (finishedWork.refCount++, null != current && releaseCache(current));\n}\nfunction recursivelyTraversePassiveMountEffects(\n  root,\n  parentFiber,\n  committedLanes,\n  committedTransitions\n) {\n  if (parentFiber.subtreeFlags & 10256)\n    for (parentFiber = parentFiber.child; null !== parentFiber; )\n      commitPassiveMountOnFiber(\n        root,\n        parentFiber,\n        committedLanes,\n        committedTransitions\n      ),\n        (parentFiber = parentFiber.sibling);\n}\nfunction commitPassiveMountOnFiber(\n  finishedRoot,\n  finishedWork,\n  committedLanes,\n  committedTransitions\n) {\n  var flags = finishedWork.flags;\n  switch (finishedWork.tag) {\n    case 0:\n    case 11:\n    case 15:\n      recursivelyTraversePassiveMountEffects(\n        finishedRoot,\n        finishedWork,\n        committedLanes,\n        committedTransitions\n      );\n      flags & 2048 && commitHookEffectListMount(9, finishedWork);\n      break;\n    case 1:\n      recursivelyTraversePassiveMountEffects(\n        finishedRoot,\n        finishedWork,\n        committedLanes,\n        committedTransitions\n      );\n      break;\n    case 3:\n      recursivelyTraversePassiveMountEffects(\n        finishedRoot,\n        finishedWork,\n        committedLanes,\n        committedTransitions\n      );\n      flags & 2048 &&\n        ((finishedRoot = null),\n        null !== finishedWork.alternate &&\n          (finishedRoot = finishedWork.alternate.memoizedState.cache),\n        (finishedWork = finishedWork.memoizedState.cache),\n        finishedWork !== finishedRoot &&\n          (finishedWork.refCount++,\n          null != finishedRoot && releaseCache(finishedRoot)));\n      break;\n    case 12:\n      if (flags & 2048) {\n        recursivelyTraversePassiveMountEffects(\n          finishedRoot,\n          finishedWork,\n          committedLanes,\n          committedTransitions\n        );\n        finishedRoot = finishedWork.stateNode;\n        try {\n          var _finishedWork$memoize2 = finishedWork.memoizedProps,\n            id = _finishedWork$memoize2.id,\n            onPostCommit = _finishedWork$memoize2.onPostCommit;\n          \"function\" === typeof onPostCommit &&\n            onPostCommit(\n              id,\n              null === finishedWork.alternate ? \"mount\" : \"update\",\n              finishedRoot.passiveEffectDuration,\n              -0\n            );\n        } catch (error) {\n          captureCommitPhaseError(finishedWork, finishedWork.return, error);\n        }\n      } else\n        recursivelyTraversePassiveMountEffects(\n          finishedRoot,\n          finishedWork,\n          committedLanes,\n          committedTransitions\n        );\n      break;\n    case 13:\n      recursivelyTraversePassiveMountEffects(\n        finishedRoot,\n        finishedWork,\n        committedLanes,\n        committedTransitions\n      );\n      break;\n    case 23:\n      break;\n    case 22:\n      _finishedWork$memoize2 = finishedWork.stateNode;\n      id = finishedWork.alternate;\n      null !== finishedWork.memoizedState\n        ? _finishedWork$memoize2._visibility & 2\n          ? recursivelyTraversePassiveMountEffects(\n              finishedRoot,\n              finishedWork,\n              committedLanes,\n              committedTransitions\n            )\n          : recursivelyTraverseAtomicPassiveEffects(finishedRoot, finishedWork)\n        : _finishedWork$memoize2._visibility & 2\n          ? recursivelyTraversePassiveMountEffects(\n              finishedRoot,\n              finishedWork,\n              committedLanes,\n              committedTransitions\n            )\n          : ((_finishedWork$memoize2._visibility |= 2),\n            recursivelyTraverseReconnectPassiveEffects(\n              finishedRoot,\n              finishedWork,\n              committedLanes,\n              committedTransitions,\n              0 !== (finishedWork.subtreeFlags & 10256)\n            ));\n      flags & 2048 && commitOffscreenPassiveMountEffects(id, finishedWork);\n      break;\n    case 24:\n      recursivelyTraversePassiveMountEffects(\n        finishedRoot,\n        finishedWork,\n        committedLanes,\n        committedTransitions\n      );\n      flags & 2048 &&\n        commitCachePassiveMountEffect(finishedWork.alternate, finishedWork);\n      break;\n    default:\n      recursivelyTraversePassiveMountEffects(\n        finishedRoot,\n        finishedWork,\n        committedLanes,\n        committedTransitions\n      );\n  }\n}\nfunction recursivelyTraverseReconnectPassiveEffects(\n  finishedRoot$jscomp$0,\n  parentFiber,\n  committedLanes$jscomp$0,\n  committedTransitions$jscomp$0,\n  includeWorkInProgressEffects\n) {\n  includeWorkInProgressEffects =\n    includeWorkInProgressEffects && 0 !== (parentFiber.subtreeFlags & 10256);\n  for (parentFiber = parentFiber.child; null !== parentFiber; ) {\n    var finishedRoot = finishedRoot$jscomp$0,\n      finishedWork = parentFiber,\n      committedLanes = committedLanes$jscomp$0,\n      committedTransitions = committedTransitions$jscomp$0,\n      flags = finishedWork.flags;\n    switch (finishedWork.tag) {\n      case 0:\n      case 11:\n      case 15:\n        recursivelyTraverseReconnectPassiveEffects(\n          finishedRoot,\n          finishedWork,\n          committedLanes,\n          committedTransitions,\n          includeWorkInProgressEffects\n        );\n        commitHookEffectListMount(8, finishedWork);\n        break;\n      case 23:\n        break;\n      case 22:\n        var instance = finishedWork.stateNode;\n        null !== finishedWork.memoizedState\n          ? instance._visibility & 2\n            ? recursivelyTraverseReconnectPassiveEffects(\n                finishedRoot,\n                finishedWork,\n                committedLanes,\n                committedTransitions,\n                includeWorkInProgressEffects\n              )\n            : recursivelyTraverseAtomicPassiveEffects(\n                finishedRoot,\n                finishedWork\n              )\n          : ((instance._visibility |= 2),\n            recursivelyTraverseReconnectPassiveEffects(\n              finishedRoot,\n              finishedWork,\n              committedLanes,\n              committedTransitions,\n              includeWorkInProgressEffects\n            ));\n        includeWorkInProgressEffects &&\n          flags & 2048 &&\n          commitOffscreenPassiveMountEffects(\n            finishedWork.alternate,\n            finishedWork\n          );\n        break;\n      case 24:\n        recursivelyTraverseReconnectPassiveEffects(\n          finishedRoot,\n          finishedWork,\n          committedLanes,\n          committedTransitions,\n          includeWorkInProgressEffects\n        );\n        includeWorkInProgressEffects &&\n          flags & 2048 &&\n          commitCachePassiveMountEffect(finishedWork.alternate, finishedWork);\n        break;\n      default:\n        recursivelyTraverseReconnectPassiveEffects(\n          finishedRoot,\n          finishedWork,\n          committedLanes,\n          committedTransitions,\n          includeWorkInProgressEffects\n        );\n    }\n    parentFiber = parentFiber.sibling;\n  }\n}\nfunction recursivelyTraverseAtomicPassiveEffects(\n  finishedRoot$jscomp$0,\n  parentFiber\n) {\n  if (parentFiber.subtreeFlags & 10256)\n    for (parentFiber = parentFiber.child; null !== parentFiber; ) {\n      var finishedRoot = finishedRoot$jscomp$0,\n        finishedWork = parentFiber,\n        flags = finishedWork.flags;\n      switch (finishedWork.tag) {\n        case 22:\n          recursivelyTraverseAtomicPassiveEffects(finishedRoot, finishedWork);\n          flags & 2048 &&\n            commitOffscreenPassiveMountEffects(\n              finishedWork.alternate,\n              finishedWork\n            );\n          break;\n        case 24:\n          recursivelyTraverseAtomicPassiveEffects(finishedRoot, finishedWork);\n          flags & 2048 &&\n            commitCachePassiveMountEffect(finishedWork.alternate, finishedWork);\n          break;\n        default:\n          recursivelyTraverseAtomicPassiveEffects(finishedRoot, finishedWork);\n      }\n      parentFiber = parentFiber.sibling;\n    }\n}\nvar suspenseyCommitFlag = 8192;\nfunction recursivelyAccumulateSuspenseyCommit(parentFiber) {\n  if (parentFiber.subtreeFlags & suspenseyCommitFlag)\n    for (parentFiber = parentFiber.child; null !== parentFiber; )\n      accumulateSuspenseyCommitOnFiber(parentFiber),\n        (parentFiber = parentFiber.sibling);\n}\nfunction accumulateSuspenseyCommitOnFiber(fiber) {\n  switch (fiber.tag) {\n    case 26:\n      recursivelyAccumulateSuspenseyCommit(fiber);\n      fiber.flags & suspenseyCommitFlag &&\n        null !== fiber.memoizedState &&\n        suspendResource(\n          currentHoistableRoot,\n          fiber.memoizedState,\n          fiber.memoizedProps\n        );\n      break;\n    case 5:\n      recursivelyAccumulateSuspenseyCommit(fiber);\n      break;\n    case 3:\n    case 4:\n      var previousHoistableRoot = currentHoistableRoot;\n      currentHoistableRoot = getHoistableRoot(fiber.stateNode.containerInfo);\n      recursivelyAccumulateSuspenseyCommit(fiber);\n      currentHoistableRoot = previousHoistableRoot;\n      break;\n    case 22:\n      null === fiber.memoizedState &&\n        ((previousHoistableRoot = fiber.alternate),\n        null !== previousHoistableRoot &&\n        null !== previousHoistableRoot.memoizedState\n          ? ((previousHoistableRoot = suspenseyCommitFlag),\n            (suspenseyCommitFlag = 16777216),\n            recursivelyAccumulateSuspenseyCommit(fiber),\n            (suspenseyCommitFlag = previousHoistableRoot))\n          : recursivelyAccumulateSuspenseyCommit(fiber));\n      break;\n    default:\n      recursivelyAccumulateSuspenseyCommit(fiber);\n  }\n}\nfunction detachAlternateSiblings(parentFiber) {\n  var previousFiber = parentFiber.alternate;\n  if (\n    null !== previousFiber &&\n    ((parentFiber = previousFiber.child), null !== parentFiber)\n  ) {\n    previousFiber.child = null;\n    do\n      (previousFiber = parentFiber.sibling),\n        (parentFiber.sibling = null),\n        (parentFiber = previousFiber);\n    while (null !== parentFiber);\n  }\n}\nfunction recursivelyTraversePassiveUnmountEffects(parentFiber) {\n  var deletions = parentFiber.deletions;\n  if (0 !== (parentFiber.flags & 16)) {\n    if (null !== deletions)\n      for (var i = 0; i < deletions.length; i++) {\n        var childToDelete = deletions[i];\n        nextEffect = childToDelete;\n        commitPassiveUnmountEffectsInsideOfDeletedTree_begin(\n          childToDelete,\n          parentFiber\n        );\n      }\n    detachAlternateSiblings(parentFiber);\n  }\n  if (parentFiber.subtreeFlags & 10256)\n    for (parentFiber = parentFiber.child; null !== parentFiber; )\n      commitPassiveUnmountOnFiber(parentFiber),\n        (parentFiber = parentFiber.sibling);\n}\nfunction commitPassiveUnmountOnFiber(finishedWork) {\n  switch (finishedWork.tag) {\n    case 0:\n    case 11:\n    case 15:\n      recursivelyTraversePassiveUnmountEffects(finishedWork);\n      finishedWork.flags & 2048 &&\n        commitHookEffectListUnmount(9, finishedWork, finishedWork.return);\n      break;\n    case 3:\n      recursivelyTraversePassiveUnmountEffects(finishedWork);\n      break;\n    case 12:\n      recursivelyTraversePassiveUnmountEffects(finishedWork);\n      break;\n    case 22:\n      var instance = finishedWork.stateNode;\n      null !== finishedWork.memoizedState &&\n      instance._visibility & 2 &&\n      (null === finishedWork.return || 13 !== finishedWork.return.tag)\n        ? ((instance._visibility &= -3),\n          recursivelyTraverseDisconnectPassiveEffects(finishedWork))\n        : recursivelyTraversePassiveUnmountEffects(finishedWork);\n      break;\n    default:\n      recursivelyTraversePassiveUnmountEffects(finishedWork);\n  }\n}\nfunction recursivelyTraverseDisconnectPassiveEffects(parentFiber) {\n  var deletions = parentFiber.deletions;\n  if (0 !== (parentFiber.flags & 16)) {\n    if (null !== deletions)\n      for (var i = 0; i < deletions.length; i++) {\n        var childToDelete = deletions[i];\n        nextEffect = childToDelete;\n        commitPassiveUnmountEffectsInsideOfDeletedTree_begin(\n          childToDelete,\n          parentFiber\n        );\n      }\n    detachAlternateSiblings(parentFiber);\n  }\n  for (parentFiber = parentFiber.child; null !== parentFiber; ) {\n    deletions = parentFiber;\n    switch (deletions.tag) {\n      case 0:\n      case 11:\n      case 15:\n        commitHookEffectListUnmount(8, deletions, deletions.return);\n        recursivelyTraverseDisconnectPassiveEffects(deletions);\n        break;\n      case 22:\n        i = deletions.stateNode;\n        i._visibility & 2 &&\n          ((i._visibility &= -3),\n          recursivelyTraverseDisconnectPassiveEffects(deletions));\n        break;\n      default:\n        recursivelyTraverseDisconnectPassiveEffects(deletions);\n    }\n    parentFiber = parentFiber.sibling;\n  }\n}\nfunction commitPassiveUnmountEffectsInsideOfDeletedTree_begin(\n  deletedSubtreeRoot,\n  nearestMountedAncestor\n) {\n  for (; null !== nextEffect; ) {\n    var fiber = nextEffect;\n    switch (fiber.tag) {\n      case 0:\n      case 11:\n      case 15:\n        commitHookEffectListUnmount(8, fiber, nearestMountedAncestor);\n        break;\n      case 23:\n      case 22:\n        if (\n          null !== fiber.memoizedState &&\n          null !== fiber.memoizedState.cachePool\n        ) {\n          var cache = fiber.memoizedState.cachePool.pool;\n          null != cache && cache.refCount++;\n        }\n        break;\n      case 24:\n        releaseCache(fiber.memoizedState.cache);\n    }\n    cache = fiber.child;\n    if (null !== cache) (cache.return = fiber), (nextEffect = cache);\n    else\n      a: for (fiber = deletedSubtreeRoot; null !== nextEffect; ) {\n        cache = nextEffect;\n        var sibling = cache.sibling,\n          returnFiber = cache.return;\n        detachFiberAfterEffects(cache);\n        if (cache === fiber) {\n          nextEffect = null;\n          break a;\n        }\n        if (null !== sibling) {\n          sibling.return = returnFiber;\n          nextEffect = sibling;\n          break a;\n        }\n        nextEffect = returnFiber;\n      }\n  }\n}\nvar DefaultAsyncDispatcher = {\n    getCacheForType: function (resourceType) {\n      var cache = readContext(CacheContext),\n        cacheForType = cache.data.get(resourceType);\n      void 0 === cacheForType &&\n        ((cacheForType = resourceType()),\n        cache.data.set(resourceType, cacheForType));\n      return cacheForType;\n    }\n  },\n  PossiblyWeakMap = \"function\" === typeof WeakMap ? WeakMap : Map,\n  executionContext = 0,\n  workInProgressRoot = null,\n  workInProgress = null,\n  workInProgressRootRenderLanes = 0,\n  workInProgressSuspendedReason = 0,\n  workInProgressThrownValue = null,\n  workInProgressRootDidSkipSuspendedSiblings = !1,\n  workInProgressRootIsPrerendering = !1,\n  workInProgressRootDidAttachPingListener = !1,\n  entangledRenderLanes = 0,\n  workInProgressRootExitStatus = 0,\n  workInProgressRootSkippedLanes = 0,\n  workInProgressRootInterleavedUpdatedLanes = 0,\n  workInProgressRootPingedLanes = 0,\n  workInProgressDeferredLane = 0,\n  workInProgressSuspendedRetryLanes = 0,\n  workInProgressRootConcurrentErrors = null,\n  workInProgressRootRecoverableErrors = null,\n  workInProgressRootDidIncludeRecursiveRenderUpdate = !1,\n  globalMostRecentFallbackTime = 0,\n  workInProgressRootRenderTargetTime = Infinity,\n  workInProgressTransitions = null,\n  legacyErrorBoundariesThatAlreadyFailed = null,\n  pendingEffectsStatus = 0,\n  pendingEffectsRoot = null,\n  pendingFinishedWork = null,\n  pendingEffectsLanes = 0,\n  pendingEffectsRemainingLanes = 0,\n  pendingPassiveTransitions = null,\n  pendingRecoverableErrors = null,\n  nestedUpdateCount = 0,\n  rootWithNestedUpdates = null;\nfunction requestUpdateLane() {\n  if (0 !== (executionContext & 2) && 0 !== workInProgressRootRenderLanes)\n    return workInProgressRootRenderLanes & -workInProgressRootRenderLanes;\n  if (null !== ReactSharedInternals.T) {\n    var actionScopeLane = currentEntangledLane;\n    return 0 !== actionScopeLane ? actionScopeLane : requestTransitionLane();\n  }\n  return resolveUpdatePriority();\n}\nfunction requestDeferredLane() {\n  0 === workInProgressDeferredLane &&\n    (workInProgressDeferredLane =\n      0 === (workInProgressRootRenderLanes & 536870912) || isHydrating\n        ? claimNextTransitionLane()\n        : 536870912);\n  var suspenseHandler = suspenseHandlerStackCursor.current;\n  null !== suspenseHandler && (suspenseHandler.flags |= 32);\n  return workInProgressDeferredLane;\n}\nfunction scheduleUpdateOnFiber(root, fiber, lane) {\n  if (\n    (root === workInProgressRoot &&\n      (2 === workInProgressSuspendedReason ||\n        9 === workInProgressSuspendedReason)) ||\n    null !== root.cancelPendingCommit\n  )\n    prepareFreshStack(root, 0),\n      markRootSuspended(\n        root,\n        workInProgressRootRenderLanes,\n        workInProgressDeferredLane,\n        !1\n      );\n  markRootUpdated$1(root, lane);\n  if (0 === (executionContext & 2) || root !== workInProgressRoot)\n    root === workInProgressRoot &&\n      (0 === (executionContext & 2) &&\n        (workInProgressRootInterleavedUpdatedLanes |= lane),\n      4 === workInProgressRootExitStatus &&\n        markRootSuspended(\n          root,\n          workInProgressRootRenderLanes,\n          workInProgressDeferredLane,\n          !1\n        )),\n      ensureRootIsScheduled(root);\n}\nfunction performWorkOnRoot(root$jscomp$0, lanes, forceSync) {\n  if (0 !== (executionContext & 6)) throw Error(formatProdErrorMessage(327));\n  var shouldTimeSlice =\n      (!forceSync &&\n        0 === (lanes & 124) &&\n        0 === (lanes & root$jscomp$0.expiredLanes)) ||\n      checkIfRootIsPrerendering(root$jscomp$0, lanes),\n    exitStatus = shouldTimeSlice\n      ? renderRootConcurrent(root$jscomp$0, lanes)\n      : renderRootSync(root$jscomp$0, lanes, !0),\n    renderWasConcurrent = shouldTimeSlice;\n  do {\n    if (0 === exitStatus) {\n      workInProgressRootIsPrerendering &&\n        !shouldTimeSlice &&\n        markRootSuspended(root$jscomp$0, lanes, 0, !1);\n      break;\n    } else {\n      forceSync = root$jscomp$0.current.alternate;\n      if (\n        renderWasConcurrent &&\n        !isRenderConsistentWithExternalStores(forceSync)\n      ) {\n        exitStatus = renderRootSync(root$jscomp$0, lanes, !1);\n        renderWasConcurrent = !1;\n        continue;\n      }\n      if (2 === exitStatus) {\n        renderWasConcurrent = lanes;\n        if (root$jscomp$0.errorRecoveryDisabledLanes & renderWasConcurrent)\n          var JSCompiler_inline_result = 0;\n        else\n          (JSCompiler_inline_result = root$jscomp$0.pendingLanes & -536870913),\n            (JSCompiler_inline_result =\n              0 !== JSCompiler_inline_result\n                ? JSCompiler_inline_result\n                : JSCompiler_inline_result & 536870912\n                  ? 536870912\n                  : 0);\n        if (0 !== JSCompiler_inline_result) {\n          lanes = JSCompiler_inline_result;\n          a: {\n            var root = root$jscomp$0;\n            exitStatus = workInProgressRootConcurrentErrors;\n            var wasRootDehydrated = root.current.memoizedState.isDehydrated;\n            wasRootDehydrated &&\n              (prepareFreshStack(root, JSCompiler_inline_result).flags |= 256);\n            JSCompiler_inline_result = renderRootSync(\n              root,\n              JSCompiler_inline_result,\n              !1\n            );\n            if (2 !== JSCompiler_inline_result) {\n              if (\n                workInProgressRootDidAttachPingListener &&\n                !wasRootDehydrated\n              ) {\n                root.errorRecoveryDisabledLanes |= renderWasConcurrent;\n                workInProgressRootInterleavedUpdatedLanes |=\n                  renderWasConcurrent;\n                exitStatus = 4;\n                break a;\n              }\n              renderWasConcurrent = workInProgressRootRecoverableErrors;\n              workInProgressRootRecoverableErrors = exitStatus;\n              null !== renderWasConcurrent &&\n                (null === workInProgressRootRecoverableErrors\n                  ? (workInProgressRootRecoverableErrors = renderWasConcurrent)\n                  : workInProgressRootRecoverableErrors.push.apply(\n                      workInProgressRootRecoverableErrors,\n                      renderWasConcurrent\n                    ));\n            }\n            exitStatus = JSCompiler_inline_result;\n          }\n          renderWasConcurrent = !1;\n          if (2 !== exitStatus) continue;\n        }\n      }\n      if (1 === exitStatus) {\n        prepareFreshStack(root$jscomp$0, 0);\n        markRootSuspended(root$jscomp$0, lanes, 0, !0);\n        break;\n      }\n      a: {\n        shouldTimeSlice = root$jscomp$0;\n        renderWasConcurrent = exitStatus;\n        switch (renderWasConcurrent) {\n          case 0:\n          case 1:\n            throw Error(formatProdErrorMessage(345));\n          case 4:\n            if ((lanes & 4194048) !== lanes) break;\n          case 6:\n            markRootSuspended(\n              shouldTimeSlice,\n              lanes,\n              workInProgressDeferredLane,\n              !workInProgressRootDidSkipSuspendedSiblings\n            );\n            break a;\n          case 2:\n            workInProgressRootRecoverableErrors = null;\n            break;\n          case 3:\n          case 5:\n            break;\n          default:\n            throw Error(formatProdErrorMessage(329));\n        }\n        if (\n          (lanes & 62914560) === lanes &&\n          ((exitStatus = globalMostRecentFallbackTime + 300 - now()),\n          10 < exitStatus)\n        ) {\n          markRootSuspended(\n            shouldTimeSlice,\n            lanes,\n            workInProgressDeferredLane,\n            !workInProgressRootDidSkipSuspendedSiblings\n          );\n          if (0 !== getNextLanes(shouldTimeSlice, 0, !0)) break a;\n          shouldTimeSlice.timeoutHandle = scheduleTimeout(\n            commitRootWhenReady.bind(\n              null,\n              shouldTimeSlice,\n              forceSync,\n              workInProgressRootRecoverableErrors,\n              workInProgressTransitions,\n              workInProgressRootDidIncludeRecursiveRenderUpdate,\n              lanes,\n              workInProgressDeferredLane,\n              workInProgressRootInterleavedUpdatedLanes,\n              workInProgressSuspendedRetryLanes,\n              workInProgressRootDidSkipSuspendedSiblings,\n              renderWasConcurrent,\n              2,\n              -0,\n              0\n            ),\n            exitStatus\n          );\n          break a;\n        }\n        commitRootWhenReady(\n          shouldTimeSlice,\n          forceSync,\n          workInProgressRootRecoverableErrors,\n          workInProgressTransitions,\n          workInProgressRootDidIncludeRecursiveRenderUpdate,\n          lanes,\n          workInProgressDeferredLane,\n          workInProgressRootInterleavedUpdatedLanes,\n          workInProgressSuspendedRetryLanes,\n          workInProgressRootDidSkipSuspendedSiblings,\n          renderWasConcurrent,\n          0,\n          -0,\n          0\n        );\n      }\n    }\n    break;\n  } while (1);\n  ensureRootIsScheduled(root$jscomp$0);\n}\nfunction commitRootWhenReady(\n  root,\n  finishedWork,\n  recoverableErrors,\n  transitions,\n  didIncludeRenderPhaseUpdate,\n  lanes,\n  spawnedLane,\n  updatedLanes,\n  suspendedRetryLanes,\n  didSkipSuspendedSiblings,\n  exitStatus,\n  suspendedCommitReason,\n  completedRenderStartTime,\n  completedRenderEndTime\n) {\n  root.timeoutHandle = -1;\n  suspendedCommitReason = finishedWork.subtreeFlags;\n  if (\n    suspendedCommitReason & 8192 ||\n    16785408 === (suspendedCommitReason & 16785408)\n  )\n    if (\n      ((suspendedState = { stylesheets: null, count: 0, unsuspend: noop }),\n      accumulateSuspenseyCommitOnFiber(finishedWork),\n      (suspendedCommitReason = waitForCommitToBeReady()),\n      null !== suspendedCommitReason)\n    ) {\n      root.cancelPendingCommit = suspendedCommitReason(\n        commitRoot.bind(\n          null,\n          root,\n          finishedWork,\n          lanes,\n          recoverableErrors,\n          transitions,\n          didIncludeRenderPhaseUpdate,\n          spawnedLane,\n          updatedLanes,\n          suspendedRetryLanes,\n          exitStatus,\n          1,\n          completedRenderStartTime,\n          completedRenderEndTime\n        )\n      );\n      markRootSuspended(root, lanes, spawnedLane, !didSkipSuspendedSiblings);\n      return;\n    }\n  commitRoot(\n    root,\n    finishedWork,\n    lanes,\n    recoverableErrors,\n    transitions,\n    didIncludeRenderPhaseUpdate,\n    spawnedLane,\n    updatedLanes,\n    suspendedRetryLanes\n  );\n}\nfunction isRenderConsistentWithExternalStores(finishedWork) {\n  for (var node = finishedWork; ; ) {\n    var tag = node.tag;\n    if (\n      (0 === tag || 11 === tag || 15 === tag) &&\n      node.flags & 16384 &&\n      ((tag = node.updateQueue),\n      null !== tag && ((tag = tag.stores), null !== tag))\n    )\n      for (var i = 0; i < tag.length; i++) {\n        var check = tag[i],\n          getSnapshot = check.getSnapshot;\n        check = check.value;\n        try {\n          if (!objectIs(getSnapshot(), check)) return !1;\n        } catch (error) {\n          return !1;\n        }\n      }\n    tag = node.child;\n    if (node.subtreeFlags & 16384 && null !== tag)\n      (tag.return = node), (node = tag);\n    else {\n      if (node === finishedWork) break;\n      for (; null === node.sibling; ) {\n        if (null === node.return || node.return === finishedWork) return !0;\n        node = node.return;\n      }\n      node.sibling.return = node.return;\n      node = node.sibling;\n    }\n  }\n  return !0;\n}\nfunction markRootSuspended(\n  root,\n  suspendedLanes,\n  spawnedLane,\n  didAttemptEntireTree\n) {\n  suspendedLanes &= ~workInProgressRootPingedLanes;\n  suspendedLanes &= ~workInProgressRootInterleavedUpdatedLanes;\n  root.suspendedLanes |= suspendedLanes;\n  root.pingedLanes &= ~suspendedLanes;\n  didAttemptEntireTree && (root.warmLanes |= suspendedLanes);\n  didAttemptEntireTree = root.expirationTimes;\n  for (var lanes = suspendedLanes; 0 < lanes; ) {\n    var index$4 = 31 - clz32(lanes),\n      lane = 1 << index$4;\n    didAttemptEntireTree[index$4] = -1;\n    lanes &= ~lane;\n  }\n  0 !== spawnedLane &&\n    markSpawnedDeferredLane(root, spawnedLane, suspendedLanes);\n}\nfunction flushSyncWork$1() {\n  return 0 === (executionContext & 6)\n    ? (flushSyncWorkAcrossRoots_impl(0, !1), !1)\n    : !0;\n}\nfunction resetWorkInProgressStack() {\n  if (null !== workInProgress) {\n    if (0 === workInProgressSuspendedReason)\n      var interruptedWork = workInProgress.return;\n    else\n      (interruptedWork = workInProgress),\n        (lastContextDependency = currentlyRenderingFiber$1 = null),\n        resetHooksOnUnwind(interruptedWork),\n        (thenableState = null),\n        (thenableIndexCounter = 0),\n        (interruptedWork = workInProgress);\n    for (; null !== interruptedWork; )\n      unwindInterruptedWork(interruptedWork.alternate, interruptedWork),\n        (interruptedWork = interruptedWork.return);\n    workInProgress = null;\n  }\n}\nfunction prepareFreshStack(root, lanes) {\n  var timeoutHandle = root.timeoutHandle;\n  -1 !== timeoutHandle &&\n    ((root.timeoutHandle = -1), cancelTimeout(timeoutHandle));\n  timeoutHandle = root.cancelPendingCommit;\n  null !== timeoutHandle &&\n    ((root.cancelPendingCommit = null), timeoutHandle());\n  resetWorkInProgressStack();\n  workInProgressRoot = root;\n  workInProgress = timeoutHandle = createWorkInProgress(root.current, null);\n  workInProgressRootRenderLanes = lanes;\n  workInProgressSuspendedReason = 0;\n  workInProgressThrownValue = null;\n  workInProgressRootDidSkipSuspendedSiblings = !1;\n  workInProgressRootIsPrerendering = checkIfRootIsPrerendering(root, lanes);\n  workInProgressRootDidAttachPingListener = !1;\n  workInProgressSuspendedRetryLanes =\n    workInProgressDeferredLane =\n    workInProgressRootPingedLanes =\n    workInProgressRootInterleavedUpdatedLanes =\n    workInProgressRootSkippedLanes =\n    workInProgressRootExitStatus =\n      0;\n  workInProgressRootRecoverableErrors = workInProgressRootConcurrentErrors =\n    null;\n  workInProgressRootDidIncludeRecursiveRenderUpdate = !1;\n  0 !== (lanes & 8) && (lanes |= lanes & 32);\n  var allEntangledLanes = root.entangledLanes;\n  if (0 !== allEntangledLanes)\n    for (\n      root = root.entanglements, allEntangledLanes &= lanes;\n      0 < allEntangledLanes;\n\n    ) {\n      var index$2 = 31 - clz32(allEntangledLanes),\n        lane = 1 << index$2;\n      lanes |= root[index$2];\n      allEntangledLanes &= ~lane;\n    }\n  entangledRenderLanes = lanes;\n  finishQueueingConcurrentUpdates();\n  return timeoutHandle;\n}\nfunction handleThrow(root, thrownValue) {\n  currentlyRenderingFiber = null;\n  ReactSharedInternals.H = ContextOnlyDispatcher;\n  thrownValue === SuspenseException || thrownValue === SuspenseActionException\n    ? ((thrownValue = getSuspendedThenable()),\n      (workInProgressSuspendedReason = 3))\n    : thrownValue === SuspenseyCommitException\n      ? ((thrownValue = getSuspendedThenable()),\n        (workInProgressSuspendedReason = 4))\n      : (workInProgressSuspendedReason =\n          thrownValue === SelectiveHydrationException\n            ? 8\n            : null !== thrownValue &&\n                \"object\" === typeof thrownValue &&\n                \"function\" === typeof thrownValue.then\n              ? 6\n              : 1);\n  workInProgressThrownValue = thrownValue;\n  null === workInProgress &&\n    ((workInProgressRootExitStatus = 1),\n    logUncaughtError(\n      root,\n      createCapturedValueAtFiber(thrownValue, root.current)\n    ));\n}\nfunction pushDispatcher() {\n  var prevDispatcher = ReactSharedInternals.H;\n  ReactSharedInternals.H = ContextOnlyDispatcher;\n  return null === prevDispatcher ? ContextOnlyDispatcher : prevDispatcher;\n}\nfunction pushAsyncDispatcher() {\n  var prevAsyncDispatcher = ReactSharedInternals.A;\n  ReactSharedInternals.A = DefaultAsyncDispatcher;\n  return prevAsyncDispatcher;\n}\nfunction renderDidSuspendDelayIfPossible() {\n  workInProgressRootExitStatus = 4;\n  workInProgressRootDidSkipSuspendedSiblings ||\n    ((workInProgressRootRenderLanes & 4194048) !==\n      workInProgressRootRenderLanes &&\n      null !== suspenseHandlerStackCursor.current) ||\n    (workInProgressRootIsPrerendering = !0);\n  (0 === (workInProgressRootSkippedLanes & 134217727) &&\n    0 === (workInProgressRootInterleavedUpdatedLanes & 134217727)) ||\n    null === workInProgressRoot ||\n    markRootSuspended(\n      workInProgressRoot,\n      workInProgressRootRenderLanes,\n      workInProgressDeferredLane,\n      !1\n    );\n}\nfunction renderRootSync(root, lanes, shouldYieldForPrerendering) {\n  var prevExecutionContext = executionContext;\n  executionContext |= 2;\n  var prevDispatcher = pushDispatcher(),\n    prevAsyncDispatcher = pushAsyncDispatcher();\n  if (workInProgressRoot !== root || workInProgressRootRenderLanes !== lanes)\n    (workInProgressTransitions = null), prepareFreshStack(root, lanes);\n  lanes = !1;\n  var exitStatus = workInProgressRootExitStatus;\n  a: do\n    try {\n      if (0 !== workInProgressSuspendedReason && null !== workInProgress) {\n        var unitOfWork = workInProgress,\n          thrownValue = workInProgressThrownValue;\n        switch (workInProgressSuspendedReason) {\n          case 8:\n            resetWorkInProgressStack();\n            exitStatus = 6;\n            break a;\n          case 3:\n          case 2:\n          case 9:\n          case 6:\n            null === suspenseHandlerStackCursor.current && (lanes = !0);\n            var reason = workInProgressSuspendedReason;\n            workInProgressSuspendedReason = 0;\n            workInProgressThrownValue = null;\n            throwAndUnwindWorkLoop(root, unitOfWork, thrownValue, reason);\n            if (\n              shouldYieldForPrerendering &&\n              workInProgressRootIsPrerendering\n            ) {\n              exitStatus = 0;\n              break a;\n            }\n            break;\n          default:\n            (reason = workInProgressSuspendedReason),\n              (workInProgressSuspendedReason = 0),\n              (workInProgressThrownValue = null),\n              throwAndUnwindWorkLoop(root, unitOfWork, thrownValue, reason);\n        }\n      }\n      workLoopSync();\n      exitStatus = workInProgressRootExitStatus;\n      break;\n    } catch (thrownValue$167) {\n      handleThrow(root, thrownValue$167);\n    }\n  while (1);\n  lanes && root.shellSuspendCounter++;\n  lastContextDependency = currentlyRenderingFiber$1 = null;\n  executionContext = prevExecutionContext;\n  ReactSharedInternals.H = prevDispatcher;\n  ReactSharedInternals.A = prevAsyncDispatcher;\n  null === workInProgress &&\n    ((workInProgressRoot = null),\n    (workInProgressRootRenderLanes = 0),\n    finishQueueingConcurrentUpdates());\n  return exitStatus;\n}\nfunction workLoopSync() {\n  for (; null !== workInProgress; ) performUnitOfWork(workInProgress);\n}\nfunction renderRootConcurrent(root, lanes) {\n  var prevExecutionContext = executionContext;\n  executionContext |= 2;\n  var prevDispatcher = pushDispatcher(),\n    prevAsyncDispatcher = pushAsyncDispatcher();\n  workInProgressRoot !== root || workInProgressRootRenderLanes !== lanes\n    ? ((workInProgressTransitions = null),\n      (workInProgressRootRenderTargetTime = now() + 500),\n      prepareFreshStack(root, lanes))\n    : (workInProgressRootIsPrerendering = checkIfRootIsPrerendering(\n        root,\n        lanes\n      ));\n  a: do\n    try {\n      if (0 !== workInProgressSuspendedReason && null !== workInProgress) {\n        lanes = workInProgress;\n        var thrownValue = workInProgressThrownValue;\n        b: switch (workInProgressSuspendedReason) {\n          case 1:\n            workInProgressSuspendedReason = 0;\n            workInProgressThrownValue = null;\n            throwAndUnwindWorkLoop(root, lanes, thrownValue, 1);\n            break;\n          case 2:\n          case 9:\n            if (isThenableResolved(thrownValue)) {\n              workInProgressSuspendedReason = 0;\n              workInProgressThrownValue = null;\n              replaySuspendedUnitOfWork(lanes);\n              break;\n            }\n            lanes = function () {\n              (2 !== workInProgressSuspendedReason &&\n                9 !== workInProgressSuspendedReason) ||\n                workInProgressRoot !== root ||\n                (workInProgressSuspendedReason = 7);\n              ensureRootIsScheduled(root);\n            };\n            thrownValue.then(lanes, lanes);\n            break a;\n          case 3:\n            workInProgressSuspendedReason = 7;\n            break a;\n          case 4:\n            workInProgressSuspendedReason = 5;\n            break a;\n          case 7:\n            isThenableResolved(thrownValue)\n              ? ((workInProgressSuspendedReason = 0),\n                (workInProgressThrownValue = null),\n                replaySuspendedUnitOfWork(lanes))\n              : ((workInProgressSuspendedReason = 0),\n                (workInProgressThrownValue = null),\n                throwAndUnwindWorkLoop(root, lanes, thrownValue, 7));\n            break;\n          case 5:\n            var resource = null;\n            switch (workInProgress.tag) {\n              case 26:\n                resource = workInProgress.memoizedState;\n              case 5:\n              case 27:\n                var hostFiber = workInProgress;\n                if (resource ? preloadResource(resource) : 1) {\n                  workInProgressSuspendedReason = 0;\n                  workInProgressThrownValue = null;\n                  var sibling = hostFiber.sibling;\n                  if (null !== sibling) workInProgress = sibling;\n                  else {\n                    var returnFiber = hostFiber.return;\n                    null !== returnFiber\n                      ? ((workInProgress = returnFiber),\n                        completeUnitOfWork(returnFiber))\n                      : (workInProgress = null);\n                  }\n                  break b;\n                }\n            }\n            workInProgressSuspendedReason = 0;\n            workInProgressThrownValue = null;\n            throwAndUnwindWorkLoop(root, lanes, thrownValue, 5);\n            break;\n          case 6:\n            workInProgressSuspendedReason = 0;\n            workInProgressThrownValue = null;\n            throwAndUnwindWorkLoop(root, lanes, thrownValue, 6);\n            break;\n          case 8:\n            resetWorkInProgressStack();\n            workInProgressRootExitStatus = 6;\n            break a;\n          default:\n            throw Error(formatProdErrorMessage(462));\n        }\n      }\n      workLoopConcurrentByScheduler();\n      break;\n    } catch (thrownValue$169) {\n      handleThrow(root, thrownValue$169);\n    }\n  while (1);\n  lastContextDependency = currentlyRenderingFiber$1 = null;\n  ReactSharedInternals.H = prevDispatcher;\n  ReactSharedInternals.A = prevAsyncDispatcher;\n  executionContext = prevExecutionContext;\n  if (null !== workInProgress) return 0;\n  workInProgressRoot = null;\n  workInProgressRootRenderLanes = 0;\n  finishQueueingConcurrentUpdates();\n  return workInProgressRootExitStatus;\n}\nfunction workLoopConcurrentByScheduler() {\n  for (; null !== workInProgress && !shouldYield(); )\n    performUnitOfWork(workInProgress);\n}\nfunction performUnitOfWork(unitOfWork) {\n  var next = beginWork(unitOfWork.alternate, unitOfWork, entangledRenderLanes);\n  unitOfWork.memoizedProps = unitOfWork.pendingProps;\n  null === next ? completeUnitOfWork(unitOfWork) : (workInProgress = next);\n}\nfunction replaySuspendedUnitOfWork(unitOfWork) {\n  var next = unitOfWork;\n  var current = next.alternate;\n  switch (next.tag) {\n    case 15:\n    case 0:\n      next = replayFunctionComponent(\n        current,\n        next,\n        next.pendingProps,\n        next.type,\n        void 0,\n        workInProgressRootRenderLanes\n      );\n      break;\n    case 11:\n      next = replayFunctionComponent(\n        current,\n        next,\n        next.pendingProps,\n        next.type.render,\n        next.ref,\n        workInProgressRootRenderLanes\n      );\n      break;\n    case 5:\n      resetHooksOnUnwind(next);\n    default:\n      unwindInterruptedWork(current, next),\n        (next = workInProgress =\n          resetWorkInProgress(next, entangledRenderLanes)),\n        (next = beginWork(current, next, entangledRenderLanes));\n  }\n  unitOfWork.memoizedProps = unitOfWork.pendingProps;\n  null === next ? completeUnitOfWork(unitOfWork) : (workInProgress = next);\n}\nfunction throwAndUnwindWorkLoop(\n  root,\n  unitOfWork,\n  thrownValue,\n  suspendedReason\n) {\n  lastContextDependency = currentlyRenderingFiber$1 = null;\n  resetHooksOnUnwind(unitOfWork);\n  thenableState = null;\n  thenableIndexCounter = 0;\n  var returnFiber = unitOfWork.return;\n  try {\n    if (\n      throwException(\n        root,\n        returnFiber,\n        unitOfWork,\n        thrownValue,\n        workInProgressRootRenderLanes\n      )\n    ) {\n      workInProgressRootExitStatus = 1;\n      logUncaughtError(\n        root,\n        createCapturedValueAtFiber(thrownValue, root.current)\n      );\n      workInProgress = null;\n      return;\n    }\n  } catch (error) {\n    if (null !== returnFiber) throw ((workInProgress = returnFiber), error);\n    workInProgressRootExitStatus = 1;\n    logUncaughtError(\n      root,\n      createCapturedValueAtFiber(thrownValue, root.current)\n    );\n    workInProgress = null;\n    return;\n  }\n  if (unitOfWork.flags & 32768) {\n    if (isHydrating || 1 === suspendedReason) root = !0;\n    else if (\n      workInProgressRootIsPrerendering ||\n      0 !== (workInProgressRootRenderLanes & 536870912)\n    )\n      root = !1;\n    else if (\n      ((workInProgressRootDidSkipSuspendedSiblings = root = !0),\n      2 === suspendedReason ||\n        9 === suspendedReason ||\n        3 === suspendedReason ||\n        6 === suspendedReason)\n    )\n      (suspendedReason = suspenseHandlerStackCursor.current),\n        null !== suspendedReason &&\n          13 === suspendedReason.tag &&\n          (suspendedReason.flags |= 16384);\n    unwindUnitOfWork(unitOfWork, root);\n  } else completeUnitOfWork(unitOfWork);\n}\nfunction completeUnitOfWork(unitOfWork) {\n  var completedWork = unitOfWork;\n  do {\n    if (0 !== (completedWork.flags & 32768)) {\n      unwindUnitOfWork(\n        completedWork,\n        workInProgressRootDidSkipSuspendedSiblings\n      );\n      return;\n    }\n    unitOfWork = completedWork.return;\n    var next = completeWork(\n      completedWork.alternate,\n      completedWork,\n      entangledRenderLanes\n    );\n    if (null !== next) {\n      workInProgress = next;\n      return;\n    }\n    completedWork = completedWork.sibling;\n    if (null !== completedWork) {\n      workInProgress = completedWork;\n      return;\n    }\n    workInProgress = completedWork = unitOfWork;\n  } while (null !== completedWork);\n  0 === workInProgressRootExitStatus && (workInProgressRootExitStatus = 5);\n}\nfunction unwindUnitOfWork(unitOfWork, skipSiblings) {\n  do {\n    var next = unwindWork(unitOfWork.alternate, unitOfWork);\n    if (null !== next) {\n      next.flags &= 32767;\n      workInProgress = next;\n      return;\n    }\n    next = unitOfWork.return;\n    null !== next &&\n      ((next.flags |= 32768), (next.subtreeFlags = 0), (next.deletions = null));\n    if (\n      !skipSiblings &&\n      ((unitOfWork = unitOfWork.sibling), null !== unitOfWork)\n    ) {\n      workInProgress = unitOfWork;\n      return;\n    }\n    workInProgress = unitOfWork = next;\n  } while (null !== unitOfWork);\n  workInProgressRootExitStatus = 6;\n  workInProgress = null;\n}\nfunction commitRoot(\n  root,\n  finishedWork,\n  lanes,\n  recoverableErrors,\n  transitions,\n  didIncludeRenderPhaseUpdate,\n  spawnedLane,\n  updatedLanes,\n  suspendedRetryLanes\n) {\n  root.cancelPendingCommit = null;\n  do flushPendingEffects();\n  while (0 !== pendingEffectsStatus);\n  if (0 !== (executionContext & 6)) throw Error(formatProdErrorMessage(327));\n  if (null !== finishedWork) {\n    if (finishedWork === root.current) throw Error(formatProdErrorMessage(177));\n    didIncludeRenderPhaseUpdate = finishedWork.lanes | finishedWork.childLanes;\n    didIncludeRenderPhaseUpdate |= concurrentlyUpdatedLanes;\n    markRootFinished(\n      root,\n      lanes,\n      didIncludeRenderPhaseUpdate,\n      spawnedLane,\n      updatedLanes,\n      suspendedRetryLanes\n    );\n    root === workInProgressRoot &&\n      ((workInProgress = workInProgressRoot = null),\n      (workInProgressRootRenderLanes = 0));\n    pendingFinishedWork = finishedWork;\n    pendingEffectsRoot = root;\n    pendingEffectsLanes = lanes;\n    pendingEffectsRemainingLanes = didIncludeRenderPhaseUpdate;\n    pendingPassiveTransitions = transitions;\n    pendingRecoverableErrors = recoverableErrors;\n    0 !== (finishedWork.subtreeFlags & 10256) ||\n    0 !== (finishedWork.flags & 10256)\n      ? ((root.callbackNode = null),\n        (root.callbackPriority = 0),\n        scheduleCallback$1(NormalPriority$1, function () {\n          flushPassiveEffects(!0);\n          return null;\n        }))\n      : ((root.callbackNode = null), (root.callbackPriority = 0));\n    recoverableErrors = 0 !== (finishedWork.flags & 13878);\n    if (0 !== (finishedWork.subtreeFlags & 13878) || recoverableErrors) {\n      recoverableErrors = ReactSharedInternals.T;\n      ReactSharedInternals.T = null;\n      transitions = ReactDOMSharedInternals.p;\n      ReactDOMSharedInternals.p = 2;\n      spawnedLane = executionContext;\n      executionContext |= 4;\n      try {\n        commitBeforeMutationEffects(root, finishedWork, lanes);\n      } finally {\n        (executionContext = spawnedLane),\n          (ReactDOMSharedInternals.p = transitions),\n          (ReactSharedInternals.T = recoverableErrors);\n      }\n    }\n    pendingEffectsStatus = 1;\n    flushMutationEffects();\n    flushLayoutEffects();\n    flushSpawnedWork();\n  }\n}\nfunction flushMutationEffects() {\n  if (1 === pendingEffectsStatus) {\n    pendingEffectsStatus = 0;\n    var root = pendingEffectsRoot,\n      finishedWork = pendingFinishedWork,\n      rootMutationHasEffect = 0 !== (finishedWork.flags & 13878);\n    if (0 !== (finishedWork.subtreeFlags & 13878) || rootMutationHasEffect) {\n      rootMutationHasEffect = ReactSharedInternals.T;\n      ReactSharedInternals.T = null;\n      var previousPriority = ReactDOMSharedInternals.p;\n      ReactDOMSharedInternals.p = 2;\n      var prevExecutionContext = executionContext;\n      executionContext |= 4;\n      try {\n        commitMutationEffectsOnFiber(finishedWork, root);\n        var priorSelectionInformation = selectionInformation,\n          curFocusedElem = getActiveElementDeep(root.containerInfo),\n          priorFocusedElem = priorSelectionInformation.focusedElem,\n          priorSelectionRange = priorSelectionInformation.selectionRange;\n        if (\n          curFocusedElem !== priorFocusedElem &&\n          priorFocusedElem &&\n          priorFocusedElem.ownerDocument &&\n          containsNode(\n            priorFocusedElem.ownerDocument.documentElement,\n            priorFocusedElem\n          )\n        ) {\n          if (\n            null !== priorSelectionRange &&\n            hasSelectionCapabilities(priorFocusedElem)\n          ) {\n            var start = priorSelectionRange.start,\n              end = priorSelectionRange.end;\n            void 0 === end && (end = start);\n            if (\"selectionStart\" in priorFocusedElem)\n              (priorFocusedElem.selectionStart = start),\n                (priorFocusedElem.selectionEnd = Math.min(\n                  end,\n                  priorFocusedElem.value.length\n                ));\n            else {\n              var doc = priorFocusedElem.ownerDocument || document,\n                win = (doc && doc.defaultView) || window;\n              if (win.getSelection) {\n                var selection = win.getSelection(),\n                  length = priorFocusedElem.textContent.length,\n                  start$jscomp$0 = Math.min(priorSelectionRange.start, length),\n                  end$jscomp$0 =\n                    void 0 === priorSelectionRange.end\n                      ? start$jscomp$0\n                      : Math.min(priorSelectionRange.end, length);\n                !selection.extend &&\n                  start$jscomp$0 > end$jscomp$0 &&\n                  ((curFocusedElem = end$jscomp$0),\n                  (end$jscomp$0 = start$jscomp$0),\n                  (start$jscomp$0 = curFocusedElem));\n                var startMarker = getNodeForCharacterOffset(\n                    priorFocusedElem,\n                    start$jscomp$0\n                  ),\n                  endMarker = getNodeForCharacterOffset(\n                    priorFocusedElem,\n                    end$jscomp$0\n                  );\n                if (\n                  startMarker &&\n                  endMarker &&\n                  (1 !== selection.rangeCount ||\n                    selection.anchorNode !== startMarker.node ||\n                    selection.anchorOffset !== startMarker.offset ||\n                    selection.focusNode !== endMarker.node ||\n                    selection.focusOffset !== endMarker.offset)\n                ) {\n                  var range = doc.createRange();\n                  range.setStart(startMarker.node, startMarker.offset);\n                  selection.removeAllRanges();\n                  start$jscomp$0 > end$jscomp$0\n                    ? (selection.addRange(range),\n                      selection.extend(endMarker.node, endMarker.offset))\n                    : (range.setEnd(endMarker.node, endMarker.offset),\n                      selection.addRange(range));\n                }\n              }\n            }\n          }\n          doc = [];\n          for (\n            selection = priorFocusedElem;\n            (selection = selection.parentNode);\n\n          )\n            1 === selection.nodeType &&\n              doc.push({\n                element: selection,\n                left: selection.scrollLeft,\n                top: selection.scrollTop\n              });\n          \"function\" === typeof priorFocusedElem.focus &&\n            priorFocusedElem.focus();\n          for (\n            priorFocusedElem = 0;\n            priorFocusedElem < doc.length;\n            priorFocusedElem++\n          ) {\n            var info = doc[priorFocusedElem];\n            info.element.scrollLeft = info.left;\n            info.element.scrollTop = info.top;\n          }\n        }\n        _enabled = !!eventsEnabled;\n        selectionInformation = eventsEnabled = null;\n      } finally {\n        (executionContext = prevExecutionContext),\n          (ReactDOMSharedInternals.p = previousPriority),\n          (ReactSharedInternals.T = rootMutationHasEffect);\n      }\n    }\n    root.current = finishedWork;\n    pendingEffectsStatus = 2;\n  }\n}\nfunction flushLayoutEffects() {\n  if (2 === pendingEffectsStatus) {\n    pendingEffectsStatus = 0;\n    var root = pendingEffectsRoot,\n      finishedWork = pendingFinishedWork,\n      rootHasLayoutEffect = 0 !== (finishedWork.flags & 8772);\n    if (0 !== (finishedWork.subtreeFlags & 8772) || rootHasLayoutEffect) {\n      rootHasLayoutEffect = ReactSharedInternals.T;\n      ReactSharedInternals.T = null;\n      var previousPriority = ReactDOMSharedInternals.p;\n      ReactDOMSharedInternals.p = 2;\n      var prevExecutionContext = executionContext;\n      executionContext |= 4;\n      try {\n        commitLayoutEffectOnFiber(root, finishedWork.alternate, finishedWork);\n      } finally {\n        (executionContext = prevExecutionContext),\n          (ReactDOMSharedInternals.p = previousPriority),\n          (ReactSharedInternals.T = rootHasLayoutEffect);\n      }\n    }\n    pendingEffectsStatus = 3;\n  }\n}\nfunction flushSpawnedWork() {\n  if (4 === pendingEffectsStatus || 3 === pendingEffectsStatus) {\n    pendingEffectsStatus = 0;\n    requestPaint();\n    var root = pendingEffectsRoot,\n      finishedWork = pendingFinishedWork,\n      lanes = pendingEffectsLanes,\n      recoverableErrors = pendingRecoverableErrors;\n    0 !== (finishedWork.subtreeFlags & 10256) ||\n    0 !== (finishedWork.flags & 10256)\n      ? (pendingEffectsStatus = 5)\n      : ((pendingEffectsStatus = 0),\n        (pendingFinishedWork = pendingEffectsRoot = null),\n        releaseRootPooledCache(root, root.pendingLanes));\n    var remainingLanes = root.pendingLanes;\n    0 === remainingLanes && (legacyErrorBoundariesThatAlreadyFailed = null);\n    lanesToEventPriority(lanes);\n    finishedWork = finishedWork.stateNode;\n    if (injectedHook && \"function\" === typeof injectedHook.onCommitFiberRoot)\n      try {\n        injectedHook.onCommitFiberRoot(\n          rendererID,\n          finishedWork,\n          void 0,\n          128 === (finishedWork.current.flags & 128)\n        );\n      } catch (err) {}\n    if (null !== recoverableErrors) {\n      finishedWork = ReactSharedInternals.T;\n      remainingLanes = ReactDOMSharedInternals.p;\n      ReactDOMSharedInternals.p = 2;\n      ReactSharedInternals.T = null;\n      try {\n        for (\n          var onRecoverableError = root.onRecoverableError, i = 0;\n          i < recoverableErrors.length;\n          i++\n        ) {\n          var recoverableError = recoverableErrors[i];\n          onRecoverableError(recoverableError.value, {\n            componentStack: recoverableError.stack\n          });\n        }\n      } finally {\n        (ReactSharedInternals.T = finishedWork),\n          (ReactDOMSharedInternals.p = remainingLanes);\n      }\n    }\n    0 !== (pendingEffectsLanes & 3) && flushPendingEffects();\n    ensureRootIsScheduled(root);\n    remainingLanes = root.pendingLanes;\n    0 !== (lanes & 4194090) && 0 !== (remainingLanes & 42)\n      ? root === rootWithNestedUpdates\n        ? nestedUpdateCount++\n        : ((nestedUpdateCount = 0), (rootWithNestedUpdates = root))\n      : (nestedUpdateCount = 0);\n    flushSyncWorkAcrossRoots_impl(0, !1);\n  }\n}\nfunction releaseRootPooledCache(root, remainingLanes) {\n  0 === (root.pooledCacheLanes &= remainingLanes) &&\n    ((remainingLanes = root.pooledCache),\n    null != remainingLanes &&\n      ((root.pooledCache = null), releaseCache(remainingLanes)));\n}\nfunction flushPendingEffects(wasDelayedCommit) {\n  flushMutationEffects();\n  flushLayoutEffects();\n  flushSpawnedWork();\n  return flushPassiveEffects(wasDelayedCommit);\n}\nfunction flushPassiveEffects() {\n  if (5 !== pendingEffectsStatus) return !1;\n  var root = pendingEffectsRoot,\n    remainingLanes = pendingEffectsRemainingLanes;\n  pendingEffectsRemainingLanes = 0;\n  var renderPriority = lanesToEventPriority(pendingEffectsLanes),\n    prevTransition = ReactSharedInternals.T,\n    previousPriority = ReactDOMSharedInternals.p;\n  try {\n    ReactDOMSharedInternals.p = 32 > renderPriority ? 32 : renderPriority;\n    ReactSharedInternals.T = null;\n    renderPriority = pendingPassiveTransitions;\n    pendingPassiveTransitions = null;\n    var root$jscomp$0 = pendingEffectsRoot,\n      lanes = pendingEffectsLanes;\n    pendingEffectsStatus = 0;\n    pendingFinishedWork = pendingEffectsRoot = null;\n    pendingEffectsLanes = 0;\n    if (0 !== (executionContext & 6)) throw Error(formatProdErrorMessage(331));\n    var prevExecutionContext = executionContext;\n    executionContext |= 4;\n    commitPassiveUnmountOnFiber(root$jscomp$0.current);\n    commitPassiveMountOnFiber(\n      root$jscomp$0,\n      root$jscomp$0.current,\n      lanes,\n      renderPriority\n    );\n    executionContext = prevExecutionContext;\n    flushSyncWorkAcrossRoots_impl(0, !1);\n    if (\n      injectedHook &&\n      \"function\" === typeof injectedHook.onPostCommitFiberRoot\n    )\n      try {\n        injectedHook.onPostCommitFiberRoot(rendererID, root$jscomp$0);\n      } catch (err) {}\n    return !0;\n  } finally {\n    (ReactDOMSharedInternals.p = previousPriority),\n      (ReactSharedInternals.T = prevTransition),\n      releaseRootPooledCache(root, remainingLanes);\n  }\n}\nfunction captureCommitPhaseErrorOnRoot(rootFiber, sourceFiber, error) {\n  sourceFiber = createCapturedValueAtFiber(error, sourceFiber);\n  sourceFiber = createRootErrorUpdate(rootFiber.stateNode, sourceFiber, 2);\n  rootFiber = enqueueUpdate(rootFiber, sourceFiber, 2);\n  null !== rootFiber &&\n    (markRootUpdated$1(rootFiber, 2), ensureRootIsScheduled(rootFiber));\n}\nfunction captureCommitPhaseError(sourceFiber, nearestMountedAncestor, error) {\n  if (3 === sourceFiber.tag)\n    captureCommitPhaseErrorOnRoot(sourceFiber, sourceFiber, error);\n  else\n    for (; null !== nearestMountedAncestor; ) {\n      if (3 === nearestMountedAncestor.tag) {\n        captureCommitPhaseErrorOnRoot(\n          nearestMountedAncestor,\n          sourceFiber,\n          error\n        );\n        break;\n      } else if (1 === nearestMountedAncestor.tag) {\n        var instance = nearestMountedAncestor.stateNode;\n        if (\n          \"function\" ===\n            typeof nearestMountedAncestor.type.getDerivedStateFromError ||\n          (\"function\" === typeof instance.componentDidCatch &&\n            (null === legacyErrorBoundariesThatAlreadyFailed ||\n              !legacyErrorBoundariesThatAlreadyFailed.has(instance)))\n        ) {\n          sourceFiber = createCapturedValueAtFiber(error, sourceFiber);\n          error = createClassErrorUpdate(2);\n          instance = enqueueUpdate(nearestMountedAncestor, error, 2);\n          null !== instance &&\n            (initializeClassErrorUpdate(\n              error,\n              instance,\n              nearestMountedAncestor,\n              sourceFiber\n            ),\n            markRootUpdated$1(instance, 2),\n            ensureRootIsScheduled(instance));\n          break;\n        }\n      }\n      nearestMountedAncestor = nearestMountedAncestor.return;\n    }\n}\nfunction attachPingListener(root, wakeable, lanes) {\n  var pingCache = root.pingCache;\n  if (null === pingCache) {\n    pingCache = root.pingCache = new PossiblyWeakMap();\n    var threadIDs = new Set();\n    pingCache.set(wakeable, threadIDs);\n  } else\n    (threadIDs = pingCache.get(wakeable)),\n      void 0 === threadIDs &&\n        ((threadIDs = new Set()), pingCache.set(wakeable, threadIDs));\n  threadIDs.has(lanes) ||\n    ((workInProgressRootDidAttachPingListener = !0),\n    threadIDs.add(lanes),\n    (root = pingSuspendedRoot.bind(null, root, wakeable, lanes)),\n    wakeable.then(root, root));\n}\nfunction pingSuspendedRoot(root, wakeable, pingedLanes) {\n  var pingCache = root.pingCache;\n  null !== pingCache && pingCache.delete(wakeable);\n  root.pingedLanes |= root.suspendedLanes & pingedLanes;\n  root.warmLanes &= ~pingedLanes;\n  workInProgressRoot === root &&\n    (workInProgressRootRenderLanes & pingedLanes) === pingedLanes &&\n    (4 === workInProgressRootExitStatus ||\n    (3 === workInProgressRootExitStatus &&\n      (workInProgressRootRenderLanes & 62914560) ===\n        workInProgressRootRenderLanes &&\n      300 > now() - globalMostRecentFallbackTime)\n      ? 0 === (executionContext & 2) && prepareFreshStack(root, 0)\n      : (workInProgressRootPingedLanes |= pingedLanes),\n    workInProgressSuspendedRetryLanes === workInProgressRootRenderLanes &&\n      (workInProgressSuspendedRetryLanes = 0));\n  ensureRootIsScheduled(root);\n}\nfunction retryTimedOutBoundary(boundaryFiber, retryLane) {\n  0 === retryLane && (retryLane = claimNextRetryLane());\n  boundaryFiber = enqueueConcurrentRenderForLane(boundaryFiber, retryLane);\n  null !== boundaryFiber &&\n    (markRootUpdated$1(boundaryFiber, retryLane),\n    ensureRootIsScheduled(boundaryFiber));\n}\nfunction retryDehydratedSuspenseBoundary(boundaryFiber) {\n  var suspenseState = boundaryFiber.memoizedState,\n    retryLane = 0;\n  null !== suspenseState && (retryLane = suspenseState.retryLane);\n  retryTimedOutBoundary(boundaryFiber, retryLane);\n}\nfunction resolveRetryWakeable(boundaryFiber, wakeable) {\n  var retryLane = 0;\n  switch (boundaryFiber.tag) {\n    case 13:\n      var retryCache = boundaryFiber.stateNode;\n      var suspenseState = boundaryFiber.memoizedState;\n      null !== suspenseState && (retryLane = suspenseState.retryLane);\n      break;\n    case 19:\n      retryCache = boundaryFiber.stateNode;\n      break;\n    case 22:\n      retryCache = boundaryFiber.stateNode._retryCache;\n      break;\n    default:\n      throw Error(formatProdErrorMessage(314));\n  }\n  null !== retryCache && retryCache.delete(wakeable);\n  retryTimedOutBoundary(boundaryFiber, retryLane);\n}\nfunction scheduleCallback$1(priorityLevel, callback) {\n  return scheduleCallback$3(priorityLevel, callback);\n}\nvar firstScheduledRoot = null,\n  lastScheduledRoot = null,\n  didScheduleMicrotask = !1,\n  mightHavePendingSyncWork = !1,\n  isFlushingWork = !1,\n  currentEventTransitionLane = 0;\nfunction ensureRootIsScheduled(root) {\n  root !== lastScheduledRoot &&\n    null === root.next &&\n    (null === lastScheduledRoot\n      ? (firstScheduledRoot = lastScheduledRoot = root)\n      : (lastScheduledRoot = lastScheduledRoot.next = root));\n  mightHavePendingSyncWork = !0;\n  didScheduleMicrotask ||\n    ((didScheduleMicrotask = !0), scheduleImmediateRootScheduleTask());\n}\nfunction flushSyncWorkAcrossRoots_impl(syncTransitionLanes, onlyLegacy) {\n  if (!isFlushingWork && mightHavePendingSyncWork) {\n    isFlushingWork = !0;\n    do {\n      var didPerformSomeWork = !1;\n      for (var root$174 = firstScheduledRoot; null !== root$174; ) {\n        if (!onlyLegacy)\n          if (0 !== syncTransitionLanes) {\n            var pendingLanes = root$174.pendingLanes;\n            if (0 === pendingLanes) var JSCompiler_inline_result = 0;\n            else {\n              var suspendedLanes = root$174.suspendedLanes,\n                pingedLanes = root$174.pingedLanes;\n              JSCompiler_inline_result =\n                (1 << (31 - clz32(42 | syncTransitionLanes) + 1)) - 1;\n              JSCompiler_inline_result &=\n                pendingLanes & ~(suspendedLanes & ~pingedLanes);\n              JSCompiler_inline_result =\n                JSCompiler_inline_result & 201326741\n                  ? (JSCompiler_inline_result & 201326741) | 1\n                  : JSCompiler_inline_result\n                    ? JSCompiler_inline_result | 2\n                    : 0;\n            }\n            0 !== JSCompiler_inline_result &&\n              ((didPerformSomeWork = !0),\n              performSyncWorkOnRoot(root$174, JSCompiler_inline_result));\n          } else\n            (JSCompiler_inline_result = workInProgressRootRenderLanes),\n              (JSCompiler_inline_result = getNextLanes(\n                root$174,\n                root$174 === workInProgressRoot ? JSCompiler_inline_result : 0,\n                null !== root$174.cancelPendingCommit ||\n                  -1 !== root$174.timeoutHandle\n              )),\n              0 === (JSCompiler_inline_result & 3) ||\n                checkIfRootIsPrerendering(root$174, JSCompiler_inline_result) ||\n                ((didPerformSomeWork = !0),\n                performSyncWorkOnRoot(root$174, JSCompiler_inline_result));\n        root$174 = root$174.next;\n      }\n    } while (didPerformSomeWork);\n    isFlushingWork = !1;\n  }\n}\nfunction processRootScheduleInImmediateTask() {\n  processRootScheduleInMicrotask();\n}\nfunction processRootScheduleInMicrotask() {\n  mightHavePendingSyncWork = didScheduleMicrotask = !1;\n  var syncTransitionLanes = 0;\n  0 !== currentEventTransitionLane &&\n    (shouldAttemptEagerTransition() &&\n      (syncTransitionLanes = currentEventTransitionLane),\n    (currentEventTransitionLane = 0));\n  for (\n    var currentTime = now(), prev = null, root = firstScheduledRoot;\n    null !== root;\n\n  ) {\n    var next = root.next,\n      nextLanes = scheduleTaskForRootDuringMicrotask(root, currentTime);\n    if (0 === nextLanes)\n      (root.next = null),\n        null === prev ? (firstScheduledRoot = next) : (prev.next = next),\n        null === next && (lastScheduledRoot = prev);\n    else if (\n      ((prev = root), 0 !== syncTransitionLanes || 0 !== (nextLanes & 3))\n    )\n      mightHavePendingSyncWork = !0;\n    root = next;\n  }\n  flushSyncWorkAcrossRoots_impl(syncTransitionLanes, !1);\n}\nfunction scheduleTaskForRootDuringMicrotask(root, currentTime) {\n  for (\n    var suspendedLanes = root.suspendedLanes,\n      pingedLanes = root.pingedLanes,\n      expirationTimes = root.expirationTimes,\n      lanes = root.pendingLanes & -62914561;\n    0 < lanes;\n\n  ) {\n    var index$3 = 31 - clz32(lanes),\n      lane = 1 << index$3,\n      expirationTime = expirationTimes[index$3];\n    if (-1 === expirationTime) {\n      if (0 === (lane & suspendedLanes) || 0 !== (lane & pingedLanes))\n        expirationTimes[index$3] = computeExpirationTime(lane, currentTime);\n    } else expirationTime <= currentTime && (root.expiredLanes |= lane);\n    lanes &= ~lane;\n  }\n  currentTime = workInProgressRoot;\n  suspendedLanes = workInProgressRootRenderLanes;\n  suspendedLanes = getNextLanes(\n    root,\n    root === currentTime ? suspendedLanes : 0,\n    null !== root.cancelPendingCommit || -1 !== root.timeoutHandle\n  );\n  pingedLanes = root.callbackNode;\n  if (\n    0 === suspendedLanes ||\n    (root === currentTime &&\n      (2 === workInProgressSuspendedReason ||\n        9 === workInProgressSuspendedReason)) ||\n    null !== root.cancelPendingCommit\n  )\n    return (\n      null !== pingedLanes &&\n        null !== pingedLanes &&\n        cancelCallback$1(pingedLanes),\n      (root.callbackNode = null),\n      (root.callbackPriority = 0)\n    );\n  if (\n    0 === (suspendedLanes & 3) ||\n    checkIfRootIsPrerendering(root, suspendedLanes)\n  ) {\n    currentTime = suspendedLanes & -suspendedLanes;\n    if (currentTime === root.callbackPriority) return currentTime;\n    null !== pingedLanes && cancelCallback$1(pingedLanes);\n    switch (lanesToEventPriority(suspendedLanes)) {\n      case 2:\n      case 8:\n        suspendedLanes = UserBlockingPriority;\n        break;\n      case 32:\n        suspendedLanes = NormalPriority$1;\n        break;\n      case 268435456:\n        suspendedLanes = IdlePriority;\n        break;\n      default:\n        suspendedLanes = NormalPriority$1;\n    }\n    pingedLanes = performWorkOnRootViaSchedulerTask.bind(null, root);\n    suspendedLanes = scheduleCallback$3(suspendedLanes, pingedLanes);\n    root.callbackPriority = currentTime;\n    root.callbackNode = suspendedLanes;\n    return currentTime;\n  }\n  null !== pingedLanes && null !== pingedLanes && cancelCallback$1(pingedLanes);\n  root.callbackPriority = 2;\n  root.callbackNode = null;\n  return 2;\n}\nfunction performWorkOnRootViaSchedulerTask(root, didTimeout) {\n  if (0 !== pendingEffectsStatus && 5 !== pendingEffectsStatus)\n    return (root.callbackNode = null), (root.callbackPriority = 0), null;\n  var originalCallbackNode = root.callbackNode;\n  if (flushPendingEffects(!0) && root.callbackNode !== originalCallbackNode)\n    return null;\n  var workInProgressRootRenderLanes$jscomp$0 = workInProgressRootRenderLanes;\n  workInProgressRootRenderLanes$jscomp$0 = getNextLanes(\n    root,\n    root === workInProgressRoot ? workInProgressRootRenderLanes$jscomp$0 : 0,\n    null !== root.cancelPendingCommit || -1 !== root.timeoutHandle\n  );\n  if (0 === workInProgressRootRenderLanes$jscomp$0) return null;\n  performWorkOnRoot(root, workInProgressRootRenderLanes$jscomp$0, didTimeout);\n  scheduleTaskForRootDuringMicrotask(root, now());\n  return null != root.callbackNode && root.callbackNode === originalCallbackNode\n    ? performWorkOnRootViaSchedulerTask.bind(null, root)\n    : null;\n}\nfunction performSyncWorkOnRoot(root, lanes) {\n  if (flushPendingEffects()) return null;\n  performWorkOnRoot(root, lanes, !0);\n}\nfunction scheduleImmediateRootScheduleTask() {\n  scheduleMicrotask(function () {\n    0 !== (executionContext & 6)\n      ? scheduleCallback$3(\n          ImmediatePriority,\n          processRootScheduleInImmediateTask\n        )\n      : processRootScheduleInMicrotask();\n  });\n}\nfunction requestTransitionLane() {\n  0 === currentEventTransitionLane &&\n    (currentEventTransitionLane = claimNextTransitionLane());\n  return currentEventTransitionLane;\n}\nfunction coerceFormActionProp(actionProp) {\n  return null == actionProp ||\n    \"symbol\" === typeof actionProp ||\n    \"boolean\" === typeof actionProp\n    ? null\n    : \"function\" === typeof actionProp\n      ? actionProp\n      : sanitizeURL(\"\" + actionProp);\n}\nfunction createFormDataWithSubmitter(form, submitter) {\n  var temp = submitter.ownerDocument.createElement(\"input\");\n  temp.name = submitter.name;\n  temp.value = submitter.value;\n  form.id && temp.setAttribute(\"form\", form.id);\n  submitter.parentNode.insertBefore(temp, submitter);\n  form = new FormData(form);\n  temp.parentNode.removeChild(temp);\n  return form;\n}\nfunction extractEvents$1(\n  dispatchQueue,\n  domEventName,\n  maybeTargetInst,\n  nativeEvent,\n  nativeEventTarget\n) {\n  if (\n    \"submit\" === domEventName &&\n    maybeTargetInst &&\n    maybeTargetInst.stateNode === nativeEventTarget\n  ) {\n    var action = coerceFormActionProp(\n        (nativeEventTarget[internalPropsKey] || null).action\n      ),\n      submitter = nativeEvent.submitter;\n    submitter &&\n      ((domEventName = (domEventName = submitter[internalPropsKey] || null)\n        ? coerceFormActionProp(domEventName.formAction)\n        : submitter.getAttribute(\"formAction\")),\n      null !== domEventName && ((action = domEventName), (submitter = null)));\n    var event = new SyntheticEvent(\n      \"action\",\n      \"action\",\n      null,\n      nativeEvent,\n      nativeEventTarget\n    );\n    dispatchQueue.push({\n      event: event,\n      listeners: [\n        {\n          instance: null,\n          listener: function () {\n            if (nativeEvent.defaultPrevented) {\n              if (0 !== currentEventTransitionLane) {\n                var formData = submitter\n                  ? createFormDataWithSubmitter(nativeEventTarget, submitter)\n                  : new FormData(nativeEventTarget);\n                startHostTransition(\n                  maybeTargetInst,\n                  {\n                    pending: !0,\n                    data: formData,\n                    method: nativeEventTarget.method,\n                    action: action\n                  },\n                  null,\n                  formData\n                );\n              }\n            } else\n              \"function\" === typeof action &&\n                (event.preventDefault(),\n                (formData = submitter\n                  ? createFormDataWithSubmitter(nativeEventTarget, submitter)\n                  : new FormData(nativeEventTarget)),\n                startHostTransition(\n                  maybeTargetInst,\n                  {\n                    pending: !0,\n                    data: formData,\n                    method: nativeEventTarget.method,\n                    action: action\n                  },\n                  action,\n                  formData\n                ));\n          },\n          currentTarget: nativeEventTarget\n        }\n      ]\n    });\n  }\n}\nfor (\n  var i$jscomp$inline_1528 = 0;\n  i$jscomp$inline_1528 < simpleEventPluginEvents.length;\n  i$jscomp$inline_1528++\n) {\n  var eventName$jscomp$inline_1529 =\n      simpleEventPluginEvents[i$jscomp$inline_1528],\n    domEventName$jscomp$inline_1530 =\n      eventName$jscomp$inline_1529.toLowerCase(),\n    capitalizedEvent$jscomp$inline_1531 =\n      eventName$jscomp$inline_1529[0].toUpperCase() +\n      eventName$jscomp$inline_1529.slice(1);\n  registerSimpleEvent(\n    domEventName$jscomp$inline_1530,\n    \"on\" + capitalizedEvent$jscomp$inline_1531\n  );\n}\nregisterSimpleEvent(ANIMATION_END, \"onAnimationEnd\");\nregisterSimpleEvent(ANIMATION_ITERATION, \"onAnimationIteration\");\nregisterSimpleEvent(ANIMATION_START, \"onAnimationStart\");\nregisterSimpleEvent(\"dblclick\", \"onDoubleClick\");\nregisterSimpleEvent(\"focusin\", \"onFocus\");\nregisterSimpleEvent(\"focusout\", \"onBlur\");\nregisterSimpleEvent(TRANSITION_RUN, \"onTransitionRun\");\nregisterSimpleEvent(TRANSITION_START, \"onTransitionStart\");\nregisterSimpleEvent(TRANSITION_CANCEL, \"onTransitionCancel\");\nregisterSimpleEvent(TRANSITION_END, \"onTransitionEnd\");\nregisterDirectEvent(\"onMouseEnter\", [\"mouseout\", \"mouseover\"]);\nregisterDirectEvent(\"onMouseLeave\", [\"mouseout\", \"mouseover\"]);\nregisterDirectEvent(\"onPointerEnter\", [\"pointerout\", \"pointerover\"]);\nregisterDirectEvent(\"onPointerLeave\", [\"pointerout\", \"pointerover\"]);\nregisterTwoPhaseEvent(\n  \"onChange\",\n  \"change click focusin focusout input keydown keyup selectionchange\".split(\" \")\n);\nregisterTwoPhaseEvent(\n  \"onSelect\",\n  \"focusout contextmenu dragend focusin keydown keyup mousedown mouseup selectionchange\".split(\n    \" \"\n  )\n);\nregisterTwoPhaseEvent(\"onBeforeInput\", [\n  \"compositionend\",\n  \"keypress\",\n  \"textInput\",\n  \"paste\"\n]);\nregisterTwoPhaseEvent(\n  \"onCompositionEnd\",\n  \"compositionend focusout keydown keypress keyup mousedown\".split(\" \")\n);\nregisterTwoPhaseEvent(\n  \"onCompositionStart\",\n  \"compositionstart focusout keydown keypress keyup mousedown\".split(\" \")\n);\nregisterTwoPhaseEvent(\n  \"onCompositionUpdate\",\n  \"compositionupdate focusout keydown keypress keyup mousedown\".split(\" \")\n);\nvar mediaEventTypes =\n    \"abort canplay canplaythrough durationchange emptied encrypted ended error loadeddata loadedmetadata loadstart pause play playing progress ratechange resize seeked seeking stalled suspend timeupdate volumechange waiting\".split(\n      \" \"\n    ),\n  nonDelegatedEvents = new Set(\n    \"beforetoggle cancel close invalid load scroll scrollend toggle\"\n      .split(\" \")\n      .concat(mediaEventTypes)\n  );\nfunction processDispatchQueue(dispatchQueue, eventSystemFlags) {\n  eventSystemFlags = 0 !== (eventSystemFlags & 4);\n  for (var i = 0; i < dispatchQueue.length; i++) {\n    var _dispatchQueue$i = dispatchQueue[i],\n      event = _dispatchQueue$i.event;\n    _dispatchQueue$i = _dispatchQueue$i.listeners;\n    a: {\n      var previousInstance = void 0;\n      if (eventSystemFlags)\n        for (\n          var i$jscomp$0 = _dispatchQueue$i.length - 1;\n          0 <= i$jscomp$0;\n          i$jscomp$0--\n        ) {\n          var _dispatchListeners$i = _dispatchQueue$i[i$jscomp$0],\n            instance = _dispatchListeners$i.instance,\n            currentTarget = _dispatchListeners$i.currentTarget;\n          _dispatchListeners$i = _dispatchListeners$i.listener;\n          if (instance !== previousInstance && event.isPropagationStopped())\n            break a;\n          previousInstance = _dispatchListeners$i;\n          event.currentTarget = currentTarget;\n          try {\n            previousInstance(event);\n          } catch (error) {\n            reportGlobalError(error);\n          }\n          event.currentTarget = null;\n          previousInstance = instance;\n        }\n      else\n        for (\n          i$jscomp$0 = 0;\n          i$jscomp$0 < _dispatchQueue$i.length;\n          i$jscomp$0++\n        ) {\n          _dispatchListeners$i = _dispatchQueue$i[i$jscomp$0];\n          instance = _dispatchListeners$i.instance;\n          currentTarget = _dispatchListeners$i.currentTarget;\n          _dispatchListeners$i = _dispatchListeners$i.listener;\n          if (instance !== previousInstance && event.isPropagationStopped())\n            break a;\n          previousInstance = _dispatchListeners$i;\n          event.currentTarget = currentTarget;\n          try {\n            previousInstance(event);\n          } catch (error) {\n            reportGlobalError(error);\n          }\n          event.currentTarget = null;\n          previousInstance = instance;\n        }\n    }\n  }\n}\nfunction listenToNonDelegatedEvent(domEventName, targetElement) {\n  var JSCompiler_inline_result = targetElement[internalEventHandlersKey];\n  void 0 === JSCompiler_inline_result &&\n    (JSCompiler_inline_result = targetElement[internalEventHandlersKey] =\n      new Set());\n  var listenerSetKey = domEventName + \"__bubble\";\n  JSCompiler_inline_result.has(listenerSetKey) ||\n    (addTrappedEventListener(targetElement, domEventName, 2, !1),\n    JSCompiler_inline_result.add(listenerSetKey));\n}\nfunction listenToNativeEvent(domEventName, isCapturePhaseListener, target) {\n  var eventSystemFlags = 0;\n  isCapturePhaseListener && (eventSystemFlags |= 4);\n  addTrappedEventListener(\n    target,\n    domEventName,\n    eventSystemFlags,\n    isCapturePhaseListener\n  );\n}\nvar listeningMarker = \"_reactListening\" + Math.random().toString(36).slice(2);\nfunction listenToAllSupportedEvents(rootContainerElement) {\n  if (!rootContainerElement[listeningMarker]) {\n    rootContainerElement[listeningMarker] = !0;\n    allNativeEvents.forEach(function (domEventName) {\n      \"selectionchange\" !== domEventName &&\n        (nonDelegatedEvents.has(domEventName) ||\n          listenToNativeEvent(domEventName, !1, rootContainerElement),\n        listenToNativeEvent(domEventName, !0, rootContainerElement));\n    });\n    var ownerDocument =\n      9 === rootContainerElement.nodeType\n        ? rootContainerElement\n        : rootContainerElement.ownerDocument;\n    null === ownerDocument ||\n      ownerDocument[listeningMarker] ||\n      ((ownerDocument[listeningMarker] = !0),\n      listenToNativeEvent(\"selectionchange\", !1, ownerDocument));\n  }\n}\nfunction addTrappedEventListener(\n  targetContainer,\n  domEventName,\n  eventSystemFlags,\n  isCapturePhaseListener\n) {\n  switch (getEventPriority(domEventName)) {\n    case 2:\n      var listenerWrapper = dispatchDiscreteEvent;\n      break;\n    case 8:\n      listenerWrapper = dispatchContinuousEvent;\n      break;\n    default:\n      listenerWrapper = dispatchEvent;\n  }\n  eventSystemFlags = listenerWrapper.bind(\n    null,\n    domEventName,\n    eventSystemFlags,\n    targetContainer\n  );\n  listenerWrapper = void 0;\n  !passiveBrowserEventsSupported ||\n    (\"touchstart\" !== domEventName &&\n      \"touchmove\" !== domEventName &&\n      \"wheel\" !== domEventName) ||\n    (listenerWrapper = !0);\n  isCapturePhaseListener\n    ? void 0 !== listenerWrapper\n      ? targetContainer.addEventListener(domEventName, eventSystemFlags, {\n          capture: !0,\n          passive: listenerWrapper\n        })\n      : targetContainer.addEventListener(domEventName, eventSystemFlags, !0)\n    : void 0 !== listenerWrapper\n      ? targetContainer.addEventListener(domEventName, eventSystemFlags, {\n          passive: listenerWrapper\n        })\n      : targetContainer.addEventListener(domEventName, eventSystemFlags, !1);\n}\nfunction dispatchEventForPluginEventSystem(\n  domEventName,\n  eventSystemFlags,\n  nativeEvent,\n  targetInst$jscomp$0,\n  targetContainer\n) {\n  var ancestorInst = targetInst$jscomp$0;\n  if (\n    0 === (eventSystemFlags & 1) &&\n    0 === (eventSystemFlags & 2) &&\n    null !== targetInst$jscomp$0\n  )\n    a: for (;;) {\n      if (null === targetInst$jscomp$0) return;\n      var nodeTag = targetInst$jscomp$0.tag;\n      if (3 === nodeTag || 4 === nodeTag) {\n        var container = targetInst$jscomp$0.stateNode.containerInfo;\n        if (container === targetContainer) break;\n        if (4 === nodeTag)\n          for (nodeTag = targetInst$jscomp$0.return; null !== nodeTag; ) {\n            var grandTag = nodeTag.tag;\n            if (\n              (3 === grandTag || 4 === grandTag) &&\n              nodeTag.stateNode.containerInfo === targetContainer\n            )\n              return;\n            nodeTag = nodeTag.return;\n          }\n        for (; null !== container; ) {\n          nodeTag = getClosestInstanceFromNode(container);\n          if (null === nodeTag) return;\n          grandTag = nodeTag.tag;\n          if (\n            5 === grandTag ||\n            6 === grandTag ||\n            26 === grandTag ||\n            27 === grandTag\n          ) {\n            targetInst$jscomp$0 = ancestorInst = nodeTag;\n            continue a;\n          }\n          container = container.parentNode;\n        }\n      }\n      targetInst$jscomp$0 = targetInst$jscomp$0.return;\n    }\n  batchedUpdates$1(function () {\n    var targetInst = ancestorInst,\n      nativeEventTarget = getEventTarget(nativeEvent),\n      dispatchQueue = [];\n    a: {\n      var reactName = topLevelEventsToReactNames.get(domEventName);\n      if (void 0 !== reactName) {\n        var SyntheticEventCtor = SyntheticEvent,\n          reactEventType = domEventName;\n        switch (domEventName) {\n          case \"keypress\":\n            if (0 === getEventCharCode(nativeEvent)) break a;\n          case \"keydown\":\n          case \"keyup\":\n            SyntheticEventCtor = SyntheticKeyboardEvent;\n            break;\n          case \"focusin\":\n            reactEventType = \"focus\";\n            SyntheticEventCtor = SyntheticFocusEvent;\n            break;\n          case \"focusout\":\n            reactEventType = \"blur\";\n            SyntheticEventCtor = SyntheticFocusEvent;\n            break;\n          case \"beforeblur\":\n          case \"afterblur\":\n            SyntheticEventCtor = SyntheticFocusEvent;\n            break;\n          case \"click\":\n            if (2 === nativeEvent.button) break a;\n          case \"auxclick\":\n          case \"dblclick\":\n          case \"mousedown\":\n          case \"mousemove\":\n          case \"mouseup\":\n          case \"mouseout\":\n          case \"mouseover\":\n          case \"contextmenu\":\n            SyntheticEventCtor = SyntheticMouseEvent;\n            break;\n          case \"drag\":\n          case \"dragend\":\n          case \"dragenter\":\n          case \"dragexit\":\n          case \"dragleave\":\n          case \"dragover\":\n          case \"dragstart\":\n          case \"drop\":\n            SyntheticEventCtor = SyntheticDragEvent;\n            break;\n          case \"touchcancel\":\n          case \"touchend\":\n          case \"touchmove\":\n          case \"touchstart\":\n            SyntheticEventCtor = SyntheticTouchEvent;\n            break;\n          case ANIMATION_END:\n          case ANIMATION_ITERATION:\n          case ANIMATION_START:\n            SyntheticEventCtor = SyntheticAnimationEvent;\n            break;\n          case TRANSITION_END:\n            SyntheticEventCtor = SyntheticTransitionEvent;\n            break;\n          case \"scroll\":\n          case \"scrollend\":\n            SyntheticEventCtor = SyntheticUIEvent;\n            break;\n          case \"wheel\":\n            SyntheticEventCtor = SyntheticWheelEvent;\n            break;\n          case \"copy\":\n          case \"cut\":\n          case \"paste\":\n            SyntheticEventCtor = SyntheticClipboardEvent;\n            break;\n          case \"gotpointercapture\":\n          case \"lostpointercapture\":\n          case \"pointercancel\":\n          case \"pointerdown\":\n          case \"pointermove\":\n          case \"pointerout\":\n          case \"pointerover\":\n          case \"pointerup\":\n            SyntheticEventCtor = SyntheticPointerEvent;\n            break;\n          case \"toggle\":\n          case \"beforetoggle\":\n            SyntheticEventCtor = SyntheticToggleEvent;\n        }\n        var inCapturePhase = 0 !== (eventSystemFlags & 4),\n          accumulateTargetOnly =\n            !inCapturePhase &&\n            (\"scroll\" === domEventName || \"scrollend\" === domEventName),\n          reactEventName = inCapturePhase\n            ? null !== reactName\n              ? reactName + \"Capture\"\n              : null\n            : reactName;\n        inCapturePhase = [];\n        for (\n          var instance = targetInst, lastHostComponent;\n          null !== instance;\n\n        ) {\n          var _instance = instance;\n          lastHostComponent = _instance.stateNode;\n          _instance = _instance.tag;\n          (5 !== _instance && 26 !== _instance && 27 !== _instance) ||\n            null === lastHostComponent ||\n            null === reactEventName ||\n            ((_instance = getListener(instance, reactEventName)),\n            null != _instance &&\n              inCapturePhase.push(\n                createDispatchListener(instance, _instance, lastHostComponent)\n              ));\n          if (accumulateTargetOnly) break;\n          instance = instance.return;\n        }\n        0 < inCapturePhase.length &&\n          ((reactName = new SyntheticEventCtor(\n            reactName,\n            reactEventType,\n            null,\n            nativeEvent,\n            nativeEventTarget\n          )),\n          dispatchQueue.push({ event: reactName, listeners: inCapturePhase }));\n      }\n    }\n    if (0 === (eventSystemFlags & 7)) {\n      a: {\n        reactName =\n          \"mouseover\" === domEventName || \"pointerover\" === domEventName;\n        SyntheticEventCtor =\n          \"mouseout\" === domEventName || \"pointerout\" === domEventName;\n        if (\n          reactName &&\n          nativeEvent !== currentReplayingEvent &&\n          (reactEventType =\n            nativeEvent.relatedTarget || nativeEvent.fromElement) &&\n          (getClosestInstanceFromNode(reactEventType) ||\n            reactEventType[internalContainerInstanceKey])\n        )\n          break a;\n        if (SyntheticEventCtor || reactName) {\n          reactName =\n            nativeEventTarget.window === nativeEventTarget\n              ? nativeEventTarget\n              : (reactName = nativeEventTarget.ownerDocument)\n                ? reactName.defaultView || reactName.parentWindow\n                : window;\n          if (SyntheticEventCtor) {\n            if (\n              ((reactEventType =\n                nativeEvent.relatedTarget || nativeEvent.toElement),\n              (SyntheticEventCtor = targetInst),\n              (reactEventType = reactEventType\n                ? getClosestInstanceFromNode(reactEventType)\n                : null),\n              null !== reactEventType &&\n                ((accumulateTargetOnly =\n                  getNearestMountedFiber(reactEventType)),\n                (inCapturePhase = reactEventType.tag),\n                reactEventType !== accumulateTargetOnly ||\n                  (5 !== inCapturePhase &&\n                    27 !== inCapturePhase &&\n                    6 !== inCapturePhase)))\n            )\n              reactEventType = null;\n          } else (SyntheticEventCtor = null), (reactEventType = targetInst);\n          if (SyntheticEventCtor !== reactEventType) {\n            inCapturePhase = SyntheticMouseEvent;\n            _instance = \"onMouseLeave\";\n            reactEventName = \"onMouseEnter\";\n            instance = \"mouse\";\n            if (\"pointerout\" === domEventName || \"pointerover\" === domEventName)\n              (inCapturePhase = SyntheticPointerEvent),\n                (_instance = \"onPointerLeave\"),\n                (reactEventName = \"onPointerEnter\"),\n                (instance = \"pointer\");\n            accumulateTargetOnly =\n              null == SyntheticEventCtor\n                ? reactName\n                : getNodeFromInstance(SyntheticEventCtor);\n            lastHostComponent =\n              null == reactEventType\n                ? reactName\n                : getNodeFromInstance(reactEventType);\n            reactName = new inCapturePhase(\n              _instance,\n              instance + \"leave\",\n              SyntheticEventCtor,\n              nativeEvent,\n              nativeEventTarget\n            );\n            reactName.target = accumulateTargetOnly;\n            reactName.relatedTarget = lastHostComponent;\n            _instance = null;\n            getClosestInstanceFromNode(nativeEventTarget) === targetInst &&\n              ((inCapturePhase = new inCapturePhase(\n                reactEventName,\n                instance + \"enter\",\n                reactEventType,\n                nativeEvent,\n                nativeEventTarget\n              )),\n              (inCapturePhase.target = lastHostComponent),\n              (inCapturePhase.relatedTarget = accumulateTargetOnly),\n              (_instance = inCapturePhase));\n            accumulateTargetOnly = _instance;\n            if (SyntheticEventCtor && reactEventType)\n              b: {\n                inCapturePhase = SyntheticEventCtor;\n                reactEventName = reactEventType;\n                instance = 0;\n                for (\n                  lastHostComponent = inCapturePhase;\n                  lastHostComponent;\n                  lastHostComponent = getParent(lastHostComponent)\n                )\n                  instance++;\n                lastHostComponent = 0;\n                for (\n                  _instance = reactEventName;\n                  _instance;\n                  _instance = getParent(_instance)\n                )\n                  lastHostComponent++;\n                for (; 0 < instance - lastHostComponent; )\n                  (inCapturePhase = getParent(inCapturePhase)), instance--;\n                for (; 0 < lastHostComponent - instance; )\n                  (reactEventName = getParent(reactEventName)),\n                    lastHostComponent--;\n                for (; instance--; ) {\n                  if (\n                    inCapturePhase === reactEventName ||\n                    (null !== reactEventName &&\n                      inCapturePhase === reactEventName.alternate)\n                  )\n                    break b;\n                  inCapturePhase = getParent(inCapturePhase);\n                  reactEventName = getParent(reactEventName);\n                }\n                inCapturePhase = null;\n              }\n            else inCapturePhase = null;\n            null !== SyntheticEventCtor &&\n              accumulateEnterLeaveListenersForEvent(\n                dispatchQueue,\n                reactName,\n                SyntheticEventCtor,\n                inCapturePhase,\n                !1\n              );\n            null !== reactEventType &&\n              null !== accumulateTargetOnly &&\n              accumulateEnterLeaveListenersForEvent(\n                dispatchQueue,\n                accumulateTargetOnly,\n                reactEventType,\n                inCapturePhase,\n                !0\n              );\n          }\n        }\n      }\n      a: {\n        reactName = targetInst ? getNodeFromInstance(targetInst) : window;\n        SyntheticEventCtor =\n          reactName.nodeName && reactName.nodeName.toLowerCase();\n        if (\n          \"select\" === SyntheticEventCtor ||\n          (\"input\" === SyntheticEventCtor && \"file\" === reactName.type)\n        )\n          var getTargetInstFunc = getTargetInstForChangeEvent;\n        else if (isTextInputElement(reactName))\n          if (isInputEventSupported)\n            getTargetInstFunc = getTargetInstForInputOrChangeEvent;\n          else {\n            getTargetInstFunc = getTargetInstForInputEventPolyfill;\n            var handleEventFunc = handleEventsForInputEventPolyfill;\n          }\n        else\n          (SyntheticEventCtor = reactName.nodeName),\n            !SyntheticEventCtor ||\n            \"input\" !== SyntheticEventCtor.toLowerCase() ||\n            (\"checkbox\" !== reactName.type && \"radio\" !== reactName.type)\n              ? targetInst &&\n                isCustomElement(targetInst.elementType) &&\n                (getTargetInstFunc = getTargetInstForChangeEvent)\n              : (getTargetInstFunc = getTargetInstForClickEvent);\n        if (\n          getTargetInstFunc &&\n          (getTargetInstFunc = getTargetInstFunc(domEventName, targetInst))\n        ) {\n          createAndAccumulateChangeEvent(\n            dispatchQueue,\n            getTargetInstFunc,\n            nativeEvent,\n            nativeEventTarget\n          );\n          break a;\n        }\n        handleEventFunc && handleEventFunc(domEventName, reactName, targetInst);\n        \"focusout\" === domEventName &&\n          targetInst &&\n          \"number\" === reactName.type &&\n          null != targetInst.memoizedProps.value &&\n          setDefaultValue(reactName, \"number\", reactName.value);\n      }\n      handleEventFunc = targetInst ? getNodeFromInstance(targetInst) : window;\n      switch (domEventName) {\n        case \"focusin\":\n          if (\n            isTextInputElement(handleEventFunc) ||\n            \"true\" === handleEventFunc.contentEditable\n          )\n            (activeElement = handleEventFunc),\n              (activeElementInst = targetInst),\n              (lastSelection = null);\n          break;\n        case \"focusout\":\n          lastSelection = activeElementInst = activeElement = null;\n          break;\n        case \"mousedown\":\n          mouseDown = !0;\n          break;\n        case \"contextmenu\":\n        case \"mouseup\":\n        case \"dragend\":\n          mouseDown = !1;\n          constructSelectEvent(dispatchQueue, nativeEvent, nativeEventTarget);\n          break;\n        case \"selectionchange\":\n          if (skipSelectionChangeEvent) break;\n        case \"keydown\":\n        case \"keyup\":\n          constructSelectEvent(dispatchQueue, nativeEvent, nativeEventTarget);\n      }\n      var fallbackData;\n      if (canUseCompositionEvent)\n        b: {\n          switch (domEventName) {\n            case \"compositionstart\":\n              var eventType = \"onCompositionStart\";\n              break b;\n            case \"compositionend\":\n              eventType = \"onCompositionEnd\";\n              break b;\n            case \"compositionupdate\":\n              eventType = \"onCompositionUpdate\";\n              break b;\n          }\n          eventType = void 0;\n        }\n      else\n        isComposing\n          ? isFallbackCompositionEnd(domEventName, nativeEvent) &&\n            (eventType = \"onCompositionEnd\")\n          : \"keydown\" === domEventName &&\n            229 === nativeEvent.keyCode &&\n            (eventType = \"onCompositionStart\");\n      eventType &&\n        (useFallbackCompositionData &&\n          \"ko\" !== nativeEvent.locale &&\n          (isComposing || \"onCompositionStart\" !== eventType\n            ? \"onCompositionEnd\" === eventType &&\n              isComposing &&\n              (fallbackData = getData())\n            : ((root = nativeEventTarget),\n              (startText = \"value\" in root ? root.value : root.textContent),\n              (isComposing = !0))),\n        (handleEventFunc = accumulateTwoPhaseListeners(targetInst, eventType)),\n        0 < handleEventFunc.length &&\n          ((eventType = new SyntheticCompositionEvent(\n            eventType,\n            domEventName,\n            null,\n            nativeEvent,\n            nativeEventTarget\n          )),\n          dispatchQueue.push({ event: eventType, listeners: handleEventFunc }),\n          fallbackData\n            ? (eventType.data = fallbackData)\n            : ((fallbackData = getDataFromCustomEvent(nativeEvent)),\n              null !== fallbackData && (eventType.data = fallbackData))));\n      if (\n        (fallbackData = canUseTextInputEvent\n          ? getNativeBeforeInputChars(domEventName, nativeEvent)\n          : getFallbackBeforeInputChars(domEventName, nativeEvent))\n      )\n        (eventType = accumulateTwoPhaseListeners(targetInst, \"onBeforeInput\")),\n          0 < eventType.length &&\n            ((handleEventFunc = new SyntheticCompositionEvent(\n              \"onBeforeInput\",\n              \"beforeinput\",\n              null,\n              nativeEvent,\n              nativeEventTarget\n            )),\n            dispatchQueue.push({\n              event: handleEventFunc,\n              listeners: eventType\n            }),\n            (handleEventFunc.data = fallbackData));\n      extractEvents$1(\n        dispatchQueue,\n        domEventName,\n        targetInst,\n        nativeEvent,\n        nativeEventTarget\n      );\n    }\n    processDispatchQueue(dispatchQueue, eventSystemFlags);\n  });\n}\nfunction createDispatchListener(instance, listener, currentTarget) {\n  return {\n    instance: instance,\n    listener: listener,\n    currentTarget: currentTarget\n  };\n}\nfunction accumulateTwoPhaseListeners(targetFiber, reactName) {\n  for (\n    var captureName = reactName + \"Capture\", listeners = [];\n    null !== targetFiber;\n\n  ) {\n    var _instance2 = targetFiber,\n      stateNode = _instance2.stateNode;\n    _instance2 = _instance2.tag;\n    (5 !== _instance2 && 26 !== _instance2 && 27 !== _instance2) ||\n      null === stateNode ||\n      ((_instance2 = getListener(targetFiber, captureName)),\n      null != _instance2 &&\n        listeners.unshift(\n          createDispatchListener(targetFiber, _instance2, stateNode)\n        ),\n      (_instance2 = getListener(targetFiber, reactName)),\n      null != _instance2 &&\n        listeners.push(\n          createDispatchListener(targetFiber, _instance2, stateNode)\n        ));\n    if (3 === targetFiber.tag) return listeners;\n    targetFiber = targetFiber.return;\n  }\n  return [];\n}\nfunction getParent(inst) {\n  if (null === inst) return null;\n  do inst = inst.return;\n  while (inst && 5 !== inst.tag && 27 !== inst.tag);\n  return inst ? inst : null;\n}\nfunction accumulateEnterLeaveListenersForEvent(\n  dispatchQueue,\n  event,\n  target,\n  common,\n  inCapturePhase\n) {\n  for (\n    var registrationName = event._reactName, listeners = [];\n    null !== target && target !== common;\n\n  ) {\n    var _instance3 = target,\n      alternate = _instance3.alternate,\n      stateNode = _instance3.stateNode;\n    _instance3 = _instance3.tag;\n    if (null !== alternate && alternate === common) break;\n    (5 !== _instance3 && 26 !== _instance3 && 27 !== _instance3) ||\n      null === stateNode ||\n      ((alternate = stateNode),\n      inCapturePhase\n        ? ((stateNode = getListener(target, registrationName)),\n          null != stateNode &&\n            listeners.unshift(\n              createDispatchListener(target, stateNode, alternate)\n            ))\n        : inCapturePhase ||\n          ((stateNode = getListener(target, registrationName)),\n          null != stateNode &&\n            listeners.push(\n              createDispatchListener(target, stateNode, alternate)\n            )));\n    target = target.return;\n  }\n  0 !== listeners.length &&\n    dispatchQueue.push({ event: event, listeners: listeners });\n}\nvar NORMALIZE_NEWLINES_REGEX = /\\r\\n?/g,\n  NORMALIZE_NULL_AND_REPLACEMENT_REGEX = /\\u0000|\\uFFFD/g;\nfunction normalizeMarkupForTextOrAttribute(markup) {\n  return (\"string\" === typeof markup ? markup : \"\" + markup)\n    .replace(NORMALIZE_NEWLINES_REGEX, \"\\n\")\n    .replace(NORMALIZE_NULL_AND_REPLACEMENT_REGEX, \"\");\n}\nfunction checkForUnmatchedText(serverText, clientText) {\n  clientText = normalizeMarkupForTextOrAttribute(clientText);\n  return normalizeMarkupForTextOrAttribute(serverText) === clientText ? !0 : !1;\n}\nfunction noop$1() {}\nfunction setProp(domElement, tag, key, value, props, prevValue) {\n  switch (key) {\n    case \"children\":\n      \"string\" === typeof value\n        ? \"body\" === tag ||\n          (\"textarea\" === tag && \"\" === value) ||\n          setTextContent(domElement, value)\n        : (\"number\" === typeof value || \"bigint\" === typeof value) &&\n          \"body\" !== tag &&\n          setTextContent(domElement, \"\" + value);\n      break;\n    case \"className\":\n      setValueForKnownAttribute(domElement, \"class\", value);\n      break;\n    case \"tabIndex\":\n      setValueForKnownAttribute(domElement, \"tabindex\", value);\n      break;\n    case \"dir\":\n    case \"role\":\n    case \"viewBox\":\n    case \"width\":\n    case \"height\":\n      setValueForKnownAttribute(domElement, key, value);\n      break;\n    case \"style\":\n      setValueForStyles(domElement, value, prevValue);\n      break;\n    case \"data\":\n      if (\"object\" !== tag) {\n        setValueForKnownAttribute(domElement, \"data\", value);\n        break;\n      }\n    case \"src\":\n    case \"href\":\n      if (\"\" === value && (\"a\" !== tag || \"href\" !== key)) {\n        domElement.removeAttribute(key);\n        break;\n      }\n      if (\n        null == value ||\n        \"function\" === typeof value ||\n        \"symbol\" === typeof value ||\n        \"boolean\" === typeof value\n      ) {\n        domElement.removeAttribute(key);\n        break;\n      }\n      value = sanitizeURL(\"\" + value);\n      domElement.setAttribute(key, value);\n      break;\n    case \"action\":\n    case \"formAction\":\n      if (\"function\" === typeof value) {\n        domElement.setAttribute(\n          key,\n          \"javascript:throw new Error('A React form was unexpectedly submitted. If you called form.submit() manually, consider using form.requestSubmit() instead. If you\\\\'re trying to use event.stopPropagation() in a submit event handler, consider also calling event.preventDefault().')\"\n        );\n        break;\n      } else\n        \"function\" === typeof prevValue &&\n          (\"formAction\" === key\n            ? (\"input\" !== tag &&\n                setProp(domElement, tag, \"name\", props.name, props, null),\n              setProp(\n                domElement,\n                tag,\n                \"formEncType\",\n                props.formEncType,\n                props,\n                null\n              ),\n              setProp(\n                domElement,\n                tag,\n                \"formMethod\",\n                props.formMethod,\n                props,\n                null\n              ),\n              setProp(\n                domElement,\n                tag,\n                \"formTarget\",\n                props.formTarget,\n                props,\n                null\n              ))\n            : (setProp(domElement, tag, \"encType\", props.encType, props, null),\n              setProp(domElement, tag, \"method\", props.method, props, null),\n              setProp(domElement, tag, \"target\", props.target, props, null)));\n      if (\n        null == value ||\n        \"symbol\" === typeof value ||\n        \"boolean\" === typeof value\n      ) {\n        domElement.removeAttribute(key);\n        break;\n      }\n      value = sanitizeURL(\"\" + value);\n      domElement.setAttribute(key, value);\n      break;\n    case \"onClick\":\n      null != value && (domElement.onclick = noop$1);\n      break;\n    case \"onScroll\":\n      null != value && listenToNonDelegatedEvent(\"scroll\", domElement);\n      break;\n    case \"onScrollEnd\":\n      null != value && listenToNonDelegatedEvent(\"scrollend\", domElement);\n      break;\n    case \"dangerouslySetInnerHTML\":\n      if (null != value) {\n        if (\"object\" !== typeof value || !(\"__html\" in value))\n          throw Error(formatProdErrorMessage(61));\n        key = value.__html;\n        if (null != key) {\n          if (null != props.children) throw Error(formatProdErrorMessage(60));\n          domElement.innerHTML = key;\n        }\n      }\n      break;\n    case \"multiple\":\n      domElement.multiple =\n        value && \"function\" !== typeof value && \"symbol\" !== typeof value;\n      break;\n    case \"muted\":\n      domElement.muted =\n        value && \"function\" !== typeof value && \"symbol\" !== typeof value;\n      break;\n    case \"suppressContentEditableWarning\":\n    case \"suppressHydrationWarning\":\n    case \"defaultValue\":\n    case \"defaultChecked\":\n    case \"innerHTML\":\n    case \"ref\":\n      break;\n    case \"autoFocus\":\n      break;\n    case \"xlinkHref\":\n      if (\n        null == value ||\n        \"function\" === typeof value ||\n        \"boolean\" === typeof value ||\n        \"symbol\" === typeof value\n      ) {\n        domElement.removeAttribute(\"xlink:href\");\n        break;\n      }\n      key = sanitizeURL(\"\" + value);\n      domElement.setAttributeNS(\n        \"http://www.w3.org/1999/xlink\",\n        \"xlink:href\",\n        key\n      );\n      break;\n    case \"contentEditable\":\n    case \"spellCheck\":\n    case \"draggable\":\n    case \"value\":\n    case \"autoReverse\":\n    case \"externalResourcesRequired\":\n    case \"focusable\":\n    case \"preserveAlpha\":\n      null != value && \"function\" !== typeof value && \"symbol\" !== typeof value\n        ? domElement.setAttribute(key, \"\" + value)\n        : domElement.removeAttribute(key);\n      break;\n    case \"inert\":\n    case \"allowFullScreen\":\n    case \"async\":\n    case \"autoPlay\":\n    case \"controls\":\n    case \"default\":\n    case \"defer\":\n    case \"disabled\":\n    case \"disablePictureInPicture\":\n    case \"disableRemotePlayback\":\n    case \"formNoValidate\":\n    case \"hidden\":\n    case \"loop\":\n    case \"noModule\":\n    case \"noValidate\":\n    case \"open\":\n    case \"playsInline\":\n    case \"readOnly\":\n    case \"required\":\n    case \"reversed\":\n    case \"scoped\":\n    case \"seamless\":\n    case \"itemScope\":\n      value && \"function\" !== typeof value && \"symbol\" !== typeof value\n        ? domElement.setAttribute(key, \"\")\n        : domElement.removeAttribute(key);\n      break;\n    case \"capture\":\n    case \"download\":\n      !0 === value\n        ? domElement.setAttribute(key, \"\")\n        : !1 !== value &&\n            null != value &&\n            \"function\" !== typeof value &&\n            \"symbol\" !== typeof value\n          ? domElement.setAttribute(key, value)\n          : domElement.removeAttribute(key);\n      break;\n    case \"cols\":\n    case \"rows\":\n    case \"size\":\n    case \"span\":\n      null != value &&\n      \"function\" !== typeof value &&\n      \"symbol\" !== typeof value &&\n      !isNaN(value) &&\n      1 <= value\n        ? domElement.setAttribute(key, value)\n        : domElement.removeAttribute(key);\n      break;\n    case \"rowSpan\":\n    case \"start\":\n      null == value ||\n      \"function\" === typeof value ||\n      \"symbol\" === typeof value ||\n      isNaN(value)\n        ? domElement.removeAttribute(key)\n        : domElement.setAttribute(key, value);\n      break;\n    case \"popover\":\n      listenToNonDelegatedEvent(\"beforetoggle\", domElement);\n      listenToNonDelegatedEvent(\"toggle\", domElement);\n      setValueForAttribute(domElement, \"popover\", value);\n      break;\n    case \"xlinkActuate\":\n      setValueForNamespacedAttribute(\n        domElement,\n        \"http://www.w3.org/1999/xlink\",\n        \"xlink:actuate\",\n        value\n      );\n      break;\n    case \"xlinkArcrole\":\n      setValueForNamespacedAttribute(\n        domElement,\n        \"http://www.w3.org/1999/xlink\",\n        \"xlink:arcrole\",\n        value\n      );\n      break;\n    case \"xlinkRole\":\n      setValueForNamespacedAttribute(\n        domElement,\n        \"http://www.w3.org/1999/xlink\",\n        \"xlink:role\",\n        value\n      );\n      break;\n    case \"xlinkShow\":\n      setValueForNamespacedAttribute(\n        domElement,\n        \"http://www.w3.org/1999/xlink\",\n        \"xlink:show\",\n        value\n      );\n      break;\n    case \"xlinkTitle\":\n      setValueForNamespacedAttribute(\n        domElement,\n        \"http://www.w3.org/1999/xlink\",\n        \"xlink:title\",\n        value\n      );\n      break;\n    case \"xlinkType\":\n      setValueForNamespacedAttribute(\n        domElement,\n        \"http://www.w3.org/1999/xlink\",\n        \"xlink:type\",\n        value\n      );\n      break;\n    case \"xmlBase\":\n      setValueForNamespacedAttribute(\n        domElement,\n        \"http://www.w3.org/XML/1998/namespace\",\n        \"xml:base\",\n        value\n      );\n      break;\n    case \"xmlLang\":\n      setValueForNamespacedAttribute(\n        domElement,\n        \"http://www.w3.org/XML/1998/namespace\",\n        \"xml:lang\",\n        value\n      );\n      break;\n    case \"xmlSpace\":\n      setValueForNamespacedAttribute(\n        domElement,\n        \"http://www.w3.org/XML/1998/namespace\",\n        \"xml:space\",\n        value\n      );\n      break;\n    case \"is\":\n      setValueForAttribute(domElement, \"is\", value);\n      break;\n    case \"innerText\":\n    case \"textContent\":\n      break;\n    default:\n      if (\n        !(2 < key.length) ||\n        (\"o\" !== key[0] && \"O\" !== key[0]) ||\n        (\"n\" !== key[1] && \"N\" !== key[1])\n      )\n        (key = aliases.get(key) || key),\n          setValueForAttribute(domElement, key, value);\n  }\n}\nfunction setPropOnCustomElement(domElement, tag, key, value, props, prevValue) {\n  switch (key) {\n    case \"style\":\n      setValueForStyles(domElement, value, prevValue);\n      break;\n    case \"dangerouslySetInnerHTML\":\n      if (null != value) {\n        if (\"object\" !== typeof value || !(\"__html\" in value))\n          throw Error(formatProdErrorMessage(61));\n        key = value.__html;\n        if (null != key) {\n          if (null != props.children) throw Error(formatProdErrorMessage(60));\n          domElement.innerHTML = key;\n        }\n      }\n      break;\n    case \"children\":\n      \"string\" === typeof value\n        ? setTextContent(domElement, value)\n        : (\"number\" === typeof value || \"bigint\" === typeof value) &&\n          setTextContent(domElement, \"\" + value);\n      break;\n    case \"onScroll\":\n      null != value && listenToNonDelegatedEvent(\"scroll\", domElement);\n      break;\n    case \"onScrollEnd\":\n      null != value && listenToNonDelegatedEvent(\"scrollend\", domElement);\n      break;\n    case \"onClick\":\n      null != value && (domElement.onclick = noop$1);\n      break;\n    case \"suppressContentEditableWarning\":\n    case \"suppressHydrationWarning\":\n    case \"innerHTML\":\n    case \"ref\":\n      break;\n    case \"innerText\":\n    case \"textContent\":\n      break;\n    default:\n      if (!registrationNameDependencies.hasOwnProperty(key))\n        a: {\n          if (\n            \"o\" === key[0] &&\n            \"n\" === key[1] &&\n            ((props = key.endsWith(\"Capture\")),\n            (tag = key.slice(2, props ? key.length - 7 : void 0)),\n            (prevValue = domElement[internalPropsKey] || null),\n            (prevValue = null != prevValue ? prevValue[key] : null),\n            \"function\" === typeof prevValue &&\n              domElement.removeEventListener(tag, prevValue, props),\n            \"function\" === typeof value)\n          ) {\n            \"function\" !== typeof prevValue &&\n              null !== prevValue &&\n              (key in domElement\n                ? (domElement[key] = null)\n                : domElement.hasAttribute(key) &&\n                  domElement.removeAttribute(key));\n            domElement.addEventListener(tag, value, props);\n            break a;\n          }\n          key in domElement\n            ? (domElement[key] = value)\n            : !0 === value\n              ? domElement.setAttribute(key, \"\")\n              : setValueForAttribute(domElement, key, value);\n        }\n  }\n}\nfunction setInitialProperties(domElement, tag, props) {\n  switch (tag) {\n    case \"div\":\n    case \"span\":\n    case \"svg\":\n    case \"path\":\n    case \"a\":\n    case \"g\":\n    case \"p\":\n    case \"li\":\n      break;\n    case \"img\":\n      listenToNonDelegatedEvent(\"error\", domElement);\n      listenToNonDelegatedEvent(\"load\", domElement);\n      var hasSrc = !1,\n        hasSrcSet = !1,\n        propKey;\n      for (propKey in props)\n        if (props.hasOwnProperty(propKey)) {\n          var propValue = props[propKey];\n          if (null != propValue)\n            switch (propKey) {\n              case \"src\":\n                hasSrc = !0;\n                break;\n              case \"srcSet\":\n                hasSrcSet = !0;\n                break;\n              case \"children\":\n              case \"dangerouslySetInnerHTML\":\n                throw Error(formatProdErrorMessage(137, tag));\n              default:\n                setProp(domElement, tag, propKey, propValue, props, null);\n            }\n        }\n      hasSrcSet &&\n        setProp(domElement, tag, \"srcSet\", props.srcSet, props, null);\n      hasSrc && setProp(domElement, tag, \"src\", props.src, props, null);\n      return;\n    case \"input\":\n      listenToNonDelegatedEvent(\"invalid\", domElement);\n      var defaultValue = (propKey = propValue = hasSrcSet = null),\n        checked = null,\n        defaultChecked = null;\n      for (hasSrc in props)\n        if (props.hasOwnProperty(hasSrc)) {\n          var propValue$188 = props[hasSrc];\n          if (null != propValue$188)\n            switch (hasSrc) {\n              case \"name\":\n                hasSrcSet = propValue$188;\n                break;\n              case \"type\":\n                propValue = propValue$188;\n                break;\n              case \"checked\":\n                checked = propValue$188;\n                break;\n              case \"defaultChecked\":\n                defaultChecked = propValue$188;\n                break;\n              case \"value\":\n                propKey = propValue$188;\n                break;\n              case \"defaultValue\":\n                defaultValue = propValue$188;\n                break;\n              case \"children\":\n              case \"dangerouslySetInnerHTML\":\n                if (null != propValue$188)\n                  throw Error(formatProdErrorMessage(137, tag));\n                break;\n              default:\n                setProp(domElement, tag, hasSrc, propValue$188, props, null);\n            }\n        }\n      initInput(\n        domElement,\n        propKey,\n        defaultValue,\n        checked,\n        defaultChecked,\n        propValue,\n        hasSrcSet,\n        !1\n      );\n      track(domElement);\n      return;\n    case \"select\":\n      listenToNonDelegatedEvent(\"invalid\", domElement);\n      hasSrc = propValue = propKey = null;\n      for (hasSrcSet in props)\n        if (\n          props.hasOwnProperty(hasSrcSet) &&\n          ((defaultValue = props[hasSrcSet]), null != defaultValue)\n        )\n          switch (hasSrcSet) {\n            case \"value\":\n              propKey = defaultValue;\n              break;\n            case \"defaultValue\":\n              propValue = defaultValue;\n              break;\n            case \"multiple\":\n              hasSrc = defaultValue;\n            default:\n              setProp(domElement, tag, hasSrcSet, defaultValue, props, null);\n          }\n      tag = propKey;\n      props = propValue;\n      domElement.multiple = !!hasSrc;\n      null != tag\n        ? updateOptions(domElement, !!hasSrc, tag, !1)\n        : null != props && updateOptions(domElement, !!hasSrc, props, !0);\n      return;\n    case \"textarea\":\n      listenToNonDelegatedEvent(\"invalid\", domElement);\n      propKey = hasSrcSet = hasSrc = null;\n      for (propValue in props)\n        if (\n          props.hasOwnProperty(propValue) &&\n          ((defaultValue = props[propValue]), null != defaultValue)\n        )\n          switch (propValue) {\n            case \"value\":\n              hasSrc = defaultValue;\n              break;\n            case \"defaultValue\":\n              hasSrcSet = defaultValue;\n              break;\n            case \"children\":\n              propKey = defaultValue;\n              break;\n            case \"dangerouslySetInnerHTML\":\n              if (null != defaultValue) throw Error(formatProdErrorMessage(91));\n              break;\n            default:\n              setProp(domElement, tag, propValue, defaultValue, props, null);\n          }\n      initTextarea(domElement, hasSrc, hasSrcSet, propKey);\n      track(domElement);\n      return;\n    case \"option\":\n      for (checked in props)\n        if (\n          props.hasOwnProperty(checked) &&\n          ((hasSrc = props[checked]), null != hasSrc)\n        )\n          switch (checked) {\n            case \"selected\":\n              domElement.selected =\n                hasSrc &&\n                \"function\" !== typeof hasSrc &&\n                \"symbol\" !== typeof hasSrc;\n              break;\n            default:\n              setProp(domElement, tag, checked, hasSrc, props, null);\n          }\n      return;\n    case \"dialog\":\n      listenToNonDelegatedEvent(\"beforetoggle\", domElement);\n      listenToNonDelegatedEvent(\"toggle\", domElement);\n      listenToNonDelegatedEvent(\"cancel\", domElement);\n      listenToNonDelegatedEvent(\"close\", domElement);\n      break;\n    case \"iframe\":\n    case \"object\":\n      listenToNonDelegatedEvent(\"load\", domElement);\n      break;\n    case \"video\":\n    case \"audio\":\n      for (hasSrc = 0; hasSrc < mediaEventTypes.length; hasSrc++)\n        listenToNonDelegatedEvent(mediaEventTypes[hasSrc], domElement);\n      break;\n    case \"image\":\n      listenToNonDelegatedEvent(\"error\", domElement);\n      listenToNonDelegatedEvent(\"load\", domElement);\n      break;\n    case \"details\":\n      listenToNonDelegatedEvent(\"toggle\", domElement);\n      break;\n    case \"embed\":\n    case \"source\":\n    case \"link\":\n      listenToNonDelegatedEvent(\"error\", domElement),\n        listenToNonDelegatedEvent(\"load\", domElement);\n    case \"area\":\n    case \"base\":\n    case \"br\":\n    case \"col\":\n    case \"hr\":\n    case \"keygen\":\n    case \"meta\":\n    case \"param\":\n    case \"track\":\n    case \"wbr\":\n    case \"menuitem\":\n      for (defaultChecked in props)\n        if (\n          props.hasOwnProperty(defaultChecked) &&\n          ((hasSrc = props[defaultChecked]), null != hasSrc)\n        )\n          switch (defaultChecked) {\n            case \"children\":\n            case \"dangerouslySetInnerHTML\":\n              throw Error(formatProdErrorMessage(137, tag));\n            default:\n              setProp(domElement, tag, defaultChecked, hasSrc, props, null);\n          }\n      return;\n    default:\n      if (isCustomElement(tag)) {\n        for (propValue$188 in props)\n          props.hasOwnProperty(propValue$188) &&\n            ((hasSrc = props[propValue$188]),\n            void 0 !== hasSrc &&\n              setPropOnCustomElement(\n                domElement,\n                tag,\n                propValue$188,\n                hasSrc,\n                props,\n                void 0\n              ));\n        return;\n      }\n  }\n  for (defaultValue in props)\n    props.hasOwnProperty(defaultValue) &&\n      ((hasSrc = props[defaultValue]),\n      null != hasSrc &&\n        setProp(domElement, tag, defaultValue, hasSrc, props, null));\n}\nfunction updateProperties(domElement, tag, lastProps, nextProps) {\n  switch (tag) {\n    case \"div\":\n    case \"span\":\n    case \"svg\":\n    case \"path\":\n    case \"a\":\n    case \"g\":\n    case \"p\":\n    case \"li\":\n      break;\n    case \"input\":\n      var name = null,\n        type = null,\n        value = null,\n        defaultValue = null,\n        lastDefaultValue = null,\n        checked = null,\n        defaultChecked = null;\n      for (propKey in lastProps) {\n        var lastProp = lastProps[propKey];\n        if (lastProps.hasOwnProperty(propKey) && null != lastProp)\n          switch (propKey) {\n            case \"checked\":\n              break;\n            case \"value\":\n              break;\n            case \"defaultValue\":\n              lastDefaultValue = lastProp;\n            default:\n              nextProps.hasOwnProperty(propKey) ||\n                setProp(domElement, tag, propKey, null, nextProps, lastProp);\n          }\n      }\n      for (var propKey$205 in nextProps) {\n        var propKey = nextProps[propKey$205];\n        lastProp = lastProps[propKey$205];\n        if (\n          nextProps.hasOwnProperty(propKey$205) &&\n          (null != propKey || null != lastProp)\n        )\n          switch (propKey$205) {\n            case \"type\":\n              type = propKey;\n              break;\n            case \"name\":\n              name = propKey;\n              break;\n            case \"checked\":\n              checked = propKey;\n              break;\n            case \"defaultChecked\":\n              defaultChecked = propKey;\n              break;\n            case \"value\":\n              value = propKey;\n              break;\n            case \"defaultValue\":\n              defaultValue = propKey;\n              break;\n            case \"children\":\n            case \"dangerouslySetInnerHTML\":\n              if (null != propKey)\n                throw Error(formatProdErrorMessage(137, tag));\n              break;\n            default:\n              propKey !== lastProp &&\n                setProp(\n                  domElement,\n                  tag,\n                  propKey$205,\n                  propKey,\n                  nextProps,\n                  lastProp\n                );\n          }\n      }\n      updateInput(\n        domElement,\n        value,\n        defaultValue,\n        lastDefaultValue,\n        checked,\n        defaultChecked,\n        type,\n        name\n      );\n      return;\n    case \"select\":\n      propKey = value = defaultValue = propKey$205 = null;\n      for (type in lastProps)\n        if (\n          ((lastDefaultValue = lastProps[type]),\n          lastProps.hasOwnProperty(type) && null != lastDefaultValue)\n        )\n          switch (type) {\n            case \"value\":\n              break;\n            case \"multiple\":\n              propKey = lastDefaultValue;\n            default:\n              nextProps.hasOwnProperty(type) ||\n                setProp(\n                  domElement,\n                  tag,\n                  type,\n                  null,\n                  nextProps,\n                  lastDefaultValue\n                );\n          }\n      for (name in nextProps)\n        if (\n          ((type = nextProps[name]),\n          (lastDefaultValue = lastProps[name]),\n          nextProps.hasOwnProperty(name) &&\n            (null != type || null != lastDefaultValue))\n        )\n          switch (name) {\n            case \"value\":\n              propKey$205 = type;\n              break;\n            case \"defaultValue\":\n              defaultValue = type;\n              break;\n            case \"multiple\":\n              value = type;\n            default:\n              type !== lastDefaultValue &&\n                setProp(\n                  domElement,\n                  tag,\n                  name,\n                  type,\n                  nextProps,\n                  lastDefaultValue\n                );\n          }\n      tag = defaultValue;\n      lastProps = value;\n      nextProps = propKey;\n      null != propKey$205\n        ? updateOptions(domElement, !!lastProps, propKey$205, !1)\n        : !!nextProps !== !!lastProps &&\n          (null != tag\n            ? updateOptions(domElement, !!lastProps, tag, !0)\n            : updateOptions(domElement, !!lastProps, lastProps ? [] : \"\", !1));\n      return;\n    case \"textarea\":\n      propKey = propKey$205 = null;\n      for (defaultValue in lastProps)\n        if (\n          ((name = lastProps[defaultValue]),\n          lastProps.hasOwnProperty(defaultValue) &&\n            null != name &&\n            !nextProps.hasOwnProperty(defaultValue))\n        )\n          switch (defaultValue) {\n            case \"value\":\n              break;\n            case \"children\":\n              break;\n            default:\n              setProp(domElement, tag, defaultValue, null, nextProps, name);\n          }\n      for (value in nextProps)\n        if (\n          ((name = nextProps[value]),\n          (type = lastProps[value]),\n          nextProps.hasOwnProperty(value) && (null != name || null != type))\n        )\n          switch (value) {\n            case \"value\":\n              propKey$205 = name;\n              break;\n            case \"defaultValue\":\n              propKey = name;\n              break;\n            case \"children\":\n              break;\n            case \"dangerouslySetInnerHTML\":\n              if (null != name) throw Error(formatProdErrorMessage(91));\n              break;\n            default:\n              name !== type &&\n                setProp(domElement, tag, value, name, nextProps, type);\n          }\n      updateTextarea(domElement, propKey$205, propKey);\n      return;\n    case \"option\":\n      for (var propKey$221 in lastProps)\n        if (\n          ((propKey$205 = lastProps[propKey$221]),\n          lastProps.hasOwnProperty(propKey$221) &&\n            null != propKey$205 &&\n            !nextProps.hasOwnProperty(propKey$221))\n        )\n          switch (propKey$221) {\n            case \"selected\":\n              domElement.selected = !1;\n              break;\n            default:\n              setProp(\n                domElement,\n                tag,\n                propKey$221,\n                null,\n                nextProps,\n                propKey$205\n              );\n          }\n      for (lastDefaultValue in nextProps)\n        if (\n          ((propKey$205 = nextProps[lastDefaultValue]),\n          (propKey = lastProps[lastDefaultValue]),\n          nextProps.hasOwnProperty(lastDefaultValue) &&\n            propKey$205 !== propKey &&\n            (null != propKey$205 || null != propKey))\n        )\n          switch (lastDefaultValue) {\n            case \"selected\":\n              domElement.selected =\n                propKey$205 &&\n                \"function\" !== typeof propKey$205 &&\n                \"symbol\" !== typeof propKey$205;\n              break;\n            default:\n              setProp(\n                domElement,\n                tag,\n                lastDefaultValue,\n                propKey$205,\n                nextProps,\n                propKey\n              );\n          }\n      return;\n    case \"img\":\n    case \"link\":\n    case \"area\":\n    case \"base\":\n    case \"br\":\n    case \"col\":\n    case \"embed\":\n    case \"hr\":\n    case \"keygen\":\n    case \"meta\":\n    case \"param\":\n    case \"source\":\n    case \"track\":\n    case \"wbr\":\n    case \"menuitem\":\n      for (var propKey$226 in lastProps)\n        (propKey$205 = lastProps[propKey$226]),\n          lastProps.hasOwnProperty(propKey$226) &&\n            null != propKey$205 &&\n            !nextProps.hasOwnProperty(propKey$226) &&\n            setProp(domElement, tag, propKey$226, null, nextProps, propKey$205);\n      for (checked in nextProps)\n        if (\n          ((propKey$205 = nextProps[checked]),\n          (propKey = lastProps[checked]),\n          nextProps.hasOwnProperty(checked) &&\n            propKey$205 !== propKey &&\n            (null != propKey$205 || null != propKey))\n        )\n          switch (checked) {\n            case \"children\":\n            case \"dangerouslySetInnerHTML\":\n              if (null != propKey$205)\n                throw Error(formatProdErrorMessage(137, tag));\n              break;\n            default:\n              setProp(\n                domElement,\n                tag,\n                checked,\n                propKey$205,\n                nextProps,\n                propKey\n              );\n          }\n      return;\n    default:\n      if (isCustomElement(tag)) {\n        for (var propKey$231 in lastProps)\n          (propKey$205 = lastProps[propKey$231]),\n            lastProps.hasOwnProperty(propKey$231) &&\n              void 0 !== propKey$205 &&\n              !nextProps.hasOwnProperty(propKey$231) &&\n              setPropOnCustomElement(\n                domElement,\n                tag,\n                propKey$231,\n                void 0,\n                nextProps,\n                propKey$205\n              );\n        for (defaultChecked in nextProps)\n          (propKey$205 = nextProps[defaultChecked]),\n            (propKey = lastProps[defaultChecked]),\n            !nextProps.hasOwnProperty(defaultChecked) ||\n              propKey$205 === propKey ||\n              (void 0 === propKey$205 && void 0 === propKey) ||\n              setPropOnCustomElement(\n                domElement,\n                tag,\n                defaultChecked,\n                propKey$205,\n                nextProps,\n                propKey\n              );\n        return;\n      }\n  }\n  for (var propKey$236 in lastProps)\n    (propKey$205 = lastProps[propKey$236]),\n      lastProps.hasOwnProperty(propKey$236) &&\n        null != propKey$205 &&\n        !nextProps.hasOwnProperty(propKey$236) &&\n        setProp(domElement, tag, propKey$236, null, nextProps, propKey$205);\n  for (lastProp in nextProps)\n    (propKey$205 = nextProps[lastProp]),\n      (propKey = lastProps[lastProp]),\n      !nextProps.hasOwnProperty(lastProp) ||\n        propKey$205 === propKey ||\n        (null == propKey$205 && null == propKey) ||\n        setProp(domElement, tag, lastProp, propKey$205, nextProps, propKey);\n}\nvar eventsEnabled = null,\n  selectionInformation = null;\nfunction getOwnerDocumentFromRootContainer(rootContainerElement) {\n  return 9 === rootContainerElement.nodeType\n    ? rootContainerElement\n    : rootContainerElement.ownerDocument;\n}\nfunction getOwnHostContext(namespaceURI) {\n  switch (namespaceURI) {\n    case \"http://www.w3.org/2000/svg\":\n      return 1;\n    case \"http://www.w3.org/1998/Math/MathML\":\n      return 2;\n    default:\n      return 0;\n  }\n}\nfunction getChildHostContextProd(parentNamespace, type) {\n  if (0 === parentNamespace)\n    switch (type) {\n      case \"svg\":\n        return 1;\n      case \"math\":\n        return 2;\n      default:\n        return 0;\n    }\n  return 1 === parentNamespace && \"foreignObject\" === type\n    ? 0\n    : parentNamespace;\n}\nfunction shouldSetTextContent(type, props) {\n  return (\n    \"textarea\" === type ||\n    \"noscript\" === type ||\n    \"string\" === typeof props.children ||\n    \"number\" === typeof props.children ||\n    \"bigint\" === typeof props.children ||\n    (\"object\" === typeof props.dangerouslySetInnerHTML &&\n      null !== props.dangerouslySetInnerHTML &&\n      null != props.dangerouslySetInnerHTML.__html)\n  );\n}\nvar currentPopstateTransitionEvent = null;\nfunction shouldAttemptEagerTransition() {\n  var event = window.event;\n  if (event && \"popstate\" === event.type) {\n    if (event === currentPopstateTransitionEvent) return !1;\n    currentPopstateTransitionEvent = event;\n    return !0;\n  }\n  currentPopstateTransitionEvent = null;\n  return !1;\n}\nvar scheduleTimeout = \"function\" === typeof setTimeout ? setTimeout : void 0,\n  cancelTimeout = \"function\" === typeof clearTimeout ? clearTimeout : void 0,\n  localPromise = \"function\" === typeof Promise ? Promise : void 0,\n  scheduleMicrotask =\n    \"function\" === typeof queueMicrotask\n      ? queueMicrotask\n      : \"undefined\" !== typeof localPromise\n        ? function (callback) {\n            return localPromise\n              .resolve(null)\n              .then(callback)\n              .catch(handleErrorInNextTick);\n          }\n        : scheduleTimeout;\nfunction handleErrorInNextTick(error) {\n  setTimeout(function () {\n    throw error;\n  });\n}\nfunction isSingletonScope(type) {\n  return \"head\" === type;\n}\nfunction clearSuspenseBoundary(parentInstance, suspenseInstance) {\n  var node = suspenseInstance,\n    possiblePreambleContribution = 0,\n    depth = 0;\n  do {\n    var nextNode = node.nextSibling;\n    parentInstance.removeChild(node);\n    if (nextNode && 8 === nextNode.nodeType)\n      if (((node = nextNode.data), \"/$\" === node)) {\n        if (\n          0 < possiblePreambleContribution &&\n          8 > possiblePreambleContribution\n        ) {\n          node = possiblePreambleContribution;\n          var ownerDocument = parentInstance.ownerDocument;\n          node & 1 && releaseSingletonInstance(ownerDocument.documentElement);\n          node & 2 && releaseSingletonInstance(ownerDocument.body);\n          if (node & 4)\n            for (\n              node = ownerDocument.head,\n                releaseSingletonInstance(node),\n                ownerDocument = node.firstChild;\n              ownerDocument;\n\n            ) {\n              var nextNode$jscomp$0 = ownerDocument.nextSibling,\n                nodeName = ownerDocument.nodeName;\n              ownerDocument[internalHoistableMarker] ||\n                \"SCRIPT\" === nodeName ||\n                \"STYLE\" === nodeName ||\n                (\"LINK\" === nodeName &&\n                  \"stylesheet\" === ownerDocument.rel.toLowerCase()) ||\n                node.removeChild(ownerDocument);\n              ownerDocument = nextNode$jscomp$0;\n            }\n        }\n        if (0 === depth) {\n          parentInstance.removeChild(nextNode);\n          retryIfBlockedOn(suspenseInstance);\n          return;\n        }\n        depth--;\n      } else\n        \"$\" === node || \"$?\" === node || \"$!\" === node\n          ? depth++\n          : (possiblePreambleContribution = node.charCodeAt(0) - 48);\n    else possiblePreambleContribution = 0;\n    node = nextNode;\n  } while (node);\n  retryIfBlockedOn(suspenseInstance);\n}\nfunction clearContainerSparingly(container) {\n  var nextNode = container.firstChild;\n  nextNode && 10 === nextNode.nodeType && (nextNode = nextNode.nextSibling);\n  for (; nextNode; ) {\n    var node = nextNode;\n    nextNode = nextNode.nextSibling;\n    switch (node.nodeName) {\n      case \"HTML\":\n      case \"HEAD\":\n      case \"BODY\":\n        clearContainerSparingly(node);\n        detachDeletedInstance(node);\n        continue;\n      case \"SCRIPT\":\n      case \"STYLE\":\n        continue;\n      case \"LINK\":\n        if (\"stylesheet\" === node.rel.toLowerCase()) continue;\n    }\n    container.removeChild(node);\n  }\n}\nfunction canHydrateInstance(instance, type, props, inRootOrSingleton) {\n  for (; 1 === instance.nodeType; ) {\n    var anyProps = props;\n    if (instance.nodeName.toLowerCase() !== type.toLowerCase()) {\n      if (\n        !inRootOrSingleton &&\n        (\"INPUT\" !== instance.nodeName || \"hidden\" !== instance.type)\n      )\n        break;\n    } else if (!inRootOrSingleton)\n      if (\"input\" === type && \"hidden\" === instance.type) {\n        var name = null == anyProps.name ? null : \"\" + anyProps.name;\n        if (\n          \"hidden\" === anyProps.type &&\n          instance.getAttribute(\"name\") === name\n        )\n          return instance;\n      } else return instance;\n    else if (!instance[internalHoistableMarker])\n      switch (type) {\n        case \"meta\":\n          if (!instance.hasAttribute(\"itemprop\")) break;\n          return instance;\n        case \"link\":\n          name = instance.getAttribute(\"rel\");\n          if (\"stylesheet\" === name && instance.hasAttribute(\"data-precedence\"))\n            break;\n          else if (\n            name !== anyProps.rel ||\n            instance.getAttribute(\"href\") !==\n              (null == anyProps.href || \"\" === anyProps.href\n                ? null\n                : anyProps.href) ||\n            instance.getAttribute(\"crossorigin\") !==\n              (null == anyProps.crossOrigin ? null : anyProps.crossOrigin) ||\n            instance.getAttribute(\"title\") !==\n              (null == anyProps.title ? null : anyProps.title)\n          )\n            break;\n          return instance;\n        case \"style\":\n          if (instance.hasAttribute(\"data-precedence\")) break;\n          return instance;\n        case \"script\":\n          name = instance.getAttribute(\"src\");\n          if (\n            (name !== (null == anyProps.src ? null : anyProps.src) ||\n              instance.getAttribute(\"type\") !==\n                (null == anyProps.type ? null : anyProps.type) ||\n              instance.getAttribute(\"crossorigin\") !==\n                (null == anyProps.crossOrigin ? null : anyProps.crossOrigin)) &&\n            name &&\n            instance.hasAttribute(\"async\") &&\n            !instance.hasAttribute(\"itemprop\")\n          )\n            break;\n          return instance;\n        default:\n          return instance;\n      }\n    instance = getNextHydratable(instance.nextSibling);\n    if (null === instance) break;\n  }\n  return null;\n}\nfunction canHydrateTextInstance(instance, text, inRootOrSingleton) {\n  if (\"\" === text) return null;\n  for (; 3 !== instance.nodeType; ) {\n    if (\n      (1 !== instance.nodeType ||\n        \"INPUT\" !== instance.nodeName ||\n        \"hidden\" !== instance.type) &&\n      !inRootOrSingleton\n    )\n      return null;\n    instance = getNextHydratable(instance.nextSibling);\n    if (null === instance) return null;\n  }\n  return instance;\n}\nfunction isSuspenseInstanceFallback(instance) {\n  return (\n    \"$!\" === instance.data ||\n    (\"$?\" === instance.data && \"complete\" === instance.ownerDocument.readyState)\n  );\n}\nfunction registerSuspenseInstanceRetry(instance, callback) {\n  var ownerDocument = instance.ownerDocument;\n  if (\"$?\" !== instance.data || \"complete\" === ownerDocument.readyState)\n    callback();\n  else {\n    var listener = function () {\n      callback();\n      ownerDocument.removeEventListener(\"DOMContentLoaded\", listener);\n    };\n    ownerDocument.addEventListener(\"DOMContentLoaded\", listener);\n    instance._reactRetry = listener;\n  }\n}\nfunction getNextHydratable(node) {\n  for (; null != node; node = node.nextSibling) {\n    var nodeType = node.nodeType;\n    if (1 === nodeType || 3 === nodeType) break;\n    if (8 === nodeType) {\n      nodeType = node.data;\n      if (\n        \"$\" === nodeType ||\n        \"$!\" === nodeType ||\n        \"$?\" === nodeType ||\n        \"F!\" === nodeType ||\n        \"F\" === nodeType\n      )\n        break;\n      if (\"/$\" === nodeType) return null;\n    }\n  }\n  return node;\n}\nvar previousHydratableOnEnteringScopedSingleton = null;\nfunction getParentSuspenseInstance(targetInstance) {\n  targetInstance = targetInstance.previousSibling;\n  for (var depth = 0; targetInstance; ) {\n    if (8 === targetInstance.nodeType) {\n      var data = targetInstance.data;\n      if (\"$\" === data || \"$!\" === data || \"$?\" === data) {\n        if (0 === depth) return targetInstance;\n        depth--;\n      } else \"/$\" === data && depth++;\n    }\n    targetInstance = targetInstance.previousSibling;\n  }\n  return null;\n}\nfunction resolveSingletonInstance(type, props, rootContainerInstance) {\n  props = getOwnerDocumentFromRootContainer(rootContainerInstance);\n  switch (type) {\n    case \"html\":\n      type = props.documentElement;\n      if (!type) throw Error(formatProdErrorMessage(452));\n      return type;\n    case \"head\":\n      type = props.head;\n      if (!type) throw Error(formatProdErrorMessage(453));\n      return type;\n    case \"body\":\n      type = props.body;\n      if (!type) throw Error(formatProdErrorMessage(454));\n      return type;\n    default:\n      throw Error(formatProdErrorMessage(451));\n  }\n}\nfunction releaseSingletonInstance(instance) {\n  for (var attributes = instance.attributes; attributes.length; )\n    instance.removeAttributeNode(attributes[0]);\n  detachDeletedInstance(instance);\n}\nvar preloadPropsMap = new Map(),\n  preconnectsSet = new Set();\nfunction getHoistableRoot(container) {\n  return \"function\" === typeof container.getRootNode\n    ? container.getRootNode()\n    : 9 === container.nodeType\n      ? container\n      : container.ownerDocument;\n}\nvar previousDispatcher = ReactDOMSharedInternals.d;\nReactDOMSharedInternals.d = {\n  f: flushSyncWork,\n  r: requestFormReset,\n  D: prefetchDNS,\n  C: preconnect,\n  L: preload,\n  m: preloadModule,\n  X: preinitScript,\n  S: preinitStyle,\n  M: preinitModuleScript\n};\nfunction flushSyncWork() {\n  var previousWasRendering = previousDispatcher.f(),\n    wasRendering = flushSyncWork$1();\n  return previousWasRendering || wasRendering;\n}\nfunction requestFormReset(form) {\n  var formInst = getInstanceFromNode(form);\n  null !== formInst && 5 === formInst.tag && \"form\" === formInst.type\n    ? requestFormReset$1(formInst)\n    : previousDispatcher.r(form);\n}\nvar globalDocument = \"undefined\" === typeof document ? null : document;\nfunction preconnectAs(rel, href, crossOrigin) {\n  var ownerDocument = globalDocument;\n  if (ownerDocument && \"string\" === typeof href && href) {\n    var limitedEscapedHref =\n      escapeSelectorAttributeValueInsideDoubleQuotes(href);\n    limitedEscapedHref =\n      'link[rel=\"' + rel + '\"][href=\"' + limitedEscapedHref + '\"]';\n    \"string\" === typeof crossOrigin &&\n      (limitedEscapedHref += '[crossorigin=\"' + crossOrigin + '\"]');\n    preconnectsSet.has(limitedEscapedHref) ||\n      (preconnectsSet.add(limitedEscapedHref),\n      (rel = { rel: rel, crossOrigin: crossOrigin, href: href }),\n      null === ownerDocument.querySelector(limitedEscapedHref) &&\n        ((href = ownerDocument.createElement(\"link\")),\n        setInitialProperties(href, \"link\", rel),\n        markNodeAsHoistable(href),\n        ownerDocument.head.appendChild(href)));\n  }\n}\nfunction prefetchDNS(href) {\n  previousDispatcher.D(href);\n  preconnectAs(\"dns-prefetch\", href, null);\n}\nfunction preconnect(href, crossOrigin) {\n  previousDispatcher.C(href, crossOrigin);\n  preconnectAs(\"preconnect\", href, crossOrigin);\n}\nfunction preload(href, as, options) {\n  previousDispatcher.L(href, as, options);\n  var ownerDocument = globalDocument;\n  if (ownerDocument && href && as) {\n    var preloadSelector =\n      'link[rel=\"preload\"][as=\"' +\n      escapeSelectorAttributeValueInsideDoubleQuotes(as) +\n      '\"]';\n    \"image\" === as\n      ? options && options.imageSrcSet\n        ? ((preloadSelector +=\n            '[imagesrcset=\"' +\n            escapeSelectorAttributeValueInsideDoubleQuotes(\n              options.imageSrcSet\n            ) +\n            '\"]'),\n          \"string\" === typeof options.imageSizes &&\n            (preloadSelector +=\n              '[imagesizes=\"' +\n              escapeSelectorAttributeValueInsideDoubleQuotes(\n                options.imageSizes\n              ) +\n              '\"]'))\n        : (preloadSelector +=\n            '[href=\"' +\n            escapeSelectorAttributeValueInsideDoubleQuotes(href) +\n            '\"]')\n      : (preloadSelector +=\n          '[href=\"' +\n          escapeSelectorAttributeValueInsideDoubleQuotes(href) +\n          '\"]');\n    var key = preloadSelector;\n    switch (as) {\n      case \"style\":\n        key = getStyleKey(href);\n        break;\n      case \"script\":\n        key = getScriptKey(href);\n    }\n    preloadPropsMap.has(key) ||\n      ((href = assign(\n        {\n          rel: \"preload\",\n          href:\n            \"image\" === as && options && options.imageSrcSet ? void 0 : href,\n          as: as\n        },\n        options\n      )),\n      preloadPropsMap.set(key, href),\n      null !== ownerDocument.querySelector(preloadSelector) ||\n        (\"style\" === as &&\n          ownerDocument.querySelector(getStylesheetSelectorFromKey(key))) ||\n        (\"script\" === as &&\n          ownerDocument.querySelector(getScriptSelectorFromKey(key))) ||\n        ((as = ownerDocument.createElement(\"link\")),\n        setInitialProperties(as, \"link\", href),\n        markNodeAsHoistable(as),\n        ownerDocument.head.appendChild(as)));\n  }\n}\nfunction preloadModule(href, options) {\n  previousDispatcher.m(href, options);\n  var ownerDocument = globalDocument;\n  if (ownerDocument && href) {\n    var as = options && \"string\" === typeof options.as ? options.as : \"script\",\n      preloadSelector =\n        'link[rel=\"modulepreload\"][as=\"' +\n        escapeSelectorAttributeValueInsideDoubleQuotes(as) +\n        '\"][href=\"' +\n        escapeSelectorAttributeValueInsideDoubleQuotes(href) +\n        '\"]',\n      key = preloadSelector;\n    switch (as) {\n      case \"audioworklet\":\n      case \"paintworklet\":\n      case \"serviceworker\":\n      case \"sharedworker\":\n      case \"worker\":\n      case \"script\":\n        key = getScriptKey(href);\n    }\n    if (\n      !preloadPropsMap.has(key) &&\n      ((href = assign({ rel: \"modulepreload\", href: href }, options)),\n      preloadPropsMap.set(key, href),\n      null === ownerDocument.querySelector(preloadSelector))\n    ) {\n      switch (as) {\n        case \"audioworklet\":\n        case \"paintworklet\":\n        case \"serviceworker\":\n        case \"sharedworker\":\n        case \"worker\":\n        case \"script\":\n          if (ownerDocument.querySelector(getScriptSelectorFromKey(key)))\n            return;\n      }\n      as = ownerDocument.createElement(\"link\");\n      setInitialProperties(as, \"link\", href);\n      markNodeAsHoistable(as);\n      ownerDocument.head.appendChild(as);\n    }\n  }\n}\nfunction preinitStyle(href, precedence, options) {\n  previousDispatcher.S(href, precedence, options);\n  var ownerDocument = globalDocument;\n  if (ownerDocument && href) {\n    var styles = getResourcesFromRoot(ownerDocument).hoistableStyles,\n      key = getStyleKey(href);\n    precedence = precedence || \"default\";\n    var resource = styles.get(key);\n    if (!resource) {\n      var state = { loading: 0, preload: null };\n      if (\n        (resource = ownerDocument.querySelector(\n          getStylesheetSelectorFromKey(key)\n        ))\n      )\n        state.loading = 5;\n      else {\n        href = assign(\n          { rel: \"stylesheet\", href: href, \"data-precedence\": precedence },\n          options\n        );\n        (options = preloadPropsMap.get(key)) &&\n          adoptPreloadPropsForStylesheet(href, options);\n        var link = (resource = ownerDocument.createElement(\"link\"));\n        markNodeAsHoistable(link);\n        setInitialProperties(link, \"link\", href);\n        link._p = new Promise(function (resolve, reject) {\n          link.onload = resolve;\n          link.onerror = reject;\n        });\n        link.addEventListener(\"load\", function () {\n          state.loading |= 1;\n        });\n        link.addEventListener(\"error\", function () {\n          state.loading |= 2;\n        });\n        state.loading |= 4;\n        insertStylesheet(resource, precedence, ownerDocument);\n      }\n      resource = {\n        type: \"stylesheet\",\n        instance: resource,\n        count: 1,\n        state: state\n      };\n      styles.set(key, resource);\n    }\n  }\n}\nfunction preinitScript(src, options) {\n  previousDispatcher.X(src, options);\n  var ownerDocument = globalDocument;\n  if (ownerDocument && src) {\n    var scripts = getResourcesFromRoot(ownerDocument).hoistableScripts,\n      key = getScriptKey(src),\n      resource = scripts.get(key);\n    resource ||\n      ((resource = ownerDocument.querySelector(getScriptSelectorFromKey(key))),\n      resource ||\n        ((src = assign({ src: src, async: !0 }, options)),\n        (options = preloadPropsMap.get(key)) &&\n          adoptPreloadPropsForScript(src, options),\n        (resource = ownerDocument.createElement(\"script\")),\n        markNodeAsHoistable(resource),\n        setInitialProperties(resource, \"link\", src),\n        ownerDocument.head.appendChild(resource)),\n      (resource = {\n        type: \"script\",\n        instance: resource,\n        count: 1,\n        state: null\n      }),\n      scripts.set(key, resource));\n  }\n}\nfunction preinitModuleScript(src, options) {\n  previousDispatcher.M(src, options);\n  var ownerDocument = globalDocument;\n  if (ownerDocument && src) {\n    var scripts = getResourcesFromRoot(ownerDocument).hoistableScripts,\n      key = getScriptKey(src),\n      resource = scripts.get(key);\n    resource ||\n      ((resource = ownerDocument.querySelector(getScriptSelectorFromKey(key))),\n      resource ||\n        ((src = assign({ src: src, async: !0, type: \"module\" }, options)),\n        (options = preloadPropsMap.get(key)) &&\n          adoptPreloadPropsForScript(src, options),\n        (resource = ownerDocument.createElement(\"script\")),\n        markNodeAsHoistable(resource),\n        setInitialProperties(resource, \"link\", src),\n        ownerDocument.head.appendChild(resource)),\n      (resource = {\n        type: \"script\",\n        instance: resource,\n        count: 1,\n        state: null\n      }),\n      scripts.set(key, resource));\n  }\n}\nfunction getResource(type, currentProps, pendingProps, currentResource) {\n  var JSCompiler_inline_result = (JSCompiler_inline_result =\n    rootInstanceStackCursor.current)\n    ? getHoistableRoot(JSCompiler_inline_result)\n    : null;\n  if (!JSCompiler_inline_result) throw Error(formatProdErrorMessage(446));\n  switch (type) {\n    case \"meta\":\n    case \"title\":\n      return null;\n    case \"style\":\n      return \"string\" === typeof pendingProps.precedence &&\n        \"string\" === typeof pendingProps.href\n        ? ((currentProps = getStyleKey(pendingProps.href)),\n          (pendingProps = getResourcesFromRoot(\n            JSCompiler_inline_result\n          ).hoistableStyles),\n          (currentResource = pendingProps.get(currentProps)),\n          currentResource ||\n            ((currentResource = {\n              type: \"style\",\n              instance: null,\n              count: 0,\n              state: null\n            }),\n            pendingProps.set(currentProps, currentResource)),\n          currentResource)\n        : { type: \"void\", instance: null, count: 0, state: null };\n    case \"link\":\n      if (\n        \"stylesheet\" === pendingProps.rel &&\n        \"string\" === typeof pendingProps.href &&\n        \"string\" === typeof pendingProps.precedence\n      ) {\n        type = getStyleKey(pendingProps.href);\n        var styles$244 = getResourcesFromRoot(\n            JSCompiler_inline_result\n          ).hoistableStyles,\n          resource$245 = styles$244.get(type);\n        resource$245 ||\n          ((JSCompiler_inline_result =\n            JSCompiler_inline_result.ownerDocument || JSCompiler_inline_result),\n          (resource$245 = {\n            type: \"stylesheet\",\n            instance: null,\n            count: 0,\n            state: { loading: 0, preload: null }\n          }),\n          styles$244.set(type, resource$245),\n          (styles$244 = JSCompiler_inline_result.querySelector(\n            getStylesheetSelectorFromKey(type)\n          )) &&\n            !styles$244._p &&\n            ((resource$245.instance = styles$244),\n            (resource$245.state.loading = 5)),\n          preloadPropsMap.has(type) ||\n            ((pendingProps = {\n              rel: \"preload\",\n              as: \"style\",\n              href: pendingProps.href,\n              crossOrigin: pendingProps.crossOrigin,\n              integrity: pendingProps.integrity,\n              media: pendingProps.media,\n              hrefLang: pendingProps.hrefLang,\n              referrerPolicy: pendingProps.referrerPolicy\n            }),\n            preloadPropsMap.set(type, pendingProps),\n            styles$244 ||\n              preloadStylesheet(\n                JSCompiler_inline_result,\n                type,\n                pendingProps,\n                resource$245.state\n              )));\n        if (currentProps && null === currentResource)\n          throw Error(formatProdErrorMessage(528, \"\"));\n        return resource$245;\n      }\n      if (currentProps && null !== currentResource)\n        throw Error(formatProdErrorMessage(529, \"\"));\n      return null;\n    case \"script\":\n      return (\n        (currentProps = pendingProps.async),\n        (pendingProps = pendingProps.src),\n        \"string\" === typeof pendingProps &&\n        currentProps &&\n        \"function\" !== typeof currentProps &&\n        \"symbol\" !== typeof currentProps\n          ? ((currentProps = getScriptKey(pendingProps)),\n            (pendingProps = getResourcesFromRoot(\n              JSCompiler_inline_result\n            ).hoistableScripts),\n            (currentResource = pendingProps.get(currentProps)),\n            currentResource ||\n              ((currentResource = {\n                type: \"script\",\n                instance: null,\n                count: 0,\n                state: null\n              }),\n              pendingProps.set(currentProps, currentResource)),\n            currentResource)\n          : { type: \"void\", instance: null, count: 0, state: null }\n      );\n    default:\n      throw Error(formatProdErrorMessage(444, type));\n  }\n}\nfunction getStyleKey(href) {\n  return 'href=\"' + escapeSelectorAttributeValueInsideDoubleQuotes(href) + '\"';\n}\nfunction getStylesheetSelectorFromKey(key) {\n  return 'link[rel=\"stylesheet\"][' + key + \"]\";\n}\nfunction stylesheetPropsFromRawProps(rawProps) {\n  return assign({}, rawProps, {\n    \"data-precedence\": rawProps.precedence,\n    precedence: null\n  });\n}\nfunction preloadStylesheet(ownerDocument, key, preloadProps, state) {\n  ownerDocument.querySelector('link[rel=\"preload\"][as=\"style\"][' + key + \"]\")\n    ? (state.loading = 1)\n    : ((key = ownerDocument.createElement(\"link\")),\n      (state.preload = key),\n      key.addEventListener(\"load\", function () {\n        return (state.loading |= 1);\n      }),\n      key.addEventListener(\"error\", function () {\n        return (state.loading |= 2);\n      }),\n      setInitialProperties(key, \"link\", preloadProps),\n      markNodeAsHoistable(key),\n      ownerDocument.head.appendChild(key));\n}\nfunction getScriptKey(src) {\n  return '[src=\"' + escapeSelectorAttributeValueInsideDoubleQuotes(src) + '\"]';\n}\nfunction getScriptSelectorFromKey(key) {\n  return \"script[async]\" + key;\n}\nfunction acquireResource(hoistableRoot, resource, props) {\n  resource.count++;\n  if (null === resource.instance)\n    switch (resource.type) {\n      case \"style\":\n        var instance = hoistableRoot.querySelector(\n          'style[data-href~=\"' +\n            escapeSelectorAttributeValueInsideDoubleQuotes(props.href) +\n            '\"]'\n        );\n        if (instance)\n          return (\n            (resource.instance = instance),\n            markNodeAsHoistable(instance),\n            instance\n          );\n        var styleProps = assign({}, props, {\n          \"data-href\": props.href,\n          \"data-precedence\": props.precedence,\n          href: null,\n          precedence: null\n        });\n        instance = (hoistableRoot.ownerDocument || hoistableRoot).createElement(\n          \"style\"\n        );\n        markNodeAsHoistable(instance);\n        setInitialProperties(instance, \"style\", styleProps);\n        insertStylesheet(instance, props.precedence, hoistableRoot);\n        return (resource.instance = instance);\n      case \"stylesheet\":\n        styleProps = getStyleKey(props.href);\n        var instance$250 = hoistableRoot.querySelector(\n          getStylesheetSelectorFromKey(styleProps)\n        );\n        if (instance$250)\n          return (\n            (resource.state.loading |= 4),\n            (resource.instance = instance$250),\n            markNodeAsHoistable(instance$250),\n            instance$250\n          );\n        instance = stylesheetPropsFromRawProps(props);\n        (styleProps = preloadPropsMap.get(styleProps)) &&\n          adoptPreloadPropsForStylesheet(instance, styleProps);\n        instance$250 = (\n          hoistableRoot.ownerDocument || hoistableRoot\n        ).createElement(\"link\");\n        markNodeAsHoistable(instance$250);\n        var linkInstance = instance$250;\n        linkInstance._p = new Promise(function (resolve, reject) {\n          linkInstance.onload = resolve;\n          linkInstance.onerror = reject;\n        });\n        setInitialProperties(instance$250, \"link\", instance);\n        resource.state.loading |= 4;\n        insertStylesheet(instance$250, props.precedence, hoistableRoot);\n        return (resource.instance = instance$250);\n      case \"script\":\n        instance$250 = getScriptKey(props.src);\n        if (\n          (styleProps = hoistableRoot.querySelector(\n            getScriptSelectorFromKey(instance$250)\n          ))\n        )\n          return (\n            (resource.instance = styleProps),\n            markNodeAsHoistable(styleProps),\n            styleProps\n          );\n        instance = props;\n        if ((styleProps = preloadPropsMap.get(instance$250)))\n          (instance = assign({}, props)),\n            adoptPreloadPropsForScript(instance, styleProps);\n        hoistableRoot = hoistableRoot.ownerDocument || hoistableRoot;\n        styleProps = hoistableRoot.createElement(\"script\");\n        markNodeAsHoistable(styleProps);\n        setInitialProperties(styleProps, \"link\", instance);\n        hoistableRoot.head.appendChild(styleProps);\n        return (resource.instance = styleProps);\n      case \"void\":\n        return null;\n      default:\n        throw Error(formatProdErrorMessage(443, resource.type));\n    }\n  else\n    \"stylesheet\" === resource.type &&\n      0 === (resource.state.loading & 4) &&\n      ((instance = resource.instance),\n      (resource.state.loading |= 4),\n      insertStylesheet(instance, props.precedence, hoistableRoot));\n  return resource.instance;\n}\nfunction insertStylesheet(instance, precedence, root) {\n  for (\n    var nodes = root.querySelectorAll(\n        'link[rel=\"stylesheet\"][data-precedence],style[data-precedence]'\n      ),\n      last = nodes.length ? nodes[nodes.length - 1] : null,\n      prior = last,\n      i = 0;\n    i < nodes.length;\n    i++\n  ) {\n    var node = nodes[i];\n    if (node.dataset.precedence === precedence) prior = node;\n    else if (prior !== last) break;\n  }\n  prior\n    ? prior.parentNode.insertBefore(instance, prior.nextSibling)\n    : ((precedence = 9 === root.nodeType ? root.head : root),\n      precedence.insertBefore(instance, precedence.firstChild));\n}\nfunction adoptPreloadPropsForStylesheet(stylesheetProps, preloadProps) {\n  null == stylesheetProps.crossOrigin &&\n    (stylesheetProps.crossOrigin = preloadProps.crossOrigin);\n  null == stylesheetProps.referrerPolicy &&\n    (stylesheetProps.referrerPolicy = preloadProps.referrerPolicy);\n  null == stylesheetProps.title && (stylesheetProps.title = preloadProps.title);\n}\nfunction adoptPreloadPropsForScript(scriptProps, preloadProps) {\n  null == scriptProps.crossOrigin &&\n    (scriptProps.crossOrigin = preloadProps.crossOrigin);\n  null == scriptProps.referrerPolicy &&\n    (scriptProps.referrerPolicy = preloadProps.referrerPolicy);\n  null == scriptProps.integrity &&\n    (scriptProps.integrity = preloadProps.integrity);\n}\nvar tagCaches = null;\nfunction getHydratableHoistableCache(type, keyAttribute, ownerDocument) {\n  if (null === tagCaches) {\n    var cache = new Map();\n    var caches = (tagCaches = new Map());\n    caches.set(ownerDocument, cache);\n  } else\n    (caches = tagCaches),\n      (cache = caches.get(ownerDocument)),\n      cache || ((cache = new Map()), caches.set(ownerDocument, cache));\n  if (cache.has(type)) return cache;\n  cache.set(type, null);\n  ownerDocument = ownerDocument.getElementsByTagName(type);\n  for (caches = 0; caches < ownerDocument.length; caches++) {\n    var node = ownerDocument[caches];\n    if (\n      !(\n        node[internalHoistableMarker] ||\n        node[internalInstanceKey] ||\n        (\"link\" === type && \"stylesheet\" === node.getAttribute(\"rel\"))\n      ) &&\n      \"http://www.w3.org/2000/svg\" !== node.namespaceURI\n    ) {\n      var nodeKey = node.getAttribute(keyAttribute) || \"\";\n      nodeKey = type + nodeKey;\n      var existing = cache.get(nodeKey);\n      existing ? existing.push(node) : cache.set(nodeKey, [node]);\n    }\n  }\n  return cache;\n}\nfunction mountHoistable(hoistableRoot, type, instance) {\n  hoistableRoot = hoistableRoot.ownerDocument || hoistableRoot;\n  hoistableRoot.head.insertBefore(\n    instance,\n    \"title\" === type ? hoistableRoot.querySelector(\"head > title\") : null\n  );\n}\nfunction isHostHoistableType(type, props, hostContext) {\n  if (1 === hostContext || null != props.itemProp) return !1;\n  switch (type) {\n    case \"meta\":\n    case \"title\":\n      return !0;\n    case \"style\":\n      if (\n        \"string\" !== typeof props.precedence ||\n        \"string\" !== typeof props.href ||\n        \"\" === props.href\n      )\n        break;\n      return !0;\n    case \"link\":\n      if (\n        \"string\" !== typeof props.rel ||\n        \"string\" !== typeof props.href ||\n        \"\" === props.href ||\n        props.onLoad ||\n        props.onError\n      )\n        break;\n      switch (props.rel) {\n        case \"stylesheet\":\n          return (\n            (type = props.disabled),\n            \"string\" === typeof props.precedence && null == type\n          );\n        default:\n          return !0;\n      }\n    case \"script\":\n      if (\n        props.async &&\n        \"function\" !== typeof props.async &&\n        \"symbol\" !== typeof props.async &&\n        !props.onLoad &&\n        !props.onError &&\n        props.src &&\n        \"string\" === typeof props.src\n      )\n        return !0;\n  }\n  return !1;\n}\nfunction preloadResource(resource) {\n  return \"stylesheet\" === resource.type && 0 === (resource.state.loading & 3)\n    ? !1\n    : !0;\n}\nvar suspendedState = null;\nfunction noop() {}\nfunction suspendResource(hoistableRoot, resource, props) {\n  if (null === suspendedState) throw Error(formatProdErrorMessage(475));\n  var state = suspendedState;\n  if (\n    \"stylesheet\" === resource.type &&\n    (\"string\" !== typeof props.media ||\n      !1 !== matchMedia(props.media).matches) &&\n    0 === (resource.state.loading & 4)\n  ) {\n    if (null === resource.instance) {\n      var key = getStyleKey(props.href),\n        instance = hoistableRoot.querySelector(\n          getStylesheetSelectorFromKey(key)\n        );\n      if (instance) {\n        hoistableRoot = instance._p;\n        null !== hoistableRoot &&\n          \"object\" === typeof hoistableRoot &&\n          \"function\" === typeof hoistableRoot.then &&\n          (state.count++,\n          (state = onUnsuspend.bind(state)),\n          hoistableRoot.then(state, state));\n        resource.state.loading |= 4;\n        resource.instance = instance;\n        markNodeAsHoistable(instance);\n        return;\n      }\n      instance = hoistableRoot.ownerDocument || hoistableRoot;\n      props = stylesheetPropsFromRawProps(props);\n      (key = preloadPropsMap.get(key)) &&\n        adoptPreloadPropsForStylesheet(props, key);\n      instance = instance.createElement(\"link\");\n      markNodeAsHoistable(instance);\n      var linkInstance = instance;\n      linkInstance._p = new Promise(function (resolve, reject) {\n        linkInstance.onload = resolve;\n        linkInstance.onerror = reject;\n      });\n      setInitialProperties(instance, \"link\", props);\n      resource.instance = instance;\n    }\n    null === state.stylesheets && (state.stylesheets = new Map());\n    state.stylesheets.set(resource, hoistableRoot);\n    (hoistableRoot = resource.state.preload) &&\n      0 === (resource.state.loading & 3) &&\n      (state.count++,\n      (resource = onUnsuspend.bind(state)),\n      hoistableRoot.addEventListener(\"load\", resource),\n      hoistableRoot.addEventListener(\"error\", resource));\n  }\n}\nfunction waitForCommitToBeReady() {\n  if (null === suspendedState) throw Error(formatProdErrorMessage(475));\n  var state = suspendedState;\n  state.stylesheets &&\n    0 === state.count &&\n    insertSuspendedStylesheets(state, state.stylesheets);\n  return 0 < state.count\n    ? function (commit) {\n        var stylesheetTimer = setTimeout(function () {\n          state.stylesheets &&\n            insertSuspendedStylesheets(state, state.stylesheets);\n          if (state.unsuspend) {\n            var unsuspend = state.unsuspend;\n            state.unsuspend = null;\n            unsuspend();\n          }\n        }, 6e4);\n        state.unsuspend = commit;\n        return function () {\n          state.unsuspend = null;\n          clearTimeout(stylesheetTimer);\n        };\n      }\n    : null;\n}\nfunction onUnsuspend() {\n  this.count--;\n  if (0 === this.count)\n    if (this.stylesheets) insertSuspendedStylesheets(this, this.stylesheets);\n    else if (this.unsuspend) {\n      var unsuspend = this.unsuspend;\n      this.unsuspend = null;\n      unsuspend();\n    }\n}\nvar precedencesByRoot = null;\nfunction insertSuspendedStylesheets(state, resources) {\n  state.stylesheets = null;\n  null !== state.unsuspend &&\n    (state.count++,\n    (precedencesByRoot = new Map()),\n    resources.forEach(insertStylesheetIntoRoot, state),\n    (precedencesByRoot = null),\n    onUnsuspend.call(state));\n}\nfunction insertStylesheetIntoRoot(root, resource) {\n  if (!(resource.state.loading & 4)) {\n    var precedences = precedencesByRoot.get(root);\n    if (precedences) var last = precedences.get(null);\n    else {\n      precedences = new Map();\n      precedencesByRoot.set(root, precedences);\n      for (\n        var nodes = root.querySelectorAll(\n            \"link[data-precedence],style[data-precedence]\"\n          ),\n          i = 0;\n        i < nodes.length;\n        i++\n      ) {\n        var node = nodes[i];\n        if (\n          \"LINK\" === node.nodeName ||\n          \"not all\" !== node.getAttribute(\"media\")\n        )\n          precedences.set(node.dataset.precedence, node), (last = node);\n      }\n      last && precedences.set(null, last);\n    }\n    nodes = resource.instance;\n    node = nodes.getAttribute(\"data-precedence\");\n    i = precedences.get(node) || last;\n    i === last && precedences.set(null, nodes);\n    precedences.set(node, nodes);\n    this.count++;\n    last = onUnsuspend.bind(this);\n    nodes.addEventListener(\"load\", last);\n    nodes.addEventListener(\"error\", last);\n    i\n      ? i.parentNode.insertBefore(nodes, i.nextSibling)\n      : ((root = 9 === root.nodeType ? root.head : root),\n        root.insertBefore(nodes, root.firstChild));\n    resource.state.loading |= 4;\n  }\n}\nvar HostTransitionContext = {\n  $$typeof: REACT_CONTEXT_TYPE,\n  Provider: null,\n  Consumer: null,\n  _currentValue: sharedNotPendingObject,\n  _currentValue2: sharedNotPendingObject,\n  _threadCount: 0\n};\nfunction FiberRootNode(\n  containerInfo,\n  tag,\n  hydrate,\n  identifierPrefix,\n  onUncaughtError,\n  onCaughtError,\n  onRecoverableError,\n  formState\n) {\n  this.tag = 1;\n  this.containerInfo = containerInfo;\n  this.pingCache = this.current = this.pendingChildren = null;\n  this.timeoutHandle = -1;\n  this.callbackNode =\n    this.next =\n    this.pendingContext =\n    this.context =\n    this.cancelPendingCommit =\n      null;\n  this.callbackPriority = 0;\n  this.expirationTimes = createLaneMap(-1);\n  this.entangledLanes =\n    this.shellSuspendCounter =\n    this.errorRecoveryDisabledLanes =\n    this.expiredLanes =\n    this.warmLanes =\n    this.pingedLanes =\n    this.suspendedLanes =\n    this.pendingLanes =\n      0;\n  this.entanglements = createLaneMap(0);\n  this.hiddenUpdates = createLaneMap(null);\n  this.identifierPrefix = identifierPrefix;\n  this.onUncaughtError = onUncaughtError;\n  this.onCaughtError = onCaughtError;\n  this.onRecoverableError = onRecoverableError;\n  this.pooledCache = null;\n  this.pooledCacheLanes = 0;\n  this.formState = formState;\n  this.incompleteTransitions = new Map();\n}\nfunction createFiberRoot(\n  containerInfo,\n  tag,\n  hydrate,\n  initialChildren,\n  hydrationCallbacks,\n  isStrictMode,\n  identifierPrefix,\n  onUncaughtError,\n  onCaughtError,\n  onRecoverableError,\n  transitionCallbacks,\n  formState\n) {\n  containerInfo = new FiberRootNode(\n    containerInfo,\n    tag,\n    hydrate,\n    identifierPrefix,\n    onUncaughtError,\n    onCaughtError,\n    onRecoverableError,\n    formState\n  );\n  tag = 1;\n  !0 === isStrictMode && (tag |= 24);\n  isStrictMode = createFiberImplClass(3, null, null, tag);\n  containerInfo.current = isStrictMode;\n  isStrictMode.stateNode = containerInfo;\n  tag = createCache();\n  tag.refCount++;\n  containerInfo.pooledCache = tag;\n  tag.refCount++;\n  isStrictMode.memoizedState = {\n    element: initialChildren,\n    isDehydrated: hydrate,\n    cache: tag\n  };\n  initializeUpdateQueue(isStrictMode);\n  return containerInfo;\n}\nfunction getContextForSubtree(parentComponent) {\n  if (!parentComponent) return emptyContextObject;\n  parentComponent = emptyContextObject;\n  return parentComponent;\n}\nfunction updateContainerImpl(\n  rootFiber,\n  lane,\n  element,\n  container,\n  parentComponent,\n  callback\n) {\n  parentComponent = getContextForSubtree(parentComponent);\n  null === container.context\n    ? (container.context = parentComponent)\n    : (container.pendingContext = parentComponent);\n  container = createUpdate(lane);\n  container.payload = { element: element };\n  callback = void 0 === callback ? null : callback;\n  null !== callback && (container.callback = callback);\n  element = enqueueUpdate(rootFiber, container, lane);\n  null !== element &&\n    (scheduleUpdateOnFiber(element, rootFiber, lane),\n    entangleTransitions(element, rootFiber, lane));\n}\nfunction markRetryLaneImpl(fiber, retryLane) {\n  fiber = fiber.memoizedState;\n  if (null !== fiber && null !== fiber.dehydrated) {\n    var a = fiber.retryLane;\n    fiber.retryLane = 0 !== a && a < retryLane ? a : retryLane;\n  }\n}\nfunction markRetryLaneIfNotHydrated(fiber, retryLane) {\n  markRetryLaneImpl(fiber, retryLane);\n  (fiber = fiber.alternate) && markRetryLaneImpl(fiber, retryLane);\n}\nfunction attemptContinuousHydration(fiber) {\n  if (13 === fiber.tag) {\n    var root = enqueueConcurrentRenderForLane(fiber, 67108864);\n    null !== root && scheduleUpdateOnFiber(root, fiber, 67108864);\n    markRetryLaneIfNotHydrated(fiber, 67108864);\n  }\n}\nvar _enabled = !0;\nfunction dispatchDiscreteEvent(\n  domEventName,\n  eventSystemFlags,\n  container,\n  nativeEvent\n) {\n  var prevTransition = ReactSharedInternals.T;\n  ReactSharedInternals.T = null;\n  var previousPriority = ReactDOMSharedInternals.p;\n  try {\n    (ReactDOMSharedInternals.p = 2),\n      dispatchEvent(domEventName, eventSystemFlags, container, nativeEvent);\n  } finally {\n    (ReactDOMSharedInternals.p = previousPriority),\n      (ReactSharedInternals.T = prevTransition);\n  }\n}\nfunction dispatchContinuousEvent(\n  domEventName,\n  eventSystemFlags,\n  container,\n  nativeEvent\n) {\n  var prevTransition = ReactSharedInternals.T;\n  ReactSharedInternals.T = null;\n  var previousPriority = ReactDOMSharedInternals.p;\n  try {\n    (ReactDOMSharedInternals.p = 8),\n      dispatchEvent(domEventName, eventSystemFlags, container, nativeEvent);\n  } finally {\n    (ReactDOMSharedInternals.p = previousPriority),\n      (ReactSharedInternals.T = prevTransition);\n  }\n}\nfunction dispatchEvent(\n  domEventName,\n  eventSystemFlags,\n  targetContainer,\n  nativeEvent\n) {\n  if (_enabled) {\n    var blockedOn = findInstanceBlockingEvent(nativeEvent);\n    if (null === blockedOn)\n      dispatchEventForPluginEventSystem(\n        domEventName,\n        eventSystemFlags,\n        nativeEvent,\n        return_targetInst,\n        targetContainer\n      ),\n        clearIfContinuousEvent(domEventName, nativeEvent);\n    else if (\n      queueIfContinuousEvent(\n        blockedOn,\n        domEventName,\n        eventSystemFlags,\n        targetContainer,\n        nativeEvent\n      )\n    )\n      nativeEvent.stopPropagation();\n    else if (\n      (clearIfContinuousEvent(domEventName, nativeEvent),\n      eventSystemFlags & 4 &&\n        -1 < discreteReplayableEvents.indexOf(domEventName))\n    ) {\n      for (; null !== blockedOn; ) {\n        var fiber = getInstanceFromNode(blockedOn);\n        if (null !== fiber)\n          switch (fiber.tag) {\n            case 3:\n              fiber = fiber.stateNode;\n              if (fiber.current.memoizedState.isDehydrated) {\n                var lanes = getHighestPriorityLanes(fiber.pendingLanes);\n                if (0 !== lanes) {\n                  var root = fiber;\n                  root.pendingLanes |= 2;\n                  for (root.entangledLanes |= 2; lanes; ) {\n                    var lane = 1 << (31 - clz32(lanes));\n                    root.entanglements[1] |= lane;\n                    lanes &= ~lane;\n                  }\n                  ensureRootIsScheduled(fiber);\n                  0 === (executionContext & 6) &&\n                    ((workInProgressRootRenderTargetTime = now() + 500),\n                    flushSyncWorkAcrossRoots_impl(0, !1));\n                }\n              }\n              break;\n            case 13:\n              (root = enqueueConcurrentRenderForLane(fiber, 2)),\n                null !== root && scheduleUpdateOnFiber(root, fiber, 2),\n                flushSyncWork$1(),\n                markRetryLaneIfNotHydrated(fiber, 2);\n          }\n        fiber = findInstanceBlockingEvent(nativeEvent);\n        null === fiber &&\n          dispatchEventForPluginEventSystem(\n            domEventName,\n            eventSystemFlags,\n            nativeEvent,\n            return_targetInst,\n            targetContainer\n          );\n        if (fiber === blockedOn) break;\n        blockedOn = fiber;\n      }\n      null !== blockedOn && nativeEvent.stopPropagation();\n    } else\n      dispatchEventForPluginEventSystem(\n        domEventName,\n        eventSystemFlags,\n        nativeEvent,\n        null,\n        targetContainer\n      );\n  }\n}\nfunction findInstanceBlockingEvent(nativeEvent) {\n  nativeEvent = getEventTarget(nativeEvent);\n  return findInstanceBlockingTarget(nativeEvent);\n}\nvar return_targetInst = null;\nfunction findInstanceBlockingTarget(targetNode) {\n  return_targetInst = null;\n  targetNode = getClosestInstanceFromNode(targetNode);\n  if (null !== targetNode) {\n    var nearestMounted = getNearestMountedFiber(targetNode);\n    if (null === nearestMounted) targetNode = null;\n    else {\n      var tag = nearestMounted.tag;\n      if (13 === tag) {\n        targetNode = getSuspenseInstanceFromFiber(nearestMounted);\n        if (null !== targetNode) return targetNode;\n        targetNode = null;\n      } else if (3 === tag) {\n        if (nearestMounted.stateNode.current.memoizedState.isDehydrated)\n          return 3 === nearestMounted.tag\n            ? nearestMounted.stateNode.containerInfo\n            : null;\n        targetNode = null;\n      } else nearestMounted !== targetNode && (targetNode = null);\n    }\n  }\n  return_targetInst = targetNode;\n  return null;\n}\nfunction getEventPriority(domEventName) {\n  switch (domEventName) {\n    case \"beforetoggle\":\n    case \"cancel\":\n    case \"click\":\n    case \"close\":\n    case \"contextmenu\":\n    case \"copy\":\n    case \"cut\":\n    case \"auxclick\":\n    case \"dblclick\":\n    case \"dragend\":\n    case \"dragstart\":\n    case \"drop\":\n    case \"focusin\":\n    case \"focusout\":\n    case \"input\":\n    case \"invalid\":\n    case \"keydown\":\n    case \"keypress\":\n    case \"keyup\":\n    case \"mousedown\":\n    case \"mouseup\":\n    case \"paste\":\n    case \"pause\":\n    case \"play\":\n    case \"pointercancel\":\n    case \"pointerdown\":\n    case \"pointerup\":\n    case \"ratechange\":\n    case \"reset\":\n    case \"resize\":\n    case \"seeked\":\n    case \"submit\":\n    case \"toggle\":\n    case \"touchcancel\":\n    case \"touchend\":\n    case \"touchstart\":\n    case \"volumechange\":\n    case \"change\":\n    case \"selectionchange\":\n    case \"textInput\":\n    case \"compositionstart\":\n    case \"compositionend\":\n    case \"compositionupdate\":\n    case \"beforeblur\":\n    case \"afterblur\":\n    case \"beforeinput\":\n    case \"blur\":\n    case \"fullscreenchange\":\n    case \"focus\":\n    case \"hashchange\":\n    case \"popstate\":\n    case \"select\":\n    case \"selectstart\":\n      return 2;\n    case \"drag\":\n    case \"dragenter\":\n    case \"dragexit\":\n    case \"dragleave\":\n    case \"dragover\":\n    case \"mousemove\":\n    case \"mouseout\":\n    case \"mouseover\":\n    case \"pointermove\":\n    case \"pointerout\":\n    case \"pointerover\":\n    case \"scroll\":\n    case \"touchmove\":\n    case \"wheel\":\n    case \"mouseenter\":\n    case \"mouseleave\":\n    case \"pointerenter\":\n    case \"pointerleave\":\n      return 8;\n    case \"message\":\n      switch (getCurrentPriorityLevel()) {\n        case ImmediatePriority:\n          return 2;\n        case UserBlockingPriority:\n          return 8;\n        case NormalPriority$1:\n        case LowPriority:\n          return 32;\n        case IdlePriority:\n          return 268435456;\n        default:\n          return 32;\n      }\n    default:\n      return 32;\n  }\n}\nvar hasScheduledReplayAttempt = !1,\n  queuedFocus = null,\n  queuedDrag = null,\n  queuedMouse = null,\n  queuedPointers = new Map(),\n  queuedPointerCaptures = new Map(),\n  queuedExplicitHydrationTargets = [],\n  discreteReplayableEvents =\n    \"mousedown mouseup touchcancel touchend touchstart auxclick dblclick pointercancel pointerdown pointerup dragend dragstart drop compositionend compositionstart keydown keypress keyup input textInput copy cut paste click change contextmenu reset\".split(\n      \" \"\n    );\nfunction clearIfContinuousEvent(domEventName, nativeEvent) {\n  switch (domEventName) {\n    case \"focusin\":\n    case \"focusout\":\n      queuedFocus = null;\n      break;\n    case \"dragenter\":\n    case \"dragleave\":\n      queuedDrag = null;\n      break;\n    case \"mouseover\":\n    case \"mouseout\":\n      queuedMouse = null;\n      break;\n    case \"pointerover\":\n    case \"pointerout\":\n      queuedPointers.delete(nativeEvent.pointerId);\n      break;\n    case \"gotpointercapture\":\n    case \"lostpointercapture\":\n      queuedPointerCaptures.delete(nativeEvent.pointerId);\n  }\n}\nfunction accumulateOrCreateContinuousQueuedReplayableEvent(\n  existingQueuedEvent,\n  blockedOn,\n  domEventName,\n  eventSystemFlags,\n  targetContainer,\n  nativeEvent\n) {\n  if (\n    null === existingQueuedEvent ||\n    existingQueuedEvent.nativeEvent !== nativeEvent\n  )\n    return (\n      (existingQueuedEvent = {\n        blockedOn: blockedOn,\n        domEventName: domEventName,\n        eventSystemFlags: eventSystemFlags,\n        nativeEvent: nativeEvent,\n        targetContainers: [targetContainer]\n      }),\n      null !== blockedOn &&\n        ((blockedOn = getInstanceFromNode(blockedOn)),\n        null !== blockedOn && attemptContinuousHydration(blockedOn)),\n      existingQueuedEvent\n    );\n  existingQueuedEvent.eventSystemFlags |= eventSystemFlags;\n  blockedOn = existingQueuedEvent.targetContainers;\n  null !== targetContainer &&\n    -1 === blockedOn.indexOf(targetContainer) &&\n    blockedOn.push(targetContainer);\n  return existingQueuedEvent;\n}\nfunction queueIfContinuousEvent(\n  blockedOn,\n  domEventName,\n  eventSystemFlags,\n  targetContainer,\n  nativeEvent\n) {\n  switch (domEventName) {\n    case \"focusin\":\n      return (\n        (queuedFocus = accumulateOrCreateContinuousQueuedReplayableEvent(\n          queuedFocus,\n          blockedOn,\n          domEventName,\n          eventSystemFlags,\n          targetContainer,\n          nativeEvent\n        )),\n        !0\n      );\n    case \"dragenter\":\n      return (\n        (queuedDrag = accumulateOrCreateContinuousQueuedReplayableEvent(\n          queuedDrag,\n          blockedOn,\n          domEventName,\n          eventSystemFlags,\n          targetContainer,\n          nativeEvent\n        )),\n        !0\n      );\n    case \"mouseover\":\n      return (\n        (queuedMouse = accumulateOrCreateContinuousQueuedReplayableEvent(\n          queuedMouse,\n          blockedOn,\n          domEventName,\n          eventSystemFlags,\n          targetContainer,\n          nativeEvent\n        )),\n        !0\n      );\n    case \"pointerover\":\n      var pointerId = nativeEvent.pointerId;\n      queuedPointers.set(\n        pointerId,\n        accumulateOrCreateContinuousQueuedReplayableEvent(\n          queuedPointers.get(pointerId) || null,\n          blockedOn,\n          domEventName,\n          eventSystemFlags,\n          targetContainer,\n          nativeEvent\n        )\n      );\n      return !0;\n    case \"gotpointercapture\":\n      return (\n        (pointerId = nativeEvent.pointerId),\n        queuedPointerCaptures.set(\n          pointerId,\n          accumulateOrCreateContinuousQueuedReplayableEvent(\n            queuedPointerCaptures.get(pointerId) || null,\n            blockedOn,\n            domEventName,\n            eventSystemFlags,\n            targetContainer,\n            nativeEvent\n          )\n        ),\n        !0\n      );\n  }\n  return !1;\n}\nfunction attemptExplicitHydrationTarget(queuedTarget) {\n  var targetInst = getClosestInstanceFromNode(queuedTarget.target);\n  if (null !== targetInst) {\n    var nearestMounted = getNearestMountedFiber(targetInst);\n    if (null !== nearestMounted)\n      if (((targetInst = nearestMounted.tag), 13 === targetInst)) {\n        if (\n          ((targetInst = getSuspenseInstanceFromFiber(nearestMounted)),\n          null !== targetInst)\n        ) {\n          queuedTarget.blockedOn = targetInst;\n          runWithPriority(queuedTarget.priority, function () {\n            if (13 === nearestMounted.tag) {\n              var lane = requestUpdateLane();\n              lane = getBumpedLaneForHydrationByLane(lane);\n              var root = enqueueConcurrentRenderForLane(nearestMounted, lane);\n              null !== root &&\n                scheduleUpdateOnFiber(root, nearestMounted, lane);\n              markRetryLaneIfNotHydrated(nearestMounted, lane);\n            }\n          });\n          return;\n        }\n      } else if (\n        3 === targetInst &&\n        nearestMounted.stateNode.current.memoizedState.isDehydrated\n      ) {\n        queuedTarget.blockedOn =\n          3 === nearestMounted.tag\n            ? nearestMounted.stateNode.containerInfo\n            : null;\n        return;\n      }\n  }\n  queuedTarget.blockedOn = null;\n}\nfunction attemptReplayContinuousQueuedEvent(queuedEvent) {\n  if (null !== queuedEvent.blockedOn) return !1;\n  for (\n    var targetContainers = queuedEvent.targetContainers;\n    0 < targetContainers.length;\n\n  ) {\n    var nextBlockedOn = findInstanceBlockingEvent(queuedEvent.nativeEvent);\n    if (null === nextBlockedOn) {\n      nextBlockedOn = queuedEvent.nativeEvent;\n      var nativeEventClone = new nextBlockedOn.constructor(\n        nextBlockedOn.type,\n        nextBlockedOn\n      );\n      currentReplayingEvent = nativeEventClone;\n      nextBlockedOn.target.dispatchEvent(nativeEventClone);\n      currentReplayingEvent = null;\n    } else\n      return (\n        (targetContainers = getInstanceFromNode(nextBlockedOn)),\n        null !== targetContainers &&\n          attemptContinuousHydration(targetContainers),\n        (queuedEvent.blockedOn = nextBlockedOn),\n        !1\n      );\n    targetContainers.shift();\n  }\n  return !0;\n}\nfunction attemptReplayContinuousQueuedEventInMap(queuedEvent, key, map) {\n  attemptReplayContinuousQueuedEvent(queuedEvent) && map.delete(key);\n}\nfunction replayUnblockedEvents() {\n  hasScheduledReplayAttempt = !1;\n  null !== queuedFocus &&\n    attemptReplayContinuousQueuedEvent(queuedFocus) &&\n    (queuedFocus = null);\n  null !== queuedDrag &&\n    attemptReplayContinuousQueuedEvent(queuedDrag) &&\n    (queuedDrag = null);\n  null !== queuedMouse &&\n    attemptReplayContinuousQueuedEvent(queuedMouse) &&\n    (queuedMouse = null);\n  queuedPointers.forEach(attemptReplayContinuousQueuedEventInMap);\n  queuedPointerCaptures.forEach(attemptReplayContinuousQueuedEventInMap);\n}\nfunction scheduleCallbackIfUnblocked(queuedEvent, unblocked) {\n  queuedEvent.blockedOn === unblocked &&\n    ((queuedEvent.blockedOn = null),\n    hasScheduledReplayAttempt ||\n      ((hasScheduledReplayAttempt = !0),\n      Scheduler.unstable_scheduleCallback(\n        Scheduler.unstable_NormalPriority,\n        replayUnblockedEvents\n      )));\n}\nvar lastScheduledReplayQueue = null;\nfunction scheduleReplayQueueIfNeeded(formReplayingQueue) {\n  lastScheduledReplayQueue !== formReplayingQueue &&\n    ((lastScheduledReplayQueue = formReplayingQueue),\n    Scheduler.unstable_scheduleCallback(\n      Scheduler.unstable_NormalPriority,\n      function () {\n        lastScheduledReplayQueue === formReplayingQueue &&\n          (lastScheduledReplayQueue = null);\n        for (var i = 0; i < formReplayingQueue.length; i += 3) {\n          var form = formReplayingQueue[i],\n            submitterOrAction = formReplayingQueue[i + 1],\n            formData = formReplayingQueue[i + 2];\n          if (\"function\" !== typeof submitterOrAction)\n            if (null === findInstanceBlockingTarget(submitterOrAction || form))\n              continue;\n            else break;\n          var formInst = getInstanceFromNode(form);\n          null !== formInst &&\n            (formReplayingQueue.splice(i, 3),\n            (i -= 3),\n            startHostTransition(\n              formInst,\n              {\n                pending: !0,\n                data: formData,\n                method: form.method,\n                action: submitterOrAction\n              },\n              submitterOrAction,\n              formData\n            ));\n        }\n      }\n    ));\n}\nfunction retryIfBlockedOn(unblocked) {\n  function unblock(queuedEvent) {\n    return scheduleCallbackIfUnblocked(queuedEvent, unblocked);\n  }\n  null !== queuedFocus && scheduleCallbackIfUnblocked(queuedFocus, unblocked);\n  null !== queuedDrag && scheduleCallbackIfUnblocked(queuedDrag, unblocked);\n  null !== queuedMouse && scheduleCallbackIfUnblocked(queuedMouse, unblocked);\n  queuedPointers.forEach(unblock);\n  queuedPointerCaptures.forEach(unblock);\n  for (var i = 0; i < queuedExplicitHydrationTargets.length; i++) {\n    var queuedTarget = queuedExplicitHydrationTargets[i];\n    queuedTarget.blockedOn === unblocked && (queuedTarget.blockedOn = null);\n  }\n  for (\n    ;\n    0 < queuedExplicitHydrationTargets.length &&\n    ((i = queuedExplicitHydrationTargets[0]), null === i.blockedOn);\n\n  )\n    attemptExplicitHydrationTarget(i),\n      null === i.blockedOn && queuedExplicitHydrationTargets.shift();\n  i = (unblocked.ownerDocument || unblocked).$$reactFormReplay;\n  if (null != i)\n    for (queuedTarget = 0; queuedTarget < i.length; queuedTarget += 3) {\n      var form = i[queuedTarget],\n        submitterOrAction = i[queuedTarget + 1],\n        formProps = form[internalPropsKey] || null;\n      if (\"function\" === typeof submitterOrAction)\n        formProps || scheduleReplayQueueIfNeeded(i);\n      else if (formProps) {\n        var action = null;\n        if (submitterOrAction && submitterOrAction.hasAttribute(\"formAction\"))\n          if (\n            ((form = submitterOrAction),\n            (formProps = submitterOrAction[internalPropsKey] || null))\n          )\n            action = formProps.formAction;\n          else {\n            if (null !== findInstanceBlockingTarget(form)) continue;\n          }\n        else action = formProps.action;\n        \"function\" === typeof action\n          ? (i[queuedTarget + 1] = action)\n          : (i.splice(queuedTarget, 3), (queuedTarget -= 3));\n        scheduleReplayQueueIfNeeded(i);\n      }\n    }\n}\nfunction ReactDOMRoot(internalRoot) {\n  this._internalRoot = internalRoot;\n}\nReactDOMHydrationRoot.prototype.render = ReactDOMRoot.prototype.render =\n  function (children) {\n    var root = this._internalRoot;\n    if (null === root) throw Error(formatProdErrorMessage(409));\n    var current = root.current,\n      lane = requestUpdateLane();\n    updateContainerImpl(current, lane, children, root, null, null);\n  };\nReactDOMHydrationRoot.prototype.unmount = ReactDOMRoot.prototype.unmount =\n  function () {\n    var root = this._internalRoot;\n    if (null !== root) {\n      this._internalRoot = null;\n      var container = root.containerInfo;\n      updateContainerImpl(root.current, 2, null, root, null, null);\n      flushSyncWork$1();\n      container[internalContainerInstanceKey] = null;\n    }\n  };\nfunction ReactDOMHydrationRoot(internalRoot) {\n  this._internalRoot = internalRoot;\n}\nReactDOMHydrationRoot.prototype.unstable_scheduleHydration = function (target) {\n  if (target) {\n    var updatePriority = resolveUpdatePriority();\n    target = { blockedOn: null, target: target, priority: updatePriority };\n    for (\n      var i = 0;\n      i < queuedExplicitHydrationTargets.length &&\n      0 !== updatePriority &&\n      updatePriority < queuedExplicitHydrationTargets[i].priority;\n      i++\n    );\n    queuedExplicitHydrationTargets.splice(i, 0, target);\n    0 === i && attemptExplicitHydrationTarget(target);\n  }\n};\nvar isomorphicReactPackageVersion$jscomp$inline_1785 = React.version;\nif (\n  \"19.1.0\" !==\n  isomorphicReactPackageVersion$jscomp$inline_1785\n)\n  throw Error(\n    formatProdErrorMessage(\n      527,\n      isomorphicReactPackageVersion$jscomp$inline_1785,\n      \"19.1.0\"\n    )\n  );\nReactDOMSharedInternals.findDOMNode = function (componentOrElement) {\n  var fiber = componentOrElement._reactInternals;\n  if (void 0 === fiber) {\n    if (\"function\" === typeof componentOrElement.render)\n      throw Error(formatProdErrorMessage(188));\n    componentOrElement = Object.keys(componentOrElement).join(\",\");\n    throw Error(formatProdErrorMessage(268, componentOrElement));\n  }\n  componentOrElement = findCurrentFiberUsingSlowPath(fiber);\n  componentOrElement =\n    null !== componentOrElement\n      ? findCurrentHostFiberImpl(componentOrElement)\n      : null;\n  componentOrElement =\n    null === componentOrElement ? null : componentOrElement.stateNode;\n  return componentOrElement;\n};\nvar internals$jscomp$inline_2256 = {\n  bundleType: 0,\n  version: \"19.1.0\",\n  rendererPackageName: \"react-dom\",\n  currentDispatcherRef: ReactSharedInternals,\n  reconcilerVersion: \"19.1.0\"\n};\nif (\"undefined\" !== typeof __REACT_DEVTOOLS_GLOBAL_HOOK__) {\n  var hook$jscomp$inline_2257 = __REACT_DEVTOOLS_GLOBAL_HOOK__;\n  if (\n    !hook$jscomp$inline_2257.isDisabled &&\n    hook$jscomp$inline_2257.supportsFiber\n  )\n    try {\n      (rendererID = hook$jscomp$inline_2257.inject(\n        internals$jscomp$inline_2256\n      )),\n        (injectedHook = hook$jscomp$inline_2257);\n    } catch (err) {}\n}\nexports.createRoot = function (container, options) {\n  if (!isValidContainer(container)) throw Error(formatProdErrorMessage(299));\n  var isStrictMode = !1,\n    identifierPrefix = \"\",\n    onUncaughtError = defaultOnUncaughtError,\n    onCaughtError = defaultOnCaughtError,\n    onRecoverableError = defaultOnRecoverableError,\n    transitionCallbacks = null;\n  null !== options &&\n    void 0 !== options &&\n    (!0 === options.unstable_strictMode && (isStrictMode = !0),\n    void 0 !== options.identifierPrefix &&\n      (identifierPrefix = options.identifierPrefix),\n    void 0 !== options.onUncaughtError &&\n      (onUncaughtError = options.onUncaughtError),\n    void 0 !== options.onCaughtError && (onCaughtError = options.onCaughtError),\n    void 0 !== options.onRecoverableError &&\n      (onRecoverableError = options.onRecoverableError),\n    void 0 !== options.unstable_transitionCallbacks &&\n      (transitionCallbacks = options.unstable_transitionCallbacks));\n  options = createFiberRoot(\n    container,\n    1,\n    !1,\n    null,\n    null,\n    isStrictMode,\n    identifierPrefix,\n    onUncaughtError,\n    onCaughtError,\n    onRecoverableError,\n    transitionCallbacks,\n    null\n  );\n  container[internalContainerInstanceKey] = options.current;\n  listenToAllSupportedEvents(container);\n  return new ReactDOMRoot(options);\n};\nexports.hydrateRoot = function (container, initialChildren, options) {\n  if (!isValidContainer(container)) throw Error(formatProdErrorMessage(299));\n  var isStrictMode = !1,\n    identifierPrefix = \"\",\n    onUncaughtError = defaultOnUncaughtError,\n    onCaughtError = defaultOnCaughtError,\n    onRecoverableError = defaultOnRecoverableError,\n    transitionCallbacks = null,\n    formState = null;\n  null !== options &&\n    void 0 !== options &&\n    (!0 === options.unstable_strictMode && (isStrictMode = !0),\n    void 0 !== options.identifierPrefix &&\n      (identifierPrefix = options.identifierPrefix),\n    void 0 !== options.onUncaughtError &&\n      (onUncaughtError = options.onUncaughtError),\n    void 0 !== options.onCaughtError && (onCaughtError = options.onCaughtError),\n    void 0 !== options.onRecoverableError &&\n      (onRecoverableError = options.onRecoverableError),\n    void 0 !== options.unstable_transitionCallbacks &&\n      (transitionCallbacks = options.unstable_transitionCallbacks),\n    void 0 !== options.formState && (formState = options.formState));\n  initialChildren = createFiberRoot(\n    container,\n    1,\n    !0,\n    initialChildren,\n    null != options ? options : null,\n    isStrictMode,\n    identifierPrefix,\n    onUncaughtError,\n    onCaughtError,\n    onRecoverableError,\n    transitionCallbacks,\n    formState\n  );\n  initialChildren.context = getContextForSubtree(null);\n  options = initialChildren.current;\n  isStrictMode = requestUpdateLane();\n  isStrictMode = getBumpedLaneForHydrationByLane(isStrictMode);\n  identifierPrefix = createUpdate(isStrictMode);\n  identifierPrefix.callback = null;\n  enqueueUpdate(options, identifierPrefix, isStrictMode);\n  options = isStrictMode;\n  initialChildren.current.lanes = options;\n  markRootUpdated$1(initialChildren, options);\n  ensureRootIsScheduled(initialChildren);\n  container[internalContainerInstanceKey] = initialChildren.current;\n  listenToAllSupportedEvents(container);\n  return new ReactDOMHydrationRoot(initialChildren);\n};\nexports.version = \"19.1.0\";\n","// loaders.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\nimport { assert } from \"../env-utils/assert.js\";\nconst workerURLCache = new Map();\n/**\n * Creates a loadable URL from worker source or URL\n * that can be used to create `Worker` instances.\n * Due to CORS issues it may be necessary to wrap a URL in a small importScripts\n * @param props\n * @param props.source Worker source\n * @param props.url Worker URL\n * @returns loadable url\n */\nexport function getLoadableWorkerURL(props) {\n    assert((props.source && !props.url) || (!props.source && props.url)); // Either source or url must be defined\n    let workerURL = workerURLCache.get(props.source || props.url);\n    if (!workerURL) {\n        // Differentiate worker urls from worker source code\n        if (props.url) {\n            workerURL = getLoadableWorkerURLFromURL(props.url);\n            workerURLCache.set(props.url, workerURL);\n        }\n        if (props.source) {\n            workerURL = getLoadableWorkerURLFromSource(props.source);\n            workerURLCache.set(props.source, workerURL);\n        }\n    }\n    assert(workerURL);\n    return workerURL;\n}\n/**\n * Build a loadable worker URL from worker URL\n * @param url\n * @returns loadable URL\n */\nfunction getLoadableWorkerURLFromURL(url) {\n    // A local script url, we can use it to initialize a Worker directly\n    if (!url.startsWith('http')) {\n        return url;\n    }\n    // A remote script, we need to use `importScripts` to load from different origin\n    const workerSource = buildScriptSource(url);\n    return getLoadableWorkerURLFromSource(workerSource);\n}\n/**\n * Build a loadable worker URL from worker source\n * @param workerSource\n * @returns loadable url\n */\nfunction getLoadableWorkerURLFromSource(workerSource) {\n    const blob = new Blob([workerSource], { type: 'application/javascript' });\n    return URL.createObjectURL(blob);\n}\n/**\n * Per spec, worker cannot be initialized with a script from a different origin\n * However a local worker script can still import scripts from other origins,\n * so we simply build a wrapper script.\n *\n * @param workerUrl\n * @returns source\n */\nfunction buildScriptSource(workerUrl) {\n    return `\\\ntry {\n  importScripts('${workerUrl}');\n} catch (error) {\n  console.error(error);\n  throw error;\n}`;\n}\n","// loaders.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n// NOTE - there is a copy of this function is both in core and loader-utils\n// core does not need all the utils in loader-utils, just this one.\n/**\n * Returns an array of Transferrable objects that can be used with postMessage\n * https://developer.mozilla.org/en-US/docs/Web/API/Worker/postMessage\n * @param object data to be sent via postMessage\n * @param recursive - not for application use\n * @param transfers - not for application use\n * @returns a transfer list that can be passed to postMessage\n */\nexport function getTransferList(object, recursive = true, transfers) {\n    // Make sure that items in the transfer list is unique\n    const transfersSet = transfers || new Set();\n    if (!object) {\n        // ignore\n    }\n    else if (isTransferable(object)) {\n        transfersSet.add(object);\n    }\n    else if (isTransferable(object.buffer)) {\n        // Typed array\n        transfersSet.add(object.buffer);\n    }\n    else if (ArrayBuffer.isView(object)) {\n        // object is a TypeArray viewing into a SharedArrayBuffer (not transferable)\n        // Do not iterate through the content in this case\n    }\n    else if (recursive && typeof object === 'object') {\n        for (const key in object) {\n            // Avoid perf hit - only go one level deep\n            getTransferList(object[key], recursive, transfersSet);\n        }\n    }\n    // If transfers is defined, is internal recursive call\n    // Otherwise it's called by the user\n    return transfers === undefined ? Array.from(transfersSet) : [];\n}\n// https://developer.mozilla.org/en-US/docs/Web/API/Transferable\nfunction isTransferable(object) {\n    if (!object) {\n        return false;\n    }\n    if (object instanceof ArrayBuffer) {\n        return true;\n    }\n    if (typeof MessagePort !== 'undefined' && object instanceof MessagePort) {\n        return true;\n    }\n    if (typeof ImageBitmap !== 'undefined' && object instanceof ImageBitmap) {\n        return true;\n    }\n    // @ts-ignore\n    if (typeof OffscreenCanvas !== 'undefined' && object instanceof OffscreenCanvas) {\n        return true;\n    }\n    return false;\n}\n/**\n * Recursively drop non serializable values like functions and regexps.\n * @param object\n */\nexport function getTransferListForWriter(object) {\n    if (object === null) {\n        return {};\n    }\n    const clone = Object.assign({}, object);\n    Object.keys(clone).forEach((key) => {\n        // Typed Arrays and Arrays are passed with no change\n        if (typeof object[key] === 'object' &&\n            !ArrayBuffer.isView(object[key]) &&\n            !(object[key] instanceof Array)) {\n            clone[key] = getTransferListForWriter(object[key]);\n        }\n        else if (typeof clone[key] === 'function' || clone[key] instanceof RegExp) {\n            clone[key] = {};\n        }\n        else {\n            clone[key] = object[key];\n        }\n    });\n    return clone;\n}\n","// luma.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\nexport const MODULE_INJECTORS_VS = /* glsl */ `\\\n#ifdef MODULE_LOGDEPTH\n  logdepth_adjustPosition(gl_Position);\n#endif\n`;\nexport const MODULE_INJECTORS_FS = /* glsl */ `\\\n#ifdef MODULE_MATERIAL\n  fragColor = material_filterColor(fragColor);\n#endif\n\n#ifdef MODULE_LIGHTING\n  fragColor = lighting_filterColor(fragColor);\n#endif\n\n#ifdef MODULE_FOG\n  fragColor = fog_filterColor(fragColor);\n#endif\n\n#ifdef MODULE_PICKING\n  fragColor = picking_filterHighlightColor(fragColor);\n  fragColor = picking_filterPickingColor(fragColor);\n#endif\n\n#ifdef MODULE_LOGDEPTH\n  logdepth_setFragDepth();\n#endif\n`;\n//# sourceMappingURL=module-injectors.js.map","// luma.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\nimport { MODULE_INJECTORS_VS, MODULE_INJECTORS_FS } from \"../../module-injectors.js\";\nimport { assert } from \"../utils/assert.js\";\n// TODO - experimental\nconst MODULE_INJECTORS = {\n    vertex: MODULE_INJECTORS_VS,\n    fragment: MODULE_INJECTORS_FS\n};\nconst REGEX_START_OF_MAIN = /void\\s+main\\s*\\([^)]*\\)\\s*\\{\\n?/; // Beginning of main\nconst REGEX_END_OF_MAIN = /}\\n?[^{}]*$/; // End of main, assumes main is last function\nconst fragments = [];\nexport const DECLARATION_INJECT_MARKER = '__LUMA_INJECT_DECLARATIONS__';\n/**\n *\n */\nexport function normalizeInjections(injections) {\n    const result = { vertex: {}, fragment: {} };\n    for (const hook in injections) {\n        let injection = injections[hook];\n        const stage = getHookStage(hook);\n        if (typeof injection === 'string') {\n            injection = {\n                order: 0,\n                injection\n            };\n        }\n        result[stage][hook] = injection;\n    }\n    return result;\n}\nfunction getHookStage(hook) {\n    const type = hook.slice(0, 2);\n    switch (type) {\n        case 'vs':\n            return 'vertex';\n        case 'fs':\n            return 'fragment';\n        default:\n            throw new Error(type);\n    }\n}\n/**\n// A minimal shader injection/templating system.\n// RFC: https://github.com/visgl/luma.gl/blob/7.0-release/dev-docs/RFCs/v6.0/shader-injection-rfc.md\n * @param source\n * @param type\n * @param inject\n * @param injectStandardStubs\n * @returns\n */\n// eslint-disable-next-line complexity\nexport function injectShader(source, stage, inject, injectStandardStubs = false) {\n    const isVertex = stage === 'vertex';\n    for (const key in inject) {\n        const fragmentData = inject[key];\n        fragmentData.sort((a, b) => a.order - b.order);\n        fragments.length = fragmentData.length;\n        for (let i = 0, len = fragmentData.length; i < len; ++i) {\n            fragments[i] = fragmentData[i].injection;\n        }\n        const fragmentString = `${fragments.join('\\n')}\\n`;\n        switch (key) {\n            // declarations are injected before the main function\n            case 'vs:#decl':\n                if (isVertex) {\n                    source = source.replace(DECLARATION_INJECT_MARKER, fragmentString);\n                }\n                break;\n            // inject code at the beginning of the main function\n            case 'vs:#main-start':\n                if (isVertex) {\n                    source = source.replace(REGEX_START_OF_MAIN, (match) => match + fragmentString);\n                }\n                break;\n            // inject code at the end of main function\n            case 'vs:#main-end':\n                if (isVertex) {\n                    source = source.replace(REGEX_END_OF_MAIN, (match) => fragmentString + match);\n                }\n                break;\n            // declarations are injected before the main function\n            case 'fs:#decl':\n                if (!isVertex) {\n                    source = source.replace(DECLARATION_INJECT_MARKER, fragmentString);\n                }\n                break;\n            // inject code at the beginning of the main function\n            case 'fs:#main-start':\n                if (!isVertex) {\n                    source = source.replace(REGEX_START_OF_MAIN, (match) => match + fragmentString);\n                }\n                break;\n            // inject code at the end of main function\n            case 'fs:#main-end':\n                if (!isVertex) {\n                    source = source.replace(REGEX_END_OF_MAIN, (match) => fragmentString + match);\n                }\n                break;\n            default:\n                // TODO(Tarek): I think this usage should be deprecated.\n                // inject code after key, leaving key in place\n                source = source.replace(key, (match) => match + fragmentString);\n        }\n    }\n    // Remove if it hasn't already been replaced\n    source = source.replace(DECLARATION_INJECT_MARKER, '');\n    // Finally, if requested, insert an automatic module injector chunk\n    if (injectStandardStubs) {\n        source = source.replace(/\\}\\s*$/, (match) => match + MODULE_INJECTORS[stage]);\n    }\n    return source;\n}\n// Takes an array of inject objects and combines them into one\nexport function combineInjects(injects) {\n    const result = {};\n    assert(Array.isArray(injects) && injects.length > 1);\n    injects.forEach(inject => {\n        for (const key in inject) {\n            result[key] = result[key] ? `${result[key]}\\n${inject[key]}` : inject[key];\n        }\n    });\n    return result;\n}\n//# sourceMappingURL=shader-injections.js.map","// luma.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n/** Adds defines to help identify GPU architecture / platform */\nexport function getPlatformShaderDefines(platformInfo) {\n    switch (platformInfo?.gpu.toLowerCase()) {\n        case 'apple':\n            return /* glsl */ `\\\n#define APPLE_GPU\n// Apple optimizes away the calculation necessary for emulated fp64\n#define LUMA_FP64_CODE_ELIMINATION_WORKAROUND 1\n#define LUMA_FP32_TAN_PRECISION_WORKAROUND 1\n// Intel GPU doesn't have full 32 bits precision in same cases, causes overflow\n#define LUMA_FP64_HIGH_BITS_OVERFLOW_WORKAROUND 1\n`;\n        case 'nvidia':\n            return /* glsl */ `\\\n#define NVIDIA_GPU\n// Nvidia optimizes away the calculation necessary for emulated fp64\n#define LUMA_FP64_CODE_ELIMINATION_WORKAROUND 1\n`;\n        case 'intel':\n            return /* glsl */ `\\\n#define INTEL_GPU\n// Intel optimizes away the calculation necessary for emulated fp64\n#define LUMA_FP64_CODE_ELIMINATION_WORKAROUND 1\n// Intel's built-in 'tan' function doesn't have acceptable precision\n#define LUMA_FP32_TAN_PRECISION_WORKAROUND 1\n// Intel GPU doesn't have full 32 bits precision in same cases, causes overflow\n#define LUMA_FP64_HIGH_BITS_OVERFLOW_WORKAROUND 1\n`;\n        case 'amd':\n            // AMD Does not eliminate fp64 code\n            return /* glsl */ `\\\n#define AMD_GPU\n`;\n        default:\n            // We don't know what GPU it is, could be that the GPU driver or\n            // browser is not implementing UNMASKED_RENDERER constant and not\n            // reporting a correct name\n            return /* glsl */ `\\\n#define DEFAULT_GPU\n// Prevent driver from optimizing away the calculation necessary for emulated fp64\n#define LUMA_FP64_CODE_ELIMINATION_WORKAROUND 1\n// Headless Chrome's software shader 'tan' function doesn't have acceptable precision\n#define LUMA_FP32_TAN_PRECISION_WORKAROUND 1\n// If the GPU doesn't have full 32 bits precision, will causes overflow\n#define LUMA_FP64_HIGH_BITS_OVERFLOW_WORKAROUND 1\n`;\n    }\n}\n//# sourceMappingURL=platform-defines.js.map","// luma.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n// TRANSPILATION TABLES\n/**\n * Transpiles GLSL 3.00 shader source code to target GLSL version (3.00 or 1.00)\n *\n * @note We always run transpiler even if same version e.g. 3.00 => 3.00\n * @note For texture sampling transpilation, apps need to use non-standard texture* calls in GLSL 3.00 source\n * RFC: https://github.com/visgl/luma.gl/blob/7.0-release/dev-docs/RFCs/v6.0/portable-glsl-300-rfc.md\n */\nexport function transpileGLSLShader(source, stage) {\n    const sourceGLSLVersion = Number(source.match(/^#version[ \\t]+(\\d+)/m)?.[1] || 100);\n    if (sourceGLSLVersion !== 300) {\n        // TODO - we splurge on a longer error message to help deck.gl custom layer developers\n        throw new Error('luma.gl v9 only supports GLSL 3.00 shader sources');\n    }\n    switch (stage) {\n        case 'vertex':\n            source = convertShader(source, ES300_VERTEX_REPLACEMENTS);\n            return source;\n        case 'fragment':\n            source = convertShader(source, ES300_FRAGMENT_REPLACEMENTS);\n            return source;\n        default:\n            // Unknown shader stage\n            throw new Error(stage);\n    }\n}\n/** Simple regex replacements for GLSL ES 1.00 syntax that has changed in GLSL ES 3.00 */\nconst ES300_REPLACEMENTS = [\n    // Fix poorly formatted version directive\n    [/^(#version[ \\t]+(100|300[ \\t]+es))?[ \\t]*\\n/, '#version 300 es\\n'],\n    // The individual `texture...()` functions were replaced with `texture()` overloads\n    [/\\btexture(2D|2DProj|Cube)Lod(EXT)?\\(/g, 'textureLod('],\n    [/\\btexture(2D|2DProj|Cube)(EXT)?\\(/g, 'texture(']\n];\nconst ES300_VERTEX_REPLACEMENTS = [\n    ...ES300_REPLACEMENTS,\n    // `attribute` keyword replaced with `in`\n    [makeVariableTextRegExp('attribute'), 'in $1'],\n    // `varying` keyword replaced with `out`\n    [makeVariableTextRegExp('varying'), 'out $1']\n];\n/** Simple regex replacements for GLSL ES 1.00 syntax that has changed in GLSL ES 3.00 */\nconst ES300_FRAGMENT_REPLACEMENTS = [\n    ...ES300_REPLACEMENTS,\n    // `varying` keyword replaced with `in`\n    [makeVariableTextRegExp('varying'), 'in $1']\n];\nfunction convertShader(source, replacements) {\n    for (const [pattern, replacement] of replacements) {\n        source = source.replace(pattern, replacement);\n    }\n    return source;\n}\n/**\n * Creates a regexp that tests for a specific variable type\n * @example\n *   should match:\n *     in float weight;\n *     out vec4 positions[2];\n *   should not match:\n *     void f(out float a, in float b) {}\n */\nfunction makeVariableTextRegExp(qualifier) {\n    return new RegExp(`\\\\b${qualifier}[ \\\\t]+(\\\\w+[ \\\\t]+\\\\w+(\\\\[\\\\w+\\\\])?;)`, 'g');\n}\n//# sourceMappingURL=transpile-glsl-shader.js.map","// luma.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n/** Generate hook source code */\nexport function getShaderHooks(hookFunctions, hookInjections) {\n    let result = '';\n    for (const hookName in hookFunctions) {\n        const hookFunction = hookFunctions[hookName];\n        result += `void ${hookFunction.signature} {\\n`;\n        if (hookFunction.header) {\n            result += `  ${hookFunction.header}`;\n        }\n        if (hookInjections[hookName]) {\n            const injections = hookInjections[hookName];\n            injections.sort((a, b) => a.order - b.order);\n            for (const injection of injections) {\n                result += `  ${injection.injection}\\n`;\n            }\n        }\n        if (hookFunction.footer) {\n            result += `  ${hookFunction.footer}`;\n        }\n        result += '}\\n';\n    }\n    return result;\n}\n/**\n * Parse string based hook functions\n * And split per shader\n */\nexport function normalizeShaderHooks(hookFunctions) {\n    const result = { vertex: {}, fragment: {} };\n    for (const hookFunction of hookFunctions) {\n        let opts;\n        let hook;\n        if (typeof hookFunction !== 'string') {\n            opts = hookFunction;\n            hook = opts.hook;\n        }\n        else {\n            opts = {};\n            hook = hookFunction;\n        }\n        hook = hook.trim();\n        const [shaderStage, signature] = hook.split(':');\n        const name = hook.replace(/\\(.+/, '');\n        const normalizedHook = Object.assign(opts, { signature });\n        switch (shaderStage) {\n            case 'vs':\n                result.vertex[name] = normalizedHook;\n                break;\n            case 'fs':\n                result.fragment[name] = normalizedHook;\n                break;\n            default:\n                throw new Error(shaderStage);\n        }\n    }\n    return result;\n}\n//# sourceMappingURL=shader-hooks.js.map","// luma.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\nimport { getShaderModuleDependencies } from \"../shader-module/shader-module-dependencies.js\";\nimport { getPlatformShaderDefines } from \"./platform-defines.js\";\nimport { injectShader, DECLARATION_INJECT_MARKER } from \"./shader-injections.js\";\nimport { transpileGLSLShader } from \"../shader-transpiler/transpile-glsl-shader.js\";\nimport { checkShaderModuleDeprecations } from \"../shader-module/shader-module.js\";\nimport { normalizeShaderHooks, getShaderHooks } from \"./shader-hooks.js\";\nimport { assert } from \"../utils/assert.js\";\nimport { getShaderInfo } from \"../glsl-utils/get-shader-info.js\";\nconst INJECT_SHADER_DECLARATIONS = `\\n\\n${DECLARATION_INJECT_MARKER}\\n`;\n/**\n * Precision prologue to inject before functions are injected in shader\n * TODO - extract any existing prologue in the fragment source and move it up...\n */\nconst FRAGMENT_SHADER_PROLOGUE = /* glsl */ `\\\nprecision highp float;\n`;\n/**\n * Inject a list of shader modules into a single shader source for WGSL\n */\nexport function assembleWGSLShader(options) {\n    const modules = getShaderModuleDependencies(options.modules || []);\n    return {\n        source: assembleShaderWGSL(options.platformInfo, {\n            ...options,\n            source: options.source,\n            stage: 'vertex',\n            modules\n        }),\n        getUniforms: assembleGetUniforms(modules)\n    };\n}\n/**\n * Injects dependent shader module sources into pair of main vertex/fragment shader sources for GLSL\n */\nexport function assembleGLSLShaderPair(options) {\n    const { vs, fs } = options;\n    const modules = getShaderModuleDependencies(options.modules || []);\n    return {\n        vs: assembleShaderGLSL(options.platformInfo, {\n            ...options,\n            source: vs,\n            stage: 'vertex',\n            modules\n        }),\n        fs: assembleShaderGLSL(options.platformInfo, {\n            ...options,\n            // @ts-expect-error\n            source: fs,\n            stage: 'fragment',\n            modules\n        }),\n        getUniforms: assembleGetUniforms(modules)\n    };\n}\n/**\n * Pulls together complete source code for either a vertex or a fragment shader\n * adding prologues, requested module chunks, and any final injections.\n * @param gl\n * @param options\n * @returns\n */\nexport function assembleShaderWGSL(platformInfo, options) {\n    const { \n    // id,\n    source, stage, modules, \n    // defines = {},\n    hookFunctions = [], inject = {}, log } = options;\n    assert(typeof source === 'string', 'shader source must be a string');\n    // const isVertex = type === 'vs';\n    // const sourceLines = source.split('\\n');\n    const coreSource = source;\n    // Combine Module and Application Defines\n    // const allDefines = {};\n    // modules.forEach(module => {\n    //   Object.assign(allDefines, module.getDefines());\n    // });\n    // Object.assign(allDefines, defines);\n    // Add platform defines (use these to work around platform-specific bugs and limitations)\n    // Add common defines (GLSL version compatibility, feature detection)\n    // Add precision declaration for fragment shaders\n    let assembledSource = '';\n    //   prologue\n    //     ? `\\\n    // ${getShaderNameDefine({id, source, type})}\n    // ${getShaderType(type)}\n    // ${getPlatformShaderDefines(platformInfo)}\n    // ${getApplicationDefines(allDefines)}\n    // ${isVertex ? '' : FRAGMENT_SHADER_PROLOGUE}\n    // `\n    // `;\n    const hookFunctionMap = normalizeShaderHooks(hookFunctions);\n    // Add source of dependent modules in resolved order\n    const hookInjections = {};\n    const declInjections = {};\n    const mainInjections = {};\n    for (const key in inject) {\n        const injection = typeof inject[key] === 'string' ? { injection: inject[key], order: 0 } : inject[key];\n        const match = /^(v|f)s:(#)?([\\w-]+)$/.exec(key);\n        if (match) {\n            const hash = match[2];\n            const name = match[3];\n            if (hash) {\n                if (name === 'decl') {\n                    declInjections[key] = [injection];\n                }\n                else {\n                    mainInjections[key] = [injection];\n                }\n            }\n            else {\n                hookInjections[key] = [injection];\n            }\n        }\n        else {\n            // Regex injection\n            mainInjections[key] = [injection];\n        }\n    }\n    // TODO - hack until shadertool modules support WebGPU\n    const modulesToInject = modules;\n    for (const module of modulesToInject) {\n        if (log) {\n            checkShaderModuleDeprecations(module, coreSource, log);\n        }\n        const moduleSource = getShaderModuleSource(module, 'wgsl');\n        // Add the module source, and a #define that declares it presence\n        assembledSource += moduleSource;\n        const injections = module.injections?.[stage] || {};\n        for (const key in injections) {\n            const match = /^(v|f)s:#([\\w-]+)$/.exec(key);\n            if (match) {\n                const name = match[2];\n                const injectionType = name === 'decl' ? declInjections : mainInjections;\n                injectionType[key] = injectionType[key] || [];\n                injectionType[key].push(injections[key]);\n            }\n            else {\n                hookInjections[key] = hookInjections[key] || [];\n                hookInjections[key].push(injections[key]);\n            }\n        }\n    }\n    // For injectShader\n    assembledSource += INJECT_SHADER_DECLARATIONS;\n    assembledSource = injectShader(assembledSource, stage, declInjections);\n    assembledSource += getShaderHooks(hookFunctionMap[stage], hookInjections);\n    // Add the version directive and actual source of this shader\n    assembledSource += coreSource;\n    // Apply any requested shader injections\n    assembledSource = injectShader(assembledSource, stage, mainInjections);\n    return assembledSource;\n}\n/**\n * Pulls together complete source code for either a vertex or a fragment shader\n * adding prologues, requested module chunks, and any final injections.\n * @param gl\n * @param options\n * @returns\n */\nfunction assembleShaderGLSL(platformInfo, options) {\n    const { id, source, stage, language = 'glsl', modules, defines = {}, hookFunctions = [], inject = {}, prologue = true, log } = options;\n    assert(typeof source === 'string', 'shader source must be a string');\n    const sourceVersion = language === 'glsl' ? getShaderInfo(source).version : -1;\n    const targetVersion = platformInfo.shaderLanguageVersion;\n    const sourceVersionDirective = sourceVersion === 100 ? '#version 100' : '#version 300 es';\n    const sourceLines = source.split('\\n');\n    // TODO : keep all pre-processor statements at the beginning of the shader.\n    const coreSource = sourceLines.slice(1).join('\\n');\n    // Combine Module and Application Defines\n    const allDefines = {};\n    modules.forEach(module => {\n        Object.assign(allDefines, module.defines);\n    });\n    Object.assign(allDefines, defines);\n    // Add platform defines (use these to work around platform-specific bugs and limitations)\n    // Add common defines (GLSL version compatibility, feature detection)\n    // Add precision declaration for fragment shaders\n    let assembledSource = '';\n    switch (language) {\n        case 'wgsl':\n            break;\n        case 'glsl':\n            assembledSource = prologue\n                ? `\\\n${sourceVersionDirective}\n\n// ----- PROLOGUE -------------------------\n${getShaderNameDefine({ id, source, stage })}\n${`#define SHADER_TYPE_${stage.toUpperCase()}`}\n\n${getPlatformShaderDefines(platformInfo)}\n${stage === 'fragment' ? FRAGMENT_SHADER_PROLOGUE : ''}\n\n// ----- APPLICATION DEFINES -------------------------\n\n${getApplicationDefines(allDefines)}\n\n`\n                : `${sourceVersionDirective}\n`;\n            break;\n    }\n    const hookFunctionMap = normalizeShaderHooks(hookFunctions);\n    // Add source of dependent modules in resolved order\n    const hookInjections = {};\n    const declInjections = {};\n    const mainInjections = {};\n    for (const key in inject) {\n        const injection = typeof inject[key] === 'string' ? { injection: inject[key], order: 0 } : inject[key];\n        const match = /^(v|f)s:(#)?([\\w-]+)$/.exec(key);\n        if (match) {\n            const hash = match[2];\n            const name = match[3];\n            if (hash) {\n                if (name === 'decl') {\n                    declInjections[key] = [injection];\n                }\n                else {\n                    mainInjections[key] = [injection];\n                }\n            }\n            else {\n                hookInjections[key] = [injection];\n            }\n        }\n        else {\n            // Regex injection\n            mainInjections[key] = [injection];\n        }\n    }\n    for (const module of modules) {\n        if (log) {\n            checkShaderModuleDeprecations(module, coreSource, log);\n        }\n        const moduleSource = getShaderModuleSource(module, stage);\n        // Add the module source, and a #define that declares it presence\n        assembledSource += moduleSource;\n        const injections = module.instance?.normalizedInjections[stage] || {};\n        for (const key in injections) {\n            const match = /^(v|f)s:#([\\w-]+)$/.exec(key);\n            if (match) {\n                const name = match[2];\n                const injectionType = name === 'decl' ? declInjections : mainInjections;\n                injectionType[key] = injectionType[key] || [];\n                injectionType[key].push(injections[key]);\n            }\n            else {\n                hookInjections[key] = hookInjections[key] || [];\n                hookInjections[key].push(injections[key]);\n            }\n        }\n    }\n    assembledSource += '// ----- MAIN SHADER SOURCE -------------------------';\n    // For injectShader\n    assembledSource += INJECT_SHADER_DECLARATIONS;\n    assembledSource = injectShader(assembledSource, stage, declInjections);\n    assembledSource += getShaderHooks(hookFunctionMap[stage], hookInjections);\n    // Add the version directive and actual source of this shader\n    assembledSource += coreSource;\n    // Apply any requested shader injections\n    assembledSource = injectShader(assembledSource, stage, mainInjections);\n    if (language === 'glsl' && sourceVersion !== targetVersion) {\n        assembledSource = transpileGLSLShader(assembledSource, stage);\n    }\n    return assembledSource.trim();\n}\n/**\n * Returns a combined `getUniforms` covering the options for all the modules,\n * the created function will pass on options to the inidividual `getUniforms`\n * function of each shader module and combine the results into one object that\n * can be passed to setUniforms.\n * @param modules\n * @returns\n */\nexport function assembleGetUniforms(modules) {\n    return function getUniforms(opts) {\n        const uniforms = {};\n        for (const module of modules) {\n            // `modules` is already sorted by dependency level. This guarantees that\n            // modules have access to the uniforms that are generated by their dependencies.\n            const moduleUniforms = module.getUniforms?.(opts, uniforms);\n            Object.assign(uniforms, moduleUniforms);\n        }\n        return uniforms;\n    };\n}\n/**\n * Generate \"glslify-compatible\" SHADER_NAME defines\n * These are understood by the GLSL error parsing function\n * If id is provided and no SHADER_NAME constant is present in source, create one\n */\nfunction getShaderNameDefine(options) {\n    const { id, source, stage } = options;\n    const injectShaderName = id && source.indexOf('SHADER_NAME') === -1;\n    return injectShaderName\n        ? `\n#define SHADER_NAME ${id}_${stage}`\n        : '';\n}\n/** Generates application defines from an object of key value pairs */\nfunction getApplicationDefines(defines = {}) {\n    let sourceText = '';\n    for (const define in defines) {\n        const value = defines[define];\n        if (value || Number.isFinite(value)) {\n            sourceText += `#define ${define.toUpperCase()} ${defines[define]}\\n`;\n        }\n    }\n    return sourceText;\n}\n/** Extracts the source code chunk for the specified shader type from the named shader module */\nexport function getShaderModuleSource(module, stage) {\n    let moduleSource;\n    switch (stage) {\n        case 'vertex':\n            moduleSource = module.vs || '';\n            break;\n        case 'fragment':\n            moduleSource = module.fs || '';\n            break;\n        case 'wgsl':\n            moduleSource = module.source || '';\n            break;\n        default:\n            assert(false);\n    }\n    if (!module.name) {\n        throw new Error('Shader module must have a name');\n    }\n    const moduleName = module.name.toUpperCase().replace(/[^0-9a-z]/gi, '_');\n    let source = `\\\n// ----- MODULE ${module.name} ---------------\n\n`;\n    if (stage !== 'wgsl') {\n        source += `#define MODULE_${moduleName}\\n`;\n    }\n    source += `${moduleSource}\\n`;\n    return source;\n}\n/*\nfunction getHookFunctions(\n  hookFunctions: Record<string, HookFunction>,\n  hookInjections: Record<string, Injection[]>\n): string {\n  let result = '';\n  for (const hookName in hookFunctions) {\n    const hookFunction = hookFunctions[hookName];\n    result += `void ${hookFunction.signature} {\\n`;\n    if (hookFunction.header) {\n      result += `  ${hookFunction.header}`;\n    }\n    if (hookInjections[hookName]) {\n      const injections = hookInjections[hookName];\n      injections.sort((a: {order: number}, b: {order: number}): number => a.order - b.order);\n      for (const injection of injections) {\n        result += `  ${injection.injection}\\n`;\n      }\n    }\n    if (hookFunction.footer) {\n      result += `  ${hookFunction.footer}`;\n    }\n    result += '}\\n';\n  }\n\n  return result;\n}\n\nfunction normalizeHookFunctions(hookFunctions: (string | HookFunction)[]): {\n  vs: Record<string, HookFunction>;\n  fs: Record<string, HookFunction>;\n} {\n  const result: {vs: Record<string, any>; fs: Record<string, any>} = {\n    vs: {},\n    fs: {}\n  };\n\n  hookFunctions.forEach((hookFunction: string | HookFunction) => {\n    let opts: HookFunction;\n    let hook: string;\n    if (typeof hookFunction !== 'string') {\n      opts = hookFunction;\n      hook = opts.hook;\n    } else {\n      opts = {} as HookFunction;\n      hook = hookFunction;\n    }\n    hook = hook.trim();\n    const [stage, signature] = hook.split(':');\n    const name = hook.replace(/\\(.+/, '');\n    if (stage !== 'vs' && stage !== 'fs') {\n      throw new Error(stage);\n    }\n    result[stage][name] = Object.assign(opts, {signature});\n  });\n\n  return result;\n}\n*/\n//# sourceMappingURL=assemble-shaders.js.map","// luma.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\nconst IFDEF_REGEXP = /^\\s*\\#\\s*ifdef\\s*([a-zA-Z_]+)\\s*$/;\nconst ENDIF_REGEXP = /^\\s*\\#\\s*endif\\s*$/;\nexport function preprocess(source, options) {\n    const lines = source.split('\\n');\n    const output = [];\n    let conditional = true;\n    let currentDefine = null;\n    for (const line of lines) {\n        const matchIf = line.match(IFDEF_REGEXP);\n        const matchEnd = line.match(ENDIF_REGEXP);\n        if (matchIf) {\n            currentDefine = matchIf[1];\n            conditional = Boolean(options?.defines?.[currentDefine]);\n        }\n        else if (matchEnd) {\n            conditional = true;\n        }\n        else if (conditional) {\n            output.push(line);\n        }\n    }\n    return output.join('\\n');\n}\n//# sourceMappingURL=preprocessor.js.map","// luma.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\nimport { initializeShaderModules } from \"./shader-module/shader-module.js\";\nimport { assembleWGSLShader, assembleGLSLShaderPair } from \"./shader-assembly/assemble-shaders.js\";\nimport { preprocess } from \"./preprocessor/preprocessor.js\";\n/**\n * A stateful version of `assembleShaders` that can be used to assemble shaders.\n * Supports setting of default modules and hooks.\n */\nexport class ShaderAssembler {\n    /** Default ShaderAssembler instance */\n    static defaultShaderAssembler;\n    /** Hook functions */\n    _hookFunctions = [];\n    /** Shader modules */\n    _defaultModules = [];\n    /**\n     * A default shader assembler instance - the natural place to register default modules and hooks\n     * @returns\n     */\n    static getDefaultShaderAssembler() {\n        ShaderAssembler.defaultShaderAssembler =\n            ShaderAssembler.defaultShaderAssembler || new ShaderAssembler();\n        return ShaderAssembler.defaultShaderAssembler;\n    }\n    /**\n     * Add a default module that does not have to be provided with every call to assembleShaders()\n     */\n    addDefaultModule(module) {\n        if (!this._defaultModules.find(m => m.name === (typeof module === 'string' ? module : module.name))) {\n            this._defaultModules.push(module);\n        }\n    }\n    /**\n     * Remove a default module\n     */\n    removeDefaultModule(module) {\n        const moduleName = typeof module === 'string' ? module : module.name;\n        this._defaultModules = this._defaultModules.filter(m => m.name !== moduleName);\n    }\n    /**\n     * Register a shader hook\n     * @param hook\n     * @param opts\n     */\n    addShaderHook(hook, opts) {\n        if (opts) {\n            hook = Object.assign(opts, { hook });\n        }\n        this._hookFunctions.push(hook);\n    }\n    /**\n     * Assemble a WGSL unified shader\n     * @param platformInfo\n     * @param props\n     * @returns\n     */\n    assembleWGSLShader(props) {\n        const modules = this._getModuleList(props.modules); // Combine with default modules\n        const hookFunctions = this._hookFunctions; // TODO - combine with default hook functions\n        const { source, getUniforms } = assembleWGSLShader({\n            ...props,\n            // @ts-expect-error\n            source: props.source,\n            modules,\n            hookFunctions\n        });\n        // WGSL does not have built-in preprocessing support (just compile time constants)\n        const preprocessedSource = props.platformInfo.shaderLanguage === 'wgsl' ? preprocess(source) : source;\n        return { source: preprocessedSource, getUniforms, modules };\n    }\n    /**\n     * Assemble a pair of shaders into a single shader program\n     * @param platformInfo\n     * @param props\n     * @returns\n     */\n    assembleGLSLShaderPair(props) {\n        const modules = this._getModuleList(props.modules); // Combine with default modules\n        const hookFunctions = this._hookFunctions; // TODO - combine with default hook functions\n        const assembled = assembleGLSLShaderPair({\n            ...props,\n            // @ts-expect-error\n            vs: props.vs,\n            // @ts-expect-error\n            fs: props.fs,\n            modules,\n            hookFunctions\n        });\n        return { ...assembled, modules };\n    }\n    /**\n     * Dedupe and combine with default modules\n     */\n    _getModuleList(appModules = []) {\n        const modules = new Array(this._defaultModules.length + appModules.length);\n        const seen = {};\n        let count = 0;\n        for (let i = 0, len = this._defaultModules.length; i < len; ++i) {\n            const module = this._defaultModules[i];\n            const name = module.name;\n            modules[count++] = module;\n            seen[name] = true;\n        }\n        for (let i = 0, len = appModules.length; i < len; ++i) {\n            const module = appModules[i];\n            const name = module.name;\n            if (!seen[name]) {\n                modules[count++] = module;\n                seen[name] = true;\n            }\n        }\n        modules.length = count;\n        initializeShaderModules(modules);\n        return modules;\n    }\n}\n//# sourceMappingURL=shader-assembler.js.map","// luma.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\nconst FS_GLES = /* glsl */ `\\\nout vec4 transform_output;\nvoid main() {\n  transform_output = vec4(0);\n}`;\nconst FS300 = `#version 300 es\\n${FS_GLES}`;\n// Prase given glsl line and return qualifier details or null\nexport function getQualifierDetails(line, qualifiers) {\n    qualifiers = Array.isArray(qualifiers) ? qualifiers : [qualifiers];\n    const words = line.replace(/^\\s+/, '').split(/\\s+/);\n    // TODO add support for precession qualifiers (highp, mediump and lowp)\n    const [qualifier, type, definition] = words;\n    if (!qualifiers.includes(qualifier) || !type || !definition) {\n        return null;\n    }\n    const name = definition.split(';')[0];\n    return { qualifier, type, name };\n}\n/**\n * Given the shader input and output variable names,\n * builds and return a pass through fragment shader.\n */\nexport function getPassthroughFS(options) {\n    const { input, inputChannels, output } = options || {};\n    if (!input) {\n        // Default shader\n        return FS300;\n    }\n    if (!inputChannels) {\n        throw new Error('inputChannels');\n    }\n    const inputType = channelCountToType(inputChannels);\n    const outputValue = convertToVec4(input, inputChannels);\n    return `\\\n#version 300 es\nin ${inputType} ${input};\nout vec4 ${output};\nvoid main() {\n  ${output} = ${outputValue};\n}`;\n}\n/** convert glsl type to suffix */\nexport function typeToChannelSuffix(type) {\n    // prettier-ignore\n    switch (type) {\n        case 'float': return 'x';\n        case 'vec2': return 'xy';\n        case 'vec3': return 'xyz';\n        case 'vec4': return 'xyzw';\n        default:\n            throw new Error(type);\n    }\n}\n/** convert glsl type to channel count */\nexport function typeToChannelCount(type) {\n    // prettier-ignore\n    switch (type) {\n        case 'float': return 1;\n        case 'vec2': return 2;\n        case 'vec3': return 3;\n        case 'vec4': return 4;\n        default:\n            throw new Error(type);\n    }\n}\nfunction channelCountToType(channels) {\n    // prettier-ignore\n    switch (channels) {\n        case 1: return 'float';\n        case 2: return 'vec2';\n        case 3: return 'vec3';\n        case 4: return 'vec4';\n        default:\n            throw new Error(`invalid channels: ${channels}`);\n    }\n}\n/** Returns glsl instruction for converting to vec4 */\nexport function convertToVec4(variable, channels) {\n    // prettier-ignore\n    switch (channels) {\n        case 1: return `vec4(${variable}, 0.0, 0.0, 1.0)`;\n        case 2: return `vec4(${variable}, 0.0, 1.0)`;\n        case 3: return `vec4(${variable}, 1.0)`;\n        case 4: return variable;\n        default:\n            throw new Error(`invalid channels: ${channels}`);\n    }\n}\n//# sourceMappingURL=shader-utils.js.map","// luma.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n/** @returns annotated errors or warnings */\nexport function formatCompilerLog(shaderLog, source, options) {\n    let formattedLog = '';\n    const lines = source.split(/\\r?\\n/);\n    const log = shaderLog.slice().sort((a, b) => a.lineNum - b.lineNum);\n    switch (options?.showSourceCode || 'no') {\n        case 'all':\n            // Parse the error - note: browser and driver dependent\n            let currentMessage = 0;\n            for (let lineNum = 1; lineNum <= lines.length; lineNum++) {\n                formattedLog += getNumberedLine(lines[lineNum - 1], lineNum, options);\n                while (log.length > currentMessage && log[currentMessage].lineNum === lineNum) {\n                    const message = log[currentMessage++];\n                    formattedLog += formatCompilerMessage(message, lines, message.lineNum, {\n                        ...options,\n                        inlineSource: false\n                    });\n                }\n            }\n            return formattedLog;\n        case 'issues':\n        case 'no':\n            // Parse the error - note: browser and driver dependent\n            for (const message of shaderLog) {\n                formattedLog += formatCompilerMessage(message, lines, message.lineNum, {\n                    inlineSource: options?.showSourceCode !== 'no'\n                });\n            }\n            return formattedLog;\n    }\n}\n// Helpers\n/** Format one message */\nfunction formatCompilerMessage(message, lines, lineNum, options) {\n    if (options?.inlineSource) {\n        const numberedLines = getNumberedLines(lines, lineNum);\n        // If we got error position on line add a `^^^` indicator on next line\n        const positionIndicator = message.linePos > 0 ? `${' '.repeat(message.linePos + 5)}^^^\\n` : '';\n        return `\n${numberedLines}${positionIndicator}${message.type.toUpperCase()}: ${message.message}\n\n`;\n    }\n    const color = message.type === 'error' ? 'red' : '#8B4000'; // dark orange\n    return options?.html\n        ? `<div class='luma-compiler-log-error' style=\"color:${color};\"><b> ${message.type.toUpperCase()}: ${message.message}</b></div>`\n        : `${message.type.toUpperCase()}: ${message.message}`;\n}\nfunction getNumberedLines(lines, lineNum, options) {\n    let numberedLines = '';\n    for (let lineIndex = lineNum - 2; lineIndex <= lineNum; lineIndex++) {\n        const sourceLine = lines[lineIndex - 1];\n        if (sourceLine !== undefined) {\n            numberedLines += getNumberedLine(sourceLine, lineNum, options);\n        }\n    }\n    return numberedLines;\n}\nfunction getNumberedLine(line, lineNum, options) {\n    const escapedLine = options?.html ? escapeHTML(line) : line;\n    return `${padLeft(String(lineNum), 4)}: ${escapedLine}${options?.html ? '<br/>' : '\\n'}`;\n}\n/**\n * Pads a string with a number of spaces (space characters) to the left\n * @param {String} string - string to pad\n * @param {Number} digits - number of spaces to add\n * @return {String} string - The padded string\n */\nfunction padLeft(string, paddedLength) {\n    let result = '';\n    for (let i = string.length; i < paddedLength; ++i) {\n        result += ' ';\n    }\n    return result + string;\n}\nfunction escapeHTML(unsafe) {\n    return unsafe\n        .replaceAll('&', '&amp;')\n        .replaceAll('<', '&lt;')\n        .replaceAll('>', '&gt;')\n        .replaceAll('\"', '&quot;')\n        .replaceAll(\"'\", '&#039;');\n}\n//# sourceMappingURL=format-compiler-log.js.map","// luma.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\nimport { Resource } from \"./resource.js\";\n// import { log } from '../../utils/log';\nimport { uid } from \"../../utils/uid.js\";\nimport { formatCompilerLog } from \"../../adapter-utils/format-compiler-log.js\";\n/**\n * Immutable Shader object\n * In WebGPU the handle can be copied between threads\n */\nexport class Shader extends Resource {\n    static defaultProps = {\n        ...Resource.defaultProps,\n        language: 'auto',\n        stage: undefined,\n        source: '',\n        sourceMap: null,\n        entryPoint: 'main',\n        debugShaders: undefined\n    };\n    get [Symbol.toStringTag]() {\n        return 'Shader';\n    }\n    /** The stage of this shader */\n    stage;\n    /** The source code of this shader */\n    source;\n    /** The compilation status of the shader. 'pending' if compilation is asynchronous, and on production */\n    compilationStatus = 'pending';\n    /** Create a new Shader instance */\n    constructor(device, props) {\n        props = { ...props, debugShaders: props.debugShaders || device.props.debugShaders || 'errors' };\n        super(device, { id: getShaderIdFromProps(props), ...props }, Shader.defaultProps);\n        this.stage = this.props.stage;\n        this.source = this.props.source;\n    }\n    /** Get compiler log synchronously (WebGL only) */\n    getCompilationInfoSync() {\n        return null;\n    }\n    /** Get translated shader source in host platform's native language (HLSL, GLSL, and even GLSL ES), if available */\n    getTranslatedSource() {\n        return null;\n    }\n    // PORTABLE HELPERS\n    /** In browser logging of errors */\n    async debugShader() {\n        const trigger = this.props.debugShaders;\n        switch (trigger) {\n            case 'never':\n                return;\n            case 'errors':\n                // On WebGL - Don't extract the log unless errors\n                if (this.compilationStatus === 'success') {\n                    return;\n                }\n                break;\n            case 'warnings':\n            case 'always':\n                break;\n        }\n        const messages = await this.getCompilationInfo();\n        if (trigger === 'warnings' && messages?.length === 0) {\n            return;\n        }\n        this._displayShaderLog(messages);\n    }\n    // PRIVATE\n    /**\n     * In-browser UI logging of errors\n     * TODO - this HTML formatting code should not be in Device, should be pluggable\n     */\n    _displayShaderLog(messages) {\n        // Return if under Node.js / incomplete `document` polyfills\n        if (typeof document === 'undefined' || !document?.createElement) {\n            return;\n        }\n        const shaderName = getShaderName(this.source);\n        const shaderTitle = `${this.stage} ${shaderName}`;\n        let htmlLog = formatCompilerLog(messages, this.source, { showSourceCode: 'all', html: true });\n        // Show translated source if available\n        const translatedSource = this.getTranslatedSource();\n        if (translatedSource) {\n            htmlLog += `<br /><br /><h1>Translated Source</h1><br /><br /><code style=\"user-select:text;\"><pre>${translatedSource}</pre></code>`;\n        }\n        // Make it clickable so we can copy to clipboard\n        const button = document.createElement('Button');\n        button.innerHTML = `\n<h1>Shader Compilation Error in ${shaderTitle}</h1><br /><br />\n<code style=\"user-select:text;\"><pre>\n${htmlLog}\n</pre></code>`;\n        button.style.top = '10px';\n        button.style.left = '10px';\n        button.style.position = 'absolute';\n        button.style.zIndex = '9999';\n        button.style.width = '100%';\n        button.style.textAlign = 'left';\n        document.body.appendChild(button);\n        const errors = document.getElementsByClassName('luma-compiler-log-error');\n        errors[0]?.scrollIntoView();\n        // TODO - add a small embedded copy button (instead of main button)\n        button.onclick = () => {\n            // const source = this.source.replaceAll('\\n', '<br />');\n            const dataURI = `data:text/plain,${encodeURIComponent(this.source)}`;\n            navigator.clipboard.writeText(dataURI);\n        };\n        // TODO - add a small embedded close button\n    }\n}\n// HELPERS\n/** Deduce an id, from shader source, or supplied id, or shader type */\nfunction getShaderIdFromProps(props) {\n    return getShaderName(props.source) || props.id || uid(`unnamed ${props.stage}-shader`);\n}\n/** Extracts GLSLIFY style naming of shaders: `#define SHADER_NAME ...` */\nfunction getShaderName(shader, defaultName = 'unnamed') {\n    const SHADER_NAME_REGEXP = /#define[\\s*]SHADER_NAME[\\s*]([A-Za-z0-9_-]+)[\\s*]/;\n    const match = SHADER_NAME_REGEXP.exec(shader);\n    return match ? match[1] : defaultName;\n}\n//# sourceMappingURL=shader.js.map","class e{constructor(e,t){this.name=e,this.attributes=t,this.size=0}get isArray(){return!1}get isStruct(){return!1}get isTemplate(){return!1}getTypeName(){return this.name}}class t{constructor(e,t,n){this.name=e,this.type=t,this.attributes=n,this.offset=0,this.size=0}get isArray(){return this.type.isArray}get isStruct(){return this.type.isStruct}get isTemplate(){return this.type.isTemplate}get align(){return this.type.isStruct?this.type.align:0}get members(){return this.type.isStruct?this.type.members:null}get format(){return this.type.isArray||this.type.isTemplate?this.type.format:null}get count(){return this.type.isArray?this.type.count:0}get stride(){return this.type.isArray?this.type.stride:this.size}}class n extends e{constructor(e,t){super(e,t),this.members=[],this.align=0,this.startLine=-1,this.endLine=-1,this.inUse=!1}get isStruct(){return!0}}class s extends e{constructor(e,t){super(e,t),this.count=0,this.stride=0}get isArray(){return!0}}class r extends e{constructor(e,t,n,s){super(e,n),this.format=t,this.access=s}get isTemplate(){return!0}getTypeName(){let e=this.name;if(null!==this.format){if('vec2'===e||'vec3'===e||'vec4'===e||'mat2x2'===e||'mat2x3'===e||'mat2x4'===e||'mat3x2'===e||'mat3x3'===e||'mat3x4'===e||'mat4x2'===e||'mat4x3'===e||'mat4x4'===e){if('f32'===this.format.name)return e+='f',e;if('i32'===this.format.name)return e+='i',e;if('u32'===this.format.name)return e+='u',e;if('bool'===this.format.name)return e+='b',e;if('f16'===this.format.name)return e+='h',e}e+=`<${this.format.name}>`}else if('vec2'===e||'vec3'===e||'vec4'===e)return e;return e}}var a;(e=>{e[e.Uniform=0]='Uniform',e[e.Storage=1]='Storage',e[e.Texture=2]='Texture',e[e.Sampler=3]='Sampler',e[e.StorageTexture=4]='StorageTexture'})(a||(a={}));class i{constructor(e,t,n,s,r,a,i){this.name=e,this.type=t,this.group=n,this.binding=s,this.attributes=r,this.resourceType=a,this.access=i}get isArray(){return this.type.isArray}get isStruct(){return this.type.isStruct}get isTemplate(){return this.type.isTemplate}get size(){return this.type.size}get align(){return this.type.isStruct?this.type.align:0}get members(){return this.type.isStruct?this.type.members:null}get format(){return this.type.isArray||this.type.isTemplate?this.type.format:null}get count(){return this.type.isArray?this.type.count:0}get stride(){return this.type.isArray?this.type.stride:this.size}}class o{constructor(e,t){this.name=e,this.type=t}}class l{constructor(e,t,n,s){this.name=e,this.type=t,this.locationType=n,this.location=s,this.interpolation=null}}class c{constructor(e,t,n,s){this.name=e,this.type=t,this.locationType=n,this.location=s}}class u{constructor(e,t,n,s){this.name=e,this.type=t,this.attributes=n,this.id=s}}class h{constructor(e,t,n){this.name=e,this.type=t,this.attributes=n}}class f{constructor(e,t=null,n){this.stage=null,this.inputs=[],this.outputs=[],this.arguments=[],this.returnType=null,this.resources=[],this.overrides=[],this.startLine=-1,this.endLine=-1,this.inUse=!1,this.calls=new Set,this.name=e,this.stage=t,this.attributes=n}}class p{constructor(){this.vertex=[],this.fragment=[],this.compute=[]}}const d=new Float32Array(1),m=new Int32Array(d.buffer),_=new Uint16Array(1);function g(e){d[0]=e;const t=m[0],n=t>>31&1;let s=t>>23&255,r=8388607&t;if(255===s)return _[0]=n<<15|31744|(0!==r?512:0),_[0];if(0===s){if(0===r)return _[0]=n<<15,_[0];r|=8388608;let e=113;for(;!(8388608&r);)r<<=1,e--;return s=127-e,r&=8388607,s>0?(r=(r>>126-s)+(r>>127-s&1),_[0]=n<<15|s<<10|r>>13,_[0]):(_[0]=n<<15,_[0])}return s=s-127+15,s>=31?(_[0]=n<<15|31744,_[0]):s<=0?s<-10?(_[0]=n<<15,_[0]):(r=(8388608|r)>>1-s,_[0]=n<<15|r>>13,_[0]):(r>>=13,_[0]=n<<15|s<<10|r,_[0])}const x=new Uint32Array(1),y=new Float32Array(x.buffer,0,1);function b(e){const t=112+(e>>6&31)<<23|(63&e)<<17;return x[0]=t,y[0]}function v(e,t,n,s,r,a,i,o,l){const c=s*(i>>=r)*(a>>=r)+n*i+t*o;switch(l){case'r8unorm':return[w(e,c,'8unorm',1)[0]];case'r8snorm':return[w(e,c,'8snorm',1)[0]];case'r8uint':return[w(e,c,'8uint',1)[0]];case'r8sint':return[w(e,c,'8sint',1)[0]];case'rg8unorm':{const t=w(e,c,'8unorm',2);return[t[0],t[1]]}case'rg8snorm':{const t=w(e,c,'8snorm',2);return[t[0],t[1]]}case'rg8uint':{const t=w(e,c,'8uint',2);return[t[0],t[1]]}case'rg8sint':{const t=w(e,c,'8sint',2);return[t[0],t[1]]}case'rgba8unorm-srgb':case'rgba8unorm':{const t=w(e,c,'8unorm',4);return[t[0],t[1],t[2],t[3]]}case'rgba8snorm':{const t=w(e,c,'8snorm',4);return[t[0],t[1],t[2],t[3]]}case'rgba8uint':{const t=w(e,c,'8uint',4);return[t[0],t[1],t[2],t[3]]}case'rgba8sint':{const t=w(e,c,'8sint',4);return[t[0],t[1],t[2],t[3]]}case'bgra8unorm-srgb':case'bgra8unorm':{const t=w(e,c,'8unorm',4);return[t[2],t[1],t[0],t[3]]}case'r16uint':return[w(e,c,'16uint',1)[0]];case'r16sint':return[w(e,c,'16sint',1)[0]];case'r16float':return[w(e,c,'16float',1)[0]];case'rg16uint':{const t=w(e,c,'16uint',2);return[t[0],t[1]]}case'rg16sint':{const t=w(e,c,'16sint',2);return[t[0],t[1]]}case'rg16float':{const t=w(e,c,'16float',2);return[t[0],t[1]]}case'rgba16uint':{const t=w(e,c,'16uint',4);return[t[0],t[1],t[2],t[3]]}case'rgba16sint':{const t=w(e,c,'16sint',4);return[t[0],t[1],t[2],t[3]]}case'rgba16float':{const t=w(e,c,'16float',4);return[t[0],t[1],t[2],t[3]]}case'r32uint':return[w(e,c,'32uint',1)[0]];case'r32sint':return[w(e,c,'32sint',1)[0]];case'depth16unorm':case'depth24plus':case'depth24plus-stencil8':case'depth32float':case'depth32float-stencil8':case'r32float':return[w(e,c,'32float',1)[0]];case'rg32uint':{const t=w(e,c,'32uint',2);return[t[0],t[1]]}case'rg32sint':{const t=w(e,c,'32sint',2);return[t[0],t[1]]}case'rg32float':{const t=w(e,c,'32float',2);return[t[0],t[1]]}case'rgba32uint':{const t=w(e,c,'32uint',4);return[t[0],t[1],t[2],t[3]]}case'rgba32sint':{const t=w(e,c,'32sint',4);return[t[0],t[1],t[2],t[3]]}case'rgba32float':{const t=w(e,c,'32float',4);return[t[0],t[1],t[2],t[3]]}case'rg11b10ufloat':{const t=new Uint32Array(e.buffer,c,1)[0],n=(4192256&t)>>11,s=(4290772992&t)>>22;return[b(2047&t),b(n),function(e){const t=112+(e>>5&31)<<23|(31&e)<<18;return x[0]=t,y[0]}(s),1]}}return null}function w(e,t,n,s){const r=[0,0,0,0];for(let c=0;c<s;++c)switch(n){case'8unorm':r[c]=e[t]/255,t++;break;case'8snorm':r[c]=e[t]/255*2-1,t++;break;case'8uint':r[c]=e[t],t++;break;case'8sint':r[c]=e[t]-127,t++;break;case'16uint':r[c]=e[t]|e[t+1]<<8,t+=2;break;case'16sint':r[c]=(e[t]|e[t+1]<<8)-32768,t+=2;break;case'16float':r[c]=(a=e[t]|e[t+1]<<8,i=void 0,o=void 0,l=void 0,i=(32768&a)>>15,l=1023&a,0==(o=(31744&a)>>10)?(i?-1:1)*Math.pow(2,-14)*(l/Math.pow(2,10)):31==o?l?NaN:1/0*(i?-1:1):(i?-1:1)*Math.pow(2,o-15)*(1+l/Math.pow(2,10))),t+=2;break;case'32uint':case'32sint':r[c]=e[t]|e[t+1]<<8|e[t+2]<<16|e[t+3]<<24,t+=4;break;case'32float':r[c]=new Float32Array(e.buffer,t,1)[0],t+=4}var a,i,o,l;return r}function k(e,t,n,s,r){for(let a=0;a<s;++a)switch(n){case'8unorm':e[t]=255*r[a],t++;break;case'8snorm':e[t]=.5*(r[a]+1)*255,t++;break;case'8uint':e[t]=r[a],t++;break;case'8sint':e[t]=r[a]+127,t++;break;case'16uint':new Uint16Array(e.buffer,t,1)[0]=r[a],t+=2;break;case'16sint':new Int16Array(e.buffer,t,1)[0]=r[a],t+=2;break;case'16float':{const n=g(r[a]);new Uint16Array(e.buffer,t,1)[0]=n,t+=2;break}case'32uint':new Uint32Array(e.buffer,t,1)[0]=r[a],t+=4;break;case'32sint':new Int32Array(e.buffer,t,1)[0]=r[a],t+=4;break;case'32float':new Float32Array(e.buffer,t,1)[0]=r[a],t+=4}return r}const I={r8unorm:{bytesPerBlock:1,blockWidth:1,blockHeight:1,isCompressed:!1,channels:1},r8snorm:{bytesPerBlock:1,blockWidth:1,blockHeight:1,isCompressed:!1,channels:1},r8uint:{bytesPerBlock:1,blockWidth:1,blockHeight:1,isCompressed:!1,channels:1},r8sint:{bytesPerBlock:1,blockWidth:1,blockHeight:1,isCompressed:!1,channels:1},rg8unorm:{bytesPerBlock:2,blockWidth:1,blockHeight:1,isCompressed:!1,channels:2},rg8snorm:{bytesPerBlock:2,blockWidth:1,blockHeight:1,isCompressed:!1,channels:2},rg8uint:{bytesPerBlock:2,blockWidth:1,blockHeight:1,isCompressed:!1,channels:2},rg8sint:{bytesPerBlock:2,blockWidth:1,blockHeight:1,isCompressed:!1,channels:2},rgba8unorm:{bytesPerBlock:4,blockWidth:1,blockHeight:1,isCompressed:!1,channels:4},'rgba8unorm-srgb':{bytesPerBlock:4,blockWidth:1,blockHeight:1,isCompressed:!1,channels:4},rgba8snorm:{bytesPerBlock:4,blockWidth:1,blockHeight:1,isCompressed:!1,channels:4},rgba8uint:{bytesPerBlock:4,blockWidth:1,blockHeight:1,isCompressed:!1,channels:4},rgba8sint:{bytesPerBlock:4,blockWidth:1,blockHeight:1,isCompressed:!1,channels:4},bgra8unorm:{bytesPerBlock:4,blockWidth:1,blockHeight:1,isCompressed:!1,channels:4},'bgra8unorm-srgb':{bytesPerBlock:4,blockWidth:1,blockHeight:1,isCompressed:!1,channels:4},r16uint:{bytesPerBlock:2,blockWidth:1,blockHeight:1,isCompressed:!1,channels:1},r16sint:{bytesPerBlock:2,blockWidth:1,blockHeight:1,isCompressed:!1,channels:1},r16float:{bytesPerBlock:2,blockWidth:1,blockHeight:1,isCompressed:!1,channels:1},rg16uint:{bytesPerBlock:4,blockWidth:1,blockHeight:1,isCompressed:!1,channels:2},rg16sint:{bytesPerBlock:4,blockWidth:1,blockHeight:1,isCompressed:!1,channels:2},rg16float:{bytesPerBlock:4,blockWidth:1,blockHeight:1,isCompressed:!1,channels:2},rgba16uint:{bytesPerBlock:8,blockWidth:1,blockHeight:1,isCompressed:!1,channels:4},rgba16sint:{bytesPerBlock:8,blockWidth:1,blockHeight:1,isCompressed:!1,channels:4},rgba16float:{bytesPerBlock:8,blockWidth:1,blockHeight:1,isCompressed:!1,channels:4},r32uint:{bytesPerBlock:4,blockWidth:1,blockHeight:1,isCompressed:!1,channels:1},r32sint:{bytesPerBlock:4,blockWidth:1,blockHeight:1,isCompressed:!1,channels:1},r32float:{bytesPerBlock:4,blockWidth:1,blockHeight:1,isCompressed:!1,channels:1},rg32uint:{bytesPerBlock:8,blockWidth:1,blockHeight:1,isCompressed:!1,channels:2},rg32sint:{bytesPerBlock:8,blockWidth:1,blockHeight:1,isCompressed:!1,channels:2},rg32float:{bytesPerBlock:8,blockWidth:1,blockHeight:1,isCompressed:!1,channels:2},rgba32uint:{bytesPerBlock:16,blockWidth:1,blockHeight:1,isCompressed:!1,channels:4},rgba32sint:{bytesPerBlock:16,blockWidth:1,blockHeight:1,isCompressed:!1,channels:4},rgba32float:{bytesPerBlock:16,blockWidth:1,blockHeight:1,isCompressed:!1,channels:4},rgb10a2uint:{bytesPerBlock:4,blockWidth:1,blockHeight:1,isCompressed:!1,channels:4},rgb10a2unorm:{bytesPerBlock:4,blockWidth:1,blockHeight:1,isCompressed:!1,channels:4},rg11b10ufloat:{bytesPerBlock:4,blockWidth:1,blockHeight:1,isCompressed:!1,channels:4},stencil8:{bytesPerBlock:1,blockWidth:1,blockHeight:1,isCompressed:!1,isDepthStencil:!0,hasDepth:!1,hasStencil:!0,channels:1},depth16unorm:{bytesPerBlock:2,blockWidth:1,blockHeight:1,isCompressed:!1,isDepthStencil:!0,hasDepth:!0,hasStencil:!1,channels:1},depth24plus:{bytesPerBlock:4,blockWidth:1,blockHeight:1,isCompressed:!1,isDepthStencil:!0,hasDepth:!0,hasStencil:!1,depthOnlyFormat:'depth32float',channels:1},'depth24plus-stencil8':{bytesPerBlock:8,blockWidth:1,blockHeight:1,isCompressed:!1,isDepthStencil:!0,hasDepth:!0,hasStencil:!0,depthOnlyFormat:'depth32float',channels:1},depth32float:{bytesPerBlock:4,blockWidth:1,blockHeight:1,isCompressed:!1,isDepthStencil:!0,hasDepth:!0,hasStencil:!1,channels:1},'depth32float-stencil8':{bytesPerBlock:8,blockWidth:1,blockHeight:1,isCompressed:!1,isDepthStencil:!0,hasDepth:!0,hasStencil:!0,stencilOnlyFormat:'depth32float',channels:1},rgb9e5ufloat:{bytesPerBlock:4,blockWidth:1,blockHeight:1,isCompressed:!1,channels:4},'bc1-rgba-unorm':{bytesPerBlock:8,blockWidth:4,blockHeight:4,isCompressed:!0,channels:4},'bc1-rgba-unorm-srgb':{bytesPerBlock:8,blockWidth:4,blockHeight:4,isCompressed:!0,channels:4},'bc2-rgba-unorm':{bytesPerBlock:16,blockWidth:4,blockHeight:4,isCompressed:!0,channels:4},'bc2-rgba-unorm-srgb':{bytesPerBlock:16,blockWidth:4,blockHeight:4,isCompressed:!0,channels:4},'bc3-rgba-unorm':{bytesPerBlock:16,blockWidth:4,blockHeight:4,isCompressed:!0,channels:4},'bc3-rgba-unorm-srgb':{bytesPerBlock:16,blockWidth:4,blockHeight:4,isCompressed:!0,channels:4},'bc4-r-unorm':{bytesPerBlock:8,blockWidth:4,blockHeight:4,isCompressed:!0,channels:1},'bc4-r-snorm':{bytesPerBlock:8,blockWidth:4,blockHeight:4,isCompressed:!0,channels:1},'bc5-rg-unorm':{bytesPerBlock:16,blockWidth:4,blockHeight:4,isCompressed:!0,channels:2},'bc5-rg-snorm':{bytesPerBlock:16,blockWidth:4,blockHeight:4,isCompressed:!0,channels:2},'bc6h-rgb-ufloat':{bytesPerBlock:16,blockWidth:4,blockHeight:4,isCompressed:!0,channels:4},'bc6h-rgb-float':{bytesPerBlock:16,blockWidth:4,blockHeight:4,isCompressed:!0,channels:4},'bc7-rgba-unorm':{bytesPerBlock:16,blockWidth:4,blockHeight:4,isCompressed:!0,channels:4},'bc7-rgba-unorm-srgb':{bytesPerBlock:16,blockWidth:4,blockHeight:4,isCompressed:!0,channels:4},'etc2-rgb8unorm':{bytesPerBlock:8,blockWidth:4,blockHeight:4,isCompressed:!0,channels:4},'etc2-rgb8unorm-srgb':{bytesPerBlock:8,blockWidth:4,blockHeight:4,isCompressed:!0,channels:4},'etc2-rgb8a1unorm':{bytesPerBlock:8,blockWidth:4,blockHeight:4,isCompressed:!0,channels:4},'etc2-rgb8a1unorm-srgb':{bytesPerBlock:8,blockWidth:4,blockHeight:4,isCompressed:!0,channels:4},'etc2-rgba8unorm':{bytesPerBlock:16,blockWidth:4,blockHeight:4,isCompressed:!0,channels:4},'etc2-rgba8unorm-srgb':{bytesPerBlock:16,blockWidth:4,blockHeight:4,isCompressed:!0,channels:4},'eac-r11unorm':{bytesPerBlock:8,blockWidth:1,blockHeight:1,isCompressed:!0,channels:1},'eac-r11snorm':{bytesPerBlock:8,blockWidth:1,blockHeight:1,isCompressed:!0,channels:1},'eac-rg11unorm':{bytesPerBlock:16,blockWidth:1,blockHeight:1,isCompressed:!0,channels:2},'eac-rg11snorm':{bytesPerBlock:16,blockWidth:1,blockHeight:1,isCompressed:!0,channels:2},'astc-4x4-unorm':{bytesPerBlock:16,blockWidth:4,blockHeight:4,isCompressed:!0,channels:4},'astc-4x4-unorm-srgb':{bytesPerBlock:16,blockWidth:4,blockHeight:4,isCompressed:!0,channels:4},'astc-5x4-unorm':{bytesPerBlock:16,blockWidth:5,blockHeight:4,isCompressed:!0,channels:4},'astc-5x4-unorm-srgb':{bytesPerBlock:16,blockWidth:5,blockHeight:4,isCompressed:!0,channels:4},'astc-5x5-unorm':{bytesPerBlock:16,blockWidth:5,blockHeight:5,isCompressed:!0,channels:4},'astc-5x5-unorm-srgb':{bytesPerBlock:16,blockWidth:5,blockHeight:5,isCompressed:!0,channels:4},'astc-6x5-unorm':{bytesPerBlock:16,blockWidth:6,blockHeight:5,isCompressed:!0,channels:4},'astc-6x5-unorm-srgb':{bytesPerBlock:16,blockWidth:6,blockHeight:5,isCompressed:!0,channels:4},'astc-6x6-unorm':{bytesPerBlock:16,blockWidth:6,blockHeight:6,isCompressed:!0,channels:4},'astc-6x6-unorm-srgb':{bytesPerBlock:16,blockWidth:6,blockHeight:6,isCompressed:!0,channels:4},'astc-8x5-unorm':{bytesPerBlock:16,blockWidth:8,blockHeight:5,isCompressed:!0,channels:4},'astc-8x5-unorm-srgb':{bytesPerBlock:16,blockWidth:8,blockHeight:5,isCompressed:!0,channels:4},'astc-8x6-unorm':{bytesPerBlock:16,blockWidth:8,blockHeight:6,isCompressed:!0,channels:4},'astc-8x6-unorm-srgb':{bytesPerBlock:16,blockWidth:8,blockHeight:6,isCompressed:!0,channels:4},'astc-8x8-unorm':{bytesPerBlock:16,blockWidth:8,blockHeight:8,isCompressed:!0,channels:4},'astc-8x8-unorm-srgb':{bytesPerBlock:16,blockWidth:8,blockHeight:8,isCompressed:!0,channels:4},'astc-10x5-unorm':{bytesPerBlock:16,blockWidth:10,blockHeight:5,isCompressed:!0,channels:4},'astc-10x5-unorm-srgb':{bytesPerBlock:16,blockWidth:10,blockHeight:5,isCompressed:!0,channels:4},'astc-10x6-unorm':{bytesPerBlock:16,blockWidth:10,blockHeight:6,isCompressed:!0,channels:4},'astc-10x6-unorm-srgb':{bytesPerBlock:16,blockWidth:10,blockHeight:6,isCompressed:!0,channels:4},'astc-10x8-unorm':{bytesPerBlock:16,blockWidth:10,blockHeight:8,isCompressed:!0,channels:4},'astc-10x8-unorm-srgb':{bytesPerBlock:16,blockWidth:10,blockHeight:8,isCompressed:!0,channels:4},'astc-10x10-unorm':{bytesPerBlock:16,blockWidth:10,blockHeight:10,isCompressed:!0,channels:4},'astc-10x10-unorm-srgb':{bytesPerBlock:16,blockWidth:10,blockHeight:10,isCompressed:!0,channels:4},'astc-12x10-unorm':{bytesPerBlock:16,blockWidth:12,blockHeight:10,isCompressed:!0,channels:4},'astc-12x10-unorm-srgb':{bytesPerBlock:16,blockWidth:12,blockHeight:10,isCompressed:!0,channels:4},'astc-12x12-unorm':{bytesPerBlock:16,blockWidth:12,blockHeight:12,isCompressed:!0,channels:4},'astc-12x12-unorm-srgb':{bytesPerBlock:16,blockWidth:12,blockHeight:12,isCompressed:!0,channels:4}};class T{constructor(){this.id=T._id++,this.line=0}get isAstNode(){return!0}get astNodeType(){return''}search(e){e(this)}searchBlock(e,t){if(e){t(S.instance);for(const n of e)n instanceof Array?this.searchBlock(n,t):n.search(t);t(A.instance)}}constEvaluate(e,t){throw new Error('Cannot evaluate node')}constEvaluateString(e){return this.constEvaluate(e).toString()}}T._id=0;class S extends T{}S.instance=new S;class A extends T{}A.instance=new A;const E=new Set(['all','all','any','select','arrayLength','abs','acos','acosh','asin','asinh','atan','atanh','atan2','ceil','clamp','cos','cosh','countLeadingZeros','countOneBits','countTrailingZeros','cross','degrees','determinant','distance','dot','dot4U8Packed','dot4I8Packed','exp','exp2','extractBits','faceForward','firstLeadingBit','firstTrailingBit','floor','fma','fract','frexp','insertBits','inverseSqrt','ldexp','length','log','log2','max','min','mix','modf','normalize','pow','quantizeToF16','radians','reflect','refract','reverseBits','round','saturate','sign','sin','sinh','smoothStep','sqrt','step','tan','tanh','transpose','trunc','dpdx','dpdxCoarse','dpdxFine','dpdy','dpdyCoarse','dpdyFine','fwidth','fwidthCoarse','fwidthFine','textureDimensions','textureGather','textureGatherCompare','textureLoad','textureNumLayers','textureNumLevels','textureNumSamples','textureSample','textureSampleBias','textureSampleCompare','textureSampleCompareLevel','textureSampleGrad','textureSampleLevel','textureSampleBaseClampToEdge','textureStore','atomicLoad','atomicStore','atomicAdd','atomicSub','atomicMax','atomicMin','atomicAnd','atomicOr','atomicXor','atomicExchange','atomicCompareExchangeWeak','pack4x8snorm','pack4x8unorm','pack4xI8','pack4xU8','pack4x8Clamp','pack4xU8Clamp','pack2x16snorm','pack2x16unorm','pack2x16float','unpack4x8snorm','unpack4x8unorm','unpack4xI8','unpack4xU8','unpack2x16snorm','unpack2x16unorm','unpack2x16float','storageBarrier','textureBarrier','workgroupBarrier','workgroupUniformLoad','subgroupAdd','subgroupExclusiveAdd','subgroupInclusiveAdd','subgroupAll','subgroupAnd','subgroupAny','subgroupBallot','subgroupBroadcast','subgroupBroadcastFirst','subgroupElect','subgroupMax','subgroupMin','subgroupMul','subgroupExclusiveMul','subgroupInclusiveMul','subgroupOr','subgroupShuffle','subgroupShuffleDown','subgroupShuffleUp','subgroupShuffleXor','subgroupXor','quadBroadcast','quadSwapDiagonal','quadSwapX','quadSwapY']);class $ extends T{constructor(){super()}}class L extends ${constructor(e,t,n,s,r,a){super(),this.calls=new Set,this.name=e,this.args=t,this.returnType=n,this.body=s,this.startLine=r,this.endLine=a}get astNodeType(){return'function'}search(e){if(this.attributes)for(const t of this.attributes)e(t);e(this);for(const t of this.args)e(t);this.searchBlock(this.body,e)}}class C extends ${constructor(e){super(),this.expression=e}get astNodeType(){return'staticAssert'}search(e){this.expression.search(e)}}class D extends ${constructor(e,t){super(),this.condition=e,this.body=t}get astNodeType(){return'while'}search(e){this.condition.search(e),this.searchBlock(this.body,e)}}class N extends ${constructor(e,t){super(),this.body=e,this.loopId=t}get astNodeType(){return'continuing'}search(e){this.searchBlock(this.body,e)}}class V extends ${constructor(e,t,n,s){super(),this.init=e,this.condition=t,this.increment=n,this.body=s}get astNodeType(){return'for'}search(e){var t,n,s;null===(t=this.init)||void 0===t||t.search(e),null===(n=this.condition)||void 0===n||n.search(e),null===(s=this.increment)||void 0===s||s.search(e),this.searchBlock(this.body,e)}}class O extends ${constructor(e,t,n,s,r){super(),this.attributes=null,this.name=e,this.type=t,this.storage=n,this.access=s,this.value=r}get astNodeType(){return'var'}search(e){var t;e(this),null===(t=this.value)||void 0===t||t.search(e)}}class B extends ${constructor(e,t,n){super(),this.attributes=null,this.name=e,this.type=t,this.value=n}get astNodeType(){return'override'}search(e){var t;null===(t=this.value)||void 0===t||t.search(e)}}class F extends ${constructor(e,t,n,s,r){super(),this.attributes=null,this.name=e,this.type=t,this.storage=n,this.access=s,this.value=r}get astNodeType(){return'let'}search(e){var t;e(this),null===(t=this.value)||void 0===t||t.search(e)}}class M extends ${constructor(e,t,n,s,r){super(),this.attributes=null,this.name=e,this.type=t,this.storage=n,this.access=s,this.value=r}get astNodeType(){return'const'}constEvaluate(e,t){return this.value.constEvaluate(e,t)}search(e){var t;e(this),null===(t=this.value)||void 0===t||t.search(e)}}var U,P,W,q;(e=>{e.increment='++',e.decrement='--'})(U||(U={})),(e=>{e.parse=function(t){const n=t;if('parse'==n)throw new Error('Invalid value for IncrementOperator');return e[n]}})(U||(U={}));class H extends ${constructor(e,t){super(),this.operator=e,this.variable=t}get astNodeType(){return'increment'}search(e){this.variable.search(e)}}(e=>{e.assign='=',e.addAssign='+=',e.subtractAssin='-=',e.multiplyAssign='*=',e.divideAssign='/=',e.moduloAssign='%=',e.andAssign='&=',e.orAssign='|=',e.xorAssign='^=',e.shiftLeftAssign='<<=',e.shiftRightAssign='>>='})(P||(P={})),(e=>{e.parse=function(e){const t=e;if('parse'==t)throw new Error('Invalid value for AssignOperator');return t}})(P||(P={}));class z extends ${constructor(e,t,n){super(),this.operator=e,this.variable=t,this.value=n}get astNodeType(){return'assign'}search(e){this.variable.search(e),this.value.search(e)}}class R extends ${constructor(e,t){super(),this.name=e,this.args=t}get astNodeType(){return'call'}isBuiltin(){return E.has(this.name)}search(e){for(const t of this.args)t.search(e);e(this)}}class G extends ${constructor(e,t){super(),this.body=e,this.continuing=t}get astNodeType(){return'loop'}}class X extends ${constructor(e,t){super(),this.condition=e,this.cases=t}get astNodeType(){return'switch'}}class j extends ${constructor(e,t,n,s){super(),this.condition=e,this.body=t,this.elseif=n,this.else=s}get astNodeType(){return'if'}search(e){this.condition.search(e),this.searchBlock(this.body,e),this.searchBlock(this.elseif,e),this.searchBlock(this.else,e)}}class Z extends ${constructor(e){super(),this.value=e}get astNodeType(){return'return'}search(e){var t;null===(t=this.value)||void 0===t||t.search(e)}}class Q extends ${constructor(e){super(),this.name=e}get astNodeType(){return'enable'}}class Y extends ${constructor(e){super(),this.extensions=e}get astNodeType(){return'requires'}}class K extends ${constructor(e,t){super(),this.severity=e,this.rule=t}get astNodeType(){return'diagnostic'}}class J extends ${constructor(e,t){super(),this.name=e,this.type=t}get astNodeType(){return'alias'}}class ee extends ${constructor(){super()}get astNodeType(){return'discard'}}class te extends ${constructor(){super(),this.condition=null,this.loopId=-1}get astNodeType(){return'break'}}class ne extends ${constructor(){super(),this.loopId=-1}get astNodeType(){return'continue'}}class se extends ${constructor(e){super(),this.attributes=null,this.name=e}get astNodeType(){return'type'}get isStruct(){return!1}get isArray(){return!1}static maxFormatType(e){let t=e[0];if('f32'===t.name)return t;for(let n=1;n<e.length;++n){const s=se._priority.get(t.name);se._priority.get(e[n].name)<s&&(t=e[n])}return'x32'===t.name?se.i32:t}getTypeName(){return this.name}}se.x32=new se('x32'),se.f32=new se('f32'),se.i32=new se('i32'),se.u32=new se('u32'),se.f16=new se('f16'),se.bool=new se('bool'),se.void=new se('void'),se._priority=new Map([['f32',0],['f16',1],['u32',2],['i32',3],['x32',3]]);class re extends se{constructor(e){super(e)}}class ae extends se{constructor(e,t,n,s){super(e),this.members=t,this.startLine=n,this.endLine=s}get astNodeType(){return'struct'}get isStruct(){return!0}getMemberIndex(e){for(let t=0;t<this.members.length;t++)if(this.members[t].name==e)return t;return-1}search(e){for(const t of this.members)e(t)}}class ie extends se{constructor(e,t,n){super(e),this.format=t,this.access=n}get astNodeType(){return'template'}getTypeName(){let e=this.name;if(null!==this.format){if('vec2'===e||'vec3'===e||'vec4'===e||'mat2x2'===e||'mat2x3'===e||'mat2x4'===e||'mat3x2'===e||'mat3x3'===e||'mat3x4'===e||'mat4x2'===e||'mat4x3'===e||'mat4x4'===e){if('f32'===this.format.name)return e+='f',e;if('i32'===this.format.name)return e+='i',e;if('u32'===this.format.name)return e+='u',e;if('bool'===this.format.name)return e+='b',e;if('f16'===this.format.name)return e+='h',e}e+=`<${this.format.name}>`}else if('vec2'===e||'vec3'===e||'vec4'===e)return e;return e}}ie.vec2f=new ie('vec2',se.f32,null),ie.vec3f=new ie('vec3',se.f32,null),ie.vec4f=new ie('vec4',se.f32,null),ie.vec2i=new ie('vec2',se.i32,null),ie.vec3i=new ie('vec3',se.i32,null),ie.vec4i=new ie('vec4',se.i32,null),ie.vec2u=new ie('vec2',se.u32,null),ie.vec3u=new ie('vec3',se.u32,null),ie.vec4u=new ie('vec4',se.u32,null),ie.vec2h=new ie('vec2',se.f16,null),ie.vec3h=new ie('vec3',se.f16,null),ie.vec4h=new ie('vec4',se.f16,null),ie.vec2b=new ie('vec2',se.bool,null),ie.vec3b=new ie('vec3',se.bool,null),ie.vec4b=new ie('vec4',se.bool,null),ie.mat2x2f=new ie('mat2x2',se.f32,null),ie.mat2x3f=new ie('mat2x3',se.f32,null),ie.mat2x4f=new ie('mat2x4',se.f32,null),ie.mat3x2f=new ie('mat3x2',se.f32,null),ie.mat3x3f=new ie('mat3x3',se.f32,null),ie.mat3x4f=new ie('mat3x4',se.f32,null),ie.mat4x2f=new ie('mat4x2',se.f32,null),ie.mat4x3f=new ie('mat4x3',se.f32,null),ie.mat4x4f=new ie('mat4x4',se.f32,null),ie.mat2x2h=new ie('mat2x2',se.f16,null),ie.mat2x3h=new ie('mat2x3',se.f16,null),ie.mat2x4h=new ie('mat2x4',se.f16,null),ie.mat3x2h=new ie('mat3x2',se.f16,null),ie.mat3x3h=new ie('mat3x3',se.f16,null),ie.mat3x4h=new ie('mat3x4',se.f16,null),ie.mat4x2h=new ie('mat4x2',se.f16,null),ie.mat4x3h=new ie('mat4x3',se.f16,null),ie.mat4x4h=new ie('mat4x4',se.f16,null),ie.mat2x2i=new ie('mat2x2',se.i32,null),ie.mat2x3i=new ie('mat2x3',se.i32,null),ie.mat2x4i=new ie('mat2x4',se.i32,null),ie.mat3x2i=new ie('mat3x2',se.i32,null),ie.mat3x3i=new ie('mat3x3',se.i32,null),ie.mat3x4i=new ie('mat3x4',se.i32,null),ie.mat4x2i=new ie('mat4x2',se.i32,null),ie.mat4x3i=new ie('mat4x3',se.i32,null),ie.mat4x4i=new ie('mat4x4',se.i32,null),ie.mat2x2u=new ie('mat2x2',se.u32,null),ie.mat2x3u=new ie('mat2x3',se.u32,null),ie.mat2x4u=new ie('mat2x4',se.u32,null),ie.mat3x2u=new ie('mat3x2',se.u32,null),ie.mat3x3u=new ie('mat3x3',se.u32,null),ie.mat3x4u=new ie('mat3x4',se.u32,null),ie.mat4x2u=new ie('mat4x2',se.u32,null),ie.mat4x3u=new ie('mat4x3',se.u32,null),ie.mat4x4u=new ie('mat4x4',se.u32,null);class oe extends se{constructor(e,t,n,s){super(e),this.storage=t,this.type=n,this.access=s}get astNodeType(){return'pointer'}}class le extends se{constructor(e,t,n,s){super(e),this.attributes=t,this.format=n,this.count=s}get astNodeType(){return'array'}get isArray(){return!0}}class ce extends se{constructor(e,t,n){super(e),this.format=t,this.access=n}get astNodeType(){return'sampler'}}class ue extends T{constructor(){super(),this.postfix=null}}class he extends ue{constructor(e){super(),this.value=e}get astNodeType(){return'stringExpr'}toString(){return this.value}constEvaluateString(){return this.value}}class fe extends ue{constructor(e,t){super(),this.type=e,this.args=t}get astNodeType(){return'createExpr'}search(e){if(e(this),this.args)for(const t of this.args)t.search(e)}constEvaluate(e,t){return t&&(t[0]=this.type),e.evalExpression(this,e.context)}}class pe extends ue{constructor(e,t){super(),this.cachedReturnValue=null,this.name=e,this.args=t}get astNodeType(){return'callExpr'}setCachedReturnValue(e){this.cachedReturnValue=e}get isBuiltin(){return E.has(this.name)}constEvaluate(e,t){return e.evalExpression(this,e.context)}search(e){for(const t of this.args)t.search(e);e(this)}}class de extends ue{constructor(e){super(),this.name=e}get astNodeType(){return'varExpr'}search(e){e(this),this.postfix&&this.postfix.search(e)}constEvaluate(e,t){return e.evalExpression(this,e.context)}}class me extends ue{constructor(e,t){super(),this.name=e,this.initializer=t}get astNodeType(){return'constExpr'}constEvaluate(e,t){if(this.initializer){const t=e.evalExpression(this.initializer,e.context);return null!==t&&this.postfix?t.getSubData(e,this.postfix,e.context):t}return null}search(e){this.initializer.search(e)}}class _e extends ue{constructor(e,t){super(),this.value=e,this.type=t}get astNodeType(){return'literalExpr'}constEvaluate(e,t){return void 0!==t&&(t[0]=this.type),this.value}get isScalar(){return this.value instanceof Ve}get isVector(){return this.value instanceof Be||this.value instanceof Fe}get scalarValue(){return this.value instanceof Ve?this.value.value:(console.error('Value is not scalar.'),0)}get vectorValue(){return this.value instanceof Be||this.value instanceof Fe?this.value.data:(console.error('Value is not a vector or matrix.'),new Float32Array(0))}}class ge extends ue{constructor(e,t){super(),this.type=e,this.value=t}get astNodeType(){return'bitcastExpr'}search(e){this.value.search(e)}}class xe extends ue{constructor(e,t){super(),this.type=e,this.args=t}get astNodeType(){return'typecastExpr'}constEvaluate(e,t){return e.evalExpression(this,e.context)}search(e){this.searchBlock(this.args,e)}}class ye extends ue{constructor(e){super(),this.index=e}search(e){this.index.search(e)}}class be extends ue{constructor(){super()}}class ve extends be{constructor(e,t){super(),this.operator=e,this.right=t}get astNodeType(){return'unaryOp'}constEvaluate(e,t){return e.evalExpression(this,e.context)}search(e){this.right.search(e)}}class we extends be{constructor(e,t,n){super(),this.operator=e,this.left=t,this.right=n}get astNodeType(){return'binaryOp'}_getPromotedType(e,t){return e.name===t.name?e:'f32'===e.name||'f32'===t.name?se.f32:'u32'===e.name||'u32'===t.name?se.u32:se.i32}constEvaluate(e,t){return e.evalExpression(this,e.context)}search(e){this.left.search(e),this.right.search(e)}}class ke extends T{constructor(e){super(),this.body=e}}class Ie extends ue{constructor(){super()}get astNodeType(){return'default'}}class Te extends ke{constructor(e,t){super(t),this.selectors=e}get astNodeType(){return'case'}search(e){this.searchBlock(this.body,e)}}class Se extends ke{constructor(e){super(e)}get astNodeType(){return'default'}search(e){this.searchBlock(this.body,e)}}class Ae extends T{constructor(e,t,n){super(),this.name=e,this.type=t,this.attributes=n}get astNodeType(){return'argument'}}class Ee extends T{constructor(e,t){super(),this.condition=e,this.body=t}get astNodeType(){return'elseif'}search(e){this.condition.search(e),this.searchBlock(this.body,e)}}class $e extends T{constructor(e,t,n){super(),this.name=e,this.type=t,this.attributes=n}get astNodeType(){return'member'}}class Le extends T{constructor(e,t){super(),this.name=e,this.value=t}get astNodeType(){return'attribute'}}class Ce{constructor(e,t){this.parent=null,this.typeInfo=e,this.parent=t,this.id=Ce._id++}clone(){throw`Clone: Not implemented for ${this.constructor.name}`}setDataValue(e,t,n,s){console.error(`SetDataValue: Not implemented for ${this.constructor.name}`)}getSubData(e,t,n){return console.error(`GetDataValue: Not implemented for ${this.constructor.name}`),null}toString(){return`<${this.typeInfo.name}>`}}Ce._id=0;class De extends Ce{constructor(){super(new e('void',null),null)}toString(){return'void'}}De.void=new De;class Ne extends Ce{constructor(t){super(new e('pointer',null),null),this.reference=t}clone(){return this}setDataValue(e,t,n,s){this.reference.setDataValue(e,t,n,s)}getSubData(e,t,n){return t?this.reference.getSubData(e,t,n):this}}class Ve extends Ce{constructor(e,t,n=null){super(t,n),e instanceof Int32Array||e instanceof Uint32Array||e instanceof Float32Array?this.data=e:'x32'===this.typeInfo.name?e-Math.floor(e)!=0?this.data=new Float32Array([e]):this.data=e>=0?new Uint32Array([e]):new Int32Array([e]):'i32'===this.typeInfo.name||'bool'===this.typeInfo.name?this.data=new Int32Array([e]):'u32'===this.typeInfo.name?this.data=new Uint32Array([e]):'f32'===this.typeInfo.name||'f16'===this.typeInfo.name?this.data=new Float32Array([e]):console.error('ScalarData2: Invalid type',t)}clone(){if(this.data instanceof Float32Array)return new Ve(new Float32Array(this.data),this.typeInfo,null);if(this.data instanceof Int32Array)return new Ve(new Int32Array(this.data),this.typeInfo,null);if(this.data instanceof Uint32Array)return new Ve(new Uint32Array(this.data),this.typeInfo,null);throw'ScalarData: Invalid data type'}get value(){return this.data[0]}set value(e){this.data[0]=e}setDataValue(e,t,n,s){if(n)return void console.error('SetDataValue: Scalar data does not support postfix',n);if(!(t instanceof Ve))return void console.error('SetDataValue: Invalid value',t);let r=t.data[0];'i32'===this.typeInfo.name||'u32'===this.typeInfo.name?r=Math.floor(r):'bool'===this.typeInfo.name&&(r=r?1:0),this.data[0]=r}getSubData(e,t,n){return t?(console.error('getSubData: Scalar data does not support postfix',t),null):this}toString(){return`${this.value}`}}function Oe(e,t,n){const s=t.length;return 2===s?'f32'===n?new Be(new Float32Array(t),e.getTypeInfo('vec2f')):'i32'===n||'bool'===n?new Be(new Int32Array(t),e.getTypeInfo('vec2i')):'u32'===n?new Be(new Uint32Array(t),e.getTypeInfo('vec2u')):'f16'===n?new Be(new Float32Array(t),e.getTypeInfo('vec2h')):(console.error(`getSubData: Unknown format ${n}`),null):3===s?'f32'===n?new Be(new Float32Array(t),e.getTypeInfo('vec3f')):'i32'===n||'bool'===n?new Be(new Int32Array(t),e.getTypeInfo('vec3i')):'u32'===n?new Be(new Uint32Array(t),e.getTypeInfo('vec3u')):'f16'===n?new Be(new Float32Array(t),e.getTypeInfo('vec3h')):(console.error(`getSubData: Unknown format ${n}`),null):4===s?'f32'===n?new Be(new Float32Array(t),e.getTypeInfo('vec4f')):'i32'===n||'bool'===n?new Be(new Int32Array(t),e.getTypeInfo('vec4i')):'u32'===n?new Be(new Uint32Array(t),e.getTypeInfo('vec4u')):'f16'===n?new Be(new Float32Array(t),e.getTypeInfo('vec4h')):(console.error(`getSubData: Unknown format ${n}`),null):(console.error(`getSubData: Invalid vector size ${t.length}`),null)}class Be extends Ce{constructor(e,t,n=null){if(super(t,n),e instanceof Float32Array||e instanceof Uint32Array||e instanceof Int32Array)this.data=e;else{const t=this.typeInfo.name;'vec2f'===t||'vec3f'===t||'vec4f'===t?this.data=new Float32Array(e):'vec2i'===t||'vec3i'===t||'vec4i'===t?this.data=new Int32Array(e):'vec2u'===t||'vec3u'===t||'vec4u'===t?this.data=new Uint32Array(e):'vec2h'===t||'vec3h'===t||'vec4h'===t?this.data=new Float32Array(e):'vec2b'===t||'vec3b'===t||'vec4b'===t?this.data=new Int32Array(e):'vec2'===t||'vec3'===t||'vec4'===t?this.data=new Float32Array(e):console.error(`VectorData: Invalid type ${t}`)}}clone(){if(this.data instanceof Float32Array)return new Be(new Float32Array(this.data),this.typeInfo,null);if(this.data instanceof Int32Array)return new Be(new Int32Array(this.data),this.typeInfo,null);if(this.data instanceof Uint32Array)return new Be(new Uint32Array(this.data),this.typeInfo,null);throw'VectorData: Invalid data type'}setDataValue(e,t,n,s){n instanceof he?console.error('TODO: Set vector postfix'):t instanceof Be?this.data=t.data:console.error('SetDataValue: Invalid value',t)}getSubData(e,t,n){if(null===t)return this;let s=e.getTypeInfo('f32');if(this.typeInfo instanceof r)s=this.typeInfo.format||s;else{const t=this.typeInfo.name;'vec2f'===t||'vec3f'===t||'vec4f'===t?s=e.getTypeInfo('f32'):'vec2i'===t||'vec3i'===t||'vec4i'===t?s=e.getTypeInfo('i32'):'vec2b'===t||'vec3b'===t||'vec4b'===t?s=e.getTypeInfo('bool'):'vec2u'===t||'vec3u'===t||'vec4u'===t?s=e.getTypeInfo('u32'):'vec2h'===t||'vec3h'===t||'vec4h'===t?s=e.getTypeInfo('f16'):console.error(`GetSubData: Unknown type ${t}`)}let a=this;for(;null!==t&&null!==a;){if(t instanceof ye){const r=t.index;let i=-1;if(r instanceof _e){if(!(r.value instanceof Ve))return console.error(`GetSubData: Invalid array index ${r.value}`),null;i=r.value.value}else{const t=e.evalExpression(r,n);if(!(t instanceof Ve))return console.error('GetSubData: Unknown index type',r),null;i=t.value}if(i<0||i>=a.data.length)return console.error('GetSubData: Index out of range',i),null;if(a.data instanceof Float32Array){const e=new Float32Array(a.data.buffer,a.data.byteOffset+4*i,1);return new Ve(e,s)}if(a.data instanceof Int32Array){const e=new Int32Array(a.data.buffer,a.data.byteOffset+4*i,1);return new Ve(e,s)}if(a.data instanceof Uint32Array){const e=new Uint32Array(a.data.buffer,a.data.byteOffset+4*i,1);return new Ve(e,s)}throw'GetSubData: Invalid data type'}if(!(t instanceof he))return console.error('GetSubData: Unknown postfix',t),null;{const n=t.value.toLowerCase();if(1===n.length){let e=0;if('x'===n||'r'===n)e=0;else if('y'===n||'g'===n)e=1;else if('z'===n||'b'===n)e=2;else{if('w'!==n&&'a'!==n)return console.error(`GetSubData: Unknown member ${n}`),null;e=3}if(this.data instanceof Float32Array){let t=new Float32Array(this.data.buffer,this.data.byteOffset+4*e,1);return new Ve(t,s,this)}if(this.data instanceof Int32Array){let t=new Int32Array(this.data.buffer,this.data.byteOffset+4*e,1);return new Ve(t,s,this)}if(this.data instanceof Uint32Array){let t=new Uint32Array(this.data.buffer,this.data.byteOffset+4*e,1);return new Ve(t,s,this)}}const r=[];for(const e of n)'x'===e||'r'===e?r.push(this.data[0]):'y'===e||'g'===e?r.push(this.data[1]):'z'===e||'b'===e?r.push(this.data[2]):'w'===e||'a'===e?r.push(this.data[3]):console.error(`GetDataValue: Unknown member ${e}`);a=Oe(e,r,s.name)}t=t.postfix}return a}toString(){let e=`${this.data[0]}`;for(let t=1;t<this.data.length;++t)e+=`, ${this.data[t]}`;return e}}class Fe extends Ce{constructor(e,t,n=null){super(t,n),e instanceof Float32Array?this.data=e:this.data=new Float32Array(e)}clone(){return new Fe(new Float32Array(this.data),this.typeInfo,null)}setDataValue(e,t,n,s){n instanceof he?console.error('TODO: Set matrix postfix'):t instanceof Fe?this.data=t.data:console.error('SetDataValue: Invalid value',t)}getSubData(e,t,n){if(null===t)return this;const s=this.typeInfo.name;if(e.getTypeInfo('f32'),this.typeInfo instanceof r)this.typeInfo.format;else if(s.endsWith('f'))e.getTypeInfo('f32');else if(s.endsWith('i'))e.getTypeInfo('i32');else if(s.endsWith('u'))e.getTypeInfo('u32');else{if(!s.endsWith('h'))return console.error(`GetDataValue: Unknown type ${s}`),null;e.getTypeInfo('f16')}if(t instanceof ye){const r=t.index;let a=-1;if(r instanceof _e){if(!(r.value instanceof Ve))return console.error(`GetDataValue: Invalid array index ${r.value}`),null;a=r.value.value}else{const t=e.evalExpression(r,n);if(!(t instanceof Ve))return console.error('GetDataValue: Unknown index type',r),null;a=t.value}if(a<0||a>=this.data.length)return console.error('GetDataValue: Index out of range',a),null;const i=s.endsWith('h')?'h':'f';let o;if('mat2x2'===s||'mat2x2f'===s||'mat2x2h'===s||'mat3x2'===s||'mat3x2f'===s||'mat3x2h'===s||'mat4x2'===s||'mat4x2f'===s||'mat4x2h'===s)o=new Be(new Float32Array(this.data.buffer,this.data.byteOffset+2*a*4,2),e.getTypeInfo(`vec2${i}`));else if('mat2x3'===s||'mat2x3f'===s||'mat2x3h'===s||'mat3x3'===s||'mat3x3f'===s||'mat3x3h'===s||'mat4x3'===s||'mat4x3f'===s||'mat4x3h'===s)o=new Be(new Float32Array(this.data.buffer,this.data.byteOffset+3*a*4,3),e.getTypeInfo(`vec3${i}`));else{if('mat2x4'!==s&&'mat2x4f'!==s&&'mat2x4h'!==s&&'mat3x4'!==s&&'mat3x4f'!==s&&'mat3x4h'!==s&&'mat4x4'!==s&&'mat4x4f'!==s&&'mat4x4h'!==s)return console.error(`GetDataValue: Unknown type ${s}`),null;o=new Be(new Float32Array(this.data.buffer,this.data.byteOffset+4*a*4,4),e.getTypeInfo(`vec4${i}`))}return t.postfix?o.getSubData(e,t.postfix,n):o}return console.error('GetDataValue: Invalid postfix',t),null}toString(){let e=`${this.data[0]}`;for(let t=1;t<this.data.length;++t)e+=`, ${this.data[t]}`;return e}}class Me extends Ce{constructor(e,t,n=0,s=null){super(t,s),this.buffer=e instanceof ArrayBuffer?e:e.buffer,this.offset=n}clone(){const e=new Uint8Array(new Uint8Array(this.buffer,this.offset,this.typeInfo.size));return new Me(e.buffer,this.typeInfo,0,null)}setDataValue(t,r,a,i){if(null===r)return void console.log('setDataValue: NULL data.');let o=this.offset,l=this.typeInfo;for(;a;){if(a instanceof ye)if(l instanceof s){const e=a.index;if(e instanceof _e){if(!(e.value instanceof Ve))return void console.error(`SetDataValue: Invalid index type ${e.value}`);o+=e.value.value*l.stride}else{const n=t.evalExpression(e,i);if(!(n instanceof Ve))return void console.error('SetDataValue: Unknown index type',e);o+=n.value*l.stride}l=l.format}else console.error(`SetDataValue: Type ${l.getTypeName()} is not an array`);else{if(!(a instanceof he))return void console.error('SetDataValue: Unknown postfix type',a);{const t=a.value;if(l instanceof n){let e=!1;for(const n of l.members)if(n.name===t){o+=n.offset,l=n.type,e=!0;break}if(!e)return void console.error(`SetDataValue: Member ${t} not found`)}else if(l instanceof e){const e=l.getTypeName();let n=0;if('x'===t||'r'===t)n=0;else if('y'===t||'g'===t)n=1;else if('z'===t||'b'===t)n=2;else{if('w'!==t&&'a'!==t)return void console.error(`SetDataValue: Unknown member ${t}`);n=3}if(!(r instanceof Ve))return void console.error('SetDataValue: Invalid value',r);const s=r.value;return'vec2f'===e?void(new Float32Array(this.buffer,o,2)[n]=s):'vec3f'===e?void(new Float32Array(this.buffer,o,3)[n]=s):'vec4f'===e?void(new Float32Array(this.buffer,o,4)[n]=s):'vec2i'===e?void(new Int32Array(this.buffer,o,2)[n]=s):'vec3i'===e?void(new Int32Array(this.buffer,o,3)[n]=s):'vec4i'===e?void(new Int32Array(this.buffer,o,4)[n]=s):'vec2u'===e?void(new Uint32Array(this.buffer,o,2)[n]=s):'vec3u'===e?void(new Uint32Array(this.buffer,o,3)[n]=s):'vec4u'===e?void(new Uint32Array(this.buffer,o,4)[n]=s):void console.error(`SetDataValue: Type ${e} is not a struct`)}}}a=a.postfix}this.setData(t,r,l,o,i)}setData(e,t,n,s,r){const a=n.getTypeName();if('f32'!==a&&'f16'!==a)if('i32'!==a&&'atomic<i32>'!==a&&'x32'!==a)if('u32'!==a&&'atomic<u32>'!==a)if('bool'!==a)if('vec2f'!==a&&'vec2h'!==a)if('vec3f'!==a&&'vec3h'!==a)if('vec4f'!==a&&'vec4h'!==a)if('vec2i'!==a)if('vec3i'!==a)if('vec4i'!==a)if('vec2u'!==a)if('vec3u'!==a)if('vec4u'!==a)if('vec2b'!==a)if('vec3b'!==a)if('vec4b'!==a)if('mat2x2f'!==a&&'mat2x2h'!==a)if('mat2x3f'!==a&&'mat2x3h'!==a)if('mat2x4f'!==a&&'mat2x4h'!==a)if('mat3x2f'!==a&&'mat3x2h'!==a)if('mat3x3f'!==a&&'mat3x3h'!==a)if('mat3x4f'!==a&&'mat3x4h'!==a)if('mat4x2f'!==a&&'mat4x2h'!==a)if('mat4x3f'!==a&&'mat4x3h'!==a)if('mat4x4f'!==a&&'mat4x4h'!==a)if(t instanceof Me){if(n===t.typeInfo){return void new Uint8Array(this.buffer,s,t.buffer.byteLength).set(new Uint8Array(t.buffer))}console.error('SetDataValue: Type mismatch',a,t.typeInfo.getTypeName())}else console.error(`SetData: Unknown type ${a}`);else{const e=new Float32Array(this.buffer,s,16);t instanceof Fe?(e[0]=t.data[0],e[1]=t.data[1],e[2]=t.data[2],e[3]=t.data[3],e[4]=t.data[4],e[5]=t.data[5],e[6]=t.data[6],e[7]=t.data[7],e[8]=t.data[8],e[9]=t.data[9],e[10]=t.data[10],e[11]=t.data[11],e[12]=t.data[12],e[13]=t.data[13],e[14]=t.data[14],e[15]=t.data[15]):(e[0]=t[0],e[1]=t[1],e[2]=t[2],e[3]=t[3],e[4]=t[4],e[5]=t[5],e[6]=t[6],e[7]=t[7],e[8]=t[8],e[9]=t[9],e[10]=t[10],e[11]=t[11],e[12]=t[12],e[13]=t[13],e[14]=t[14],e[15]=t[15])}else{const e=new Float32Array(this.buffer,s,12);t instanceof Fe?(e[0]=t.data[0],e[1]=t.data[1],e[2]=t.data[2],e[3]=t.data[3],e[4]=t.data[4],e[5]=t.data[5],e[6]=t.data[6],e[7]=t.data[7],e[8]=t.data[8],e[9]=t.data[9],e[10]=t.data[10],e[11]=t.data[11]):(e[0]=t[0],e[1]=t[1],e[2]=t[2],e[3]=t[3],e[4]=t[4],e[5]=t[5],e[6]=t[6],e[7]=t[7],e[8]=t[8],e[9]=t[9],e[10]=t[10],e[11]=t[11])}else{const e=new Float32Array(this.buffer,s,8);t instanceof Fe?(e[0]=t.data[0],e[1]=t.data[1],e[2]=t.data[2],e[3]=t.data[3],e[4]=t.data[4],e[5]=t.data[5],e[6]=t.data[6],e[7]=t.data[7]):(e[0]=t[0],e[1]=t[1],e[2]=t[2],e[3]=t[3],e[4]=t[4],e[5]=t[5],e[6]=t[6],e[7]=t[7])}else{const e=new Float32Array(this.buffer,s,12);t instanceof Fe?(e[0]=t.data[0],e[1]=t.data[1],e[2]=t.data[2],e[3]=t.data[3],e[4]=t.data[4],e[5]=t.data[5],e[6]=t.data[6],e[7]=t.data[7],e[8]=t.data[8],e[9]=t.data[9],e[10]=t.data[10],e[11]=t.data[11]):(e[0]=t[0],e[1]=t[1],e[2]=t[2],e[3]=t[3],e[4]=t[4],e[5]=t[5],e[6]=t[6],e[7]=t[7],e[8]=t[8],e[9]=t[9],e[10]=t[10],e[11]=t[11])}else{const e=new Float32Array(this.buffer,s,9);t instanceof Fe?(e[0]=t.data[0],e[1]=t.data[1],e[2]=t.data[2],e[3]=t.data[3],e[4]=t.data[4],e[5]=t.data[5],e[6]=t.data[6],e[7]=t.data[7],e[8]=t.data[8]):(e[0]=t[0],e[1]=t[1],e[2]=t[2],e[3]=t[3],e[4]=t[4],e[5]=t[5],e[6]=t[6],e[7]=t[7],e[8]=t[8])}else{const e=new Float32Array(this.buffer,s,6);t instanceof Fe?(e[0]=t.data[0],e[1]=t.data[1],e[2]=t.data[2],e[3]=t.data[3],e[4]=t.data[4],e[5]=t.data[5]):(e[0]=t[0],e[1]=t[1],e[2]=t[2],e[3]=t[3],e[4]=t[4],e[5]=t[5])}else{const e=new Float32Array(this.buffer,s,8);t instanceof Fe?(e[0]=t.data[0],e[1]=t.data[1],e[2]=t.data[2],e[3]=t.data[3],e[4]=t.data[4],e[5]=t.data[5],e[6]=t.data[6],e[7]=t.data[7]):(e[0]=t[0],e[1]=t[1],e[2]=t[2],e[3]=t[3],e[4]=t[4],e[5]=t[5],e[6]=t[6],e[7]=t[7])}else{const e=new Float32Array(this.buffer,s,6);t instanceof Fe?(e[0]=t.data[0],e[1]=t.data[1],e[2]=t.data[2],e[3]=t.data[3],e[4]=t.data[4],e[5]=t.data[5]):(e[0]=t[0],e[1]=t[1],e[2]=t[2],e[3]=t[3],e[4]=t[4],e[5]=t[5])}else{const e=new Float32Array(this.buffer,s,4);t instanceof Fe?(e[0]=t.data[0],e[1]=t.data[1],e[2]=t.data[2],e[3]=t.data[3]):(e[0]=t[0],e[1]=t[1],e[2]=t[2],e[3]=t[3])}else{const e=new Uint32Array(this.buffer,s,4);t instanceof Be?(e[0]=t.data[0],e[1]=t.data[1],e[2]=t.data[2],e[3]=t.data[3]):(e[0]=t[0],e[1]=t[1],e[2]=t[2],e[3]=t[3])}else{const e=new Uint32Array(this.buffer,s,3);t instanceof Be?(e[0]=t.data[0],e[1]=t.data[1],e[2]=t.data[2]):(e[0]=t[0],e[1]=t[1],e[2]=t[2])}else{const e=new Uint32Array(this.buffer,s,2);t instanceof Be?(e[0]=t.data[0],e[1]=t.data[1]):(e[0]=t[0],e[1]=t[1])}else{const e=new Uint32Array(this.buffer,s,4);t instanceof Be?(e[0]=t.data[0],e[1]=t.data[1],e[2]=t.data[2],e[3]=t.data[3]):(e[0]=t[0],e[1]=t[1],e[2]=t[2],e[3]=t[3])}else{const e=new Uint32Array(this.buffer,s,3);t instanceof Be?(e[0]=t.data[0],e[1]=t.data[1],e[2]=t.data[2]):(e[0]=t[0],e[1]=t[1],e[2]=t[2])}else{const e=new Uint32Array(this.buffer,s,2);t instanceof Be?(e[0]=t.data[0],e[1]=t.data[1]):(e[0]=t[0],e[1]=t[1])}else{const e=new Int32Array(this.buffer,s,4);t instanceof Be?(e[0]=t.data[0],e[1]=t.data[1],e[2]=t.data[2],e[3]=t.data[3]):(e[0]=t[0],e[1]=t[1],e[2]=t[2],e[3]=t[3])}else{const e=new Int32Array(this.buffer,s,3);t instanceof Be?(e[0]=t.data[0],e[1]=t.data[1],e[2]=t.data[2]):(e[0]=t[0],e[1]=t[1],e[2]=t[2])}else{const e=new Int32Array(this.buffer,s,2);t instanceof Be?(e[0]=t.data[0],e[1]=t.data[1]):(e[0]=t[0],e[1]=t[1])}else{const e=new Float32Array(this.buffer,s,4);t instanceof Be?(e[0]=t.data[0],e[1]=t.data[1],e[2]=t.data[2],e[3]=t.data[3]):(e[0]=t[0],e[1]=t[1],e[2]=t[2],e[3]=t[3])}else{const e=new Float32Array(this.buffer,s,3);t instanceof Be?(e[0]=t.data[0],e[1]=t.data[1],e[2]=t.data[2]):(e[0]=t[0],e[1]=t[1],e[2]=t[2])}else{const e=new Float32Array(this.buffer,s,2);t instanceof Be?(e[0]=t.data[0],e[1]=t.data[1]):(e[0]=t[0],e[1]=t[1])}else t instanceof Ve&&(new Int32Array(this.buffer,s,1)[0]=t.value);else t instanceof Ve&&(new Uint32Array(this.buffer,s,1)[0]=t.value);else t instanceof Ve&&(new Int32Array(this.buffer,s,1)[0]=t.value);else t instanceof Ve&&(new Float32Array(this.buffer,s,1)[0]=t.value)}getSubData(t,a,i){var o,l,c;if(null===a)return this;let u=this.offset,h=this.typeInfo;for(;a;){if(a instanceof ye){const e=a.index,n=t.evalExpression(e,i);let r=0;if(n instanceof Ve?r=n.value:console.error('GetDataValue: Invalid index type',e),h instanceof s)u+=r*h.stride,h=h.format;else{const e=h.getTypeName();'mat4x4'===e||'mat4x4f'===e||'mat4x4h'===e?(u+=16*r,h=t.getTypeInfo('vec4f')):console.error(`getDataValue: Type ${h.getTypeName()} is not an array`)}}else{if(!(a instanceof he))return console.error('GetDataValue: Unknown postfix type',a),null;{const s=a.value;if(h instanceof n){let e=!1;for(const t of h.members)if(t.name===s){u+=t.offset,h=t.type,e=!0;break}if(!e)return console.error(`GetDataValue: Member ${s} not found`),null}else if(h instanceof e){const e=h.getTypeName();if('vec2f'===e||'vec3f'===e||'vec4f'===e||'vec2i'===e||'vec3i'===e||'vec4i'===e||'vec2u'===e||'vec3u'===e||'vec4u'===e||'vec2b'===e||'vec3b'===e||'vec4b'===e||'vec2h'===e||'vec3h'===e||'vec4h'===e||'vec2'===e||'vec3'===e||'vec4'===e){if(s.length>0&&s.length<5){let n='f';const r=[];for(let a=0;a<s.length;++a){const i=s[a].toLowerCase();let o=0;if('x'===i||'r'===i)o=0;else if('y'===i||'g'===i)o=1;else if('z'===i||'b'===i)o=2;else{if('w'!==i&&'a'!==i)return console.error(`Unknown member ${s}`),null;o=3}if(1===s.length){if(e.endsWith('f'))return this.buffer.byteLength<u+4*o+4?(console.log('Insufficient buffer data'),null):new Ve(new Float32Array(this.buffer,u+4*o,1),t.getTypeInfo('f32'),this);if(e.endsWith('h'))return new Ve(new Float32Array(this.buffer,u+4*o,1),t.getTypeInfo('f16'),this);if(e.endsWith('i'))return new Ve(new Int32Array(this.buffer,u+4*o,1),t.getTypeInfo('i32'),this);if(e.endsWith('b'))return new Ve(new Int32Array(this.buffer,u+4*o,1),t.getTypeInfo('bool'),this);if(e.endsWith('u'))return new Ve(new Uint32Array(this.buffer,u+4*o,1),t.getTypeInfo('i32'),this)}if('vec2f'===e)r.push(new Float32Array(this.buffer,u,2)[o]);else if('vec3f'===e){if(u+12>=this.buffer.byteLength)return console.log('Insufficient buffer data'),null;const e=new Float32Array(this.buffer,u,3);r.push(e[o])}else if('vec4f'===e)r.push(new Float32Array(this.buffer,u,4)[o]);else if('vec2i'===e)n='i',r.push(new Int32Array(this.buffer,u,2)[o]);else if('vec3i'===e)n='i',r.push(new Int32Array(this.buffer,u,3)[o]);else if('vec4i'===e)n='i',r.push(new Int32Array(this.buffer,u,4)[o]);else if('vec2u'===e){n='u';const e=new Uint32Array(this.buffer,u,2);r.push(e[o])}else'vec3u'===e?(n='u',r.push(new Uint32Array(this.buffer,u,3)[o])):'vec4u'===e&&(n='u',r.push(new Uint32Array(this.buffer,u,4)[o]))}return 2===r.length?h=t.getTypeInfo(`vec2${n}`):3===r.length?h=t.getTypeInfo(`vec3${n}`):4===r.length?h=t.getTypeInfo(`vec4${n}`):console.error(`GetDataValue: Invalid vector length ${r.length}`),new Be(r,h,null)}return console.error(`GetDataValue: Unknown member ${s}`),null}return console.error(`GetDataValue: Type ${e} is not a struct`),null}}}a=a.postfix}const f=h.getTypeName();return'f32'===f?new Ve(new Float32Array(this.buffer,u,1),h,this):'i32'===f?new Ve(new Int32Array(this.buffer,u,1),h,this):'u32'===f?new Ve(new Uint32Array(this.buffer,u,1),h,this):'vec2f'===f?new Be(new Float32Array(this.buffer,u,2),h,this):'vec3f'===f?new Be(new Float32Array(this.buffer,u,3),h,this):'vec4f'===f?new Be(new Float32Array(this.buffer,u,4),h,this):'vec2i'===f?new Be(new Int32Array(this.buffer,u,2),h,this):'vec3i'===f?new Be(new Int32Array(this.buffer,u,3),h,this):'vec4i'===f?new Be(new Int32Array(this.buffer,u,4),h,this):'vec2u'===f?new Be(new Uint32Array(this.buffer,u,2),h,this):'vec3u'===f?new Be(new Uint32Array(this.buffer,u,3),h,this):'vec4u'===f?new Be(new Uint32Array(this.buffer,u,4),h,this):h instanceof r&&'atomic'===h.name?'u32'===(null===(o=h.format)||void 0===o?void 0:o.name)?new Ve(new Uint32Array(this.buffer,u,1)[0],h.format,this):'i32'===(null===(l=h.format)||void 0===l?void 0:l.name)?new Ve(new Int32Array(this.buffer,u,1)[0],h.format,this):(console.error(`GetDataValue: Invalid atomic format ${null===(c=h.format)||void 0===c?void 0:c.name}`),null):new Me(this.buffer,h,u,this)}toString(){let e='';if(this.typeInfo instanceof s)if('f32'===this.typeInfo.format.name){const t=new Float32Array(this.buffer,this.offset);e=`[${t[0]}`;for(let n=1;n<t.length;++n)e+=`, ${t[n]}`}else if('i32'===this.typeInfo.format.name){const t=new Int32Array(this.buffer,this.offset);e=`[${t[0]}`;for(let n=1;n<t.length;++n)e+=`, ${t[n]}`}else if('u32'===this.typeInfo.format.name){const t=new Uint32Array(this.buffer,this.offset);e=`[${t[0]}`;for(let n=1;n<t.length;++n)e+=`, ${t[n]}`}else if('vec2f'===this.typeInfo.format.name){const t=new Float32Array(this.buffer,this.offset);e=`[${t[0]}, ${t[1]}]`;for(let n=1;n<t.length/2;++n)e+=`, [${t[2*n]}, ${t[2*n+1]}]`}else if('vec3f'===this.typeInfo.format.name){const t=new Float32Array(this.buffer,this.offset);e=`[${t[0]}, ${t[1]}, ${t[2]}]`;for(let n=4;n<t.length;n+=4)e+=`, [${t[n]}, ${t[n+1]}, ${t[n+2]}]`}else if('vec4f'===this.typeInfo.format.name){const t=new Float32Array(this.buffer,this.offset);e=`[${t[0]}, ${t[1]}, ${t[2]}, ${t[3]}]`;for(let n=4;n<t.length;n+=4)e+=`, [${t[n]}, ${t[n+1]}, ${t[n+2]}, ${t[n+3]}]`}else e='[...]';else this.typeInfo instanceof n?e+='{...}':e='[...]';return e}}class Ue extends Ce{constructor(e,t,n,s){super(t,null),this.data=e,this.descriptor=n,this.view=s}clone(){return new Ue(this.data,this.typeInfo,this.descriptor,this.view)}get width(){var e,t;const n=this.descriptor.size;return n instanceof Array&&n.length>0?null!==(e=n[0])&&void 0!==e?e:0:n instanceof Object&&null!==(t=n.width)&&void 0!==t?t:0}get height(){var e,t;const n=this.descriptor.size;return n instanceof Array&&n.length>1?null!==(e=n[1])&&void 0!==e?e:0:n instanceof Object&&null!==(t=n.height)&&void 0!==t?t:0}get depthOrArrayLayers(){var e,t;const n=this.descriptor.size;return n instanceof Array&&n.length>2?null!==(e=n[2])&&void 0!==e?e:0:n instanceof Object&&null!==(t=n.depthOrArrayLayers)&&void 0!==t?t:0}get format(){var e;return this.descriptor&&null!==(e=this.descriptor.format)&&void 0!==e?e:'rgba8unorm'}get sampleCount(){var e;return this.descriptor&&null!==(e=this.descriptor.sampleCount)&&void 0!==e?e:1}get mipLevelCount(){var e;return this.descriptor&&null!==(e=this.descriptor.mipLevelCount)&&void 0!==e?e:1}get dimension(){var e;return this.descriptor&&null!==(e=this.descriptor.dimension)&&void 0!==e?e:'2d'}getMipLevelSize(e){if(e>=this.mipLevelCount)return[0,0,0];const t=[this.width,this.height,this.depthOrArrayLayers];for(let n=0;n<t.length;++n)t[n]=Math.max(1,t[n]>>e);return t}get texelByteSize(){const e=this.format,t=I[e];return t?t.isDepthStencil?4:t.bytesPerBlock:0}get bytesPerRow(){return this.width*this.texelByteSize}get isDepthStencil(){const e=this.format,t=I[e];return!!t&&t.isDepthStencil}getGpuSize(){const e=this.format,t=I[e],n=this.width;if(!e||n<=0||!t)return-1;const s=this.height,r=this.depthOrArrayLayers,a=this.dimension;return n/t.blockWidth*('1d'===a?1:s/t.blockHeight)*t.bytesPerBlock*r}getPixel(e,t,n=0,s=0){const r=this.texelByteSize,a=this.bytesPerRow,i=this.height,o=this.data[s];return v(new Uint8Array(o),e,t,n,s,i,a,r,this.format)}setPixel(e,t,n,s,r){const a=this.texelByteSize,i=this.bytesPerRow,o=this.height,l=this.data[s];!function(e,t,n,s,r,a,i,o,l,c){const u=s*(i>>=r)*(a>>=r)+n*i+t*o;switch(l){case'r8unorm':return void k(e,u,'8unorm',1,c);case'r8snorm':return void k(e,u,'8snorm',1,c);case'r8uint':return void k(e,u,'8uint',1,c);case'r8sint':return void k(e,u,'8sint',1,c);case'rg8unorm':return void k(e,u,'8unorm',2,c);case'rg8snorm':return void k(e,u,'8snorm',2,c);case'rg8uint':return void k(e,u,'8uint',2,c);case'rg8sint':return void k(e,u,'8sint',2,c);case'rgba8unorm-srgb':case'rgba8unorm':case'bgra8unorm-srgb':case'bgra8unorm':return void k(e,u,'8unorm',4,c);case'rgba8snorm':return void k(e,u,'8snorm',4,c);case'rgba8uint':return void k(e,u,'8uint',4,c);case'rgba8sint':return void k(e,u,'8sint',4,c);case'r16uint':return void k(e,u,'16uint',1,c);case'r16sint':return void k(e,u,'16sint',1,c);case'r16float':return void k(e,u,'16float',1,c);case'rg16uint':return void k(e,u,'16uint',2,c);case'rg16sint':return void k(e,u,'16sint',2,c);case'rg16float':return void k(e,u,'16float',2,c);case'rgba16uint':return void k(e,u,'16uint',4,c);case'rgba16sint':return void k(e,u,'16sint',4,c);case'rgba16float':return void k(e,u,'16float',4,c);case'r32uint':return void k(e,u,'32uint',1,c);case'r32sint':return void k(e,u,'32sint',1,c);case'depth16unorm':case'depth24plus':case'depth24plus-stencil8':case'depth32float':case'depth32float-stencil8':case'r32float':return void k(e,u,'32float',1,c);case'rg32uint':return void k(e,u,'32uint',2,c);case'rg32sint':return void k(e,u,'32sint',2,c);case'rg32float':return void k(e,u,'32float',2,c);case'rgba32uint':return void k(e,u,'32uint',4,c);case'rgba32sint':return void k(e,u,'32sint',4,c);case'rgba32float':return void k(e,u,'32float',4,c);case'rg11b10ufloat':console.error('TODO: rg11b10ufloat not supported for writing')}}(new Uint8Array(l),e,t,n,s,o,i,a,this.format,r)}}(e=>{e[e.token=0]='token',e[e.keyword=1]='keyword',e[e.reserved=2]='reserved'})(q||(q={}));class Pe{constructor(e,t,n){this.name=e,this.type=t,this.rule=n}toString(){return this.name}}class We{}W=We,We.none=new Pe('',q.reserved,''),We.eof=new Pe('EOF',q.token,''),We.reserved={asm:new Pe('asm',q.reserved,'asm'),bf16:new Pe('bf16',q.reserved,'bf16'),do:new Pe('do',q.reserved,'do'),enum:new Pe('enum',q.reserved,'enum'),f16:new Pe('f16',q.reserved,'f16'),f64:new Pe('f64',q.reserved,'f64'),handle:new Pe('handle',q.reserved,'handle'),i8:new Pe('i8',q.reserved,'i8'),i16:new Pe('i16',q.reserved,'i16'),i64:new Pe('i64',q.reserved,'i64'),mat:new Pe('mat',q.reserved,'mat'),premerge:new Pe('premerge',q.reserved,'premerge'),regardless:new Pe('regardless',q.reserved,'regardless'),typedef:new Pe('typedef',q.reserved,'typedef'),u8:new Pe('u8',q.reserved,'u8'),u16:new Pe('u16',q.reserved,'u16'),u64:new Pe('u64',q.reserved,'u64'),unless:new Pe('unless',q.reserved,'unless'),using:new Pe('using',q.reserved,'using'),vec:new Pe('vec',q.reserved,'vec'),void:new Pe('void',q.reserved,'void')},We.keywords={array:new Pe('array',q.keyword,'array'),atomic:new Pe('atomic',q.keyword,'atomic'),bool:new Pe('bool',q.keyword,'bool'),f32:new Pe('f32',q.keyword,'f32'),i32:new Pe('i32',q.keyword,'i32'),mat2x2:new Pe('mat2x2',q.keyword,'mat2x2'),mat2x3:new Pe('mat2x3',q.keyword,'mat2x3'),mat2x4:new Pe('mat2x4',q.keyword,'mat2x4'),mat3x2:new Pe('mat3x2',q.keyword,'mat3x2'),mat3x3:new Pe('mat3x3',q.keyword,'mat3x3'),mat3x4:new Pe('mat3x4',q.keyword,'mat3x4'),mat4x2:new Pe('mat4x2',q.keyword,'mat4x2'),mat4x3:new Pe('mat4x3',q.keyword,'mat4x3'),mat4x4:new Pe('mat4x4',q.keyword,'mat4x4'),ptr:new Pe('ptr',q.keyword,'ptr'),sampler:new Pe('sampler',q.keyword,'sampler'),sampler_comparison:new Pe('sampler_comparison',q.keyword,'sampler_comparison'),struct:new Pe('struct',q.keyword,'struct'),texture_1d:new Pe('texture_1d',q.keyword,'texture_1d'),texture_2d:new Pe('texture_2d',q.keyword,'texture_2d'),texture_2d_array:new Pe('texture_2d_array',q.keyword,'texture_2d_array'),texture_3d:new Pe('texture_3d',q.keyword,'texture_3d'),texture_cube:new Pe('texture_cube',q.keyword,'texture_cube'),texture_cube_array:new Pe('texture_cube_array',q.keyword,'texture_cube_array'),texture_multisampled_2d:new Pe('texture_multisampled_2d',q.keyword,'texture_multisampled_2d'),texture_storage_1d:new Pe('texture_storage_1d',q.keyword,'texture_storage_1d'),texture_storage_2d:new Pe('texture_storage_2d',q.keyword,'texture_storage_2d'),texture_storage_2d_array:new Pe('texture_storage_2d_array',q.keyword,'texture_storage_2d_array'),texture_storage_3d:new Pe('texture_storage_3d',q.keyword,'texture_storage_3d'),texture_depth_2d:new Pe('texture_depth_2d',q.keyword,'texture_depth_2d'),texture_depth_2d_array:new Pe('texture_depth_2d_array',q.keyword,'texture_depth_2d_array'),texture_depth_cube:new Pe('texture_depth_cube',q.keyword,'texture_depth_cube'),texture_depth_cube_array:new Pe('texture_depth_cube_array',q.keyword,'texture_depth_cube_array'),texture_depth_multisampled_2d:new Pe('texture_depth_multisampled_2d',q.keyword,'texture_depth_multisampled_2d'),texture_external:new Pe('texture_external',q.keyword,'texture_external'),u32:new Pe('u32',q.keyword,'u32'),vec2:new Pe('vec2',q.keyword,'vec2'),vec3:new Pe('vec3',q.keyword,'vec3'),vec4:new Pe('vec4',q.keyword,'vec4'),bitcast:new Pe('bitcast',q.keyword,'bitcast'),block:new Pe('block',q.keyword,'block'),break:new Pe('break',q.keyword,'break'),case:new Pe('case',q.keyword,'case'),continue:new Pe('continue',q.keyword,'continue'),continuing:new Pe('continuing',q.keyword,'continuing'),default:new Pe('default',q.keyword,'default'),diagnostic:new Pe('diagnostic',q.keyword,'diagnostic'),discard:new Pe('discard',q.keyword,'discard'),else:new Pe('else',q.keyword,'else'),enable:new Pe('enable',q.keyword,'enable'),fallthrough:new Pe('fallthrough',q.keyword,'fallthrough'),false:new Pe('false',q.keyword,'false'),fn:new Pe('fn',q.keyword,'fn'),for:new Pe('for',q.keyword,'for'),function:new Pe('function',q.keyword,'function'),if:new Pe('if',q.keyword,'if'),let:new Pe('let',q.keyword,'let'),const:new Pe('const',q.keyword,'const'),loop:new Pe('loop',q.keyword,'loop'),while:new Pe('while',q.keyword,'while'),private:new Pe('private',q.keyword,'private'),read:new Pe('read',q.keyword,'read'),read_write:new Pe('read_write',q.keyword,'read_write'),return:new Pe('return',q.keyword,'return'),requires:new Pe('requires',q.keyword,'requires'),storage:new Pe('storage',q.keyword,'storage'),switch:new Pe('switch',q.keyword,'switch'),true:new Pe('true',q.keyword,'true'),alias:new Pe('alias',q.keyword,'alias'),type:new Pe('type',q.keyword,'type'),uniform:new Pe('uniform',q.keyword,'uniform'),var:new Pe('var',q.keyword,'var'),override:new Pe('override',q.keyword,'override'),workgroup:new Pe('workgroup',q.keyword,'workgroup'),write:new Pe('write',q.keyword,'write'),r8unorm:new Pe('r8unorm',q.keyword,'r8unorm'),r8snorm:new Pe('r8snorm',q.keyword,'r8snorm'),r8uint:new Pe('r8uint',q.keyword,'r8uint'),r8sint:new Pe('r8sint',q.keyword,'r8sint'),r16uint:new Pe('r16uint',q.keyword,'r16uint'),r16sint:new Pe('r16sint',q.keyword,'r16sint'),r16float:new Pe('r16float',q.keyword,'r16float'),rg8unorm:new Pe('rg8unorm',q.keyword,'rg8unorm'),rg8snorm:new Pe('rg8snorm',q.keyword,'rg8snorm'),rg8uint:new Pe('rg8uint',q.keyword,'rg8uint'),rg8sint:new Pe('rg8sint',q.keyword,'rg8sint'),r32uint:new Pe('r32uint',q.keyword,'r32uint'),r32sint:new Pe('r32sint',q.keyword,'r32sint'),r32float:new Pe('r32float',q.keyword,'r32float'),rg16uint:new Pe('rg16uint',q.keyword,'rg16uint'),rg16sint:new Pe('rg16sint',q.keyword,'rg16sint'),rg16float:new Pe('rg16float',q.keyword,'rg16float'),rgba8unorm:new Pe('rgba8unorm',q.keyword,'rgba8unorm'),rgba8unorm_srgb:new Pe('rgba8unorm_srgb',q.keyword,'rgba8unorm_srgb'),rgba8snorm:new Pe('rgba8snorm',q.keyword,'rgba8snorm'),rgba8uint:new Pe('rgba8uint',q.keyword,'rgba8uint'),rgba8sint:new Pe('rgba8sint',q.keyword,'rgba8sint'),bgra8unorm:new Pe('bgra8unorm',q.keyword,'bgra8unorm'),bgra8unorm_srgb:new Pe('bgra8unorm_srgb',q.keyword,'bgra8unorm_srgb'),rgb10a2unorm:new Pe('rgb10a2unorm',q.keyword,'rgb10a2unorm'),rg11b10float:new Pe('rg11b10float',q.keyword,'rg11b10float'),rg32uint:new Pe('rg32uint',q.keyword,'rg32uint'),rg32sint:new Pe('rg32sint',q.keyword,'rg32sint'),rg32float:new Pe('rg32float',q.keyword,'rg32float'),rgba16uint:new Pe('rgba16uint',q.keyword,'rgba16uint'),rgba16sint:new Pe('rgba16sint',q.keyword,'rgba16sint'),rgba16float:new Pe('rgba16float',q.keyword,'rgba16float'),rgba32uint:new Pe('rgba32uint',q.keyword,'rgba32uint'),rgba32sint:new Pe('rgba32sint',q.keyword,'rgba32sint'),rgba32float:new Pe('rgba32float',q.keyword,'rgba32float'),static_assert:new Pe('static_assert',q.keyword,'static_assert')},We.tokens={decimal_float_literal:new Pe('decimal_float_literal',q.token,/((-?[0-9]*\\.[0-9]+|-?[0-9]+\\.[0-9]*)((e|E)(\\+|-)?[0-9]+)?[fh]?)|(-?[0-9]+(e|E)(\\+|-)?[0-9]+[fh]?)|(-?[0-9]+[fh])/),hex_float_literal:new Pe('hex_float_literal',q.token,/-?0x((([0-9a-fA-F]*\\.[0-9a-fA-F]+|[0-9a-fA-F]+\\.[0-9a-fA-F]*)((p|P)(\\+|-)?[0-9]+[fh]?)?)|([0-9a-fA-F]+(p|P)(\\+|-)?[0-9]+[fh]?))/),int_literal:new Pe('int_literal',q.token,/-?0x[0-9a-fA-F]+|0i?|-?[1-9][0-9]*i?/),uint_literal:new Pe('uint_literal',q.token,/0x[0-9a-fA-F]+u|0u|[1-9][0-9]*u/),name:new Pe('name',q.token,/([_\\p{XID_Start}][\\p{XID_Continue}]+)|([\\p{XID_Start}])/u),ident:new Pe('ident',q.token,/[_a-zA-Z][0-9a-zA-Z_]*/),and:new Pe('and',q.token,'&'),and_and:new Pe('and_and',q.token,'&&'),arrow:new Pe('arrow ',q.token,'->'),attr:new Pe('attr',q.token,'@'),forward_slash:new Pe('forward_slash',q.token,'/'),bang:new Pe('bang',q.token,'!'),bracket_left:new Pe('bracket_left',q.token,'['),bracket_right:new Pe('bracket_right',q.token,']'),brace_left:new Pe('brace_left',q.token,'{'),brace_right:new Pe('brace_right',q.token,'}'),colon:new Pe('colon',q.token,':'),comma:new Pe('comma',q.token,','),equal:new Pe('equal',q.token,'='),equal_equal:new Pe('equal_equal',q.token,'=='),not_equal:new Pe('not_equal',q.token,'!='),greater_than:new Pe('greater_than',q.token,'>'),greater_than_equal:new Pe('greater_than_equal',q.token,'>='),shift_right:new Pe('shift_right',q.token,'>>'),less_than:new Pe('less_than',q.token,'<'),less_than_equal:new Pe('less_than_equal',q.token,'<='),shift_left:new Pe('shift_left',q.token,'<<'),modulo:new Pe('modulo',q.token,'%'),minus:new Pe('minus',q.token,'-'),minus_minus:new Pe('minus_minus',q.token,'--'),period:new Pe('period',q.token,'.'),plus:new Pe('plus',q.token,'+'),plus_plus:new Pe('plus_plus',q.token,'++'),or:new Pe('or',q.token,'|'),or_or:new Pe('or_or',q.token,'||'),paren_left:new Pe('paren_left',q.token,'('),paren_right:new Pe('paren_right',q.token,')'),semicolon:new Pe('semicolon',q.token,';'),star:new Pe('star',q.token,'*'),tilde:new Pe('tilde',q.token,'~'),underscore:new Pe('underscore',q.token,'_'),xor:new Pe('xor',q.token,'^'),plus_equal:new Pe('plus_equal',q.token,'+='),minus_equal:new Pe('minus_equal',q.token,'-='),times_equal:new Pe('times_equal',q.token,'*='),division_equal:new Pe('division_equal',q.token,'/='),modulo_equal:new Pe('modulo_equal',q.token,'%='),and_equal:new Pe('and_equal',q.token,'&='),or_equal:new Pe('or_equal',q.token,'|='),xor_equal:new Pe('xor_equal',q.token,'^='),shift_right_equal:new Pe('shift_right_equal',q.token,'>>='),shift_left_equal:new Pe('shift_left_equal',q.token,'<<=')},We.simpleTokens={'@':W.tokens.attr,'{':W.tokens.brace_left,'}':W.tokens.brace_right,':':W.tokens.colon,',':W.tokens.comma,'(':W.tokens.paren_left,')':W.tokens.paren_right,';':W.tokens.semicolon},We.literalTokens={'&':W.tokens.and,'&&':W.tokens.and_and,'->':W.tokens.arrow,'/':W.tokens.forward_slash,'!':W.tokens.bang,'[':W.tokens.bracket_left,']':W.tokens.bracket_right,'=':W.tokens.equal,'==':W.tokens.equal_equal,'!=':W.tokens.not_equal,'>':W.tokens.greater_than,'>=':W.tokens.greater_than_equal,'>>':W.tokens.shift_right,'<':W.tokens.less_than,'<=':W.tokens.less_than_equal,'<<':W.tokens.shift_left,'%':W.tokens.modulo,'-':W.tokens.minus,'--':W.tokens.minus_minus,'.':W.tokens.period,'+':W.tokens.plus,'++':W.tokens.plus_plus,'|':W.tokens.or,'||':W.tokens.or_or,'*':W.tokens.star,'~':W.tokens.tilde,_:W.tokens.underscore,'^':W.tokens.xor,'+=':W.tokens.plus_equal,'-=':W.tokens.minus_equal,'*=':W.tokens.times_equal,'/=':W.tokens.division_equal,'%=':W.tokens.modulo_equal,'&=':W.tokens.and_equal,'|=':W.tokens.or_equal,'^=':W.tokens.xor_equal,'>>=':W.tokens.shift_right_equal,'<<=':W.tokens.shift_left_equal},We.regexTokens={decimal_float_literal:W.tokens.decimal_float_literal,hex_float_literal:W.tokens.hex_float_literal,int_literal:W.tokens.int_literal,uint_literal:W.tokens.uint_literal,ident:W.tokens.ident},We.storage_class=[W.keywords.function,W.keywords.private,W.keywords.workgroup,W.keywords.uniform,W.keywords.storage],We.access_mode=[W.keywords.read,W.keywords.write,W.keywords.read_write],We.sampler_type=[W.keywords.sampler,W.keywords.sampler_comparison],We.sampled_texture_type=[W.keywords.texture_1d,W.keywords.texture_2d,W.keywords.texture_2d_array,W.keywords.texture_3d,W.keywords.texture_cube,W.keywords.texture_cube_array],We.multisampled_texture_type=[W.keywords.texture_multisampled_2d],We.storage_texture_type=[W.keywords.texture_storage_1d,W.keywords.texture_storage_2d,W.keywords.texture_storage_2d_array,W.keywords.texture_storage_3d],We.depth_texture_type=[W.keywords.texture_depth_2d,W.keywords.texture_depth_2d_array,W.keywords.texture_depth_cube,W.keywords.texture_depth_cube_array,W.keywords.texture_depth_multisampled_2d],We.texture_external_type=[W.keywords.texture_external],We.any_texture_type=[...W.sampled_texture_type,...W.multisampled_texture_type,...W.storage_texture_type,...W.depth_texture_type,...W.texture_external_type],We.texel_format=[W.keywords.r8unorm,W.keywords.r8snorm,W.keywords.r8uint,W.keywords.r8sint,W.keywords.r16uint,W.keywords.r16sint,W.keywords.r16float,W.keywords.rg8unorm,W.keywords.rg8snorm,W.keywords.rg8uint,W.keywords.rg8sint,W.keywords.r32uint,W.keywords.r32sint,W.keywords.r32float,W.keywords.rg16uint,W.keywords.rg16sint,W.keywords.rg16float,W.keywords.rgba8unorm,W.keywords.rgba8unorm_srgb,W.keywords.rgba8snorm,W.keywords.rgba8uint,W.keywords.rgba8sint,W.keywords.bgra8unorm,W.keywords.bgra8unorm_srgb,W.keywords.rgb10a2unorm,W.keywords.rg11b10float,W.keywords.rg32uint,W.keywords.rg32sint,W.keywords.rg32float,W.keywords.rgba16uint,W.keywords.rgba16sint,W.keywords.rgba16float,W.keywords.rgba32uint,W.keywords.rgba32sint,W.keywords.rgba32float],We.const_literal=[W.tokens.int_literal,W.tokens.uint_literal,W.tokens.decimal_float_literal,W.tokens.hex_float_literal,W.keywords.true,W.keywords.false],We.literal_or_ident=[W.tokens.ident,W.tokens.int_literal,W.tokens.uint_literal,W.tokens.decimal_float_literal,W.tokens.hex_float_literal,W.tokens.name],We.element_count_expression=[W.tokens.int_literal,W.tokens.uint_literal,W.tokens.ident],We.template_types=[W.keywords.vec2,W.keywords.vec3,W.keywords.vec4,W.keywords.mat2x2,W.keywords.mat2x3,W.keywords.mat2x4,W.keywords.mat3x2,W.keywords.mat3x3,W.keywords.mat3x4,W.keywords.mat4x2,W.keywords.mat4x3,W.keywords.mat4x4,W.keywords.atomic,W.keywords.bitcast,...W.any_texture_type],We.attribute_name=[W.tokens.ident,W.keywords.block,W.keywords.diagnostic],We.assignment_operators=[W.tokens.equal,W.tokens.plus_equal,W.tokens.minus_equal,W.tokens.times_equal,W.tokens.division_equal,W.tokens.modulo_equal,W.tokens.and_equal,W.tokens.or_equal,W.tokens.xor_equal,W.tokens.shift_right_equal,W.tokens.shift_left_equal],We.increment_operators=[W.tokens.plus_plus,W.tokens.minus_minus];class qe{constructor(e,t,n,s,r){this.type=e,this.lexeme=t,this.line=n,this.start=s,this.end=r}toString(){return this.lexeme}isTemplateType(){return-1!=We.template_types.indexOf(this.type)}isArrayType(){return this.type==We.keywords.array}isArrayOrTemplateType(){return this.isArrayType()||this.isTemplateType()}}class He{constructor(e){this._tokens=[],this._start=0,this._current=0,this._line=1,this._source=null!=e?e:''}scanTokens(){for(;!this._isAtEnd();)if(this._start=this._current,!this.scanToken())throw`Invalid syntax at line ${this._line}`;return this._tokens.push(new qe(We.eof,'',this._line,this._current,this._current)),this._tokens}scanToken(){let e=this._advance();if('\\n'==e)return this._line++,!0;if(this._isWhitespace(e))return!0;if('/'==e){if('/'==this._peekAhead()){for(;'\\n'!=e;){if(this._isAtEnd())return!0;e=this._advance()}return this._line++,!0}if('*'==this._peekAhead()){this._advance();let t=1;for(;t>0;){if(this._isAtEnd())return!0;if(e=this._advance(),'\\n'==e)this._line++;else if('*'==e){if('/'==this._peekAhead()&&(this._advance(),t--,0==t))return!0}else'/'==e&&'*'==this._peekAhead()&&(this._advance(),t++)}return!0}}const t=We.simpleTokens[e];if(t)return this._addToken(t),!0;let n=We.none;const s=this._isAlpha(e),r='_'===e;if(this._isAlphaNumeric(e)){let t=this._peekAhead();for(;this._isAlphaNumeric(t);)e+=this._advance(),t=this._peekAhead()}if(s){const t=We.keywords[e];if(t)return this._addToken(t),!0}if(s||r)return this._addToken(We.tokens.ident),!0;for(;;){let t=this._findType(e);const s=this._peekAhead();if('-'==e&&this._tokens.length>0){if('='==s)return this._current++,e+=s,this._addToken(We.tokens.minus_equal),!0;if('-'==s)return this._current++,e+=s,this._addToken(We.tokens.minus_minus),!0;const n=this._tokens.length-1;if((-1!=We.literal_or_ident.indexOf(this._tokens[n].type)||this._tokens[n].type==We.tokens.paren_right)&&'>'!=s)return this._addToken(t),!0}if('>'==e&&('>'==s||'='==s)){let e=!1,n=this._tokens.length-1;for(let t=0;t<5&&n>=0&&-1===We.assignment_operators.indexOf(this._tokens[n].type);++t,--n)if(this._tokens[n].type===We.tokens.less_than){n>0&&this._tokens[n-1].isArrayOrTemplateType()&&(e=!0);break}if(e)return this._addToken(t),!0}if(t===We.none){let s=e,r=0;const a=2;for(let e=0;e<a;++e)if(s+=this._peekAhead(e),t=this._findType(s),t!==We.none){r=e;break}if(t===We.none)return n!==We.none&&(this._current--,this._addToken(n),!0);e=s,this._current+=r+1}if(n=t,this._isAtEnd())break;e+=this._advance()}return n!==We.none&&(this._addToken(n),!0)}_findType(e){for(const t in We.regexTokens){const n=We.regexTokens[t];if(this._match(e,n.rule))return n}const t=We.literalTokens[e];return t||We.none}_match(e,t){const n=t.exec(e);return n&&0==n.index&&n[0]==e}_isAtEnd(){return this._current>=this._source.length}_isAlpha(e){return!this._isNumeric(e)&&!this._isWhitespace(e)&&'_'!==e&&'.'!==e&&'('!==e&&')'!==e&&'['!==e&&']'!==e&&'{'!==e&&'}'!==e&&','!==e&&';'!==e&&':'!==e&&'='!==e&&'!'!==e&&'<'!==e&&'>'!==e&&'+'!==e&&'-'!==e&&'*'!==e&&'/'!==e&&'%'!==e&&'&'!==e&&'|'!==e&&'^'!==e&&'~'!==e&&'@'!==e&&'#'!==e&&'?'!==e&&'\\''!==e&&'`'!==e&&'\"'!==e&&'\\\\'!==e&&'\\n'!==e&&'\\r'!==e&&'\\t'!==e&&'\\0'!==e}_isNumeric(e){return e>='0'&&e<='9'}_isAlphaNumeric(e){return this._isAlpha(e)||this._isNumeric(e)||'_'===e}_isWhitespace(e){return' '==e||'\\t'==e||'\\r'==e}_advance(e=0){let t=this._source[this._current];return e=e||0,e++,this._current+=e,t}_peekAhead(e=0){return e=e||0,this._current+e>=this._source.length?'\\0':this._source[this._current+e]}_addToken(e){const t=this._source.substring(this._start,this._current);this._tokens.push(new qe(e,t,this._line,this._start,this._current))}}function ze(e){return Array.isArray(e)||(null==e?void 0:e.buffer)instanceof ArrayBuffer}const Re=new Float32Array(1),Ge=new Uint32Array(Re.buffer),Xe=new Uint32Array(Re.buffer),je=new Int32Array(1),Ze=new Float32Array(je.buffer),Qe=new Uint32Array(je.buffer),Ye=new Uint32Array(1),Ke=new Float32Array(Ye.buffer),Je=new Int32Array(Ye.buffer);function et(e,t,n){if(t===n)return e;if('f32'===t){if('i32'===n||'x32'===n)return Re[0]=e,Ge[0];if('u32'===n)return Re[0]=e,Xe[0]}else if('i32'===t||'x32'===t){if('f32'===n)return je[0]=e,Ze[0];if('u32'===n)return je[0]=e,Qe[0]}else if('u32'===t){if('f32'===n)return Ye[0]=e,Ke[0];if('i32'===n||'x32'===n)return Ye[0]=e,Je[0]}return console.error(`Unsupported cast from ${t} to ${n}`),e}class tt{constructor(e){this.resources=null,this.inUse=!1,this.info=null,this.node=e}}class nt{constructor(e,t){this.align=e,this.size=t}}class st{constructor(){this.uniforms=[],this.storage=[],this.textures=[],this.samplers=[],this.aliases=[],this.overrides=[],this.structs=[],this.entry=new p,this.functions=[],this._types=new Map,this._functions=new Map}_isStorageTexture(e){return'texture_storage_1d'==e.name||'texture_storage_2d'==e.name||'texture_storage_2d_array'==e.name||'texture_storage_3d'==e.name}updateAST(e){for(const t of e)t instanceof L&&this._functions.set(t.name,new tt(t));for(const t of e)if(t instanceof ae){const e=this.getTypeInfo(t,null);e instanceof n&&this.structs.push(e)}for(const t of e)if(t instanceof J)this.aliases.push(this._getAliasInfo(t));else if(t instanceof B){const e=t,n=this._getAttributeNum(e.attributes,'id',0),s=null!=e.type?this.getTypeInfo(e.type,e.attributes):null;this.overrides.push(new u(e.name,s,e.attributes,n))}else if(this._isUniformVar(t)){const e=t,n=this._getAttributeNum(e.attributes,'group',0),s=this._getAttributeNum(e.attributes,'binding',0),r=this.getTypeInfo(e.type,e.attributes),o=new i(e.name,r,n,s,e.attributes,a.Uniform,e.access);o.access||(o.access='read'),this.uniforms.push(o)}else if(this._isStorageVar(t)){const e=t,n=this._getAttributeNum(e.attributes,'group',0),s=this._getAttributeNum(e.attributes,'binding',0),r=this.getTypeInfo(e.type,e.attributes),o=this._isStorageTexture(r),l=new i(e.name,r,n,s,e.attributes,o?a.StorageTexture:a.Storage,e.access);l.access||(l.access='read'),this.storage.push(l)}else if(this._isTextureVar(t)){const e=t,n=this._getAttributeNum(e.attributes,'group',0),s=this._getAttributeNum(e.attributes,'binding',0),r=this.getTypeInfo(e.type,e.attributes),o=this._isStorageTexture(r),l=new i(e.name,r,n,s,e.attributes,o?a.StorageTexture:a.Texture,e.access);l.access||(l.access='read'),o?this.storage.push(l):this.textures.push(l)}else if(this._isSamplerVar(t)){const e=t,n=this._getAttributeNum(e.attributes,'group',0),s=this._getAttributeNum(e.attributes,'binding',0),r=this.getTypeInfo(e.type,e.attributes),o=new i(e.name,r,n,s,e.attributes,a.Sampler,e.access);this.samplers.push(o)}else if(t instanceof L){const e=this._getAttribute(t,'vertex'),n=this._getAttribute(t,'fragment'),s=this._getAttribute(t,'compute'),r=e||n||s,a=new f(t.name,null==r?void 0:r.name,t.attributes);a.attributes=t.attributes,a.startLine=t.startLine,a.endLine=t.endLine,this.functions.push(a),this._functions.get(t.name).info=a,r&&(this._functions.get(t.name).inUse=!0,a.inUse=!0,a.resources=this._findResources(t,!!r),a.inputs=this._getInputs(t.args),a.outputs=this._getOutputs(t.returnType),this.entry[r.name].push(a)),a.arguments=t.args.map((e=>new h(e.name,this.getTypeInfo(e.type,e.attributes),e.attributes))),a.returnType=t.returnType?this.getTypeInfo(t.returnType,t.attributes):null}else;for(const e of this._functions.values())e.info&&(e.info.inUse=e.inUse,this._addCalls(e.node,e.info.calls));for(const e of this._functions.values())e.node.search((t=>{var n,s,r;if(t instanceof Le){if(t.value)if(ze(t.value))for(const s of t.value)for(const t of this.overrides)s===t.name&&(null===(n=e.info)||void 0===n||n.overrides.push(t));else for(const n of this.overrides)t.value===n.name&&(null===(s=e.info)||void 0===s||s.overrides.push(n))}else if(t instanceof de)for(const n of this.overrides)t.name===n.name&&(null===(r=e.info)||void 0===r||r.overrides.push(n))}));for(const e of this.uniforms)this._markStructsInUse(e.type);for(const e of this.storage)this._markStructsInUse(e.type)}getStructInfo(e){for(const t of this.structs)if(t.name==e)return t;return null}getOverrideInfo(e){for(const t of this.overrides)if(t.name==e)return t;return null}_markStructsInUse(e){if(e)if(e.isStruct){if(e.inUse=!0,e.members)for(const t of e.members)this._markStructsInUse(t.type)}else if(e.isArray)this._markStructsInUse(e.format);else if(e.isTemplate)e.format&&this._markStructsInUse(e.format);else{const t=this._getAlias(e.name);t&&this._markStructsInUse(t)}}_addCalls(e,t){var n;for(const s of e.calls){const e=null===(n=this._functions.get(s.name))||void 0===n?void 0:n.info;e&&t.add(e)}}findResource(e,t,n){if(n){for(const s of this.entry.compute)if(s.name===n)for(const n of s.resources)if(n.group==e&&n.binding==t)return n;for(const s of this.entry.vertex)if(s.name===n)for(const n of s.resources)if(n.group==e&&n.binding==t)return n;for(const s of this.entry.fragment)if(s.name===n)for(const n of s.resources)if(n.group==e&&n.binding==t)return n}for(const n of this.uniforms)if(n.group==e&&n.binding==t)return n;for(const n of this.storage)if(n.group==e&&n.binding==t)return n;for(const n of this.textures)if(n.group==e&&n.binding==t)return n;for(const n of this.samplers)if(n.group==e&&n.binding==t)return n;return null}_findResource(e){for(const t of this.uniforms)if(t.name==e)return t;for(const t of this.storage)if(t.name==e)return t;for(const t of this.textures)if(t.name==e)return t;for(const t of this.samplers)if(t.name==e)return t;return null}_markStructsFromAST(e){const t=this.getTypeInfo(e,null);this._markStructsInUse(t)}_findResources(e,t){const n=[],s=this,r=[];return e.search((a=>{if(a instanceof S)r.push({});else if(a instanceof A)r.pop();else if(a instanceof O){const e=a;t&&null!==e.type&&this._markStructsFromAST(e.type),r.length>0&&(r[r.length-1][e.name]=e)}else if(a instanceof fe){const e=a;t&&null!==e.type&&this._markStructsFromAST(e.type)}else if(a instanceof F){const e=a;t&&null!==e.type&&this._markStructsFromAST(e.type),r.length>0&&(r[r.length-1][e.name]=e)}else if(a instanceof de){const e=a;if(r.length>0){if(r[r.length-1][e.name])return}const t=s._findResource(e.name);t&&n.push(t)}else if(a instanceof pe){const r=a,i=s._functions.get(r.name);i&&(t&&(i.inUse=!0),e.calls.add(i.node),null===i.resources&&(i.resources=s._findResources(i.node,t)),n.push(...i.resources))}else if(a instanceof R){const r=a,i=s._functions.get(r.name);i&&(t&&(i.inUse=!0),e.calls.add(i.node),null===i.resources&&(i.resources=s._findResources(i.node,t)),n.push(...i.resources))}})),[...new Map(n.map((e=>[e.name,e]))).values()]}getBindGroups(){const e=[];function t(t,n){t>=e.length&&(e.length=t+1),void 0===e[t]&&(e[t]=[]),n>=e[t].length&&(e[t].length=n+1)}for(const n of this.uniforms){t(n.group,n.binding);e[n.group][n.binding]=n}for(const n of this.storage){t(n.group,n.binding);e[n.group][n.binding]=n}for(const n of this.textures){t(n.group,n.binding);e[n.group][n.binding]=n}for(const n of this.samplers){t(n.group,n.binding);e[n.group][n.binding]=n}return e}_getOutputs(e,t=void 0){if(void 0===t&&(t=[]),e instanceof ae)this._getStructOutputs(e,t);else{const n=this._getOutputInfo(e);null!==n&&t.push(n)}return t}_getStructOutputs(e,t){for(const n of e.members)if(n.type instanceof ae)this._getStructOutputs(n.type,t);else{const e=this._getAttribute(n,'location')||this._getAttribute(n,'builtin');if(null!==e){const s=this.getTypeInfo(n.type,n.type.attributes),r=this._parseInt(e.value),a=new c(n.name,s,e.name,r);t.push(a)}}}_getOutputInfo(e){const t=this._getAttribute(e,'location')||this._getAttribute(e,'builtin');if(null!==t){const n=this.getTypeInfo(e,e.attributes),s=this._parseInt(t.value);return new c('',n,t.name,s)}return null}_getInputs(e,t=void 0){void 0===t&&(t=[]);for(const n of e)if(n.type instanceof ae)this._getStructInputs(n.type,t);else{const e=this._getInputInfo(n);null!==e&&t.push(e)}return t}_getStructInputs(e,t){for(const n of e.members)if(n.type instanceof ae)this._getStructInputs(n.type,t);else{const e=this._getInputInfo(n);null!==e&&t.push(e)}}_getInputInfo(e){const t=this._getAttribute(e,'location')||this._getAttribute(e,'builtin');if(null!==t){const n=this._getAttribute(e,'interpolation'),s=this.getTypeInfo(e.type,e.attributes),r=this._parseInt(t.value),a=new l(e.name,s,t.name,r);return null!==n&&(a.interpolation=this._parseString(n.value)),a}return null}_parseString(e){return e instanceof Array&&(e=e[0]),e}_parseInt(e){e instanceof Array&&(e=e[0]);const t=parseInt(e);return isNaN(t)?e:t}_getAlias(e){for(const t of this.aliases)if(t.name==e)return t.type;return null}_getAliasInfo(e){return new o(e.name,this.getTypeInfo(e.type,null))}getTypeInfoByName(e){for(const t of this.structs)if(t.name==e)return t;for(const t of this.aliases)if(t.name==e)return t.type;return null}getTypeInfo(a,i=null){if(this._types.has(a))return this._types.get(a);if(a instanceof le){const e=a,t=e.format?this.getTypeInfo(e.format,e.attributes):null,n=new s(e.name,i);return n.format=t,n.count=e.count,this._types.set(a,n),this._updateTypeInfo(n),n}if(a instanceof ae){const e=a,s=new n(e.name,i);s.startLine=e.startLine,s.endLine=e.endLine;for(const n of e.members){const e=this.getTypeInfo(n.type,n.attributes);s.members.push(new t(n.name,e,n.attributes))}return this._types.set(a,s),this._updateTypeInfo(s),s}if(a instanceof ce){const t=a,n=t.format instanceof se,s=t.format?n?this.getTypeInfo(t.format,null):new e(t.format,null):null,o=new r(t.name,s,i,t.access);return this._types.set(a,o),this._updateTypeInfo(o),o}if(a instanceof ie){const e=a,t=e.format?this.getTypeInfo(e.format,null):null,n=new r(e.name,t,i,e.access);return this._types.set(a,n),this._updateTypeInfo(n),n}const o=new e(a.name,i);return this._types.set(a,o),this._updateTypeInfo(o),o}_updateTypeInfo(e){var t,r,a;const i=this._getTypeSize(e);if(e.size=null!==(t=null==i?void 0:i.size)&&void 0!==t?t:0,e instanceof s&&e.format){const t=this._getTypeSize(e.format);e.stride=Math.max(null!==(r=null==t?void 0:t.size)&&void 0!==r?r:0,null!==(a=null==t?void 0:t.align)&&void 0!==a?a:0),this._updateTypeInfo(e.format)}e instanceof n&&this._updateStructInfo(e)}_updateStructInfo(e){var t;let n=0,s=0,r=0,a=0;for(let i=0,o=e.members.length;i<o;++i){const o=e.members[i],l=this._getTypeSize(o);if(!l)continue;null!==(t=this._getAlias(o.type.name))&&void 0!==t||o.type;const c=l.align,u=l.size;n=this._roundUp(c,n+s),s=u,r=n,a=Math.max(a,c),o.offset=n,o.size=u,this._updateTypeInfo(o.type)}e.size=this._roundUp(a,r+s),e.align=a}_getTypeSize(r){var a,i;if(null==r)return null;const o=this._getAttributeNum(r.attributes,'size',0),l=this._getAttributeNum(r.attributes,'align',0);if(r instanceof t&&(r=r.type),r instanceof e){const e=this._getAlias(r.name);null!==e&&(r=e)}{const e=st._typeInfo[r.name];if(void 0!==e){const t='f16'===(null===(a=r.format)||void 0===a?void 0:a.name)?2:1;return new nt(Math.max(l,e.align/t),Math.max(o,e.size/t))}}{const e=st._typeInfo[r.name.substring(0,r.name.length-1)];if(e){const t='h'===r.name[r.name.length-1]?2:1;return new nt(Math.max(l,e.align/t),Math.max(o,e.size/t))}}if(r instanceof s){let e=r,t=8,n=8;const s=this._getTypeSize(e.format);null!==s&&(n=s.size,t=s.align);return n=e.count*this._getAttributeNum(null!==(i=null==r?void 0:r.attributes)&&void 0!==i?i:null,'stride',this._roundUp(t,n)),o&&(n=o),new nt(Math.max(l,t),Math.max(o,n))}if(r instanceof n){let e=0,t=0,n=0,s=0,a=0;for(const t of r.members){const r=this._getTypeSize(t.type);null!==r&&(e=Math.max(r.align,e),n=this._roundUp(r.align,n+s),s=r.size,a=n)}return t=this._roundUp(e,a+s),new nt(Math.max(l,e),Math.max(o,t))}return null}_isUniformVar(e){return e instanceof O&&'uniform'==e.storage}_isStorageVar(e){return e instanceof O&&'storage'==e.storage}_isTextureVar(e){return e instanceof O&&null!==e.type&&-1!=st._textureTypes.indexOf(e.type.name)}_isSamplerVar(e){return e instanceof O&&null!==e.type&&-1!=st._samplerTypes.indexOf(e.type.name)}_getAttribute(e,t){const n=e;if(!n||!n.attributes)return null;const s=n.attributes;for(let e of s)if(e.name==t)return e;return null}_getAttributeNum(e,t,n){if(null===e)return n;for(let s of e)if(s.name==t){let e=null!==s&&null!==s.value?s.value:n;return e instanceof Array&&(e=e[0]),'number'==typeof e?e:'string'==typeof e?parseInt(e):n}return n}_roundUp(e,t){return Math.ceil(t/e)*e}}st._typeInfo={f16:{align:2,size:2},i32:{align:4,size:4},u32:{align:4,size:4},f32:{align:4,size:4},atomic:{align:4,size:4},vec2:{align:8,size:8},vec3:{align:16,size:12},vec4:{align:16,size:16},mat2x2:{align:8,size:16},mat3x2:{align:8,size:24},mat4x2:{align:8,size:32},mat2x3:{align:16,size:32},mat3x3:{align:16,size:48},mat4x3:{align:16,size:64},mat2x4:{align:16,size:32},mat3x4:{align:16,size:48},mat4x4:{align:16,size:64}},st._textureTypes=We.any_texture_type.map((e=>e.name)),st._samplerTypes=We.sampler_type.map((e=>e.name));class rt{constructor(e,t,n){this.name=e,this.value=t,this.node=n}clone(){return new rt(this.name,this.value,this.node)}}class at{constructor(e){this.name=e.name,this.node=e}clone(){return new at(this.node)}}class it{constructor(e){this.parent=null,this.variables=new Map,this.functions=new Map,this.currentFunctionName='',e&&(this.parent=e,this.currentFunctionName=e.currentFunctionName)}getVariable(e){var t;return this.variables.has(e)?null!==(t=this.variables.get(e))&&void 0!==t?t:null:this.parent?this.parent.getVariable(e):null}getFunction(e){var t;return this.functions.has(e)?null!==(t=this.functions.get(e))&&void 0!==t?t:null:this.parent?this.parent.getFunction(e):null}createVariable(e,t,n){this.variables.set(e,new rt(e,t,null!=n?n:null))}setVariable(e,t,n){const s=this.getVariable(e);null!==s?s.value=t:this.createVariable(e,t,n)}getVariableValue(e){var t;const n=this.getVariable(e);return null!==(t=null==n?void 0:n.value)&&void 0!==t?t:null}clone(){return new it(this)}}class ot{evalExpression(e,t){return null}getTypeInfo(e){return null}getVariableName(e,t){return''}}class lt{constructor(e){this.exec=e}getTypeInfo(e){return this.exec.getTypeInfo(e)}All(e,t){const n=this.exec.evalExpression(e.args[0],t);let s=!0;if(n instanceof Be)return n.data.forEach((e=>{e||(s=!1)})),new Ve(s?1:0,this.getTypeInfo('bool'));throw new Error(`All() expects a vector argument. Line ${e.line}`)}Any(e,t){const n=this.exec.evalExpression(e.args[0],t);if(n instanceof Be){const e=n.data.some((e=>e));return new Ve(e?1:0,this.getTypeInfo('bool'))}throw new Error(`Any() expects a vector argument. Line ${e.line}`)}Select(e,t){const n=this.exec.evalExpression(e.args[2],t);if(!(n instanceof Ve))throw new Error(`Select() expects a bool condition. Line ${e.line}`);return n.value?this.exec.evalExpression(e.args[1],t):this.exec.evalExpression(e.args[0],t)}ArrayLength(e,t){let n=e.args[0];n instanceof ve&&(n=n.right);const s=this.exec.evalExpression(n,t);if(s instanceof Me&&0===s.typeInfo.size){const e=s.typeInfo,t=s.buffer.byteLength/e.stride;return new Ve(t,this.getTypeInfo('u32'))}return new Ve(s.typeInfo.size,this.getTypeInfo('u32'))}Abs(e,t){const n=this.exec.evalExpression(e.args[0],t);if(n instanceof Be)return new Be(n.data.map((e=>Math.abs(e))),n.typeInfo);const s=n;return new Ve(Math.abs(s.value),s.typeInfo)}Acos(e,t){const n=this.exec.evalExpression(e.args[0],t);if(n instanceof Be)return new Be(n.data.map((e=>Math.acos(e))),n.typeInfo);const s=n;return new Ve(Math.acos(s.value),n.typeInfo)}Acosh(e,t){const n=this.exec.evalExpression(e.args[0],t);if(n instanceof Be)return new Be(n.data.map((e=>Math.acosh(e))),n.typeInfo);const s=n;return new Ve(Math.acosh(s.value),n.typeInfo)}Asin(e,t){const n=this.exec.evalExpression(e.args[0],t);if(n instanceof Be)return new Be(n.data.map((e=>Math.asin(e))),n.typeInfo);const s=n;return new Ve(Math.asin(s.value),n.typeInfo)}Asinh(e,t){const n=this.exec.evalExpression(e.args[0],t);if(n instanceof Be)return new Be(n.data.map((e=>Math.asinh(e))),n.typeInfo);const s=n;return new Ve(Math.asinh(s.value),n.typeInfo)}Atan(e,t){const n=this.exec.evalExpression(e.args[0],t);if(n instanceof Be)return new Be(n.data.map((e=>Math.atan(e))),n.typeInfo);const s=n;return new Ve(Math.atan(s.value),n.typeInfo)}Atanh(e,t){const n=this.exec.evalExpression(e.args[0],t);if(n instanceof Be)return new Be(n.data.map((e=>Math.atanh(e))),n.typeInfo);const s=n;return new Ve(Math.atanh(s.value),n.typeInfo)}Atan2(e,t){const n=this.exec.evalExpression(e.args[0],t),s=this.exec.evalExpression(e.args[1],t);if(n instanceof Be&&s instanceof Be)return new Be(n.data.map(((e,t)=>Math.atan2(e,s.data[t]))),n.typeInfo);const r=n,a=s;return new Ve(Math.atan2(r.value,a.value),n.typeInfo)}Ceil(e,t){const n=this.exec.evalExpression(e.args[0],t);if(n instanceof Be)return new Be(n.data.map((e=>Math.ceil(e))),n.typeInfo);const s=n;return new Ve(Math.ceil(s.value),n.typeInfo)}_clamp(e,t,n){return Math.min(Math.max(e,t),n)}Clamp(e,t){const n=this.exec.evalExpression(e.args[0],t),s=this.exec.evalExpression(e.args[1],t),r=this.exec.evalExpression(e.args[2],t);if(n instanceof Be&&s instanceof Be&&r instanceof Be)return new Be(n.data.map(((e,t)=>this._clamp(e,s.data[t],r.data[t]))),n.typeInfo);const a=n,i=s,o=r;return new Ve(this._clamp(a.value,i.value,o.value),n.typeInfo)}Cos(e,t){const n=this.exec.evalExpression(e.args[0],t);if(n instanceof Be)return new Be(n.data.map((e=>Math.cos(e))),n.typeInfo);const s=n;return new Ve(Math.cos(s.value),n.typeInfo)}Cosh(e,t){const n=this.exec.evalExpression(e.args[0],t);if(n instanceof Be)return new Be(n.data.map((e=>Math.cosh(e))),n.typeInfo);const s=n;return new Ve(Math.cos(s.value),n.typeInfo)}CountLeadingZeros(e,t){const n=this.exec.evalExpression(e.args[0],t);if(n instanceof Be)return new Be(n.data.map((e=>Math.clz32(e))),n.typeInfo);const s=n;return new Ve(Math.clz32(s.value),n.typeInfo)}_countOneBits(e){let t=0;for(;0!==e;)1&e&&t++,e>>=1;return t}CountOneBits(e,t){const n=this.exec.evalExpression(e.args[0],t);if(n instanceof Be)return new Be(n.data.map((e=>this._countOneBits(e))),n.typeInfo);const s=n;return new Ve(this._countOneBits(s.value),n.typeInfo)}_countTrailingZeros(e){if(0===e)return 32;let t=0;for(;!(1&e);)e>>=1,t++;return t}CountTrailingZeros(e,t){const n=this.exec.evalExpression(e.args[0],t);if(n instanceof Be)return new Be(n.data.map((e=>this._countTrailingZeros(e))),n.typeInfo);const s=n;return new Ve(this._countTrailingZeros(s.value),n.typeInfo)}Cross(e,t){const n=this.exec.evalExpression(e.args[0],t),s=this.exec.evalExpression(e.args[1],t);if(n instanceof Be&&s instanceof Be){if(3!==n.data.length||3!==s.data.length)return console.error(`Cross() expects 3D vectors. Line ${e.line}`),null;const t=n.data,r=s.data;return new Be([t[1]*r[2]-r[1]*t[2],t[2]*r[0]-r[2]*t[0],t[0]*r[1]-r[0]*t[1]],n.typeInfo)}return console.error(`Cross() expects vector arguments. Line ${e.line}`),null}Degrees(e,t){const n=this.exec.evalExpression(e.args[0],t),s=180/Math.PI;if(n instanceof Be)return new Be(n.data.map((e=>e*s)),n.typeInfo);return new Ve(n.value*s,this.getTypeInfo('f32'))}Determinant(e,t){const n=this.exec.evalExpression(e.args[0],t);if(n instanceof Fe){const e=n.data,t=n.typeInfo.getTypeName(),s=t.endsWith('h')?this.getTypeInfo('f16'):this.getTypeInfo('f32');if('mat2x2'===t||'mat2x2f'===t||'mat2x2h'===t)return new Ve(e[0]*e[3]-e[1]*e[2],s);if('mat2x3'===t||'mat2x3f'===t||'mat2x3h'===t)return new Ve(e[0]*(e[4]*e[8]-e[5]*e[7])-e[1]*(e[3]*e[8]-e[5]*e[6])+e[2]*(e[3]*e[7]-e[4]*e[6]),s);if('mat2x4'===t||'mat2x4f'===t||'mat2x4h'===t)console.error(`TODO: Determinant for ${t}`);else if('mat3x2'===t||'mat3x2f'===t||'mat3x2h'===t)console.error(`TODO: Determinant for ${t}`);else{if('mat3x3'===t||'mat3x3f'===t||'mat3x3h'===t)return new Ve(e[0]*(e[4]*e[8]-e[5]*e[7])-e[1]*(e[3]*e[8]-e[5]*e[6])+e[2]*(e[3]*e[7]-e[4]*e[6]),s);'mat3x4'===t||'mat3x4f'===t||'mat3x4h'===t||'mat4x2'===t||'mat4x2f'===t||'mat4x2h'===t||'mat4x3'===t||'mat4x3f'===t||'mat4x3h'===t?console.error(`TODO: Determinant for ${t}`):'mat4x4'!==t&&'mat4x4f'!==t&&'mat4x4h'!==t||console.error(`TODO: Determinant for ${t}`)}}return console.error(`Determinant expects a matrix argument. Line ${e.line}`),null}Distance(e,t){const n=this.exec.evalExpression(e.args[0],t),s=this.exec.evalExpression(e.args[1],t);if(n instanceof Be&&s instanceof Be){let e=0;for(let t=0;t<n.data.length;++t)e+=(n.data[t]-s.data[t])*(n.data[t]-s.data[t]);return new Ve(Math.sqrt(e),this.getTypeInfo('f32'))}const r=n,a=s;return new Ve(Math.abs(r.value-a.value),n.typeInfo)}_dot(e,t){let n=0;for(let s=0;s<e.length;++s)n+=t[s]*e[s];return n}Dot(e,t){const n=this.exec.evalExpression(e.args[0],t),s=this.exec.evalExpression(e.args[1],t);return n instanceof Be&&s instanceof Be?new Ve(this._dot(n.data,s.data),this.getTypeInfo('f32')):(console.error(`Dot() expects vector arguments. Line ${e.line}`),null)}Dot4U8Packed(e,t){return console.error(`TODO: dot4U8Packed. Line ${e.line}`),null}Dot4I8Packed(e,t){return console.error(`TODO: dot4I8Packed. Line ${e.line}`),null}Exp(e,t){const n=this.exec.evalExpression(e.args[0],t);if(n instanceof Be)return new Be(n.data.map((e=>Math.exp(e))),n.typeInfo);const s=n;return new Ve(Math.exp(s.value),n.typeInfo)}Exp2(e,t){const n=this.exec.evalExpression(e.args[0],t);if(n instanceof Be)return new Be(n.data.map((e=>Math.pow(2,e))),n.typeInfo);const s=n;return new Ve(Math.pow(2,s.value),n.typeInfo)}ExtractBits(e,t){const n=this.exec.evalExpression(e.args[0],t),s=this.exec.evalExpression(e.args[1],t),r=this.exec.evalExpression(e.args[2],t);if('u32'!==s.typeInfo.name&&'x32'!==s.typeInfo.name)return console.error(`ExtractBits() expects an i32 offset argument. Line ${e.line}`),null;if('u32'!==r.typeInfo.name&&'x32'!==r.typeInfo.name)return console.error(`ExtractBits() expects an i32 count argument. Line ${e.line}`),null;const a=s.value,i=r.value;if(n instanceof Be)return new Be(n.data.map((e=>e>>a&(1<<i)-1)),n.typeInfo);if('i32'!==n.typeInfo.name&&'x32'!==n.typeInfo.name)return console.error(`ExtractBits() expects an i32 argument. Line ${e.line}`),null;const o=n.value;return new Ve(o>>a&(1<<i)-1,this.getTypeInfo('i32'))}FaceForward(e,t){const n=this.exec.evalExpression(e.args[0],t),s=this.exec.evalExpression(e.args[1],t),r=this.exec.evalExpression(e.args[2],t);if(n instanceof Be&&s instanceof Be&&r instanceof Be){const e=this._dot(s.data,r.data);return new Be(e<0?Array.from(n.data):n.data.map((e=>-e)),n.typeInfo)}return console.error(`FaceForward() expects vector arguments. Line ${e.line}`),null}_firstLeadingBit(e){return 0===e?-1:31-Math.clz32(e)}FirstLeadingBit(e,t){const n=this.exec.evalExpression(e.args[0],t);if(n instanceof Be)return new Be(n.data.map((e=>this._firstLeadingBit(e))),n.typeInfo);const s=n;return new Ve(this._firstLeadingBit(s.value),n.typeInfo)}_firstTrailingBit(e){return 0===e?-1:Math.log2(e&-e)}FirstTrailingBit(e,t){const n=this.exec.evalExpression(e.args[0],t);if(n instanceof Be)return new Be(n.data.map((e=>this._firstTrailingBit(e))),n.typeInfo);const s=n;return new Ve(this._firstTrailingBit(s.value),n.typeInfo)}Floor(e,t){const n=this.exec.evalExpression(e.args[0],t);if(n instanceof Be)return new Be(n.data.map((e=>Math.floor(e))),n.typeInfo);const s=n;return new Ve(Math.floor(s.value),n.typeInfo)}Fma(e,t){const n=this.exec.evalExpression(e.args[0],t),s=this.exec.evalExpression(e.args[1],t),r=this.exec.evalExpression(e.args[2],t);if(n instanceof Be&&s instanceof Be&&r instanceof Be)return n.data.length!==s.data.length||n.data.length!==r.data.length?(console.error(`Fma() expects vectors of the same length. Line ${e.line}`),null):new Be(n.data.map(((e,t)=>e*s.data[t]+r.data[t])),n.typeInfo);const a=n,i=s,o=r;return new Ve(a.value*i.value+o.value,a.typeInfo)}Fract(e,t){const n=this.exec.evalExpression(e.args[0],t);if(n instanceof Be)return new Be(n.data.map((e=>e-Math.floor(e))),n.typeInfo);const s=n;return new Ve(s.value-Math.floor(s.value),n.typeInfo)}Frexp(e,t){return console.error(`TODO: frexp. Line ${e.line}`),null}InsertBits(e,t){const n=this.exec.evalExpression(e.args[0],t),s=this.exec.evalExpression(e.args[1],t),r=this.exec.evalExpression(e.args[2],t),a=this.exec.evalExpression(e.args[3],t);if('u32'!==r.typeInfo.name&&'x32'!==r.typeInfo.name)return console.error(`InsertBits() expects an i32 offset argument. Line ${e.line}`),null;const i=r.value,o=(1<<a.value)-1<<i,l=~o;if(n instanceof Be&&s instanceof Be)return new Be(n.data.map(((e,t)=>e&l|s.data[t]<<i&o)),n.typeInfo);const c=n.value,u=s.value;return new Ve(c&l|u<<i&o,n.typeInfo)}InverseSqrt(e,t){const n=this.exec.evalExpression(e.args[0],t);if(n instanceof Be)return new Be(n.data.map((e=>1/Math.sqrt(e))),n.typeInfo);const s=n;return new Ve(1/Math.sqrt(s.value),n.typeInfo)}Ldexp(e,t){return console.error(`TODO: ldexp. Line ${e.line}`),null}Length(e,t){const n=this.exec.evalExpression(e.args[0],t);if(n instanceof Be){let e=0;return n.data.forEach((t=>{e+=t*t})),new Ve(Math.sqrt(e),this.getTypeInfo('f32'))}const s=n;return new Ve(Math.abs(s.value),n.typeInfo)}Log(e,t){const n=this.exec.evalExpression(e.args[0],t);if(n instanceof Be)return new Be(n.data.map((e=>Math.log(e))),n.typeInfo);const s=n;return new Ve(Math.log(s.value),n.typeInfo)}Log2(e,t){const n=this.exec.evalExpression(e.args[0],t);if(n instanceof Be)return new Be(n.data.map((e=>Math.log2(e))),n.typeInfo);const s=n;return new Ve(Math.log2(s.value),n.typeInfo)}Max(e,t){const n=this.exec.evalExpression(e.args[0],t),s=this.exec.evalExpression(e.args[1],t);if(n instanceof Be&&s instanceof Be)return new Be(n.data.map(((e,t)=>Math.max(e,s.data[t]))),n.typeInfo);const r=n,a=s;return new Ve(Math.max(r.value,a.value),n.typeInfo)}Min(e,t){const n=this.exec.evalExpression(e.args[0],t),s=this.exec.evalExpression(e.args[1],t);if(n instanceof Be&&s instanceof Be)return new Be(n.data.map(((e,t)=>Math.min(e,s.data[t]))),n.typeInfo);const r=n,a=s;return new Ve(Math.min(r.value,a.value),n.typeInfo)}Mix(e,t){const n=this.exec.evalExpression(e.args[0],t),s=this.exec.evalExpression(e.args[1],t),r=this.exec.evalExpression(e.args[2],t);if(n instanceof Be&&s instanceof Be&&r instanceof Be)return new Be(n.data.map(((e,t)=>n.data[t]*(1-r.data[t])+s.data[t]*r.data[t])),n.typeInfo);const a=s,i=r;return new Ve(n.value*(1-i.value)+a.value*i.value,n.typeInfo)}Modf(e,t){const n=this.exec.evalExpression(e.args[0],t),s=this.exec.evalExpression(e.args[1],t);if(n instanceof Be&&s instanceof Be)return new Be(n.data.map(((e,t)=>e%s.data[t])),n.typeInfo);const r=s;return new Ve(n.value%r.value,n.typeInfo)}Normalize(e,t){const n=this.exec.evalExpression(e.args[0],t);if(n instanceof Be){const s=this.Length(e,t).value;return new Be(n.data.map((e=>e/s)),n.typeInfo)}return console.error(`Normalize() expects a vector argument. Line ${e.line}`),null}Pow(e,t){const n=this.exec.evalExpression(e.args[0],t),s=this.exec.evalExpression(e.args[1],t);if(n instanceof Be&&s instanceof Be)return new Be(n.data.map(((e,t)=>Math.pow(e,s.data[t]))),n.typeInfo);const r=n,a=s;return new Ve(Math.pow(r.value,a.value),n.typeInfo)}QuantizeToF16(e,t){const n=this.exec.evalExpression(e.args[0],t);if(n instanceof Be)return new Be(n.data.map((e=>e)),n.typeInfo);return new Ve(n.value,n.typeInfo)}Radians(e,t){const n=this.exec.evalExpression(e.args[0],t);if(n instanceof Be)return new Be(n.data.map((e=>e*Math.PI/180)),n.typeInfo);return new Ve(n.value*Math.PI/180,this.getTypeInfo('f32'))}Reflect(e,t){let n=this.exec.evalExpression(e.args[0],t),s=this.exec.evalExpression(e.args[1],t);if(n instanceof Be&&s instanceof Be){const e=this._dot(n.data,s.data);return new Be(n.data.map(((t,n)=>t-2*e*s.data[n])),n.typeInfo)}return console.error(`Reflect() expects vector arguments. Line ${e.line}`),null}Refract(e,t){let n=this.exec.evalExpression(e.args[0],t),s=this.exec.evalExpression(e.args[1],t),r=this.exec.evalExpression(e.args[2],t);if(n instanceof Be&&s instanceof Be&&r instanceof Ve){const e=this._dot(s.data,n.data);return new Be(n.data.map(((t,n)=>{const a=1-r.value*r.value*(1-e*e);if(a<0)return 0;const i=Math.sqrt(a);return r.value*t-(r.value*e+i)*s.data[n]})),n.typeInfo)}return console.error(`Refract() expects vector arguments and a scalar argument. Line ${e.line}`),null}ReverseBits(e,t){return console.error(`TODO: reverseBits. Line ${e.line}`),null}Round(e,t){const n=this.exec.evalExpression(e.args[0],t);if(n instanceof Be)return new Be(n.data.map((e=>Math.round(e))),n.typeInfo);const s=n;return new Ve(Math.round(s.value),n.typeInfo)}Saturate(e,t){const n=this.exec.evalExpression(e.args[0],t);if(n instanceof Be)return new Be(n.data.map((e=>Math.min(Math.max(e,0),1))),n.typeInfo);const s=n;return new Ve(Math.min(Math.max(s.value,0),1),n.typeInfo)}Sign(e,t){const n=this.exec.evalExpression(e.args[0],t);if(n instanceof Be)return new Be(n.data.map((e=>Math.sign(e))),n.typeInfo);const s=n;return new Ve(Math.sign(s.value),n.typeInfo)}Sin(e,t){const n=this.exec.evalExpression(e.args[0],t);if(n instanceof Be)return new Be(n.data.map((e=>Math.sin(e))),n.typeInfo);const s=n;return new Ve(Math.sin(s.value),n.typeInfo)}Sinh(e,t){const n=this.exec.evalExpression(e.args[0],t);if(n instanceof Be)return new Be(n.data.map((e=>Math.sinh(e))),n.typeInfo);const s=n;return new Ve(Math.sinh(s.value),n.typeInfo)}_smoothstep(e,t,n){const s=Math.min(Math.max((n-e)/(t-e),0),1);return s*s*(3-2*s)}SmoothStep(e,t){const n=this.exec.evalExpression(e.args[0],t),s=this.exec.evalExpression(e.args[1],t),r=this.exec.evalExpression(e.args[2],t);if(r instanceof Be&&n instanceof Be&&s instanceof Be)return new Be(r.data.map(((e,t)=>this._smoothstep(n.data[t],s.data[t],e))),r.typeInfo);const a=n,i=s,o=r;return new Ve(this._smoothstep(a.value,i.value,o.value),r.typeInfo)}Sqrt(e,t){const n=this.exec.evalExpression(e.args[0],t);if(n instanceof Be)return new Be(n.data.map((e=>Math.sqrt(e))),n.typeInfo);const s=n;return new Ve(Math.sqrt(s.value),n.typeInfo)}Step(e,t){const n=this.exec.evalExpression(e.args[0],t),s=this.exec.evalExpression(e.args[1],t);if(s instanceof Be&&n instanceof Be)return new Be(s.data.map(((e,t)=>e<n.data[t]?0:1)),s.typeInfo);const r=n;return new Ve(s.value<r.value?0:1,r.typeInfo)}Tan(e,t){const n=this.exec.evalExpression(e.args[0],t);if(n instanceof Be)return new Be(n.data.map((e=>Math.tan(e))),n.typeInfo);const s=n;return new Ve(Math.tan(s.value),n.typeInfo)}Tanh(e,t){const n=this.exec.evalExpression(e.args[0],t);if(n instanceof Be)return new Be(n.data.map((e=>Math.tanh(e))),n.typeInfo);const s=n;return new Ve(Math.tanh(s.value),n.typeInfo)}_getTransposeType(e){const t=e.getTypeName();return'mat2x2f'===t||'mat2x2h'===t?e:'mat2x3f'===t?this.getTypeInfo('mat3x2f'):'mat2x3h'===t?this.getTypeInfo('mat3x2h'):'mat2x4f'===t?this.getTypeInfo('mat4x2f'):'mat2x4h'===t?this.getTypeInfo('mat4x2h'):'mat3x2f'===t?this.getTypeInfo('mat2x3f'):'mat3x2h'===t?this.getTypeInfo('mat2x3h'):'mat3x3f'===t||'mat3x3h'===t?e:'mat3x4f'===t?this.getTypeInfo('mat4x3f'):'mat3x4h'===t?this.getTypeInfo('mat4x3h'):'mat4x2f'===t?this.getTypeInfo('mat2x4f'):'mat4x2h'===t?this.getTypeInfo('mat2x4h'):'mat4x3f'===t?this.getTypeInfo('mat3x4f'):'mat4x3h'===t?this.getTypeInfo('mat3x4h'):('mat4x4f'===t||'mat4x4h'===t||console.error(`Invalid matrix type ${t}`),e)}Transpose(e,t){const n=this.exec.evalExpression(e.args[0],t);if(!(n instanceof Fe))return console.error(`Transpose() expects a matrix argument. Line ${e.line}`),null;const s=this._getTransposeType(n.typeInfo);if('mat2x2'===n.typeInfo.name||'mat2x2f'===n.typeInfo.name||'mat2x2h'===n.typeInfo.name){const e=n.data;return new Fe([e[0],e[2],e[1],e[3]],s)}if('mat2x3'===n.typeInfo.name||'mat2x3f'===n.typeInfo.name||'mat2x3h'===n.typeInfo.name){const e=n.data;return new Fe([e[0],e[3],e[6],e[1],e[4],e[7]],s)}if('mat2x4'===n.typeInfo.name||'mat2x4f'===n.typeInfo.name||'mat2x4h'===n.typeInfo.name){const e=n.data;return new Fe([e[0],e[4],e[8],e[12],e[1],e[5],e[9],e[13]],s)}if('mat3x2'===n.typeInfo.name||'mat3x2f'===n.typeInfo.name||'mat3x2h'===n.typeInfo.name){const e=n.data;return new Fe([e[0],e[3],e[1],e[4],e[2],e[5]],s)}if('mat3x3'===n.typeInfo.name||'mat3x3f'===n.typeInfo.name||'mat3x3h'===n.typeInfo.name){const e=n.data;return new Fe([e[0],e[3],e[6],e[1],e[4],e[7],e[2],e[5],e[8]],s)}if('mat3x4'===n.typeInfo.name||'mat3x4f'===n.typeInfo.name||'mat3x4h'===n.typeInfo.name){const e=n.data;return new Fe([e[0],e[4],e[8],e[12],e[1],e[5],e[9],e[13],e[2],e[6],e[10],e[14]],s)}if('mat4x2'===n.typeInfo.name||'mat4x2f'===n.typeInfo.name||'mat4x2h'===n.typeInfo.name){const e=n.data;return new Fe([e[0],e[4],e[1],e[5],e[2],e[6]],s)}if('mat4x3'===n.typeInfo.name||'mat4x3f'===n.typeInfo.name||'mat4x3h'===n.typeInfo.name){const e=n.data;return new Fe([e[0],e[4],e[8],e[1],e[5],e[9],e[2],e[6],e[10]],s)}if('mat4x4'===n.typeInfo.name||'mat4x4f'===n.typeInfo.name||'mat4x4h'===n.typeInfo.name){const e=n.data;return new Fe([e[0],e[4],e[8],e[12],e[1],e[5],e[9],e[13],e[2],e[6],e[10],e[14],e[3],e[7],e[11],e[15]],s)}return console.error(`Invalid matrix type ${n.typeInfo.name}`),null}Trunc(e,t){const n=this.exec.evalExpression(e.args[0],t);if(n instanceof Be)return new Be(n.data.map((e=>Math.trunc(e))),n.typeInfo);const s=n;return new Ve(Math.trunc(s.value),n.typeInfo)}Dpdx(e,t){return console.error(`TODO: dpdx. Line ${e.line}`),null}DpdxCoarse(e,t){return console.error(`TODO: dpdxCoarse. Line ${e.line}`),null}DpdxFine(e,t){return console.error('TODO: dpdxFine'),null}Dpdy(e,t){return console.error('TODO: dpdy'),null}DpdyCoarse(e,t){return console.error('TODO: dpdyCoarse'),null}DpdyFine(e,t){return console.error('TODO: dpdyFine'),null}Fwidth(e,t){return console.error('TODO: fwidth'),null}FwidthCoarse(e,t){return console.error('TODO: fwidthCoarse'),null}FwidthFine(e,t){return console.error('TODO: fwidthFine'),null}TextureDimensions(e,t){const n=e.args[0],s=e.args.length>1?this.exec.evalExpression(e.args[1],t).value:0;if(n instanceof de){const r=n.name,a=t.getVariableValue(r);if(a instanceof Ue){if(s<0||s>=a.mipLevelCount)return console.error(`Invalid mip level for textureDimensions. Line ${e.line}`),null;const t=a.getMipLevelSize(s),n=a.dimension;return'1d'===n?new Ve(t[0],this.getTypeInfo('u32')):'3d'===n?new Be(t,this.getTypeInfo('vec3u')):'2d'===n?new Be(t.slice(0,2),this.getTypeInfo('vec2u')):(console.error(`Invalid texture dimension ${n} not found. Line ${e.line}`),null)}return console.error(`Texture ${r} not found. Line ${e.line}`),null}return console.error(`Invalid texture argument for textureDimensions. Line ${e.line}`),null}TextureGather(e,t){return console.error('TODO: textureGather'),null}TextureGatherCompare(e,t){return console.error('TODO: textureGatherCompare'),null}TextureLoad(e,t){const n=e.args[0],s=this.exec.evalExpression(e.args[1],t),r=e.args.length>2?this.exec.evalExpression(e.args[2],t).value:0;if(!(s instanceof Be)||2!==s.data.length)return console.error(`Invalid UV argument for textureLoad. Line ${e.line}`),null;if(n instanceof de){const a=n.name,i=t.getVariableValue(a);if(i instanceof Ue){const t=Math.floor(s.data[0]),n=Math.floor(s.data[1]);if(t<0||t>=i.width||n<0||n>=i.height)return console.error(`Texture ${a} out of bounds. Line ${e.line}`),null;const o=i.getPixel(t,n,0,r);return null===o?(console.error(`Invalid texture format for textureLoad. Line ${e.line}`),null):new Be(o,this.getTypeInfo('vec4f'))}return console.error(`Texture ${a} not found. Line ${e.line}`),null}return console.error(`Invalid texture argument for textureLoad. Line ${e.line}`),null}TextureNumLayers(e,t){const n=e.args[0];if(n instanceof de){const s=n.name,r=t.getVariableValue(s);return r instanceof Ue?new Ve(r.depthOrArrayLayers,this.getTypeInfo('u32')):(console.error(`Texture ${s} not found. Line ${e.line}`),null)}return console.error(`Invalid texture argument for textureNumLayers. Line ${e.line}`),null}TextureNumLevels(e,t){const n=e.args[0];if(n instanceof de){const s=n.name,r=t.getVariableValue(s);return r instanceof Ue?new Ve(r.mipLevelCount,this.getTypeInfo('u32')):(console.error(`Texture ${s} not found. Line ${e.line}`),null)}return console.error(`Invalid texture argument for textureNumLevels. Line ${e.line}`),null}TextureNumSamples(e,t){const n=e.args[0];if(n instanceof de){const s=n.name,r=t.getVariableValue(s);return r instanceof Ue?new Ve(r.sampleCount,this.getTypeInfo('u32')):(console.error(`Texture ${s} not found. Line ${e.line}`),null)}return console.error(`Invalid texture argument for textureNumSamples. Line ${e.line}`),null}TextureSample(e,t){return console.error('TODO: textureSample'),null}TextureSampleBias(e,t){return console.error('TODO: textureSampleBias'),null}TextureSampleCompare(e,t){return console.error('TODO: textureSampleCompare'),null}TextureSampleCompareLevel(e,t){return console.error('TODO: textureSampleCompareLevel'),null}TextureSampleGrad(e,t){return console.error('TODO: textureSampleGrad'),null}TextureSampleLevel(e,t){return console.error('TODO: textureSampleLevel'),null}TextureSampleBaseClampToEdge(e,t){return console.error('TODO: textureSampleBaseClampToEdge'),null}TextureStore(e,t){const n=e.args[0],s=this.exec.evalExpression(e.args[1],t),r=4===e.args.length?this.exec.evalExpression(e.args[2],t).value:0,a=4===e.args.length?this.exec.evalExpression(e.args[3],t).data:this.exec.evalExpression(e.args[2],t).data;if(4!==a.length)return console.error(`Invalid value argument for textureStore. Line ${e.line}`),null;if(!(s instanceof Be)||2!==s.data.length)return console.error(`Invalid UV argument for textureStore. Line ${e.line}`),null;if(n instanceof de){const i=n.name,o=t.getVariableValue(i);if(o instanceof Ue){const t=o.getMipLevelSize(0),n=Math.floor(s.data[0]),l=Math.floor(s.data[1]);return n<0||n>=t[0]||l<0||l>=t[1]?(console.error(`Texture ${i} out of bounds. Line ${e.line}`),null):(o.setPixel(n,l,0,r,Array.from(a)),null)}return console.error(`Texture ${i} not found. Line ${e.line}`),null}return console.error(`Invalid texture argument for textureStore. Line ${e.line}`),null}AtomicLoad(e,t){let n=e.args[0];n instanceof ve&&(n=n.right);const s=this.exec.getVariableName(n,t);return t.getVariable(s).value.getSubData(this.exec,n.postfix,t)}AtomicStore(e,t){let n=e.args[0];n instanceof ve&&(n=n.right);const s=this.exec.getVariableName(n,t),r=t.getVariable(s);let a=e.args[1];const i=this.exec.evalExpression(a,t),o=r.value.getSubData(this.exec,n.postfix,t);return o instanceof Ve&&i instanceof Ve&&(o.value=i.value),r.value instanceof Me&&r.value.setDataValue(this.exec,o,n.postfix,t),null}AtomicAdd(e,t){let n=e.args[0];n instanceof ve&&(n=n.right);const s=this.exec.getVariableName(n,t),r=t.getVariable(s);let a=e.args[1];const i=this.exec.evalExpression(a,t),o=r.value.getSubData(this.exec,n.postfix,t),l=new Ve(o.value,o.typeInfo);return o instanceof Ve&&i instanceof Ve&&(o.value+=i.value),r.value instanceof Me&&r.value.setDataValue(this.exec,o,n.postfix,t),l}AtomicSub(e,t){let n=e.args[0];n instanceof ve&&(n=n.right);const s=this.exec.getVariableName(n,t),r=t.getVariable(s);let a=e.args[1];const i=this.exec.evalExpression(a,t),o=r.value.getSubData(this.exec,n.postfix,t),l=new Ve(o.value,o.typeInfo);return o instanceof Ve&&i instanceof Ve&&(o.value-=i.value),r.value instanceof Me&&r.value.setDataValue(this.exec,o,n.postfix,t),l}AtomicMax(e,t){let n=e.args[0];n instanceof ve&&(n=n.right);const s=this.exec.getVariableName(n,t),r=t.getVariable(s);let a=e.args[1];const i=this.exec.evalExpression(a,t),o=r.value.getSubData(this.exec,n.postfix,t),l=new Ve(o.value,o.typeInfo);return o instanceof Ve&&i instanceof Ve&&(o.value=Math.max(o.value,i.value)),r.value instanceof Me&&r.value.setDataValue(this.exec,o,n.postfix,t),l}AtomicMin(e,t){let n=e.args[0];n instanceof ve&&(n=n.right);const s=this.exec.getVariableName(n,t),r=t.getVariable(s);let a=e.args[1];const i=this.exec.evalExpression(a,t),o=r.value.getSubData(this.exec,n.postfix,t),l=new Ve(o.value,o.typeInfo);return o instanceof Ve&&i instanceof Ve&&(o.value=Math.min(o.value,i.value)),r.value instanceof Me&&r.value.setDataValue(this.exec,o,n.postfix,t),l}AtomicAnd(e,t){let n=e.args[0];n instanceof ve&&(n=n.right);const s=this.exec.getVariableName(n,t),r=t.getVariable(s);let a=e.args[1];const i=this.exec.evalExpression(a,t),o=r.value.getSubData(this.exec,n.postfix,t),l=new Ve(o.value,o.typeInfo);return o instanceof Ve&&i instanceof Ve&&(o.value=o.value&i.value),r.value instanceof Me&&r.value.setDataValue(this.exec,o,n.postfix,t),l}AtomicOr(e,t){let n=e.args[0];n instanceof ve&&(n=n.right);const s=this.exec.getVariableName(n,t),r=t.getVariable(s);let a=e.args[1];const i=this.exec.evalExpression(a,t),o=r.value.getSubData(this.exec,n.postfix,t),l=new Ve(o.value,o.typeInfo);return o instanceof Ve&&i instanceof Ve&&(o.value=o.value|i.value),r.value instanceof Me&&r.value.setDataValue(this.exec,o,n.postfix,t),l}AtomicXor(e,t){let n=e.args[0];n instanceof ve&&(n=n.right);const s=this.exec.getVariableName(n,t),r=t.getVariable(s);let a=e.args[1];const i=this.exec.evalExpression(a,t),o=r.value.getSubData(this.exec,n.postfix,t),l=new Ve(o.value,o.typeInfo);return o instanceof Ve&&i instanceof Ve&&(o.value=o.value^i.value),r.value instanceof Me&&r.value.setDataValue(this.exec,o,n.postfix,t),l}AtomicExchange(e,t){let n=e.args[0];n instanceof ve&&(n=n.right);const s=this.exec.getVariableName(n,t),r=t.getVariable(s);let a=e.args[1];const i=this.exec.evalExpression(a,t),o=r.value.getSubData(this.exec,n.postfix,t),l=new Ve(o.value,o.typeInfo);return o instanceof Ve&&i instanceof Ve&&(o.value=i.value),r.value instanceof Me&&r.value.setDataValue(this.exec,o,n.postfix,t),l}AtomicCompareExchangeWeak(e,t){return console.error('TODO: atomicCompareExchangeWeak'),null}Pack4x8snorm(e,t){return console.error('TODO: pack4x8snorm'),null}Pack4x8unorm(e,t){return console.error('TODO: pack4x8unorm'),null}Pack4xI8(e,t){return console.error('TODO: pack4xI8'),null}Pack4xU8(e,t){return console.error('TODO: pack4xU8'),null}Pack4x8Clamp(e,t){return console.error('TODO: pack4x8Clamp'),null}Pack4xU8Clamp(e,t){return console.error('TODO: pack4xU8Clamp'),null}Pack2x16snorm(e,t){return console.error('TODO: pack2x16snorm'),null}Pack2x16unorm(e,t){return console.error('TODO: pack2x16unorm'),null}Pack2x16float(e,t){return console.error('TODO: pack2x16float'),null}Unpack4x8snorm(e,t){return console.error('TODO: unpack4x8snorm'),null}Unpack4x8unorm(e,t){return console.error('TODO: unpack4x8unorm'),null}Unpack4xI8(e,t){return console.error('TODO: unpack4xI8'),null}Unpack4xU8(e,t){return console.error('TODO: unpack4xU8'),null}Unpack2x16snorm(e,t){return console.error('TODO: unpack2x16snorm'),null}Unpack2x16unorm(e,t){return console.error('TODO: unpack2x16unorm'),null}Unpack2x16float(e,t){return console.error('TODO: unpack2x16float'),null}StorageBarrier(e,t){return null}TextureBarrier(e,t){return null}WorkgroupBarrier(e,t){return null}WorkgroupUniformLoad(e,t){return null}SubgroupAdd(e,t){return console.error('TODO: subgroupAdd'),null}SubgroupExclusiveAdd(e,t){return console.error('TODO: subgroupExclusiveAdd'),null}SubgroupInclusiveAdd(e,t){return console.error('TODO: subgroupInclusiveAdd'),null}SubgroupAll(e,t){return console.error('TODO: subgroupAll'),null}SubgroupAnd(e,t){return console.error('TODO: subgroupAnd'),null}SubgroupAny(e,t){return console.error('TODO: subgroupAny'),null}SubgroupBallot(e,t){return console.error('TODO: subgroupBallot'),null}SubgroupBroadcast(e,t){return console.error('TODO: subgroupBroadcast'),null}SubgroupBroadcastFirst(e,t){return console.error('TODO: subgroupBroadcastFirst'),null}SubgroupElect(e,t){return console.error('TODO: subgroupElect'),null}SubgroupMax(e,t){return console.error('TODO: subgroupMax'),null}SubgroupMin(e,t){return console.error('TODO: subgroupMin'),null}SubgroupMul(e,t){return console.error('TODO: subgroupMul'),null}SubgroupExclusiveMul(e,t){return console.error('TODO: subgroupExclusiveMul'),null}SubgroupInclusiveMul(e,t){return console.error('TODO: subgroupInclusiveMul'),null}SubgroupOr(e,t){return console.error('TODO: subgroupOr'),null}SubgroupShuffle(e,t){return console.error('TODO: subgroupShuffle'),null}SubgroupShuffleDown(e,t){return console.error('TODO: subgroupShuffleDown'),null}SubgroupShuffleUp(e,t){return console.error('TODO: subgroupShuffleUp'),null}SubgroupShuffleXor(e,t){return console.error('TODO: subgroupShuffleXor'),null}SubgroupXor(e,t){return console.error('TODO: subgroupXor'),null}QuadBroadcast(e,t){return console.error('TODO: quadBroadcast'),null}QuadSwapDiagonal(e,t){return console.error('TODO: quadSwapDiagonal'),null}QuadSwapX(e,t){return console.error('TODO: quadSwapX'),null}QuadSwapY(e,t){return console.error('TODO: quadSwapY'),null}}const ct={vec2:2,vec2f:2,vec2i:2,vec2u:2,vec2b:2,vec2h:2,vec3:3,vec3f:3,vec3i:3,vec3u:3,vec3b:3,vec3h:3,vec4:4,vec4f:4,vec4i:4,vec4u:4,vec4b:4,vec4h:4},ut={mat2x2:[2,2,4],mat2x2f:[2,2,4],mat2x2h:[2,2,4],mat2x3:[2,3,6],mat2x3f:[2,3,6],mat2x3h:[2,3,6],mat2x4:[2,4,8],mat2x4f:[2,4,8],mat2x4h:[2,4,8],mat3x2:[3,2,6],mat3x2f:[3,2,6],mat3x2h:[3,2,6],mat3x3:[3,3,9],mat3x3f:[3,3,9],mat3x3h:[3,3,9],mat3x4:[3,4,12],mat3x4f:[3,4,12],mat3x4h:[3,4,12],mat4x2:[4,2,8],mat4x2f:[4,2,8],mat4x2h:[4,2,8],mat4x3:[4,3,12],mat4x3f:[4,3,12],mat4x3h:[4,3,12],mat4x4:[4,4,16],mat4x4f:[4,4,16],mat4x4h:[4,4,16]};class ht extends ot{constructor(e,t){var n;super(),this.ast=null!=e?e:[],this.reflection=new st,this.reflection.updateAST(this.ast),this.context=null!==(n=null==t?void 0:t.clone())&&void 0!==n?n:new it,this.builtins=new lt(this),this.typeInfo={bool:this.getTypeInfo(se.bool),i32:this.getTypeInfo(se.i32),u32:this.getTypeInfo(se.u32),f32:this.getTypeInfo(se.f32),f16:this.getTypeInfo(se.f16),vec2f:this.getTypeInfo(ie.vec2f),vec2u:this.getTypeInfo(ie.vec2u),vec2i:this.getTypeInfo(ie.vec2i),vec2h:this.getTypeInfo(ie.vec2h),vec3f:this.getTypeInfo(ie.vec3f),vec3u:this.getTypeInfo(ie.vec3u),vec3i:this.getTypeInfo(ie.vec3i),vec3h:this.getTypeInfo(ie.vec3h),vec4f:this.getTypeInfo(ie.vec4f),vec4u:this.getTypeInfo(ie.vec4u),vec4i:this.getTypeInfo(ie.vec4i),vec4h:this.getTypeInfo(ie.vec4h),mat2x2f:this.getTypeInfo(ie.mat2x2f),mat2x3f:this.getTypeInfo(ie.mat2x3f),mat2x4f:this.getTypeInfo(ie.mat2x4f),mat3x2f:this.getTypeInfo(ie.mat3x2f),mat3x3f:this.getTypeInfo(ie.mat3x3f),mat3x4f:this.getTypeInfo(ie.mat3x4f),mat4x2f:this.getTypeInfo(ie.mat4x2f),mat4x3f:this.getTypeInfo(ie.mat4x3f),mat4x4f:this.getTypeInfo(ie.mat4x4f)}}getVariableValue(e){var t,n;const r=null!==(n=null===(t=this.context.getVariable(e))||void 0===t?void 0:t.value)&&void 0!==n?n:null;if(null===r)return null;if(r instanceof Ve)return r.value;if(r instanceof Be)return Array.from(r.data);if(r instanceof Fe)return Array.from(r.data);if(r instanceof Me&&r.typeInfo instanceof s){if('u32'===r.typeInfo.format.name)return Array.from(new Uint32Array(r.buffer,r.offset,r.typeInfo.count));if('i32'===r.typeInfo.format.name)return Array.from(new Int32Array(r.buffer,r.offset,r.typeInfo.count));if('f32'===r.typeInfo.format.name)return Array.from(new Float32Array(r.buffer,r.offset,r.typeInfo.count))}return console.error(`Unsupported return variable type ${r.typeInfo.name}`),null}execute(e){(e=null!=e?e:{}).constants&&this._setOverrides(e.constants,this.context),this._execStatements(this.ast,this.context)}dispatchWorkgroups(e,t,n,s){const r=this.context.clone();(s=null!=s?s:{}).constants&&this._setOverrides(s.constants,r),this._execStatements(this.ast,r);const a=r.getFunction(e);if(!a)return void console.error(`Function ${e} not found`);if('number'==typeof t)t=[t,1,1];else{if(0===t.length)return void console.error('Invalid dispatch count');1===t.length?t=[t[0],1,1]:2===t.length?t=[t[0],t[1],1]:t.length>3&&(t=[t[0],t[1],t[2]])}const i=t[0],o=t[1],l=t[2],c=this.getTypeInfo('vec3u');r.setVariable('@num_workgroups',new Be(t,c));for(const e in n)for(const t in n[e]){const s=n[e][t];r.variables.forEach((n=>{var r;const a=n.node;if(null==a?void 0:a.attributes){let i=null,o=null;for(const e of a.attributes)'binding'===e.name?i=e.value:'group'===e.name&&(o=e.value);if(t==i&&e==o)if(void 0!==s.texture&&void 0!==s.descriptor){const e=new Ue(s.texture,this.getTypeInfo(a.type),s.descriptor,null!==(r=s.texture.view)&&void 0!==r?r:null);n.value=e}else void 0!==s.uniform?n.value=new Me(s.uniform,this.getTypeInfo(a.type)):n.value=new Me(s,this.getTypeInfo(a.type))}}))}for(let e=0;e<l;++e)for(let t=0;t<o;++t)for(let n=0;n<i;++n)r.setVariable('@workgroup_id',new Be([n,t,e],this.getTypeInfo('vec3u'))),this._dispatchWorkgroup(a,[n,t,e],r)}execStatement(e,t){if(e instanceof Z)return this.evalExpression(e.value,t);if(e instanceof te){if(e.condition){const n=this.evalExpression(e.condition,t);if(!(n instanceof Ve))throw new Error('Invalid break-if condition');if(!n.value)return null}return ht._breakObj}if(e instanceof ne)return ht._continueObj;if(e instanceof F)this._let(e,t);else if(e instanceof O)this._var(e,t);else if(e instanceof M)this._const(e,t);else if(e instanceof L)this._function(e,t);else{if(e instanceof j)return this._if(e,t);if(e instanceof X)return this._switch(e,t);if(e instanceof V)return this._for(e,t);if(e instanceof D)return this._while(e,t);if(e instanceof G)return this._loop(e,t);if(e instanceof N){const n=t.clone();return n.currentFunctionName=t.currentFunctionName,this._execStatements(e.body,n)}if(e instanceof z)this._assign(e,t);else if(e instanceof H)this._increment(e,t);else{if(e instanceof ae)return null;if(e instanceof B){const n=e.name;null===t.getVariable(n)&&t.setVariable(n,new Ve(0,this.getTypeInfo('u32')))}else if(e instanceof R)this._call(e,t);else{if(e instanceof K)return null;if(e instanceof J)return null;console.error('Invalid statement type.',e,`Line ${e.line}`)}}}return null}evalExpression(e,t){return e instanceof we?this._evalBinaryOp(e,t):e instanceof _e?this._evalLiteral(e,t):e instanceof de?this._evalVariable(e,t):e instanceof pe?this._evalCall(e,t):e instanceof fe?this._evalCreate(e,t):e instanceof me?this._evalConst(e,t):e instanceof ge?this._evalBitcast(e,t):e instanceof ve?this._evalUnaryOp(e,t):(console.error('Invalid expression type',e,`Line ${e.line}`),null)}getTypeInfo(e){var t;if(e instanceof se){const t=this.reflection.getTypeInfo(e);if(null!==t)return t}let n=null!==(t=this.typeInfo[e])&&void 0!==t?t:null;return null!==n||(n=this.reflection.getTypeInfoByName(e)),n}_setOverrides(e,t){for(const n in e){const s=e[n],r=this.reflection.getOverrideInfo(n);null!==r?(null===r.type&&(r.type=this.getTypeInfo('u32')),'u32'===r.type.name||'i32'===r.type.name||'f32'===r.type.name||'f16'===r.type.name?t.setVariable(n,new Ve(s,r.type)):'bool'===r.type.name?t.setVariable(n,new Ve(s?1:0,r.type)):'vec2'===r.type.name||'vec3'===r.type.name||'vec4'===r.type.name||'vec2f'===r.type.name||'vec3f'===r.type.name||'vec4f'===r.type.name||'vec2i'===r.type.name||'vec3i'===r.type.name||'vec4i'===r.type.name||'vec2u'===r.type.name||'vec3u'===r.type.name||'vec4u'===r.type.name||'vec2h'===r.type.name||'vec3h'===r.type.name||'vec4h'===r.type.name?t.setVariable(n,new Be(s,r.type)):console.error(`Invalid constant type for ${n}`)):console.error(`Override ${n} does not exist in the shader.`)}}_dispatchWorkgroup(e,t,n){const s=[1,1,1];for(const t of e.node.attributes)if('workgroup_size'===t.name){if(t.value.length>0){const e=n.getVariableValue(t.value[0]);s[0]=e instanceof Ve?e.value:parseInt(t.value[0])}if(t.value.length>1){const e=n.getVariableValue(t.value[1]);s[1]=e instanceof Ve?e.value:parseInt(t.value[1])}if(t.value.length>2){const e=n.getVariableValue(t.value[2]);s[2]=e instanceof Ve?e.value:parseInt(t.value[2])}}const r=this.getTypeInfo('vec3u'),a=this.getTypeInfo('u32');n.setVariable('@workgroup_size',new Be(s,r));const i=s[0],o=s[1],l=s[2];for(let c=0,u=0;c<l;++c)for(let l=0;l<o;++l)for(let o=0;o<i;++o,++u){const i=[o,l,c],h=[o+t[0]*s[0],l+t[1]*s[1],c+t[2]*s[2]];n.setVariable('@local_invocation_id',new Be(i,r)),n.setVariable('@global_invocation_id',new Be(h,r)),n.setVariable('@local_invocation_index',new Ve(u,a)),this._dispatchExec(e,n)}}_dispatchExec(e,t){for(const n of e.node.args)for(const e of n.attributes)if('builtin'===e.name){const s=`@${e.value}`,r=t.getVariable(s);void 0!==r&&t.variables.set(n.name,r)}this._execStatements(e.node.body,t)}getVariableName(e,t){for(;e instanceof ve;)e=e.right;return e instanceof de?e.name:(console.error('Unknown variable type',e,'Line',e.line),null)}_execStatements(e,t){for(const n of e){if(n instanceof Array){const e=t.clone(),s=this._execStatements(n,e);if(s)return s;continue}const e=this.execStatement(n,t);if(e)return e}return null}_call(e,t){const n=t.clone();n.currentFunctionName=e.name;const s=t.getFunction(e.name);if(s){for(let t=0;t<s.node.args.length;++t){const r=s.node.args[t],a=this.evalExpression(e.args[t],n);n.setVariable(r.name,a,r)}this._execStatements(s.node.body,n)}else if(e.isBuiltin)this._callBuiltinFunction(e,n);else{this.getTypeInfo(e.name)&&this._evalCreate(e,t)}}_increment(e,t){const n=this.getVariableName(e.variable,t),s=t.getVariable(n);s?'++'===e.operator?s.value instanceof Ve?s.value.value++:console.error(`Variable ${n} is not a scalar. Line ${e.line}`):'--'===e.operator?s.value instanceof Ve?s.value.value--:console.error(`Variable ${n} is not a scalar. Line ${e.line}`):console.error(`Unknown increment operator ${e.operator}. Line ${e.line}`):console.error(`Variable ${n} not found. Line ${e.line}`)}_getVariableData(e,t){if(e instanceof de){const n=this.getVariableName(e,t),s=t.getVariable(n);return null===s?(console.error(`Variable ${n} not found. Line ${e.line}`),null):s.value.getSubData(this,e.postfix,t)}if(e instanceof ve){if('*'===e.operator){const n=this._getVariableData(e.right,t);return n instanceof Ne?n.reference.getSubData(this,e.postfix,t):(console.error(`Variable ${e.right} is not a pointer. Line ${e.line}`),null)}if('&'===e.operator){const n=this._getVariableData(e.right,t);return new Ne(n)}}return null}_assign(e,t){let n=null,s='<var>',r=null;if(e.variable instanceof ve){const n=this._getVariableData(e.variable,t),s=this.evalExpression(e.value,t),r=e.operator;if('='===r){if(n instanceof Ve||n instanceof Be||n instanceof Fe){if(s instanceof Ve||s instanceof Be||s instanceof Fe&&n.data.length===s.data.length)return void n.data.set(s.data);console.error(`Invalid assignment. Line ${e.line}`)}else if(n instanceof Me&&s instanceof Me&&n.buffer.byteLength-n.offset>=s.buffer.byteLength-s.offset)return void(n.buffer.byteLength%4==0?new Uint32Array(n.buffer,n.offset,n.typeInfo.size/4).set(new Uint32Array(s.buffer,s.offset,s.typeInfo.size/4)):new Uint8Array(n.buffer,n.offset,n.typeInfo.size).set(new Uint8Array(s.buffer,s.offset,s.typeInfo.size)));return console.error(`Invalid assignment. Line ${e.line}`),null}if('+='===r)return n instanceof Ve||n instanceof Be||n instanceof Fe?s instanceof Ve||s instanceof Be||s instanceof Fe?void n.data.set(s.data.map(((e,t)=>n.data[t]+e))):void console.error(`Invalid assignment . Line ${e.line}`):void console.error(`Invalid assignment. Line ${e.line}`);if('-='===r)return(n instanceof Ve||n instanceof Be||n instanceof Fe)&&(s instanceof Ve||s instanceof Be||s instanceof Fe)?void n.data.set(s.data.map(((e,t)=>n.data[t]-e))):void console.error(`Invalid assignment. Line ${e.line}`)}if(e.variable instanceof ve){if('*'===e.variable.operator){s=this.getVariableName(e.variable.right,t);const r=t.getVariable(s);if(!(r&&r.value instanceof Ne))return void console.error(`Variable ${s} is not a pointer. Line ${e.line}`);n=r.value.reference;let a=e.variable.postfix;if(!a){let t=e.variable.right;for(;t instanceof ve;){if(t.postfix){a=t.postfix;break}t=t.right}}a&&(n=n.getSubData(this,a,t))}}else{r=e.variable.postfix,s=this.getVariableName(e.variable,t);const a=t.getVariable(s);if(null===a)return void console.error(`Variable ${s} not found. Line ${e.line}`);n=a.value}if(n instanceof Ne&&(n=n.reference),null===n)return void console.error(`Variable ${s} not found. Line ${e.line}`);const a=this.evalExpression(e.value,t),i=e.operator;if('='===i)if(n instanceof Me)n.setDataValue(this,a,r,t);else if(r){if(!(n instanceof Be||n instanceof Fe))return void console.error(`Variable ${s} is not a vector or matrix. Line ${e.line}`);if(r instanceof ye){const i=this.evalExpression(r.index,t).value;if(n instanceof Be){if(!(a instanceof Ve))return void console.error(`Invalid assignment to ${s}. Line ${e.line}`);n.data[i]=a.value}else{if(!(n instanceof Fe))return void console.error(`Invalid assignment to ${s}. Line ${e.line}`);{const i=this.evalExpression(r.index,t).value;if(i<0)return void console.error(`Invalid assignment to ${s}. Line ${e.line}`);if(!(a instanceof Be))return void console.error(`Invalid assignment to ${s}. Line ${e.line}`);{const t=n.typeInfo.getTypeName();if('mat2x2'===t||'mat2x2f'===t||'mat2x2h'===t){if(!(i<2&&2===a.data.length))return void console.error(`Invalid assignment to ${s}. Line ${e.line}`);n.data[2*i]=a.data[0],n.data[2*i+1]=a.data[1]}else if('mat2x3'===t||'mat2x3f'===t||'mat2x3h'===t){if(!(i<2&&3===a.data.length))return void console.error(`Invalid assignment to ${s}. Line ${e.line}`);n.data[3*i]=a.data[0],n.data[3*i+1]=a.data[1],n.data[3*i+2]=a.data[2]}else if('mat2x4'===t||'mat2x4f'===t||'mat2x4h'===t){if(!(i<2&&4===a.data.length))return void console.error(`Invalid assignment to ${s}. Line ${e.line}`);n.data[4*i]=a.data[0],n.data[4*i+1]=a.data[1],n.data[4*i+2]=a.data[2],n.data[4*i+3]=a.data[3]}else if('mat3x2'===t||'mat3x2f'===t||'mat3x2h'===t){if(!(i<3&&2===a.data.length))return void console.error(`Invalid assignment to ${s}. Line ${e.line}`);n.data[2*i]=a.data[0],n.data[2*i+1]=a.data[1]}else if('mat3x3'===t||'mat3x3f'===t||'mat3x3h'===t){if(!(i<3&&3===a.data.length))return void console.error(`Invalid assignment to ${s}. Line ${e.line}`);n.data[3*i]=a.data[0],n.data[3*i+1]=a.data[1],n.data[3*i+2]=a.data[2]}else if('mat3x4'===t||'mat3x4f'===t||'mat3x4h'===t){if(!(i<3&&4===a.data.length))return void console.error(`Invalid assignment to ${s}. Line ${e.line}`);n.data[4*i]=a.data[0],n.data[4*i+1]=a.data[1],n.data[4*i+2]=a.data[2],n.data[4*i+3]=a.data[3]}else if('mat4x2'===t||'mat4x2f'===t||'mat4x2h'===t){if(!(i<4&&2===a.data.length))return void console.error(`Invalid assignment to ${s}. Line ${e.line}`);n.data[2*i]=a.data[0],n.data[2*i+1]=a.data[1]}else if('mat4x3'===t||'mat4x3f'===t||'mat4x3h'===t){if(!(i<4&&3===a.data.length))return void console.error(`Invalid assignment to ${s}. Line ${e.line}`);n.data[3*i]=a.data[0],n.data[3*i+1]=a.data[1],n.data[3*i+2]=a.data[2]}else{if('mat4x4'!==t&&'mat4x4f'!==t&&'mat4x4h'!==t)return void console.error(`Invalid assignment to ${s}. Line ${e.line}`);if(!(i<4&&4===a.data.length))return void console.error(`Invalid assignment to ${s}. Line ${e.line}`);n.data[4*i]=a.data[0],n.data[4*i+1]=a.data[1],n.data[4*i+2]=a.data[2],n.data[4*i+3]=a.data[3]}}}}}else if(r instanceof he){const t=r.value;if(!(n instanceof Be))return void console.error(`Invalid assignment to ${t}. Variable ${s} is not a vector. Line ${e.line}`);if(a instanceof Ve){if(t.length>1)return void console.error(`Invalid assignment to ${t} for variable ${s}. Line ${e.line}`);if('x'===t)n.data[0]=a.value;else if('y'===t){if(n.data.length<2)return void console.error(`Invalid assignment to ${t} for variable ${s}. Line ${e.line}`);n.data[1]=a.value}else if('z'===t){if(n.data.length<3)return void console.error(`Invalid assignment to ${t} for variable ${s}. Line ${e.line}`);n.data[2]=a.value}else if('w'===t){if(n.data.length<4)return void console.error(`Invalid assignment to ${t} for variable ${s}. Line ${e.line}`);n.data[3]=a.value}}else{if(!(a instanceof Be))return void console.error(`Invalid assignment to ${s}. Line ${e.line}`);if(t.length!==a.data.length)return void console.error(`Invalid assignment to ${t} for variable ${s}. Line ${e.line}`);for(let r=0;r<t.length;++r){const i=t[r];if('x'===i||'r'===i)n.data[0]=a.data[r];else if('y'===i||'g'===i){if(a.data.length<2)return void console.error(`Invalid assignment to ${i} for variable ${s}. Line ${e.line}`);n.data[1]=a.data[r]}else if('z'===i||'b'===i){if(a.data.length<3)return void console.error(`Invalid assignment to ${i} for variable ${s}. Line ${e.line}`);n.data[2]=a.data[r]}else{if('w'!==i&&'a'!==i)return void console.error(`Invalid assignment to ${i} for variable ${s}. Line ${e.line}`);if(a.data.length<4)return void console.error(`Invalid assignment to ${i} for variable ${s}. Line ${e.line}`);n.data[3]=a.data[r]}}}}}else n instanceof Ve&&a instanceof Ve?n.value=a.value:n instanceof Be&&a instanceof Be||n instanceof Fe&&a instanceof Fe?n.data.set(a.data):console.error(`Invalid assignment to ${s}. Line ${e.line}`);else{const s=n.getSubData(this,r,t);if(s instanceof Be&&a instanceof Ve){const t=s.data,n=a.value;if('+='===i)for(let e=0;e<t.length;++e)t[e]+=n;else if('-='===i)for(let e=0;e<t.length;++e)t[e]-=n;else if('*='===i)for(let e=0;e<t.length;++e)t[e]*=n;else if('/='===i)for(let e=0;e<t.length;++e)t[e]/=n;else if('%='===i)for(let e=0;e<t.length;++e)t[e]%=n;else if('&='===i)for(let e=0;e<t.length;++e)t[e]&=n;else if('|='===i)for(let e=0;e<t.length;++e)t[e]|=n;else if('^='===i)for(let e=0;e<t.length;++e)t[e]^=n;else if('<<='===i)for(let e=0;e<t.length;++e)t[e]<<=n;else if('>>='===i)for(let e=0;e<t.length;++e)t[e]>>=n;else console.error(`Invalid operator ${i}. Line ${e.line}`)}else if(s instanceof Be&&a instanceof Be){const t=s.data,n=a.data;if(t.length!==n.length)return void console.error(`Vector length mismatch. Line ${e.line}`);if('+='===i)for(let e=0;e<t.length;++e)t[e]+=n[e];else if('-='===i)for(let e=0;e<t.length;++e)t[e]-=n[e];else if('*='===i)for(let e=0;e<t.length;++e)t[e]*=n[e];else if('/='===i)for(let e=0;e<t.length;++e)t[e]/=n[e];else if('%='===i)for(let e=0;e<t.length;++e)t[e]%=n[e];else if('&='===i)for(let e=0;e<t.length;++e)t[e]&=n[e];else if('|='===i)for(let e=0;e<t.length;++e)t[e]|=n[e];else if('^='===i)for(let e=0;e<t.length;++e)t[e]^=n[e];else if('<<='===i)for(let e=0;e<t.length;++e)t[e]<<=n[e];else if('>>='===i)for(let e=0;e<t.length;++e)t[e]>>=n[e];else console.error(`Invalid operator ${i}. Line ${e.line}`)}else{if(!(s instanceof Ve&&a instanceof Ve))return void console.error(`Invalid type for ${e.operator} operator. Line ${e.line}`);'+='===i?s.value+=a.value:'-='===i?s.value-=a.value:'*='===i?s.value*=a.value:'/='===i?s.value/=a.value:'%='===i?s.value%=a.value:'&='===i?s.value&=a.value:'|='===i?s.value|=a.value:'^='===i?s.value^=a.value:'<<='===i?s.value<<=a.value:'>>='===i?s.value>>=a.value:console.error(`Invalid operator ${i}. Line ${e.line}`)}n instanceof Me&&n.setDataValue(this,s,r,t)}}_function(e,t){const n=new at(e);t.functions.set(e.name,n)}_const(e,t){let n=null;null!==e.value&&(n=this.evalExpression(e.value,t)),t.createVariable(e.name,n,e)}_let(e,t){let n=null;if(null!==e.value){if(n=this.evalExpression(e.value,t),null===n)return void console.error(`Invalid value for variable ${e.name}. Line ${e.line}`);e.value instanceof ve||(n=n.clone())}else{const s=e.type.name;if('f32'===s||'i32'===s||'u32'===s||'bool'===s||'f16'===s||'vec2'===s||'vec3'===s||'vec4'===s||'vec2f'===s||'vec3f'===s||'vec4f'===s||'vec2i'===s||'vec3i'===s||'vec4i'===s||'vec2u'===s||'vec3u'===s||'vec4u'===s||'vec2h'===s||'vec3h'===s||'vec4h'===s||'vec2b'===s||'vec3b'===s||'vec4b'===s||'mat2x2'===s||'mat2x3'===s||'mat2x4'===s||'mat3x2'===s||'mat3x3'===s||'mat3x4'===s||'mat4x2'===s||'mat4x3'===s||'mat4x4'===s||'mat2x2f'===s||'mat2x3f'===s||'mat2x4f'===s||'mat3x2f'===s||'mat3x3f'===s||'mat3x4f'===s||'mat4x2f'===s||'mat4x3f'===s||'mat4x4f'===s||'mat2x2h'===s||'mat2x3h'===s||'mat2x4h'===s||'mat3x2h'===s||'mat3x3h'===s||'mat3x4h'===s||'mat4x2h'===s||'mat4x3h'===s||'mat4x4h'===s||'array'===s){const s=new fe(e.type,[]);n=this._evalCreate(s,t)}}t.createVariable(e.name,n,e)}_var(e,t){let n=null;if(null!==e.value){if(n=this.evalExpression(e.value,t),null===n)return void console.error(`Invalid value for variable ${e.name}. Line ${e.line}`);e.value instanceof ve||(n=n.clone())}else{if(null===e.type)return void console.error(`Variable ${e.name} has no type. Line ${e.line}`);const s=e.type.name;if('f32'===s||'i32'===s||'u32'===s||'bool'===s||'f16'===s||'vec2'===s||'vec3'===s||'vec4'===s||'vec2f'===s||'vec3f'===s||'vec4f'===s||'vec2i'===s||'vec3i'===s||'vec4i'===s||'vec2u'===s||'vec3u'===s||'vec4u'===s||'vec2h'===s||'vec3h'===s||'vec4h'===s||'vec2b'===s||'vec3b'===s||'vec4b'===s||'mat2x2'===s||'mat2x3'===s||'mat2x4'===s||'mat3x2'===s||'mat3x3'===s||'mat3x4'===s||'mat4x2'===s||'mat4x3'===s||'mat4x4'===s||'mat2x2f'===s||'mat2x3f'===s||'mat2x4f'===s||'mat3x2f'===s||'mat3x3f'===s||'mat3x4f'===s||'mat4x2f'===s||'mat4x3f'===s||'mat4x4f'===s||'mat2x2h'===s||'mat2x3h'===s||'mat2x4h'===s||'mat3x2h'===s||'mat3x3h'===s||'mat3x4h'===s||'mat4x2h'===s||'mat4x3h'===s||'mat4x4h'===s||e.type instanceof le||e.type instanceof ae||e.type instanceof ie){const s=new fe(e.type,[]);n=this._evalCreate(s,t)}}t.createVariable(e.name,n,e)}_switch(e,t){t=t.clone();const n=this.evalExpression(e.condition,t);if(!(n instanceof Ve))return console.error(`Invalid if condition. Line ${e.line}`),null;let s=null;for(const r of e.cases)if(r instanceof Te)for(const a of r.selectors){if(a instanceof Ie){s=r;continue}const i=this.evalExpression(a,t);if(!(i instanceof Ve))return console.error(`Invalid case selector. Line ${e.line}`),null;if(i.value===n.value)return this._execStatements(r.body,t)}else r instanceof Se&&(s=r);return s?this._execStatements(s.body,t):null}_if(e,t){t=t.clone();const n=this.evalExpression(e.condition,t);if(!(n instanceof Ve))return console.error(`Invalid if condition. Line ${e.line}`),null;if(n.value)return this._execStatements(e.body,t);for(const n of e.elseif){const s=this.evalExpression(n.condition,t);if(!(s instanceof Ve))return console.error(`Invalid if condition. Line ${e.line}`),null;if(s.value)return this._execStatements(n.body,t)}return e.else?this._execStatements(e.else,t):null}_getScalarValue(e){return e instanceof Ve?e.value:(console.error('Expected scalar value.',e),0)}_for(e,t){for(t=t.clone(),this.execStatement(e.init,t);this._getScalarValue(this.evalExpression(e.condition,t));){const n=this._execStatements(e.body,t);if(n===ht._breakObj)break;if(null!==n&&n!==ht._continueObj)return n;this.execStatement(e.increment,t)}return null}_loop(e,t){for(t=t.clone();;){const n=this._execStatements(e.body,t);if(n===ht._breakObj)break;if(n===ht._continueObj){if(e.continuing){if(this._execStatements(e.continuing.body,t)===ht._breakObj)break}}else if(null!==n)return n}return null}_while(e,t){for(t=t.clone();this._getScalarValue(this.evalExpression(e.condition,t));){const n=this._execStatements(e.body,t);if(n===ht._breakObj)break;if(n!==ht._continueObj&&null!==n)return n}return null}_evalBitcast(e,t){const n=this.evalExpression(e.value,t),s=e.type;if(n instanceof Ve){const e=et(n.value,n.typeInfo.name,s.name);return new Ve(e,this.getTypeInfo(s))}if(n instanceof Be){const t=n.typeInfo.getTypeName();let r='';if(t.endsWith('f'))r='f32';else if(t.endsWith('i'))r='i32';else if(t.endsWith('u'))r='u32';else if(t.endsWith('b'))r='bool';else{if(!t.endsWith('h'))return console.error(`Unknown vector type ${t}. Line ${e.line}`),null;r='f16'}const a=s.getTypeName();let i='';if(a.endsWith('f'))i='f32';else if(a.endsWith('i'))i='i32';else if(a.endsWith('u'))i='u32';else if(a.endsWith('b'))i='bool';else{if(!a.endsWith('h'))return console.error(`Unknown vector type ${i}. Line ${e.line}`),null;i='f16'}const o=function(e,t,n){if(t===n)return e;const s=new Array(e.length);for(let r=0;r<e.length;r++)s[r]=et(e[r],t,n);return s}(Array.from(n.data),r,i);return new Be(o,this.getTypeInfo(s))}return console.error(`TODO: bitcast for ${n.typeInfo.name}. Line ${e.line}`),null}_evalConst(e,t){return t.getVariableValue(e.name).clone().getSubData(this,e.postfix,t)}_evalCreate(e,t){var r;if(e instanceof fe){if(null===e.type)return De.void;switch(e.type.getTypeName()){case'bool':case'i32':case'u32':case'f32':case'f16':return this._callConstructorValue(e,t);case'vec2':case'vec3':case'vec4':case'vec2f':case'vec3f':case'vec4f':case'vec2h':case'vec3h':case'vec4h':case'vec2i':case'vec3i':case'vec4i':case'vec2u':case'vec3u':case'vec4u':case'vec2b':case'vec3b':case'vec4b':return this._callConstructorVec(e,t);case'mat2x2':case'mat2x2f':case'mat2x2h':case'mat2x3':case'mat2x3f':case'mat2x3h':case'mat2x4':case'mat2x4f':case'mat2x4h':case'mat3x2':case'mat3x2f':case'mat3x2h':case'mat3x3':case'mat3x3f':case'mat3x3h':case'mat3x4':case'mat3x4f':case'mat3x4h':case'mat4x2':case'mat4x2f':case'mat4x2h':case'mat4x3':case'mat4x3f':case'mat4x3h':case'mat4x4':case'mat4x4f':case'mat4x4h':return this._callConstructorMatrix(e,t)}}const a=e instanceof fe?e.type.name:e.name,i=e instanceof fe?this.getTypeInfo(e.type):this.getTypeInfo(e.name);if(null===i)return console.error(`Unknown type ${a}. Line ${e.line}`),null;if(0===i.size)return null;const o=new Me(new ArrayBuffer(i.size),i,0);if(i instanceof n){if(e.args)for(let n=0;n<e.args.length;++n){const s=i.members[n],r=e.args[n],a=this.evalExpression(r,t);o.setData(this,a,s.type,s.offset,t)}}else if(i instanceof s){let n=0;if(e.args)for(let s=0;s<e.args.length;++s){const a=e.args[s],l=this.evalExpression(a,t);null===i.format&&('x32'===(null===(r=l.typeInfo)||void 0===r?void 0:r.name)?i.format=this.getTypeInfo('i32'):i.format=l.typeInfo),o.setData(this,l,i.format,n,t),n+=i.stride}}else console.error(`Unknown type \"${a}\". Line ${e.line}`);return e instanceof fe?o.getSubData(this,e.postfix,t):o}_evalLiteral(e,t){const n=this.getTypeInfo(e.type),s=n.name;if('x32'===s||'u32'===s||'f32'===s||'f16'===s||'i32'===s||'bool'===s){return new Ve(e.scalarValue,n)}return'vec2'===s||'vec3'===s||'vec4'===s||'vec2f'===s||'vec3f'===s||'vec4f'===s||'vec2h'===s||'vec3h'===s||'vec4h'===s||'vec2i'===s||'vec3i'===s||'vec4i'===s||'vec2u'===s||'vec3u'===s||'vec4u'===s?this._callConstructorVec(e,t):'mat2x2'===s||'mat2x3'===s||'mat2x4'===s||'mat3x2'===s||'mat3x3'===s||'mat3x4'===s||'mat4x2'===s||'mat4x3'===s||'mat4x4'===s||'mat2x2f'===s||'mat2x3f'===s||'mat2x4f'===s||'mat3x2f'===s||'mat3x3f'===s||'mat3x4f'===s||'mat4x2f'===s||'mat4x3f'===s||'mat4x4f'===s||'mat2x2h'===s||'mat2x3h'===s||'mat2x4h'===s||'mat3x2h'===s||'mat3x3h'===s||'mat3x4h'===s||'mat4x2h'===s||'mat4x3h'===s||'mat4x4h'===s?this._callConstructorMatrix(e,t):e.value}_evalVariable(e,t){const n=t.getVariableValue(e.name);return null===n?n:n.getSubData(this,e.postfix,t)}_maxFormatTypeInfo(e){let t=e[0];if('f32'===t.name)return t;for(let n=1;n<e.length;++n){const s=ht._priority.get(t.name);ht._priority.get(e[n].name)<s&&(t=e[n])}return'x32'===t.name?this.getTypeInfo('i32'):t}_evalUnaryOp(e,t){const n=this.evalExpression(e.right,t);if('&'===e.operator)return new Ne(n);if('*'===e.operator)return n instanceof Ne?n.reference.getSubData(this,e.postfix,t):(console.error(`Invalid dereference. Line ${e.line}`),null);const s=n instanceof Ve?n.value:n instanceof Be?Array.from(n.data):null;switch(e.operator){case'+':{if(ze(s)){const e=s.map(((e,t)=>+e));return new Be(e,n.typeInfo)}const e=s,t=this._maxFormatTypeInfo([n.typeInfo,n.typeInfo]);return new Ve(+e,t)}case'-':{if(ze(s)){const e=s.map(((e,t)=>-e));return new Be(e,n.typeInfo)}const e=s,t=this._maxFormatTypeInfo([n.typeInfo,n.typeInfo]);return new Ve(-e,t)}case'!':{if(ze(s)){const e=s.map(((e,t)=>e?0:1));return new Be(e,n.typeInfo)}const e=s,t=this._maxFormatTypeInfo([n.typeInfo,n.typeInfo]);return new Ve(e?0:1,t)}case'~':{if(ze(s)){const e=s.map(((e,t)=>~e));return new Be(e,n.typeInfo)}const e=s,t=this._maxFormatTypeInfo([n.typeInfo,n.typeInfo]);return new Ve(~e,t)}}return console.error(`Invalid unary operator ${e.operator}. Line ${e.line}`),null}_evalBinaryOp(e,t){const n=this.evalExpression(e.left,t),s=this.evalExpression(e.right,t),r=n instanceof Ve?n.value:n instanceof Be||n instanceof Fe?Array.from(n.data):null,a=s instanceof Ve?s.value:s instanceof Be||s instanceof Fe?Array.from(s.data):null;switch(e.operator){case'+':{if(ze(r)&&ze(a)){const t=r,s=a;if(t.length!==s.length)return console.error(`Vector length mismatch. Line ${e.line}.`),null;const i=t.map(((e,t)=>e+s[t]));return new Be(i,n.typeInfo)}if(ze(r)){const e=a,t=r.map(((t,n)=>t+e));return new Be(t,n.typeInfo)}if(ze(a)){const e=r,t=a.map(((t,n)=>e+t));return new Be(t,s.typeInfo)}const t=r,i=a,o=this._maxFormatTypeInfo([n.typeInfo,s.typeInfo]);return new Ve(t+i,o)}case'-':{if(ze(r)&&ze(a)){const t=r,s=a;if(t.length!==s.length)return console.error(`Vector length mismatch. Line ${e.line}.`),null;const i=t.map(((e,t)=>e-s[t]));return new Be(i,n.typeInfo)}if(ze(r)){const e=a,t=r.map(((t,n)=>t-e));return new Be(t,n.typeInfo)}if(ze(a)){const e=r,t=a.map(((t,n)=>e-t));return new Be(t,s.typeInfo)}const t=r,i=a,o=this._maxFormatTypeInfo([n.typeInfo,s.typeInfo]);return new Ve(t-i,o)}case'*':{if(ze(r)&&ze(a)){const t=r,i=a;if(n instanceof Fe&&s instanceof Fe){const r=function(e,t,n,s){if(void 0===ut[t.name]||void 0===ut[s.name])return null;const r=ut[t.name][0],a=ut[t.name][1],i=ut[s.name][0];if(r!==ut[s.name][1])return null;const o=new Array(i*a);for(let t=0;t<a;t++)for(let s=0;s<i;s++){let l=0;for(let i=0;i<r;i++)l+=e[i*a+t]*n[s*r+i];o[t*i+s]=l}return o}(t,n.typeInfo,i,s.typeInfo);if(null===r)return console.error(`Matrix multiplication failed. Line ${e.line}.`),null;const a=ut[s.typeInfo.name][0],o=ut[n.typeInfo.name][1],l=this.getTypeInfo(`mat${a}x${o}f`);return new Fe(r,l)}if(n instanceof Fe&&s instanceof Be){const r=function(e,t,n,s){if(void 0===ut[t.name]||void 0===ct[s.name])return null;const r=ut[t.name][0],a=ut[t.name][1];if(r!==n.length)return null;const i=new Array(a);for(let t=0;t<a;t++){let s=0;for(let i=0;i<r;i++)s+=e[i*a+t]*n[i];i[t]=s}return i}(t,n.typeInfo,i,s.typeInfo);return null===r?(console.error(`Matrix vector multiplication failed. Line ${e.line}.`),null):new Be(r,s.typeInfo)}if(n instanceof Be&&s instanceof Fe){const r=function(e,t,n,s){if(void 0===ct[t.name]||void 0===ut[s.name])return null;const r=ut[s.name][0],a=ut[s.name][1];if(a!==e.length)return null;const i=[];for(let t=0;t<r;t++){let s=0;for(let i=0;i<a;i++)s+=e[i]*n[i*r+t];i[t]=s}return i}(t,n.typeInfo,i,s.typeInfo);return null===r?(console.error(`Matrix vector multiplication failed. Line ${e.line}.`),null):new Be(r,n.typeInfo)}{if(t.length!==i.length)return console.error(`Vector length mismatch. Line ${e.line}.`),null;const s=t.map(((e,t)=>e*i[t]));return new Be(s,n.typeInfo)}}if(ze(r)){const e=a,t=r.map(((t,n)=>t*e));return n instanceof Fe?new Fe(t,n.typeInfo):new Be(t,n.typeInfo)}if(ze(a)){const e=r,t=a.map(((t,n)=>e*t));return s instanceof Fe?new Fe(t,s.typeInfo):new Be(t,s.typeInfo)}const t=r,i=a,o=this._maxFormatTypeInfo([n.typeInfo,s.typeInfo]);return new Ve(t*i,o)}case'%':{if(ze(r)&&ze(a)){const t=r,s=a;if(t.length!==s.length)return console.error(`Vector length mismatch. Line ${e.line}.`),null;const i=t.map(((e,t)=>e%s[t]));return new Be(i,n.typeInfo)}if(ze(r)){const e=a,t=r.map(((t,n)=>t%e));return new Be(t,n.typeInfo)}if(ze(a)){const e=r,t=a.map(((t,n)=>e%t));return new Be(t,s.typeInfo)}const t=r,i=a,o=this._maxFormatTypeInfo([n.typeInfo,s.typeInfo]);return new Ve(t%i,o)}case'/':{if(ze(r)&&ze(a)){const t=r,s=a;if(t.length!==s.length)return console.error(`Vector length mismatch. Line ${e.line}.`),null;const i=t.map(((e,t)=>e/s[t]));return new Be(i,n.typeInfo)}if(ze(r)){const e=a,t=r.map(((t,n)=>t/e));return new Be(t,n.typeInfo)}if(ze(a)){const e=r,t=a.map(((t,n)=>e/t));return new Be(t,s.typeInfo)}const t=r,i=a,o=this._maxFormatTypeInfo([n.typeInfo,s.typeInfo]);return new Ve(t/i,o)}case'&':{if(ze(r)&&ze(a)){const t=r,s=a;if(t.length!==s.length)return console.error(`Vector length mismatch. Line ${e.line}.`),null;const i=t.map(((e,t)=>e&s[t]));return new Be(i,n.typeInfo)}if(ze(r)){const e=a,t=r.map(((t,n)=>t&e));return new Be(t,n.typeInfo)}if(ze(a)){const e=r,t=a.map(((t,n)=>e&t));return new Be(t,s.typeInfo)}const t=r,i=a,o=this._maxFormatTypeInfo([n.typeInfo,s.typeInfo]);return new Ve(t&i,o)}case'|':{if(ze(r)&&ze(a)){const t=r,s=a;if(t.length!==s.length)return console.error(`Vector length mismatch. Line ${e.line}.`),null;const i=t.map(((e,t)=>e|s[t]));return new Be(i,n.typeInfo)}if(ze(r)){const e=a,t=r.map(((t,n)=>t|e));return new Be(t,n.typeInfo)}if(ze(a)){const e=r,t=a.map(((t,n)=>e|t));return new Be(t,s.typeInfo)}const t=r,i=a,o=this._maxFormatTypeInfo([n.typeInfo,s.typeInfo]);return new Ve(t|i,o)}case'^':{if(ze(r)&&ze(a)){const t=r,s=a;if(t.length!==s.length)return console.error(`Vector length mismatch. Line ${e.line}.`),null;const i=t.map(((e,t)=>e^s[t]));return new Be(i,n.typeInfo)}if(ze(r)){const e=a,t=r.map(((t,n)=>t^e));return new Be(t,n.typeInfo)}if(ze(a)){const e=r,t=a.map(((t,n)=>e^t));return new Be(t,s.typeInfo)}const t=r,i=a,o=this._maxFormatTypeInfo([n.typeInfo,s.typeInfo]);return new Ve(t^i,o)}case'<<':{if(ze(r)&&ze(a)){const t=r,s=a;if(t.length!==s.length)return console.error(`Vector length mismatch. Line ${e.line}.`),null;const i=t.map(((e,t)=>e<<s[t]));return new Be(i,n.typeInfo)}if(ze(r)){const e=a,t=r.map(((t,n)=>t<<e));return new Be(t,n.typeInfo)}if(ze(a)){const e=r,t=a.map(((t,n)=>e<<t));return new Be(t,s.typeInfo)}const t=r,i=a,o=this._maxFormatTypeInfo([n.typeInfo,s.typeInfo]);return new Ve(t<<i,o)}case'>>':{if(ze(r)&&ze(a)){const t=r,s=a;if(t.length!==s.length)return console.error(`Vector length mismatch. Line ${e.line}.`),null;const i=t.map(((e,t)=>e>>s[t]));return new Be(i,n.typeInfo)}if(ze(r)){const e=a,t=r.map(((t,n)=>t>>e));return new Be(t,n.typeInfo)}if(ze(a)){const e=r,t=a.map(((t,n)=>e>>t));return new Be(t,s.typeInfo)}const t=r,i=a,o=this._maxFormatTypeInfo([n.typeInfo,s.typeInfo]);return new Ve(t>>i,o)}case'>':if(ze(r)&&ze(a)){const t=r,s=a;if(t.length!==s.length)return console.error(`Vector length mismatch. Line ${e.line}.`),null;const i=t.map(((e,t)=>e>s[t]?1:0));return new Be(i,n.typeInfo)}if(ze(r)){const e=a,t=r.map(((t,n)=>t>e?1:0));return new Be(t,n.typeInfo)}if(ze(a)){const e=r,t=a.map(((t,n)=>e>t?1:0));return new Be(t,s.typeInfo)}return new Ve(r>a?1:0,this.getTypeInfo('bool'));case'<':if(ze(r)&&ze(a)){const t=r,s=a;if(t.length!==s.length)return console.error(`Vector length mismatch. Line ${e.line}.`),null;const i=t.map(((e,t)=>e<s[t]?1:0));return new Be(i,n.typeInfo)}if(ze(r)){const e=a,t=r.map(((t,n)=>t<e?1:0));return new Be(t,n.typeInfo)}if(ze(a)){const e=r,t=a.map(((t,n)=>e<t?1:0));return new Be(t,s.typeInfo)}return new Ve(r<a?1:0,this.getTypeInfo('bool'));case'==':if(ze(r)&&ze(a)){const t=r,s=a;if(t.length!==s.length)return console.error(`Vector length mismatch. Line ${e.line}.`),null;const i=t.map(((e,t)=>e===s[t]?1:0));return new Be(i,n.typeInfo)}if(ze(r)){const e=a,t=r.map(((t,n)=>t==e?1:0));return new Be(t,n.typeInfo)}if(ze(a)){const e=r,t=a.map(((t,n)=>e==t?1:0));return new Be(t,s.typeInfo)}return new Ve(r===a?1:0,this.getTypeInfo('bool'));case'!=':if(ze(r)&&ze(a)){const t=r,s=a;if(t.length!==s.length)return console.error(`Vector length mismatch. Line ${e.line}.`),null;const i=t.map(((e,t)=>e!==s[t]?1:0));return new Be(i,n.typeInfo)}if(ze(r)){const e=a,t=r.map(((t,n)=>t!==e?1:0));return new Be(t,n.typeInfo)}if(ze(a)){const e=r,t=a.map(((t,n)=>e!==t?1:0));return new Be(t,s.typeInfo)}return new Ve(r!==a?1:0,this.getTypeInfo('bool'));case'>=':if(ze(r)&&ze(a)){const t=r,s=a;if(t.length!==s.length)return console.error(`Vector length mismatch. Line ${e.line}.`),null;const i=t.map(((e,t)=>e>=s[t]?1:0));return new Be(i,n.typeInfo)}if(ze(r)){const e=a,t=r.map(((t,n)=>t>=e?1:0));return new Be(t,n.typeInfo)}if(ze(a)){const e=r,t=a.map(((t,n)=>e>=t?1:0));return new Be(t,s.typeInfo)}return new Ve(r>=a?1:0,this.getTypeInfo('bool'));case'<=':if(ze(r)&&ze(a)){const t=r,s=a;if(t.length!==s.length)return console.error(`Vector length mismatch. Line ${e.line}.`),null;const i=t.map(((e,t)=>e<=s[t]?1:0));return new Be(i,n.typeInfo)}if(ze(r)){const e=a,t=r.map(((t,n)=>t<=e?1:0));return new Be(t,n.typeInfo)}if(ze(a)){const e=r,t=a.map(((t,n)=>e<=t?1:0));return new Be(t,s.typeInfo)}return new Ve(r<=a?1:0,this.getTypeInfo('bool'));case'&&':if(ze(r)&&ze(a)){const t=r,s=a;if(t.length!==s.length)return console.error(`Vector length mismatch. Line ${e.line}.`),null;const i=t.map(((e,t)=>e&&s[t]?1:0));return new Be(i,n.typeInfo)}if(ze(r)){const e=a,t=r.map(((t,n)=>t&&e?1:0));return new Be(t,n.typeInfo)}if(ze(a)){const e=r,t=a.map(((t,n)=>e&&t?1:0));return new Be(t,s.typeInfo)}return new Ve(r&&a?1:0,this.getTypeInfo('bool'));case'||':if(ze(r)&&ze(a)){const t=r,s=a;if(t.length!==s.length)return console.error(`Vector length mismatch. Line ${e.line}.`),null;const i=t.map(((e,t)=>e||s[t]?1:0));return new Be(i,n.typeInfo)}if(ze(r)){const e=a,t=r.map(((t,n)=>t||e?1:0));return new Be(t,n.typeInfo)}if(ze(a)){const e=r,t=a.map(((t,n)=>e||t?1:0));return new Be(t,s.typeInfo)}return new Ve(r||a?1:0,this.getTypeInfo('bool'))}return console.error(`Unknown operator ${e.operator}. Line ${e.line}`),null}_evalCall(e,t){if(null!==e.cachedReturnValue)return e.cachedReturnValue;const n=t.clone();n.currentFunctionName=e.name;const s=t.getFunction(e.name);if(!s){if(e.isBuiltin)return this._callBuiltinFunction(e,n);return this.getTypeInfo(e.name)?this._evalCreate(e,t):(console.error(`Unknown function \"${e.name}\". Line ${e.line}`),null)}for(let t=0;t<s.node.args.length;++t){const r=s.node.args[t],a=this.evalExpression(e.args[t],n);n.createVariable(r.name,a,r)}return this._execStatements(s.node.body,n)}_callBuiltinFunction(e,t){switch(e.name){case'all':return this.builtins.All(e,t);case'any':return this.builtins.Any(e,t);case'select':return this.builtins.Select(e,t);case'arrayLength':return this.builtins.ArrayLength(e,t);case'abs':return this.builtins.Abs(e,t);case'acos':return this.builtins.Acos(e,t);case'acosh':return this.builtins.Acosh(e,t);case'asin':return this.builtins.Asin(e,t);case'asinh':return this.builtins.Asinh(e,t);case'atan':return this.builtins.Atan(e,t);case'atanh':return this.builtins.Atanh(e,t);case'atan2':return this.builtins.Atan2(e,t);case'ceil':return this.builtins.Ceil(e,t);case'clamp':return this.builtins.Clamp(e,t);case'cos':return this.builtins.Cos(e,t);case'cosh':return this.builtins.Cosh(e,t);case'countLeadingZeros':return this.builtins.CountLeadingZeros(e,t);case'countOneBits':return this.builtins.CountOneBits(e,t);case'countTrailingZeros':return this.builtins.CountTrailingZeros(e,t);case'cross':return this.builtins.Cross(e,t);case'degrees':return this.builtins.Degrees(e,t);case'determinant':return this.builtins.Determinant(e,t);case'distance':return this.builtins.Distance(e,t);case'dot':return this.builtins.Dot(e,t);case'dot4U8Packed':return this.builtins.Dot4U8Packed(e,t);case'dot4I8Packed':return this.builtins.Dot4I8Packed(e,t);case'exp':return this.builtins.Exp(e,t);case'exp2':return this.builtins.Exp2(e,t);case'extractBits':return this.builtins.ExtractBits(e,t);case'faceForward':return this.builtins.FaceForward(e,t);case'firstLeadingBit':return this.builtins.FirstLeadingBit(e,t);case'firstTrailingBit':return this.builtins.FirstTrailingBit(e,t);case'floor':return this.builtins.Floor(e,t);case'fma':return this.builtins.Fma(e,t);case'fract':return this.builtins.Fract(e,t);case'frexp':return this.builtins.Frexp(e,t);case'insertBits':return this.builtins.InsertBits(e,t);case'inverseSqrt':return this.builtins.InverseSqrt(e,t);case'ldexp':return this.builtins.Ldexp(e,t);case'length':return this.builtins.Length(e,t);case'log':return this.builtins.Log(e,t);case'log2':return this.builtins.Log2(e,t);case'max':return this.builtins.Max(e,t);case'min':return this.builtins.Min(e,t);case'mix':return this.builtins.Mix(e,t);case'modf':return this.builtins.Modf(e,t);case'normalize':return this.builtins.Normalize(e,t);case'pow':return this.builtins.Pow(e,t);case'quantizeToF16':return this.builtins.QuantizeToF16(e,t);case'radians':return this.builtins.Radians(e,t);case'reflect':return this.builtins.Reflect(e,t);case'refract':return this.builtins.Refract(e,t);case'reverseBits':return this.builtins.ReverseBits(e,t);case'round':return this.builtins.Round(e,t);case'saturate':return this.builtins.Saturate(e,t);case'sign':return this.builtins.Sign(e,t);case'sin':return this.builtins.Sin(e,t);case'sinh':return this.builtins.Sinh(e,t);case'smoothStep':return this.builtins.SmoothStep(e,t);case'sqrt':return this.builtins.Sqrt(e,t);case'step':return this.builtins.Step(e,t);case'tan':return this.builtins.Tan(e,t);case'tanh':return this.builtins.Tanh(e,t);case'transpose':return this.builtins.Transpose(e,t);case'trunc':return this.builtins.Trunc(e,t);case'dpdx':return this.builtins.Dpdx(e,t);case'dpdxCoarse':return this.builtins.DpdxCoarse(e,t);case'dpdxFine':return this.builtins.DpdxFine(e,t);case'dpdy':return this.builtins.Dpdy(e,t);case'dpdyCoarse':return this.builtins.DpdyCoarse(e,t);case'dpdyFine':return this.builtins.DpdyFine(e,t);case'fwidth':return this.builtins.Fwidth(e,t);case'fwidthCoarse':return this.builtins.FwidthCoarse(e,t);case'fwidthFine':return this.builtins.FwidthFine(e,t);case'textureDimensions':return this.builtins.TextureDimensions(e,t);case'textureGather':return this.builtins.TextureGather(e,t);case'textureGatherCompare':return this.builtins.TextureGatherCompare(e,t);case'textureLoad':return this.builtins.TextureLoad(e,t);case'textureNumLayers':return this.builtins.TextureNumLayers(e,t);case'textureNumLevels':return this.builtins.TextureNumLevels(e,t);case'textureNumSamples':return this.builtins.TextureNumSamples(e,t);case'textureSample':return this.builtins.TextureSample(e,t);case'textureSampleBias':return this.builtins.TextureSampleBias(e,t);case'textureSampleCompare':return this.builtins.TextureSampleCompare(e,t);case'textureSampleCompareLevel':return this.builtins.TextureSampleCompareLevel(e,t);case'textureSampleGrad':return this.builtins.TextureSampleGrad(e,t);case'textureSampleLevel':return this.builtins.TextureSampleLevel(e,t);case'textureSampleBaseClampToEdge':return this.builtins.TextureSampleBaseClampToEdge(e,t);case'textureStore':return this.builtins.TextureStore(e,t);case'atomicLoad':return this.builtins.AtomicLoad(e,t);case'atomicStore':return this.builtins.AtomicStore(e,t);case'atomicAdd':return this.builtins.AtomicAdd(e,t);case'atomicSub':return this.builtins.AtomicSub(e,t);case'atomicMax':return this.builtins.AtomicMax(e,t);case'atomicMin':return this.builtins.AtomicMin(e,t);case'atomicAnd':return this.builtins.AtomicAnd(e,t);case'atomicOr':return this.builtins.AtomicOr(e,t);case'atomicXor':return this.builtins.AtomicXor(e,t);case'atomicExchange':return this.builtins.AtomicExchange(e,t);case'atomicCompareExchangeWeak':return this.builtins.AtomicCompareExchangeWeak(e,t);case'pack4x8snorm':return this.builtins.Pack4x8snorm(e,t);case'pack4x8unorm':return this.builtins.Pack4x8unorm(e,t);case'pack4xI8':return this.builtins.Pack4xI8(e,t);case'pack4xU8':return this.builtins.Pack4xU8(e,t);case'pack4x8Clamp':return this.builtins.Pack4x8Clamp(e,t);case'pack4xU8Clamp':return this.builtins.Pack4xU8Clamp(e,t);case'pack2x16snorm':return this.builtins.Pack2x16snorm(e,t);case'pack2x16unorm':return this.builtins.Pack2x16unorm(e,t);case'pack2x16float':return this.builtins.Pack2x16float(e,t);case'unpack4x8snorm':return this.builtins.Unpack4x8snorm(e,t);case'unpack4x8unorm':return this.builtins.Unpack4x8unorm(e,t);case'unpack4xI8':return this.builtins.Unpack4xI8(e,t);case'unpack4xU8':return this.builtins.Unpack4xU8(e,t);case'unpack2x16snorm':return this.builtins.Unpack2x16snorm(e,t);case'unpack2x16unorm':return this.builtins.Unpack2x16unorm(e,t);case'unpack2x16float':return this.builtins.Unpack2x16float(e,t);case'storageBarrier':return this.builtins.StorageBarrier(e,t);case'textureBarrier':return this.builtins.TextureBarrier(e,t);case'workgroupBarrier':return this.builtins.WorkgroupBarrier(e,t);case'workgroupUniformLoad':return this.builtins.WorkgroupUniformLoad(e,t);case'subgroupAdd':return this.builtins.SubgroupAdd(e,t);case'subgroupExclusiveAdd':return this.builtins.SubgroupExclusiveAdd(e,t);case'subgroupInclusiveAdd':return this.builtins.SubgroupInclusiveAdd(e,t);case'subgroupAll':return this.builtins.SubgroupAll(e,t);case'subgroupAnd':return this.builtins.SubgroupAnd(e,t);case'subgroupAny':return this.builtins.SubgroupAny(e,t);case'subgroupBallot':return this.builtins.SubgroupBallot(e,t);case'subgroupBroadcast':return this.builtins.SubgroupBroadcast(e,t);case'subgroupBroadcastFirst':return this.builtins.SubgroupBroadcastFirst(e,t);case'subgroupElect':return this.builtins.SubgroupElect(e,t);case'subgroupMax':return this.builtins.SubgroupMax(e,t);case'subgroupMin':return this.builtins.SubgroupMin(e,t);case'subgroupMul':return this.builtins.SubgroupMul(e,t);case'subgroupExclusiveMul':return this.builtins.SubgroupExclusiveMul(e,t);case'subgroupInclusiveMul':return this.builtins.SubgroupInclusiveMul(e,t);case'subgroupOr':return this.builtins.SubgroupOr(e,t);case'subgroupShuffle':return this.builtins.SubgroupShuffle(e,t);case'subgroupShuffleDown':return this.builtins.SubgroupShuffleDown(e,t);case'subgroupShuffleUp':return this.builtins.SubgroupShuffleUp(e,t);case'subgroupShuffleXor':return this.builtins.SubgroupShuffleXor(e,t);case'subgroupXor':return this.builtins.SubgroupXor(e,t);case'quadBroadcast':return this.builtins.QuadBroadcast(e,t);case'quadSwapDiagonal':return this.builtins.QuadSwapDiagonal(e,t);case'quadSwapX':return this.builtins.QuadSwapX(e,t);case'quadSwapY':return this.builtins.QuadSwapY(e,t)}const n=t.getFunction(e.name);if(n){const s=t.clone();for(let t=0;t<n.node.args.length;++t){const r=n.node.args[t],a=this.evalExpression(e.args[t],s);s.setVariable(r.name,a,r)}return this._execStatements(n.node.body,s)}return null}_callConstructorValue(e,t){if(!e.args||0===e.args.length)return new Ve(0,this.getTypeInfo(e.type));const n=this.evalExpression(e.args[0],t);return n.typeInfo=this.getTypeInfo(e.type),n.getSubData(this,e.postfix,t).clone()}_callConstructorVec(e,t){const n=this.getTypeInfo(e.type),s=e.type.getTypeName(),r=ct[s];if(void 0===r)return console.error(`Invalid vec constructor ${s}. Line ${e.line}`),null;const a=[];if(e instanceof _e)if(e.isVector){const t=e.vectorValue;for(const e of t)a.push(e)}else a.push(e.scalarValue);else if(e.args)for(const n of e.args){const e=this.evalExpression(n,t);if(e instanceof Be){const t=e.data;for(let e=0;e<t.length;++e){let n=t[e];a.push(n)}}else if(e instanceof Ve){let t=e.value;a.push(t)}}if(e.type instanceof ie&&null===e.type.format&&(e.type.format=ie.f32),0===a.length){const s=new Array(r).fill(0);return new Be(s,n).getSubData(this,e.postfix,t)}if(1===a.length)for(;a.length<r;)a.push(a[0]);if(a.length<r)return console.error(`Invalid vec constructor. Line ${e.line}`),null;return new Be(a.length>r?a.slice(0,r):a,n).getSubData(this,e.postfix,t)}_callConstructorMatrix(e,t){const n=this.getTypeInfo(e.type),s=e.type.getTypeName(),a=ut[s];if(void 0===a)return console.error(`Invalid matrix constructor ${s}. Line ${e.line}`),null;const i=[];if(e instanceof _e)if(e.isVector){const t=e.vectorValue;for(const e of t)i.push(e)}else i.push(e.scalarValue);else if(e.args)for(const n of e.args){const e=this.evalExpression(n,t);e instanceof Be?i.push(...e.data):e instanceof Ve?i.push(e.value):e instanceof Fe&&i.push(...e.data)}if(n instanceof r&&null===n.format&&(n.format=this.getTypeInfo('f32')),0===i.length){const s=new Array(a[2]).fill(0);return new Fe(s,n).getSubData(this,e.postfix,t)}return i.length!==a[2]?(console.error(`Invalid matrix constructor. Line ${e.line}`),null):new Fe(i,n).getSubData(this,e.postfix,t)}}ht._breakObj=new Ce(new e('BREAK',null),null),ht._continueObj=new Ce(new e('CONTINUE',null),null),ht._priority=new Map([['f32',0],['f16',1],['u32',2],['i32',3],['x32',3]]);class ft{constructor(){this.constants=new Map,this.aliases=new Map,this.structs=new Map}}class pt{constructor(){this._tokens=[],this._current=0,this._currentLine=1,this._deferArrayCountEval=[],this._currentLoop=[],this._context=new ft,this._exec=new ht,this._forwardTypeCount=0}parse(e){this._initialize(e),this._deferArrayCountEval.length=0;const t=[];for(;!this._isAtEnd();){const e=this._global_decl_or_directive();if(!e)break;t.push(e)}if(this._deferArrayCountEval.length>0){for(const e of this._deferArrayCountEval){const t=e.arrayType,n=e.countNode;if(n instanceof de){const e=n.name,s=this._context.constants.get(e);if(s)try{const e=s.constEvaluate(this._exec);t.count=e}catch(e){}}}this._deferArrayCountEval.length=0}if(this._forwardTypeCount>0)for(const e of t)e.search((e=>{e instanceof $e||e instanceof oe?e.type=this._forwardType(e.type):e instanceof le?e.format=this._forwardType(e.format):e instanceof O||e instanceof F||e instanceof M?e.type=this._forwardType(e.type):e instanceof L?e.returnType=this._forwardType(e.returnType):e instanceof Ae&&(e.type=this._forwardType(e.type))}));return t}_forwardType(e){if(e instanceof re){const t=this._getType(e.name);if(t)return t}else e instanceof oe?e.type=this._forwardType(e.type):e instanceof le&&(e.format=this._forwardType(e.format));return e}_initialize(e){if(e)if('string'==typeof e){const t=new He(e);this._tokens=t.scanTokens()}else this._tokens=e;else this._tokens=[];this._current=0}_updateNode(e,t){return e.line=null!=t?t:this._currentLine,e}_error(e,t){return{token:e,message:t,toString:()=>`${t}`}}_isAtEnd(){return this._current>=this._tokens.length||this._peek().type==We.eof}_match(e){if(e instanceof Pe)return!!this._check(e)&&(this._advance(),!0);for(let t=0,n=e.length;t<n;++t){const n=e[t];if(this._check(n))return this._advance(),!0}return!1}_consume(e,t){if(this._check(e))return this._advance();throw this._error(this._peek(),`${t}. Line:${this._currentLine}`)}_check(e){if(this._isAtEnd())return!1;const t=this._peek();if(e instanceof Array){const n=t.type;let s=!1;for(const t of e){if(n===t)return!0;t===We.tokens.name&&(s=!0)}if(s){const e=We.tokens.name.rule.exec(t.lexeme);if(e&&0==e.index&&e[0]==t.lexeme)return!0}return!1}if(t.type===e)return!0;if(e===We.tokens.name){const e=We.tokens.name.rule.exec(t.lexeme);return e&&0==e.index&&e[0]==t.lexeme}return!1}_advance(){var e,t;return this._currentLine=null!==(t=null===(e=this._peek())||void 0===e?void 0:e.line)&&void 0!==t?t:-1,this._isAtEnd()||this._current++,this._previous()}_peek(){return this._tokens[this._current]}_previous(){return this._tokens[this._current-1]}_global_decl_or_directive(){for(;this._match(We.tokens.semicolon)&&!this._isAtEnd(););if(this._match(We.keywords.alias)){const e=this._type_alias();return this._consume(We.tokens.semicolon,'Expected \\';\\''),this._exec.reflection.updateAST([e]),e}if(this._match(We.keywords.diagnostic)){const e=this._diagnostic();return this._consume(We.tokens.semicolon,'Expected \\';\\''),this._exec.reflection.updateAST([e]),e}if(this._match(We.keywords.requires)){const e=this._requires_directive();return this._consume(We.tokens.semicolon,'Expected \\';\\''),this._exec.reflection.updateAST([e]),e}if(this._match(We.keywords.enable)){const e=this._enable_directive();return this._consume(We.tokens.semicolon,'Expected \\';\\''),this._exec.reflection.updateAST([e]),e}const e=this._attribute();if(this._check(We.keywords.var)){const t=this._global_variable_decl();return null!=t&&(t.attributes=e),this._consume(We.tokens.semicolon,'Expected \\';\\'.'),this._exec.reflection.updateAST([t]),t}if(this._check(We.keywords.override)){const t=this._override_variable_decl();return null!=t&&(t.attributes=e),this._consume(We.tokens.semicolon,'Expected \\';\\'.'),this._exec.reflection.updateAST([t]),t}if(this._check(We.keywords.let)){const t=this._global_let_decl();return null!=t&&(t.attributes=e),this._consume(We.tokens.semicolon,'Expected \\';\\'.'),this._exec.reflection.updateAST([t]),t}if(this._check(We.keywords.const)){const t=this._global_const_decl();return null!=t&&(t.attributes=e),this._consume(We.tokens.semicolon,'Expected \\';\\'.'),this._exec.reflection.updateAST([t]),t}if(this._check(We.keywords.struct)){const t=this._struct_decl();return null!=t&&(t.attributes=e),this._exec.reflection.updateAST([t]),t}if(this._check(We.keywords.fn)){const t=this._function_decl();return null!=t&&(t.attributes=e),this._exec.reflection.updateAST([t]),t}return null}_function_decl(){if(!this._match(We.keywords.fn))return null;const e=this._currentLine,t=this._consume(We.tokens.ident,'Expected function name.').toString();this._consume(We.tokens.paren_left,'Expected \\'(\\' for function arguments.');const n=[];if(!this._check(We.tokens.paren_right))do{if(this._check(We.tokens.paren_right))break;const e=this._attribute(),t=this._consume(We.tokens.name,'Expected argument name.').toString();this._consume(We.tokens.colon,'Expected \\':\\' for argument type.');const s=this._attribute(),r=this._type_decl();null!=r&&(r.attributes=s,n.push(this._updateNode(new Ae(t,r,e))))}while(this._match(We.tokens.comma));this._consume(We.tokens.paren_right,'Expected \\')\\' after function arguments.');let s=null;if(this._match(We.tokens.arrow)){const e=this._attribute();s=this._type_decl(),null!=s&&(s.attributes=e)}const r=this._compound_statement(),a=this._currentLine;return this._updateNode(new L(t,n,s,r,e,a),e)}_compound_statement(){const e=[];for(this._consume(We.tokens.brace_left,'Expected \\'{\\' for block.');!this._check(We.tokens.brace_right);){const t=this._statement();null!==t&&e.push(t)}return this._consume(We.tokens.brace_right,'Expected \\'}\\' for block.'),e}_statement(){for(;this._match(We.tokens.semicolon)&&!this._isAtEnd(););if(this._check(We.tokens.attr)&&this._attribute(),this._check(We.keywords.if))return this._if_statement();if(this._check(We.keywords.switch))return this._switch_statement();if(this._check(We.keywords.loop))return this._loop_statement();if(this._check(We.keywords.for))return this._for_statement();if(this._check(We.keywords.while))return this._while_statement();if(this._check(We.keywords.continuing))return this._continuing_statement();if(this._check(We.keywords.static_assert))return this._static_assert_statement();if(this._check(We.tokens.brace_left))return this._compound_statement();let e=null;if(this._check(We.keywords.return))e=this._return_statement();else if(this._check([We.keywords.var,We.keywords.let,We.keywords.const]))e=this._variable_statement();else if(this._match(We.keywords.discard))e=this._updateNode(new ee);else if(this._match(We.keywords.break)){const t=this._updateNode(new te);if(this._currentLoop.length>0){const e=this._currentLoop[this._currentLoop.length-1];t.loopId=e.id}e=t,this._check(We.keywords.if)&&(this._advance(),t.condition=this._optional_paren_expression())}else if(this._match(We.keywords.continue)){const t=this._updateNode(new ne);if(!(this._currentLoop.length>0))throw this._error(this._peek(),`Continue statement must be inside a loop. Line: ${t.line}`);{const e=this._currentLoop[this._currentLoop.length-1];t.loopId=e.id}e=t}else e=this._increment_decrement_statement()||this._func_call_statement()||this._assignment_statement();return null!=e&&this._consume(We.tokens.semicolon,'Expected \\';\\' after statement.'),e}_static_assert_statement(){if(!this._match(We.keywords.static_assert))return null;const e=this._currentLine,t=this._optional_paren_expression();return this._updateNode(new C(t),e)}_while_statement(){if(!this._match(We.keywords.while))return null;const e=this._updateNode(new D(null,null));return this._currentLoop.push(e),e.condition=this._optional_paren_expression(),this._check(We.tokens.attr)&&this._attribute(),e.body=this._compound_statement(),this._currentLoop.pop(),e}_continuing_statement(){const e=this._currentLoop.length>0?this._currentLoop[this._currentLoop.length-1].id:-1;if(!this._match(We.keywords.continuing))return null;const t=this._currentLine,n=this._compound_statement();return this._updateNode(new N(n,e),t)}_for_statement(){if(!this._match(We.keywords.for))return null;this._consume(We.tokens.paren_left,'Expected \\'(\\'.');const e=this._updateNode(new V(null,null,null,null));return this._currentLoop.push(e),e.init=this._check(We.tokens.semicolon)?null:this._for_init(),this._consume(We.tokens.semicolon,'Expected \\';\\'.'),e.condition=this._check(We.tokens.semicolon)?null:this._short_circuit_or_expression(),this._consume(We.tokens.semicolon,'Expected \\';\\'.'),e.increment=this._check(We.tokens.paren_right)?null:this._for_increment(),this._consume(We.tokens.paren_right,'Expected \\')\\'.'),this._check(We.tokens.attr)&&this._attribute(),e.body=this._compound_statement(),this._currentLoop.pop(),e}_for_init(){return this._variable_statement()||this._func_call_statement()||this._assignment_statement()}_for_increment(){return this._func_call_statement()||this._increment_decrement_statement()||this._assignment_statement()}_variable_statement(){if(this._check(We.keywords.var)){const e=this._variable_decl();if(null===e)throw this._error(this._peek(),'Variable declaration expected.');let t=null;return this._match(We.tokens.equal)&&(t=this._short_circuit_or_expression()),this._updateNode(new O(e.name,e.type,e.storage,e.access,t),e.line)}if(this._match(We.keywords.let)){const e=this._currentLine,t=this._consume(We.tokens.name,'Expected name for let.').toString();let n=null;if(this._match(We.tokens.colon)){const e=this._attribute();n=this._type_decl(),null!=n&&(n.attributes=e)}this._consume(We.tokens.equal,'Expected \\'=\\' for let.');const s=this._short_circuit_or_expression();return this._updateNode(new F(t,n,null,null,s),e)}if(this._match(We.keywords.const)){const e=this._currentLine,t=this._consume(We.tokens.name,'Expected name for const.').toString();let n=null;if(this._match(We.tokens.colon)){const e=this._attribute();n=this._type_decl(),null!=n&&(n.attributes=e)}this._consume(We.tokens.equal,'Expected \\'=\\' for const.');const s=this._short_circuit_or_expression();return null===n&&s instanceof _e&&(n=s.type),this._updateNode(new M(t,n,null,null,s),e)}return null}_increment_decrement_statement(){const e=this._current,t=this._unary_expression();if(null==t)return null;if(!this._check(We.increment_operators))return this._current=e,null;const n=this._consume(We.increment_operators,'Expected increment operator');return this._updateNode(new H(n.type===We.tokens.plus_plus?U.increment:U.decrement,t))}_assignment_statement(){let e=null;const t=this._currentLine;if(this._check(We.tokens.brace_right))return null;let n=this._match(We.tokens.underscore);if(n||(e=this._unary_expression()),!n&&null==e)return null;const s=this._consume(We.assignment_operators,'Expected assignment operator.'),r=this._short_circuit_or_expression();return this._updateNode(new z(P.parse(s.lexeme),e,r),t)}_func_call_statement(){if(!this._check(We.tokens.ident))return null;const e=this._currentLine,t=this._current,n=this._consume(We.tokens.ident,'Expected function name.'),s=this._argument_expression_list();return null===s?(this._current=t,null):this._updateNode(new R(n.lexeme,s),e)}_loop_statement(){if(!this._match(We.keywords.loop))return null;this._check(We.tokens.attr)&&this._attribute(),this._consume(We.tokens.brace_left,'Expected \\'{\\' for loop.');const e=this._updateNode(new G([],null));this._currentLoop.push(e);let t=this._statement();for(;null!==t;){if(Array.isArray(t))for(let n of t)e.body.push(n);else e.body.push(t);if(t instanceof N){e.continuing=t;break}t=this._statement()}return this._currentLoop.pop(),this._consume(We.tokens.brace_right,'Expected \\'}\\' for loop.'),e}_switch_statement(){if(!this._match(We.keywords.switch))return null;const e=this._updateNode(new X(null,[]));if(this._currentLoop.push(e),e.condition=this._optional_paren_expression(),this._check(We.tokens.attr)&&this._attribute(),this._consume(We.tokens.brace_left,'Expected \\'{\\' for switch.'),e.cases=this._switch_body(),null==e.cases||0==e.cases.length)throw this._error(this._previous(),'Expected \\'case\\' or \\'default\\'.');return this._consume(We.tokens.brace_right,'Expected \\'}\\' for switch.'),this._currentLoop.pop(),e}_switch_body(){const e=[];let t=!1;for(;this._check([We.keywords.default,We.keywords.case]);){if(this._match(We.keywords.case)){const n=this._case_selectors();for(const e of n)if(e instanceof Ie){if(t)throw this._error(this._previous(),'Multiple default cases in switch statement.');t=!0;break}this._match(We.tokens.colon),this._check(We.tokens.attr)&&this._attribute(),this._consume(We.tokens.brace_left,'Exected \\'{\\' for switch case.');const s=this._case_body();this._consume(We.tokens.brace_right,'Exected \\'}\\' for switch case.'),e.push(this._updateNode(new Te(n,s)))}if(this._match(We.keywords.default)){if(t)throw this._error(this._previous(),'Multiple default cases in switch statement.');this._match(We.tokens.colon),this._check(We.tokens.attr)&&this._attribute(),this._consume(We.tokens.brace_left,'Exected \\'{\\' for switch default.');const n=this._case_body();this._consume(We.tokens.brace_right,'Exected \\'}\\' for switch default.'),e.push(this._updateNode(new Se(n)))}}return e}_case_selectors(){const e=[];for(this._match(We.keywords.default)?e.push(this._updateNode(new Ie)):e.push(this._shift_expression());this._match(We.tokens.comma);)this._match(We.keywords.default)?e.push(this._updateNode(new Ie)):e.push(this._shift_expression());return e}_case_body(){if(this._match(We.keywords.fallthrough))return this._consume(We.tokens.semicolon,'Expected \\';\\''),[];let e=this._statement();if(null==e)return[];e instanceof Array||(e=[e]);const t=this._case_body();return 0==t.length?e:[...e,t[0]]}_if_statement(){if(!this._match(We.keywords.if))return null;const e=this._currentLine,t=this._optional_paren_expression();this._check(We.tokens.attr)&&this._attribute();const n=this._compound_statement();let s=[];this._match_elseif()&&(this._check(We.tokens.attr)&&this._attribute(),s=this._elseif_statement(s));let r=null;return this._match(We.keywords.else)&&(this._check(We.tokens.attr)&&this._attribute(),r=this._compound_statement()),this._updateNode(new j(t,n,s,r),e)}_match_elseif(){return this._tokens[this._current].type===We.keywords.else&&this._tokens[this._current+1].type===We.keywords.if&&(this._advance(),this._advance(),!0)}_elseif_statement(e=[]){const t=this._optional_paren_expression(),n=this._compound_statement();return e.push(this._updateNode(new Ee(t,n))),this._match_elseif()&&(this._check(We.tokens.attr)&&this._attribute(),this._elseif_statement(e)),e}_return_statement(){if(!this._match(We.keywords.return))return null;const e=this._short_circuit_or_expression();return this._updateNode(new Z(e))}_short_circuit_or_expression(){let e=this._short_circuit_and_expr();for(;this._match(We.tokens.or_or);)e=this._updateNode(new we(this._previous().toString(),e,this._short_circuit_and_expr()));return e}_short_circuit_and_expr(){let e=this._inclusive_or_expression();for(;this._match(We.tokens.and_and);)e=this._updateNode(new we(this._previous().toString(),e,this._inclusive_or_expression()));return e}_inclusive_or_expression(){let e=this._exclusive_or_expression();for(;this._match(We.tokens.or);)e=this._updateNode(new we(this._previous().toString(),e,this._exclusive_or_expression()));return e}_exclusive_or_expression(){let e=this._and_expression();for(;this._match(We.tokens.xor);)e=this._updateNode(new we(this._previous().toString(),e,this._and_expression()));return e}_and_expression(){let e=this._equality_expression();for(;this._match(We.tokens.and);)e=this._updateNode(new we(this._previous().toString(),e,this._equality_expression()));return e}_equality_expression(){const e=this._relational_expression();return this._match([We.tokens.equal_equal,We.tokens.not_equal])?this._updateNode(new we(this._previous().toString(),e,this._relational_expression())):e}_relational_expression(){let e=this._shift_expression();for(;this._match([We.tokens.less_than,We.tokens.greater_than,We.tokens.less_than_equal,We.tokens.greater_than_equal]);)e=this._updateNode(new we(this._previous().toString(),e,this._shift_expression()));return e}_shift_expression(){let e=this._additive_expression();for(;this._match([We.tokens.shift_left,We.tokens.shift_right]);)e=this._updateNode(new we(this._previous().toString(),e,this._additive_expression()));return e}_additive_expression(){let e=this._multiplicative_expression();for(;this._match([We.tokens.plus,We.tokens.minus]);)e=this._updateNode(new we(this._previous().toString(),e,this._multiplicative_expression()));return e}_multiplicative_expression(){let e=this._unary_expression();for(;this._match([We.tokens.star,We.tokens.forward_slash,We.tokens.modulo]);)e=this._updateNode(new we(this._previous().toString(),e,this._unary_expression()));return e}_unary_expression(){return this._match([We.tokens.minus,We.tokens.bang,We.tokens.tilde,We.tokens.star,We.tokens.and])?this._updateNode(new ve(this._previous().toString(),this._unary_expression())):this._singular_expression()}_singular_expression(){const e=this._primary_expression(),t=this._postfix_expression();return t&&(e.postfix=t),e}_postfix_expression(){if(this._match(We.tokens.bracket_left)){const e=this._short_circuit_or_expression();this._consume(We.tokens.bracket_right,'Expected \\']\\'.');const t=this._updateNode(new ye(e)),n=this._postfix_expression();return n&&(t.postfix=n),t}if(this._match(We.tokens.period)){const e=this._consume(We.tokens.name,'Expected member name.'),t=this._postfix_expression(),n=this._updateNode(new he(e.lexeme));return t&&(n.postfix=t),n}return null}_getStruct(e){if(this._context.aliases.has(e)){return this._context.aliases.get(e).type}if(this._context.structs.has(e)){return this._context.structs.get(e)}return null}_getType(e){const t=this._getStruct(e);if(null!==t)return t;switch(e){case'void':return se.void;case'bool':return se.bool;case'i32':return se.i32;case'u32':return se.u32;case'f32':return se.f32;case'f16':return se.f16;case'vec2f':return ie.vec2f;case'vec3f':return ie.vec3f;case'vec4f':return ie.vec4f;case'vec2i':return ie.vec2i;case'vec3i':return ie.vec3i;case'vec4i':return ie.vec4i;case'vec2u':return ie.vec2u;case'vec3u':return ie.vec3u;case'vec4u':return ie.vec4u;case'vec2h':return ie.vec2h;case'vec3h':return ie.vec3h;case'vec4h':return ie.vec4h;case'mat2x2f':return ie.mat2x2f;case'mat2x3f':return ie.mat2x3f;case'mat2x4f':return ie.mat2x4f;case'mat3x2f':return ie.mat3x2f;case'mat3x3f':return ie.mat3x3f;case'mat3x4f':return ie.mat3x4f;case'mat4x2f':return ie.mat4x2f;case'mat4x3f':return ie.mat4x3f;case'mat4x4f':return ie.mat4x4f;case'mat2x2h':return ie.mat2x2h;case'mat2x3h':return ie.mat2x3h;case'mat2x4h':return ie.mat2x4h;case'mat3x2h':return ie.mat3x2h;case'mat3x3h':return ie.mat3x3h;case'mat3x4h':return ie.mat3x4h;case'mat4x2h':return ie.mat4x2h;case'mat4x3h':return ie.mat4x3h;case'mat4x4h':return ie.mat4x4h;case'mat2x2i':return ie.mat2x2i;case'mat2x3i':return ie.mat2x3i;case'mat2x4i':return ie.mat2x4i;case'mat3x2i':return ie.mat3x2i;case'mat3x3i':return ie.mat3x3i;case'mat3x4i':return ie.mat3x4i;case'mat4x2i':return ie.mat4x2i;case'mat4x3i':return ie.mat4x3i;case'mat4x4i':return ie.mat4x4i;case'mat2x2u':return ie.mat2x2u;case'mat2x3u':return ie.mat2x3u;case'mat2x4u':return ie.mat2x4u;case'mat3x2u':return ie.mat3x2u;case'mat3x3u':return ie.mat3x3u;case'mat3x4u':return ie.mat3x4u;case'mat4x2u':return ie.mat4x2u;case'mat4x3u':return ie.mat4x3u;case'mat4x4u':return ie.mat4x4u}return null}_validateTypeRange(e,t){if('i32'===t.name){if(e<-2147483648||e>2147483647)throw this._error(this._previous(),`Value out of range for i32: ${e}. Line: ${this._currentLine}.`)}else if('u32'===t.name&&(e<0||e>4294967295))throw this._error(this._previous(),`Value out of range for u32: ${e}. Line: ${this._currentLine}.`)}_primary_expression(){if(this._match(We.tokens.ident)){const e=this._previous().toString();if(this._check(We.tokens.paren_left)){const t=this._argument_expression_list(),n=this._getType(e);return null!==n?this._updateNode(new fe(n,t)):this._updateNode(new pe(e,t))}if(this._context.constants.has(e)){const t=this._context.constants.get(e);return this._updateNode(new me(e,t.value))}return this._updateNode(new de(e))}if(this._match(We.tokens.int_literal)){const e=this._previous().toString();let t=e.endsWith('i')||e.endsWith('i')?se.i32:e.endsWith('u')||e.endsWith('U')?se.u32:se.x32;const n=parseInt(e);return this._validateTypeRange(n,t),this._updateNode(new _e(new Ve(n,this._exec.getTypeInfo(t)),t))}if(this._match(We.tokens.uint_literal)){const e=parseInt(this._previous().toString());return this._validateTypeRange(e,se.u32),this._updateNode(new _e(new Ve(e,this._exec.getTypeInfo(se.u32)),se.u32))}if(this._match([We.tokens.decimal_float_literal,We.tokens.hex_float_literal])){let e=this._previous().toString(),t=e.endsWith('h');t&&(e=e.substring(0,e.length-1));const n=parseFloat(e);this._validateTypeRange(n,t?se.f16:se.f32);const s=t?se.f16:se.f32;return this._updateNode(new _e(new Ve(n,this._exec.getTypeInfo(s)),s))}if(this._match([We.keywords.true,We.keywords.false])){let e=this._previous().toString()===We.keywords.true.rule;return this._updateNode(new _e(new Ve(e?1:0,this._exec.getTypeInfo(se.bool)),se.bool))}if(this._check(We.tokens.paren_left))return this._paren_expression();if(this._match(We.keywords.bitcast)){this._consume(We.tokens.less_than,'Expected \\'<\\'.');const e=this._type_decl();this._consume(We.tokens.greater_than,'Expected \\'>\\'.');const t=this._paren_expression();return this._updateNode(new ge(e,t))}const e=this._type_decl(),t=this._argument_expression_list();return this._updateNode(new fe(e,t))}_argument_expression_list(){if(!this._match(We.tokens.paren_left))return null;const e=[];do{if(this._check(We.tokens.paren_right))break;const t=this._short_circuit_or_expression();e.push(t)}while(this._match(We.tokens.comma));return this._consume(We.tokens.paren_right,'Expected \\')\\' for agument list'),e}_optional_paren_expression(){this._match(We.tokens.paren_left);const e=this._short_circuit_or_expression();return this._match(We.tokens.paren_right),e}_paren_expression(){this._consume(We.tokens.paren_left,'Expected \\'(\\'.');const e=this._short_circuit_or_expression();return this._consume(We.tokens.paren_right,'Expected \\')\\'.'),e}_struct_decl(){if(!this._match(We.keywords.struct))return null;const e=this._currentLine,t=this._consume(We.tokens.ident,'Expected name for struct.').toString();this._consume(We.tokens.brace_left,'Expected \\'{\\' for struct body.');const n=[];for(;!this._check(We.tokens.brace_right);){const e=this._attribute(),t=this._consume(We.tokens.name,'Expected variable name.').toString();this._consume(We.tokens.colon,'Expected \\':\\' for struct member type.');const s=this._attribute(),r=this._type_decl();null!=r&&(r.attributes=s),this._check(We.tokens.brace_right)?this._match(We.tokens.comma):this._consume(We.tokens.comma,'Expected \\',\\' for struct member.'),n.push(this._updateNode(new $e(t,r,e)))}this._consume(We.tokens.brace_right,'Expected \\'}\\' after struct body.');const s=this._currentLine,r=this._updateNode(new ae(t,n,e,s),e);return this._context.structs.set(t,r),r}_global_variable_decl(){const e=this._variable_decl();if(!e)return null;if(this._match(We.tokens.equal)){const t=this._const_expression();e.value=t}if(null!==e.type&&e.value instanceof _e){if('x32'!==e.value.type.name){if(e.type.getTypeName()!==e.value.type.getTypeName())throw this._error(this._peek(),`Invalid cast from ${e.value.type.name} to ${e.type.name}. Line:${this._currentLine}`)}e.value.isScalar&&this._validateTypeRange(e.value.scalarValue,e.type),e.value.type=e.type}else null===e.type&&e.value instanceof _e&&(e.type='x32'===e.value.type.name?se.i32:e.value.type,e.value.isScalar&&this._validateTypeRange(e.value.scalarValue,e.type));return e}_override_variable_decl(){const e=this._override_decl();return e&&this._match(We.tokens.equal)&&(e.value=this._const_expression()),e}_global_const_decl(){var e;if(!this._match(We.keywords.const))return null;const t=this._consume(We.tokens.name,'Expected variable name'),n=this._currentLine;let s=null;if(this._match(We.tokens.colon)){const e=this._attribute();s=this._type_decl(),null!=s&&(s.attributes=e)}let a=null;this._consume(We.tokens.equal,'const declarations require an assignment');const i=this._short_circuit_or_expression();try{let e=[se.f32],n=i.constEvaluate(this._exec,e);n instanceof Ve&&this._validateTypeRange(n.value,e[0]),e[0]instanceof ie&&null===e[0].format&&n.typeInfo instanceof r&&null!==n.typeInfo.format&&('f16'===n.typeInfo.format.name?e[0].format=se.f16:'f32'===n.typeInfo.format.name?e[0].format=se.f32:'i32'===n.typeInfo.format.name?e[0].format=se.i32:'u32'===n.typeInfo.format.name?e[0].format=se.u32:'bool'===n.typeInfo.format.name?e[0].format=se.bool:console.error(`TODO: impelement template format type ${n.typeInfo.format.name}`)),a=this._updateNode(new _e(n,e[0])),this._exec.context.setVariable(t.toString(),n)}catch(e){a=i}if(null!==s&&a instanceof _e){if('x32'!==a.type.name){if(s.getTypeName()!==a.type.getTypeName())throw this._error(this._peek(),`Invalid cast from ${a.type.name} to ${s.name}. Line:${this._currentLine}`)}a.type=s,a.isScalar&&this._validateTypeRange(a.scalarValue,a.type)}else null===s&&a instanceof _e&&(s=null!==(e=null==a?void 0:a.type)&&void 0!==e?e:se.f32,s===se.x32&&(s=se.i32));const o=this._updateNode(new M(t.toString(),s,'','',a),n);return this._context.constants.set(o.name,o),o}_global_let_decl(){if(!this._match(We.keywords.let))return null;const e=this._currentLine,t=this._consume(We.tokens.name,'Expected variable name');let n=null;if(this._match(We.tokens.colon)){const e=this._attribute();n=this._type_decl(),null!=n&&(n.attributes=e)}let s=null;if(this._match(We.tokens.equal)&&(s=this._const_expression()),null!==n&&s instanceof _e){if('x32'!==s.type.name){if(n.getTypeName()!==s.type.getTypeName())throw this._error(this._peek(),`Invalid cast from ${s.type.name} to ${n.name}. Line:${this._currentLine}`)}s.type=n}else null===n&&s instanceof _e&&(n='x32'===s.type.name?se.i32:s.type);return s instanceof _e&&s.isScalar&&this._validateTypeRange(s.scalarValue,n),this._updateNode(new F(t.toString(),n,'','',s),e)}_const_expression(){return this._short_circuit_or_expression()}_variable_decl(){if(!this._match(We.keywords.var))return null;const e=this._currentLine;let t='',n='';this._match(We.tokens.less_than)&&(t=this._consume(We.storage_class,'Expected storage_class.').toString(),this._match(We.tokens.comma)&&(n=this._consume(We.access_mode,'Expected access_mode.').toString()),this._consume(We.tokens.greater_than,'Expected \\'>\\'.'));const s=this._consume(We.tokens.name,'Expected variable name');let r=null;if(this._match(We.tokens.colon)){const e=this._attribute();r=this._type_decl(),null!=r&&(r.attributes=e)}return this._updateNode(new O(s.toString(),r,t,n,null),e)}_override_decl(){if(!this._match(We.keywords.override))return null;const e=this._consume(We.tokens.name,'Expected variable name');let t=null;if(this._match(We.tokens.colon)){const e=this._attribute();t=this._type_decl(),null!=t&&(t.attributes=e)}return this._updateNode(new B(e.toString(),t,null))}_diagnostic(){this._consume(We.tokens.paren_left,'Expected \\'(\\'');const e=this._consume(We.tokens.ident,'Expected severity control name.');this._consume(We.tokens.comma,'Expected \\',\\'');let t=this._consume(We.tokens.ident,'Expected diagnostic rule name.').toString();if(this._match(We.tokens.period)){t+=`.${this._consume(We.tokens.ident,'Expected diagnostic message.').toString()}`}return this._consume(We.tokens.paren_right,'Expected \\')\\''),this._updateNode(new K(e.toString(),t))}_enable_directive(){const e=this._consume(We.tokens.ident,'identity expected.');return this._updateNode(new Q(e.toString()))}_requires_directive(){const e=[this._consume(We.tokens.ident,'identity expected.').toString()];for(;this._match(We.tokens.comma);){const t=this._consume(We.tokens.ident,'identity expected.');e.push(t.toString())}return this._updateNode(new Y(e))}_type_alias(){const e=this._consume(We.tokens.ident,'identity expected.');this._consume(We.tokens.equal,'Expected \\'=\\' for type alias.');let t=this._type_decl();if(null===t)throw this._error(this._peek(),'Expected Type for Alias.');this._context.aliases.has(t.name)&&(t=this._context.aliases.get(t.name).type);const n=this._updateNode(new J(e.toString(),t));return this._context.aliases.set(n.name,n),n}_type_decl(){if(this._check([We.tokens.ident,...We.texel_format,We.keywords.bool,We.keywords.f32,We.keywords.i32,We.keywords.u32])){const e=this._advance().toString();if(this._context.structs.has(e))return this._context.structs.get(e);if(this._context.aliases.has(e))return this._context.aliases.get(e).type;if(!this._getType(e)){const t=this._updateNode(new re(e));return this._forwardTypeCount++,t}return this._updateNode(new se(e))}let e=this._texture_sampler_types();if(e)return e;if(this._check(We.template_types)){let e=this._advance().toString(),t=null,n=null;this._match(We.tokens.less_than)&&(t=this._type_decl(),n=null,this._match(We.tokens.comma)&&(n=this._consume(We.access_mode,'Expected access_mode for pointer').toString()),this._consume(We.tokens.greater_than,'Expected \\'>\\' for type.'));return this._updateNode(new ie(e,t,n))}if(this._match(We.keywords.ptr)){let e=this._previous().toString();this._consume(We.tokens.less_than,'Expected \\'<\\' for pointer.');const t=this._consume(We.storage_class,'Expected storage_class for pointer');this._consume(We.tokens.comma,'Expected \\',\\' for pointer.');const n=this._type_decl();let s=null;this._match(We.tokens.comma)&&(s=this._consume(We.access_mode,'Expected access_mode for pointer').toString()),this._consume(We.tokens.greater_than,'Expected \\'>\\' for pointer.');return this._updateNode(new oe(e,t.toString(),n,s))}const t=this._attribute();if(this._match(We.keywords.array)){let e=null,n=-1;const s=this._previous();let r=null;if(this._match(We.tokens.less_than)){e=this._type_decl(),this._context.aliases.has(e.name)&&(e=this._context.aliases.get(e.name).type);let t='';if(this._match(We.tokens.comma)){r=this._shift_expression();try{t=r.constEvaluate(this._exec).toString(),r=null}catch(e){t='1'}}this._consume(We.tokens.greater_than,'Expected \\'>\\' for array.'),n=t?parseInt(t):0}const a=this._updateNode(new le(s.toString(),t,e,n));return r&&this._deferArrayCountEval.push({arrayType:a,countNode:r}),a}return null}_texture_sampler_types(){if(this._match(We.sampler_type))return this._updateNode(new ce(this._previous().toString(),null,null));if(this._match(We.depth_texture_type))return this._updateNode(new ce(this._previous().toString(),null,null));if(this._match(We.sampled_texture_type)||this._match(We.multisampled_texture_type)){const e=this._previous();this._consume(We.tokens.less_than,'Expected \\'<\\' for sampler type.');const t=this._type_decl();return this._consume(We.tokens.greater_than,'Expected \\'>\\' for sampler type.'),this._updateNode(new ce(e.toString(),t,null))}if(this._match(We.storage_texture_type)){const e=this._previous();this._consume(We.tokens.less_than,'Expected \\'<\\' for sampler type.');const t=this._consume(We.texel_format,'Invalid texel format.').toString();this._consume(We.tokens.comma,'Expected \\',\\' after texel format.');const n=this._consume(We.access_mode,'Expected access mode for storage texture type.').toString();return this._consume(We.tokens.greater_than,'Expected \\'>\\' for sampler type.'),this._updateNode(new ce(e.toString(),t,n))}return null}_attribute(){let e=[];for(;this._match(We.tokens.attr);){const t=this._consume(We.attribute_name,'Expected attribute name'),n=this._updateNode(new Le(t.toString(),null));if(this._match(We.tokens.paren_left)){if(n.value=this._consume(We.literal_or_ident,'Expected attribute value').toString(),this._check(We.tokens.comma)){this._advance();do{const e=this._consume(We.literal_or_ident,'Expected attribute value').toString();n.value instanceof Array||(n.value=[n.value]),n.value.push(e)}while(this._match(We.tokens.comma))}this._consume(We.tokens.paren_right,'Expected \\')\\'')}e.push(n)}return 0==e.length?null:e}}class dt extends st{constructor(e){super(),e&&this.update(e)}update(e){const t=(new pt).parse(e);this.updateAST(t)}}class mt{get line(){return-1}}class _t extends mt{constructor(e){super(),this.node=e}get line(){return this.node.line}}class gt extends mt{constructor(e,t){super(),this.node=e,this.statement=t}get line(){return this.statement.line}}class xt extends mt{constructor(e){super(),this.id=e}}class yt extends mt{constructor(e){super(),this.id=e}}class bt extends mt{constructor(e,t){super(),this.id=e,this.node=t}get line(){return this.node.line}}class vt extends mt{constructor(e,t,n){super(),this.id=e,this.condition=t,this.node=n}get line(){return this.node.line}}class wt extends mt{constructor(e,t,n){super(),this.lineNo=-1,this.condition=e,this.position=t,this.lineNo=n}get line(){var e,t;return null!==(t=null===(e=this.condition)||void 0===e?void 0:e.line)&&void 0!==t?t:this.lineNo}}class kt extends mt{constructor(e){super(),this.statements=[],this.statements=e}get line(){return this.statements.length>0?this.statements[0].line:-1}}class It{constructor(e,t){this.parent=null,this.commands=[],this.current=0,this.parentCallExpr=null,this.context=e,this.parent=null!=t?t:null}get isAtEnd(){return this.current>=this.commands.length}getNextCommand(){if(this.current>=this.commands.length)return null;const e=this.commands[this.current];return this.current++,e}getCurrentCommand(){return this.current>=this.commands.length?null:this.commands[this.current]}}class Tt{constructor(){this.states=[]}get isEmpty(){return 0==this.states.length}get last(){var e;return null!==(e=this.states[this.states.length-1])&&void 0!==e?e:null}pop(){this.states.pop()}}class St{constructor(e,t){this._runTimer=null,this.breakpoints=new Set,this.runStateCallback=null,this._code=e;const n=(new pt).parse(e);this._exec=new ht(n),this.runStateCallback=null!=t?t:null}getVariableValue(e){var t,n;const s=null!==(n=null===(t=this.context.getVariable(e))||void 0===t?void 0:t.value)&&void 0!==n?n:null;return null===s?null:s instanceof Ve?s.value:s instanceof Be||s instanceof Fe?Array.from(s.data):(console.error(`Unsupported return variable type ${s.typeInfo.name}`),null)}reset(){this._exec=new ht(this._exec.ast),this.startDebug()}startDebug(){this._execStack=new Tt;const e=this._createState(this._exec.ast,this._exec.context);this._execStack.states.push(e)}get context(){const e=this.currentState;return null===e?this._exec.context:e.context}get currentState(){for(;;){if(this._execStack.isEmpty)return null;let e=this._execStack.last;if(null===e)return null;if(e.isAtEnd){if(this._execStack.pop(),this._execStack.isEmpty)return null;e=this._execStack.last}return e}}get currentCommand(){for(;;){if(this._execStack.isEmpty)return null;let e=this._execStack.last;if(null===e)return null;if(e.isAtEnd){if(this._execStack.pop(),this._execStack.isEmpty)return null;e=this._execStack.last}const t=e.getCurrentCommand();if(null!==t)return t}}toggleBreakpoint(e){this.breakpoints.has(e)?this.breakpoints.delete(e):this.breakpoints.add(e)}clearBreakpoints(){this.breakpoints.clear()}get isRunning(){return null!==this._runTimer}run(){this.isRunning||(this._runTimer=setInterval((()=>{const e=this.currentCommand;if(e&&this.breakpoints.has(e.line))return clearInterval(this._runTimer),this._runTimer=null,void(null!==this.runStateCallback&&this.runStateCallback());this.stepNext(!0)||(clearInterval(this._runTimer),this._runTimer=null,null!==this.runStateCallback&&this.runStateCallback())}),0),null!==this.runStateCallback&&this.runStateCallback())}pause(){null!==this._runTimer&&(clearInterval(this._runTimer),this._runTimer=null,null!==this.runStateCallback&&this.runStateCallback())}_setOverrides(e,t){for(const n in e){const s=e[n],r=this._exec.reflection.getOverrideInfo(n);null!==r?(null===r.type&&(r.type=this._exec.getTypeInfo('u32')),'u32'===r.type.name||'i32'===r.type.name||'f32'===r.type.name||'f16'===r.type.name?t.setVariable(n,new Ve(s,r.type)):'bool'===r.type.name?t.setVariable(n,new Ve(s?1:0,r.type)):'vec2'===r.type.name||'vec3'===r.type.name||'vec4'===r.type.name||'vec2f'===r.type.name||'vec3f'===r.type.name||'vec4f'===r.type.name||'vec2i'===r.type.name||'vec3i'===r.type.name||'vec4i'===r.type.name||'vec2u'===r.type.name||'vec3u'===r.type.name||'vec4u'===r.type.name||'vec2h'===r.type.name||'vec3h'===r.type.name||'vec4h'===r.type.name?t.setVariable(n,new Be(s,r.type)):console.error(`Invalid constant type for ${n}`)):console.error(`Override ${n} does not exist in the shader.`)}}debugWorkgroup(e,t,n,s,r){this._execStack=new Tt;const a=this._exec.context;a.currentFunctionName=e,this._dispatchId=t,(r=null!=r?r:{}).constants&&this._setOverrides(r.constants,a),this._exec._execStatements(this._exec.ast,a);const i=a.getFunction(e);if(!i)return console.error(`Function ${e} not found`),!1;if('number'==typeof n)n=[n,1,1];else{if(0===n.length)return console.error('Invalid dispatch count'),!1;1===n.length?n=[n[0],1,1]:2===n.length?n=[n[0],n[1],1]:n.length>3&&(n=[n[0],n[1],n[2]])}const o=n[2],l=n[1],c=n[0],u=this._exec.typeInfo.vec3u;a.setVariable('@num_workgroups',new Be(n,u));for(const e in s)for(const t in s[e]){const n=s[e][t];a.variables.forEach((s=>{var r;const a=s.node;if(null==a?void 0:a.attributes){let i=null,o=null;for(const e of a.attributes)'binding'===e.name?i=e.value:'group'===e.name&&(o=e.value);if(t==i&&e==o)if(void 0!==n.texture&&void 0!==n.descriptor){const e=new Ue(n.texture,this._exec.getTypeInfo(a.type),n.descriptor,null!==(r=n.texture.view)&&void 0!==r?r:null);s.value=e}else void 0!==n.uniform?s.value=new Me(n.uniform,this._exec.getTypeInfo(a.type)):s.value=new Me(n,this._exec.getTypeInfo(a.type))}}))}let h=!1;for(let e=0;e<o&&!h;++e)for(let t=0;t<l&&!h;++t)for(let n=0;n<c&&!h;++n)if(a.setVariable('@workgroup_id',new Be([n,t,e],u)),this._dispatchWorkgroup(i,[n,t,e],a)){h=!0;break}return h}_shouldExecuteNextCommand(){const e=this.currentCommand;if(null===e)return!1;if(e instanceof wt){if(null===e.condition)return!0}else if(e instanceof xt||e instanceof yt)return!0;return!1}stepInto(){this.isRunning||this.stepNext(!0)}stepOver(){this.isRunning||this.stepNext(!1)}stepOut(){const e=this.currentState;if(null===e)return;const t=e.parent;this.isRunning&&(clearInterval(this._runTimer),this._runTimer=null),this._runTimer=setInterval((()=>{const e=this.currentCommand;if(e&&this.breakpoints.has(e.line))return clearInterval(this._runTimer),this._runTimer=null,void(null!==this.runStateCallback&&this.runStateCallback());this.stepNext(!0)||(clearInterval(this._runTimer),this._runTimer=null,null!==this.runStateCallback&&this.runStateCallback());this.currentState===t&&(clearInterval(this._runTimer),this._runTimer=null,null!==this.runStateCallback&&this.runStateCallback())}),0),null!==this.runStateCallback&&this.runStateCallback()}stepNext(e=!0){if(!this._execStack){this._execStack=new Tt;const e=this._createState(this._exec.ast,this._exec.context);this._execStack.states.push(e)}for(;;){if(this._execStack.isEmpty)return!1;let t=this._execStack.last;if(null===t)return!1;if(t.isAtEnd){if(this._execStack.pop(),this._execStack.isEmpty)return!1;t=this._execStack.last}const n=t.getNextCommand();if(null!==n){if(e&&n instanceof gt){const e=n.node,s=t.context.getFunction(e.name);if(!s)continue;const r=this._createState(s.node.body,t.context.clone(),t);for(let t=0;t<s.node.args.length;++t){const n=s.node.args[t],a=this._exec.evalExpression(e.args[t],r.context);r.context.createVariable(n.name,a,n)}if(r.parentCallExpr=e,this._execStack.states.push(r),r.context.currentFunctionName=s.name,this._shouldExecuteNextCommand())continue;return!0}if(n instanceof _t){const s=n.node;if(e&&s instanceof R){const e=t.context.getFunction(s.name);if(e){const n=this._createState(e.node.body,t.context.clone(),t);for(let t=0;t<e.node.args.length;++t){const r=e.node.args[t],a=this._exec.evalExpression(s.args[t],n.context);n.context.createVariable(r.name,a,r)}if(this._execStack.states.push(n),n.context.currentFunctionName=e.name,this._shouldExecuteNextCommand())continue;return!0}}const r=this._exec.execStatement(s,t.context);if(null!=r&&!(r instanceof De)){let e=t;for(;e;){if(e.parentCallExpr){e.parentCallExpr.setCachedReturnValue(r);break}e=e.parent}if(null===e&&console.error('Could not find CallExpr to store return value in'),this._shouldExecuteNextCommand())continue;return!0}}else{if(n instanceof xt)continue;if(n instanceof yt)continue;if(n instanceof bt){const e=n.id;for(;!this._execStack.isEmpty;){t=this._execStack.last;for(let n=t.commands.length-1;n>=0;--n){const s=t.commands[n];if(s instanceof xt&&s.id===e)return t.current=n+1,!0}this._execStack.pop()}return console.error('Continue statement used outside of a loop'),!1}if(n instanceof vt){const e=n.id;if(n.condition){const e=this._exec.evalExpression(n.condition,t.context);if(!(e instanceof Ve))return console.error('Condition must be a scalar'),!1;if(!e.value){if(this._shouldExecuteNextCommand())continue;return!0}}for(;!this._execStack.isEmpty;){t=this._execStack.last;for(let n=t.commands.length-1;n>=0;--n){const s=t.commands[n];if(s instanceof yt&&s.id===e)return t.current=n+1,!0}this._execStack.pop()}return console.error('Break statement used outside of a loop'),!1}if(n instanceof wt){if(n.condition){const e=this._exec.evalExpression(n.condition,t.context);if(!(e instanceof Ve))return console.error('Condition must be a scalar'),!1;if(e.value){if(this._shouldExecuteNextCommand())continue;return!0}}if(t.current=n.position,this._shouldExecuteNextCommand())continue;return!0}if(n instanceof kt){const e=this._createState(n.statements,t.context.clone(),t);this._execStack.states.push(e);continue}}if(t.isAtEnd&&(this._execStack.pop(),this._execStack.isEmpty))return!1;if(!this._shouldExecuteNextCommand())return!0}}}_dispatchWorkgroup(e,t,n){const s=[1,1,1];for(const t of e.node.attributes)if('workgroup_size'===t.name)if(Array.isArray(t.value)){if(t.value.length>0){const e=n.getVariableValue(t.value[0]);s[0]=e instanceof Ve?e.value:parseInt(t.value[0])}if(t.value.length>1){const e=n.getVariableValue(t.value[1]);s[1]=e instanceof Ve?e.value:parseInt(t.value[1])}if(t.value.length>2){const e=n.getVariableValue(t.value[2]);s[2]=e instanceof Ve?e.value:parseInt(t.value[2])}}else{const e=n.getVariableValue(t.value);e instanceof Ve?s[0]=e.value:e instanceof Be?(s[0]=e.data[0],s[1]=e.data.length>1?e.data[1]:1,s[2]=e.data.length>2?e.data[2]:1):s[0]=parseInt(t.value)}const r=this._exec.typeInfo.vec3u,a=this._exec.typeInfo.u32;n.setVariable('@workgroup_size',new Be(s,r));const i=s[0],o=s[1],l=s[2];let c=!1;for(let e=0,u=0;e<l&&!c;++e)for(let l=0;l<o&&!c;++l)for(let o=0;o<i&&!c;++o,++u){const i=[o,l,e],h=[o+t[0]*s[0],l+t[1]*s[1],e+t[2]*s[2]];if(n.setVariable('@local_invocation_id',new Be(i,r)),n.setVariable('@global_invocation_id',new Be(h,r)),n.setVariable('@local_invocation_index',new Ve(u,a)),h[0]===this._dispatchId[0]&&h[1]===this._dispatchId[1]&&h[2]===this._dispatchId[2]){c=!0;break}}return c&&this._dispatchExec(e,n),c}_dispatchExec(e,t){for(const n of e.node.args)for(const e of n.attributes)if('builtin'===e.name){const s=`@${e.value}`,r=t.getVariable(s);null!==r&&t.variables.set(n.name,r)}const n=this._createState(e.node.body,t);this._execStack.states.push(n)}_createState(e,t,n){const s=new It(t,null!=n?n:null);for(const t of e)if(t instanceof F||t instanceof O||t instanceof M||t instanceof z){const e=[];this._collectFunctionCalls(t.value,e);for(const n of e)s.commands.push(new gt(n,t));s.commands.push(new _t(t))}else if(t instanceof R){const e=[];for(const n of t.args)this._collectFunctionCalls(n,e);for(const n of e)s.commands.push(new gt(n,t));s.commands.push(new _t(t))}else if(t instanceof Z){const e=[];this._collectFunctionCalls(t.value,e);for(const n of e)s.commands.push(new gt(n,t));s.commands.push(new _t(t))}else if(t instanceof H)s.commands.push(new _t(t));else{if(t instanceof L){const e=new at(t);s.context.functions.set(t.name,e);continue}if(t instanceof j){const e=[];this._collectFunctionCalls(t.condition,e);for(const n of e)s.commands.push(new gt(n,t));let n=new wt(t.condition,0,t.line);s.commands.push(n),t.body.length>0&&s.commands.push(new kt(t.body));const r=new wt(null,0,t.line);s.commands.push(r);for(const e of t.elseif){n.position=s.commands.length;const a=[];this._collectFunctionCalls(e.condition,a);for(const e of a)s.commands.push(new gt(e,t));n=new wt(e.condition,0,e.line),s.commands.push(n),e.body.length>0&&s.commands.push(new kt(e.body)),s.commands.push(r)}n.position=s.commands.length,t.else&&s.commands.push(new kt(t.else)),r.position=s.commands.length}else if(t instanceof X){const e=[];this._collectFunctionCalls(t.condition,e);for(const n of e)s.commands.push(new gt(n,t));let n=null;for(const e of t.cases){if(e instanceof Se){n=e;break}if(e instanceof Te)for(const t of e.selectors)if(t instanceof Ie){n=e;break}}const r=[];for(const e of t.cases){if(e===n)continue;if(!(e instanceof Te))continue;let a=null;for(const n of e.selectors){let e=new we('==',t.condition,n);a&&(e=new we('||',a,e)),a=e}const i=new wt(a,0,e.line);s.commands.push(i),e.body.length>0&&s.commands.push(new kt(e.body));const o=new wt(null,0,e.line);r.push(o),s.commands.push(o),i.position=s.commands.length}n&&s.commands.push(new kt(n.body)),s.commands.push(new yt(t.id));const a=s.commands.length;for(let e=0;e<r.length;++e)r[e].position=a}else if(t instanceof D){const e=[];s.commands.push(new xt(t.id)),this._collectFunctionCalls(t.condition,e);for(const n of e)s.commands.push(new gt(n,t));const n=new wt(t.condition,0,t.line);s.commands.push(n);let r=t.line;t.body.length>0&&(s.commands.push(new kt(t.body)),r=t.body[t.body.length-1].line),s.commands.push(new wt(t.condition,0,r)),s.commands.push(new yt(t.id)),n.position=s.commands.length}else if(t instanceof V){t.init&&s.commands.push(new _t(t.init));let e=s.commands.length;null===t.increment&&s.commands.push(new xt(t.id));let n=null;if(t.condition){const e=[];this._collectFunctionCalls(t.condition,e);for(const n of e)s.commands.push(new gt(n,t));n=new wt(t.condition,0,t.line),s.commands.push(n)}let r=t.line;t.body.length>0&&(s.commands.push(new kt(t.body)),r=t.body[t.body.length-1].line),t.increment&&(s.commands.push(new xt(t.id)),s.commands.push(new _t(t.increment))),s.commands.push(new wt(null,e,r)),s.commands.push(new yt(t.id)),n.position=s.commands.length}else if(t instanceof G){let e=s.commands.length;t.continuing||s.commands.push(new xt(t.id));let n=t.line;t.body.length>0&&(s.commands.push(new kt(t.body)),n=t.body[t.body.length-1].line),s.commands.push(new wt(null,e,n)),s.commands.push(new yt(t.id))}else t instanceof N?(s.commands.push(new xt(t.loopId)),s.commands.push(new kt(t.body))):t instanceof ne?s.commands.push(new bt(t.loopId,t)):t instanceof te?s.commands.push(new vt(t.loopId,t.condition,t)):t instanceof C?s.commands.push(new _t(t)):t instanceof ae||console.error(`TODO: statement type ${t.constructor.name}`)}return s}_collectFunctionCalls(e,t){if(e instanceof pe){if(e.args)for(const n of e.args)this._collectFunctionCalls(n,t);e.isBuiltin||t.push(e)}else if(e instanceof we)this._collectFunctionCalls(e.left,t),this._collectFunctionCalls(e.right,t);else if(e instanceof ve)this._collectFunctionCalls(e.right,t);else if(e instanceof fe){if(e.args)for(const n of e.args)this._collectFunctionCalls(n,t)}else e instanceof ge?this._collectFunctionCalls(e.value,t):e instanceof ye?this._collectFunctionCalls(e.index,t):_e||console.error(`TODO: expression type ${e.constructor.name}`)}}export{J as Alias,o as AliasInfo,Ae as Argument,h as ArgumentInfo,ye as ArrayIndex,s as ArrayInfo,le as ArrayType,z as Assign,P as AssignOperator,Le as Attribute,we as BinaryOperator,ge as BitcastExpr,te as Break,R as Call,pe as CallExpr,Te as Case,M as Const,me as ConstExpr,ne as Continue,N as Continuing,fe as CreateExpr,Ce as Data,Se as Default,Ie as DefaultSelector,K as Diagnostic,ee as Discard,Ee as ElseIf,Q as Enable,p as EntryFunctions,ue as Expression,V as For,re as ForwardType,L as Function,f as FunctionInfo,j as If,H as Increment,U as IncrementOperator,l as InputInfo,F as Let,_e as LiteralExpr,G as Loop,Fe as MatrixData,$e as Member,t as MemberInfo,T as Node,be as Operator,c as OutputInfo,B as Override,u as OverrideInfo,Ne as PointerData,oe as PointerType,Y as Requires,a as ResourceType,Z as Return,ce as SamplerType,Ve as ScalarData,$ as Statement,C as StaticAssert,he as StringExpr,ae as Struct,n as StructInfo,X as Switch,ke as SwitchCase,r as TemplateInfo,ie as TemplateType,Ue as TextureData,qe as Token,q as TokenClass,Pe as TokenType,We as TokenTypes,se as Type,e as TypeInfo,xe as TypecastExpr,Me as TypedData,ve as UnaryOperator,O as Var,de as VariableExpr,i as VariableInfo,Be as VectorData,De as VoidData,St as WgslDebug,ht as WgslExec,pt as WgslParser,dt as WgslReflect,He as WgslScanner,D as While,A as _BlockEnd,S as _BlockStart};\n//# sourceMappingURL=wgsl_reflect.module.js.map\n","// luma.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n// import {ShaderModule} from '../../types';\nconst fp32shader = /* glsl */ `\\\n#ifdef LUMA_FP32_TAN_PRECISION_WORKAROUND\n\n// All these functions are for substituting tan() function from Intel GPU only\nconst float TWO_PI = 6.2831854820251465;\nconst float PI_2 = 1.5707963705062866;\nconst float PI_16 = 0.1963495463132858;\n\nconst float SIN_TABLE_0 = 0.19509032368659973;\nconst float SIN_TABLE_1 = 0.3826834261417389;\nconst float SIN_TABLE_2 = 0.5555702447891235;\nconst float SIN_TABLE_3 = 0.7071067690849304;\n\nconst float COS_TABLE_0 = 0.9807852506637573;\nconst float COS_TABLE_1 = 0.9238795042037964;\nconst float COS_TABLE_2 = 0.8314695954322815;\nconst float COS_TABLE_3 = 0.7071067690849304;\n\nconst float INVERSE_FACTORIAL_3 = 1.666666716337204e-01; // 1/3!\nconst float INVERSE_FACTORIAL_5 = 8.333333767950535e-03; // 1/5!\nconst float INVERSE_FACTORIAL_7 = 1.9841270113829523e-04; // 1/7!\nconst float INVERSE_FACTORIAL_9 = 2.75573188446287533e-06; // 1/9!\n\nfloat sin_taylor_fp32(float a) {\n  float r, s, t, x;\n\n  if (a == 0.0) {\n    return 0.0;\n  }\n\n  x = -a * a;\n  s = a;\n  r = a;\n\n  r = r * x;\n  t = r * INVERSE_FACTORIAL_3;\n  s = s + t;\n\n  r = r * x;\n  t = r * INVERSE_FACTORIAL_5;\n  s = s + t;\n\n  r = r * x;\n  t = r * INVERSE_FACTORIAL_7;\n  s = s + t;\n\n  r = r * x;\n  t = r * INVERSE_FACTORIAL_9;\n  s = s + t;\n\n  return s;\n}\n\nvoid sincos_taylor_fp32(float a, out float sin_t, out float cos_t) {\n  if (a == 0.0) {\n    sin_t = 0.0;\n    cos_t = 1.0;\n  }\n  sin_t = sin_taylor_fp32(a);\n  cos_t = sqrt(1.0 - sin_t * sin_t);\n}\n\nfloat tan_taylor_fp32(float a) {\n    float sin_a;\n    float cos_a;\n\n    if (a == 0.0) {\n        return 0.0;\n    }\n\n    // 2pi range reduction\n    float z = floor(a / TWO_PI);\n    float r = a - TWO_PI * z;\n\n    float t;\n    float q = floor(r / PI_2 + 0.5);\n    int j = int(q);\n\n    if (j < -2 || j > 2) {\n        return 1.0 / 0.0;\n    }\n\n    t = r - PI_2 * q;\n\n    q = floor(t / PI_16 + 0.5);\n    int k = int(q);\n    int abs_k = int(abs(float(k)));\n\n    if (abs_k > 4) {\n        return 1.0 / 0.0;\n    } else {\n        t = t - PI_16 * q;\n    }\n\n    float u = 0.0;\n    float v = 0.0;\n\n    float sin_t, cos_t;\n    float s, c;\n    sincos_taylor_fp32(t, sin_t, cos_t);\n\n    if (k == 0) {\n        s = sin_t;\n        c = cos_t;\n    } else {\n        if (abs(float(abs_k) - 1.0) < 0.5) {\n            u = COS_TABLE_0;\n            v = SIN_TABLE_0;\n        } else if (abs(float(abs_k) - 2.0) < 0.5) {\n            u = COS_TABLE_1;\n            v = SIN_TABLE_1;\n        } else if (abs(float(abs_k) - 3.0) < 0.5) {\n            u = COS_TABLE_2;\n            v = SIN_TABLE_2;\n        } else if (abs(float(abs_k) - 4.0) < 0.5) {\n            u = COS_TABLE_3;\n            v = SIN_TABLE_3;\n        }\n        if (k > 0) {\n            s = u * sin_t + v * cos_t;\n            c = u * cos_t - v * sin_t;\n        } else {\n            s = u * sin_t - v * cos_t;\n            c = u * cos_t + v * sin_t;\n        }\n    }\n\n    if (j == 0) {\n        sin_a = s;\n        cos_a = c;\n    } else if (j == 1) {\n        sin_a = c;\n        cos_a = -s;\n    } else if (j == -1) {\n        sin_a = -c;\n        cos_a = s;\n    } else {\n        sin_a = -s;\n        cos_a = -c;\n    }\n    return sin_a / cos_a;\n}\n#endif\n\nfloat tan_fp32(float a) {\n#ifdef LUMA_FP32_TAN_PRECISION_WORKAROUND\n  return tan_taylor_fp32(a);\n#else\n  return tan(a);\n#endif\n}\n`;\n/**\n * 32 bit math library (fixups for GPUs)\n */\nexport const fp32 = {\n    name: 'fp32',\n    vs: fp32shader\n};\n//# sourceMappingURL=fp32.js.map","// luma.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\nexport const fp64arithmeticShader = /* glsl */ `\\\n\nuniform fp64arithmeticUniforms {\n  uniform float ONE;\n} fp64;\n\n/*\nAbout LUMA_FP64_CODE_ELIMINATION_WORKAROUND\n\nThe purpose of this workaround is to prevent shader compilers from\noptimizing away necessary arithmetic operations by swapping their sequences\nor transform the equation to some 'equivalent' form.\n\nThe method is to multiply an artifical variable, ONE, which will be known to\nthe compiler to be 1 only at runtime. The whole expression is then represented\nas a polynomial with respective to ONE. In the coefficients of all terms, only one a\nand one b should appear\n\nerr = (a + b) * ONE^6 - a * ONE^5 - (a + b) * ONE^4 + a * ONE^3 - b - (a + b) * ONE^2 + a * ONE\n*/\n\n// Divide float number to high and low floats to extend fraction bits\nvec2 split(float a) {\n  const float SPLIT = 4097.0;\n  float t = a * SPLIT;\n#if defined(LUMA_FP64_CODE_ELIMINATION_WORKAROUND)\n  float a_hi = t * fp64.ONE - (t - a);\n  float a_lo = a * fp64.ONE - a_hi;\n#else\n  float a_hi = t - (t - a);\n  float a_lo = a - a_hi;\n#endif\n  return vec2(a_hi, a_lo);\n}\n\n// Divide float number again when high float uses too many fraction bits\nvec2 split2(vec2 a) {\n  vec2 b = split(a.x);\n  b.y += a.y;\n  return b;\n}\n\n// Special sum operation when a > b\nvec2 quickTwoSum(float a, float b) {\n#if defined(LUMA_FP64_CODE_ELIMINATION_WORKAROUND)\n  float sum = (a + b) * fp64.ONE;\n  float err = b - (sum - a) * fp64.ONE;\n#else\n  float sum = a + b;\n  float err = b - (sum - a);\n#endif\n  return vec2(sum, err);\n}\n\n// General sum operation\nvec2 twoSum(float a, float b) {\n  float s = (a + b);\n#if defined(LUMA_FP64_CODE_ELIMINATION_WORKAROUND)\n  float v = (s * fp64.ONE - a) * fp64.ONE;\n  float err = (a - (s - v) * fp64.ONE) * fp64.ONE * fp64.ONE * fp64.ONE + (b - v);\n#else\n  float v = s - a;\n  float err = (a - (s - v)) + (b - v);\n#endif\n  return vec2(s, err);\n}\n\nvec2 twoSub(float a, float b) {\n  float s = (a - b);\n#if defined(LUMA_FP64_CODE_ELIMINATION_WORKAROUND)\n  float v = (s * fp64.ONE - a) * fp64.ONE;\n  float err = (a - (s - v) * fp64.ONE) * fp64.ONE * fp64.ONE * fp64.ONE - (b + v);\n#else\n  float v = s - a;\n  float err = (a - (s - v)) - (b + v);\n#endif\n  return vec2(s, err);\n}\n\nvec2 twoSqr(float a) {\n  float prod = a * a;\n  vec2 a_fp64 = split(a);\n#if defined(LUMA_FP64_CODE_ELIMINATION_WORKAROUND)\n  float err = ((a_fp64.x * a_fp64.x - prod) * fp64.ONE + 2.0 * a_fp64.x *\n    a_fp64.y * fp64.ONE * fp64.ONE) + a_fp64.y * a_fp64.y * fp64.ONE * fp64.ONE * fp64.ONE;\n#else\n  float err = ((a_fp64.x * a_fp64.x - prod) + 2.0 * a_fp64.x * a_fp64.y) + a_fp64.y * a_fp64.y;\n#endif\n  return vec2(prod, err);\n}\n\nvec2 twoProd(float a, float b) {\n  float prod = a * b;\n  vec2 a_fp64 = split(a);\n  vec2 b_fp64 = split(b);\n  float err = ((a_fp64.x * b_fp64.x - prod) + a_fp64.x * b_fp64.y +\n    a_fp64.y * b_fp64.x) + a_fp64.y * b_fp64.y;\n  return vec2(prod, err);\n}\n\nvec2 sum_fp64(vec2 a, vec2 b) {\n  vec2 s, t;\n  s = twoSum(a.x, b.x);\n  t = twoSum(a.y, b.y);\n  s.y += t.x;\n  s = quickTwoSum(s.x, s.y);\n  s.y += t.y;\n  s = quickTwoSum(s.x, s.y);\n  return s;\n}\n\nvec2 sub_fp64(vec2 a, vec2 b) {\n  vec2 s, t;\n  s = twoSub(a.x, b.x);\n  t = twoSub(a.y, b.y);\n  s.y += t.x;\n  s = quickTwoSum(s.x, s.y);\n  s.y += t.y;\n  s = quickTwoSum(s.x, s.y);\n  return s;\n}\n\nvec2 mul_fp64(vec2 a, vec2 b) {\n  vec2 prod = twoProd(a.x, b.x);\n  // y component is for the error\n  prod.y += a.x * b.y;\n#if defined(LUMA_FP64_HIGH_BITS_OVERFLOW_WORKAROUND)\n  prod = split2(prod);\n#endif\n  prod = quickTwoSum(prod.x, prod.y);\n  prod.y += a.y * b.x;\n#if defined(LUMA_FP64_HIGH_BITS_OVERFLOW_WORKAROUND)\n  prod = split2(prod);\n#endif\n  prod = quickTwoSum(prod.x, prod.y);\n  return prod;\n}\n\nvec2 div_fp64(vec2 a, vec2 b) {\n  float xn = 1.0 / b.x;\n#if defined(LUMA_FP64_HIGH_BITS_OVERFLOW_WORKAROUND)\n  vec2 yn = mul_fp64(a, vec2(xn, 0));\n#else\n  vec2 yn = a * xn;\n#endif\n  float diff = (sub_fp64(a, mul_fp64(b, yn))).x;\n  vec2 prod = twoProd(xn, diff);\n  return sum_fp64(yn, prod);\n}\n\nvec2 sqrt_fp64(vec2 a) {\n  if (a.x == 0.0 && a.y == 0.0) return vec2(0.0, 0.0);\n  if (a.x < 0.0) return vec2(0.0 / 0.0, 0.0 / 0.0);\n\n  float x = 1.0 / sqrt(a.x);\n  float yn = a.x * x;\n#if defined(LUMA_FP64_CODE_ELIMINATION_WORKAROUND)\n  vec2 yn_sqr = twoSqr(yn) * fp64.ONE;\n#else\n  vec2 yn_sqr = twoSqr(yn);\n#endif\n  float diff = sub_fp64(a, yn_sqr).x;\n  vec2 prod = twoProd(x * 0.5, diff);\n#if defined(LUMA_FP64_HIGH_BITS_OVERFLOW_WORKAROUND)\n  return sum_fp64(split(yn), prod);\n#else\n  return sum_fp64(vec2(yn, 0.0), prod);\n#endif\n}\n`;\n//# sourceMappingURL=fp64-arithmetic-glsl.js.map","// luma.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\nimport { fp64ify, fp64LowPart, fp64ifyMatrix4 } from \"../../../modules/math/fp64/fp64-utils.js\";\nimport { fp64arithmeticShader } from \"./fp64-arithmetic-glsl.js\";\nimport { fp64functionShader } from \"./fp64-functions-glsl.js\";\nconst defaultUniforms = {\n    // Used in LUMA_FP64_CODE_ELIMINATION_WORKAROUND\n    ONE: 1.0\n};\n/**\n * 64bit arithmetic: add, sub, mul, div (small subset of fp64 module)\n */\nexport const fp64arithmetic = {\n    name: 'fp64arithmetic',\n    vs: fp64arithmeticShader,\n    defaultUniforms,\n    uniformTypes: { ONE: 'f32' },\n    // Additional Functions\n    fp64ify,\n    fp64LowPart,\n    fp64ifyMatrix4\n};\n/**\n * Full 64 bit math library\n */\nexport const fp64 = {\n    name: 'fp64',\n    vs: fp64functionShader,\n    dependencies: [fp64arithmetic],\n    // Additional Functions\n    fp64ify,\n    fp64LowPart,\n    fp64ifyMatrix4\n};\nexport { fp64ify, fp64LowPart, fp64ifyMatrix4 };\n//# sourceMappingURL=fp64.js.map","// luma.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n// cyan color\nconst DEFAULT_HIGHLIGHT_COLOR = [0, 1, 1, 1];\nconst vs = /* glsl */ `\\\nuniform pickingUniforms {\n  float isActive;\n  float isAttribute;\n  float isHighlightActive;\n  float useFloatColors;\n  vec3 highlightedObjectColor;\n  vec4 highlightColor;\n} picking;\n\nout vec4 picking_vRGBcolor_Avalid;\n\n// Normalize unsigned byte color to 0-1 range\nvec3 picking_normalizeColor(vec3 color) {\n  return picking.useFloatColors > 0.5 ? color : color / 255.0;\n}\n\n// Normalize unsigned byte color to 0-1 range\nvec4 picking_normalizeColor(vec4 color) {\n  return picking.useFloatColors > 0.5 ? color : color / 255.0;\n}\n\nbool picking_isColorZero(vec3 color) {\n  return dot(color, vec3(1.0)) < 0.00001;\n}\n\nbool picking_isColorValid(vec3 color) {\n  return dot(color, vec3(1.0)) > 0.00001;\n}\n\n// Check if this vertex is highlighted \nbool isVertexHighlighted(vec3 vertexColor) {\n  vec3 highlightedObjectColor = picking_normalizeColor(picking.highlightedObjectColor);\n  return\n    bool(picking.isHighlightActive) && picking_isColorZero(abs(vertexColor - highlightedObjectColor));\n}\n\n// Set the current picking color\nvoid picking_setPickingColor(vec3 pickingColor) {\n  pickingColor = picking_normalizeColor(pickingColor);\n\n  if (bool(picking.isActive)) {\n    // Use alpha as the validity flag. If pickingColor is [0, 0, 0] fragment is non-pickable\n    picking_vRGBcolor_Avalid.a = float(picking_isColorValid(pickingColor));\n\n    if (!bool(picking.isAttribute)) {\n      // Stores the picking color so that the fragment shader can render it during picking\n      picking_vRGBcolor_Avalid.rgb = pickingColor;\n    }\n  } else {\n    // Do the comparison with selected item color in vertex shader as it should mean fewer compares\n    picking_vRGBcolor_Avalid.a = float(isVertexHighlighted(pickingColor));\n  }\n}\n\nvoid picking_setPickingAttribute(float value) {\n  if (bool(picking.isAttribute)) {\n    picking_vRGBcolor_Avalid.r = value;\n  }\n}\n\nvoid picking_setPickingAttribute(vec2 value) {\n  if (bool(picking.isAttribute)) {\n    picking_vRGBcolor_Avalid.rg = value;\n  }\n}\n\nvoid picking_setPickingAttribute(vec3 value) {\n  if (bool(picking.isAttribute)) {\n    picking_vRGBcolor_Avalid.rgb = value;\n  }\n}\n`;\nconst fs = /* glsl */ `\\\nuniform pickingUniforms {\n  float isActive;\n  float isAttribute;\n  float isHighlightActive;\n  float useFloatColors;\n  vec3 highlightedObjectColor;\n  vec4 highlightColor;\n} picking;\n\nin vec4 picking_vRGBcolor_Avalid;\n\n/*\n * Returns highlight color if this item is selected.\n */\nvec4 picking_filterHighlightColor(vec4 color) {\n  // If we are still picking, we don't highlight\n  if (picking.isActive > 0.5) {\n    return color;\n  }\n\n  bool selected = bool(picking_vRGBcolor_Avalid.a);\n\n  if (selected) {\n    // Blend in highlight color based on its alpha value\n    float highLightAlpha = picking.highlightColor.a;\n    float blendedAlpha = highLightAlpha + color.a * (1.0 - highLightAlpha);\n    float highLightRatio = highLightAlpha / blendedAlpha;\n\n    vec3 blendedRGB = mix(color.rgb, picking.highlightColor.rgb, highLightRatio);\n    return vec4(blendedRGB, blendedAlpha);\n  } else {\n    return color;\n  }\n}\n\n/*\n * Returns picking color if picking enabled else unmodified argument.\n */\nvec4 picking_filterPickingColor(vec4 color) {\n  if (bool(picking.isActive)) {\n    if (picking_vRGBcolor_Avalid.a == 0.0) {\n      discard;\n    }\n    return picking_vRGBcolor_Avalid;\n  }\n  return color;\n}\n\n/*\n * Returns picking color if picking is enabled if not\n * highlight color if this item is selected, otherwise unmodified argument.\n */\nvec4 picking_filterColor(vec4 color) {\n  vec4 highlightColor = picking_filterHighlightColor(color);\n  return picking_filterPickingColor(highlightColor);\n}\n`;\n/**\n * Provides support for color-coding-based picking and highlighting.\n * In particular, supports picking a specific instance in an instanced\n * draw call and highlighting an instance based on its picking color,\n * and correspondingly, supports picking and highlighting groups of\n * primitives with the same picking color in non-instanced draw-calls\n */\nexport const picking = {\n    props: {},\n    uniforms: {},\n    name: 'picking',\n    uniformTypes: {\n        isActive: 'f32',\n        isAttribute: 'f32',\n        isHighlightActive: 'f32',\n        useFloatColors: 'f32',\n        highlightedObjectColor: 'vec3<f32>',\n        highlightColor: 'vec4<f32>'\n    },\n    defaultUniforms: {\n        isActive: false,\n        isAttribute: false,\n        isHighlightActive: false,\n        useFloatColors: true,\n        highlightedObjectColor: [0, 0, 0],\n        highlightColor: DEFAULT_HIGHLIGHT_COLOR\n    },\n    vs,\n    fs,\n    getUniforms\n};\nfunction getUniforms(opts = {}, prevUniforms) {\n    const uniforms = {};\n    if (opts.highlightedObjectColor === undefined) {\n        // Unless highlightedObjectColor explicitly null or set, do not update state\n    }\n    else if (opts.highlightedObjectColor === null) {\n        uniforms.isHighlightActive = false;\n    }\n    else {\n        uniforms.isHighlightActive = true;\n        const highlightedObjectColor = opts.highlightedObjectColor.slice(0, 3);\n        uniforms.highlightedObjectColor = highlightedObjectColor;\n    }\n    if (opts.highlightColor) {\n        const color = Array.from(opts.highlightColor, x => x / 255);\n        if (!Number.isFinite(color[3])) {\n            color[3] = 1;\n        }\n        uniforms.highlightColor = color;\n    }\n    if (opts.isActive !== undefined) {\n        uniforms.isActive = Boolean(opts.isActive);\n        uniforms.isAttribute = Boolean(opts.isAttribute);\n    }\n    if (opts.useFloatColors !== undefined) {\n        uniforms.useFloatColors = Boolean(opts.useFloatColors);\n    }\n    return uniforms;\n}\n//# sourceMappingURL=picking.js.map","// luma.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\nexport const lightingUniformsGLSL = /* glsl */ `\\\nprecision highp int;\n\n// #if (defined(SHADER_TYPE_FRAGMENT) && defined(LIGHTING_FRAGMENT)) || (defined(SHADER_TYPE_VERTEX) && defined(LIGHTING_VERTEX))\nstruct AmbientLight {\n  vec3 color;\n};\n\nstruct PointLight {\n  vec3 color;\n  vec3 position;\n  vec3 attenuation; // 2nd order x:Constant-y:Linear-z:Exponential\n};\n\nstruct DirectionalLight {\n  vec3 color;\n  vec3 direction;\n};\n\nuniform lightingUniforms {\n  int enabled;\n  int lightType;\n\n  int directionalLightCount;\n  int pointLightCount;\n\n  vec3 ambientColor;\n\n  vec3 lightColor0;\n  vec3 lightPosition0;\n  vec3 lightDirection0;\n  vec3 lightAttenuation0;\n\n  vec3 lightColor1;\n  vec3 lightPosition1;\n  vec3 lightDirection1;\n  vec3 lightAttenuation1;\n\n  vec3 lightColor2;\n  vec3 lightPosition2;\n  vec3 lightDirection2;\n  vec3 lightAttenuation2;\n} lighting;\n\nPointLight lighting_getPointLight(int index) {\n  switch (index) {\n    case 0:\n      return PointLight(lighting.lightColor0, lighting.lightPosition0, lighting.lightAttenuation0);\n    case 1:\n      return PointLight(lighting.lightColor1, lighting.lightPosition1, lighting.lightAttenuation1);\n    case 2:\n    default:  \n      return PointLight(lighting.lightColor2, lighting.lightPosition2, lighting.lightAttenuation2);\n  }\n}\n\nDirectionalLight lighting_getDirectionalLight(int index) {\n  switch (index) {\n    case 0:\n      return DirectionalLight(lighting.lightColor0, lighting.lightDirection0);\n    case 1:\n      return DirectionalLight(lighting.lightColor1, lighting.lightDirection1);\n    case 2:\n    default:   \n      return DirectionalLight(lighting.lightColor2, lighting.lightDirection2);\n  }\n} \n\nfloat getPointLightAttenuation(PointLight pointLight, float distance) {\n  return pointLight.attenuation.x\n       + pointLight.attenuation.y * distance\n       + pointLight.attenuation.z * distance * distance;\n}\n\n// #endif\n`;\n//# sourceMappingURL=lighting-uniforms-glsl.js.map","// luma.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\nexport const lightingUniformsWGSL = /* wgsl */ `\\\n// #if (defined(SHADER_TYPE_FRAGMENT) && defined(LIGHTING_FRAGMENT)) || (defined(SHADER_TYPE_VERTEX) && defined(LIGHTING_VERTEX))\nstruct AmbientLight {\n  color: vec3<f32>,\n};\n\nstruct PointLight {\n  color: vec3<f32>,\n  position: vec3<f32>,\n  attenuation: vec3<f32>, // 2nd order x:Constant-y:Linear-z:Exponential\n};\n\nstruct DirectionalLight {\n  color: vec3<f32>,\n  direction: vec3<f32>,\n};\n\nstruct lightingUniforms {\n  enabled: i32,\n  pointLightCount: i32,\n  directionalLightCount: i32,\n\n  ambientColor: vec3<f32>,\n\n  // TODO - support multiple lights by uncommenting arrays below\n  lightType: i32,\n  lightColor: vec3<f32>,\n  lightDirection: vec3<f32>,\n  lightPosition: vec3<f32>,\n  lightAttenuation: vec3<f32>,\n\n  // AmbientLight ambientLight;\n  // PointLight pointLight[MAX_LIGHTS];\n  // DirectionalLight directionalLight[MAX_LIGHTS];\n};\n\n// Binding 0:1 is reserved for lighting (Note: could go into separate bind group as it is stable across draw calls)\n@binding(1) @group(0) var<uniform> lighting : lightingUniforms;\n\nfn lighting_getPointLight(index: i32) -> PointLight {\n  return PointLight(lighting.lightColor, lighting.lightPosition, lighting.lightAttenuation);\n}\n\nfn lighting_getDirectionalLight(index: i32) -> DirectionalLight {\n  return DirectionalLight(lighting.lightColor, lighting.lightDirection);\n} \n\nfn getPointLightAttenuation(pointLight: PointLight, distance: f32) -> f32 {\n  return pointLight.attenuation.x\n       + pointLight.attenuation.y * distance\n       + pointLight.attenuation.z * distance * distance;\n}\n`;\n//# sourceMappingURL=lighting-uniforms-wgsl.js.map","// luma.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\nimport { log } from '@luma.gl/core';\nimport { lightingUniformsGLSL } from \"./lighting-uniforms-glsl.js\";\nimport { lightingUniformsWGSL } from \"./lighting-uniforms-wgsl.js\";\n/** Max number of supported lights (in addition to ambient light */\nconst MAX_LIGHTS = 3;\n/** Whether to divide */\nconst COLOR_FACTOR = 255.0;\n/** Shader type field for lights */\n// eslint-disable-next-line no-shadow\nexport var LIGHT_TYPE;\n(function (LIGHT_TYPE) {\n    LIGHT_TYPE[LIGHT_TYPE[\"POINT\"] = 0] = \"POINT\";\n    LIGHT_TYPE[LIGHT_TYPE[\"DIRECTIONAL\"] = 1] = \"DIRECTIONAL\";\n})(LIGHT_TYPE || (LIGHT_TYPE = {}));\n/** UBO ready lighting module */\nexport const lighting = {\n    props: {},\n    uniforms: {},\n    name: 'lighting',\n    defines: {\n        MAX_LIGHTS\n    },\n    uniformTypes: {\n        enabled: 'i32',\n        lightType: 'i32',\n        directionalLightCount: 'i32',\n        pointLightCount: 'i32',\n        ambientLightColor: 'vec3<f32>',\n        // TODO define as arrays once we have appropriate uniformTypes\n        lightColor0: 'vec3<f32>',\n        lightPosition0: 'vec3<f32>',\n        // TODO - could combine direction and attenuation\n        lightDirection0: 'vec3<f32>',\n        lightAttenuation0: 'vec3<f32>',\n        lightColor1: 'vec3<f32>',\n        lightPosition1: 'vec3<f32>',\n        lightDirection1: 'vec3<f32>',\n        lightAttenuation1: 'vec3<f32>',\n        lightColor2: 'vec3<f32>',\n        lightPosition2: 'vec3<f32>',\n        lightDirection2: 'vec3<f32>',\n        lightAttenuation2: 'vec3<f32>'\n    },\n    defaultUniforms: {\n        enabled: 1,\n        lightType: LIGHT_TYPE.POINT,\n        directionalLightCount: 0,\n        pointLightCount: 0,\n        ambientLightColor: [0.1, 0.1, 0.1],\n        lightColor0: [1, 1, 1],\n        lightPosition0: [1, 1, 2],\n        // TODO - could combine direction and attenuation\n        lightDirection0: [1, 1, 1],\n        lightAttenuation0: [1, 0, 0],\n        lightColor1: [1, 1, 1],\n        lightPosition1: [1, 1, 2],\n        lightDirection1: [1, 1, 1],\n        lightAttenuation1: [1, 0, 0],\n        lightColor2: [1, 1, 1],\n        lightPosition2: [1, 1, 2],\n        lightDirection2: [1, 1, 1],\n        lightAttenuation2: [1, 0, 0]\n    },\n    source: lightingUniformsWGSL,\n    vs: lightingUniformsGLSL,\n    fs: lightingUniformsGLSL,\n    getUniforms\n};\nfunction getUniforms(props, prevUniforms = {}) {\n    // Copy props so we can modify\n    props = props ? { ...props } : props;\n    // TODO legacy\n    if (!props) {\n        return { ...lighting.defaultUniforms };\n    }\n    // Support for array of lights. Type of light is detected by type field\n    if (props.lights) {\n        props = { ...props, ...extractLightTypes(props.lights), lights: undefined };\n    }\n    // Specify lights separately\n    const { ambientLight, pointLights, directionalLights } = props || {};\n    const hasLights = ambientLight ||\n        (pointLights && pointLights.length > 0) ||\n        (directionalLights && directionalLights.length > 0);\n    // TODO - this may not be the correct decision\n    if (!hasLights) {\n        return { ...lighting.defaultUniforms, enabled: 0 };\n    }\n    const uniforms = {\n        ...lighting.defaultUniforms,\n        ...prevUniforms,\n        ...getLightSourceUniforms({ ambientLight, pointLights, directionalLights })\n    };\n    if (props.enabled !== undefined) {\n        uniforms.enabled = props.enabled ? 1 : 0;\n    }\n    return uniforms;\n}\nfunction getLightSourceUniforms({ ambientLight, pointLights = [], directionalLights = [] }) {\n    const lightSourceUniforms = {};\n    lightSourceUniforms.ambientLightColor = convertColor(ambientLight);\n    let currentLight = 0;\n    for (const pointLight of pointLights) {\n        lightSourceUniforms.lightType = LIGHT_TYPE.POINT;\n        const i = currentLight;\n        lightSourceUniforms[`lightColor${i}`] = convertColor(pointLight);\n        lightSourceUniforms[`lightPosition${i}`] = pointLight.position;\n        lightSourceUniforms[`lightAttenuation${i}`] = pointLight.attenuation || [1, 0, 0];\n        currentLight++;\n    }\n    for (const directionalLight of directionalLights) {\n        lightSourceUniforms.lightType = LIGHT_TYPE.DIRECTIONAL;\n        const i = currentLight;\n        lightSourceUniforms[`lightColor${i}`] = convertColor(directionalLight);\n        lightSourceUniforms[`lightDirection${i}`] = directionalLight.direction;\n        currentLight++;\n    }\n    if (currentLight > MAX_LIGHTS) {\n        log.warn('MAX_LIGHTS exceeded')();\n    }\n    lightSourceUniforms.directionalLightCount = directionalLights.length;\n    lightSourceUniforms.pointLightCount = pointLights.length;\n    return lightSourceUniforms;\n}\nfunction extractLightTypes(lights) {\n    const lightSources = { pointLights: [], directionalLights: [] };\n    for (const light of lights || []) {\n        switch (light.type) {\n            case 'ambient':\n                // Note: Only uses last ambient light\n                // TODO - add ambient light sources on CPU?\n                lightSources.ambientLight = light;\n                break;\n            case 'directional':\n                lightSources.directionalLights?.push(light);\n                break;\n            case 'point':\n                lightSources.pointLights?.push(light);\n                break;\n            default:\n            // eslint-disable-next-line\n            // console.warn(light.type);\n        }\n    }\n    return lightSources;\n}\n/** Take color 0-255 and intensity as input and output 0.0-1.0 range */\nfunction convertColor(colorDef = {}) {\n    const { color = [0, 0, 0], intensity = 1.0 } = colorDef;\n    return color.map(component => (component * intensity) / COLOR_FACTOR);\n}\n//# sourceMappingURL=lighting.js.map","// luma.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\nexport const PHONG_VS = /* glsl */ `\\\nuniform phongMaterialUniforms {\n  uniform float ambient;\n  uniform float diffuse;\n  uniform float shininess;\n  uniform vec3  specularColor;\n} material;\n`;\nexport const PHONG_FS = /* glsl */ `\\\nuniform phongMaterialUniforms {\n  uniform float ambient;\n  uniform float diffuse;\n  uniform float shininess;\n  uniform vec3  specularColor;\n} material;\n\nvec3 lighting_getLightColor(vec3 surfaceColor, vec3 light_direction, vec3 view_direction, vec3 normal_worldspace, vec3 color) {\n  vec3 halfway_direction = normalize(light_direction + view_direction);\n  float lambertian = dot(light_direction, normal_worldspace);\n  float specular = 0.0;\n  if (lambertian > 0.0) {\n    float specular_angle = max(dot(normal_worldspace, halfway_direction), 0.0);\n    specular = pow(specular_angle, material.shininess);\n  }\n  lambertian = max(lambertian, 0.0);\n  return (lambertian * material.diffuse * surfaceColor + specular * material.specularColor) * color;\n}\n\nvec3 lighting_getLightColor(vec3 surfaceColor, vec3 cameraPosition, vec3 position_worldspace, vec3 normal_worldspace) {\n  vec3 lightColor = surfaceColor;\n\n  if (lighting.enabled == 0) {\n    return lightColor;\n  }\n\n  vec3 view_direction = normalize(cameraPosition - position_worldspace);\n  lightColor = material.ambient * surfaceColor * lighting.ambientColor;\n\n  for (int i = 0; i < lighting.pointLightCount; i++) {\n    PointLight pointLight = lighting_getPointLight(i);\n    vec3 light_position_worldspace = pointLight.position;\n    vec3 light_direction = normalize(light_position_worldspace - position_worldspace);\n    float light_attenuation = getPointLightAttenuation(pointLight, distance(light_position_worldspace, position_worldspace));\n    lightColor += lighting_getLightColor(surfaceColor, light_direction, view_direction, normal_worldspace, pointLight.color / light_attenuation);\n  }\n\n  int totalLights = min(MAX_LIGHTS, lighting.pointLightCount + lighting.directionalLightCount);\n  for (int i = lighting.pointLightCount; i < totalLights; i++) {\n    DirectionalLight directionalLight = lighting_getDirectionalLight(i);\n    lightColor += lighting_getLightColor(surfaceColor, -directionalLight.direction, view_direction, normal_worldspace, directionalLight.color);\n  }\n  \n  return lightColor;\n}\n`;\n//# sourceMappingURL=phong-shaders-glsl.js.map","// luma.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\nexport const PHONG_WGSL = /* wgsl */ `\\\nstruct phongMaterialUniforms {\n  ambient: f32,\n  diffuse: f32,\n  shininess: f32,\n  specularColor: vec3<f32>,\n};\n\n@binding(2) @group(0) var<uniform> phongMaterial : phongMaterialUniforms;\n\nfn lighting_getLightColor(surfaceColor: vec3<f32>, light_direction: vec3<f32>, view_direction: vec3<f32>, normal_worldspace: vec3<f32>, color: vec3<f32>) -> vec3<f32> {\n  let halfway_direction: vec3<f32> = normalize(light_direction + view_direction);\n  var lambertian: f32 = dot(light_direction, normal_worldspace);\n  var specular: f32 = 0.0;\n  if (lambertian > 0.0) {\n    let specular_angle = max(dot(normal_worldspace, halfway_direction), 0.0);\n    specular = pow(specular_angle, phongMaterial.shininess);\n  }\n  lambertian = max(lambertian, 0.0);\n  return (lambertian * phongMaterial.diffuse * surfaceColor + specular * phongMaterial.specularColor) * color;\n}\n\nfn lighting_getLightColor2(surfaceColor: vec3<f32>, cameraPosition: vec3<f32>, position_worldspace: vec3<f32>, normal_worldspace: vec3<f32>) -> vec3<f32> {\n  var lightColor: vec3<f32> = surfaceColor;\n\n  if (lighting.enabled == 0) {\n    return lightColor;\n  }\n\n  let view_direction: vec3<f32> = normalize(cameraPosition - position_worldspace);\n  lightColor = phongMaterial.ambient * surfaceColor * lighting.ambientColor;\n\n  if (lighting.lightType == 0) {\n    let pointLight: PointLight  = lighting_getPointLight(0);\n    let light_position_worldspace: vec3<f32> = pointLight.position;\n    let light_direction: vec3<f32> = normalize(light_position_worldspace - position_worldspace);\n    lightColor += lighting_getLightColor(surfaceColor, light_direction, view_direction, normal_worldspace, pointLight.color);\n  } else if (lighting.lightType == 1) {\n    var directionalLight: DirectionalLight = lighting_getDirectionalLight(0);\n    lightColor += lighting_getLightColor(surfaceColor, -directionalLight.direction, view_direction, normal_worldspace, directionalLight.color);\n  }\n  \n  return lightColor;\n  /*\n  for (int i = 0; i < MAX_LIGHTS; i++) {\n    if (i >= lighting.pointLightCount) {\n      break;\n    }\n    PointLight pointLight = lighting.pointLight[i];\n    vec3 light_position_worldspace = pointLight.position;\n    vec3 light_direction = normalize(light_position_worldspace - position_worldspace);\n    lightColor += lighting_getLightColor(surfaceColor, light_direction, view_direction, normal_worldspace, pointLight.color);\n  }\n\n  for (int i = 0; i < MAX_LIGHTS; i++) {\n    if (i >= lighting.directionalLightCount) {\n      break;\n    }\n    DirectionalLight directionalLight = lighting.directionalLight[i];\n    lightColor += lighting_getLightColor(surfaceColor, -directionalLight.direction, view_direction, normal_worldspace, directionalLight.color);\n  }\n  */\n}\n\nfn lighting_getSpecularLightColor(cameraPosition: vec3<f32>, position_worldspace: vec3<f32>, normal_worldspace: vec3<f32>) -> vec3<f32>{\n  var lightColor = vec3<f32>(0, 0, 0);\n  let surfaceColor = vec3<f32>(0, 0, 0);\n\n  if (lighting.enabled == 0) {\n    let view_direction = normalize(cameraPosition - position_worldspace);\n\n    switch (lighting.lightType) {\n      case 0, default: {\n        let pointLight: PointLight = lighting_getPointLight(0);\n        let light_position_worldspace: vec3<f32> = pointLight.position;\n        let light_direction: vec3<f32> = normalize(light_position_worldspace - position_worldspace);\n        lightColor += lighting_getLightColor(surfaceColor, light_direction, view_direction, normal_worldspace, pointLight.color);\n      }\n      case 1: {\n        let directionalLight: DirectionalLight = lighting_getDirectionalLight(0);\n        lightColor += lighting_getLightColor(surfaceColor, -directionalLight.direction, view_direction, normal_worldspace, directionalLight.color);\n      }\n    }\n  }\n  return lightColor;\n}\n`;\n// TODO - handle multiple lights\n/**\n    for (int i = 0; i < MAX_LIGHTS; i++) {\n      if (i >= lighting.pointLightCount) {\n        break;\n      }\n      PointLight pointLight = lighting_getPointLight(i);\n      vec3 light_position_worldspace = pointLight.position;\n      vec3 light_direction = normalize(light_position_worldspace - position_worldspace);\n      lightColor += lighting_getLightColor(surfaceColor, light_direction, view_direction, normal_worldspace, pointLight.color);\n    }\n\n    for (int i = 0; i < MAX_LIGHTS; i++) {\n      if (i >= lighting.directionalLightCount) {\n        break;\n      }\n      PointLight pointLight = lighting_getDirectionalLight(i);\n      lightColor += lighting_getLightColor(surfaceColor, -directionalLight.direction, view_direction, normal_worldspace, directionalLight.color);\n    }\n  }\n    /**\n    for (int i = 0; i < MAX_LIGHTS; i++) {\n      if (i >= lighting.pointLightCount) {\n        break;\n      }\n      PointLight pointLight = lighting_getPointLight(i);\n      vec3 light_position_worldspace = pointLight.position;\n      vec3 light_direction = normalize(light_position_worldspace - position_worldspace);\n      lightColor += lighting_getLightColor(surfaceColor, light_direction, view_direction, normal_worldspace, pointLight.color);\n    }\n\n    for (int i = 0; i < MAX_LIGHTS; i++) {\n      if (i >= lighting.directionalLightCount) {\n        break;\n      }\n      PointLight pointLight = lighting_getDirectionalLight(i);\n      lightColor += lighting_getLightColor(surfaceColor, -directionalLight.direction, view_direction, normal_worldspace, directionalLight.color);\n    }\n  }\n  */\n//# sourceMappingURL=phong-shaders-wgsl.js.map","// luma.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\nimport { lighting } from \"../lights/lighting.js\";\nimport { PHONG_VS, PHONG_FS } from \"../phong-material/phong-shaders-glsl.js\";\nimport { PHONG_WGSL } from \"../phong-material/phong-shaders-wgsl.js\";\n/** In Gouraud shading, color is calculated for each triangle vertex normal, and then color is interpolated colors across the triangle */\nexport const gouraudMaterial = {\n    props: {},\n    name: 'gouraudMaterial',\n    // Note these are switched between phong and gouraud\n    vs: PHONG_FS.replace('phongMaterial', 'gouraudMaterial'),\n    fs: PHONG_VS.replace('phongMaterial', 'gouraudMaterial'),\n    source: PHONG_WGSL.replaceAll('phongMaterial', 'gouraudMaterial'),\n    defines: {\n        LIGHTING_VERTEX: 1\n    },\n    dependencies: [lighting],\n    uniformTypes: {\n        ambient: 'f32',\n        diffuse: 'f32',\n        shininess: 'f32',\n        specularColor: 'vec3<f32>'\n    },\n    defaultUniforms: {\n        ambient: 0.35,\n        diffuse: 0.6,\n        shininess: 32,\n        specularColor: [0.15, 0.15, 0.15]\n    },\n    getUniforms(props) {\n        const uniforms = { ...props };\n        if (uniforms.specularColor) {\n            uniforms.specularColor = uniforms.specularColor.map(x => x / 255);\n        }\n        return { ...gouraudMaterial.defaultUniforms, ...uniforms };\n    }\n};\n//# sourceMappingURL=gouraud-material.js.map","// deck.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\nconst uniformBlock = `\\\nuniform layerUniforms {\n  uniform float opacity;\n} layer;\n`;\nexport const layerUniforms = {\n    name: 'layer',\n    vs: uniformBlock,\n    fs: uniformBlock,\n    getUniforms: (props) => {\n        return {\n            // apply gamma to opacity to make it visually \"linear\"\n            // TODO - v10: use raw opacity?\n            opacity: Math.pow(props.opacity, 1 / 2.2)\n        };\n    },\n    uniformTypes: {\n        opacity: 'f32'\n    }\n};\n//# sourceMappingURL=layer-uniforms.js.map","// deck.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\nconst source = /* wgsl */ `\\\nconst SMOOTH_EDGE_RADIUS: f32 = 0.5;\n\nstruct VertexGeometry {\n  position: vec4<f32>,\n  worldPosition: vec3<f32>,\n  worldPositionAlt: vec3<f32>,\n  normal: vec3<f32>,\n  uv: vec2<f32>,\n  pickingColor: vec3<f32>,\n};\n\nvar<private> geometry_: VertexGeometry = VertexGeometry(\n  vec4<f32>(0.0, 0.0, 1.0, 0.0),\n  vec3<f32>(0.0, 0.0, 0.0),\n  vec3<f32>(0.0, 0.0, 0.0),\n  vec3<f32>(0.0, 0.0, 0.0),\n  vec2<f32>(0.0, 0.0),\n  vec3<f32>(0.0, 0.0, 0.0)\n);\n\nstruct FragmentGeometry {\n  uv: vec2<f32>,\n};\n\nvar<private> fragmentGeometry: FragmentGeometry;\n\nfn smoothedge(edge: f32, x: f32) -> f32 {\n  return smoothstep(edge - SMOOTH_EDGE_RADIUS, edge + SMOOTH_EDGE_RADIUS, x);\n}\n`;\nconst defines = '#define SMOOTH_EDGE_RADIUS 0.5';\nconst vs = /* glsl */ `\\\n${defines}\n\nstruct VertexGeometry {\n  vec4 position;\n  vec3 worldPosition;\n  vec3 worldPositionAlt;\n  vec3 normal;\n  vec2 uv;\n  vec3 pickingColor;\n} geometry = VertexGeometry(\n  vec4(0.0, 0.0, 1.0, 0.0),\n  vec3(0.0),\n  vec3(0.0),\n  vec3(0.0),\n  vec2(0.0),\n  vec3(0.0)\n);\n`;\nconst fs = /* glsl */ `\\\n${defines}\n\nstruct FragmentGeometry {\n  vec2 uv;\n} geometry;\n\nfloat smoothedge(float edge, float x) {\n  return smoothstep(edge - SMOOTH_EDGE_RADIUS, edge + SMOOTH_EDGE_RADIUS, x);\n}\n`;\nexport default {\n    name: 'geometry',\n    source,\n    vs,\n    fs\n};\n//# sourceMappingURL=geometry.js.map","// deck.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\nimport { COORDINATE_SYSTEM, PROJECTION_MODE, UNIT } from \"../../lib/constants.js\";\n// We are generating these from the js code in constants.js\nconst COORDINATE_SYSTEM_WGSL_CONSTANTS = Object.keys(COORDINATE_SYSTEM)\n    .map(key => `const COORDINATE_SYSTEM_${key}: i32 = ${COORDINATE_SYSTEM[key]};`)\n    .join('');\nconst PROJECTION_MODE_WGSL_CONSTANTS = Object.keys(PROJECTION_MODE)\n    .map(key => `const PROJECTION_MODE_${key}: i32 = ${PROJECTION_MODE[key]};`)\n    .join('');\nconst UNIT_WGSL_CONSTANTS = Object.keys(UNIT)\n    .map(key => `const UNIT_${key.toUpperCase()}: i32 = ${UNIT[key]};`)\n    .join('');\nexport const projectWGSLHeader = /* wgsl */ `\\\n${COORDINATE_SYSTEM_WGSL_CONSTANTS}\n${PROJECTION_MODE_WGSL_CONSTANTS}\n${UNIT_WGSL_CONSTANTS}\n\nconst TILE_SIZE: f32 = 512.0;\nconst PI: f32 = 3.1415926536;\nconst WORLD_SCALE: f32 = TILE_SIZE / (PI * 2.0);\nconst ZERO_64_LOW: vec3<f32> = vec3<f32>(0.0, 0.0, 0.0);\nconst EARTH_RADIUS: f32 = 6370972.0; // meters\nconst GLOBE_RADIUS: f32 = 256.0;\n\n// -----------------------------------------------------------------------------\n// Uniform block (converted from GLSL uniform block)\n// -----------------------------------------------------------------------------\nstruct ProjectUniforms {\n  wrapLongitude: i32,\n  coordinateSystem: i32,\n  commonUnitsPerMeter: vec3<f32>,\n  projectionMode: i32,\n  scale: f32,\n  commonUnitsPerWorldUnit: vec3<f32>,\n  commonUnitsPerWorldUnit2: vec3<f32>,\n  center: vec4<f32>,\n  modelMatrix: mat4x4<f32>,\n  viewProjectionMatrix: mat4x4<f32>,\n  viewportSize: vec2<f32>,\n  devicePixelRatio: f32,\n  focalDistance: f32,\n  cameraPosition: vec3<f32>,\n  coordinateOrigin: vec3<f32>,\n  commonOrigin: vec3<f32>,\n  pseudoMeters: i32,\n};\n\n@group(0) @binding(0)\nvar<uniform> project: ProjectUniforms;\n\n// -----------------------------------------------------------------------------\n// Geometry data\n// (In your GLSL code, \"geometry\" was assumed to be available globally. In WGSL,\n// you might supply this via vertex attributes or a uniform. Here we define a\n// uniform struct for demonstration.)\n// -----------------------------------------------------------------------------\n\n// Structure to carry additional geometry data used by deck.gl filters.\nstruct Geometry {\n  worldPosition: vec3<f32>,\n  worldPositionAlt: vec3<f32>,\n  position: vec4<f32>,\n  uv: vec2<f32>,\n  pickingColor: vec3<f32>,\n};\n\n// @group(0) @binding(1)\nvar<private> geometry: Geometry;\n`;\nexport const projectWGSL = /* wgsl */ `\\\n${projectWGSLHeader}\n\n// -----------------------------------------------------------------------------\n// Functions\n// -----------------------------------------------------------------------------\n\n// Returns an adjustment factor for commonUnitsPerMeter\nfn _project_size_at_latitude(lat: f32) -> f32 {\n  let y = clamp(lat, -89.9, 89.9);\n  return 1.0 / cos(radians(y));\n}\n\n// Overloaded version: scales a value in meters at a given latitude.\nfn _project_size_at_latitude_m(meters: f32, lat: f32) -> f32 {\n  return meters * project.commonUnitsPerMeter.z * _project_size_at_latitude(lat);\n}\n\n// Computes a non-linear scale factor based on geometry.\n// (Note: This function relies on \"geometry\" being provided.)\nfn project_size() -> f32 {\n  if (project.projectionMode == PROJECTION_MODE_WEB_MERCATOR &&\n      project.coordinateSystem == COORDINATE_SYSTEM_LNGLAT &&\n      project.pseudoMeters == 0) {\n    if (geometry.position.w == 0.0) {\n      return _project_size_at_latitude(geometry.worldPosition.y);\n    }\n    let y: f32 = geometry.position.y / TILE_SIZE * 2.0 - 1.0;\n    let y2 = y * y;\n    let y4 = y2 * y2;\n    let y6 = y4 * y2;\n    return 1.0 + 4.9348 * y2 + 4.0587 * y4 + 1.5642 * y6;\n  }\n  return 1.0;\n}\n\n// Overloads to scale offsets (meters to world units)\nfn project_size_float(meters: f32) -> f32 {\n  return meters * project.commonUnitsPerMeter.z * project_size();\n}\n\nfn project_size_vec2(meters: vec2<f32>) -> vec2<f32> {\n  return meters * project.commonUnitsPerMeter.xy * project_size();\n}\n\nfn project_size_vec3(meters: vec3<f32>) -> vec3<f32> {\n  return meters * project.commonUnitsPerMeter * project_size();\n}\n\nfn project_size_vec4(meters: vec4<f32>) -> vec4<f32> {\n  return vec4<f32>(meters.xyz * project.commonUnitsPerMeter, meters.w);\n}\n\n// Returns a rotation matrix aligning the z‑axis with the given up vector.\nfn project_get_orientation_matrix(up: vec3<f32>) -> mat3x3<f32> {\n  let uz = normalize(up);\n  let ux = select(\n    vec3<f32>(1.0, 0.0, 0.0),\n    normalize(vec3<f32>(uz.y, -uz.x, 0.0)),\n    abs(uz.z) == 1.0\n  );\n  let uy = cross(uz, ux);\n  return mat3x3<f32>(ux, uy, uz);\n}\n\n// Since WGSL does not support \"out\" parameters, we return a struct.\nstruct RotationResult {\n  needsRotation: bool,\n  transform: mat3x3<f32>,\n};\n\nfn project_needs_rotation(commonPosition: vec3<f32>) -> RotationResult {\n  if (project.projectionMode == PROJECTION_MODE_GLOBE) {\n    return RotationResult(true, project_get_orientation_matrix(commonPosition));\n  } else {\n    return RotationResult(false, mat3x3<f32>());  // identity alternative if needed\n  };\n}\n\n// Projects a normal vector from the current coordinate system to world space.\nfn project_normal(vector: vec3<f32>) -> vec3<f32> {\n  let normal_modelspace = project.modelMatrix * vec4<f32>(vector, 0.0);\n  var n = normalize(normal_modelspace.xyz * project.commonUnitsPerMeter);\n  let rotResult = project_needs_rotation(geometry.position.xyz);\n  if (rotResult.needsRotation) {\n    n = rotResult.transform * n;\n  }\n  return n;\n}\n\n// Applies a scale offset based on y-offset (dy)\nfn project_offset_(offset: vec4<f32>) -> vec4<f32> {\n  let dy: f32 = offset.y;\n  let commonUnitsPerWorldUnit = project.commonUnitsPerWorldUnit + project.commonUnitsPerWorldUnit2 * dy;\n  return vec4<f32>(offset.xyz * commonUnitsPerWorldUnit, offset.w);\n}\n\n// Projects lng/lat coordinates to a unit tile [0,1]\nfn project_mercator_(lnglat: vec2<f32>) -> vec2<f32> {\n  var x = lnglat.x;\n  if (project.wrapLongitude != 0) {\n    x = ((x + 180.0) % 360.0) - 180.0;\n  }\n  let y = clamp(lnglat.y, -89.9, 89.9);\n  return vec2<f32>(\n    radians(x) + PI,\n    PI + log(tan(PI * 0.25 + radians(y) * 0.5))\n  ) * WORLD_SCALE;\n}\n\n// Projects lng/lat/z coordinates for a globe projection.\nfn project_globe_(lnglatz: vec3<f32>) -> vec3<f32> {\n  let lambda = radians(lnglatz.x);\n  let phi = radians(lnglatz.y);\n  let cosPhi = cos(phi);\n  let D = (lnglatz.z / EARTH_RADIUS + 1.0) * GLOBE_RADIUS;\n  return vec3<f32>(\n    sin(lambda) * cosPhi,\n    -cos(lambda) * cosPhi,\n    sin(phi)\n  ) * D;\n}\n\n// Projects positions (with an optional 64-bit low part) from the input\n// coordinate system to the common space.\nfn project_position_vec4_f64(position: vec4<f32>, position64Low: vec3<f32>) -> vec4<f32> {\n  var position_world = project.modelMatrix * position;\n\n  // Work around for a Mac+NVIDIA bug:\n  if (project.projectionMode == PROJECTION_MODE_WEB_MERCATOR) {\n    if (project.coordinateSystem == COORDINATE_SYSTEM_LNGLAT) {\n      return vec4<f32>(\n        project_mercator_(position_world.xy),\n        _project_size_at_latitude_m(position_world.z, position_world.y),\n        position_world.w\n      );\n    }\n    if (project.coordinateSystem == COORDINATE_SYSTEM_CARTESIAN) {\n      position_world = vec4f(position_world.xyz + project.coordinateOrigin, position_world.w);\n    }\n  }\n  if (project.projectionMode == PROJECTION_MODE_GLOBE) {\n    if (project.coordinateSystem == COORDINATE_SYSTEM_LNGLAT) {\n      return vec4<f32>(\n        project_globe_(position_world.xyz),\n        position_world.w\n      );\n    }\n  }\n  if (project.projectionMode == PROJECTION_MODE_WEB_MERCATOR_AUTO_OFFSET) {\n    if (project.coordinateSystem == COORDINATE_SYSTEM_LNGLAT) {\n      if (abs(position_world.y - project.coordinateOrigin.y) > 0.25) {\n        return vec4<f32>(\n          project_mercator_(position_world.xy) - project.commonOrigin.xy,\n          project_size_float(position_world.z),\n          position_world.w\n        );\n      }\n    }\n  }\n  if (project.projectionMode == PROJECTION_MODE_IDENTITY ||\n      (project.projectionMode == PROJECTION_MODE_WEB_MERCATOR_AUTO_OFFSET &&\n       (project.coordinateSystem == COORDINATE_SYSTEM_LNGLAT ||\n        project.coordinateSystem == COORDINATE_SYSTEM_CARTESIAN))) {\n    position_world = vec4f(position_world.xyz - project.coordinateOrigin, position_world.w);\n  }\n\n  return project_offset_(position_world) +\n         project_offset_(project.modelMatrix * vec4<f32>(position64Low, 0.0));\n}\n\n// Overloaded versions for different input types.\nfn project_position_vec4_f32(position: vec4<f32>) -> vec4<f32> {\n  return project_position_vec4_f64(position, ZERO_64_LOW);\n}\n\nfn project_position_vec3_f64(position: vec3<f32>, position64Low: vec3<f32>) -> vec3<f32> {\n  let projected_position = project_position_vec4_f64(vec4<f32>(position, 1.0), position64Low);\n  return projected_position.xyz;\n}\n\nfn project_position_vec3_f32(position: vec3<f32>) -> vec3<f32> {\n  let projected_position = project_position_vec4_f64(vec4<f32>(position, 1.0), ZERO_64_LOW);\n  return projected_position.xyz;\n}\n\nfn project_position_vec2_f32(position: vec2<f32>) -> vec2<f32> {\n  let projected_position = project_position_vec4_f64(vec4<f32>(position, 0.0, 1.0), ZERO_64_LOW);\n  return projected_position.xy;\n}\n\n// Transforms a common space position to clip space.\nfn project_common_position_to_clipspace_with_projection(position: vec4<f32>, viewProjectionMatrix: mat4x4<f32>, center: vec4<f32>) -> vec4<f32> {\n  return viewProjectionMatrix * position + center;\n}\n\n// Uses the project viewProjectionMatrix and center.\nfn project_common_position_to_clipspace(position: vec4<f32>) -> vec4<f32> {\n  return project_common_position_to_clipspace_with_projection(position, project.viewProjectionMatrix, project.center);\n}\n\n// Returns a clip space offset corresponding to a given number of screen pixels.\nfn project_pixel_size_to_clipspace(pixels: vec2<f32>) -> vec2<f32> {\n  let offset = pixels / project.viewportSize * project.devicePixelRatio * 2.0;\n  return offset * project.focalDistance;\n}\n\nfn project_meter_size_to_pixel(meters: f32) -> f32 {\n  return project_size_float(meters) * project.scale;\n}\n\nfn project_unit_size_to_pixel(size: f32, unit: i32) -> f32 {\n  if (unit == UNIT_METERS) {\n    return project_meter_size_to_pixel(size);\n  } else if (unit == UNIT_COMMON) {\n    return size * project.scale;\n  }\n  // UNIT_PIXELS: no scaling applied.\n  return size;\n}\n\nfn project_pixel_size_float(pixels: f32) -> f32 {\n  return pixels / project.scale;\n}\n\nfn project_pixel_size_vec2(pixels: vec2<f32>) -> vec2<f32> {\n  return pixels / project.scale;\n}\n`;\n//# sourceMappingURL=project.wgsl.js.map","// deck.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\nimport { COORDINATE_SYSTEM, PROJECTION_MODE, UNIT } from \"../../lib/constants.js\";\n// We are generating these from the js code in constants.js\nconst COORDINATE_SYSTEM_GLSL_CONSTANTS = Object.keys(COORDINATE_SYSTEM)\n    .map(key => `const int COORDINATE_SYSTEM_${key} = ${COORDINATE_SYSTEM[key]};`)\n    .join('');\nconst PROJECTION_MODE_GLSL_CONSTANTS = Object.keys(PROJECTION_MODE)\n    .map(key => `const int PROJECTION_MODE_${key} = ${PROJECTION_MODE[key]};`)\n    .join('');\nconst UNIT_GLSL_CONSTANTS = Object.keys(UNIT)\n    .map(key => `const int UNIT_${key.toUpperCase()} = ${UNIT[key]};`)\n    .join('');\nexport const projectGLSL = /* glsl */ `\\\n${COORDINATE_SYSTEM_GLSL_CONSTANTS}\n${PROJECTION_MODE_GLSL_CONSTANTS}\n${UNIT_GLSL_CONSTANTS}\nuniform projectUniforms {\nbool wrapLongitude;\nint coordinateSystem;\nvec3 commonUnitsPerMeter;\nint projectionMode;\nfloat scale;\nvec3 commonUnitsPerWorldUnit;\nvec3 commonUnitsPerWorldUnit2;\nvec4 center;\nmat4 modelMatrix;\nmat4 viewProjectionMatrix;\nvec2 viewportSize;\nfloat devicePixelRatio;\nfloat focalDistance;\nvec3 cameraPosition;\nvec3 coordinateOrigin;\nvec3 commonOrigin;\nbool pseudoMeters;\n} project;\nconst float TILE_SIZE = 512.0;\nconst float PI = 3.1415926536;\nconst float WORLD_SCALE = TILE_SIZE / (PI * 2.0);\nconst vec3 ZERO_64_LOW = vec3(0.0);\nconst float EARTH_RADIUS = 6370972.0;\nconst float GLOBE_RADIUS = 256.0;\nfloat project_size_at_latitude(float lat) {\nfloat y = clamp(lat, -89.9, 89.9);\nreturn 1.0 / cos(radians(y));\n}\nfloat project_size() {\nif (project.projectionMode == PROJECTION_MODE_WEB_MERCATOR &&\nproject.coordinateSystem == COORDINATE_SYSTEM_LNGLAT &&\nproject.pseudoMeters == false) {\nif (geometry.position.w == 0.0) {\nreturn project_size_at_latitude(geometry.worldPosition.y);\n}\nfloat y = geometry.position.y / TILE_SIZE * 2.0 - 1.0;\nfloat y2 = y * y;\nfloat y4 = y2 * y2;\nfloat y6 = y4 * y2;\nreturn 1.0 + 4.9348 * y2 + 4.0587 * y4 + 1.5642 * y6;\n}\nreturn 1.0;\n}\nfloat project_size_at_latitude(float meters, float lat) {\nreturn meters * project.commonUnitsPerMeter.z * project_size_at_latitude(lat);\n}\nfloat project_size(float meters) {\nreturn meters * project.commonUnitsPerMeter.z * project_size();\n}\nvec2 project_size(vec2 meters) {\nreturn meters * project.commonUnitsPerMeter.xy * project_size();\n}\nvec3 project_size(vec3 meters) {\nreturn meters * project.commonUnitsPerMeter * project_size();\n}\nvec4 project_size(vec4 meters) {\nreturn vec4(meters.xyz * project.commonUnitsPerMeter, meters.w);\n}\nmat3 project_get_orientation_matrix(vec3 up) {\nvec3 uz = normalize(up);\nvec3 ux = abs(uz.z) == 1.0 ? vec3(1.0, 0.0, 0.0) : normalize(vec3(uz.y, -uz.x, 0));\nvec3 uy = cross(uz, ux);\nreturn mat3(ux, uy, uz);\n}\nbool project_needs_rotation(vec3 commonPosition, out mat3 transform) {\nif (project.projectionMode == PROJECTION_MODE_GLOBE) {\ntransform = project_get_orientation_matrix(commonPosition);\nreturn true;\n}\nreturn false;\n}\nvec3 project_normal(vec3 vector) {\nvec4 normal_modelspace = project.modelMatrix * vec4(vector, 0.0);\nvec3 n = normalize(normal_modelspace.xyz * project.commonUnitsPerMeter);\nmat3 rotation;\nif (project_needs_rotation(geometry.position.xyz, rotation)) {\nn = rotation * n;\n}\nreturn n;\n}\nvec4 project_offset_(vec4 offset) {\nfloat dy = offset.y;\nvec3 commonUnitsPerWorldUnit = project.commonUnitsPerWorldUnit + project.commonUnitsPerWorldUnit2 * dy;\nreturn vec4(offset.xyz * commonUnitsPerWorldUnit, offset.w);\n}\nvec2 project_mercator_(vec2 lnglat) {\nfloat x = lnglat.x;\nif (project.wrapLongitude) {\nx = mod(x + 180., 360.0) - 180.;\n}\nfloat y = clamp(lnglat.y, -89.9, 89.9);\nreturn vec2(\nradians(x) + PI,\nPI + log(tan_fp32(PI * 0.25 + radians(y) * 0.5))\n) * WORLD_SCALE;\n}\nvec3 project_globe_(vec3 lnglatz) {\nfloat lambda = radians(lnglatz.x);\nfloat phi = radians(lnglatz.y);\nfloat cosPhi = cos(phi);\nfloat D = (lnglatz.z / EARTH_RADIUS + 1.0) * GLOBE_RADIUS;\nreturn vec3(\nsin(lambda) * cosPhi,\n-cos(lambda) * cosPhi,\nsin(phi)\n) * D;\n}\nvec4 project_position(vec4 position, vec3 position64Low) {\nvec4 position_world = project.modelMatrix * position;\nif (project.projectionMode == PROJECTION_MODE_WEB_MERCATOR) {\nif (project.coordinateSystem == COORDINATE_SYSTEM_LNGLAT) {\nreturn vec4(\nproject_mercator_(position_world.xy),\nproject_size_at_latitude(position_world.z, position_world.y),\nposition_world.w\n);\n}\nif (project.coordinateSystem == COORDINATE_SYSTEM_CARTESIAN) {\nposition_world.xyz += project.coordinateOrigin;\n}\n}\nif (project.projectionMode == PROJECTION_MODE_GLOBE) {\nif (project.coordinateSystem == COORDINATE_SYSTEM_LNGLAT) {\nreturn vec4(\nproject_globe_(position_world.xyz),\nposition_world.w\n);\n}\n}\nif (project.projectionMode == PROJECTION_MODE_WEB_MERCATOR_AUTO_OFFSET) {\nif (project.coordinateSystem == COORDINATE_SYSTEM_LNGLAT) {\nif (abs(position_world.y - project.coordinateOrigin.y) > 0.25) {\nreturn vec4(\nproject_mercator_(position_world.xy) - project.commonOrigin.xy,\nproject_size(position_world.z),\nposition_world.w\n);\n}\n}\n}\nif (project.projectionMode == PROJECTION_MODE_IDENTITY ||\n(project.projectionMode == PROJECTION_MODE_WEB_MERCATOR_AUTO_OFFSET &&\n(project.coordinateSystem == COORDINATE_SYSTEM_LNGLAT ||\nproject.coordinateSystem == COORDINATE_SYSTEM_CARTESIAN))) {\nposition_world.xyz -= project.coordinateOrigin;\n}\nreturn project_offset_(position_world) + project_offset_(project.modelMatrix * vec4(position64Low, 0.0));\n}\nvec4 project_position(vec4 position) {\nreturn project_position(position, ZERO_64_LOW);\n}\nvec3 project_position(vec3 position, vec3 position64Low) {\nvec4 projected_position = project_position(vec4(position, 1.0), position64Low);\nreturn projected_position.xyz;\n}\nvec3 project_position(vec3 position) {\nvec4 projected_position = project_position(vec4(position, 1.0), ZERO_64_LOW);\nreturn projected_position.xyz;\n}\nvec2 project_position(vec2 position) {\nvec4 projected_position = project_position(vec4(position, 0.0, 1.0), ZERO_64_LOW);\nreturn projected_position.xy;\n}\nvec4 project_common_position_to_clipspace(vec4 position, mat4 viewProjectionMatrix, vec4 center) {\nreturn viewProjectionMatrix * position + center;\n}\nvec4 project_common_position_to_clipspace(vec4 position) {\nreturn project_common_position_to_clipspace(position, project.viewProjectionMatrix, project.center);\n}\nvec2 project_pixel_size_to_clipspace(vec2 pixels) {\nvec2 offset = pixels / project.viewportSize * project.devicePixelRatio * 2.0;\nreturn offset * project.focalDistance;\n}\nfloat project_size_to_pixel(float meters) {\nreturn project_size(meters) * project.scale;\n}\nfloat project_size_to_pixel(float size, int unit) {\nif (unit == UNIT_METERS) return project_size_to_pixel(size);\nif (unit == UNIT_COMMON) return size * project.scale;\nreturn size;\n}\nfloat project_pixel_size(float pixels) {\nreturn pixels / project.scale;\n}\nvec2 project_pixel_size(vec2 pixels) {\nreturn pixels / project.scale;\n}\n`;\n//# sourceMappingURL=project.glsl.js.map","// deck.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\nimport { fp32 } from '@luma.gl/shadertools';\nimport geometry from \"../misc/geometry.js\";\nimport { getUniformsFromViewport } from \"./viewport-uniforms.js\";\nimport { projectWGSL } from \"./project.wgsl.js\";\nimport { projectGLSL } from \"./project.glsl.js\";\nconst INITIAL_MODULE_OPTIONS = {};\nfunction getUniforms(opts = INITIAL_MODULE_OPTIONS) {\n    if ('viewport' in opts) {\n        return getUniformsFromViewport(opts);\n    }\n    return {};\n}\nexport default {\n    name: 'project',\n    dependencies: [fp32, geometry],\n    source: projectWGSL,\n    vs: projectGLSL,\n    getUniforms,\n    uniformTypes: {\n        wrapLongitude: 'f32',\n        coordinateSystem: 'i32',\n        commonUnitsPerMeter: 'vec3<f32>',\n        projectionMode: 'i32',\n        scale: 'f32',\n        commonUnitsPerWorldUnit: 'vec3<f32>',\n        commonUnitsPerWorldUnit2: 'vec3<f32>',\n        center: 'vec4<f32>',\n        modelMatrix: 'mat4x4<f32>',\n        viewProjectionMatrix: 'mat4x4<f32>',\n        viewportSize: 'vec2<f32>',\n        devicePixelRatio: 'f32',\n        focalDistance: 'f32',\n        cameraPosition: 'vec3<f32>',\n        coordinateOrigin: 'vec3<f32>',\n        commonOrigin: 'vec3<f32>',\n        pseudoMeters: 'f32'\n    }\n    // @ts-ignore TODO v9.1\n};\n//# sourceMappingURL=project.js.map","// deck.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\nimport project from \"../project/project.js\";\nconst source = /* wgsl */ `\\\n// Define a structure to hold both the clip-space position and the common position.\nstruct ProjectResult {\n  clipPosition: vec4<f32>,\n  commonPosition: vec4<f32>,\n};\n\n// This function mimics the GLSL version with the 'out' parameter by returning both values.\nfn project_position_to_clipspace_and_commonspace(\n    position: vec3<f32>,\n    position64Low: vec3<f32>,\n    offset: vec3<f32>\n) -> ProjectResult {\n  // Compute the projected position.\n  let projectedPosition: vec3<f32> = project_position_vec3_f64(position, position64Low);\n\n  // Start with the provided offset.\n  var finalOffset: vec3<f32> = offset;\n\n  // Get whether a rotation is needed and the rotation matrix.\n  let rotationResult = project_needs_rotation(projectedPosition);\n\n  // If rotation is needed, update the offset.\n  if (rotationResult.needsRotation) {\n    finalOffset = rotationResult.transform * offset;\n  }\n\n  // Compute the common position.\n  let commonPosition: vec4<f32> = vec4<f32>(projectedPosition + finalOffset, 1.0);\n\n  // Convert to clip-space.\n  let clipPosition: vec4<f32> = project_common_position_to_clipspace(commonPosition);\n\n  return ProjectResult(clipPosition, commonPosition);\n}\n\n// A convenience overload that returns only the clip-space position.\nfn project_position_to_clipspace(\n    position: vec3<f32>,\n    position64Low: vec3<f32>,\n    offset: vec3<f32>\n) -> vec4<f32> {\n  return project_position_to_clipspace_and_commonspace(position, position64Low, offset).clipPosition;\n}\n`;\nconst vs = /* glsl */ `\\\nvec4 project_position_to_clipspace(\n  vec3 position, vec3 position64Low, vec3 offset, out vec4 commonPosition\n) {\n  vec3 projectedPosition = project_position(position, position64Low);\n  mat3 rotation;\n  if (project_needs_rotation(projectedPosition, rotation)) {\n    // offset is specified as ENU\n    // when in globe projection, rotate offset so that the ground alighs with the surface of the globe\n    offset = rotation * offset;\n  }\n  commonPosition = vec4(projectedPosition + offset, 1.0);\n  return project_common_position_to_clipspace(commonPosition);\n}\n\nvec4 project_position_to_clipspace(\n  vec3 position, vec3 position64Low, vec3 offset\n) {\n  vec4 commonPosition;\n  return project_position_to_clipspace(position, position64Low, offset, commonPosition);\n}\n`;\nexport default {\n    name: 'project32',\n    dependencies: [project],\n    source,\n    vs\n};\n//# sourceMappingURL=project32.js.map","// deck.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\nimport { COORDINATE_SYSTEM, PROJECTION_MODE } from \"../../lib/constants.js\";\nimport project from \"../project/project.js\";\nimport { Vector3, Matrix4 } from '@math.gl/core';\nimport memoize from \"../../utils/memoize.js\";\nimport { pixelsToWorld } from '@math.gl/web-mercator';\nconst uniformBlock = /* glsl */ `\nuniform shadowUniforms {\n  bool drawShadowMap;\n  bool useShadowMap;\n  vec4 color;\n  highp int lightId;\n  float lightCount;\n  mat4 viewProjectionMatrix0;\n  mat4 viewProjectionMatrix1;\n  vec4 projectCenter0;\n  vec4 projectCenter1;\n} shadow;\n`;\nconst vertex = /* glsl */ `\nconst int max_lights = 2;\n\nout vec3 shadow_vPosition[max_lights];\n\nvec4 shadow_setVertexPosition(vec4 position_commonspace) {\n  mat4 viewProjectionMatrices[max_lights];\n  viewProjectionMatrices[0] = shadow.viewProjectionMatrix0;\n  viewProjectionMatrices[1] = shadow.viewProjectionMatrix1;\n  vec4 projectCenters[max_lights];\n  projectCenters[0] = shadow.projectCenter0;\n  projectCenters[1] = shadow.projectCenter1;\n\n  if (shadow.drawShadowMap) {\n    return project_common_position_to_clipspace(position_commonspace, viewProjectionMatrices[shadow.lightId], projectCenters[shadow.lightId]);\n  }\n  if (shadow.useShadowMap) {\n    for (int i = 0; i < max_lights; i++) {\n      if(i < int(shadow.lightCount)) {\n        vec4 shadowMap_position = project_common_position_to_clipspace(position_commonspace, viewProjectionMatrices[i], projectCenters[i]);\n        shadow_vPosition[i] = (shadowMap_position.xyz / shadowMap_position.w + 1.0) / 2.0;\n      }\n    }\n  }\n  return gl_Position;\n}\n`;\nconst vs = `\n${uniformBlock}\n${vertex}\n`;\nconst fragment = /* glsl */ `\nconst int max_lights = 2;\nuniform sampler2D shadow_uShadowMap0;\nuniform sampler2D shadow_uShadowMap1;\n\nin vec3 shadow_vPosition[max_lights];\n\nconst vec4 bitPackShift = vec4(1.0, 255.0, 65025.0, 16581375.0);\nconst vec4 bitUnpackShift = 1.0 / bitPackShift;\nconst vec4 bitMask = vec4(1.0 / 255.0, 1.0 / 255.0, 1.0 / 255.0,  0.0);\n\nfloat shadow_getShadowWeight(vec3 position, sampler2D shadowMap) {\n  vec4 rgbaDepth = texture(shadowMap, position.xy);\n\n  float z = dot(rgbaDepth, bitUnpackShift);\n  return smoothstep(0.001, 0.01, position.z - z);\n}\n\nvec4 shadow_filterShadowColor(vec4 color) {\n  if (shadow.drawShadowMap) {\n    vec4 rgbaDepth = fract(gl_FragCoord.z * bitPackShift);\n    rgbaDepth -= rgbaDepth.gbaa * bitMask;\n    return rgbaDepth;\n  }\n  if (shadow.useShadowMap) {\n    float shadowAlpha = 0.0;\n    shadowAlpha += shadow_getShadowWeight(shadow_vPosition[0], shadow_uShadowMap0);\n    if(shadow.lightCount > 1.0) {\n      shadowAlpha += shadow_getShadowWeight(shadow_vPosition[1], shadow_uShadowMap1);\n    }\n    shadowAlpha *= shadow.color.a / shadow.lightCount;\n    float blendedAlpha = shadowAlpha + color.a * (1.0 - shadowAlpha);\n\n    return vec4(\n      mix(color.rgb, shadow.color.rgb, shadowAlpha / blendedAlpha),\n      blendedAlpha\n    );\n  }\n  return color;\n}\n`;\nconst fs = `\n${uniformBlock}\n${fragment}\n`;\nconst getMemoizedViewportCenterPosition = memoize(getViewportCenterPosition);\nconst getMemoizedViewProjectionMatrices = memoize(getViewProjectionMatrices);\nconst DEFAULT_SHADOW_COLOR = [0, 0, 0, 1.0];\nconst VECTOR_TO_POINT_MATRIX = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0];\nfunction screenToCommonSpace(xyz, pixelUnprojectionMatrix) {\n    const [x, y, z] = xyz;\n    const coord = pixelsToWorld([x, y, z], pixelUnprojectionMatrix);\n    if (Number.isFinite(z)) {\n        return coord;\n    }\n    return [coord[0], coord[1], 0];\n}\nfunction getViewportCenterPosition({ viewport, center }) {\n    return new Matrix4(viewport.viewProjectionMatrix).invert().transform(center);\n}\nfunction getViewProjectionMatrices({ viewport, shadowMatrices }) {\n    const projectionMatrices = [];\n    const pixelUnprojectionMatrix = viewport.pixelUnprojectionMatrix;\n    const farZ = viewport.isGeospatial ? undefined : 1;\n    const corners = [\n        [0, 0, farZ], // top left ground\n        [viewport.width, 0, farZ], // top right ground\n        [0, viewport.height, farZ], // bottom left ground\n        [viewport.width, viewport.height, farZ], // bottom right ground\n        [0, 0, -1], // top left near\n        [viewport.width, 0, -1], // top right near\n        [0, viewport.height, -1], // bottom left near\n        [viewport.width, viewport.height, -1] // bottom right near\n    ].map(pixel => \n    // @ts-expect-error z may be undefined\n    screenToCommonSpace(pixel, pixelUnprojectionMatrix));\n    for (const shadowMatrix of shadowMatrices) {\n        const viewMatrix = shadowMatrix.clone().translate(new Vector3(viewport.center).negate());\n        const positions = corners.map(corner => viewMatrix.transform(corner));\n        const projectionMatrix = new Matrix4().ortho({\n            left: Math.min(...positions.map(position => position[0])),\n            right: Math.max(...positions.map(position => position[0])),\n            bottom: Math.min(...positions.map(position => position[1])),\n            top: Math.max(...positions.map(position => position[1])),\n            near: Math.min(...positions.map(position => -position[2])),\n            far: Math.max(...positions.map(position => -position[2]))\n        });\n        projectionMatrices.push(projectionMatrix.multiplyRight(shadowMatrix));\n    }\n    return projectionMatrices;\n}\n/* eslint-disable camelcase */\n// eslint-disable-next-line complexity\nfunction createShadowUniforms(opts) {\n    const { shadowEnabled = true, project: projectProps } = opts;\n    if (!shadowEnabled || !projectProps || !opts.shadowMatrices || !opts.shadowMatrices.length) {\n        return {\n            drawShadowMap: false,\n            useShadowMap: false,\n            shadow_uShadowMap0: opts.dummyShadowMap,\n            shadow_uShadowMap1: opts.dummyShadowMap\n        };\n    }\n    const projectUniforms = project.getUniforms(projectProps);\n    const center = getMemoizedViewportCenterPosition({\n        viewport: projectProps.viewport,\n        center: projectUniforms.center\n    });\n    const projectCenters = [];\n    const viewProjectionMatrices = getMemoizedViewProjectionMatrices({\n        shadowMatrices: opts.shadowMatrices,\n        viewport: projectProps.viewport\n    }).slice();\n    for (let i = 0; i < opts.shadowMatrices.length; i++) {\n        const viewProjectionMatrix = viewProjectionMatrices[i];\n        const viewProjectionMatrixCentered = viewProjectionMatrix\n            .clone()\n            .translate(new Vector3(projectProps.viewport.center).negate());\n        if (projectUniforms.coordinateSystem === COORDINATE_SYSTEM.LNGLAT &&\n            projectUniforms.projectionMode === PROJECTION_MODE.WEB_MERCATOR) {\n            viewProjectionMatrices[i] = viewProjectionMatrixCentered;\n            projectCenters[i] = center;\n        }\n        else {\n            viewProjectionMatrices[i] = viewProjectionMatrix\n                .clone()\n                .multiplyRight(VECTOR_TO_POINT_MATRIX);\n            projectCenters[i] = viewProjectionMatrixCentered.transform(center);\n        }\n    }\n    const uniforms = {\n        drawShadowMap: Boolean(opts.drawToShadowMap),\n        useShadowMap: opts.shadowMaps ? opts.shadowMaps.length > 0 : false,\n        color: opts.shadowColor || DEFAULT_SHADOW_COLOR,\n        lightId: opts.shadowLightId || 0,\n        lightCount: opts.shadowMatrices.length,\n        shadow_uShadowMap0: opts.dummyShadowMap,\n        shadow_uShadowMap1: opts.dummyShadowMap\n    };\n    for (let i = 0; i < viewProjectionMatrices.length; i++) {\n        uniforms[`viewProjectionMatrix${i}`] = viewProjectionMatrices[i];\n        uniforms[`projectCenter${i}`] = projectCenters[i];\n    }\n    for (let i = 0; i < 2; i++) {\n        uniforms[`shadow_uShadowMap${i}`] =\n            (opts.shadowMaps && opts.shadowMaps[i]) || opts.dummyShadowMap;\n    }\n    return uniforms;\n}\nexport default {\n    name: 'shadow',\n    dependencies: [project],\n    vs,\n    fs,\n    inject: {\n        'vs:DECKGL_FILTER_GL_POSITION': `\n    position = shadow_setVertexPosition(geometry.position);\n    `,\n        'fs:DECKGL_FILTER_COLOR': `\n    color = shadow_filterShadowColor(color);\n    `\n    },\n    getUniforms: createShadowUniforms,\n    uniformTypes: {\n        drawShadowMap: 'f32',\n        useShadowMap: 'f32',\n        color: 'vec4<f32>',\n        lightId: 'i32',\n        lightCount: 'f32',\n        viewProjectionMatrix0: 'mat4x4<f32>',\n        viewProjectionMatrix1: 'mat4x4<f32>',\n        projectCenter0: 'vec4<f32>',\n        projectCenter1: 'vec4<f32>'\n    }\n};\n//# sourceMappingURL=shadow.js.map","// deck.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\nimport { picking } from '@luma.gl/shadertools';\nexport default {\n    ...picking,\n    defaultUniforms: { ...picking.defaultUniforms, useFloatColors: false },\n    inject: {\n        'vs:DECKGL_FILTER_GL_POSITION': `\n    // for picking depth values\n    picking_setPickingAttribute(position.z / position.w);\n  `,\n        'vs:DECKGL_FILTER_COLOR': `\n  picking_setPickingColor(geometry.pickingColor);\n  `,\n        'fs:DECKGL_FILTER_COLOR': {\n            order: 99,\n            injection: `\n  // use highlight color if this fragment belongs to the selected object.\n  color = picking_filterHighlightColor(color);\n\n  // use picking color if rendering to picking FBO.\n  color = picking_filterPickingColor(color);\n    `\n        }\n    }\n};\n//# sourceMappingURL=picking.js.map","// deck.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\nimport { ShaderAssembler } from '@luma.gl/shadertools';\nimport { gouraudLighting, phongLighting } from '@luma.gl/shadertools';\nimport { layerUniforms } from \"./misc/layer-uniforms.js\";\nimport geometry from \"./misc/geometry.js\";\nimport project from \"./project/project.js\";\nimport project32 from \"./project32/project32.js\";\nimport shadow from \"./shadow/shadow.js\";\nimport picking from \"./picking/picking.js\";\nconst DEFAULT_MODULES = [geometry];\nconst SHADER_HOOKS_GLSL = [\n    'vs:DECKGL_FILTER_SIZE(inout vec3 size, VertexGeometry geometry)',\n    'vs:DECKGL_FILTER_GL_POSITION(inout vec4 position, VertexGeometry geometry)',\n    'vs:DECKGL_FILTER_COLOR(inout vec4 color, VertexGeometry geometry)',\n    'fs:DECKGL_FILTER_COLOR(inout vec4 color, FragmentGeometry geometry)'\n];\nconst SHADER_HOOKS_WGSL = [\n// Not yet supported\n];\nexport function getShaderAssembler(language) {\n    const shaderAssembler = ShaderAssembler.getDefaultShaderAssembler();\n    for (const shaderModule of DEFAULT_MODULES) {\n        shaderAssembler.addDefaultModule(shaderModule);\n    }\n    // Add shader hooks based on language\n    // TODO(ibgreen) - should the luma shader assembler support both sets of hooks?\n    const shaderHooks = language === 'glsl' ? SHADER_HOOKS_GLSL : SHADER_HOOKS_WGSL;\n    for (const shaderHook of shaderHooks) {\n        shaderAssembler.addShaderHook(shaderHook);\n    }\n    return shaderAssembler;\n}\nexport { layerUniforms, picking, project, project32, gouraudLighting, phongLighting, shadow };\n//# sourceMappingURL=index.js.map","// luma.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\nimport { Shader, log } from '@luma.gl/core';\nimport { GL } from '@luma.gl/constants';\nimport { parseShaderCompilerLog } from \"../helpers/parse-shader-compiler-log.js\";\n/**\n * An immutable compiled shader program that execute portions of the GPU Pipeline\n */\nexport class WEBGLShader extends Shader {\n    device;\n    handle;\n    constructor(device, props) {\n        super(device, props);\n        this.device = device;\n        switch (this.props.stage) {\n            case 'vertex':\n                this.handle = this.props.handle || this.device.gl.createShader(35633);\n                break;\n            case 'fragment':\n                this.handle = this.props.handle || this.device.gl.createShader(35632);\n                break;\n            default:\n                throw new Error(this.props.stage);\n        }\n        this._compile(this.source);\n    }\n    destroy() {\n        if (this.handle) {\n            this.removeStats();\n            this.device.gl.deleteShader(this.handle);\n            // this.handle = null;\n            this.destroyed = true;\n        }\n    }\n    get asyncCompilationStatus() {\n        return this._waitForCompilationComplete().then(() => this.compilationStatus);\n    }\n    async getCompilationInfo() {\n        await this._waitForCompilationComplete();\n        return this.getCompilationInfoSync();\n    }\n    getCompilationInfoSync() {\n        const shaderLog = this.device.gl.getShaderInfoLog(this.handle);\n        return shaderLog ? parseShaderCompilerLog(shaderLog) : [];\n    }\n    getTranslatedSource() {\n        const extensions = this.device.getExtension('WEBGL_debug_shaders');\n        const ext = extensions.WEBGL_debug_shaders;\n        return ext?.getTranslatedShaderSource(this.handle) || null;\n    }\n    // PRIVATE METHODS\n    /** Compile a shader and get compilation status */\n    async _compile(source) {\n        source = source.startsWith('#version ') ? source : `#version 300 es\\n${source}`;\n        const { gl } = this.device;\n        gl.shaderSource(this.handle, source);\n        gl.compileShader(this.handle);\n        // For performance reasons, avoid checking shader compilation errors on production\n        if (!this.device.props.debug) {\n            this.compilationStatus = 'pending';\n            return;\n        }\n        // Sync case - slower, but advantage is that it throws in the constructor, making break on error more useful\n        if (!this.device.features.has('compilation-status-async-webgl')) {\n            this._getCompilationStatus();\n            // The `Shader` base class will determine if debug window should be opened based on this.compilationStatus\n            this.debugShader();\n            if (this.compilationStatus === 'error') {\n                throw new Error(`GLSL compilation errors in ${this.props.stage} shader ${this.props.id}`);\n            }\n            return;\n        }\n        // async case\n        log.once(1, 'Shader compilation is asynchronous')();\n        await this._waitForCompilationComplete();\n        log.info(2, `Shader ${this.id} - async compilation complete: ${this.compilationStatus}`)();\n        this._getCompilationStatus();\n        // The `Shader` base class will determine if debug window should be opened based on this.compilationStatus\n        this.debugShader();\n    }\n    /** Use KHR_parallel_shader_compile extension if available */\n    async _waitForCompilationComplete() {\n        const waitMs = async (ms) => await new Promise(resolve => setTimeout(resolve, ms));\n        const DELAY_MS = 10; // Shader compilation is typically quite fast (with some exceptions)\n        // If status polling is not available, we can't wait for completion. Just wait a little to minimize blocking\n        if (!this.device.features.has('compilation-status-async-webgl')) {\n            await waitMs(DELAY_MS);\n            return;\n        }\n        const { gl } = this.device;\n        for (;;) {\n            const complete = gl.getShaderParameter(this.handle, 37297);\n            if (complete) {\n                return;\n            }\n            await waitMs(DELAY_MS);\n        }\n    }\n    /**\n     * Get the shader compilation status\n     * TODO - Load log even when no error reported, to catch warnings?\n     * https://gamedev.stackexchange.com/questions/30429/how-to-detect-glsl-warnings\n     */\n    _getCompilationStatus() {\n        this.compilationStatus = this.device.gl.getShaderParameter(this.handle, 35713)\n            ? 'success'\n            : 'error';\n    }\n}\n// TODO - Original code from luma.gl v8 - keep until new debug functionality has matured\n// if (!compilationSuccess) {\n//   const parsedLog = shaderLog ? parseShaderCompilerLog(shaderLog) : [];\n//   const messages = parsedLog.filter(message => message.type === 'error');\n//   const formattedLog = formatCompilerLog(messages, source, {showSourceCode: 'all', html: true});\n//   const shaderDescription = `${this.stage} shader ${shaderName}`;\n//   log.error(`GLSL compilation errors in ${shaderDescription}\\n${formattedLog}`)();\n//   displayShaderLog(parsedLog, source, shaderName);\n// }\n//# sourceMappingURL=webgl-shader.js.map","// deck.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\nimport { BufferTransform } from '@luma.gl/engine';\nimport { fp64arithmetic } from '@luma.gl/shadertools';\nimport { GL } from '@luma.gl/constants';\nimport { getAttributeTypeFromSize, cycleBuffers, padBuffer, matchBuffer, getFloat32VertexFormat } from \"./gpu-transition-utils.js\";\nimport { GPUTransitionBase } from \"./gpu-transition.js\";\nexport default class GPUInterpolationTransition extends GPUTransitionBase {\n    constructor({ device, attribute, timeline }) {\n        super({ device, attribute, timeline });\n        this.type = 'interpolation';\n        this.transform = getTransform(device, attribute);\n    }\n    start(transitionSettings, numInstances) {\n        const prevLength = this.currentLength;\n        const prevStartIndices = this.currentStartIndices;\n        super.start(transitionSettings, numInstances, transitionSettings.duration);\n        if (transitionSettings.duration <= 0) {\n            this.transition.cancel();\n            return;\n        }\n        const { buffers, attribute } = this;\n        // Alternate between two buffers when new transitions start.\n        // Last destination buffer is used as an attribute (from state),\n        // And the other buffer is now the current buffer.\n        cycleBuffers(buffers);\n        buffers[0] = padBuffer({\n            device: this.device,\n            buffer: buffers[0],\n            attribute,\n            fromLength: prevLength,\n            toLength: this.currentLength,\n            fromStartIndices: prevStartIndices,\n            getData: transitionSettings.enter\n        });\n        buffers[1] = matchBuffer({\n            device: this.device,\n            source: buffers[0],\n            target: buffers[1]\n        });\n        this.setBuffer(buffers[1]);\n        const { transform } = this;\n        const model = transform.model;\n        let vertexCount = Math.floor(this.currentLength / attribute.size);\n        if (useFp64(attribute)) {\n            vertexCount /= 2;\n        }\n        model.setVertexCount(vertexCount);\n        if (attribute.isConstant) {\n            model.setAttributes({ aFrom: buffers[0] });\n            model.setConstantAttributes({ aTo: attribute.value });\n        }\n        else {\n            model.setAttributes({\n                aFrom: buffers[0],\n                aTo: attribute.getBuffer()\n            });\n        }\n        transform.transformFeedback.setBuffers({ vCurrent: buffers[1] });\n    }\n    onUpdate() {\n        const { duration, easing } = this.settings;\n        const { time } = this.transition;\n        let t = time / duration;\n        if (easing) {\n            t = easing(t);\n        }\n        const { model } = this.transform;\n        const interpolationProps = { time: t };\n        model.shaderInputs.setProps({ interpolation: interpolationProps });\n        this.transform.run({ discard: true });\n    }\n    delete() {\n        super.delete();\n        this.transform.destroy();\n    }\n}\nconst uniformBlock = `\\\nuniform interpolationUniforms {\n  float time;\n} interpolation;\n`;\nconst interpolationUniforms = {\n    name: 'interpolation',\n    vs: uniformBlock,\n    uniformTypes: {\n        time: 'f32'\n    }\n};\nconst vs = `\\\n#version 300 es\n#define SHADER_NAME interpolation-transition-vertex-shader\n\nin ATTRIBUTE_TYPE aFrom;\nin ATTRIBUTE_TYPE aTo;\nout ATTRIBUTE_TYPE vCurrent;\n\nvoid main(void) {\n  vCurrent = mix(aFrom, aTo, interpolation.time);\n  gl_Position = vec4(0.0);\n}\n`;\nconst vs64 = `\\\n#version 300 es\n#define SHADER_NAME interpolation-transition-vertex-shader\n\nin ATTRIBUTE_TYPE aFrom;\nin ATTRIBUTE_TYPE aFrom64Low;\nin ATTRIBUTE_TYPE aTo;\nin ATTRIBUTE_TYPE aTo64Low;\nout ATTRIBUTE_TYPE vCurrent;\nout ATTRIBUTE_TYPE vCurrent64Low;\n\nvec2 mix_fp64(vec2 a, vec2 b, float x) {\n  vec2 range = sub_fp64(b, a);\n  return sum_fp64(a, mul_fp64(range, vec2(x, 0.0)));\n}\n\nvoid main(void) {\n  for (int i=0; i<ATTRIBUTE_SIZE; i++) {\n    vec2 value = mix_fp64(vec2(aFrom[i], aFrom64Low[i]), vec2(aTo[i], aTo64Low[i]), interpolation.time);\n    vCurrent[i] = value.x;\n    vCurrent64Low[i] = value.y;\n  }\n  gl_Position = vec4(0.0);\n}\n`;\nfunction useFp64(attribute) {\n    return attribute.doublePrecision && attribute.value instanceof Float64Array;\n}\nfunction getTransform(device, attribute) {\n    const attributeSize = attribute.size;\n    const attributeType = getAttributeTypeFromSize(attributeSize);\n    const inputFormat = getFloat32VertexFormat(attributeSize);\n    const bufferLayout = attribute.getBufferLayout();\n    if (useFp64(attribute)) {\n        return new BufferTransform(device, {\n            vs: vs64,\n            bufferLayout: [\n                {\n                    name: 'aFrom',\n                    byteStride: 8 * attributeSize,\n                    attributes: [\n                        { attribute: 'aFrom', format: inputFormat, byteOffset: 0 },\n                        { attribute: 'aFrom64Low', format: inputFormat, byteOffset: 4 * attributeSize }\n                    ]\n                },\n                {\n                    name: 'aTo',\n                    byteStride: 8 * attributeSize,\n                    attributes: [\n                        { attribute: 'aTo', format: inputFormat, byteOffset: 0 },\n                        { attribute: 'aTo64Low', format: inputFormat, byteOffset: 4 * attributeSize }\n                    ]\n                }\n            ],\n            // @ts-expect-error fp64 module only sets ONE uniform via defaultUniforms\n            modules: [fp64arithmetic, interpolationUniforms],\n            defines: {\n                ATTRIBUTE_TYPE: attributeType,\n                ATTRIBUTE_SIZE: attributeSize\n            },\n            // Default uniforms are not set without this\n            moduleSettings: {},\n            varyings: ['vCurrent', 'vCurrent64Low'],\n            bufferMode: 35980,\n            disableWarnings: true\n        });\n    }\n    return new BufferTransform(device, {\n        vs,\n        bufferLayout: [\n            { name: 'aFrom', format: inputFormat },\n            { name: 'aTo', format: bufferLayout.attributes[0].format }\n        ],\n        modules: [interpolationUniforms],\n        defines: {\n            ATTRIBUTE_TYPE: attributeType\n        },\n        varyings: ['vCurrent'],\n        // TODO investigate why this is needed\n        disableWarnings: true\n    });\n}\n//# sourceMappingURL=gpu-interpolation-transition.js.map","// deck.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\nimport { BufferTransform } from '@luma.gl/engine';\nimport { padBuffer, matchBuffer, getAttributeTypeFromSize, getFloat32VertexFormat, cycleBuffers } from \"./gpu-transition-utils.js\";\nimport { GPUTransitionBase } from \"./gpu-transition.js\";\nexport default class GPUSpringTransition extends GPUTransitionBase {\n    constructor({ device, attribute, timeline }) {\n        super({ device, attribute, timeline });\n        this.type = 'spring';\n        this.texture = getTexture(device);\n        this.framebuffer = getFramebuffer(device, this.texture);\n        this.transform = getTransform(device, attribute);\n    }\n    start(transitionSettings, numInstances) {\n        const prevLength = this.currentLength;\n        const prevStartIndices = this.currentStartIndices;\n        super.start(transitionSettings, numInstances);\n        const { buffers, attribute } = this;\n        for (let i = 0; i < 2; i++) {\n            buffers[i] = padBuffer({\n                device: this.device,\n                buffer: buffers[i],\n                attribute,\n                fromLength: prevLength,\n                toLength: this.currentLength,\n                fromStartIndices: prevStartIndices,\n                getData: transitionSettings.enter\n            });\n        }\n        buffers[2] = matchBuffer({\n            device: this.device,\n            source: buffers[0],\n            target: buffers[2]\n        });\n        this.setBuffer(buffers[1]);\n        const { model } = this.transform;\n        model.setVertexCount(Math.floor(this.currentLength / attribute.size));\n        if (attribute.isConstant) {\n            model.setConstantAttributes({ aTo: attribute.value });\n        }\n        else {\n            model.setAttributes({ aTo: attribute.getBuffer() });\n        }\n    }\n    onUpdate() {\n        const { buffers, transform, framebuffer, transition } = this;\n        const settings = this.settings;\n        transform.model.setAttributes({\n            aPrev: buffers[0],\n            aCur: buffers[1]\n        });\n        transform.transformFeedback.setBuffers({ vNext: buffers[2] });\n        const springProps = {\n            stiffness: settings.stiffness,\n            damping: settings.damping\n        };\n        transform.model.shaderInputs.setProps({ spring: springProps });\n        transform.run({\n            framebuffer,\n            discard: false,\n            parameters: { viewport: [0, 0, 1, 1] },\n            clearColor: [0, 0, 0, 0]\n        });\n        cycleBuffers(buffers);\n        this.setBuffer(buffers[1]);\n        const isTransitioning = this.device.readPixelsToArrayWebGL(framebuffer)[0] > 0;\n        if (!isTransitioning) {\n            transition.end();\n        }\n    }\n    delete() {\n        super.delete();\n        this.transform.destroy();\n        this.texture.destroy();\n        this.framebuffer.destroy();\n    }\n}\nconst uniformBlock = `\\\nuniform springUniforms {\n  float damping;\n  float stiffness;\n} spring;\n`;\nconst springUniforms = {\n    name: 'spring',\n    vs: uniformBlock,\n    uniformTypes: {\n        damping: 'f32',\n        stiffness: 'f32'\n    }\n};\nconst vs = `\\\n#version 300 es\n#define SHADER_NAME spring-transition-vertex-shader\n\n#define EPSILON 0.00001\n\nin ATTRIBUTE_TYPE aPrev;\nin ATTRIBUTE_TYPE aCur;\nin ATTRIBUTE_TYPE aTo;\nout ATTRIBUTE_TYPE vNext;\nout float vIsTransitioningFlag;\n\nATTRIBUTE_TYPE getNextValue(ATTRIBUTE_TYPE cur, ATTRIBUTE_TYPE prev, ATTRIBUTE_TYPE dest) {\n  ATTRIBUTE_TYPE velocity = cur - prev;\n  ATTRIBUTE_TYPE delta = dest - cur;\n  ATTRIBUTE_TYPE force = delta * spring.stiffness;\n  ATTRIBUTE_TYPE resistance = velocity * spring.damping;\n  return force - resistance + velocity + cur;\n}\n\nvoid main(void) {\n  bool isTransitioning = length(aCur - aPrev) > EPSILON || length(aTo - aCur) > EPSILON;\n  vIsTransitioningFlag = isTransitioning ? 1.0 : 0.0;\n\n  vNext = getNextValue(aCur, aPrev, aTo);\n  gl_Position = vec4(0, 0, 0, 1);\n  gl_PointSize = 100.0;\n}\n`;\nconst fs = `\\\n#version 300 es\n#define SHADER_NAME spring-transition-is-transitioning-fragment-shader\n\nin float vIsTransitioningFlag;\n\nout vec4 fragColor;\n\nvoid main(void) {\n  if (vIsTransitioningFlag == 0.0) {\n    discard;\n  }\n  fragColor = vec4(1.0);\n}`;\nfunction getTransform(device, attribute) {\n    const attributeType = getAttributeTypeFromSize(attribute.size);\n    const format = getFloat32VertexFormat(attribute.size);\n    return new BufferTransform(device, {\n        vs,\n        fs,\n        bufferLayout: [\n            { name: 'aPrev', format },\n            { name: 'aCur', format },\n            { name: 'aTo', format: attribute.getBufferLayout().attributes[0].format }\n        ],\n        varyings: ['vNext'],\n        modules: [springUniforms],\n        defines: { ATTRIBUTE_TYPE: attributeType },\n        parameters: {\n            depthCompare: 'always',\n            blendColorOperation: 'max',\n            blendColorSrcFactor: 'one',\n            blendColorDstFactor: 'one',\n            blendAlphaOperation: 'max',\n            blendAlphaSrcFactor: 'one',\n            blendAlphaDstFactor: 'one'\n        }\n    });\n}\nfunction getTexture(device) {\n    return device.createTexture({\n        data: new Uint8Array(4),\n        format: 'rgba8unorm',\n        mipmaps: false,\n        width: 1,\n        height: 1\n    });\n}\nfunction getFramebuffer(device, texture) {\n    return device.createFramebuffer({\n        id: 'spring-transition-is-transitioning-framebuffer',\n        width: 1,\n        height: 1,\n        colorAttachments: [texture]\n    });\n}\n//# sourceMappingURL=gpu-spring-transition.js.map","// deck.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\nconst glslUniformBlock = `\\\nuniform scatterplotUniforms {\n  float radiusScale;\n  float radiusMinPixels;\n  float radiusMaxPixels;\n  float lineWidthScale;\n  float lineWidthMinPixels;\n  float lineWidthMaxPixels;\n  float stroked;\n  float filled;\n  bool antialiasing;\n  bool billboard;\n  highp int radiusUnits;\n  highp int lineWidthUnits;\n} scatterplot;\n`;\nexport const scatterplotUniforms = {\n    name: 'scatterplot',\n    vs: glslUniformBlock,\n    fs: glslUniformBlock,\n    source: '',\n    uniformTypes: {\n        radiusScale: 'f32',\n        radiusMinPixels: 'f32',\n        radiusMaxPixels: 'f32',\n        lineWidthScale: 'f32',\n        lineWidthMinPixels: 'f32',\n        lineWidthMaxPixels: 'f32',\n        stroked: 'f32',\n        filled: 'f32',\n        antialiasing: 'f32',\n        billboard: 'f32',\n        radiusUnits: 'i32',\n        lineWidthUnits: 'i32'\n    }\n};\n//# sourceMappingURL=scatterplot-layer-uniforms.js.map","// deck.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\nexport default /* glsl */ `\\\n#version 300 es\n#define SHADER_NAME scatterplot-layer-vertex-shader\nin vec3 positions;\nin vec3 instancePositions;\nin vec3 instancePositions64Low;\nin float instanceRadius;\nin float instanceLineWidths;\nin vec4 instanceFillColors;\nin vec4 instanceLineColors;\nin vec3 instancePickingColors;\nout vec4 vFillColor;\nout vec4 vLineColor;\nout vec2 unitPosition;\nout float innerUnitRadius;\nout float outerRadiusPixels;\nvoid main(void) {\ngeometry.worldPosition = instancePositions;\nouterRadiusPixels = clamp(\nproject_size_to_pixel(scatterplot.radiusScale * instanceRadius, scatterplot.radiusUnits),\nscatterplot.radiusMinPixels, scatterplot.radiusMaxPixels\n);\nfloat lineWidthPixels = clamp(\nproject_size_to_pixel(scatterplot.lineWidthScale * instanceLineWidths, scatterplot.lineWidthUnits),\nscatterplot.lineWidthMinPixels, scatterplot.lineWidthMaxPixels\n);\nouterRadiusPixels += scatterplot.stroked * lineWidthPixels / 2.0;\nfloat edgePadding = scatterplot.antialiasing ? (outerRadiusPixels + SMOOTH_EDGE_RADIUS) / outerRadiusPixels : 1.0;\nunitPosition = edgePadding * positions.xy;\ngeometry.uv = unitPosition;\ngeometry.pickingColor = instancePickingColors;\ninnerUnitRadius = 1.0 - scatterplot.stroked * lineWidthPixels / outerRadiusPixels;\nif (scatterplot.billboard) {\ngl_Position = project_position_to_clipspace(instancePositions, instancePositions64Low, vec3(0.0), geometry.position);\nDECKGL_FILTER_GL_POSITION(gl_Position, geometry);\nvec3 offset = edgePadding * positions * outerRadiusPixels;\nDECKGL_FILTER_SIZE(offset, geometry);\ngl_Position.xy += project_pixel_size_to_clipspace(offset.xy);\n} else {\nvec3 offset = edgePadding * positions * project_pixel_size(outerRadiusPixels);\nDECKGL_FILTER_SIZE(offset, geometry);\ngl_Position = project_position_to_clipspace(instancePositions, instancePositions64Low, offset, geometry.position);\nDECKGL_FILTER_GL_POSITION(gl_Position, geometry);\n}\nvFillColor = vec4(instanceFillColors.rgb, instanceFillColors.a * layer.opacity);\nDECKGL_FILTER_COLOR(vFillColor, geometry);\nvLineColor = vec4(instanceLineColors.rgb, instanceLineColors.a * layer.opacity);\nDECKGL_FILTER_COLOR(vLineColor, geometry);\n}\n`;\n//# sourceMappingURL=scatterplot-layer-vertex.glsl.js.map","// deck.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\nexport default /* glsl */ `\\\n#version 300 es\n#define SHADER_NAME scatterplot-layer-fragment-shader\nprecision highp float;\nin vec4 vFillColor;\nin vec4 vLineColor;\nin vec2 unitPosition;\nin float innerUnitRadius;\nin float outerRadiusPixels;\nout vec4 fragColor;\nvoid main(void) {\ngeometry.uv = unitPosition;\nfloat distToCenter = length(unitPosition) * outerRadiusPixels;\nfloat inCircle = scatterplot.antialiasing ?\nsmoothedge(distToCenter, outerRadiusPixels) :\nstep(distToCenter, outerRadiusPixels);\nif (inCircle == 0.0) {\ndiscard;\n}\nif (scatterplot.stroked > 0.5) {\nfloat isLine = scatterplot.antialiasing ?\nsmoothedge(innerUnitRadius * outerRadiusPixels, distToCenter) :\nstep(innerUnitRadius * outerRadiusPixels, distToCenter);\nif (scatterplot.filled > 0.5) {\nfragColor = mix(vFillColor, vLineColor, isLine);\n} else {\nif (isLine == 0.0) {\ndiscard;\n}\nfragColor = vec4(vLineColor.rgb, vLineColor.a * isLine);\n}\n} else if (scatterplot.filled < 0.5) {\ndiscard;\n} else {\nfragColor = vFillColor;\n}\nfragColor.a *= inCircle;\nDECKGL_FILTER_COLOR(fragColor, geometry);\n}\n`;\n//# sourceMappingURL=scatterplot-layer-fragment.glsl.js.map","// deck.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\nexport default /* wgsl */ `\\\n// TODO(ibgreen): Hack for Layer uniforms (move to new \"color\" module?)\n\nstruct LayerUniforms {\n  opacity: f32,\n};\n\nvar<private> layer: LayerUniforms = LayerUniforms(1.0);\n// @group(0) @binding(1) var<uniform> layer: LayerUniforms;\n\n// Main shaders\n\nstruct ScatterplotUniforms {\n  radiusScale: f32,\n  radiusMinPixels: f32,\n  radiusMaxPixels: f32,\n  lineWidthScale: f32,\n  lineWidthMinPixels: f32,\n  lineWidthMaxPixels: f32,\n  stroked: f32,\n  filled: i32,\n  antialiasing: i32,\n  billboard: i32,\n  radiusUnits: i32,\n  lineWidthUnits: i32,\n};\n\nstruct ConstantAttributeUniforms {\n instancePositions: vec3<f32>,\n instancePositions64Low: vec3<f32>,\n instanceRadius: f32,\n instanceLineWidths: f32,\n instanceFillColors: vec4<f32>,\n instanceLineColors: vec4<f32>,\n instancePickingColors: vec3<f32>,\n\n instancePositionsConstant: i32,\n instancePositions64LowConstant: i32,\n instanceRadiusConstant: i32,\n instanceLineWidthsConstant: i32,\n instanceFillColorsConstant: i32,\n instanceLineColorsConstant: i32,\n instancePickingColorsConstant: i32\n};\n\n@group(0) @binding(2) var<uniform> scatterplot: ScatterplotUniforms;\n\nstruct ConstantAttributes {\n  instancePositions: vec3<f32>,\n  instancePositions64Low: vec3<f32>,\n  instanceRadius: f32,\n  instanceLineWidths: f32,\n  instanceFillColors: vec4<f32>,\n  instanceLineColors: vec4<f32>,\n  instancePickingColors: vec3<f32>\n};\n\nconst constants = ConstantAttributes(\n  vec3<f32>(0.0),\n  vec3<f32>(0.0),\n  0.0,\n  0.0,\n  vec4<f32>(0.0, 0.0, 0.0, 1.0),\n  vec4<f32>(0.0, 0.0, 0.0, 1.0),\n  vec3<f32>(0.0)\n);\n\nstruct Attributes {\n  @builtin(instance_index) instanceIndex : u32,\n  @builtin(vertex_index) vertexIndex : u32,\n  @location(0) positions: vec3<f32>,\n  @location(1) instancePositions: vec3<f32>,\n  @location(2) instancePositions64Low: vec3<f32>,\n  @location(3) instanceRadius: f32,\n  @location(4) instanceLineWidths: f32,\n  @location(5) instanceFillColors: vec4<f32>,\n  @location(6) instanceLineColors: vec4<f32>,\n  @location(7) instancePickingColors: vec3<f32>\n};\n\nstruct Varyings {\n  @builtin(position) position: vec4<f32>,\n  @location(0) vFillColor: vec4<f32>,\n  @location(1) vLineColor: vec4<f32>,\n  @location(2) unitPosition: vec2<f32>,\n  @location(3) innerUnitRadius: f32,\n  @location(4) outerRadiusPixels: f32,\n};\n\n@vertex\nfn vertexMain(attributes: Attributes) -> Varyings {\n  var varyings: Varyings;\n\n  // Draw an inline geometry constant array clip space triangle to verify that rendering works.\n  // var positions = array<vec2<f32>, 3>(vec2(0.0, 0.5), vec2(-0.5, -0.5), vec2(0.5, -0.5));\n  // if (attributes.instanceIndex == 0) {\n  //   varyings.position = vec4<f32>(positions[attributes.vertexIndex], 0.0, 1.0);\n  //   return varyings;\n  // }\n\n  // var geometry: Geometry;\n  // geometry.worldPosition = instancePositions;\n\n  // Multiply out radius and clamp to limits\n  varyings.outerRadiusPixels = clamp(\n    project_unit_size_to_pixel(scatterplot.radiusScale * attributes.instanceRadius, scatterplot.radiusUnits),\n    scatterplot.radiusMinPixels, scatterplot.radiusMaxPixels\n  );\n\n  // Multiply out line width and clamp to limits\n  let lineWidthPixels = clamp(\n    project_unit_size_to_pixel(scatterplot.lineWidthScale * attributes.instanceLineWidths, scatterplot.lineWidthUnits),\n    scatterplot.lineWidthMinPixels, scatterplot.lineWidthMaxPixels\n  );\n\n  // outer radius needs to offset by half stroke width\n  varyings.outerRadiusPixels += scatterplot.stroked * lineWidthPixels / 2.0;\n  // Expand geometry to accommodate edge smoothing\n  let edgePadding = select(\n    (varyings.outerRadiusPixels + SMOOTH_EDGE_RADIUS) / varyings.outerRadiusPixels,\n    1.0,\n    scatterplot.antialiasing != 0\n  );\n\n  // position on the containing square in [-1, 1] space\n  varyings.unitPosition = edgePadding * attributes.positions.xy;\n  geometry.uv = varyings.unitPosition;\n  geometry.pickingColor = attributes.instancePickingColors;\n\n  varyings.innerUnitRadius = 1.0 - scatterplot.stroked * lineWidthPixels / varyings.outerRadiusPixels;\n\n  if (scatterplot.billboard != 0) {\n    varyings.position = project_position_to_clipspace(attributes.instancePositions, attributes.instancePositions64Low, vec3<f32>(0.0)); // TODO , geometry.position);\n    // DECKGL_FILTER_GL_POSITION(varyings.position, geometry);\n    let offset = attributes.positions; // * edgePadding * varyings.outerRadiusPixels;\n    // DECKGL_FILTER_SIZE(offset, geometry);\n    let clipPixels = project_pixel_size_to_clipspace(offset.xy);\n    varyings.position.x = clipPixels.x;\n    varyings.position.y = clipPixels.y;\n  } else {\n    let offset = edgePadding * attributes.positions * project_pixel_size_float(varyings.outerRadiusPixels);\n    // DECKGL_FILTER_SIZE(offset, geometry);\n    varyings.position = project_position_to_clipspace(attributes.instancePositions, attributes.instancePositions64Low, offset); // TODO , geometry.position);\n    // DECKGL_FILTER_GL_POSITION(varyings.position, geometry);\n  }\n\n  // Apply opacity to instance color, or return instance picking color\n  varyings.vFillColor = vec4<f32>(attributes.instanceFillColors.rgb, attributes.instanceFillColors.a * layer.opacity);\n  // DECKGL_FILTER_COLOR(varyings.vFillColor, geometry);\n  varyings.vLineColor = vec4<f32>(attributes.instanceLineColors.rgb, attributes.instanceLineColors.a * layer.opacity);\n  // DECKGL_FILTER_COLOR(varyings.vLineColor, geometry);\n\n  return varyings;\n}\n\n@fragment\nfn fragmentMain(varyings: Varyings) -> @location(0) vec4<f32> {\n  // var geometry: Geometry;\n  // geometry.uv = unitPosition;\n\n  let distToCenter = length(varyings.unitPosition) * varyings.outerRadiusPixels;\n  let inCircle = select(\n    smoothedge(distToCenter, varyings.outerRadiusPixels),\n    step(distToCenter, varyings.outerRadiusPixels),\n    scatterplot.antialiasing != 0\n  );\n\n  if (inCircle == 0.0) {\n    // discard;\n  }\n\n  var fragColor: vec4<f32>;\n\n  if (scatterplot.stroked != 0) {\n    let isLine = select(\n      smoothedge(varyings.innerUnitRadius * varyings.outerRadiusPixels, distToCenter),\n      step(varyings.innerUnitRadius * varyings.outerRadiusPixels, distToCenter),\n      scatterplot.antialiasing != 0\n    );\n\n    if (scatterplot.filled != 0) {\n      fragColor = mix(varyings.vFillColor, varyings.vLineColor, isLine);\n    } else {\n      if (isLine == 0.0) {\n        // discard;\n      }\n      fragColor = vec4<f32>(varyings.vLineColor.rgb, varyings.vLineColor.a * isLine);\n    }\n  } else if (scatterplot.filled == 0) {\n    // discard;\n  } else {\n    fragColor = varyings.vFillColor;\n  }\n\n  fragColor.a *= inCircle;\n  // DECKGL_FILTER_COLOR(fragColor, geometry);\n\n  return fragColor;\n  // return vec4<f32>(0, 0, 1, 1);\n}\n`;\n//# sourceMappingURL=scatterplot-layer.wgsl.js.map","// deck.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\nimport { Layer, project32, picking, UNIT } from '@deck.gl/core';\nimport { Model, Geometry } from '@luma.gl/engine';\nimport { scatterplotUniforms } from \"./scatterplot-layer-uniforms.js\";\nimport vs from \"./scatterplot-layer-vertex.glsl.js\";\nimport fs from \"./scatterplot-layer-fragment.glsl.js\";\nimport source from \"./scatterplot-layer.wgsl.js\";\nconst DEFAULT_COLOR = [0, 0, 0, 255];\nconst defaultProps = {\n    radiusUnits: 'meters',\n    radiusScale: { type: 'number', min: 0, value: 1 },\n    radiusMinPixels: { type: 'number', min: 0, value: 0 }, //  min point radius in pixels\n    radiusMaxPixels: { type: 'number', min: 0, value: Number.MAX_SAFE_INTEGER }, // max point radius in pixels\n    lineWidthUnits: 'meters',\n    lineWidthScale: { type: 'number', min: 0, value: 1 },\n    lineWidthMinPixels: { type: 'number', min: 0, value: 0 },\n    lineWidthMaxPixels: { type: 'number', min: 0, value: Number.MAX_SAFE_INTEGER },\n    stroked: false,\n    filled: true,\n    billboard: false,\n    antialiasing: true,\n    getPosition: { type: 'accessor', value: (x) => x.position },\n    getRadius: { type: 'accessor', value: 1 },\n    getFillColor: { type: 'accessor', value: DEFAULT_COLOR },\n    getLineColor: { type: 'accessor', value: DEFAULT_COLOR },\n    getLineWidth: { type: 'accessor', value: 1 },\n    // deprecated\n    strokeWidth: { deprecatedFor: 'getLineWidth' },\n    outline: { deprecatedFor: 'stroked' },\n    getColor: { deprecatedFor: ['getFillColor', 'getLineColor'] }\n};\n/** Render circles at given coordinates. */\nclass ScatterplotLayer extends Layer {\n    getShaders() {\n        return super.getShaders({\n            vs,\n            fs,\n            source,\n            modules: [project32, picking, scatterplotUniforms]\n        });\n    }\n    initializeState() {\n        this.getAttributeManager().addInstanced({\n            instancePositions: {\n                size: 3,\n                type: 'float64',\n                fp64: this.use64bitPositions(),\n                transition: true,\n                accessor: 'getPosition'\n            },\n            instanceRadius: {\n                size: 1,\n                transition: true,\n                accessor: 'getRadius',\n                defaultValue: 1\n            },\n            instanceFillColors: {\n                size: this.props.colorFormat.length,\n                transition: true,\n                type: 'unorm8',\n                accessor: 'getFillColor',\n                defaultValue: [0, 0, 0, 255]\n            },\n            instanceLineColors: {\n                size: this.props.colorFormat.length,\n                transition: true,\n                type: 'unorm8',\n                accessor: 'getLineColor',\n                defaultValue: [0, 0, 0, 255]\n            },\n            instanceLineWidths: {\n                size: 1,\n                transition: true,\n                accessor: 'getLineWidth',\n                defaultValue: 1\n            }\n        });\n    }\n    updateState(params) {\n        super.updateState(params);\n        if (params.changeFlags.extensionsChanged) {\n            this.state.model?.destroy();\n            this.state.model = this._getModel();\n            this.getAttributeManager().invalidateAll();\n        }\n    }\n    draw({ uniforms }) {\n        const { radiusUnits, radiusScale, radiusMinPixels, radiusMaxPixels, stroked, filled, billboard, antialiasing, lineWidthUnits, lineWidthScale, lineWidthMinPixels, lineWidthMaxPixels } = this.props;\n        const scatterplotProps = {\n            stroked,\n            filled,\n            billboard,\n            antialiasing,\n            radiusUnits: UNIT[radiusUnits],\n            radiusScale,\n            radiusMinPixels,\n            radiusMaxPixels,\n            lineWidthUnits: UNIT[lineWidthUnits],\n            lineWidthScale,\n            lineWidthMinPixels,\n            lineWidthMaxPixels\n        };\n        const model = this.state.model;\n        model.shaderInputs.setProps({ scatterplot: scatterplotProps });\n        model.draw(this.context.renderPass);\n    }\n    _getModel() {\n        // a square that minimally cover the unit circle\n        const positions = [-1, -1, 0, 1, -1, 0, -1, 1, 0, 1, 1, 0];\n        return new Model(this.context.device, {\n            ...this.getShaders(),\n            id: this.props.id,\n            bufferLayout: this.getAttributeManager().getBufferLayouts(),\n            geometry: new Geometry({\n                topology: 'triangle-strip',\n                attributes: {\n                    positions: { size: 3, value: new Float32Array(positions) }\n                }\n            }),\n            isInstanced: true\n        });\n    }\n}\nScatterplotLayer.defaultProps = defaultProps;\nScatterplotLayer.layerName = 'ScatterplotLayer';\nexport default ScatterplotLayer;\n//# sourceMappingURL=scatterplot-layer.js.map","// deck.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\nconst uniformBlock = `\\\nuniform columnUniforms {\n  float radius;\n  float angle;\n  vec2 offset;\n  bool extruded;\n  bool stroked;\n  bool isStroke;\n  float coverage;\n  float elevationScale;\n  float edgeDistance;\n  float widthScale;\n  float widthMinPixels;\n  float widthMaxPixels;\n  highp int radiusUnits;\n  highp int widthUnits;\n} column;\n`;\nexport const columnUniforms = {\n    name: 'column',\n    vs: uniformBlock,\n    fs: uniformBlock,\n    uniformTypes: {\n        radius: 'f32',\n        angle: 'f32',\n        offset: 'vec2<f32>',\n        extruded: 'f32',\n        stroked: 'f32',\n        isStroke: 'f32',\n        coverage: 'f32',\n        elevationScale: 'f32',\n        edgeDistance: 'f32',\n        widthScale: 'f32',\n        widthMinPixels: 'f32',\n        widthMaxPixels: 'f32',\n        radiusUnits: 'i32',\n        widthUnits: 'i32'\n    }\n};\n//# sourceMappingURL=column-layer-uniforms.js.map","// deck.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\nexport default `#version 300 es\n#define SHADER_NAME column-layer-vertex-shader\nin vec3 positions;\nin vec3 normals;\nin vec3 instancePositions;\nin float instanceElevations;\nin vec3 instancePositions64Low;\nin vec4 instanceFillColors;\nin vec4 instanceLineColors;\nin float instanceStrokeWidths;\nin vec3 instancePickingColors;\nout vec4 vColor;\n#ifdef FLAT_SHADING\nout vec3 cameraPosition;\nout vec4 position_commonspace;\n#endif\nvoid main(void) {\ngeometry.worldPosition = instancePositions;\nvec4 color = column.isStroke ? instanceLineColors : instanceFillColors;\nmat2 rotationMatrix = mat2(cos(column.angle), sin(column.angle), -sin(column.angle), cos(column.angle));\nfloat elevation = 0.0;\nfloat strokeOffsetRatio = 1.0;\nif (column.extruded) {\nelevation = instanceElevations * (positions.z + 1.0) / 2.0 * column.elevationScale;\n} else if (column.stroked) {\nfloat widthPixels = clamp(\nproject_size_to_pixel(instanceStrokeWidths * column.widthScale, column.widthUnits),\ncolumn.widthMinPixels, column.widthMaxPixels) / 2.0;\nfloat halfOffset = project_pixel_size(widthPixels) / project_size(column.edgeDistance * column.coverage * column.radius);\nif (column.isStroke) {\nstrokeOffsetRatio -= sign(positions.z) * halfOffset;\n} else {\nstrokeOffsetRatio -= halfOffset;\n}\n}\nfloat shouldRender = float(color.a > 0.0 && instanceElevations >= 0.0);\nfloat dotRadius = column.radius * column.coverage * shouldRender;\ngeometry.pickingColor = instancePickingColors;\nvec3 centroidPosition = vec3(instancePositions.xy, instancePositions.z + elevation);\nvec3 centroidPosition64Low = instancePositions64Low;\nvec2 offset = (rotationMatrix * positions.xy * strokeOffsetRatio + column.offset) * dotRadius;\nif (column.radiusUnits == UNIT_METERS) {\noffset = project_size(offset);\n}\nvec3 pos = vec3(offset, 0.);\nDECKGL_FILTER_SIZE(pos, geometry);\ngl_Position = project_position_to_clipspace(centroidPosition, centroidPosition64Low, pos, geometry.position);\ngeometry.normal = project_normal(vec3(rotationMatrix * normals.xy, normals.z));\nDECKGL_FILTER_GL_POSITION(gl_Position, geometry);\nif (column.extruded && !column.isStroke) {\n#ifdef FLAT_SHADING\ncameraPosition = project.cameraPosition;\nposition_commonspace = geometry.position;\nvColor = vec4(color.rgb, color.a * layer.opacity);\n#else\nvec3 lightColor = lighting_getLightColor(color.rgb, project.cameraPosition, geometry.position.xyz, geometry.normal);\nvColor = vec4(lightColor, color.a * layer.opacity);\n#endif\n} else {\nvColor = vec4(color.rgb, color.a * layer.opacity);\n}\nDECKGL_FILTER_COLOR(vColor, geometry);\n}\n`;\n//# sourceMappingURL=column-layer-vertex.glsl.js.map","// deck.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\nexport default `#version 300 es\n#define SHADER_NAME column-layer-fragment-shader\nprecision highp float;\nout vec4 fragColor;\nin vec4 vColor;\n#ifdef FLAT_SHADING\nin vec3 cameraPosition;\nin vec4 position_commonspace;\n#endif\nvoid main(void) {\nfragColor = vColor;\ngeometry.uv = vec2(0.);\n#ifdef FLAT_SHADING\nif (column.extruded && !column.isStroke && !bool(picking.isActive)) {\nvec3 normal = normalize(cross(dFdx(position_commonspace.xyz), dFdy(position_commonspace.xyz)));\nfragColor.rgb = lighting_getLightColor(vColor.rgb, cameraPosition, position_commonspace.xyz, normal);\n}\n#endif\nDECKGL_FILTER_COLOR(fragColor, geometry);\n}\n`;\n//# sourceMappingURL=column-layer-fragment.glsl.js.map","// deck.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\nimport { Layer, project32, picking, UNIT } from '@deck.gl/core';\nimport { gouraudMaterial, phongMaterial } from '@luma.gl/shadertools';\nimport { Model } from '@luma.gl/engine';\nimport ColumnGeometry from \"./column-geometry.js\";\nimport { columnUniforms } from \"./column-layer-uniforms.js\";\nimport vs from \"./column-layer-vertex.glsl.js\";\nimport fs from \"./column-layer-fragment.glsl.js\";\nconst DEFAULT_COLOR = [0, 0, 0, 255];\nconst defaultProps = {\n    diskResolution: { type: 'number', min: 4, value: 20 },\n    vertices: null,\n    radius: { type: 'number', min: 0, value: 1000 },\n    angle: { type: 'number', value: 0 },\n    offset: { type: 'array', value: [0, 0] },\n    coverage: { type: 'number', min: 0, max: 1, value: 1 },\n    elevationScale: { type: 'number', min: 0, value: 1 },\n    radiusUnits: 'meters',\n    lineWidthUnits: 'meters',\n    lineWidthScale: 1,\n    lineWidthMinPixels: 0,\n    lineWidthMaxPixels: Number.MAX_SAFE_INTEGER,\n    extruded: true,\n    wireframe: false,\n    filled: true,\n    stroked: false,\n    flatShading: false,\n    getPosition: { type: 'accessor', value: (x) => x.position },\n    getFillColor: { type: 'accessor', value: DEFAULT_COLOR },\n    getLineColor: { type: 'accessor', value: DEFAULT_COLOR },\n    getLineWidth: { type: 'accessor', value: 1 },\n    getElevation: { type: 'accessor', value: 1000 },\n    material: true,\n    getColor: { deprecatedFor: ['getFillColor', 'getLineColor'] }\n};\n/** Render extruded cylinders (tessellated regular polygons) at given coordinates. */\nclass ColumnLayer extends Layer {\n    getShaders() {\n        const defines = {};\n        const { flatShading } = this.props;\n        if (flatShading) {\n            defines.FLAT_SHADING = 1;\n        }\n        return super.getShaders({\n            vs,\n            fs,\n            defines,\n            modules: [project32, flatShading ? phongMaterial : gouraudMaterial, picking, columnUniforms]\n        });\n    }\n    /**\n     * DeckGL calls initializeState when GL context is available\n     * Essentially a deferred constructor\n     */\n    initializeState() {\n        const attributeManager = this.getAttributeManager();\n        /* eslint-disable max-len */\n        attributeManager.addInstanced({\n            instancePositions: {\n                size: 3,\n                type: 'float64',\n                fp64: this.use64bitPositions(),\n                transition: true,\n                accessor: 'getPosition'\n            },\n            instanceElevations: {\n                size: 1,\n                transition: true,\n                accessor: 'getElevation'\n            },\n            instanceFillColors: {\n                size: this.props.colorFormat.length,\n                type: 'unorm8',\n                transition: true,\n                accessor: 'getFillColor',\n                defaultValue: DEFAULT_COLOR\n            },\n            instanceLineColors: {\n                size: this.props.colorFormat.length,\n                type: 'unorm8',\n                transition: true,\n                accessor: 'getLineColor',\n                defaultValue: DEFAULT_COLOR\n            },\n            instanceStrokeWidths: {\n                size: 1,\n                accessor: 'getLineWidth',\n                transition: true\n            }\n        });\n        /* eslint-enable max-len */\n    }\n    updateState(params) {\n        super.updateState(params);\n        const { props, oldProps, changeFlags } = params;\n        const regenerateModels = changeFlags.extensionsChanged || props.flatShading !== oldProps.flatShading;\n        if (regenerateModels) {\n            this.state.models?.forEach(model => model.destroy());\n            this.setState(this._getModels());\n            this.getAttributeManager().invalidateAll();\n        }\n        const instanceCount = this.getNumInstances();\n        this.state.fillModel.setInstanceCount(instanceCount);\n        this.state.wireframeModel.setInstanceCount(instanceCount);\n        if (regenerateModels ||\n            props.diskResolution !== oldProps.diskResolution ||\n            props.vertices !== oldProps.vertices ||\n            (props.extruded || props.stroked) !== (oldProps.extruded || oldProps.stroked)) {\n            this._updateGeometry(props);\n        }\n    }\n    getGeometry(diskResolution, vertices, hasThinkness) {\n        const geometry = new ColumnGeometry({\n            radius: 1,\n            height: hasThinkness ? 2 : 0,\n            vertices,\n            nradial: diskResolution\n        });\n        let meanVertexDistance = 0;\n        if (vertices) {\n            for (let i = 0; i < diskResolution; i++) {\n                const p = vertices[i];\n                const d = Math.sqrt(p[0] * p[0] + p[1] * p[1]);\n                meanVertexDistance += d / diskResolution;\n            }\n        }\n        else {\n            meanVertexDistance = 1;\n        }\n        this.setState({\n            edgeDistance: Math.cos(Math.PI / diskResolution) * meanVertexDistance\n        });\n        return geometry;\n    }\n    _getModels() {\n        const shaders = this.getShaders();\n        const bufferLayout = this.getAttributeManager().getBufferLayouts();\n        const fillModel = new Model(this.context.device, {\n            ...shaders,\n            id: `${this.props.id}-fill`,\n            bufferLayout,\n            isInstanced: true\n        });\n        const wireframeModel = new Model(this.context.device, {\n            ...shaders,\n            id: `${this.props.id}-wireframe`,\n            bufferLayout,\n            isInstanced: true\n        });\n        return {\n            fillModel,\n            wireframeModel,\n            models: [wireframeModel, fillModel]\n        };\n    }\n    _updateGeometry({ diskResolution, vertices, extruded, stroked }) {\n        const geometry = this.getGeometry(diskResolution, vertices, extruded || stroked);\n        this.setState({\n            fillVertexCount: geometry.attributes.POSITION.value.length / 3\n        });\n        const fillModel = this.state.fillModel;\n        const wireframeModel = this.state.wireframeModel;\n        fillModel.setGeometry(geometry);\n        fillModel.setTopology('triangle-strip');\n        // Disable indices\n        fillModel.setIndexBuffer(null);\n        wireframeModel.setGeometry(geometry);\n        wireframeModel.setTopology('line-list');\n    }\n    draw({ uniforms }) {\n        const { lineWidthUnits, lineWidthScale, lineWidthMinPixels, lineWidthMaxPixels, radiusUnits, elevationScale, extruded, filled, stroked, wireframe, offset, coverage, radius, angle } = this.props;\n        const fillModel = this.state.fillModel;\n        const wireframeModel = this.state.wireframeModel;\n        const { fillVertexCount, edgeDistance } = this.state;\n        const columnProps = {\n            radius,\n            angle: (angle / 180) * Math.PI,\n            offset,\n            extruded,\n            stroked,\n            coverage,\n            elevationScale,\n            edgeDistance,\n            radiusUnits: UNIT[radiusUnits],\n            widthUnits: UNIT[lineWidthUnits],\n            widthScale: lineWidthScale,\n            widthMinPixels: lineWidthMinPixels,\n            widthMaxPixels: lineWidthMaxPixels\n        };\n        // When drawing 3d: draw wireframe first so it doesn't get occluded by depth test\n        if (extruded && wireframe) {\n            wireframeModel.shaderInputs.setProps({\n                column: {\n                    ...columnProps,\n                    isStroke: true\n                }\n            });\n            wireframeModel.draw(this.context.renderPass);\n        }\n        if (filled) {\n            // model.setProps({isIndexed: false});\n            fillModel.setVertexCount(fillVertexCount);\n            fillModel.shaderInputs.setProps({\n                column: {\n                    ...columnProps,\n                    isStroke: false\n                }\n            });\n            fillModel.draw(this.context.renderPass);\n        }\n        // When drawing 2d: draw fill before stroke so that the outline is always on top\n        if (!extruded && stroked) {\n            // model.setProps({isIndexed: false});\n            // The width of the stroke is achieved by flattening the side of the cylinder.\n            // Skip the last 1/3 of the vertices which is the top.\n            fillModel.setVertexCount((fillVertexCount * 2) / 3);\n            fillModel.shaderInputs.setProps({\n                column: {\n                    ...columnProps,\n                    isStroke: true\n                }\n            });\n            fillModel.draw(this.context.renderPass);\n        }\n    }\n}\nColumnLayer.layerName = 'ColumnLayer';\nColumnLayer.defaultProps = defaultProps;\nexport default ColumnLayer;\n//# sourceMappingURL=column-layer.js.map","// deck.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\nconst uniformBlock = /* glsl */ `\\\nuniform binSorterUniforms {\n  ivec4 binIdRange;\n  ivec2 targetSize;\n} binSorter;\n`;\nexport const binSorterUniforms = {\n    name: 'binSorter',\n    vs: uniformBlock,\n    uniformTypes: {\n        binIdRange: 'vec4<i32>',\n        targetSize: 'vec2<i32>'\n    }\n};\n//# sourceMappingURL=bin-sorter-uniforms.js.map","// deck.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\nimport { Model } from '@luma.gl/engine';\nimport { createRenderTarget } from \"./utils.js\";\nimport { binSorterUniforms } from \"./bin-sorter-uniforms.js\";\nconst COLOR_CHANNELS = [0x1, 0x2, 0x4, 0x8]; // GPU color mask RED, GREEN, BLUE, ALPHA\nconst MAX_FLOAT32 = 3e38;\nconst EMPTY_MASKS = { SUM: 0, MEAN: 0, MIN: 0, MAX: 0, COUNT: 0 };\nexport const TEXTURE_WIDTH = 1024;\n/**\n * This class manages the resources for performing the first step of aggregation\n * Sort a list of data points into a number of bins\n */\nexport class WebGLBinSorter {\n    constructor(device, props) {\n        /**\n         * A packed texture in which each pixel represents a bin.\n         * The index of the pixel in the memory layout is the bin index.\n         * Alpha value is the count of data points that fall into this bin\n         * R,G,B values are the aggregated values of each channel:\n         *   - Sum of all data points if operation is 'SUM', or 'MEAN'\n         *   - Min of all data points if operation is 'MIN'\n         *   - Max of all data points if operation is 'MAX'\n         */\n        this.binsFBO = null;\n        this.device = device;\n        this.model = createModel(device, props);\n    }\n    get texture() {\n        return this.binsFBO ? this.binsFBO.colorAttachments[0].texture : null;\n    }\n    destroy() {\n        this.model.destroy();\n        this.binsFBO?.colorAttachments[0].texture.destroy();\n        this.binsFBO?.destroy();\n    }\n    getBinValues(index) {\n        if (!this.binsFBO) {\n            return null;\n        }\n        const x = index % TEXTURE_WIDTH;\n        const y = Math.floor(index / TEXTURE_WIDTH);\n        const buffer = this.device.readPixelsToArrayWebGL(this.binsFBO, {\n            sourceX: x,\n            sourceY: y,\n            sourceWidth: 1,\n            sourceHeight: 1\n        }).buffer;\n        return new Float32Array(buffer);\n    }\n    setDimensions(binCount, binIdRange) {\n        const width = TEXTURE_WIDTH;\n        const height = Math.ceil(binCount / width);\n        // Only destroy existing texture if it is not large enough\n        if (!this.binsFBO) {\n            this.binsFBO = createRenderTarget(this.device, width, height);\n        }\n        else if (this.binsFBO.height < height) {\n            this.binsFBO.resize({ width, height });\n        }\n        const binSorterProps = {\n            binIdRange: [\n                binIdRange[0][0],\n                binIdRange[0][1],\n                binIdRange[1]?.[0] || 0,\n                binIdRange[1]?.[1] || 0\n            ],\n            targetSize: [this.binsFBO.width, this.binsFBO.height]\n        };\n        this.model.shaderInputs.setProps({ binSorter: binSorterProps });\n    }\n    setModelProps(props) {\n        const model = this.model;\n        if (props.attributes) {\n            model.setAttributes(props.attributes);\n        }\n        if (props.constantAttributes) {\n            model.setConstantAttributes(props.constantAttributes);\n        }\n        if (props.vertexCount !== undefined) {\n            model.setVertexCount(props.vertexCount);\n        }\n        if (props.shaderModuleProps) {\n            model.shaderInputs.setProps(props.shaderModuleProps);\n        }\n    }\n    /** Update aggregation */\n    update(\n    /** The aggregation operation for each channel. Use null to skip update. */\n    operations) {\n        if (!this.binsFBO) {\n            return;\n        }\n        const masks = getMaskByOperation(operations);\n        this._updateBins('SUM', masks.SUM + masks.MEAN);\n        this._updateBins('MIN', masks.MIN);\n        this._updateBins('MAX', masks.MAX);\n    }\n    /** Recalculate aggregation on the given channels using the given operation */\n    _updateBins(operation, \n    /** GPU bit mask of one or more channels that should be updated */\n    colorMask) {\n        if (colorMask === 0) {\n            return;\n        }\n        colorMask |= COLOR_CHANNELS[3]; // Also renders to the alpha channel (point count)\n        const model = this.model;\n        const target = this.binsFBO;\n        const initialValue = operation === 'MAX' ? -MAX_FLOAT32 : operation === 'MIN' ? MAX_FLOAT32 : 0;\n        const renderPass = this.device.beginRenderPass({\n            id: `gpu-aggregation-${operation}`,\n            framebuffer: target,\n            parameters: {\n                viewport: [0, 0, target.width, target.height],\n                colorMask\n            },\n            clearColor: [initialValue, initialValue, initialValue, 0],\n            clearDepth: false,\n            clearStencil: false\n        });\n        model.setParameters({\n            blend: true,\n            blendColorSrcFactor: 'one',\n            blendColorDstFactor: 'one',\n            blendAlphaSrcFactor: 'one',\n            blendAlphaDstFactor: 'one',\n            blendColorOperation: operation === 'MAX' ? 'max' : operation === 'MIN' ? 'min' : 'add',\n            blendAlphaOperation: 'add'\n        });\n        model.draw(renderPass);\n        renderPass.end();\n    }\n}\n/** Convert a [channel -> operation] map to a [operation -> GPU color mask] map */\nfunction getMaskByOperation(operations) {\n    const result = { ...EMPTY_MASKS };\n    for (let channel = 0; channel < operations.length; channel++) {\n        const op = operations[channel];\n        if (op) {\n            result[op] += COLOR_CHANNELS[channel];\n        }\n    }\n    return result;\n}\nfunction createModel(device, props) {\n    let userVs = props.vs;\n    if (props.dimensions === 2) {\n        // If user provides 2d bin IDs, convert them to 1d indices for data packing\n        userVs += /* glsl */ `\nvoid getBin(out int binId) {\n  ivec2 binId2;\n  getBin(binId2);\n  if (binId2.x < binSorter.binIdRange.x || binId2.x >= binSorter.binIdRange.y) {\n    binId = -1;\n  } else {\n    binId = (binId2.y - binSorter.binIdRange.z) * (binSorter.binIdRange.y - binSorter.binIdRange.x) + binId2.x;\n  }\n}\n`;\n    }\n    const vs = `\\\n#version 300 es\n#define SHADER_NAME gpu-aggregation-sort-bins-vertex\n\n${userVs}\n\nout vec3 v_Value;\n\nvoid main() {\n  int binIndex;\n  getBin(binIndex);\n  binIndex = binIndex - binSorter.binIdRange.x;\n  if (binIndex < 0) {\n    gl_Position = vec4(0.);\n    return;\n  }\n  int row = binIndex / binSorter.targetSize.x;\n  int col = binIndex - row * binSorter.targetSize.x;\n  vec2 position = (vec2(col, row) + 0.5) / vec2(binSorter.targetSize) * 2.0 - 1.0;\n  gl_Position = vec4(position, 0.0, 1.0);\n  gl_PointSize = 1.0;\n\n#if NUM_CHANNELS == 3\n  getValue(v_Value);\n#elif NUM_CHANNELS == 2\n  getValue(v_Value.xy);\n#else\n  getValue(v_Value.x);\n#endif\n}\n`;\n    const fs = /* glsl */ `\\\n#version 300 es\n#define SHADER_NAME gpu-aggregation-sort-bins-fragment\n\nprecision highp float;\n\nin vec3 v_Value;\nout vec4 fragColor;\n\nvoid main() {\n  fragColor.xyz = v_Value;\n\n  #ifdef MODULE_GEOMETRY\n  geometry.uv = vec2(0.);\n  DECKGL_FILTER_COLOR(fragColor, geometry);\n  #endif\n\n  fragColor.w = 1.0;\n}\n`;\n    const model = new Model(device, {\n        bufferLayout: props.bufferLayout,\n        modules: [...(props.modules || []), binSorterUniforms],\n        defines: { ...props.defines, NON_INSTANCED_MODEL: 1, NUM_CHANNELS: props.channelCount },\n        isInstanced: false,\n        vs,\n        fs,\n        topology: 'point-list',\n        disableWarnings: true\n    });\n    return model;\n}\n//# sourceMappingURL=webgl-bin-sorter.js.map","// deck.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\nconst uniformBlock = /* glsl */ `\\\nuniform aggregatorTransformUniforms {\n  ivec4 binIdRange;\n  bvec3 isCount;\n  bvec3 isMean;\n  float naN;\n} aggregatorTransform;\n`;\nexport const aggregatorTransformUniforms = {\n    name: 'aggregatorTransform',\n    vs: uniformBlock,\n    uniformTypes: {\n        binIdRange: 'vec4<i32>',\n        isCount: 'vec3<f32>',\n        isMean: 'vec3<f32>'\n    }\n};\n//# sourceMappingURL=aggregation-transform-uniforms.js.map","// deck.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\nimport { BufferTransform } from '@luma.gl/engine';\nimport { createRenderTarget } from \"./utils.js\";\nimport { TEXTURE_WIDTH } from \"./webgl-bin-sorter.js\";\nimport { aggregatorTransformUniforms } from \"./aggregation-transform-uniforms.js\";\nconst MAX_FLOAT32 = 3e38;\nexport class WebGLAggregationTransform {\n    constructor(device, props) {\n        /** Packed from bin ids */\n        this.binBuffer = null;\n        /** Packed values from each channel of each bin\n         * Stride is number of channels * 4 bytes (float32)\n         */\n        this.valueBuffer = null;\n        /** Aggregated [min, max] for each channel */\n        this._domains = null;\n        this.device = device;\n        this.channelCount = props.channelCount;\n        this.transform = createTransform(device, props);\n        this.domainFBO = createRenderTarget(device, 2, 1);\n    }\n    destroy() {\n        this.transform.destroy();\n        this.binBuffer?.destroy();\n        this.valueBuffer?.destroy();\n        this.domainFBO.colorAttachments[0].texture.destroy();\n        this.domainFBO.destroy();\n    }\n    get domains() {\n        if (!this._domains) {\n            // Domain model has run, but result has not been read to CPU\n            const buffer = this.device.readPixelsToArrayWebGL(this.domainFBO).buffer;\n            const domain = new Float32Array(buffer);\n            this._domains = [\n                [-domain[4], domain[0]],\n                [-domain[5], domain[1]],\n                [-domain[6], domain[2]]\n            ].slice(0, this.channelCount);\n        }\n        return this._domains;\n    }\n    setDimensions(binCount, binIdRange) {\n        const { model, transformFeedback } = this.transform;\n        model.setVertexCount(binCount);\n        const aggregatorTransformProps = {\n            binIdRange: [\n                binIdRange[0][0],\n                binIdRange[0][1],\n                binIdRange[1]?.[0] || 0,\n                binIdRange[1]?.[1] || 0\n            ]\n        };\n        model.shaderInputs.setProps({ aggregatorTransform: aggregatorTransformProps });\n        // Only destroy existing buffer if it is not large enough\n        const binBufferByteLength = binCount * binIdRange.length * 4;\n        if (!this.binBuffer || this.binBuffer.byteLength < binBufferByteLength) {\n            this.binBuffer?.destroy();\n            this.binBuffer = this.device.createBuffer({ byteLength: binBufferByteLength });\n            transformFeedback.setBuffer('binIds', this.binBuffer);\n        }\n        const valueBufferByteLength = binCount * this.channelCount * 4;\n        if (!this.valueBuffer || this.valueBuffer.byteLength < valueBufferByteLength) {\n            this.valueBuffer?.destroy();\n            this.valueBuffer = this.device.createBuffer({ byteLength: valueBufferByteLength });\n            transformFeedback.setBuffer('values', this.valueBuffer);\n        }\n    }\n    update(bins, operations) {\n        if (!bins) {\n            return;\n        }\n        const transform = this.transform;\n        const target = this.domainFBO;\n        const isCount = [0, 1, 2].map(i => (operations[i] === 'COUNT' ? 1 : 0));\n        const isMean = [0, 1, 2].map(i => (operations[i] === 'MEAN' ? 1 : 0));\n        const aggregatorTransformProps = {\n            isCount: isCount,\n            isMean: isMean,\n            bins\n        };\n        transform.model.shaderInputs.setProps({ aggregatorTransform: aggregatorTransformProps });\n        transform.run({\n            id: 'gpu-aggregation-domain',\n            framebuffer: target,\n            parameters: {\n                viewport: [0, 0, 2, 1]\n            },\n            clearColor: [-MAX_FLOAT32, -MAX_FLOAT32, -MAX_FLOAT32, 0],\n            clearDepth: false,\n            clearStencil: false\n        });\n        // Clear the last read results. This will be lazy-populated if used.\n        this._domains = null;\n    }\n}\nfunction createTransform(device, props) {\n    const vs = /* glsl */ `\\\n#version 300 es\n#define SHADER_NAME gpu-aggregation-domain-vertex\n\nuniform sampler2D bins;\n\n#if NUM_DIMS == 1\nout float binIds;\n#else\nout vec2 binIds;\n#endif\n\n#if NUM_CHANNELS == 1\nflat out float values;\n#elif NUM_CHANNELS == 2\nflat out vec2 values;\n#else\nflat out vec3 values;\n#endif\n\nconst float NAN = intBitsToFloat(-1);\n\nvoid main() {\n  int row = gl_VertexID / SAMPLER_WIDTH;\n  int col = gl_VertexID - row * SAMPLER_WIDTH;\n  vec4 weights = texelFetch(bins, ivec2(col, row), 0);\n  vec3 value3 = mix(\n    mix(weights.rgb, vec3(weights.a), aggregatorTransform.isCount),\n    weights.rgb / max(weights.a, 1.0),\n    aggregatorTransform.isMean\n  );\n  if (weights.a == 0.0) {\n    value3 = vec3(NAN);\n  }\n\n#if NUM_DIMS == 1\n  binIds = float(gl_VertexID + aggregatorTransform.binIdRange.x);\n#else\n  int y = gl_VertexID / (aggregatorTransform.binIdRange.y - aggregatorTransform.binIdRange.x);\n  int x = gl_VertexID - y * (aggregatorTransform.binIdRange.y - aggregatorTransform.binIdRange.x);\n  binIds.y = float(y + aggregatorTransform.binIdRange.z);\n  binIds.x = float(x + aggregatorTransform.binIdRange.x);\n#endif\n\n#if NUM_CHANNELS == 3\n  values = value3;\n#elif NUM_CHANNELS == 2\n  values = value3.xy;\n#else\n  values = value3.x;\n#endif\n\n  gl_Position = vec4(0., 0., 0., 1.);\n  // This model renders into a 2x1 texture to obtain min and max simultaneously.\n  // See comments in fragment shader\n  gl_PointSize = 2.0;\n}\n`;\n    const fs = /* glsl */ `\\\n#version 300 es\n#define SHADER_NAME gpu-aggregation-domain-fragment\n\nprecision highp float;\n\n#if NUM_CHANNELS == 1\nflat in float values;\n#elif NUM_CHANNELS == 2\nflat in vec2 values;\n#else\nflat in vec3 values;\n#endif\n\nout vec4 fragColor;\n\nvoid main() {\n  vec3 value3;\n#if NUM_CHANNELS == 3\n  value3 = values;\n#elif NUM_CHANNELS == 2\n  value3.xy = values;\n#else\n  value3.x = values;\n#endif\n  if (isnan(value3.x)) discard;\n  // This shader renders into a 2x1 texture with blending=max\n  // The left pixel yields the max value of each channel\n  // The right pixel yields the min value of each channel\n  if (gl_FragCoord.x < 1.0) {\n    fragColor = vec4(value3, 1.0);\n  } else {\n    fragColor = vec4(-value3, 1.0);\n  }\n}\n`;\n    return new BufferTransform(device, {\n        vs,\n        fs,\n        topology: 'point-list',\n        modules: [aggregatorTransformUniforms],\n        parameters: {\n            blend: true,\n            blendColorSrcFactor: 'one',\n            blendColorDstFactor: 'one',\n            blendColorOperation: 'max',\n            blendAlphaSrcFactor: 'one',\n            blendAlphaDstFactor: 'one',\n            blendAlphaOperation: 'max'\n        },\n        defines: {\n            NUM_DIMS: props.dimensions,\n            NUM_CHANNELS: props.channelCount,\n            SAMPLER_WIDTH: TEXTURE_WIDTH\n        },\n        varyings: ['binIds', 'values'],\n        disableWarnings: true\n    });\n}\n//# sourceMappingURL=webgl-aggregation-transform.js.map","// deck.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\nconst THIRD_PI = Math.PI / 3;\nconst DIST_X = 2 * Math.sin(THIRD_PI);\nconst DIST_Y = 1.5;\nexport const HexbinVertices = Array.from({ length: 6 }, (_, i) => {\n    const angle = i * THIRD_PI;\n    return [Math.sin(angle), -Math.cos(angle)];\n});\n/**\n * Adapted from d3-hexbin\n * Copyright Mike Bostock, 2012-2016\n   All rights reserved.\n * https://github.com/d3/d3-hexbin/blob/master/src/hexbin.js\n *\n * Returns the hexbin that a point (x,y) falls into\n */\nexport function pointToHexbin([px, py], radius) {\n    let pj = Math.round((py = py / radius / DIST_Y));\n    let pi = Math.round((px = px / radius / DIST_X - (pj & 1) / 2));\n    const py1 = py - pj;\n    if (Math.abs(py1) * 3 > 1) {\n        const px1 = px - pi;\n        const pi2 = pi + (px < pi ? -1 : 1) / 2;\n        const pj2 = pj + (py < pj ? -1 : 1);\n        const px2 = px - pi2;\n        const py2 = py - pj2;\n        if (px1 * px1 + py1 * py1 > px2 * px2 + py2 * py2) {\n            pi = pi2 + (pj & 1 ? 1 : -1) / 2;\n            pj = pj2;\n        }\n    }\n    return [pi, pj];\n}\nexport const pointToHexbinGLSL = /* glsl */ `\nconst vec2 DIST = vec2(${DIST_X}, ${DIST_Y});\n\nivec2 pointToHexbin(vec2 p, float radius) {\n  p /= radius * DIST;\n  float pj = round(p.y);\n  float pjm2 = mod(pj, 2.0);\n  p.x -= pjm2 * 0.5;\n  float pi = round(p.x);\n  vec2 d1 = p - vec2(pi, pj);\n\n  if (abs(d1.y) * 3. > 1.) {\n    vec2 v2 = step(0.0, d1) - 0.5;\n    v2.y *= 2.0;\n    vec2 d2 = d1 - v2;\n    if (dot(d1, d1) > dot(d2, d2)) {\n      pi += v2.x + pjm2 - 0.5;\n      pj += v2.y;\n    }\n  }\n  return ivec2(pi, pj);\n}\n`;\nexport function getHexbinCentroid([i, j], radius) {\n    return [(i + (j & 1) / 2) * radius * DIST_X, j * radius * DIST_Y];\n}\nexport const getHexbinCentroidGLSL = `\nconst vec2 DIST = vec2(${DIST_X}, ${DIST_Y});\n\nvec2 hexbinCentroid(vec2 binId, float radius) {\n  binId.x += fract(binId.y * 0.5);\n  return binId * DIST * radius;\n}\n`;\n//# sourceMappingURL=hexbin.js.map","// deck.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\nimport { getHexbinCentroidGLSL } from \"./hexbin.js\";\nexport default /* glsl */ `\\\n#version 300 es\n#define SHADER_NAME hexagon-cell-layer-vertex-shader\nin vec3 positions;\nin vec3 normals;\nin vec2 instancePositions;\nin float instanceElevationValues;\nin float instanceColorValues;\nin vec3 instancePickingColors;\nuniform sampler2D colorRange;\nout vec4 vColor;\n${getHexbinCentroidGLSL}\nfloat interp(float value, vec2 domain, vec2 range) {\nfloat r = min(max((value - domain.x) / (domain.y - domain.x), 0.), 1.);\nreturn mix(range.x, range.y, r);\n}\nvec4 interp(float value, vec2 domain, sampler2D range) {\nfloat r = (value - domain.x) / (domain.y - domain.x);\nreturn texture(range, vec2(r, 0.5));\n}\nvoid main(void) {\ngeometry.pickingColor = instancePickingColors;\nif (isnan(instanceColorValues) ||\ninstanceColorValues < hexagon.colorDomain.z ||\ninstanceColorValues > hexagon.colorDomain.w ||\ninstanceElevationValues < hexagon.elevationDomain.z ||\ninstanceElevationValues > hexagon.elevationDomain.w\n) {\ngl_Position = vec4(0.);\nreturn;\n}\nvec2 commonPosition = hexbinCentroid(instancePositions, column.radius) + (hexagon.originCommon - project.commonOrigin.xy);\ncommonPosition += positions.xy * column.radius * column.coverage;\ngeometry.position = vec4(commonPosition, 0.0, 1.0);\ngeometry.normal = project_normal(normals);\nfloat elevation = 0.0;\nif (column.extruded) {\nelevation = interp(instanceElevationValues, hexagon.elevationDomain.xy, hexagon.elevationRange);\nelevation = project_size(elevation);\ngeometry.position.z = (positions.z + 1.0) / 2.0 * elevation;\n}\ngl_Position = project_common_position_to_clipspace(geometry.position);\nDECKGL_FILTER_GL_POSITION(gl_Position, geometry);\nvColor = interp(instanceColorValues, hexagon.colorDomain.xy, colorRange);\nvColor.a *= layer.opacity;\nif (column.extruded) {\nvColor.rgb = lighting_getLightColor(vColor.rgb, project.cameraPosition, geometry.position.xyz, geometry.normal);\n}\nDECKGL_FILTER_COLOR(vColor, geometry);\n}\n`;\n//# sourceMappingURL=hexagon-cell-layer-vertex.glsl.js.map","// deck.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\nconst uniformBlock = /* glsl */ `\\\nuniform hexagonUniforms {\n  vec4 colorDomain;\n  vec4 elevationDomain;\n  vec2 elevationRange;\n  vec2 originCommon;\n} hexagon;\n`;\nexport const hexagonUniforms = {\n    name: 'hexagon',\n    vs: uniformBlock,\n    uniformTypes: {\n        colorDomain: 'vec4<f32>',\n        elevationDomain: 'vec4<f32>',\n        elevationRange: 'vec2<f32>',\n        originCommon: 'vec2<f32>'\n    }\n};\n//# sourceMappingURL=hexagon-layer-uniforms.js.map","// deck.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\nconst uniformBlock = /* glsl */ `\\\nuniform binOptionsUniforms {\n  vec2 hexOriginCommon;\n  float radiusCommon;\n} binOptions;\n`;\nexport const binOptionsUniforms = {\n    name: 'binOptions',\n    vs: uniformBlock,\n    uniformTypes: {\n        hexOriginCommon: 'vec2<f32>',\n        radiusCommon: 'f32'\n    }\n};\n//# sourceMappingURL=bin-options-uniforms.js.map","// deck.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\nimport { log, createIterable, project32, Viewport } from '@deck.gl/core';\nimport { WebGLAggregator, CPUAggregator } from \"../common/aggregator/index.js\";\nimport AggregationLayer from \"../common/aggregation-layer.js\";\nimport { defaultColorRange } from \"../common/utils/color-utils.js\";\nimport { AttributeWithScale } from \"../common/utils/scale-utils.js\";\nimport { getBinIdRange } from \"../common/utils/bounds-utils.js\";\nimport HexagonCellLayer from \"./hexagon-cell-layer.js\";\nimport { pointToHexbin, HexbinVertices, getHexbinCentroid, pointToHexbinGLSL } from \"./hexbin.js\";\nimport { binOptionsUniforms } from \"./bin-options-uniforms.js\";\n// eslint-disable-next-line @typescript-eslint/no-empty-function\nfunction noop() { }\nconst defaultProps = {\n    gpuAggregation: true,\n    // color\n    colorDomain: null,\n    colorRange: defaultColorRange,\n    getColorValue: { type: 'accessor', value: null }, // default value is calculated from `getColorWeight` and `colorAggregation`\n    getColorWeight: { type: 'accessor', value: 1 },\n    colorAggregation: 'SUM',\n    lowerPercentile: { type: 'number', min: 0, max: 100, value: 0 },\n    upperPercentile: { type: 'number', min: 0, max: 100, value: 100 },\n    colorScaleType: 'quantize',\n    onSetColorDomain: noop,\n    // elevation\n    elevationDomain: null,\n    elevationRange: [0, 1000],\n    getElevationValue: { type: 'accessor', value: null }, // default value is calculated from `getElevationWeight` and `elevationAggregation`\n    getElevationWeight: { type: 'accessor', value: 1 },\n    elevationAggregation: 'SUM',\n    elevationScale: { type: 'number', min: 0, value: 1 },\n    elevationLowerPercentile: { type: 'number', min: 0, max: 100, value: 0 },\n    elevationUpperPercentile: { type: 'number', min: 0, max: 100, value: 100 },\n    elevationScaleType: 'linear',\n    onSetElevationDomain: noop,\n    // hexbin\n    radius: { type: 'number', min: 1, value: 1000 },\n    coverage: { type: 'number', min: 0, max: 1, value: 1 },\n    getPosition: { type: 'accessor', value: (x) => x.position },\n    hexagonAggregator: { type: 'function', optional: true, value: null },\n    extruded: false,\n    // Optional material for 'lighting' shader module\n    material: true\n};\n/** Aggregate data into a grid-based heatmap. The color and height of a cell are determined based on the objects it contains. */\nclass HexagonLayer extends AggregationLayer {\n    getAggregatorType() {\n        const { gpuAggregation, hexagonAggregator, getColorValue, getElevationValue } = this.props;\n        if (gpuAggregation && (hexagonAggregator || getColorValue || getElevationValue)) {\n            // If these features are desired by the app, the user should explicitly use CPU aggregation\n            log.warn('Features not supported by GPU aggregation, falling back to CPU')();\n            return 'cpu';\n        }\n        if (\n        // GPU aggregation is requested\n        gpuAggregation &&\n            // GPU aggregation is supported by the device\n            WebGLAggregator.isSupported(this.context.device)) {\n            return 'gpu';\n        }\n        return 'cpu';\n    }\n    createAggregator(type) {\n        if (type === 'cpu') {\n            const { hexagonAggregator, radius } = this.props;\n            return new CPUAggregator({\n                dimensions: 2,\n                getBin: {\n                    sources: ['positions'],\n                    getValue: ({ positions }, index, opts) => {\n                        if (hexagonAggregator) {\n                            return hexagonAggregator(positions, radius);\n                        }\n                        const viewport = this.state.aggregatorViewport;\n                        // project to common space\n                        const p = viewport.projectPosition(positions);\n                        const { radiusCommon, hexOriginCommon } = opts;\n                        return pointToHexbin([p[0] - hexOriginCommon[0], p[1] - hexOriginCommon[1]], radiusCommon);\n                    }\n                },\n                getValue: [\n                    { sources: ['colorWeights'], getValue: ({ colorWeights }) => colorWeights },\n                    { sources: ['elevationWeights'], getValue: ({ elevationWeights }) => elevationWeights }\n                ]\n            });\n        }\n        return new WebGLAggregator(this.context.device, {\n            dimensions: 2,\n            channelCount: 2,\n            bufferLayout: this.getAttributeManager().getBufferLayouts({ isInstanced: false }),\n            ...super.getShaders({\n                modules: [project32, binOptionsUniforms],\n                vs: /* glsl */ `\n  in vec3 positions;\n  in vec3 positions64Low;\n  in float colorWeights;\n  in float elevationWeights;\n  \n  ${pointToHexbinGLSL}\n\n  void getBin(out ivec2 binId) {\n    vec3 positionCommon = project_position(positions, positions64Low);\n    binId = pointToHexbin(positionCommon.xy, binOptions.radiusCommon);\n  }\n  void getValue(out vec2 value) {\n    value = vec2(colorWeights, elevationWeights);\n  }\n  `\n            })\n        });\n    }\n    initializeState() {\n        super.initializeState();\n        const attributeManager = this.getAttributeManager();\n        attributeManager.add({\n            positions: {\n                size: 3,\n                accessor: 'getPosition',\n                type: 'float64',\n                fp64: this.use64bitPositions()\n            },\n            colorWeights: { size: 1, accessor: 'getColorWeight' },\n            elevationWeights: { size: 1, accessor: 'getElevationWeight' }\n        });\n    }\n    // eslint-disable-next-line complexity\n    updateState(params) {\n        const aggregatorChanged = super.updateState(params);\n        const { props, oldProps, changeFlags } = params;\n        const { aggregator } = this.state;\n        if ((changeFlags.dataChanged || !this.state.dataAsArray) &&\n            (props.getColorValue || props.getElevationValue)) {\n            // Convert data to array\n            this.state.dataAsArray = Array.from(createIterable(props.data).iterable);\n        }\n        if (aggregatorChanged ||\n            changeFlags.dataChanged ||\n            props.radius !== oldProps.radius ||\n            props.getColorValue !== oldProps.getColorValue ||\n            props.getElevationValue !== oldProps.getElevationValue ||\n            props.colorAggregation !== oldProps.colorAggregation ||\n            props.elevationAggregation !== oldProps.elevationAggregation) {\n            this._updateBinOptions();\n            const { radiusCommon, hexOriginCommon, binIdRange, dataAsArray } = this.state;\n            aggregator.setProps({\n                // @ts-expect-error only used by GPUAggregator\n                binIdRange,\n                pointCount: this.getNumInstances(),\n                operations: [props.colorAggregation, props.elevationAggregation],\n                binOptions: {\n                    radiusCommon,\n                    hexOriginCommon\n                },\n                onUpdate: this._onAggregationUpdate.bind(this)\n            });\n            if (dataAsArray) {\n                const { getColorValue, getElevationValue } = this.props;\n                aggregator.setProps({\n                    // @ts-expect-error only used by CPUAggregator\n                    customOperations: [\n                        getColorValue &&\n                            ((indices) => getColorValue(indices.map(i => dataAsArray[i]), { indices, data: props.data })),\n                        getElevationValue &&\n                            ((indices) => getElevationValue(indices.map(i => dataAsArray[i]), { indices, data: props.data }))\n                    ]\n                });\n            }\n        }\n        if (changeFlags.updateTriggersChanged && changeFlags.updateTriggersChanged.getColorValue) {\n            aggregator.setNeedsUpdate(0);\n        }\n        if (changeFlags.updateTriggersChanged && changeFlags.updateTriggersChanged.getElevationValue) {\n            aggregator.setNeedsUpdate(1);\n        }\n        return aggregatorChanged;\n    }\n    _updateBinOptions() {\n        const bounds = this.getBounds();\n        let radiusCommon = 1;\n        let hexOriginCommon = [0, 0];\n        let binIdRange = [\n            [0, 1],\n            [0, 1]\n        ];\n        let viewport = this.context.viewport;\n        if (bounds && Number.isFinite(bounds[0][0])) {\n            let centroid = [(bounds[0][0] + bounds[1][0]) / 2, (bounds[0][1] + bounds[1][1]) / 2];\n            const { radius } = this.props;\n            const { unitsPerMeter } = viewport.getDistanceScales(centroid);\n            radiusCommon = unitsPerMeter[0] * radius;\n            // Use the centroid of the hex at the center of the data\n            // This offsets the common space without changing the bins\n            const centerHex = pointToHexbin(viewport.projectFlat(centroid), radiusCommon);\n            centroid = viewport.unprojectFlat(getHexbinCentroid(centerHex, radiusCommon));\n            const ViewportType = viewport.constructor;\n            // We construct a viewport for the GPU aggregator's project module\n            // This viewport is determined by data\n            // removes arbitrary precision variance that depends on initial view state\n            viewport = viewport.isGeospatial\n                ? new ViewportType({ longitude: centroid[0], latitude: centroid[1], zoom: 12 })\n                : new Viewport({ position: [centroid[0], centroid[1], 0], zoom: 12 });\n            hexOriginCommon = [Math.fround(viewport.center[0]), Math.fround(viewport.center[1])];\n            binIdRange = getBinIdRange({\n                dataBounds: bounds,\n                getBinId: (p) => {\n                    const positionCommon = viewport.projectFlat(p);\n                    positionCommon[0] -= hexOriginCommon[0];\n                    positionCommon[1] -= hexOriginCommon[1];\n                    return pointToHexbin(positionCommon, radiusCommon);\n                },\n                padding: 1\n            });\n        }\n        this.setState({ radiusCommon, hexOriginCommon, binIdRange, aggregatorViewport: viewport });\n    }\n    draw(opts) {\n        // Replaces render time viewport with our own\n        if (opts.shaderModuleProps.project) {\n            opts.shaderModuleProps.project.viewport = this.state.aggregatorViewport;\n        }\n        super.draw(opts);\n    }\n    _onAggregationUpdate({ channel }) {\n        const props = this.getCurrentLayer().props;\n        const { aggregator } = this.state;\n        if (channel === 0) {\n            const result = aggregator.getResult(0);\n            this.setState({\n                colors: new AttributeWithScale(result, aggregator.binCount)\n            });\n            props.onSetColorDomain(aggregator.getResultDomain(0));\n        }\n        else if (channel === 1) {\n            const result = aggregator.getResult(1);\n            this.setState({\n                elevations: new AttributeWithScale(result, aggregator.binCount)\n            });\n            props.onSetElevationDomain(aggregator.getResultDomain(1));\n        }\n    }\n    onAttributeChange(id) {\n        const { aggregator } = this.state;\n        switch (id) {\n            case 'positions':\n                aggregator.setNeedsUpdate();\n                this._updateBinOptions();\n                const { radiusCommon, hexOriginCommon, binIdRange } = this.state;\n                aggregator.setProps({\n                    // @ts-expect-error only used by GPUAggregator\n                    binIdRange,\n                    binOptions: {\n                        radiusCommon,\n                        hexOriginCommon\n                    }\n                });\n                break;\n            case 'colorWeights':\n                aggregator.setNeedsUpdate(0);\n                break;\n            case 'elevationWeights':\n                aggregator.setNeedsUpdate(1);\n                break;\n            default:\n            // This should not happen\n        }\n    }\n    renderLayers() {\n        const { aggregator, radiusCommon, hexOriginCommon } = this.state;\n        const { elevationScale, colorRange, elevationRange, extruded, coverage, material, transitions, colorScaleType, lowerPercentile, upperPercentile, colorDomain, elevationScaleType, elevationLowerPercentile, elevationUpperPercentile, elevationDomain } = this.props;\n        const CellLayerClass = this.getSubLayerClass('cells', HexagonCellLayer);\n        const binAttribute = aggregator.getBins();\n        const colors = this.state.colors?.update({\n            scaleType: colorScaleType,\n            lowerPercentile,\n            upperPercentile\n        });\n        const elevations = this.state.elevations?.update({\n            scaleType: elevationScaleType,\n            lowerPercentile: elevationLowerPercentile,\n            upperPercentile: elevationUpperPercentile\n        });\n        if (!colors || !elevations) {\n            return null;\n        }\n        return new CellLayerClass(this.getSubLayerProps({\n            id: 'cells'\n        }), {\n            data: {\n                length: aggregator.binCount,\n                attributes: {\n                    getBin: binAttribute,\n                    getColorValue: colors.attribute,\n                    getElevationValue: elevations.attribute\n                }\n            },\n            // Data has changed shallowly, but we likely don't need to update the attributes\n            dataComparator: (data, oldData) => data.length === oldData.length,\n            updateTriggers: {\n                getBin: [binAttribute],\n                getColorValue: [colors.attribute],\n                getElevationValue: [elevations.attribute]\n            },\n            diskResolution: 6,\n            vertices: HexbinVertices,\n            radius: radiusCommon,\n            hexOriginCommon,\n            elevationScale,\n            colorRange,\n            colorScaleType,\n            elevationRange,\n            extruded,\n            coverage,\n            material,\n            colorDomain: colors.domain || colorDomain || aggregator.getResultDomain(0),\n            elevationDomain: elevations.domain || elevationDomain || aggregator.getResultDomain(1),\n            colorCutoff: colors.cutoff,\n            elevationCutoff: elevations.cutoff,\n            transitions: transitions && {\n                getFillColor: transitions.getColorValue || transitions.getColorWeight,\n                getElevation: transitions.getElevationValue || transitions.getElevationWeight\n            },\n            // Extensions are already handled by the GPUAggregator, do not pass it down\n            extensions: []\n        });\n    }\n    getPickingInfo(params) {\n        const info = params.info;\n        const { index } = info;\n        if (index >= 0) {\n            const bin = this.state.aggregator.getBin(index);\n            let object;\n            if (bin) {\n                const centroidCommon = getHexbinCentroid(bin.id, this.state.radiusCommon);\n                const centroid = this.context.viewport.unprojectFlat(centroidCommon);\n                object = {\n                    col: bin.id[0],\n                    row: bin.id[1],\n                    position: centroid,\n                    colorValue: bin.value[0],\n                    elevationValue: bin.value[1],\n                    count: bin.count\n                };\n                if (bin.pointIndices) {\n                    object.pointIndices = bin.pointIndices;\n                    object.points = Array.isArray(this.props.data)\n                        ? bin.pointIndices.map(i => this.props.data[i])\n                        : [];\n                }\n            }\n            info.object = object;\n        }\n        return info;\n    }\n}\nHexagonLayer.layerName = 'HexagonLayer';\nHexagonLayer.defaultProps = defaultProps;\nexport default HexagonLayer;\n//# sourceMappingURL=hexagon-layer.js.map","// deck.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\n// Inspired by screen-grid-layer vertex shader in deck.gl\nexport default `\\\n#version 300 es\n#define SHADER_NAME heatp-map-layer-vertex-shader\nuniform sampler2D maxTexture;\nin vec3 positions;\nin vec2 texCoords;\nout vec2 vTexCoords;\nout float vIntensityMin;\nout float vIntensityMax;\nvoid main(void) {\ngl_Position = project_position_to_clipspace(positions, vec3(0.0), vec3(0.0));\nvTexCoords = texCoords;\nvec4 maxTexture = texture(maxTexture, vec2(0.5));\nfloat maxValue = triangle.aggregationMode < 0.5 ? maxTexture.r : maxTexture.g;\nfloat minValue = maxValue * triangle.threshold;\nif (triangle.colorDomain[1] > 0.) {\nmaxValue = triangle.colorDomain[1];\nminValue = triangle.colorDomain[0];\n}\nvIntensityMax = triangle.intensity / maxValue;\nvIntensityMin = triangle.intensity / minValue;\n}\n`;\n//# sourceMappingURL=triangle-layer-vertex.glsl.js.map","// deck.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\nexport default `\\\n#version 300 es\n#define SHADER_NAME triangle-layer-fragment-shader\nprecision highp float;\nuniform sampler2D weightsTexture;\nuniform sampler2D colorTexture;\nin vec2 vTexCoords;\nin float vIntensityMin;\nin float vIntensityMax;\nout vec4 fragColor;\nvec4 getLinearColor(float value) {\nfloat factor = clamp(value * vIntensityMax, 0., 1.);\nvec4 color = texture(colorTexture, vec2(factor, 0.5));\ncolor.a *= min(value * vIntensityMin, 1.0);\nreturn color;\n}\nvoid main(void) {\nvec4 weights = texture(weightsTexture, vTexCoords);\nfloat weight = weights.r;\nif (triangle.aggregationMode > 0.5) {\nweight /= max(1.0, weights.a);\n}\nif (weight <= 0.) {\ndiscard;\n}\nvec4 linearColor = getLinearColor(weight);\nlinearColor.a *= layer.opacity;\nfragColor = linearColor;\n}\n`;\n//# sourceMappingURL=triangle-layer-fragment.glsl.js.map","// deck.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\nconst uniformBlock = `\\\nuniform triangleUniforms {\n  float aggregationMode;\n  vec2 colorDomain;\n  float intensity;\n  float threshold;\n} triangle;\n`;\nexport const triangleUniforms = {\n    name: 'triangle',\n    vs: uniformBlock,\n    fs: uniformBlock,\n    uniformTypes: {\n        aggregationMode: 'f32',\n        colorDomain: 'vec2<f32>',\n        intensity: 'f32',\n        threshold: 'f32'\n    }\n};\n//# sourceMappingURL=triangle-layer-uniforms.js.map","// deck.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\nexport default `\\\n#version 300 es\nin vec3 positions;\nin vec3 positions64Low;\nin float weights;\nout vec4 weightsTexture;\nvoid main()\n{\nweightsTexture = vec4(weights * weight.weightsScale, 0., 0., 1.);\nfloat radiusTexels = project_pixel_size(weight.radiusPixels) * weight.textureWidth / (weight.commonBounds.z - weight.commonBounds.x);\ngl_PointSize = radiusTexels * 2.;\nvec3 commonPosition = project_position(positions, positions64Low);\ngl_Position.xy = (commonPosition.xy - weight.commonBounds.xy) / (weight.commonBounds.zw - weight.commonBounds.xy) ;\ngl_Position.xy = (gl_Position.xy * 2.) - (1.);\ngl_Position.w = 1.0;\n}\n`;\n//# sourceMappingURL=weights-vs.glsl.js.map","// deck.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\nexport default `\\\n#version 300 es\nin vec4 weightsTexture;\nout vec4 fragColor;\nfloat gaussianKDE(float u){\nreturn pow(2.71828, -u*u/0.05555)/(1.77245385*0.166666);\n}\nvoid main()\n{\nfloat dist = length(gl_PointCoord - vec2(0.5, 0.5));\nif (dist > 0.5) {\ndiscard;\n}\nfragColor = weightsTexture * gaussianKDE(2. * dist);\nDECKGL_FILTER_COLOR(fragColor, geometry);\n}\n`;\n//# sourceMappingURL=weights-fs.glsl.js.map","// deck.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\nexport default `\\\n#version 300 es\nuniform sampler2D inTexture;\nout vec4 outTexture;\nvoid main()\n{\nint yIndex = gl_VertexID / int(maxWeight.textureSize);\nint xIndex = gl_VertexID - (yIndex * int(maxWeight.textureSize));\nvec2 uv = (0.5 + vec2(float(xIndex), float(yIndex))) / maxWeight.textureSize;\noutTexture = texture(inTexture, uv);\ngl_Position = vec4(0.0, 0.0, 0.0, 1.0);\ngl_PointSize = 1.0;\n}\n`;\n//# sourceMappingURL=max-vs.glsl.js.map","// deck.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\nexport default `\\\n#version 300 es\nin vec4 outTexture;\nout vec4 fragColor;\nvoid main() {\nfragColor = outTexture;\nfragColor.g = outTexture.r / max(1.0, outTexture.a);\n}\n`;\n//# sourceMappingURL=max-fs.glsl.js.map","// deck.gl\n// SPDX-License-Identifier: MIT\n// Copyright (c) vis.gl contributors\nconst uniformBlock = `\\\nuniform weightUniforms {\n  vec4 commonBounds;\n  float radiusPixels;\n  float textureWidth;\n  float weightsScale;\n} weight;\n`;\nexport const weightUniforms = {\n    name: 'weight',\n    vs: uniformBlock,\n    uniformTypes: {\n        commonBounds: 'vec4<f32>',\n        radiusPixels: 'f32',\n        textureWidth: 'f32',\n        weightsScale: 'f32'\n    }\n};\nexport const maxWeightUniforms = {\n    name: 'maxWeight',\n    vs: `\\\nuniform maxWeightUniforms {\n  float textureSize;\n} maxWeight;\n`,\n    uniformTypes: {\n        textureSize: 'f32'\n    }\n};\n//# sourceMappingURL=heatmap-layer-uniforms.js.map","import React, { useState, useEffect, useMemo, useCallback, useRef } from 'react';\r\nimport { Map } from '@vis.gl/react-maplibre';\r\nimport DeckGL from '@deck.gl/react';\r\nimport { ScatterplotLayer } from '@deck.gl/layers';\r\nimport { GridLayer, HexagonLayer, HeatmapLayer } from '@deck.gl/aggregation-layers';\r\nimport { lightingEffect } from './effects.jsx';\r\nimport * as ColorMaps from './ColorScaleMaps.jsx';\r\nimport { useParquetFileUrls } from './FileUrls';\r\nimport WorkerPool from './workers/workerPool'\r\nimport 'maplibre-gl/dist/maplibre-gl.css';\r\nimport LegendPanel from './RightPanel.jsx';\r\n\r\nconst INITIAL_VIEW_STATE = {\r\n    longitude: 15.1,\r\n    latitude: 48.9,\r\n    zoom: 4,\r\n    maxZoom: 12,\r\n    minZoom: 4,\r\n    pitch: 30,\r\n    bearing: 0,\r\n};\r\n\r\nexport default function ParquetMap() {\r\n    const [mapStyle, setMapStyle] = useState(true)\r\n    const [mapReady, setMapReady] = useState(true); // Карта всегда готова к отображению\r\n    const [allData, setAllData] = useState([]);\r\n    const [isLoading, setIsLoading] = useState(true);\r\n    const [processedFiles, setProcessedFiles] = useState(0);\r\n    const [totalFiles, setTotalFiles] = useState(0);\r\n    const [error, setError] = useState(null);\r\n    const [elevation, setElevation] = useState(0);\r\n    const [showHex, setShowHex] = useState(true);\r\n    const [activeLayerKey, setActiveLayerKey] = useState('scatterplot');\r\n    const [activeColorSchemeKey, setActiveColorSchemeKey] = useState('ElectricViolet'); // <-- Ключ схемы по умолчанию для Scatterplot\r\n    const [activeColorHexagonSchemeKey, setActiveColorHexagonSchemeKey] = useState('BrightSpectrum'); // <-- Ключ схемы по умолчанию для Hexagon/Heatmap\r\n    const [totalDataLenght, setTotalDataLenght] = useState()\r\n\r\n\r\n    // Ref для отслеживания монтирования компонента\r\n    const isMountedRef = useRef(true);\r\n    const loadingStartedRef = useRef(false);\r\n    const fileUrls = useParquetFileUrls();\r\n\r\n    const workerPoolRef = useRef(null);\r\n    const currentDataRef = useRef({ src: new Float32Array(0), length: 0 });\r\n\r\n    const darkMatterStyle = 'https://basemaps.cartocdn.com/gl/dark-matter-gl-style/style.json';\r\n    const darkMatterNolabels = 'https://basemaps.cartocdn.com/gl/dark-matter-nolabels-gl-style/style.json';\r\n\r\n    const setActiveMapStyleOnMap = useMemo(() => {\r\n        return mapStyle ? darkMatterNolabels : darkMatterStyle\r\n    }, [mapStyle]);\r\n\r\n    useEffect(() => {\r\n        // Сброс данных при изменении списка файлов\r\n        // if (fileUrls.length > 0) {\r\n        //     setAllData([{ src: new Float32Array(0), length: 0 }]);\r\n        //     loadingStartedRef.current = false;\r\n        // }\r\n    }, [fileUrls]);\r\n\r\n    // Выбираем актуальную функцию цветовой шкалы на основе ключа для ScatterplotLayer\r\n    const activeColorScaleFunction = useMemo(() => {\r\n        const schemeMap = {\r\n            'ElectricViolet': ColorMaps.avgd_ElectricViolet_ScaleFunction,\r\n            'VividGem': ColorMaps.avgd_VividGem_ScaleFunction,\r\n            'InfernoLava': ColorMaps.avgd_InfernoGradient_ScaleFunction,\r\n            'MutedStone': ColorMaps.avgd_MutedStone_ScaleFunction,\r\n        };\r\n        const selectedFunction = schemeMap[activeColorSchemeKey];\r\n        if (selectedFunction) {\r\n            return selectedFunction;\r\n        } else {\r\n            console.warn(`Unknown color scheme key: ${activeColorSchemeKey}. Using the default 'blues' scheme.`);\r\n            return ColorMaps.avgd_ElectricViolet_ScaleFunction;\r\n        }\r\n    }, [activeColorSchemeKey]);\r\n\r\n    // Выбираем актуальную цветовую шкалу на основе ключа для HexagonLayer и HeatmapLayer\r\n    const activeColorHexagonScaleFunction = useMemo(() => {\r\n        const schemeMap = {\r\n            'BrightSpectrum': ColorMaps.COLOR_RANGE_AGGREGATE.BrightSpectrum,\r\n            'DeepMauve': ColorMaps.COLOR_RANGE_AGGREGATE.DeepMauve,\r\n            'TwilightBlue': ColorMaps.COLOR_RANGE_AGGREGATE.TwilightBlue,\r\n            'MarineTeal': ColorMaps.COLOR_RANGE_AGGREGATE.MarineTeal,\r\n        };\r\n        const selectedFunction = schemeMap[activeColorHexagonSchemeKey];\r\n        if (selectedFunction) {\r\n            return selectedFunction;\r\n        } else {\r\n            console.warn(`Unknown color scheme key: ${activeColorHexagonSchemeKey}. Using the default 'blues' scheme.`);\r\n            return ColorMaps.COLOR_RANGE_AGGREGATE.MarineTeal;\r\n        }\r\n    }, [activeColorHexagonSchemeKey]);\r\n\r\n    // Создаем слои на основе текущих данных\r\n    const layers = useMemo(() => {\r\n        if (allData.length === 0 || allData[0].length === 0) return [];\r\n        const commonProps = {\r\n            data: allData[0],\r\n            getPosition: (_, { index, data, target }) => {\r\n                target[0] = data.src[index * 6];\r\n                target[1] = data.src[index * 6 + 1];\r\n                target[2] = 0;\r\n                return target;\r\n            },\r\n            colorRange: activeColorHexagonScaleFunction,\r\n            updateTriggers: {\r\n                elevationScale: [elevation],\r\n                colorRange: activeColorHexagonScaleFunction,\r\n            }\r\n        };\r\n\r\n        const layersArray = [];\r\n\r\n        // --- Конфигурация первого слоя ---\r\n        if (activeLayerKey === 'hexagon') {\r\n            layersArray.push(new HexagonLayer({\r\n                id: 'hexagon-layer',\r\n                ...commonProps,\r\n                coverage: .9,\r\n                gpuAggregation: true,\r\n                radius: 1000,\r\n                // elevationRange: [1, 150],\r\n                // elevationScale: elevation,\r\n                // extruded: true,\r\n                upperPercentile: 1000,\r\n                material: { ambient: 0.94, diffuse: 0.4, shininess: 32 }, //, specularColor: [51, 51, 51] \r\n                // transitions: { elevationScale: 3000 },\r\n            }));\r\n            // --- Конфигурация второго слоя ---\r\n        } else if (activeLayerKey === 'heatmap') {\r\n            layersArray.push(new HeatmapLayer({\r\n                id: 'heatmap-layer',\r\n                ...commonProps,\r\n                radiusPixels: 3,\r\n                intensity: .7,\r\n                threshold: 0.5,\r\n            }));\r\n            // --- Конфигурация третьего слоя ---\r\n        } else if (activeLayerKey === 'scatterplot') {\r\n            layersArray.push(new ScatterplotLayer({\r\n                id: 'scatterplot-layer',\r\n                ...commonProps,\r\n                gpuAggregation: true,\r\n                // pickable: true,\r\n                filled: true,\r\n                opacity: 1,\r\n                radiusScale: 200,\r\n                parameters: {\r\n                    depthTest: false\r\n                },\r\n                getFillColor: (_, { index, data, target }) => {\r\n                    target[0] = data.src[index * 6 + 3];\r\n                    return activeColorScaleFunction(target * 5);\r\n                },\r\n                updateTriggers: {\r\n                    getFillColor: [\r\n                        commonProps.data,\r\n                        activeColorScaleFunction,\r\n                    ],\r\n                },\r\n            }));\r\n        }\r\n\r\n        return layersArray;\r\n    }, [allData, elevation, activeLayerKey, activeColorScaleFunction, activeColorHexagonScaleFunction]);\r\n\r\n    // Функция для объединения данных\r\n    const mergeData = useCallback((existingData, newData) => {\r\n        if (!newData || newData.length === 0) return existingData;\r\n        if (existingData.length === 0) return newData;\r\n\r\n        const totalLength = existingData.length + newData.length;\r\n        const combinedSrc = new Float32Array(totalLength * 6);\r\n\r\n        // Копируем существующие данные\r\n        combinedSrc.set(existingData.src);\r\n\r\n        // Добавляем новые данные\r\n        combinedSrc.set(newData.src, existingData.length * 6);\r\n        setTotalDataLenght(totalLength)\r\n\r\n        return { src: combinedSrc, length: totalLength };\r\n    }, []);\r\n\r\n    // Эффект для инициализации и загрузки данных\r\n    useEffect(() => {\r\n        if (loadingStartedRef.current) {\r\n            console.log(\"Data loading already started, skipping.\");\r\n            return;\r\n        }\r\n\r\n        async function initialize() {\r\n            loadingStartedRef.current = true;\r\n            console.log(\"Starting data loading process\");\r\n\r\n            // Инициализируем состояние\r\n            setProcessedFiles(0);\r\n            setTotalFiles(fileUrls.length);\r\n            setIsLoading(true);\r\n            setError(null);\r\n            setMapReady(true);\r\n\r\n            // Создаем worker pool\r\n            // Вместо\r\n            // const worker = new Worker(new URL('./parquetWorker.js', import.meta.url), { type: 'module' });\r\n\r\n            // Используйте инлайн воркер с CDN-версиями библиотек\r\n            const workerCode = `\r\n  // Глобальный обработчик ошибок\r\n  self.onerror = function(e) {\r\n    console.error('Global worker error caught:', e);\r\n    return true;\r\n  };\r\n\r\n  console.log('Worker: Starting initialization...');\r\n\r\n  // Загружаем зависимости напрямую с CDN\r\n  self.importScripts(\r\n    'https://unpkg.com/apache-arrow@13.0.0/Arrow.es2015.min.js',\r\n    'https://cdn.jsdelivr.net/npm/parquet-wasm@0.6.1/+esm'\r\n  );\r\n  \r\n  console.log('Worker: Libraries loaded via importScripts');\r\n  \r\n  // Проверяем, что библиотеки загрузились правильно\r\n  if (!self.Apache || !self.Apache.Arrow) {\r\n    throw new Error('Apache Arrow library not loaded correctly');\r\n  }\r\n  \r\n  if (!self.parquetWasm) {\r\n    throw new Error('Parquet WASM library not loaded correctly');\r\n  }\r\n  \r\n  // Получаем необходимые функции из загруженных библиотек\r\n  const tableFromIPC = self.Apache.Arrow.tableFromIPC;\r\n  const initWasm = self.parquetWasm.default;\r\n  const readParquet = self.parquetWasm.readParquet;\r\n  \r\n  // Инициализируем WASM при старте воркера один раз\r\n  let wasmInitialized = false;\r\n  \r\n  async function ensureWasmInitialized() {\r\n    console.log('Worker: Ensuring WASM is initialized...');\r\n    if (!wasmInitialized) {\r\n      console.log('Worker: Initializing WASM...');\r\n      try {\r\n        await initWasm();\r\n        wasmInitialized = true;\r\n        console.log('Worker: WASM initialized successfully');\r\n      } catch (error) {\r\n        console.error('Worker: WASM initialization error:', error);\r\n        throw error;\r\n      }\r\n    }\r\n  }\r\n  \r\n  self.onmessage = async function (e) {\r\n    // Используем let для taskId и url, чтобы они были доступны в catch блоке\r\n    let taskId = -1;\r\n    let url = 'unknown';\r\n    \r\n    try {\r\n      console.log('Worker: Received message:', e.data);\r\n      \r\n      // --- Получение taskId и данных задачи ---\r\n      if (!e.data || typeof e.data !== 'object' || !('taskId' in e.data) || !e.data.data || typeof e.data.data !== 'object' || !('url' in e.data.data)) {\r\n        throw new Error('Invalid message format received by worker: missing taskId or data.url.');\r\n      }\r\n      \r\n      taskId = e.data.taskId;\r\n      url = e.data.data.url;\r\n      console.log(\\`Worker: Processing task \\${taskId} for URL: \\${url}\\`);\r\n      \r\n      // Инициализация WASM\r\n      await ensureWasmInitialized();\r\n      \r\n      // Получение данных Parquet\r\n      console.log(\\`Worker: Fetching Parquet data from \\${url}\\`);\r\n      const res = await fetch(url);\r\n      \r\n      if (!res.ok) {\r\n        throw new Error(\\`HTTP error! Status: \\${res.status} for \\${url}\\`);\r\n      }\r\n      \r\n      const parquetUint8Array = new Uint8Array(await res.arrayBuffer());\r\n      console.log(\\`Worker: Parquet data fetched, size: \\${parquetUint8Array.length} bytes\\`);\r\n      \r\n      // Чтение parquet данных\r\n      console.log('Worker: Reading Parquet data...');\r\n      const arrowWasmTable = readParquet(parquetUint8Array);\r\n      const arrowTable = tableFromIPC(arrowWasmTable.intoIPCStream());\r\n      console.log('Worker: Parquet data read successfully');\r\n      \r\n      // --- Проверка наличия батчей и получение данных ---\r\n      if (!arrowTable.batches || arrowTable.batches.length === 0) {\r\n        console.log(\\`Worker: Task \\${taskId}: No batches in arrow table, returning empty result\\`);\r\n        self.postMessage({\r\n          taskId: taskId,\r\n          success: true,\r\n          data: { src: new Float32Array(0), length: 0, url }\r\n        }, [new Float32Array(0).buffer]);\r\n        return;\r\n      }\r\n      \r\n      const recordBatch = arrowTable.batches[0];\r\n      const arrowSchema = arrowTable.schema;\r\n      \r\n      // Проверка stride\r\n      const strideStr = arrowSchema.metadata.get('stride');\r\n      const stride = parseInt(strideStr);\r\n      if (isNaN(stride) || stride <= 0) {\r\n        throw new Error(\\`Worker task \\${taskId} (\\${url}): Invalid stride value \"\\${strideStr}\" (\\${stride}) in metadata.\\`);\r\n      }\r\n      \r\n      // Получение массива float32\r\n      const float32Array = recordBatch.data.children[0].children[0].values;\r\n      const numRecords = float32Array.length / stride;\r\n      console.log(\\`Worker: Processing \\${numRecords} records with stride \\${stride}\\`);\r\n      \r\n      // --- Преобразование данных ---\r\n      const binaryData = new Float32Array(numRecords * 6);\r\n      for (let i = 0; i < numRecords; i++) {\r\n        const index = i * stride;\r\n        const newIndex = i * 6;\r\n        \r\n        binaryData[newIndex + 0] = float32Array[index + 0]; // longitude\r\n        binaryData[newIndex + 1] = float32Array[index + 1]; // latitude\r\n        binaryData[newIndex + 2] = float32Array[index + 2]; // country\r\n        binaryData[newIndex + 3] = float32Array[index + 3]; // downloadSpeed\r\n        binaryData[newIndex + 4] = float32Array[index + 4]; // uploadSpeed\r\n        binaryData[newIndex + 5] = float32Array[index + 5]; // countryCode\r\n      }\r\n      \r\n      // --- Отправка результатов ---\r\n      console.log(\\`Worker: Task \\${taskId}: Sending processed data (\\${numRecords} records)\\`);\r\n      self.postMessage({\r\n        taskId: taskId,\r\n        success: true,\r\n        data: { src: binaryData, length: numRecords, url }\r\n      }, [binaryData.buffer]);\r\n      \r\n    } catch (error) {\r\n      // --- Логирование ошибки в воркере и отправка в основной поток ---\r\n      console.error(\\`Worker task \\${taskId} (\\${url}) caught error:\\`, error);\r\n      \r\n      self.postMessage({\r\n        taskId: taskId,\r\n        success: false,\r\n        error: error.message || 'Unknown worker error',\r\n        stack: error.stack,\r\n        url: url\r\n      });\r\n    }\r\n  };\r\n  \r\n  console.log('Worker: Initialization complete, ready to process messages');\r\n`;\r\n\r\n            // Создаем Blob из кода воркера\r\n            const workerBlob = new Blob([workerCode], { type: 'application/javascript' });\r\n            // Создаем URL для этого Blob\r\n            const workerUrl = URL.createObjectURL(workerBlob);\r\n            // Создаем воркер с этим URL\r\n            const workerScriptUrl = new Worker(workerUrl);\r\n\r\n            // Не забудьте освободить URL, когда он больше не нужен\r\n            window.addEventListener('unload', () => URL.revokeObjectURL(workerUrl));\r\n            // const workerScriptUrl = new URL('./workers/parquetWorker.js', import.meta.url);\r\n            console.log('workerScriptUrl', workerScriptUrl)\r\n            workerPoolRef.current = new WorkerPool(workerScriptUrl, 10, { type: 'module' });\r\n            console.log('workerPoolRef.current', workerPoolRef.current)\r\n            // Сбрасываем текущие данные\r\n            currentDataRef.current = { src: new Float32Array(0), length: 0 };\r\n\r\n            // Обрабатываем файлы\r\n            console.time(\"⏱️ Full Feature Load Time\");\r\n            await processFilesWithWorkers(fileUrls);\r\n            console.timeEnd(\"⏱️ Full Feature Load Time\");\r\n\r\n            if (isMountedRef.current) {\r\n                setIsLoading(false);\r\n            }\r\n        }\r\n\r\n        initialize();\r\n        const timer = setTimeout(() => setElevation(50), 2500);\r\n\r\n        // Очистка\r\n        return () => {\r\n            console.log(\"Component unmounted\");\r\n            clearTimeout(timer);\r\n            isMountedRef.current = false;\r\n\r\n            if (workerPoolRef.current) {\r\n                workerPoolRef.current.terminate();\r\n            }\r\n        };\r\n    }, [fileUrls]);\r\n\r\n    // Функция для обработки файлов с использованием воркер-пула\r\n    const processFilesWithWorkers = useCallback(async (urls) => {\r\n        const BATCH_SIZE = 10;\r\n        for (let i = 0; i < urls.length; i += BATCH_SIZE) {\r\n            const batchUrls = urls.slice(i, i + BATCH_SIZE);\r\n            const batchPromises = batchUrls.map(url => workerPoolRef.current.enqueueTask({ url }) // enqueueTask теперь вернет Promise\r\n                .then(result => { // Этот .then сработает при success: true\r\n                    if (!isMountedRef.current) return null;\r\n                    setProcessedFiles(prev => prev + 1);\r\n                    // result будет иметь структуру { success: true, data: { src, length, url } }\r\n                    return result.data;\r\n                })\r\n                .catch(error => { // Добавляем .catch для обработки ошибок воркера\r\n                    if (!isMountedRef.current) return null;\r\n                    setProcessedFiles(prev => prev + 1); // Считаем файл обработанным (неудачно)\r\n                    console.error(`Failed to process file ${url}:`, error);\r\n                    // Возможно, здесь нужно показать ошибку пользователю setErrorMessage(...)\r\n                    return null; // Возвращаем null для неудачного файла\r\n                })\r\n            );\r\n            const batchResults = await Promise.all(batchPromises);\r\n\r\n            // Объединяем результаты текущего пакета\r\n            let batchData = { src: new Float32Array(0), length: 0 };\r\n            for (const result of batchResults) {\r\n                if (result) {\r\n                    batchData = mergeData(batchData, result);\r\n                }\r\n            }\r\n\r\n            // Объединяем с общими данными\r\n            if (batchData.length > 0 && isMountedRef.current) {\r\n                const newData = mergeData(currentDataRef.current, batchData);\r\n                currentDataRef.current = newData;\r\n                setAllData([newData]);\r\n            }\r\n        }\r\n    }, [mergeData, isMountedRef, setProcessedFiles]);\r\n\r\n    // Функция для тултипа\r\n    const getTooltip = useCallback(({ index }) => {\r\n        if (index === -1 || !allData.length) return null;\r\n\r\n        const { src } = allData[0];\r\n        const i = index * 6;\r\n\r\n        if (i + 5 >= src.length) return null;\r\n\r\n        return {\r\n            html: `\r\n        <div class=\"custom-tooltip\">\r\n          <b>Download:</b> ${(src[i + 3] / 1000).toFixed(2)} Mbps<br>\r\n          <b>Upload:</b>  ${(src[i + 4] / 1000).toFixed(2)} Mbps<br>\r\n          <b>Country Code:</b> ${src[i + 5]}\r\n        </div>\r\n      `,\r\n            style: {\r\n                backgroundColor: '#1a1a1a',\r\n                fontSize: '14px',\r\n                padding: '10px',\r\n                borderRadius: '4px'\r\n            }\r\n        };\r\n    }, [allData]);\r\n\r\n    // DeckGL опции\r\n    const deckGLOptions = useMemo(() => ({\r\n        initialViewState: INITIAL_VIEW_STATE,\r\n        controller: true,\r\n        layers: layers,\r\n        useDevicePixels: false,\r\n    }), [layers]);\r\n    // console.log('layers after setAllData:', layers);\r\n    return (\r\n        <div>\r\n            {/* Карта всегда отображается немедленно */}\r\n            {mapReady && (\r\n                <DeckGL {...deckGLOptions} effects={[lightingEffect]} > {/* getTooltip={getTooltip} */}\r\n                    <Map mapStyle={setActiveMapStyleOnMap} />\r\n                    <div className=\"rotate-shift\">\r\n                        Hold down shift to rotate <br />\r\n                        Zum Drehen Umschalttaste gedrückt halten\r\n                    </div>\r\n                    <LegendPanel\r\n                        showHex={showHex}\r\n                        setShowHex={setShowHex}\r\n                        mapStyle={mapStyle}\r\n                        setMapStyle={setMapStyle}\r\n                        activeColorHexagonSchemeKey={activeColorHexagonSchemeKey}\r\n                        setActiveColorHexagonSchemeKey={setActiveColorHexagonSchemeKey}\r\n                        activeColorSchemeKey={activeColorSchemeKey}\r\n                        setActiveColorSchemeKey={setActiveColorSchemeKey}\r\n                        activeLayerKey={activeLayerKey}\r\n                        setActiveLayerKey={setActiveLayerKey}\r\n                        totalDataLenght={totalDataLenght}\r\n                    />\r\n                </DeckGL>\r\n            )}\r\n            {/* Прогресс загрузки поверх карты */}\r\n            {isLoading && (\r\n                <div style={{\r\n                    position: 'absolute',\r\n                    top: '20px',\r\n                    left: '50%',\r\n                    transform: 'translateX(-50%)',\r\n                    background: 'rgba(0,0,0,0.7)',\r\n                    color: 'white',\r\n                    padding: '10px',\r\n                    borderRadius: '5px',\r\n                    zIndex: 100\r\n                }}>\r\n\r\n                    Downloaded {processedFiles} of {totalFiles} files ({Math.round(processedFiles / totalFiles * 100)}%)\r\n                </div>\r\n            )}\r\n            {error && (\r\n                <div style={{ position: 'absolute', bottom: '10px', left: '10px', background: 'rgba(255,0,0,0.7)', color: 'white', padding: '10px', borderRadius: '4px', zIndex: 10 }}>\r\n                    Loading Error: {error.message}\r\n                </div>\r\n            )}\r\n        </div>\r\n    );\r\n}"],"file":"assets/index-CRT4U-wY.js"}
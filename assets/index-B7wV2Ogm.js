var __defProp = Object.defineProperty;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __publicField = (obj, key, value) => __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
let Hv;
let __tla = (async () => {
  var _a, _b2;
  (function() {
    const e = document.createElement("link").relList;
    if (e && e.supports && e.supports("modulepreload")) return;
    for (const s of document.querySelectorAll('link[rel="modulepreload"]')) i(s);
    new MutationObserver((s) => {
      for (const a of s) if (a.type === "childList") for (const l of a.addedNodes) l.tagName === "LINK" && l.rel === "modulepreload" && i(l);
    }).observe(document, {
      childList: true,
      subtree: true
    });
    function t(s) {
      const a = {};
      return s.integrity && (a.integrity = s.integrity), s.referrerPolicy && (a.referrerPolicy = s.referrerPolicy), s.crossOrigin === "use-credentials" ? a.credentials = "include" : s.crossOrigin === "anonymous" ? a.credentials = "omit" : a.credentials = "same-origin", a;
    }
    function i(s) {
      if (s.ep) return;
      s.ep = true;
      const a = t(s);
      fetch(s.href, a);
    }
  })();
  Hv = function(n) {
    return n && n.__esModule && Object.prototype.hasOwnProperty.call(n, "default") ? n.default : n;
  };
  var bh = {
    exports: {}
  }, Ka = {};
  var Hy;
  function gS() {
    if (Hy) return Ka;
    Hy = 1;
    var n = Symbol.for("react.transitional.element"), e = Symbol.for("react.fragment");
    function t(i, s, a) {
      var l = null;
      if (a !== void 0 && (l = "" + a), s.key !== void 0 && (l = "" + s.key), "key" in s) {
        a = {};
        for (var u in s) u !== "key" && (a[u] = s[u]);
      } else a = s;
      return s = a.ref, {
        $$typeof: n,
        type: i,
        key: l,
        ref: s !== void 0 ? s : null,
        props: a
      };
    }
    return Ka.Fragment = e, Ka.jsx = t, Ka.jsxs = t, Ka;
  }
  var jy;
  function pS() {
    return jy || (jy = 1, bh.exports = gS()), bh.exports;
  }
  var Te = pS(), vh = {
    exports: {}
  }, we = {};
  var Wy;
  function mS() {
    if (Wy) return we;
    Wy = 1;
    var n = Symbol.for("react.transitional.element"), e = Symbol.for("react.portal"), t = Symbol.for("react.fragment"), i = Symbol.for("react.strict_mode"), s = Symbol.for("react.profiler"), a = Symbol.for("react.consumer"), l = Symbol.for("react.context"), u = Symbol.for("react.forward_ref"), h = Symbol.for("react.suspense"), d = Symbol.for("react.memo"), p = Symbol.for("react.lazy"), _ = Symbol.iterator;
    function y(R) {
      return R === null || typeof R != "object" ? null : (R = _ && R[_] || R["@@iterator"], typeof R == "function" ? R : null);
    }
    var v = {
      isMounted: function() {
        return false;
      },
      enqueueForceUpdate: function() {
      },
      enqueueReplaceState: function() {
      },
      enqueueSetState: function() {
      }
    }, S = Object.assign, E = {};
    function M(R, Q, oe) {
      this.props = R, this.context = Q, this.refs = E, this.updater = oe || v;
    }
    M.prototype.isReactComponent = {}, M.prototype.setState = function(R, Q) {
      if (typeof R != "object" && typeof R != "function" && R != null) throw Error("takes an object of state variables to update or a function which returns an object of state variables.");
      this.updater.enqueueSetState(this, R, Q, "setState");
    }, M.prototype.forceUpdate = function(R) {
      this.updater.enqueueForceUpdate(this, R, "forceUpdate");
    };
    function F() {
    }
    F.prototype = M.prototype;
    function H(R, Q, oe) {
      this.props = R, this.context = Q, this.refs = E, this.updater = oe || v;
    }
    var O = H.prototype = new F();
    O.constructor = H, S(O, M.prototype), O.isPureReactComponent = true;
    var U = Array.isArray, B = {
      H: null,
      A: null,
      T: null,
      S: null,
      V: null
    }, Z = Object.prototype.hasOwnProperty;
    function re(R, Q, oe, se, ae, de) {
      return oe = de.ref, {
        $$typeof: n,
        type: R,
        key: Q,
        ref: oe !== void 0 ? oe : null,
        props: de
      };
    }
    function le(R, Q) {
      return re(R.type, Q, void 0, void 0, void 0, R.props);
    }
    function ee(R) {
      return typeof R == "object" && R !== null && R.$$typeof === n;
    }
    function fe(R) {
      var Q = {
        "=": "=0",
        ":": "=2"
      };
      return "$" + R.replace(/[=:]/g, function(oe) {
        return Q[oe];
      });
    }
    var te = /\/+/g;
    function ye(R, Q) {
      return typeof R == "object" && R !== null && R.key != null ? fe("" + R.key) : Q.toString(36);
    }
    function xe() {
    }
    function ve(R) {
      switch (R.status) {
        case "fulfilled":
          return R.value;
        case "rejected":
          throw R.reason;
        default:
          switch (typeof R.status == "string" ? R.then(xe, xe) : (R.status = "pending", R.then(function(Q) {
            R.status === "pending" && (R.status = "fulfilled", R.value = Q);
          }, function(Q) {
            R.status === "pending" && (R.status = "rejected", R.reason = Q);
          })), R.status) {
            case "fulfilled":
              return R.value;
            case "rejected":
              throw R.reason;
          }
      }
      throw R;
    }
    function Ue(R, Q, oe, se, ae) {
      var de = typeof R;
      (de === "undefined" || de === "boolean") && (R = null);
      var ue = false;
      if (R === null) ue = true;
      else switch (de) {
        case "bigint":
        case "string":
        case "number":
          ue = true;
          break;
        case "object":
          switch (R.$$typeof) {
            case n:
            case e:
              ue = true;
              break;
            case p:
              return ue = R._init, Ue(ue(R._payload), Q, oe, se, ae);
          }
      }
      if (ue) return ae = ae(R), ue = se === "" ? "." + ye(R, 0) : se, U(ae) ? (oe = "", ue != null && (oe = ue.replace(te, "$&/") + "/"), Ue(ae, Q, oe, "", function(pt) {
        return pt;
      })) : ae != null && (ee(ae) && (ae = le(ae, oe + (ae.key == null || R && R.key === ae.key ? "" : ("" + ae.key).replace(te, "$&/") + "/") + ue)), Q.push(ae)), 1;
      ue = 0;
      var Ge = se === "" ? "." : se + ":";
      if (U(R)) for (var Pe = 0; Pe < R.length; Pe++) se = R[Pe], de = Ge + ye(se, Pe), ue += Ue(se, Q, oe, de, ae);
      else if (Pe = y(R), typeof Pe == "function") for (R = Pe.call(R), Pe = 0; !(se = R.next()).done; ) se = se.value, de = Ge + ye(se, Pe++), ue += Ue(se, Q, oe, de, ae);
      else if (de === "object") {
        if (typeof R.then == "function") return Ue(ve(R), Q, oe, se, ae);
        throw Q = String(R), Error("Objects are not valid as a React child (found: " + (Q === "[object Object]" ? "object with keys {" + Object.keys(R).join(", ") + "}" : Q) + "). If you meant to render a collection of children, use an array instead.");
      }
      return ue;
    }
    function $(R, Q, oe) {
      if (R == null) return R;
      var se = [], ae = 0;
      return Ue(R, se, "", "", function(de) {
        return Q.call(oe, de, ae++);
      }), se;
    }
    function ne(R) {
      if (R._status === -1) {
        var Q = R._result;
        Q = Q(), Q.then(function(oe) {
          (R._status === 0 || R._status === -1) && (R._status = 1, R._result = oe);
        }, function(oe) {
          (R._status === 0 || R._status === -1) && (R._status = 2, R._result = oe);
        }), R._status === -1 && (R._status = 0, R._result = Q);
      }
      if (R._status === 1) return R._result.default;
      throw R._result;
    }
    var he = typeof reportError == "function" ? reportError : function(R) {
      if (typeof window == "object" && typeof window.ErrorEvent == "function") {
        var Q = new window.ErrorEvent("error", {
          bubbles: true,
          cancelable: true,
          message: typeof R == "object" && R !== null && typeof R.message == "string" ? String(R.message) : String(R),
          error: R
        });
        if (!window.dispatchEvent(Q)) return;
      } else if (typeof process == "object" && typeof process.emit == "function") {
        process.emit("uncaughtException", R);
        return;
      }
      console.error(R);
    };
    function Ae() {
    }
    return we.Children = {
      map: $,
      forEach: function(R, Q, oe) {
        $(R, function() {
          Q.apply(this, arguments);
        }, oe);
      },
      count: function(R) {
        var Q = 0;
        return $(R, function() {
          Q++;
        }), Q;
      },
      toArray: function(R) {
        return $(R, function(Q) {
          return Q;
        }) || [];
      },
      only: function(R) {
        if (!ee(R)) throw Error("React.Children.only expected to receive a single React element child.");
        return R;
      }
    }, we.Component = M, we.Fragment = t, we.Profiler = s, we.PureComponent = H, we.StrictMode = i, we.Suspense = h, we.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE = B, we.__COMPILER_RUNTIME = {
      __proto__: null,
      c: function(R) {
        return B.H.useMemoCache(R);
      }
    }, we.cache = function(R) {
      return function() {
        return R.apply(null, arguments);
      };
    }, we.cloneElement = function(R, Q, oe) {
      if (R == null) throw Error("The argument must be a React element, but you passed " + R + ".");
      var se = S({}, R.props), ae = R.key, de = void 0;
      if (Q != null) for (ue in Q.ref !== void 0 && (de = void 0), Q.key !== void 0 && (ae = "" + Q.key), Q) !Z.call(Q, ue) || ue === "key" || ue === "__self" || ue === "__source" || ue === "ref" && Q.ref === void 0 || (se[ue] = Q[ue]);
      var ue = arguments.length - 2;
      if (ue === 1) se.children = oe;
      else if (1 < ue) {
        for (var Ge = Array(ue), Pe = 0; Pe < ue; Pe++) Ge[Pe] = arguments[Pe + 2];
        se.children = Ge;
      }
      return re(R.type, ae, void 0, void 0, de, se);
    }, we.createContext = function(R) {
      return R = {
        $$typeof: l,
        _currentValue: R,
        _currentValue2: R,
        _threadCount: 0,
        Provider: null,
        Consumer: null
      }, R.Provider = R, R.Consumer = {
        $$typeof: a,
        _context: R
      }, R;
    }, we.createElement = function(R, Q, oe) {
      var se, ae = {}, de = null;
      if (Q != null) for (se in Q.key !== void 0 && (de = "" + Q.key), Q) Z.call(Q, se) && se !== "key" && se !== "__self" && se !== "__source" && (ae[se] = Q[se]);
      var ue = arguments.length - 2;
      if (ue === 1) ae.children = oe;
      else if (1 < ue) {
        for (var Ge = Array(ue), Pe = 0; Pe < ue; Pe++) Ge[Pe] = arguments[Pe + 2];
        ae.children = Ge;
      }
      if (R && R.defaultProps) for (se in ue = R.defaultProps, ue) ae[se] === void 0 && (ae[se] = ue[se]);
      return re(R, de, void 0, void 0, null, ae);
    }, we.createRef = function() {
      return {
        current: null
      };
    }, we.forwardRef = function(R) {
      return {
        $$typeof: u,
        render: R
      };
    }, we.isValidElement = ee, we.lazy = function(R) {
      return {
        $$typeof: p,
        _payload: {
          _status: -1,
          _result: R
        },
        _init: ne
      };
    }, we.memo = function(R, Q) {
      return {
        $$typeof: d,
        type: R,
        compare: Q === void 0 ? null : Q
      };
    }, we.startTransition = function(R) {
      var Q = B.T, oe = {};
      B.T = oe;
      try {
        var se = R(), ae = B.S;
        ae !== null && ae(oe, se), typeof se == "object" && se !== null && typeof se.then == "function" && se.then(Ae, he);
      } catch (de) {
        he(de);
      } finally {
        B.T = Q;
      }
    }, we.unstable_useCacheRefresh = function() {
      return B.H.useCacheRefresh();
    }, we.use = function(R) {
      return B.H.use(R);
    }, we.useActionState = function(R, Q, oe) {
      return B.H.useActionState(R, Q, oe);
    }, we.useCallback = function(R, Q) {
      return B.H.useCallback(R, Q);
    }, we.useContext = function(R) {
      return B.H.useContext(R);
    }, we.useDebugValue = function() {
    }, we.useDeferredValue = function(R, Q) {
      return B.H.useDeferredValue(R, Q);
    }, we.useEffect = function(R, Q, oe) {
      var se = B.H;
      if (typeof oe == "function") throw Error("useEffect CRUD overload is not enabled in this build of React.");
      return se.useEffect(R, Q);
    }, we.useId = function() {
      return B.H.useId();
    }, we.useImperativeHandle = function(R, Q, oe) {
      return B.H.useImperativeHandle(R, Q, oe);
    }, we.useInsertionEffect = function(R, Q) {
      return B.H.useInsertionEffect(R, Q);
    }, we.useLayoutEffect = function(R, Q) {
      return B.H.useLayoutEffect(R, Q);
    }, we.useMemo = function(R, Q) {
      return B.H.useMemo(R, Q);
    }, we.useOptimistic = function(R, Q) {
      return B.H.useOptimistic(R, Q);
    }, we.useReducer = function(R, Q, oe) {
      return B.H.useReducer(R, Q, oe);
    }, we.useRef = function(R) {
      return B.H.useRef(R);
    }, we.useState = function(R) {
      return B.H.useState(R);
    }, we.useSyncExternalStore = function(R, Q, oe) {
      return B.H.useSyncExternalStore(R, Q, oe);
    }, we.useTransition = function() {
      return B.H.useTransition();
    }, we.version = "19.1.0", we;
  }
  var $y;
  function Gd() {
    return $y || ($y = 1, vh.exports = mS()), vh.exports;
  }
  var G = Gd(), Th = {
    exports: {}
  }, Za = {}, xh = {
    exports: {}
  }, Sh = {};
  var Xy;
  function _S() {
    return Xy || (Xy = 1, function(n) {
      function e($, ne) {
        var he = $.length;
        $.push(ne);
        e: for (; 0 < he; ) {
          var Ae = he - 1 >>> 1, R = $[Ae];
          if (0 < s(R, ne)) $[Ae] = ne, $[he] = R, he = Ae;
          else break e;
        }
      }
      function t($) {
        return $.length === 0 ? null : $[0];
      }
      function i($) {
        if ($.length === 0) return null;
        var ne = $[0], he = $.pop();
        if (he !== ne) {
          $[0] = he;
          e: for (var Ae = 0, R = $.length, Q = R >>> 1; Ae < Q; ) {
            var oe = 2 * (Ae + 1) - 1, se = $[oe], ae = oe + 1, de = $[ae];
            if (0 > s(se, he)) ae < R && 0 > s(de, se) ? ($[Ae] = de, $[ae] = he, Ae = ae) : ($[Ae] = se, $[oe] = he, Ae = oe);
            else if (ae < R && 0 > s(de, he)) $[Ae] = de, $[ae] = he, Ae = ae;
            else break e;
          }
        }
        return ne;
      }
      function s($, ne) {
        var he = $.sortIndex - ne.sortIndex;
        return he !== 0 ? he : $.id - ne.id;
      }
      if (n.unstable_now = void 0, typeof performance == "object" && typeof performance.now == "function") {
        var a = performance;
        n.unstable_now = function() {
          return a.now();
        };
      } else {
        var l = Date, u = l.now();
        n.unstable_now = function() {
          return l.now() - u;
        };
      }
      var h = [], d = [], p = 1, _ = null, y = 3, v = false, S = false, E = false, M = false, F = typeof setTimeout == "function" ? setTimeout : null, H = typeof clearTimeout == "function" ? clearTimeout : null, O = typeof setImmediate < "u" ? setImmediate : null;
      function U($) {
        for (var ne = t(d); ne !== null; ) {
          if (ne.callback === null) i(d);
          else if (ne.startTime <= $) i(d), ne.sortIndex = ne.expirationTime, e(h, ne);
          else break;
          ne = t(d);
        }
      }
      function B($) {
        if (E = false, U($), !S) if (t(h) !== null) S = true, Z || (Z = true, ye());
        else {
          var ne = t(d);
          ne !== null && Ue(B, ne.startTime - $);
        }
      }
      var Z = false, re = -1, le = 5, ee = -1;
      function fe() {
        return M ? true : !(n.unstable_now() - ee < le);
      }
      function te() {
        if (M = false, Z) {
          var $ = n.unstable_now();
          ee = $;
          var ne = true;
          try {
            e: {
              S = false, E && (E = false, H(re), re = -1), v = true;
              var he = y;
              try {
                t: {
                  for (U($), _ = t(h); _ !== null && !(_.expirationTime > $ && fe()); ) {
                    var Ae = _.callback;
                    if (typeof Ae == "function") {
                      _.callback = null, y = _.priorityLevel;
                      var R = Ae(_.expirationTime <= $);
                      if ($ = n.unstable_now(), typeof R == "function") {
                        _.callback = R, U($), ne = true;
                        break t;
                      }
                      _ === t(h) && i(h), U($);
                    } else i(h);
                    _ = t(h);
                  }
                  if (_ !== null) ne = true;
                  else {
                    var Q = t(d);
                    Q !== null && Ue(B, Q.startTime - $), ne = false;
                  }
                }
                break e;
              } finally {
                _ = null, y = he, v = false;
              }
              ne = void 0;
            }
          } finally {
            ne ? ye() : Z = false;
          }
        }
      }
      var ye;
      if (typeof O == "function") ye = function() {
        O(te);
      };
      else if (typeof MessageChannel < "u") {
        var xe = new MessageChannel(), ve = xe.port2;
        xe.port1.onmessage = te, ye = function() {
          ve.postMessage(null);
        };
      } else ye = function() {
        F(te, 0);
      };
      function Ue($, ne) {
        re = F(function() {
          $(n.unstable_now());
        }, ne);
      }
      n.unstable_IdlePriority = 5, n.unstable_ImmediatePriority = 1, n.unstable_LowPriority = 4, n.unstable_NormalPriority = 3, n.unstable_Profiling = null, n.unstable_UserBlockingPriority = 2, n.unstable_cancelCallback = function($) {
        $.callback = null;
      }, n.unstable_forceFrameRate = function($) {
        0 > $ || 125 < $ ? console.error("forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported") : le = 0 < $ ? Math.floor(1e3 / $) : 5;
      }, n.unstable_getCurrentPriorityLevel = function() {
        return y;
      }, n.unstable_next = function($) {
        switch (y) {
          case 1:
          case 2:
          case 3:
            var ne = 3;
            break;
          default:
            ne = y;
        }
        var he = y;
        y = ne;
        try {
          return $();
        } finally {
          y = he;
        }
      }, n.unstable_requestPaint = function() {
        M = true;
      }, n.unstable_runWithPriority = function($, ne) {
        switch ($) {
          case 1:
          case 2:
          case 3:
          case 4:
          case 5:
            break;
          default:
            $ = 3;
        }
        var he = y;
        y = $;
        try {
          return ne();
        } finally {
          y = he;
        }
      }, n.unstable_scheduleCallback = function($, ne, he) {
        var Ae = n.unstable_now();
        switch (typeof he == "object" && he !== null ? (he = he.delay, he = typeof he == "number" && 0 < he ? Ae + he : Ae) : he = Ae, $) {
          case 1:
            var R = -1;
            break;
          case 2:
            R = 250;
            break;
          case 5:
            R = 1073741823;
            break;
          case 4:
            R = 1e4;
            break;
          default:
            R = 5e3;
        }
        return R = he + R, $ = {
          id: p++,
          callback: ne,
          priorityLevel: $,
          startTime: he,
          expirationTime: R,
          sortIndex: -1
        }, he > Ae ? ($.sortIndex = he, e(d, $), t(h) === null && $ === t(d) && (E ? (H(re), re = -1) : E = true, Ue(B, he - Ae))) : ($.sortIndex = R, e(h, $), S || v || (S = true, Z || (Z = true, ye()))), $;
      }, n.unstable_shouldYield = fe, n.unstable_wrapCallback = function($) {
        var ne = y;
        return function() {
          var he = y;
          y = ne;
          try {
            return $.apply(this, arguments);
          } finally {
            y = he;
          }
        };
      };
    }(Sh)), Sh;
  }
  var Yy;
  function yS() {
    return Yy || (Yy = 1, xh.exports = _S()), xh.exports;
  }
  var Ah = {
    exports: {}
  }, Et = {};
  var qy;
  function bS() {
    if (qy) return Et;
    qy = 1;
    var n = Gd();
    function e(h) {
      var d = "https://react.dev/errors/" + h;
      if (1 < arguments.length) {
        d += "?args[]=" + encodeURIComponent(arguments[1]);
        for (var p = 2; p < arguments.length; p++) d += "&args[]=" + encodeURIComponent(arguments[p]);
      }
      return "Minified React error #" + h + "; visit " + d + " for the full message or use the non-minified dev environment for full errors and additional helpful warnings.";
    }
    function t() {
    }
    var i = {
      d: {
        f: t,
        r: function() {
          throw Error(e(522));
        },
        D: t,
        C: t,
        L: t,
        m: t,
        X: t,
        S: t,
        M: t
      },
      p: 0,
      findDOMNode: null
    }, s = Symbol.for("react.portal");
    function a(h, d, p) {
      var _ = 3 < arguments.length && arguments[3] !== void 0 ? arguments[3] : null;
      return {
        $$typeof: s,
        key: _ == null ? null : "" + _,
        children: h,
        containerInfo: d,
        implementation: p
      };
    }
    var l = n.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE;
    function u(h, d) {
      if (h === "font") return "";
      if (typeof d == "string") return d === "use-credentials" ? d : "";
    }
    return Et.__DOM_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE = i, Et.createPortal = function(h, d) {
      var p = 2 < arguments.length && arguments[2] !== void 0 ? arguments[2] : null;
      if (!d || d.nodeType !== 1 && d.nodeType !== 9 && d.nodeType !== 11) throw Error(e(299));
      return a(h, d, null, p);
    }, Et.flushSync = function(h) {
      var d = l.T, p = i.p;
      try {
        if (l.T = null, i.p = 2, h) return h();
      } finally {
        l.T = d, i.p = p, i.d.f();
      }
    }, Et.preconnect = function(h, d) {
      typeof h == "string" && (d ? (d = d.crossOrigin, d = typeof d == "string" ? d === "use-credentials" ? d : "" : void 0) : d = null, i.d.C(h, d));
    }, Et.prefetchDNS = function(h) {
      typeof h == "string" && i.d.D(h);
    }, Et.preinit = function(h, d) {
      if (typeof h == "string" && d && typeof d.as == "string") {
        var p = d.as, _ = u(p, d.crossOrigin), y = typeof d.integrity == "string" ? d.integrity : void 0, v = typeof d.fetchPriority == "string" ? d.fetchPriority : void 0;
        p === "style" ? i.d.S(h, typeof d.precedence == "string" ? d.precedence : void 0, {
          crossOrigin: _,
          integrity: y,
          fetchPriority: v
        }) : p === "script" && i.d.X(h, {
          crossOrigin: _,
          integrity: y,
          fetchPriority: v,
          nonce: typeof d.nonce == "string" ? d.nonce : void 0
        });
      }
    }, Et.preinitModule = function(h, d) {
      if (typeof h == "string") if (typeof d == "object" && d !== null) {
        if (d.as == null || d.as === "script") {
          var p = u(d.as, d.crossOrigin);
          i.d.M(h, {
            crossOrigin: p,
            integrity: typeof d.integrity == "string" ? d.integrity : void 0,
            nonce: typeof d.nonce == "string" ? d.nonce : void 0
          });
        }
      } else d == null && i.d.M(h);
    }, Et.preload = function(h, d) {
      if (typeof h == "string" && typeof d == "object" && d !== null && typeof d.as == "string") {
        var p = d.as, _ = u(p, d.crossOrigin);
        i.d.L(h, p, {
          crossOrigin: _,
          integrity: typeof d.integrity == "string" ? d.integrity : void 0,
          nonce: typeof d.nonce == "string" ? d.nonce : void 0,
          type: typeof d.type == "string" ? d.type : void 0,
          fetchPriority: typeof d.fetchPriority == "string" ? d.fetchPriority : void 0,
          referrerPolicy: typeof d.referrerPolicy == "string" ? d.referrerPolicy : void 0,
          imageSrcSet: typeof d.imageSrcSet == "string" ? d.imageSrcSet : void 0,
          imageSizes: typeof d.imageSizes == "string" ? d.imageSizes : void 0,
          media: typeof d.media == "string" ? d.media : void 0
        });
      }
    }, Et.preloadModule = function(h, d) {
      if (typeof h == "string") if (d) {
        var p = u(d.as, d.crossOrigin);
        i.d.m(h, {
          as: typeof d.as == "string" && d.as !== "script" ? d.as : void 0,
          crossOrigin: p,
          integrity: typeof d.integrity == "string" ? d.integrity : void 0
        });
      } else i.d.m(h);
    }, Et.requestFormReset = function(h) {
      i.d.r(h);
    }, Et.unstable_batchedUpdates = function(h, d) {
      return h(d);
    }, Et.useFormState = function(h, d, p) {
      return l.H.useFormState(h, d, p);
    }, Et.useFormStatus = function() {
      return l.H.useHostTransitionStatus();
    }, Et.version = "19.1.0", Et;
  }
  var Ky;
  function jv() {
    if (Ky) return Ah.exports;
    Ky = 1;
    function n() {
      if (!(typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ > "u" || typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE != "function")) try {
        __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(n);
      } catch (e) {
        console.error(e);
      }
    }
    return n(), Ah.exports = bS(), Ah.exports;
  }
  var Zy;
  function vS() {
    if (Zy) return Za;
    Zy = 1;
    var n = yS(), e = Gd(), t = jv();
    function i(r) {
      var o = "https://react.dev/errors/" + r;
      if (1 < arguments.length) {
        o += "?args[]=" + encodeURIComponent(arguments[1]);
        for (var c = 2; c < arguments.length; c++) o += "&args[]=" + encodeURIComponent(arguments[c]);
      }
      return "Minified React error #" + r + "; visit " + o + " for the full message or use the non-minified dev environment for full errors and additional helpful warnings.";
    }
    function s(r) {
      return !(!r || r.nodeType !== 1 && r.nodeType !== 9 && r.nodeType !== 11);
    }
    function a(r) {
      var o = r, c = r;
      if (r.alternate) for (; o.return; ) o = o.return;
      else {
        r = o;
        do
          o = r, (o.flags & 4098) !== 0 && (c = o.return), r = o.return;
        while (r);
      }
      return o.tag === 3 ? c : null;
    }
    function l(r) {
      if (r.tag === 13) {
        var o = r.memoizedState;
        if (o === null && (r = r.alternate, r !== null && (o = r.memoizedState)), o !== null) return o.dehydrated;
      }
      return null;
    }
    function u(r) {
      if (a(r) !== r) throw Error(i(188));
    }
    function h(r) {
      var o = r.alternate;
      if (!o) {
        if (o = a(r), o === null) throw Error(i(188));
        return o !== r ? null : r;
      }
      for (var c = r, f = o; ; ) {
        var g = c.return;
        if (g === null) break;
        var m = g.alternate;
        if (m === null) {
          if (f = g.return, f !== null) {
            c = f;
            continue;
          }
          break;
        }
        if (g.child === m.child) {
          for (m = g.child; m; ) {
            if (m === c) return u(g), r;
            if (m === f) return u(g), o;
            m = m.sibling;
          }
          throw Error(i(188));
        }
        if (c.return !== f.return) c = g, f = m;
        else {
          for (var b = false, T = g.child; T; ) {
            if (T === c) {
              b = true, c = g, f = m;
              break;
            }
            if (T === f) {
              b = true, f = g, c = m;
              break;
            }
            T = T.sibling;
          }
          if (!b) {
            for (T = m.child; T; ) {
              if (T === c) {
                b = true, c = m, f = g;
                break;
              }
              if (T === f) {
                b = true, f = m, c = g;
                break;
              }
              T = T.sibling;
            }
            if (!b) throw Error(i(189));
          }
        }
        if (c.alternate !== f) throw Error(i(190));
      }
      if (c.tag !== 3) throw Error(i(188));
      return c.stateNode.current === c ? r : o;
    }
    function d(r) {
      var o = r.tag;
      if (o === 5 || o === 26 || o === 27 || o === 6) return r;
      for (r = r.child; r !== null; ) {
        if (o = d(r), o !== null) return o;
        r = r.sibling;
      }
      return null;
    }
    var p = Object.assign, _ = Symbol.for("react.element"), y = Symbol.for("react.transitional.element"), v = Symbol.for("react.portal"), S = Symbol.for("react.fragment"), E = Symbol.for("react.strict_mode"), M = Symbol.for("react.profiler"), F = Symbol.for("react.provider"), H = Symbol.for("react.consumer"), O = Symbol.for("react.context"), U = Symbol.for("react.forward_ref"), B = Symbol.for("react.suspense"), Z = Symbol.for("react.suspense_list"), re = Symbol.for("react.memo"), le = Symbol.for("react.lazy"), ee = Symbol.for("react.activity"), fe = Symbol.for("react.memo_cache_sentinel"), te = Symbol.iterator;
    function ye(r) {
      return r === null || typeof r != "object" ? null : (r = te && r[te] || r["@@iterator"], typeof r == "function" ? r : null);
    }
    var xe = Symbol.for("react.client.reference");
    function ve(r) {
      if (r == null) return null;
      if (typeof r == "function") return r.$$typeof === xe ? null : r.displayName || r.name || null;
      if (typeof r == "string") return r;
      switch (r) {
        case S:
          return "Fragment";
        case M:
          return "Profiler";
        case E:
          return "StrictMode";
        case B:
          return "Suspense";
        case Z:
          return "SuspenseList";
        case ee:
          return "Activity";
      }
      if (typeof r == "object") switch (r.$$typeof) {
        case v:
          return "Portal";
        case O:
          return (r.displayName || "Context") + ".Provider";
        case H:
          return (r._context.displayName || "Context") + ".Consumer";
        case U:
          var o = r.render;
          return r = r.displayName, r || (r = o.displayName || o.name || "", r = r !== "" ? "ForwardRef(" + r + ")" : "ForwardRef"), r;
        case re:
          return o = r.displayName || null, o !== null ? o : ve(r.type) || "Memo";
        case le:
          o = r._payload, r = r._init;
          try {
            return ve(r(o));
          } catch {
          }
      }
      return null;
    }
    var Ue = Array.isArray, $ = e.__CLIENT_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE, ne = t.__DOM_INTERNALS_DO_NOT_USE_OR_WARN_USERS_THEY_CANNOT_UPGRADE, he = {
      pending: false,
      data: null,
      method: null,
      action: null
    }, Ae = [], R = -1;
    function Q(r) {
      return {
        current: r
      };
    }
    function oe(r) {
      0 > R || (r.current = Ae[R], Ae[R] = null, R--);
    }
    function se(r, o) {
      R++, Ae[R] = r.current, r.current = o;
    }
    var ae = Q(null), de = Q(null), ue = Q(null), Ge = Q(null);
    function Pe(r, o) {
      switch (se(ue, o), se(de, r), se(ae, null), o.nodeType) {
        case 9:
        case 11:
          r = (r = o.documentElement) && (r = r.namespaceURI) ? my(r) : 0;
          break;
        default:
          if (r = o.tagName, o = o.namespaceURI) o = my(o), r = _y(o, r);
          else switch (r) {
            case "svg":
              r = 1;
              break;
            case "math":
              r = 2;
              break;
            default:
              r = 0;
          }
      }
      oe(ae), se(ae, r);
    }
    function pt() {
      oe(ae), oe(de), oe(ue);
    }
    function ui(r) {
      r.memoizedState !== null && se(Ge, r);
      var o = ae.current, c = _y(o, r.type);
      o !== c && (se(de, r), se(ae, c));
    }
    function zt(r) {
      de.current === r && (oe(ae), oe(de)), Ge.current === r && (oe(Ge), Wa._currentValue = he);
    }
    var Ki = Object.prototype.hasOwnProperty, Zi = n.unstable_scheduleCallback, au = n.unstable_cancelCallback, XT = n.unstable_shouldYield, YT = n.unstable_requestPaint, wn = n.unstable_now, qT = n.unstable_getCurrentPriorityLevel, Zg = n.unstable_ImmediatePriority, Qg = n.unstable_UserBlockingPriority, Io = n.unstable_NormalPriority, KT = n.unstable_LowPriority, Gg = n.unstable_IdlePriority, ZT = n.log, QT = n.unstable_setDisableYieldValue, Gr = null, Ht = null;
    function fi(r) {
      if (typeof ZT == "function" && QT(r), Ht && typeof Ht.setStrictMode == "function") try {
        Ht.setStrictMode(Gr, r);
      } catch {
      }
    }
    var jt = Math.clz32 ? Math.clz32 : e1, GT = Math.log, JT = Math.LN2;
    function e1(r) {
      return r >>>= 0, r === 0 ? 32 : 31 - (GT(r) / JT | 0) | 0;
    }
    var No = 256, Po = 4194304;
    function Qi(r) {
      var o = r & 42;
      if (o !== 0) return o;
      switch (r & -r) {
        case 1:
          return 1;
        case 2:
          return 2;
        case 4:
          return 4;
        case 8:
          return 8;
        case 16:
          return 16;
        case 32:
          return 32;
        case 64:
          return 64;
        case 128:
          return 128;
        case 256:
        case 512:
        case 1024:
        case 2048:
        case 4096:
        case 8192:
        case 16384:
        case 32768:
        case 65536:
        case 131072:
        case 262144:
        case 524288:
        case 1048576:
        case 2097152:
          return r & 4194048;
        case 4194304:
        case 8388608:
        case 16777216:
        case 33554432:
          return r & 62914560;
        case 67108864:
          return 67108864;
        case 134217728:
          return 134217728;
        case 268435456:
          return 268435456;
        case 536870912:
          return 536870912;
        case 1073741824:
          return 0;
        default:
          return r;
      }
    }
    function Do(r, o, c) {
      var f = r.pendingLanes;
      if (f === 0) return 0;
      var g = 0, m = r.suspendedLanes, b = r.pingedLanes;
      r = r.warmLanes;
      var T = f & 134217727;
      return T !== 0 ? (f = T & ~m, f !== 0 ? g = Qi(f) : (b &= T, b !== 0 ? g = Qi(b) : c || (c = T & ~r, c !== 0 && (g = Qi(c))))) : (T = f & ~m, T !== 0 ? g = Qi(T) : b !== 0 ? g = Qi(b) : c || (c = f & ~r, c !== 0 && (g = Qi(c)))), g === 0 ? 0 : o !== 0 && o !== g && (o & m) === 0 && (m = g & -g, c = o & -o, m >= c || m === 32 && (c & 4194048) !== 0) ? o : g;
    }
    function Jr(r, o) {
      return (r.pendingLanes & ~(r.suspendedLanes & ~r.pingedLanes) & o) === 0;
    }
    function t1(r, o) {
      switch (r) {
        case 1:
        case 2:
        case 4:
        case 8:
        case 64:
          return o + 250;
        case 16:
        case 32:
        case 128:
        case 256:
        case 512:
        case 1024:
        case 2048:
        case 4096:
        case 8192:
        case 16384:
        case 32768:
        case 65536:
        case 131072:
        case 262144:
        case 524288:
        case 1048576:
        case 2097152:
          return o + 5e3;
        case 4194304:
        case 8388608:
        case 16777216:
        case 33554432:
          return -1;
        case 67108864:
        case 134217728:
        case 268435456:
        case 536870912:
        case 1073741824:
          return -1;
        default:
          return -1;
      }
    }
    function Jg() {
      var r = No;
      return No <<= 1, (No & 4194048) === 0 && (No = 256), r;
    }
    function ep() {
      var r = Po;
      return Po <<= 1, (Po & 62914560) === 0 && (Po = 4194304), r;
    }
    function ou(r) {
      for (var o = [], c = 0; 31 > c; c++) o.push(r);
      return o;
    }
    function ea(r, o) {
      r.pendingLanes |= o, o !== 268435456 && (r.suspendedLanes = 0, r.pingedLanes = 0, r.warmLanes = 0);
    }
    function n1(r, o, c, f, g, m) {
      var b = r.pendingLanes;
      r.pendingLanes = c, r.suspendedLanes = 0, r.pingedLanes = 0, r.warmLanes = 0, r.expiredLanes &= c, r.entangledLanes &= c, r.errorRecoveryDisabledLanes &= c, r.shellSuspendCounter = 0;
      var T = r.entanglements, w = r.expirationTimes, z = r.hiddenUpdates;
      for (c = b & ~c; 0 < c; ) {
        var X = 31 - jt(c), K = 1 << X;
        T[X] = 0, w[X] = -1;
        var j = z[X];
        if (j !== null) for (z[X] = null, X = 0; X < j.length; X++) {
          var W = j[X];
          W !== null && (W.lane &= -536870913);
        }
        c &= ~K;
      }
      f !== 0 && tp(r, f, 0), m !== 0 && g === 0 && r.tag !== 0 && (r.suspendedLanes |= m & ~(b & ~o));
    }
    function tp(r, o, c) {
      r.pendingLanes |= o, r.suspendedLanes &= ~o;
      var f = 31 - jt(o);
      r.entangledLanes |= o, r.entanglements[f] = r.entanglements[f] | 1073741824 | c & 4194090;
    }
    function np(r, o) {
      var c = r.entangledLanes |= o;
      for (r = r.entanglements; c; ) {
        var f = 31 - jt(c), g = 1 << f;
        g & o | r[f] & o && (r[f] |= o), c &= ~g;
      }
    }
    function lu(r) {
      switch (r) {
        case 2:
          r = 1;
          break;
        case 8:
          r = 4;
          break;
        case 32:
          r = 16;
          break;
        case 256:
        case 512:
        case 1024:
        case 2048:
        case 4096:
        case 8192:
        case 16384:
        case 32768:
        case 65536:
        case 131072:
        case 262144:
        case 524288:
        case 1048576:
        case 2097152:
        case 4194304:
        case 8388608:
        case 16777216:
        case 33554432:
          r = 128;
          break;
        case 268435456:
          r = 134217728;
          break;
        default:
          r = 0;
      }
      return r;
    }
    function cu(r) {
      return r &= -r, 2 < r ? 8 < r ? (r & 134217727) !== 0 ? 32 : 268435456 : 8 : 2;
    }
    function ip() {
      var r = ne.p;
      return r !== 0 ? r : (r = window.event, r === void 0 ? 32 : Uy(r.type));
    }
    function i1(r, o) {
      var c = ne.p;
      try {
        return ne.p = r, o();
      } finally {
        ne.p = c;
      }
    }
    var hi = Math.random().toString(36).slice(2), At = "__reactFiber$" + hi, Dt = "__reactProps$" + hi, ks = "__reactContainer$" + hi, uu = "__reactEvents$" + hi, s1 = "__reactListeners$" + hi, r1 = "__reactHandles$" + hi, sp = "__reactResources$" + hi, ta = "__reactMarker$" + hi;
    function fu(r) {
      delete r[At], delete r[Dt], delete r[uu], delete r[s1], delete r[r1];
    }
    function Us(r) {
      var o = r[At];
      if (o) return o;
      for (var c = r.parentNode; c; ) {
        if (o = c[ks] || c[At]) {
          if (c = o.alternate, o.child !== null || c !== null && c.child !== null) for (r = Ty(r); r !== null; ) {
            if (c = r[At]) return c;
            r = Ty(r);
          }
          return o;
        }
        r = c, c = r.parentNode;
      }
      return null;
    }
    function Bs(r) {
      if (r = r[At] || r[ks]) {
        var o = r.tag;
        if (o === 5 || o === 6 || o === 13 || o === 26 || o === 27 || o === 3) return r;
      }
      return null;
    }
    function na(r) {
      var o = r.tag;
      if (o === 5 || o === 26 || o === 27 || o === 6) return r.stateNode;
      throw Error(i(33));
    }
    function Ls(r) {
      var o = r[sp];
      return o || (o = r[sp] = {
        hoistableStyles: /* @__PURE__ */ new Map(),
        hoistableScripts: /* @__PURE__ */ new Map()
      }), o;
    }
    function mt(r) {
      r[ta] = true;
    }
    var rp = /* @__PURE__ */ new Set(), ap = {};
    function Gi(r, o) {
      Fs(r, o), Fs(r + "Capture", o);
    }
    function Fs(r, o) {
      for (ap[r] = o, r = 0; r < o.length; r++) rp.add(o[r]);
    }
    var a1 = RegExp("^[:A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD][:A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD\\-.0-9\\u00B7\\u0300-\\u036F\\u203F-\\u2040]*$"), op = {}, lp = {};
    function o1(r) {
      return Ki.call(lp, r) ? true : Ki.call(op, r) ? false : a1.test(r) ? lp[r] = true : (op[r] = true, false);
    }
    function ko(r, o, c) {
      if (o1(o)) if (c === null) r.removeAttribute(o);
      else {
        switch (typeof c) {
          case "undefined":
          case "function":
          case "symbol":
            r.removeAttribute(o);
            return;
          case "boolean":
            var f = o.toLowerCase().slice(0, 5);
            if (f !== "data-" && f !== "aria-") {
              r.removeAttribute(o);
              return;
            }
        }
        r.setAttribute(o, "" + c);
      }
    }
    function Uo(r, o, c) {
      if (c === null) r.removeAttribute(o);
      else {
        switch (typeof c) {
          case "undefined":
          case "function":
          case "symbol":
          case "boolean":
            r.removeAttribute(o);
            return;
        }
        r.setAttribute(o, "" + c);
      }
    }
    function Hn(r, o, c, f) {
      if (f === null) r.removeAttribute(c);
      else {
        switch (typeof f) {
          case "undefined":
          case "function":
          case "symbol":
          case "boolean":
            r.removeAttribute(c);
            return;
        }
        r.setAttributeNS(o, c, "" + f);
      }
    }
    var hu, cp;
    function Vs(r) {
      if (hu === void 0) try {
        throw Error();
      } catch (c) {
        var o = c.stack.trim().match(/\n( *(at )?)/);
        hu = o && o[1] || "", cp = -1 < c.stack.indexOf(`
    at`) ? " (<anonymous>)" : -1 < c.stack.indexOf("@") ? "@unknown:0:0" : "";
      }
      return `
` + hu + r + cp;
    }
    var du = false;
    function gu(r, o) {
      if (!r || du) return "";
      du = true;
      var c = Error.prepareStackTrace;
      Error.prepareStackTrace = void 0;
      try {
        var f = {
          DetermineComponentFrameRoot: function() {
            try {
              if (o) {
                var K = function() {
                  throw Error();
                };
                if (Object.defineProperty(K.prototype, "props", {
                  set: function() {
                    throw Error();
                  }
                }), typeof Reflect == "object" && Reflect.construct) {
                  try {
                    Reflect.construct(K, []);
                  } catch (W) {
                    var j = W;
                  }
                  Reflect.construct(r, [], K);
                } else {
                  try {
                    K.call();
                  } catch (W) {
                    j = W;
                  }
                  r.call(K.prototype);
                }
              } else {
                try {
                  throw Error();
                } catch (W) {
                  j = W;
                }
                (K = r()) && typeof K.catch == "function" && K.catch(function() {
                });
              }
            } catch (W) {
              if (W && j && typeof W.stack == "string") return [
                W.stack,
                j.stack
              ];
            }
            return [
              null,
              null
            ];
          }
        };
        f.DetermineComponentFrameRoot.displayName = "DetermineComponentFrameRoot";
        var g = Object.getOwnPropertyDescriptor(f.DetermineComponentFrameRoot, "name");
        g && g.configurable && Object.defineProperty(f.DetermineComponentFrameRoot, "name", {
          value: "DetermineComponentFrameRoot"
        });
        var m = f.DetermineComponentFrameRoot(), b = m[0], T = m[1];
        if (b && T) {
          var w = b.split(`
`), z = T.split(`
`);
          for (g = f = 0; f < w.length && !w[f].includes("DetermineComponentFrameRoot"); ) f++;
          for (; g < z.length && !z[g].includes("DetermineComponentFrameRoot"); ) g++;
          if (f === w.length || g === z.length) for (f = w.length - 1, g = z.length - 1; 1 <= f && 0 <= g && w[f] !== z[g]; ) g--;
          for (; 1 <= f && 0 <= g; f--, g--) if (w[f] !== z[g]) {
            if (f !== 1 || g !== 1) do
              if (f--, g--, 0 > g || w[f] !== z[g]) {
                var X = `
` + w[f].replace(" at new ", " at ");
                return r.displayName && X.includes("<anonymous>") && (X = X.replace("<anonymous>", r.displayName)), X;
              }
            while (1 <= f && 0 <= g);
            break;
          }
        }
      } finally {
        du = false, Error.prepareStackTrace = c;
      }
      return (c = r ? r.displayName || r.name : "") ? Vs(c) : "";
    }
    function l1(r) {
      switch (r.tag) {
        case 26:
        case 27:
        case 5:
          return Vs(r.type);
        case 16:
          return Vs("Lazy");
        case 13:
          return Vs("Suspense");
        case 19:
          return Vs("SuspenseList");
        case 0:
        case 15:
          return gu(r.type, false);
        case 11:
          return gu(r.type.render, false);
        case 1:
          return gu(r.type, true);
        case 31:
          return Vs("Activity");
        default:
          return "";
      }
    }
    function up(r) {
      try {
        var o = "";
        do
          o += l1(r), r = r.return;
        while (r);
        return o;
      } catch (c) {
        return `
Error generating stack: ` + c.message + `
` + c.stack;
      }
    }
    function tn(r) {
      switch (typeof r) {
        case "bigint":
        case "boolean":
        case "number":
        case "string":
        case "undefined":
          return r;
        case "object":
          return r;
        default:
          return "";
      }
    }
    function fp(r) {
      var o = r.type;
      return (r = r.nodeName) && r.toLowerCase() === "input" && (o === "checkbox" || o === "radio");
    }
    function c1(r) {
      var o = fp(r) ? "checked" : "value", c = Object.getOwnPropertyDescriptor(r.constructor.prototype, o), f = "" + r[o];
      if (!r.hasOwnProperty(o) && typeof c < "u" && typeof c.get == "function" && typeof c.set == "function") {
        var g = c.get, m = c.set;
        return Object.defineProperty(r, o, {
          configurable: true,
          get: function() {
            return g.call(this);
          },
          set: function(b) {
            f = "" + b, m.call(this, b);
          }
        }), Object.defineProperty(r, o, {
          enumerable: c.enumerable
        }), {
          getValue: function() {
            return f;
          },
          setValue: function(b) {
            f = "" + b;
          },
          stopTracking: function() {
            r._valueTracker = null, delete r[o];
          }
        };
      }
    }
    function Bo(r) {
      r._valueTracker || (r._valueTracker = c1(r));
    }
    function hp(r) {
      if (!r) return false;
      var o = r._valueTracker;
      if (!o) return true;
      var c = o.getValue(), f = "";
      return r && (f = fp(r) ? r.checked ? "true" : "false" : r.value), r = f, r !== c ? (o.setValue(r), true) : false;
    }
    function Lo(r) {
      if (r = r || (typeof document < "u" ? document : void 0), typeof r > "u") return null;
      try {
        return r.activeElement || r.body;
      } catch {
        return r.body;
      }
    }
    var u1 = /[\n"\\]/g;
    function nn(r) {
      return r.replace(u1, function(o) {
        return "\\" + o.charCodeAt(0).toString(16) + " ";
      });
    }
    function pu(r, o, c, f, g, m, b, T) {
      r.name = "", b != null && typeof b != "function" && typeof b != "symbol" && typeof b != "boolean" ? r.type = b : r.removeAttribute("type"), o != null ? b === "number" ? (o === 0 && r.value === "" || r.value != o) && (r.value = "" + tn(o)) : r.value !== "" + tn(o) && (r.value = "" + tn(o)) : b !== "submit" && b !== "reset" || r.removeAttribute("value"), o != null ? mu(r, b, tn(o)) : c != null ? mu(r, b, tn(c)) : f != null && r.removeAttribute("value"), g == null && m != null && (r.defaultChecked = !!m), g != null && (r.checked = g && typeof g != "function" && typeof g != "symbol"), T != null && typeof T != "function" && typeof T != "symbol" && typeof T != "boolean" ? r.name = "" + tn(T) : r.removeAttribute("name");
    }
    function dp(r, o, c, f, g, m, b, T) {
      if (m != null && typeof m != "function" && typeof m != "symbol" && typeof m != "boolean" && (r.type = m), o != null || c != null) {
        if (!(m !== "submit" && m !== "reset" || o != null)) return;
        c = c != null ? "" + tn(c) : "", o = o != null ? "" + tn(o) : c, T || o === r.value || (r.value = o), r.defaultValue = o;
      }
      f = f ?? g, f = typeof f != "function" && typeof f != "symbol" && !!f, r.checked = T ? r.checked : !!f, r.defaultChecked = !!f, b != null && typeof b != "function" && typeof b != "symbol" && typeof b != "boolean" && (r.name = b);
    }
    function mu(r, o, c) {
      o === "number" && Lo(r.ownerDocument) === r || r.defaultValue === "" + c || (r.defaultValue = "" + c);
    }
    function zs(r, o, c, f) {
      if (r = r.options, o) {
        o = {};
        for (var g = 0; g < c.length; g++) o["$" + c[g]] = true;
        for (c = 0; c < r.length; c++) g = o.hasOwnProperty("$" + r[c].value), r[c].selected !== g && (r[c].selected = g), g && f && (r[c].defaultSelected = true);
      } else {
        for (c = "" + tn(c), o = null, g = 0; g < r.length; g++) {
          if (r[g].value === c) {
            r[g].selected = true, f && (r[g].defaultSelected = true);
            return;
          }
          o !== null || r[g].disabled || (o = r[g]);
        }
        o !== null && (o.selected = true);
      }
    }
    function gp(r, o, c) {
      if (o != null && (o = "" + tn(o), o !== r.value && (r.value = o), c == null)) {
        r.defaultValue !== o && (r.defaultValue = o);
        return;
      }
      r.defaultValue = c != null ? "" + tn(c) : "";
    }
    function pp(r, o, c, f) {
      if (o == null) {
        if (f != null) {
          if (c != null) throw Error(i(92));
          if (Ue(f)) {
            if (1 < f.length) throw Error(i(93));
            f = f[0];
          }
          c = f;
        }
        c == null && (c = ""), o = c;
      }
      c = tn(o), r.defaultValue = c, f = r.textContent, f === c && f !== "" && f !== null && (r.value = f);
    }
    function Hs(r, o) {
      if (o) {
        var c = r.firstChild;
        if (c && c === r.lastChild && c.nodeType === 3) {
          c.nodeValue = o;
          return;
        }
      }
      r.textContent = o;
    }
    var f1 = new Set("animationIterationCount aspectRatio borderImageOutset borderImageSlice borderImageWidth boxFlex boxFlexGroup boxOrdinalGroup columnCount columns flex flexGrow flexPositive flexShrink flexNegative flexOrder gridArea gridRow gridRowEnd gridRowSpan gridRowStart gridColumn gridColumnEnd gridColumnSpan gridColumnStart fontWeight lineClamp lineHeight opacity order orphans scale tabSize widows zIndex zoom fillOpacity floodOpacity stopOpacity strokeDasharray strokeDashoffset strokeMiterlimit strokeOpacity strokeWidth MozAnimationIterationCount MozBoxFlex MozBoxFlexGroup MozLineClamp msAnimationIterationCount msFlex msZoom msFlexGrow msFlexNegative msFlexOrder msFlexPositive msFlexShrink msGridColumn msGridColumnSpan msGridRow msGridRowSpan WebkitAnimationIterationCount WebkitBoxFlex WebKitBoxFlexGroup WebkitBoxOrdinalGroup WebkitColumnCount WebkitColumns WebkitFlex WebkitFlexGrow WebkitFlexPositive WebkitFlexShrink WebkitLineClamp".split(" "));
    function mp(r, o, c) {
      var f = o.indexOf("--") === 0;
      c == null || typeof c == "boolean" || c === "" ? f ? r.setProperty(o, "") : o === "float" ? r.cssFloat = "" : r[o] = "" : f ? r.setProperty(o, c) : typeof c != "number" || c === 0 || f1.has(o) ? o === "float" ? r.cssFloat = c : r[o] = ("" + c).trim() : r[o] = c + "px";
    }
    function _p(r, o, c) {
      if (o != null && typeof o != "object") throw Error(i(62));
      if (r = r.style, c != null) {
        for (var f in c) !c.hasOwnProperty(f) || o != null && o.hasOwnProperty(f) || (f.indexOf("--") === 0 ? r.setProperty(f, "") : f === "float" ? r.cssFloat = "" : r[f] = "");
        for (var g in o) f = o[g], o.hasOwnProperty(g) && c[g] !== f && mp(r, g, f);
      } else for (var m in o) o.hasOwnProperty(m) && mp(r, m, o[m]);
    }
    function _u(r) {
      if (r.indexOf("-") === -1) return false;
      switch (r) {
        case "annotation-xml":
        case "color-profile":
        case "font-face":
        case "font-face-src":
        case "font-face-uri":
        case "font-face-format":
        case "font-face-name":
        case "missing-glyph":
          return false;
        default:
          return true;
      }
    }
    var h1 = /* @__PURE__ */ new Map([
      [
        "acceptCharset",
        "accept-charset"
      ],
      [
        "htmlFor",
        "for"
      ],
      [
        "httpEquiv",
        "http-equiv"
      ],
      [
        "crossOrigin",
        "crossorigin"
      ],
      [
        "accentHeight",
        "accent-height"
      ],
      [
        "alignmentBaseline",
        "alignment-baseline"
      ],
      [
        "arabicForm",
        "arabic-form"
      ],
      [
        "baselineShift",
        "baseline-shift"
      ],
      [
        "capHeight",
        "cap-height"
      ],
      [
        "clipPath",
        "clip-path"
      ],
      [
        "clipRule",
        "clip-rule"
      ],
      [
        "colorInterpolation",
        "color-interpolation"
      ],
      [
        "colorInterpolationFilters",
        "color-interpolation-filters"
      ],
      [
        "colorProfile",
        "color-profile"
      ],
      [
        "colorRendering",
        "color-rendering"
      ],
      [
        "dominantBaseline",
        "dominant-baseline"
      ],
      [
        "enableBackground",
        "enable-background"
      ],
      [
        "fillOpacity",
        "fill-opacity"
      ],
      [
        "fillRule",
        "fill-rule"
      ],
      [
        "floodColor",
        "flood-color"
      ],
      [
        "floodOpacity",
        "flood-opacity"
      ],
      [
        "fontFamily",
        "font-family"
      ],
      [
        "fontSize",
        "font-size"
      ],
      [
        "fontSizeAdjust",
        "font-size-adjust"
      ],
      [
        "fontStretch",
        "font-stretch"
      ],
      [
        "fontStyle",
        "font-style"
      ],
      [
        "fontVariant",
        "font-variant"
      ],
      [
        "fontWeight",
        "font-weight"
      ],
      [
        "glyphName",
        "glyph-name"
      ],
      [
        "glyphOrientationHorizontal",
        "glyph-orientation-horizontal"
      ],
      [
        "glyphOrientationVertical",
        "glyph-orientation-vertical"
      ],
      [
        "horizAdvX",
        "horiz-adv-x"
      ],
      [
        "horizOriginX",
        "horiz-origin-x"
      ],
      [
        "imageRendering",
        "image-rendering"
      ],
      [
        "letterSpacing",
        "letter-spacing"
      ],
      [
        "lightingColor",
        "lighting-color"
      ],
      [
        "markerEnd",
        "marker-end"
      ],
      [
        "markerMid",
        "marker-mid"
      ],
      [
        "markerStart",
        "marker-start"
      ],
      [
        "overlinePosition",
        "overline-position"
      ],
      [
        "overlineThickness",
        "overline-thickness"
      ],
      [
        "paintOrder",
        "paint-order"
      ],
      [
        "panose-1",
        "panose-1"
      ],
      [
        "pointerEvents",
        "pointer-events"
      ],
      [
        "renderingIntent",
        "rendering-intent"
      ],
      [
        "shapeRendering",
        "shape-rendering"
      ],
      [
        "stopColor",
        "stop-color"
      ],
      [
        "stopOpacity",
        "stop-opacity"
      ],
      [
        "strikethroughPosition",
        "strikethrough-position"
      ],
      [
        "strikethroughThickness",
        "strikethrough-thickness"
      ],
      [
        "strokeDasharray",
        "stroke-dasharray"
      ],
      [
        "strokeDashoffset",
        "stroke-dashoffset"
      ],
      [
        "strokeLinecap",
        "stroke-linecap"
      ],
      [
        "strokeLinejoin",
        "stroke-linejoin"
      ],
      [
        "strokeMiterlimit",
        "stroke-miterlimit"
      ],
      [
        "strokeOpacity",
        "stroke-opacity"
      ],
      [
        "strokeWidth",
        "stroke-width"
      ],
      [
        "textAnchor",
        "text-anchor"
      ],
      [
        "textDecoration",
        "text-decoration"
      ],
      [
        "textRendering",
        "text-rendering"
      ],
      [
        "transformOrigin",
        "transform-origin"
      ],
      [
        "underlinePosition",
        "underline-position"
      ],
      [
        "underlineThickness",
        "underline-thickness"
      ],
      [
        "unicodeBidi",
        "unicode-bidi"
      ],
      [
        "unicodeRange",
        "unicode-range"
      ],
      [
        "unitsPerEm",
        "units-per-em"
      ],
      [
        "vAlphabetic",
        "v-alphabetic"
      ],
      [
        "vHanging",
        "v-hanging"
      ],
      [
        "vIdeographic",
        "v-ideographic"
      ],
      [
        "vMathematical",
        "v-mathematical"
      ],
      [
        "vectorEffect",
        "vector-effect"
      ],
      [
        "vertAdvY",
        "vert-adv-y"
      ],
      [
        "vertOriginX",
        "vert-origin-x"
      ],
      [
        "vertOriginY",
        "vert-origin-y"
      ],
      [
        "wordSpacing",
        "word-spacing"
      ],
      [
        "writingMode",
        "writing-mode"
      ],
      [
        "xmlnsXlink",
        "xmlns:xlink"
      ],
      [
        "xHeight",
        "x-height"
      ]
    ]), d1 = /^[\u0000-\u001F ]*j[\r\n\t]*a[\r\n\t]*v[\r\n\t]*a[\r\n\t]*s[\r\n\t]*c[\r\n\t]*r[\r\n\t]*i[\r\n\t]*p[\r\n\t]*t[\r\n\t]*:/i;
    function Fo(r) {
      return d1.test("" + r) ? "javascript:throw new Error('React has blocked a javascript: URL as a security precaution.')" : r;
    }
    var yu = null;
    function bu(r) {
      return r = r.target || r.srcElement || window, r.correspondingUseElement && (r = r.correspondingUseElement), r.nodeType === 3 ? r.parentNode : r;
    }
    var js = null, Ws = null;
    function yp(r) {
      var o = Bs(r);
      if (o && (r = o.stateNode)) {
        var c = r[Dt] || null;
        e: switch (r = o.stateNode, o.type) {
          case "input":
            if (pu(r, c.value, c.defaultValue, c.defaultValue, c.checked, c.defaultChecked, c.type, c.name), o = c.name, c.type === "radio" && o != null) {
              for (c = r; c.parentNode; ) c = c.parentNode;
              for (c = c.querySelectorAll('input[name="' + nn("" + o) + '"][type="radio"]'), o = 0; o < c.length; o++) {
                var f = c[o];
                if (f !== r && f.form === r.form) {
                  var g = f[Dt] || null;
                  if (!g) throw Error(i(90));
                  pu(f, g.value, g.defaultValue, g.defaultValue, g.checked, g.defaultChecked, g.type, g.name);
                }
              }
              for (o = 0; o < c.length; o++) f = c[o], f.form === r.form && hp(f);
            }
            break e;
          case "textarea":
            gp(r, c.value, c.defaultValue);
            break e;
          case "select":
            o = c.value, o != null && zs(r, !!c.multiple, o, false);
        }
      }
    }
    var vu = false;
    function bp(r, o, c) {
      if (vu) return r(o, c);
      vu = true;
      try {
        var f = r(o);
        return f;
      } finally {
        if (vu = false, (js !== null || Ws !== null) && (Al(), js && (o = js, r = Ws, Ws = js = null, yp(o), r))) for (o = 0; o < r.length; o++) yp(r[o]);
      }
    }
    function ia(r, o) {
      var c = r.stateNode;
      if (c === null) return null;
      var f = c[Dt] || null;
      if (f === null) return null;
      c = f[o];
      e: switch (o) {
        case "onClick":
        case "onClickCapture":
        case "onDoubleClick":
        case "onDoubleClickCapture":
        case "onMouseDown":
        case "onMouseDownCapture":
        case "onMouseMove":
        case "onMouseMoveCapture":
        case "onMouseUp":
        case "onMouseUpCapture":
        case "onMouseEnter":
          (f = !f.disabled) || (r = r.type, f = !(r === "button" || r === "input" || r === "select" || r === "textarea")), r = !f;
          break e;
        default:
          r = false;
      }
      if (r) return null;
      if (c && typeof c != "function") throw Error(i(231, o, typeof c));
      return c;
    }
    var jn = !(typeof window > "u" || typeof window.document > "u" || typeof window.document.createElement > "u"), Tu = false;
    if (jn) try {
      var sa = {};
      Object.defineProperty(sa, "passive", {
        get: function() {
          Tu = true;
        }
      }), window.addEventListener("test", sa, sa), window.removeEventListener("test", sa, sa);
    } catch {
      Tu = false;
    }
    var di = null, xu = null, Vo = null;
    function vp() {
      if (Vo) return Vo;
      var r, o = xu, c = o.length, f, g = "value" in di ? di.value : di.textContent, m = g.length;
      for (r = 0; r < c && o[r] === g[r]; r++) ;
      var b = c - r;
      for (f = 1; f <= b && o[c - f] === g[m - f]; f++) ;
      return Vo = g.slice(r, 1 < f ? 1 - f : void 0);
    }
    function zo(r) {
      var o = r.keyCode;
      return "charCode" in r ? (r = r.charCode, r === 0 && o === 13 && (r = 13)) : r = o, r === 10 && (r = 13), 32 <= r || r === 13 ? r : 0;
    }
    function Ho() {
      return true;
    }
    function Tp() {
      return false;
    }
    function kt(r) {
      function o(c, f, g, m, b) {
        this._reactName = c, this._targetInst = g, this.type = f, this.nativeEvent = m, this.target = b, this.currentTarget = null;
        for (var T in r) r.hasOwnProperty(T) && (c = r[T], this[T] = c ? c(m) : m[T]);
        return this.isDefaultPrevented = (m.defaultPrevented != null ? m.defaultPrevented : m.returnValue === false) ? Ho : Tp, this.isPropagationStopped = Tp, this;
      }
      return p(o.prototype, {
        preventDefault: function() {
          this.defaultPrevented = true;
          var c = this.nativeEvent;
          c && (c.preventDefault ? c.preventDefault() : typeof c.returnValue != "unknown" && (c.returnValue = false), this.isDefaultPrevented = Ho);
        },
        stopPropagation: function() {
          var c = this.nativeEvent;
          c && (c.stopPropagation ? c.stopPropagation() : typeof c.cancelBubble != "unknown" && (c.cancelBubble = true), this.isPropagationStopped = Ho);
        },
        persist: function() {
        },
        isPersistent: Ho
      }), o;
    }
    var Ji = {
      eventPhase: 0,
      bubbles: 0,
      cancelable: 0,
      timeStamp: function(r) {
        return r.timeStamp || Date.now();
      },
      defaultPrevented: 0,
      isTrusted: 0
    }, jo = kt(Ji), ra = p({}, Ji, {
      view: 0,
      detail: 0
    }), g1 = kt(ra), Su, Au, aa, Wo = p({}, ra, {
      screenX: 0,
      screenY: 0,
      clientX: 0,
      clientY: 0,
      pageX: 0,
      pageY: 0,
      ctrlKey: 0,
      shiftKey: 0,
      altKey: 0,
      metaKey: 0,
      getModifierState: Eu,
      button: 0,
      buttons: 0,
      relatedTarget: function(r) {
        return r.relatedTarget === void 0 ? r.fromElement === r.srcElement ? r.toElement : r.fromElement : r.relatedTarget;
      },
      movementX: function(r) {
        return "movementX" in r ? r.movementX : (r !== aa && (aa && r.type === "mousemove" ? (Su = r.screenX - aa.screenX, Au = r.screenY - aa.screenY) : Au = Su = 0, aa = r), Su);
      },
      movementY: function(r) {
        return "movementY" in r ? r.movementY : Au;
      }
    }), xp = kt(Wo), p1 = p({}, Wo, {
      dataTransfer: 0
    }), m1 = kt(p1), _1 = p({}, ra, {
      relatedTarget: 0
    }), wu = kt(_1), y1 = p({}, Ji, {
      animationName: 0,
      elapsedTime: 0,
      pseudoElement: 0
    }), b1 = kt(y1), v1 = p({}, Ji, {
      clipboardData: function(r) {
        return "clipboardData" in r ? r.clipboardData : window.clipboardData;
      }
    }), T1 = kt(v1), x1 = p({}, Ji, {
      data: 0
    }), Sp = kt(x1), S1 = {
      Esc: "Escape",
      Spacebar: " ",
      Left: "ArrowLeft",
      Up: "ArrowUp",
      Right: "ArrowRight",
      Down: "ArrowDown",
      Del: "Delete",
      Win: "OS",
      Menu: "ContextMenu",
      Apps: "ContextMenu",
      Scroll: "ScrollLock",
      MozPrintableKey: "Unidentified"
    }, A1 = {
      8: "Backspace",
      9: "Tab",
      12: "Clear",
      13: "Enter",
      16: "Shift",
      17: "Control",
      18: "Alt",
      19: "Pause",
      20: "CapsLock",
      27: "Escape",
      32: " ",
      33: "PageUp",
      34: "PageDown",
      35: "End",
      36: "Home",
      37: "ArrowLeft",
      38: "ArrowUp",
      39: "ArrowRight",
      40: "ArrowDown",
      45: "Insert",
      46: "Delete",
      112: "F1",
      113: "F2",
      114: "F3",
      115: "F4",
      116: "F5",
      117: "F6",
      118: "F7",
      119: "F8",
      120: "F9",
      121: "F10",
      122: "F11",
      123: "F12",
      144: "NumLock",
      145: "ScrollLock",
      224: "Meta"
    }, w1 = {
      Alt: "altKey",
      Control: "ctrlKey",
      Meta: "metaKey",
      Shift: "shiftKey"
    };
    function E1(r) {
      var o = this.nativeEvent;
      return o.getModifierState ? o.getModifierState(r) : (r = w1[r]) ? !!o[r] : false;
    }
    function Eu() {
      return E1;
    }
    var R1 = p({}, ra, {
      key: function(r) {
        if (r.key) {
          var o = S1[r.key] || r.key;
          if (o !== "Unidentified") return o;
        }
        return r.type === "keypress" ? (r = zo(r), r === 13 ? "Enter" : String.fromCharCode(r)) : r.type === "keydown" || r.type === "keyup" ? A1[r.keyCode] || "Unidentified" : "";
      },
      code: 0,
      location: 0,
      ctrlKey: 0,
      shiftKey: 0,
      altKey: 0,
      metaKey: 0,
      repeat: 0,
      locale: 0,
      getModifierState: Eu,
      charCode: function(r) {
        return r.type === "keypress" ? zo(r) : 0;
      },
      keyCode: function(r) {
        return r.type === "keydown" || r.type === "keyup" ? r.keyCode : 0;
      },
      which: function(r) {
        return r.type === "keypress" ? zo(r) : r.type === "keydown" || r.type === "keyup" ? r.keyCode : 0;
      }
    }), C1 = kt(R1), M1 = p({}, Wo, {
      pointerId: 0,
      width: 0,
      height: 0,
      pressure: 0,
      tangentialPressure: 0,
      tiltX: 0,
      tiltY: 0,
      twist: 0,
      pointerType: 0,
      isPrimary: 0
    }), Ap = kt(M1), O1 = p({}, ra, {
      touches: 0,
      targetTouches: 0,
      changedTouches: 0,
      altKey: 0,
      metaKey: 0,
      ctrlKey: 0,
      shiftKey: 0,
      getModifierState: Eu
    }), I1 = kt(O1), N1 = p({}, Ji, {
      propertyName: 0,
      elapsedTime: 0,
      pseudoElement: 0
    }), P1 = kt(N1), D1 = p({}, Wo, {
      deltaX: function(r) {
        return "deltaX" in r ? r.deltaX : "wheelDeltaX" in r ? -r.wheelDeltaX : 0;
      },
      deltaY: function(r) {
        return "deltaY" in r ? r.deltaY : "wheelDeltaY" in r ? -r.wheelDeltaY : "wheelDelta" in r ? -r.wheelDelta : 0;
      },
      deltaZ: 0,
      deltaMode: 0
    }), k1 = kt(D1), U1 = p({}, Ji, {
      newState: 0,
      oldState: 0
    }), B1 = kt(U1), L1 = [
      9,
      13,
      27,
      32
    ], Ru = jn && "CompositionEvent" in window, oa = null;
    jn && "documentMode" in document && (oa = document.documentMode);
    var F1 = jn && "TextEvent" in window && !oa, wp = jn && (!Ru || oa && 8 < oa && 11 >= oa), Ep = " ", Rp = false;
    function Cp(r, o) {
      switch (r) {
        case "keyup":
          return L1.indexOf(o.keyCode) !== -1;
        case "keydown":
          return o.keyCode !== 229;
        case "keypress":
        case "mousedown":
        case "focusout":
          return true;
        default:
          return false;
      }
    }
    function Mp(r) {
      return r = r.detail, typeof r == "object" && "data" in r ? r.data : null;
    }
    var $s = false;
    function V1(r, o) {
      switch (r) {
        case "compositionend":
          return Mp(o);
        case "keypress":
          return o.which !== 32 ? null : (Rp = true, Ep);
        case "textInput":
          return r = o.data, r === Ep && Rp ? null : r;
        default:
          return null;
      }
    }
    function z1(r, o) {
      if ($s) return r === "compositionend" || !Ru && Cp(r, o) ? (r = vp(), Vo = xu = di = null, $s = false, r) : null;
      switch (r) {
        case "paste":
          return null;
        case "keypress":
          if (!(o.ctrlKey || o.altKey || o.metaKey) || o.ctrlKey && o.altKey) {
            if (o.char && 1 < o.char.length) return o.char;
            if (o.which) return String.fromCharCode(o.which);
          }
          return null;
        case "compositionend":
          return wp && o.locale !== "ko" ? null : o.data;
        default:
          return null;
      }
    }
    var H1 = {
      color: true,
      date: true,
      datetime: true,
      "datetime-local": true,
      email: true,
      month: true,
      number: true,
      password: true,
      range: true,
      search: true,
      tel: true,
      text: true,
      time: true,
      url: true,
      week: true
    };
    function Op(r) {
      var o = r && r.nodeName && r.nodeName.toLowerCase();
      return o === "input" ? !!H1[r.type] : o === "textarea";
    }
    function Ip(r, o, c, f) {
      js ? Ws ? Ws.push(f) : Ws = [
        f
      ] : js = f, o = Ol(o, "onChange"), 0 < o.length && (c = new jo("onChange", "change", null, c, f), r.push({
        event: c,
        listeners: o
      }));
    }
    var la = null, ca = null;
    function j1(r) {
      fy(r, 0);
    }
    function $o(r) {
      var o = na(r);
      if (hp(o)) return r;
    }
    function Np(r, o) {
      if (r === "change") return o;
    }
    var Pp = false;
    if (jn) {
      var Cu;
      if (jn) {
        var Mu = "oninput" in document;
        if (!Mu) {
          var Dp = document.createElement("div");
          Dp.setAttribute("oninput", "return;"), Mu = typeof Dp.oninput == "function";
        }
        Cu = Mu;
      } else Cu = false;
      Pp = Cu && (!document.documentMode || 9 < document.documentMode);
    }
    function kp() {
      la && (la.detachEvent("onpropertychange", Up), ca = la = null);
    }
    function Up(r) {
      if (r.propertyName === "value" && $o(ca)) {
        var o = [];
        Ip(o, ca, r, bu(r)), bp(j1, o);
      }
    }
    function W1(r, o, c) {
      r === "focusin" ? (kp(), la = o, ca = c, la.attachEvent("onpropertychange", Up)) : r === "focusout" && kp();
    }
    function $1(r) {
      if (r === "selectionchange" || r === "keyup" || r === "keydown") return $o(ca);
    }
    function X1(r, o) {
      if (r === "click") return $o(o);
    }
    function Y1(r, o) {
      if (r === "input" || r === "change") return $o(o);
    }
    function q1(r, o) {
      return r === o && (r !== 0 || 1 / r === 1 / o) || r !== r && o !== o;
    }
    var Wt = typeof Object.is == "function" ? Object.is : q1;
    function ua(r, o) {
      if (Wt(r, o)) return true;
      if (typeof r != "object" || r === null || typeof o != "object" || o === null) return false;
      var c = Object.keys(r), f = Object.keys(o);
      if (c.length !== f.length) return false;
      for (f = 0; f < c.length; f++) {
        var g = c[f];
        if (!Ki.call(o, g) || !Wt(r[g], o[g])) return false;
      }
      return true;
    }
    function Bp(r) {
      for (; r && r.firstChild; ) r = r.firstChild;
      return r;
    }
    function Lp(r, o) {
      var c = Bp(r);
      r = 0;
      for (var f; c; ) {
        if (c.nodeType === 3) {
          if (f = r + c.textContent.length, r <= o && f >= o) return {
            node: c,
            offset: o - r
          };
          r = f;
        }
        e: {
          for (; c; ) {
            if (c.nextSibling) {
              c = c.nextSibling;
              break e;
            }
            c = c.parentNode;
          }
          c = void 0;
        }
        c = Bp(c);
      }
    }
    function Fp(r, o) {
      return r && o ? r === o ? true : r && r.nodeType === 3 ? false : o && o.nodeType === 3 ? Fp(r, o.parentNode) : "contains" in r ? r.contains(o) : r.compareDocumentPosition ? !!(r.compareDocumentPosition(o) & 16) : false : false;
    }
    function Vp(r) {
      r = r != null && r.ownerDocument != null && r.ownerDocument.defaultView != null ? r.ownerDocument.defaultView : window;
      for (var o = Lo(r.document); o instanceof r.HTMLIFrameElement; ) {
        try {
          var c = typeof o.contentWindow.location.href == "string";
        } catch {
          c = false;
        }
        if (c) r = o.contentWindow;
        else break;
        o = Lo(r.document);
      }
      return o;
    }
    function Ou(r) {
      var o = r && r.nodeName && r.nodeName.toLowerCase();
      return o && (o === "input" && (r.type === "text" || r.type === "search" || r.type === "tel" || r.type === "url" || r.type === "password") || o === "textarea" || r.contentEditable === "true");
    }
    var K1 = jn && "documentMode" in document && 11 >= document.documentMode, Xs = null, Iu = null, fa = null, Nu = false;
    function zp(r, o, c) {
      var f = c.window === c ? c.document : c.nodeType === 9 ? c : c.ownerDocument;
      Nu || Xs == null || Xs !== Lo(f) || (f = Xs, "selectionStart" in f && Ou(f) ? f = {
        start: f.selectionStart,
        end: f.selectionEnd
      } : (f = (f.ownerDocument && f.ownerDocument.defaultView || window).getSelection(), f = {
        anchorNode: f.anchorNode,
        anchorOffset: f.anchorOffset,
        focusNode: f.focusNode,
        focusOffset: f.focusOffset
      }), fa && ua(fa, f) || (fa = f, f = Ol(Iu, "onSelect"), 0 < f.length && (o = new jo("onSelect", "select", null, o, c), r.push({
        event: o,
        listeners: f
      }), o.target = Xs)));
    }
    function es(r, o) {
      var c = {};
      return c[r.toLowerCase()] = o.toLowerCase(), c["Webkit" + r] = "webkit" + o, c["Moz" + r] = "moz" + o, c;
    }
    var Ys = {
      animationend: es("Animation", "AnimationEnd"),
      animationiteration: es("Animation", "AnimationIteration"),
      animationstart: es("Animation", "AnimationStart"),
      transitionrun: es("Transition", "TransitionRun"),
      transitionstart: es("Transition", "TransitionStart"),
      transitioncancel: es("Transition", "TransitionCancel"),
      transitionend: es("Transition", "TransitionEnd")
    }, Pu = {}, Hp = {};
    jn && (Hp = document.createElement("div").style, "AnimationEvent" in window || (delete Ys.animationend.animation, delete Ys.animationiteration.animation, delete Ys.animationstart.animation), "TransitionEvent" in window || delete Ys.transitionend.transition);
    function ts(r) {
      if (Pu[r]) return Pu[r];
      if (!Ys[r]) return r;
      var o = Ys[r], c;
      for (c in o) if (o.hasOwnProperty(c) && c in Hp) return Pu[r] = o[c];
      return r;
    }
    var jp = ts("animationend"), Wp = ts("animationiteration"), $p = ts("animationstart"), Z1 = ts("transitionrun"), Q1 = ts("transitionstart"), G1 = ts("transitioncancel"), Xp = ts("transitionend"), Yp = /* @__PURE__ */ new Map(), Du = "abort auxClick beforeToggle cancel canPlay canPlayThrough click close contextMenu copy cut drag dragEnd dragEnter dragExit dragLeave dragOver dragStart drop durationChange emptied encrypted ended error gotPointerCapture input invalid keyDown keyPress keyUp load loadedData loadedMetadata loadStart lostPointerCapture mouseDown mouseMove mouseOut mouseOver mouseUp paste pause play playing pointerCancel pointerDown pointerMove pointerOut pointerOver pointerUp progress rateChange reset resize seeked seeking stalled submit suspend timeUpdate touchCancel touchEnd touchStart volumeChange scroll toggle touchMove waiting wheel".split(" ");
    Du.push("scrollEnd");
    function yn(r, o) {
      Yp.set(r, o), Gi(o, [
        r
      ]);
    }
    var qp = /* @__PURE__ */ new WeakMap();
    function sn(r, o) {
      if (typeof r == "object" && r !== null) {
        var c = qp.get(r);
        return c !== void 0 ? c : (o = {
          value: r,
          source: o,
          stack: up(o)
        }, qp.set(r, o), o);
      }
      return {
        value: r,
        source: o,
        stack: up(o)
      };
    }
    var rn = [], qs = 0, ku = 0;
    function Xo() {
      for (var r = qs, o = ku = qs = 0; o < r; ) {
        var c = rn[o];
        rn[o++] = null;
        var f = rn[o];
        rn[o++] = null;
        var g = rn[o];
        rn[o++] = null;
        var m = rn[o];
        if (rn[o++] = null, f !== null && g !== null) {
          var b = f.pending;
          b === null ? g.next = g : (g.next = b.next, b.next = g), f.pending = g;
        }
        m !== 0 && Kp(c, g, m);
      }
    }
    function Yo(r, o, c, f) {
      rn[qs++] = r, rn[qs++] = o, rn[qs++] = c, rn[qs++] = f, ku |= f, r.lanes |= f, r = r.alternate, r !== null && (r.lanes |= f);
    }
    function Uu(r, o, c, f) {
      return Yo(r, o, c, f), qo(r);
    }
    function Ks(r, o) {
      return Yo(r, null, null, o), qo(r);
    }
    function Kp(r, o, c) {
      r.lanes |= c;
      var f = r.alternate;
      f !== null && (f.lanes |= c);
      for (var g = false, m = r.return; m !== null; ) m.childLanes |= c, f = m.alternate, f !== null && (f.childLanes |= c), m.tag === 22 && (r = m.stateNode, r === null || r._visibility & 1 || (g = true)), r = m, m = m.return;
      return r.tag === 3 ? (m = r.stateNode, g && o !== null && (g = 31 - jt(c), r = m.hiddenUpdates, f = r[g], f === null ? r[g] = [
        o
      ] : f.push(o), o.lane = c | 536870912), m) : null;
    }
    function qo(r) {
      if (50 < Ua) throw Ua = 0, jf = null, Error(i(185));
      for (var o = r.return; o !== null; ) r = o, o = r.return;
      return r.tag === 3 ? r.stateNode : null;
    }
    var Zs = {};
    function J1(r, o, c, f) {
      this.tag = r, this.key = c, this.sibling = this.child = this.return = this.stateNode = this.type = this.elementType = null, this.index = 0, this.refCleanup = this.ref = null, this.pendingProps = o, this.dependencies = this.memoizedState = this.updateQueue = this.memoizedProps = null, this.mode = f, this.subtreeFlags = this.flags = 0, this.deletions = null, this.childLanes = this.lanes = 0, this.alternate = null;
    }
    function $t(r, o, c, f) {
      return new J1(r, o, c, f);
    }
    function Bu(r) {
      return r = r.prototype, !(!r || !r.isReactComponent);
    }
    function Wn(r, o) {
      var c = r.alternate;
      return c === null ? (c = $t(r.tag, o, r.key, r.mode), c.elementType = r.elementType, c.type = r.type, c.stateNode = r.stateNode, c.alternate = r, r.alternate = c) : (c.pendingProps = o, c.type = r.type, c.flags = 0, c.subtreeFlags = 0, c.deletions = null), c.flags = r.flags & 65011712, c.childLanes = r.childLanes, c.lanes = r.lanes, c.child = r.child, c.memoizedProps = r.memoizedProps, c.memoizedState = r.memoizedState, c.updateQueue = r.updateQueue, o = r.dependencies, c.dependencies = o === null ? null : {
        lanes: o.lanes,
        firstContext: o.firstContext
      }, c.sibling = r.sibling, c.index = r.index, c.ref = r.ref, c.refCleanup = r.refCleanup, c;
    }
    function Zp(r, o) {
      r.flags &= 65011714;
      var c = r.alternate;
      return c === null ? (r.childLanes = 0, r.lanes = o, r.child = null, r.subtreeFlags = 0, r.memoizedProps = null, r.memoizedState = null, r.updateQueue = null, r.dependencies = null, r.stateNode = null) : (r.childLanes = c.childLanes, r.lanes = c.lanes, r.child = c.child, r.subtreeFlags = 0, r.deletions = null, r.memoizedProps = c.memoizedProps, r.memoizedState = c.memoizedState, r.updateQueue = c.updateQueue, r.type = c.type, o = c.dependencies, r.dependencies = o === null ? null : {
        lanes: o.lanes,
        firstContext: o.firstContext
      }), r;
    }
    function Ko(r, o, c, f, g, m) {
      var b = 0;
      if (f = r, typeof r == "function") Bu(r) && (b = 1);
      else if (typeof r == "string") b = tS(r, c, ae.current) ? 26 : r === "html" || r === "head" || r === "body" ? 27 : 5;
      else e: switch (r) {
        case ee:
          return r = $t(31, c, o, g), r.elementType = ee, r.lanes = m, r;
        case S:
          return ns(c.children, g, m, o);
        case E:
          b = 8, g |= 24;
          break;
        case M:
          return r = $t(12, c, o, g | 2), r.elementType = M, r.lanes = m, r;
        case B:
          return r = $t(13, c, o, g), r.elementType = B, r.lanes = m, r;
        case Z:
          return r = $t(19, c, o, g), r.elementType = Z, r.lanes = m, r;
        default:
          if (typeof r == "object" && r !== null) switch (r.$$typeof) {
            case F:
            case O:
              b = 10;
              break e;
            case H:
              b = 9;
              break e;
            case U:
              b = 11;
              break e;
            case re:
              b = 14;
              break e;
            case le:
              b = 16, f = null;
              break e;
          }
          b = 29, c = Error(i(130, r === null ? "null" : typeof r, "")), f = null;
      }
      return o = $t(b, c, o, g), o.elementType = r, o.type = f, o.lanes = m, o;
    }
    function ns(r, o, c, f) {
      return r = $t(7, r, f, o), r.lanes = c, r;
    }
    function Lu(r, o, c) {
      return r = $t(6, r, null, o), r.lanes = c, r;
    }
    function Fu(r, o, c) {
      return o = $t(4, r.children !== null ? r.children : [], r.key, o), o.lanes = c, o.stateNode = {
        containerInfo: r.containerInfo,
        pendingChildren: null,
        implementation: r.implementation
      }, o;
    }
    var Qs = [], Gs = 0, Zo = null, Qo = 0, an = [], on = 0, is = null, $n = 1, Xn = "";
    function ss(r, o) {
      Qs[Gs++] = Qo, Qs[Gs++] = Zo, Zo = r, Qo = o;
    }
    function Qp(r, o, c) {
      an[on++] = $n, an[on++] = Xn, an[on++] = is, is = r;
      var f = $n;
      r = Xn;
      var g = 32 - jt(f) - 1;
      f &= ~(1 << g), c += 1;
      var m = 32 - jt(o) + g;
      if (30 < m) {
        var b = g - g % 5;
        m = (f & (1 << b) - 1).toString(32), f >>= b, g -= b, $n = 1 << 32 - jt(o) + g | c << g | f, Xn = m + r;
      } else $n = 1 << m | c << g | f, Xn = r;
    }
    function Vu(r) {
      r.return !== null && (ss(r, 1), Qp(r, 1, 0));
    }
    function zu(r) {
      for (; r === Zo; ) Zo = Qs[--Gs], Qs[Gs] = null, Qo = Qs[--Gs], Qs[Gs] = null;
      for (; r === is; ) is = an[--on], an[on] = null, Xn = an[--on], an[on] = null, $n = an[--on], an[on] = null;
    }
    var Nt = null, et = null, De = false, rs = null, En = false, Hu = Error(i(519));
    function as(r) {
      var o = Error(i(418, ""));
      throw ga(sn(o, r)), Hu;
    }
    function Gp(r) {
      var o = r.stateNode, c = r.type, f = r.memoizedProps;
      switch (o[At] = r, o[Dt] = f, c) {
        case "dialog":
          Me("cancel", o), Me("close", o);
          break;
        case "iframe":
        case "object":
        case "embed":
          Me("load", o);
          break;
        case "video":
        case "audio":
          for (c = 0; c < La.length; c++) Me(La[c], o);
          break;
        case "source":
          Me("error", o);
          break;
        case "img":
        case "image":
        case "link":
          Me("error", o), Me("load", o);
          break;
        case "details":
          Me("toggle", o);
          break;
        case "input":
          Me("invalid", o), dp(o, f.value, f.defaultValue, f.checked, f.defaultChecked, f.type, f.name, true), Bo(o);
          break;
        case "select":
          Me("invalid", o);
          break;
        case "textarea":
          Me("invalid", o), pp(o, f.value, f.defaultValue, f.children), Bo(o);
      }
      c = f.children, typeof c != "string" && typeof c != "number" && typeof c != "bigint" || o.textContent === "" + c || f.suppressHydrationWarning === true || py(o.textContent, c) ? (f.popover != null && (Me("beforetoggle", o), Me("toggle", o)), f.onScroll != null && Me("scroll", o), f.onScrollEnd != null && Me("scrollend", o), f.onClick != null && (o.onclick = Il), o = true) : o = false, o || as(r);
    }
    function Jp(r) {
      for (Nt = r.return; Nt; ) switch (Nt.tag) {
        case 5:
        case 13:
          En = false;
          return;
        case 27:
        case 3:
          En = true;
          return;
        default:
          Nt = Nt.return;
      }
    }
    function ha(r) {
      if (r !== Nt) return false;
      if (!De) return Jp(r), De = true, false;
      var o = r.tag, c;
      if ((c = o !== 3 && o !== 27) && ((c = o === 5) && (c = r.type, c = !(c !== "form" && c !== "button") || rh(r.type, r.memoizedProps)), c = !c), c && et && as(r), Jp(r), o === 13) {
        if (r = r.memoizedState, r = r !== null ? r.dehydrated : null, !r) throw Error(i(317));
        e: {
          for (r = r.nextSibling, o = 0; r; ) {
            if (r.nodeType === 8) if (c = r.data, c === "/$") {
              if (o === 0) {
                et = vn(r.nextSibling);
                break e;
              }
              o--;
            } else c !== "$" && c !== "$!" && c !== "$?" || o++;
            r = r.nextSibling;
          }
          et = null;
        }
      } else o === 27 ? (o = et, Mi(r.type) ? (r = ch, ch = null, et = r) : et = o) : et = Nt ? vn(r.stateNode.nextSibling) : null;
      return true;
    }
    function da() {
      et = Nt = null, De = false;
    }
    function em() {
      var r = rs;
      return r !== null && (Lt === null ? Lt = r : Lt.push.apply(Lt, r), rs = null), r;
    }
    function ga(r) {
      rs === null ? rs = [
        r
      ] : rs.push(r);
    }
    var ju = Q(null), os = null, Yn = null;
    function gi(r, o, c) {
      se(ju, o._currentValue), o._currentValue = c;
    }
    function qn(r) {
      r._currentValue = ju.current, oe(ju);
    }
    function Wu(r, o, c) {
      for (; r !== null; ) {
        var f = r.alternate;
        if ((r.childLanes & o) !== o ? (r.childLanes |= o, f !== null && (f.childLanes |= o)) : f !== null && (f.childLanes & o) !== o && (f.childLanes |= o), r === c) break;
        r = r.return;
      }
    }
    function $u(r, o, c, f) {
      var g = r.child;
      for (g !== null && (g.return = r); g !== null; ) {
        var m = g.dependencies;
        if (m !== null) {
          var b = g.child;
          m = m.firstContext;
          e: for (; m !== null; ) {
            var T = m;
            m = g;
            for (var w = 0; w < o.length; w++) if (T.context === o[w]) {
              m.lanes |= c, T = m.alternate, T !== null && (T.lanes |= c), Wu(m.return, c, r), f || (b = null);
              break e;
            }
            m = T.next;
          }
        } else if (g.tag === 18) {
          if (b = g.return, b === null) throw Error(i(341));
          b.lanes |= c, m = b.alternate, m !== null && (m.lanes |= c), Wu(b, c, r), b = null;
        } else b = g.child;
        if (b !== null) b.return = g;
        else for (b = g; b !== null; ) {
          if (b === r) {
            b = null;
            break;
          }
          if (g = b.sibling, g !== null) {
            g.return = b.return, b = g;
            break;
          }
          b = b.return;
        }
        g = b;
      }
    }
    function pa(r, o, c, f) {
      r = null;
      for (var g = o, m = false; g !== null; ) {
        if (!m) {
          if ((g.flags & 524288) !== 0) m = true;
          else if ((g.flags & 262144) !== 0) break;
        }
        if (g.tag === 10) {
          var b = g.alternate;
          if (b === null) throw Error(i(387));
          if (b = b.memoizedProps, b !== null) {
            var T = g.type;
            Wt(g.pendingProps.value, b.value) || (r !== null ? r.push(T) : r = [
              T
            ]);
          }
        } else if (g === Ge.current) {
          if (b = g.alternate, b === null) throw Error(i(387));
          b.memoizedState.memoizedState !== g.memoizedState.memoizedState && (r !== null ? r.push(Wa) : r = [
            Wa
          ]);
        }
        g = g.return;
      }
      r !== null && $u(o, r, c, f), o.flags |= 262144;
    }
    function Go(r) {
      for (r = r.firstContext; r !== null; ) {
        if (!Wt(r.context._currentValue, r.memoizedValue)) return true;
        r = r.next;
      }
      return false;
    }
    function ls(r) {
      os = r, Yn = null, r = r.dependencies, r !== null && (r.firstContext = null);
    }
    function wt(r) {
      return tm(os, r);
    }
    function Jo(r, o) {
      return os === null && ls(r), tm(r, o);
    }
    function tm(r, o) {
      var c = o._currentValue;
      if (o = {
        context: o,
        memoizedValue: c,
        next: null
      }, Yn === null) {
        if (r === null) throw Error(i(308));
        Yn = o, r.dependencies = {
          lanes: 0,
          firstContext: o
        }, r.flags |= 524288;
      } else Yn = Yn.next = o;
      return c;
    }
    var ex = typeof AbortController < "u" ? AbortController : function() {
      var r = [], o = this.signal = {
        aborted: false,
        addEventListener: function(c, f) {
          r.push(f);
        }
      };
      this.abort = function() {
        o.aborted = true, r.forEach(function(c) {
          return c();
        });
      };
    }, tx = n.unstable_scheduleCallback, nx = n.unstable_NormalPriority, ft = {
      $$typeof: O,
      Consumer: null,
      Provider: null,
      _currentValue: null,
      _currentValue2: null,
      _threadCount: 0
    };
    function Xu() {
      return {
        controller: new ex(),
        data: /* @__PURE__ */ new Map(),
        refCount: 0
      };
    }
    function ma(r) {
      r.refCount--, r.refCount === 0 && tx(nx, function() {
        r.controller.abort();
      });
    }
    var _a2 = null, Yu = 0, Js = 0, er = null;
    function ix(r, o) {
      if (_a2 === null) {
        var c = _a2 = [];
        Yu = 0, Js = Zf(), er = {
          status: "pending",
          value: void 0,
          then: function(f) {
            c.push(f);
          }
        };
      }
      return Yu++, o.then(nm, nm), o;
    }
    function nm() {
      if (--Yu === 0 && _a2 !== null) {
        er !== null && (er.status = "fulfilled");
        var r = _a2;
        _a2 = null, Js = 0, er = null;
        for (var o = 0; o < r.length; o++) (0, r[o])();
      }
    }
    function sx(r, o) {
      var c = [], f = {
        status: "pending",
        value: null,
        reason: null,
        then: function(g) {
          c.push(g);
        }
      };
      return r.then(function() {
        f.status = "fulfilled", f.value = o;
        for (var g = 0; g < c.length; g++) (0, c[g])(o);
      }, function(g) {
        for (f.status = "rejected", f.reason = g, g = 0; g < c.length; g++) (0, c[g])(void 0);
      }), f;
    }
    var im = $.S;
    $.S = function(r, o) {
      typeof o == "object" && o !== null && typeof o.then == "function" && ix(r, o), im !== null && im(r, o);
    };
    var cs = Q(null);
    function qu() {
      var r = cs.current;
      return r !== null ? r : qe.pooledCache;
    }
    function el(r, o) {
      o === null ? se(cs, cs.current) : se(cs, o.pool);
    }
    function sm() {
      var r = qu();
      return r === null ? null : {
        parent: ft._currentValue,
        pool: r
      };
    }
    var ya = Error(i(460)), rm = Error(i(474)), tl = Error(i(542)), Ku = {
      then: function() {
      }
    };
    function am(r) {
      return r = r.status, r === "fulfilled" || r === "rejected";
    }
    function nl() {
    }
    function om(r, o, c) {
      switch (c = r[c], c === void 0 ? r.push(o) : c !== o && (o.then(nl, nl), o = c), o.status) {
        case "fulfilled":
          return o.value;
        case "rejected":
          throw r = o.reason, cm(r), r;
        default:
          if (typeof o.status == "string") o.then(nl, nl);
          else {
            if (r = qe, r !== null && 100 < r.shellSuspendCounter) throw Error(i(482));
            r = o, r.status = "pending", r.then(function(f) {
              if (o.status === "pending") {
                var g = o;
                g.status = "fulfilled", g.value = f;
              }
            }, function(f) {
              if (o.status === "pending") {
                var g = o;
                g.status = "rejected", g.reason = f;
              }
            });
          }
          switch (o.status) {
            case "fulfilled":
              return o.value;
            case "rejected":
              throw r = o.reason, cm(r), r;
          }
          throw ba = o, ya;
      }
    }
    var ba = null;
    function lm() {
      if (ba === null) throw Error(i(459));
      var r = ba;
      return ba = null, r;
    }
    function cm(r) {
      if (r === ya || r === tl) throw Error(i(483));
    }
    var pi = false;
    function Zu(r) {
      r.updateQueue = {
        baseState: r.memoizedState,
        firstBaseUpdate: null,
        lastBaseUpdate: null,
        shared: {
          pending: null,
          lanes: 0,
          hiddenCallbacks: null
        },
        callbacks: null
      };
    }
    function Qu(r, o) {
      r = r.updateQueue, o.updateQueue === r && (o.updateQueue = {
        baseState: r.baseState,
        firstBaseUpdate: r.firstBaseUpdate,
        lastBaseUpdate: r.lastBaseUpdate,
        shared: r.shared,
        callbacks: null
      });
    }
    function mi(r) {
      return {
        lane: r,
        tag: 0,
        payload: null,
        callback: null,
        next: null
      };
    }
    function _i(r, o, c) {
      var f = r.updateQueue;
      if (f === null) return null;
      if (f = f.shared, (Fe & 2) !== 0) {
        var g = f.pending;
        return g === null ? o.next = o : (o.next = g.next, g.next = o), f.pending = o, o = qo(r), Kp(r, null, c), o;
      }
      return Yo(r, f, o, c), qo(r);
    }
    function va(r, o, c) {
      if (o = o.updateQueue, o !== null && (o = o.shared, (c & 4194048) !== 0)) {
        var f = o.lanes;
        f &= r.pendingLanes, c |= f, o.lanes = c, np(r, c);
      }
    }
    function Gu(r, o) {
      var c = r.updateQueue, f = r.alternate;
      if (f !== null && (f = f.updateQueue, c === f)) {
        var g = null, m = null;
        if (c = c.firstBaseUpdate, c !== null) {
          do {
            var b = {
              lane: c.lane,
              tag: c.tag,
              payload: c.payload,
              callback: null,
              next: null
            };
            m === null ? g = m = b : m = m.next = b, c = c.next;
          } while (c !== null);
          m === null ? g = m = o : m = m.next = o;
        } else g = m = o;
        c = {
          baseState: f.baseState,
          firstBaseUpdate: g,
          lastBaseUpdate: m,
          shared: f.shared,
          callbacks: f.callbacks
        }, r.updateQueue = c;
        return;
      }
      r = c.lastBaseUpdate, r === null ? c.firstBaseUpdate = o : r.next = o, c.lastBaseUpdate = o;
    }
    var Ju = false;
    function Ta() {
      if (Ju) {
        var r = er;
        if (r !== null) throw r;
      }
    }
    function xa(r, o, c, f) {
      Ju = false;
      var g = r.updateQueue;
      pi = false;
      var m = g.firstBaseUpdate, b = g.lastBaseUpdate, T = g.shared.pending;
      if (T !== null) {
        g.shared.pending = null;
        var w = T, z = w.next;
        w.next = null, b === null ? m = z : b.next = z, b = w;
        var X = r.alternate;
        X !== null && (X = X.updateQueue, T = X.lastBaseUpdate, T !== b && (T === null ? X.firstBaseUpdate = z : T.next = z, X.lastBaseUpdate = w));
      }
      if (m !== null) {
        var K = g.baseState;
        b = 0, X = z = w = null, T = m;
        do {
          var j = T.lane & -536870913, W = j !== T.lane;
          if (W ? (Ie & j) === j : (f & j) === j) {
            j !== 0 && j === Js && (Ju = true), X !== null && (X = X.next = {
              lane: 0,
              tag: T.tag,
              payload: T.payload,
              callback: null,
              next: null
            });
            e: {
              var be = r, pe = T;
              j = o;
              var je = c;
              switch (pe.tag) {
                case 1:
                  if (be = pe.payload, typeof be == "function") {
                    K = be.call(je, K, j);
                    break e;
                  }
                  K = be;
                  break e;
                case 3:
                  be.flags = be.flags & -65537 | 128;
                case 0:
                  if (be = pe.payload, j = typeof be == "function" ? be.call(je, K, j) : be, j == null) break e;
                  K = p({}, K, j);
                  break e;
                case 2:
                  pi = true;
              }
            }
            j = T.callback, j !== null && (r.flags |= 64, W && (r.flags |= 8192), W = g.callbacks, W === null ? g.callbacks = [
              j
            ] : W.push(j));
          } else W = {
            lane: j,
            tag: T.tag,
            payload: T.payload,
            callback: T.callback,
            next: null
          }, X === null ? (z = X = W, w = K) : X = X.next = W, b |= j;
          if (T = T.next, T === null) {
            if (T = g.shared.pending, T === null) break;
            W = T, T = W.next, W.next = null, g.lastBaseUpdate = W, g.shared.pending = null;
          }
        } while (true);
        X === null && (w = K), g.baseState = w, g.firstBaseUpdate = z, g.lastBaseUpdate = X, m === null && (g.shared.lanes = 0), wi |= b, r.lanes = b, r.memoizedState = K;
      }
    }
    function um(r, o) {
      if (typeof r != "function") throw Error(i(191, r));
      r.call(o);
    }
    function fm(r, o) {
      var c = r.callbacks;
      if (c !== null) for (r.callbacks = null, r = 0; r < c.length; r++) um(c[r], o);
    }
    var tr = Q(null), il = Q(0);
    function hm(r, o) {
      r = ti, se(il, r), se(tr, o), ti = r | o.baseLanes;
    }
    function ef() {
      se(il, ti), se(tr, tr.current);
    }
    function tf() {
      ti = il.current, oe(tr), oe(il);
    }
    var yi = 0, Ee = null, ze = null, at = null, sl = false, nr = false, us = false, rl = 0, Sa = 0, ir = null, rx = 0;
    function st() {
      throw Error(i(321));
    }
    function nf(r, o) {
      if (o === null) return false;
      for (var c = 0; c < o.length && c < r.length; c++) if (!Wt(r[c], o[c])) return false;
      return true;
    }
    function sf(r, o, c, f, g, m) {
      return yi = m, Ee = o, o.memoizedState = null, o.updateQueue = null, o.lanes = 0, $.H = r === null || r.memoizedState === null ? Km : Zm, us = false, m = c(f, g), us = false, nr && (m = gm(o, c, f, g)), dm(r), m;
    }
    function dm(r) {
      $.H = fl;
      var o = ze !== null && ze.next !== null;
      if (yi = 0, at = ze = Ee = null, sl = false, Sa = 0, ir = null, o) throw Error(i(300));
      r === null || _t || (r = r.dependencies, r !== null && Go(r) && (_t = true));
    }
    function gm(r, o, c, f) {
      Ee = r;
      var g = 0;
      do {
        if (nr && (ir = null), Sa = 0, nr = false, 25 <= g) throw Error(i(301));
        if (g += 1, at = ze = null, r.updateQueue != null) {
          var m = r.updateQueue;
          m.lastEffect = null, m.events = null, m.stores = null, m.memoCache != null && (m.memoCache.index = 0);
        }
        $.H = hx, m = o(c, f);
      } while (nr);
      return m;
    }
    function ax() {
      var r = $.H, o = r.useState()[0];
      return o = typeof o.then == "function" ? Aa(o) : o, r = r.useState()[0], (ze !== null ? ze.memoizedState : null) !== r && (Ee.flags |= 1024), o;
    }
    function rf() {
      var r = rl !== 0;
      return rl = 0, r;
    }
    function af(r, o, c) {
      o.updateQueue = r.updateQueue, o.flags &= -2053, r.lanes &= ~c;
    }
    function of(r) {
      if (sl) {
        for (r = r.memoizedState; r !== null; ) {
          var o = r.queue;
          o !== null && (o.pending = null), r = r.next;
        }
        sl = false;
      }
      yi = 0, at = ze = Ee = null, nr = false, Sa = rl = 0, ir = null;
    }
    function Ut() {
      var r = {
        memoizedState: null,
        baseState: null,
        baseQueue: null,
        queue: null,
        next: null
      };
      return at === null ? Ee.memoizedState = at = r : at = at.next = r, at;
    }
    function ot() {
      if (ze === null) {
        var r = Ee.alternate;
        r = r !== null ? r.memoizedState : null;
      } else r = ze.next;
      var o = at === null ? Ee.memoizedState : at.next;
      if (o !== null) at = o, ze = r;
      else {
        if (r === null) throw Ee.alternate === null ? Error(i(467)) : Error(i(310));
        ze = r, r = {
          memoizedState: ze.memoizedState,
          baseState: ze.baseState,
          baseQueue: ze.baseQueue,
          queue: ze.queue,
          next: null
        }, at === null ? Ee.memoizedState = at = r : at = at.next = r;
      }
      return at;
    }
    function lf() {
      return {
        lastEffect: null,
        events: null,
        stores: null,
        memoCache: null
      };
    }
    function Aa(r) {
      var o = Sa;
      return Sa += 1, ir === null && (ir = []), r = om(ir, r, o), o = Ee, (at === null ? o.memoizedState : at.next) === null && (o = o.alternate, $.H = o === null || o.memoizedState === null ? Km : Zm), r;
    }
    function al(r) {
      if (r !== null && typeof r == "object") {
        if (typeof r.then == "function") return Aa(r);
        if (r.$$typeof === O) return wt(r);
      }
      throw Error(i(438, String(r)));
    }
    function cf(r) {
      var o = null, c = Ee.updateQueue;
      if (c !== null && (o = c.memoCache), o == null) {
        var f = Ee.alternate;
        f !== null && (f = f.updateQueue, f !== null && (f = f.memoCache, f != null && (o = {
          data: f.data.map(function(g) {
            return g.slice();
          }),
          index: 0
        })));
      }
      if (o == null && (o = {
        data: [],
        index: 0
      }), c === null && (c = lf(), Ee.updateQueue = c), c.memoCache = o, c = o.data[o.index], c === void 0) for (c = o.data[o.index] = Array(r), f = 0; f < r; f++) c[f] = fe;
      return o.index++, c;
    }
    function Kn(r, o) {
      return typeof o == "function" ? o(r) : o;
    }
    function ol(r) {
      var o = ot();
      return uf(o, ze, r);
    }
    function uf(r, o, c) {
      var f = r.queue;
      if (f === null) throw Error(i(311));
      f.lastRenderedReducer = c;
      var g = r.baseQueue, m = f.pending;
      if (m !== null) {
        if (g !== null) {
          var b = g.next;
          g.next = m.next, m.next = b;
        }
        o.baseQueue = g = m, f.pending = null;
      }
      if (m = r.baseState, g === null) r.memoizedState = m;
      else {
        o = g.next;
        var T = b = null, w = null, z = o, X = false;
        do {
          var K = z.lane & -536870913;
          if (K !== z.lane ? (Ie & K) === K : (yi & K) === K) {
            var j = z.revertLane;
            if (j === 0) w !== null && (w = w.next = {
              lane: 0,
              revertLane: 0,
              action: z.action,
              hasEagerState: z.hasEagerState,
              eagerState: z.eagerState,
              next: null
            }), K === Js && (X = true);
            else if ((yi & j) === j) {
              z = z.next, j === Js && (X = true);
              continue;
            } else K = {
              lane: 0,
              revertLane: z.revertLane,
              action: z.action,
              hasEagerState: z.hasEagerState,
              eagerState: z.eagerState,
              next: null
            }, w === null ? (T = w = K, b = m) : w = w.next = K, Ee.lanes |= j, wi |= j;
            K = z.action, us && c(m, K), m = z.hasEagerState ? z.eagerState : c(m, K);
          } else j = {
            lane: K,
            revertLane: z.revertLane,
            action: z.action,
            hasEagerState: z.hasEagerState,
            eagerState: z.eagerState,
            next: null
          }, w === null ? (T = w = j, b = m) : w = w.next = j, Ee.lanes |= K, wi |= K;
          z = z.next;
        } while (z !== null && z !== o);
        if (w === null ? b = m : w.next = T, !Wt(m, r.memoizedState) && (_t = true, X && (c = er, c !== null))) throw c;
        r.memoizedState = m, r.baseState = b, r.baseQueue = w, f.lastRenderedState = m;
      }
      return g === null && (f.lanes = 0), [
        r.memoizedState,
        f.dispatch
      ];
    }
    function ff(r) {
      var o = ot(), c = o.queue;
      if (c === null) throw Error(i(311));
      c.lastRenderedReducer = r;
      var f = c.dispatch, g = c.pending, m = o.memoizedState;
      if (g !== null) {
        c.pending = null;
        var b = g = g.next;
        do
          m = r(m, b.action), b = b.next;
        while (b !== g);
        Wt(m, o.memoizedState) || (_t = true), o.memoizedState = m, o.baseQueue === null && (o.baseState = m), c.lastRenderedState = m;
      }
      return [
        m,
        f
      ];
    }
    function pm(r, o, c) {
      var f = Ee, g = ot(), m = De;
      if (m) {
        if (c === void 0) throw Error(i(407));
        c = c();
      } else c = o();
      var b = !Wt((ze || g).memoizedState, c);
      b && (g.memoizedState = c, _t = true), g = g.queue;
      var T = ym.bind(null, f, g, r);
      if (wa(2048, 8, T, [
        r
      ]), g.getSnapshot !== o || b || at !== null && at.memoizedState.tag & 1) {
        if (f.flags |= 2048, sr(9, ll(), _m.bind(null, f, g, c, o), null), qe === null) throw Error(i(349));
        m || (yi & 124) !== 0 || mm(f, o, c);
      }
      return c;
    }
    function mm(r, o, c) {
      r.flags |= 16384, r = {
        getSnapshot: o,
        value: c
      }, o = Ee.updateQueue, o === null ? (o = lf(), Ee.updateQueue = o, o.stores = [
        r
      ]) : (c = o.stores, c === null ? o.stores = [
        r
      ] : c.push(r));
    }
    function _m(r, o, c, f) {
      o.value = c, o.getSnapshot = f, bm(o) && vm(r);
    }
    function ym(r, o, c) {
      return c(function() {
        bm(o) && vm(r);
      });
    }
    function bm(r) {
      var o = r.getSnapshot;
      r = r.value;
      try {
        var c = o();
        return !Wt(r, c);
      } catch {
        return true;
      }
    }
    function vm(r) {
      var o = Ks(r, 2);
      o !== null && Zt(o, r, 2);
    }
    function hf(r) {
      var o = Ut();
      if (typeof r == "function") {
        var c = r;
        if (r = c(), us) {
          fi(true);
          try {
            c();
          } finally {
            fi(false);
          }
        }
      }
      return o.memoizedState = o.baseState = r, o.queue = {
        pending: null,
        lanes: 0,
        dispatch: null,
        lastRenderedReducer: Kn,
        lastRenderedState: r
      }, o;
    }
    function Tm(r, o, c, f) {
      return r.baseState = c, uf(r, ze, typeof f == "function" ? f : Kn);
    }
    function ox(r, o, c, f, g) {
      if (ul(r)) throw Error(i(485));
      if (r = o.action, r !== null) {
        var m = {
          payload: g,
          action: r,
          next: null,
          isTransition: true,
          status: "pending",
          value: null,
          reason: null,
          listeners: [],
          then: function(b) {
            m.listeners.push(b);
          }
        };
        $.T !== null ? c(true) : m.isTransition = false, f(m), c = o.pending, c === null ? (m.next = o.pending = m, xm(o, m)) : (m.next = c.next, o.pending = c.next = m);
      }
    }
    function xm(r, o) {
      var c = o.action, f = o.payload, g = r.state;
      if (o.isTransition) {
        var m = $.T, b = {};
        $.T = b;
        try {
          var T = c(g, f), w = $.S;
          w !== null && w(b, T), Sm(r, o, T);
        } catch (z) {
          df(r, o, z);
        } finally {
          $.T = m;
        }
      } else try {
        m = c(g, f), Sm(r, o, m);
      } catch (z) {
        df(r, o, z);
      }
    }
    function Sm(r, o, c) {
      c !== null && typeof c == "object" && typeof c.then == "function" ? c.then(function(f) {
        Am(r, o, f);
      }, function(f) {
        return df(r, o, f);
      }) : Am(r, o, c);
    }
    function Am(r, o, c) {
      o.status = "fulfilled", o.value = c, wm(o), r.state = c, o = r.pending, o !== null && (c = o.next, c === o ? r.pending = null : (c = c.next, o.next = c, xm(r, c)));
    }
    function df(r, o, c) {
      var f = r.pending;
      if (r.pending = null, f !== null) {
        f = f.next;
        do
          o.status = "rejected", o.reason = c, wm(o), o = o.next;
        while (o !== f);
      }
      r.action = null;
    }
    function wm(r) {
      r = r.listeners;
      for (var o = 0; o < r.length; o++) (0, r[o])();
    }
    function Em(r, o) {
      return o;
    }
    function Rm(r, o) {
      if (De) {
        var c = qe.formState;
        if (c !== null) {
          e: {
            var f = Ee;
            if (De) {
              if (et) {
                t: {
                  for (var g = et, m = En; g.nodeType !== 8; ) {
                    if (!m) {
                      g = null;
                      break t;
                    }
                    if (g = vn(g.nextSibling), g === null) {
                      g = null;
                      break t;
                    }
                  }
                  m = g.data, g = m === "F!" || m === "F" ? g : null;
                }
                if (g) {
                  et = vn(g.nextSibling), f = g.data === "F!";
                  break e;
                }
              }
              as(f);
            }
            f = false;
          }
          f && (o = c[0]);
        }
      }
      return c = Ut(), c.memoizedState = c.baseState = o, f = {
        pending: null,
        lanes: 0,
        dispatch: null,
        lastRenderedReducer: Em,
        lastRenderedState: o
      }, c.queue = f, c = Xm.bind(null, Ee, f), f.dispatch = c, f = hf(false), m = yf.bind(null, Ee, false, f.queue), f = Ut(), g = {
        state: o,
        dispatch: null,
        action: r,
        pending: null
      }, f.queue = g, c = ox.bind(null, Ee, g, m, c), g.dispatch = c, f.memoizedState = r, [
        o,
        c,
        false
      ];
    }
    function Cm(r) {
      var o = ot();
      return Mm(o, ze, r);
    }
    function Mm(r, o, c) {
      if (o = uf(r, o, Em)[0], r = ol(Kn)[0], typeof o == "object" && o !== null && typeof o.then == "function") try {
        var f = Aa(o);
      } catch (b) {
        throw b === ya ? tl : b;
      }
      else f = o;
      o = ot();
      var g = o.queue, m = g.dispatch;
      return c !== o.memoizedState && (Ee.flags |= 2048, sr(9, ll(), lx.bind(null, g, c), null)), [
        f,
        m,
        r
      ];
    }
    function lx(r, o) {
      r.action = o;
    }
    function Om(r) {
      var o = ot(), c = ze;
      if (c !== null) return Mm(o, c, r);
      ot(), o = o.memoizedState, c = ot();
      var f = c.queue.dispatch;
      return c.memoizedState = r, [
        o,
        f,
        false
      ];
    }
    function sr(r, o, c, f) {
      return r = {
        tag: r,
        create: c,
        deps: f,
        inst: o,
        next: null
      }, o = Ee.updateQueue, o === null && (o = lf(), Ee.updateQueue = o), c = o.lastEffect, c === null ? o.lastEffect = r.next = r : (f = c.next, c.next = r, r.next = f, o.lastEffect = r), r;
    }
    function ll() {
      return {
        destroy: void 0,
        resource: void 0
      };
    }
    function Im() {
      return ot().memoizedState;
    }
    function cl(r, o, c, f) {
      var g = Ut();
      f = f === void 0 ? null : f, Ee.flags |= r, g.memoizedState = sr(1 | o, ll(), c, f);
    }
    function wa(r, o, c, f) {
      var g = ot();
      f = f === void 0 ? null : f;
      var m = g.memoizedState.inst;
      ze !== null && f !== null && nf(f, ze.memoizedState.deps) ? g.memoizedState = sr(o, m, c, f) : (Ee.flags |= r, g.memoizedState = sr(1 | o, m, c, f));
    }
    function Nm(r, o) {
      cl(8390656, 8, r, o);
    }
    function Pm(r, o) {
      wa(2048, 8, r, o);
    }
    function Dm(r, o) {
      return wa(4, 2, r, o);
    }
    function km(r, o) {
      return wa(4, 4, r, o);
    }
    function Um(r, o) {
      if (typeof o == "function") {
        r = r();
        var c = o(r);
        return function() {
          typeof c == "function" ? c() : o(null);
        };
      }
      if (o != null) return r = r(), o.current = r, function() {
        o.current = null;
      };
    }
    function Bm(r, o, c) {
      c = c != null ? c.concat([
        r
      ]) : null, wa(4, 4, Um.bind(null, o, r), c);
    }
    function gf() {
    }
    function Lm(r, o) {
      var c = ot();
      o = o === void 0 ? null : o;
      var f = c.memoizedState;
      return o !== null && nf(o, f[1]) ? f[0] : (c.memoizedState = [
        r,
        o
      ], r);
    }
    function Fm(r, o) {
      var c = ot();
      o = o === void 0 ? null : o;
      var f = c.memoizedState;
      if (o !== null && nf(o, f[1])) return f[0];
      if (f = r(), us) {
        fi(true);
        try {
          r();
        } finally {
          fi(false);
        }
      }
      return c.memoizedState = [
        f,
        o
      ], f;
    }
    function pf(r, o, c) {
      return c === void 0 || (yi & 1073741824) !== 0 ? r.memoizedState = o : (r.memoizedState = c, r = H_(), Ee.lanes |= r, wi |= r, c);
    }
    function Vm(r, o, c, f) {
      return Wt(c, o) ? c : tr.current !== null ? (r = pf(r, c, f), Wt(r, o) || (_t = true), r) : (yi & 42) === 0 ? (_t = true, r.memoizedState = c) : (r = H_(), Ee.lanes |= r, wi |= r, o);
    }
    function zm(r, o, c, f, g) {
      var m = ne.p;
      ne.p = m !== 0 && 8 > m ? m : 8;
      var b = $.T, T = {};
      $.T = T, yf(r, false, o, c);
      try {
        var w = g(), z = $.S;
        if (z !== null && z(T, w), w !== null && typeof w == "object" && typeof w.then == "function") {
          var X = sx(w, f);
          Ea(r, o, X, Kt(r));
        } else Ea(r, o, f, Kt(r));
      } catch (K) {
        Ea(r, o, {
          then: function() {
          },
          status: "rejected",
          reason: K
        }, Kt());
      } finally {
        ne.p = m, $.T = b;
      }
    }
    function cx() {
    }
    function mf(r, o, c, f) {
      if (r.tag !== 5) throw Error(i(476));
      var g = Hm(r).queue;
      zm(r, g, o, he, c === null ? cx : function() {
        return jm(r), c(f);
      });
    }
    function Hm(r) {
      var o = r.memoizedState;
      if (o !== null) return o;
      o = {
        memoizedState: he,
        baseState: he,
        baseQueue: null,
        queue: {
          pending: null,
          lanes: 0,
          dispatch: null,
          lastRenderedReducer: Kn,
          lastRenderedState: he
        },
        next: null
      };
      var c = {};
      return o.next = {
        memoizedState: c,
        baseState: c,
        baseQueue: null,
        queue: {
          pending: null,
          lanes: 0,
          dispatch: null,
          lastRenderedReducer: Kn,
          lastRenderedState: c
        },
        next: null
      }, r.memoizedState = o, r = r.alternate, r !== null && (r.memoizedState = o), o;
    }
    function jm(r) {
      var o = Hm(r).next.queue;
      Ea(r, o, {}, Kt());
    }
    function _f() {
      return wt(Wa);
    }
    function Wm() {
      return ot().memoizedState;
    }
    function $m() {
      return ot().memoizedState;
    }
    function ux(r) {
      for (var o = r.return; o !== null; ) {
        switch (o.tag) {
          case 24:
          case 3:
            var c = Kt();
            r = mi(c);
            var f = _i(o, r, c);
            f !== null && (Zt(f, o, c), va(f, o, c)), o = {
              cache: Xu()
            }, r.payload = o;
            return;
        }
        o = o.return;
      }
    }
    function fx(r, o, c) {
      var f = Kt();
      c = {
        lane: f,
        revertLane: 0,
        action: c,
        hasEagerState: false,
        eagerState: null,
        next: null
      }, ul(r) ? Ym(o, c) : (c = Uu(r, o, c, f), c !== null && (Zt(c, r, f), qm(c, o, f)));
    }
    function Xm(r, o, c) {
      var f = Kt();
      Ea(r, o, c, f);
    }
    function Ea(r, o, c, f) {
      var g = {
        lane: f,
        revertLane: 0,
        action: c,
        hasEagerState: false,
        eagerState: null,
        next: null
      };
      if (ul(r)) Ym(o, g);
      else {
        var m = r.alternate;
        if (r.lanes === 0 && (m === null || m.lanes === 0) && (m = o.lastRenderedReducer, m !== null)) try {
          var b = o.lastRenderedState, T = m(b, c);
          if (g.hasEagerState = true, g.eagerState = T, Wt(T, b)) return Yo(r, o, g, 0), qe === null && Xo(), false;
        } catch {
        } finally {
        }
        if (c = Uu(r, o, g, f), c !== null) return Zt(c, r, f), qm(c, o, f), true;
      }
      return false;
    }
    function yf(r, o, c, f) {
      if (f = {
        lane: 2,
        revertLane: Zf(),
        action: f,
        hasEagerState: false,
        eagerState: null,
        next: null
      }, ul(r)) {
        if (o) throw Error(i(479));
      } else o = Uu(r, c, f, 2), o !== null && Zt(o, r, 2);
    }
    function ul(r) {
      var o = r.alternate;
      return r === Ee || o !== null && o === Ee;
    }
    function Ym(r, o) {
      nr = sl = true;
      var c = r.pending;
      c === null ? o.next = o : (o.next = c.next, c.next = o), r.pending = o;
    }
    function qm(r, o, c) {
      if ((c & 4194048) !== 0) {
        var f = o.lanes;
        f &= r.pendingLanes, c |= f, o.lanes = c, np(r, c);
      }
    }
    var fl = {
      readContext: wt,
      use: al,
      useCallback: st,
      useContext: st,
      useEffect: st,
      useImperativeHandle: st,
      useLayoutEffect: st,
      useInsertionEffect: st,
      useMemo: st,
      useReducer: st,
      useRef: st,
      useState: st,
      useDebugValue: st,
      useDeferredValue: st,
      useTransition: st,
      useSyncExternalStore: st,
      useId: st,
      useHostTransitionStatus: st,
      useFormState: st,
      useActionState: st,
      useOptimistic: st,
      useMemoCache: st,
      useCacheRefresh: st
    }, Km = {
      readContext: wt,
      use: al,
      useCallback: function(r, o) {
        return Ut().memoizedState = [
          r,
          o === void 0 ? null : o
        ], r;
      },
      useContext: wt,
      useEffect: Nm,
      useImperativeHandle: function(r, o, c) {
        c = c != null ? c.concat([
          r
        ]) : null, cl(4194308, 4, Um.bind(null, o, r), c);
      },
      useLayoutEffect: function(r, o) {
        return cl(4194308, 4, r, o);
      },
      useInsertionEffect: function(r, o) {
        cl(4, 2, r, o);
      },
      useMemo: function(r, o) {
        var c = Ut();
        o = o === void 0 ? null : o;
        var f = r();
        if (us) {
          fi(true);
          try {
            r();
          } finally {
            fi(false);
          }
        }
        return c.memoizedState = [
          f,
          o
        ], f;
      },
      useReducer: function(r, o, c) {
        var f = Ut();
        if (c !== void 0) {
          var g = c(o);
          if (us) {
            fi(true);
            try {
              c(o);
            } finally {
              fi(false);
            }
          }
        } else g = o;
        return f.memoizedState = f.baseState = g, r = {
          pending: null,
          lanes: 0,
          dispatch: null,
          lastRenderedReducer: r,
          lastRenderedState: g
        }, f.queue = r, r = r.dispatch = fx.bind(null, Ee, r), [
          f.memoizedState,
          r
        ];
      },
      useRef: function(r) {
        var o = Ut();
        return r = {
          current: r
        }, o.memoizedState = r;
      },
      useState: function(r) {
        r = hf(r);
        var o = r.queue, c = Xm.bind(null, Ee, o);
        return o.dispatch = c, [
          r.memoizedState,
          c
        ];
      },
      useDebugValue: gf,
      useDeferredValue: function(r, o) {
        var c = Ut();
        return pf(c, r, o);
      },
      useTransition: function() {
        var r = hf(false);
        return r = zm.bind(null, Ee, r.queue, true, false), Ut().memoizedState = r, [
          false,
          r
        ];
      },
      useSyncExternalStore: function(r, o, c) {
        var f = Ee, g = Ut();
        if (De) {
          if (c === void 0) throw Error(i(407));
          c = c();
        } else {
          if (c = o(), qe === null) throw Error(i(349));
          (Ie & 124) !== 0 || mm(f, o, c);
        }
        g.memoizedState = c;
        var m = {
          value: c,
          getSnapshot: o
        };
        return g.queue = m, Nm(ym.bind(null, f, m, r), [
          r
        ]), f.flags |= 2048, sr(9, ll(), _m.bind(null, f, m, c, o), null), c;
      },
      useId: function() {
        var r = Ut(), o = qe.identifierPrefix;
        if (De) {
          var c = Xn, f = $n;
          c = (f & ~(1 << 32 - jt(f) - 1)).toString(32) + c, o = "\xAB" + o + "R" + c, c = rl++, 0 < c && (o += "H" + c.toString(32)), o += "\xBB";
        } else c = rx++, o = "\xAB" + o + "r" + c.toString(32) + "\xBB";
        return r.memoizedState = o;
      },
      useHostTransitionStatus: _f,
      useFormState: Rm,
      useActionState: Rm,
      useOptimistic: function(r) {
        var o = Ut();
        o.memoizedState = o.baseState = r;
        var c = {
          pending: null,
          lanes: 0,
          dispatch: null,
          lastRenderedReducer: null,
          lastRenderedState: null
        };
        return o.queue = c, o = yf.bind(null, Ee, true, c), c.dispatch = o, [
          r,
          o
        ];
      },
      useMemoCache: cf,
      useCacheRefresh: function() {
        return Ut().memoizedState = ux.bind(null, Ee);
      }
    }, Zm = {
      readContext: wt,
      use: al,
      useCallback: Lm,
      useContext: wt,
      useEffect: Pm,
      useImperativeHandle: Bm,
      useInsertionEffect: Dm,
      useLayoutEffect: km,
      useMemo: Fm,
      useReducer: ol,
      useRef: Im,
      useState: function() {
        return ol(Kn);
      },
      useDebugValue: gf,
      useDeferredValue: function(r, o) {
        var c = ot();
        return Vm(c, ze.memoizedState, r, o);
      },
      useTransition: function() {
        var r = ol(Kn)[0], o = ot().memoizedState;
        return [
          typeof r == "boolean" ? r : Aa(r),
          o
        ];
      },
      useSyncExternalStore: pm,
      useId: Wm,
      useHostTransitionStatus: _f,
      useFormState: Cm,
      useActionState: Cm,
      useOptimistic: function(r, o) {
        var c = ot();
        return Tm(c, ze, r, o);
      },
      useMemoCache: cf,
      useCacheRefresh: $m
    }, hx = {
      readContext: wt,
      use: al,
      useCallback: Lm,
      useContext: wt,
      useEffect: Pm,
      useImperativeHandle: Bm,
      useInsertionEffect: Dm,
      useLayoutEffect: km,
      useMemo: Fm,
      useReducer: ff,
      useRef: Im,
      useState: function() {
        return ff(Kn);
      },
      useDebugValue: gf,
      useDeferredValue: function(r, o) {
        var c = ot();
        return ze === null ? pf(c, r, o) : Vm(c, ze.memoizedState, r, o);
      },
      useTransition: function() {
        var r = ff(Kn)[0], o = ot().memoizedState;
        return [
          typeof r == "boolean" ? r : Aa(r),
          o
        ];
      },
      useSyncExternalStore: pm,
      useId: Wm,
      useHostTransitionStatus: _f,
      useFormState: Om,
      useActionState: Om,
      useOptimistic: function(r, o) {
        var c = ot();
        return ze !== null ? Tm(c, ze, r, o) : (c.baseState = r, [
          r,
          c.queue.dispatch
        ]);
      },
      useMemoCache: cf,
      useCacheRefresh: $m
    }, rr = null, Ra = 0;
    function hl(r) {
      var o = Ra;
      return Ra += 1, rr === null && (rr = []), om(rr, r, o);
    }
    function Ca(r, o) {
      o = o.props.ref, r.ref = o !== void 0 ? o : null;
    }
    function dl(r, o) {
      throw o.$$typeof === _ ? Error(i(525)) : (r = Object.prototype.toString.call(o), Error(i(31, r === "[object Object]" ? "object with keys {" + Object.keys(o).join(", ") + "}" : r)));
    }
    function Qm(r) {
      var o = r._init;
      return o(r._payload);
    }
    function Gm(r) {
      function o(D, C) {
        if (r) {
          var V = D.deletions;
          V === null ? (D.deletions = [
            C
          ], D.flags |= 16) : V.push(C);
        }
      }
      function c(D, C) {
        if (!r) return null;
        for (; C !== null; ) o(D, C), C = C.sibling;
        return null;
      }
      function f(D) {
        for (var C = /* @__PURE__ */ new Map(); D !== null; ) D.key !== null ? C.set(D.key, D) : C.set(D.index, D), D = D.sibling;
        return C;
      }
      function g(D, C) {
        return D = Wn(D, C), D.index = 0, D.sibling = null, D;
      }
      function m(D, C, V) {
        return D.index = V, r ? (V = D.alternate, V !== null ? (V = V.index, V < C ? (D.flags |= 67108866, C) : V) : (D.flags |= 67108866, C)) : (D.flags |= 1048576, C);
      }
      function b(D) {
        return r && D.alternate === null && (D.flags |= 67108866), D;
      }
      function T(D, C, V, Y) {
        return C === null || C.tag !== 6 ? (C = Lu(V, D.mode, Y), C.return = D, C) : (C = g(C, V), C.return = D, C);
      }
      function w(D, C, V, Y) {
        var ce = V.type;
        return ce === S ? X(D, C, V.props.children, Y, V.key) : C !== null && (C.elementType === ce || typeof ce == "object" && ce !== null && ce.$$typeof === le && Qm(ce) === C.type) ? (C = g(C, V.props), Ca(C, V), C.return = D, C) : (C = Ko(V.type, V.key, V.props, null, D.mode, Y), Ca(C, V), C.return = D, C);
      }
      function z(D, C, V, Y) {
        return C === null || C.tag !== 4 || C.stateNode.containerInfo !== V.containerInfo || C.stateNode.implementation !== V.implementation ? (C = Fu(V, D.mode, Y), C.return = D, C) : (C = g(C, V.children || []), C.return = D, C);
      }
      function X(D, C, V, Y, ce) {
        return C === null || C.tag !== 7 ? (C = ns(V, D.mode, Y, ce), C.return = D, C) : (C = g(C, V), C.return = D, C);
      }
      function K(D, C, V) {
        if (typeof C == "string" && C !== "" || typeof C == "number" || typeof C == "bigint") return C = Lu("" + C, D.mode, V), C.return = D, C;
        if (typeof C == "object" && C !== null) {
          switch (C.$$typeof) {
            case y:
              return V = Ko(C.type, C.key, C.props, null, D.mode, V), Ca(V, C), V.return = D, V;
            case v:
              return C = Fu(C, D.mode, V), C.return = D, C;
            case le:
              var Y = C._init;
              return C = Y(C._payload), K(D, C, V);
          }
          if (Ue(C) || ye(C)) return C = ns(C, D.mode, V, null), C.return = D, C;
          if (typeof C.then == "function") return K(D, hl(C), V);
          if (C.$$typeof === O) return K(D, Jo(D, C), V);
          dl(D, C);
        }
        return null;
      }
      function j(D, C, V, Y) {
        var ce = C !== null ? C.key : null;
        if (typeof V == "string" && V !== "" || typeof V == "number" || typeof V == "bigint") return ce !== null ? null : T(D, C, "" + V, Y);
        if (typeof V == "object" && V !== null) {
          switch (V.$$typeof) {
            case y:
              return V.key === ce ? w(D, C, V, Y) : null;
            case v:
              return V.key === ce ? z(D, C, V, Y) : null;
            case le:
              return ce = V._init, V = ce(V._payload), j(D, C, V, Y);
          }
          if (Ue(V) || ye(V)) return ce !== null ? null : X(D, C, V, Y, null);
          if (typeof V.then == "function") return j(D, C, hl(V), Y);
          if (V.$$typeof === O) return j(D, C, Jo(D, V), Y);
          dl(D, V);
        }
        return null;
      }
      function W(D, C, V, Y, ce) {
        if (typeof Y == "string" && Y !== "" || typeof Y == "number" || typeof Y == "bigint") return D = D.get(V) || null, T(C, D, "" + Y, ce);
        if (typeof Y == "object" && Y !== null) {
          switch (Y.$$typeof) {
            case y:
              return D = D.get(Y.key === null ? V : Y.key) || null, w(C, D, Y, ce);
            case v:
              return D = D.get(Y.key === null ? V : Y.key) || null, z(C, D, Y, ce);
            case le:
              var Re = Y._init;
              return Y = Re(Y._payload), W(D, C, V, Y, ce);
          }
          if (Ue(Y) || ye(Y)) return D = D.get(V) || null, X(C, D, Y, ce, null);
          if (typeof Y.then == "function") return W(D, C, V, hl(Y), ce);
          if (Y.$$typeof === O) return W(D, C, V, Jo(C, Y), ce);
          dl(C, Y);
        }
        return null;
      }
      function be(D, C, V, Y) {
        for (var ce = null, Re = null, ge = C, me = C = 0, bt = null; ge !== null && me < V.length; me++) {
          ge.index > me ? (bt = ge, ge = null) : bt = ge.sibling;
          var Ne = j(D, ge, V[me], Y);
          if (Ne === null) {
            ge === null && (ge = bt);
            break;
          }
          r && ge && Ne.alternate === null && o(D, ge), C = m(Ne, C, me), Re === null ? ce = Ne : Re.sibling = Ne, Re = Ne, ge = bt;
        }
        if (me === V.length) return c(D, ge), De && ss(D, me), ce;
        if (ge === null) {
          for (; me < V.length; me++) ge = K(D, V[me], Y), ge !== null && (C = m(ge, C, me), Re === null ? ce = ge : Re.sibling = ge, Re = ge);
          return De && ss(D, me), ce;
        }
        for (ge = f(ge); me < V.length; me++) bt = W(ge, D, me, V[me], Y), bt !== null && (r && bt.alternate !== null && ge.delete(bt.key === null ? me : bt.key), C = m(bt, C, me), Re === null ? ce = bt : Re.sibling = bt, Re = bt);
        return r && ge.forEach(function(Di) {
          return o(D, Di);
        }), De && ss(D, me), ce;
      }
      function pe(D, C, V, Y) {
        if (V == null) throw Error(i(151));
        for (var ce = null, Re = null, ge = C, me = C = 0, bt = null, Ne = V.next(); ge !== null && !Ne.done; me++, Ne = V.next()) {
          ge.index > me ? (bt = ge, ge = null) : bt = ge.sibling;
          var Di = j(D, ge, Ne.value, Y);
          if (Di === null) {
            ge === null && (ge = bt);
            break;
          }
          r && ge && Di.alternate === null && o(D, ge), C = m(Di, C, me), Re === null ? ce = Di : Re.sibling = Di, Re = Di, ge = bt;
        }
        if (Ne.done) return c(D, ge), De && ss(D, me), ce;
        if (ge === null) {
          for (; !Ne.done; me++, Ne = V.next()) Ne = K(D, Ne.value, Y), Ne !== null && (C = m(Ne, C, me), Re === null ? ce = Ne : Re.sibling = Ne, Re = Ne);
          return De && ss(D, me), ce;
        }
        for (ge = f(ge); !Ne.done; me++, Ne = V.next()) Ne = W(ge, D, me, Ne.value, Y), Ne !== null && (r && Ne.alternate !== null && ge.delete(Ne.key === null ? me : Ne.key), C = m(Ne, C, me), Re === null ? ce = Ne : Re.sibling = Ne, Re = Ne);
        return r && ge.forEach(function(dS) {
          return o(D, dS);
        }), De && ss(D, me), ce;
      }
      function je(D, C, V, Y) {
        if (typeof V == "object" && V !== null && V.type === S && V.key === null && (V = V.props.children), typeof V == "object" && V !== null) {
          switch (V.$$typeof) {
            case y:
              e: {
                for (var ce = V.key; C !== null; ) {
                  if (C.key === ce) {
                    if (ce = V.type, ce === S) {
                      if (C.tag === 7) {
                        c(D, C.sibling), Y = g(C, V.props.children), Y.return = D, D = Y;
                        break e;
                      }
                    } else if (C.elementType === ce || typeof ce == "object" && ce !== null && ce.$$typeof === le && Qm(ce) === C.type) {
                      c(D, C.sibling), Y = g(C, V.props), Ca(Y, V), Y.return = D, D = Y;
                      break e;
                    }
                    c(D, C);
                    break;
                  } else o(D, C);
                  C = C.sibling;
                }
                V.type === S ? (Y = ns(V.props.children, D.mode, Y, V.key), Y.return = D, D = Y) : (Y = Ko(V.type, V.key, V.props, null, D.mode, Y), Ca(Y, V), Y.return = D, D = Y);
              }
              return b(D);
            case v:
              e: {
                for (ce = V.key; C !== null; ) {
                  if (C.key === ce) if (C.tag === 4 && C.stateNode.containerInfo === V.containerInfo && C.stateNode.implementation === V.implementation) {
                    c(D, C.sibling), Y = g(C, V.children || []), Y.return = D, D = Y;
                    break e;
                  } else {
                    c(D, C);
                    break;
                  }
                  else o(D, C);
                  C = C.sibling;
                }
                Y = Fu(V, D.mode, Y), Y.return = D, D = Y;
              }
              return b(D);
            case le:
              return ce = V._init, V = ce(V._payload), je(D, C, V, Y);
          }
          if (Ue(V)) return be(D, C, V, Y);
          if (ye(V)) {
            if (ce = ye(V), typeof ce != "function") throw Error(i(150));
            return V = ce.call(V), pe(D, C, V, Y);
          }
          if (typeof V.then == "function") return je(D, C, hl(V), Y);
          if (V.$$typeof === O) return je(D, C, Jo(D, V), Y);
          dl(D, V);
        }
        return typeof V == "string" && V !== "" || typeof V == "number" || typeof V == "bigint" ? (V = "" + V, C !== null && C.tag === 6 ? (c(D, C.sibling), Y = g(C, V), Y.return = D, D = Y) : (c(D, C), Y = Lu(V, D.mode, Y), Y.return = D, D = Y), b(D)) : c(D, C);
      }
      return function(D, C, V, Y) {
        try {
          Ra = 0;
          var ce = je(D, C, V, Y);
          return rr = null, ce;
        } catch (ge) {
          if (ge === ya || ge === tl) throw ge;
          var Re = $t(29, ge, null, D.mode);
          return Re.lanes = Y, Re.return = D, Re;
        } finally {
        }
      };
    }
    var ar = Gm(true), Jm = Gm(false), ln = Q(null), Rn = null;
    function bi(r) {
      var o = r.alternate;
      se(ht, ht.current & 1), se(ln, r), Rn === null && (o === null || tr.current !== null || o.memoizedState !== null) && (Rn = r);
    }
    function e_(r) {
      if (r.tag === 22) {
        if (se(ht, ht.current), se(ln, r), Rn === null) {
          var o = r.alternate;
          o !== null && o.memoizedState !== null && (Rn = r);
        }
      } else vi();
    }
    function vi() {
      se(ht, ht.current), se(ln, ln.current);
    }
    function Zn(r) {
      oe(ln), Rn === r && (Rn = null), oe(ht);
    }
    var ht = Q(0);
    function gl(r) {
      for (var o = r; o !== null; ) {
        if (o.tag === 13) {
          var c = o.memoizedState;
          if (c !== null && (c = c.dehydrated, c === null || c.data === "$?" || lh(c))) return o;
        } else if (o.tag === 19 && o.memoizedProps.revealOrder !== void 0) {
          if ((o.flags & 128) !== 0) return o;
        } else if (o.child !== null) {
          o.child.return = o, o = o.child;
          continue;
        }
        if (o === r) break;
        for (; o.sibling === null; ) {
          if (o.return === null || o.return === r) return null;
          o = o.return;
        }
        o.sibling.return = o.return, o = o.sibling;
      }
      return null;
    }
    function bf(r, o, c, f) {
      o = r.memoizedState, c = c(f, o), c = c == null ? o : p({}, o, c), r.memoizedState = c, r.lanes === 0 && (r.updateQueue.baseState = c);
    }
    var vf = {
      enqueueSetState: function(r, o, c) {
        r = r._reactInternals;
        var f = Kt(), g = mi(f);
        g.payload = o, c != null && (g.callback = c), o = _i(r, g, f), o !== null && (Zt(o, r, f), va(o, r, f));
      },
      enqueueReplaceState: function(r, o, c) {
        r = r._reactInternals;
        var f = Kt(), g = mi(f);
        g.tag = 1, g.payload = o, c != null && (g.callback = c), o = _i(r, g, f), o !== null && (Zt(o, r, f), va(o, r, f));
      },
      enqueueForceUpdate: function(r, o) {
        r = r._reactInternals;
        var c = Kt(), f = mi(c);
        f.tag = 2, o != null && (f.callback = o), o = _i(r, f, c), o !== null && (Zt(o, r, c), va(o, r, c));
      }
    };
    function t_(r, o, c, f, g, m, b) {
      return r = r.stateNode, typeof r.shouldComponentUpdate == "function" ? r.shouldComponentUpdate(f, m, b) : o.prototype && o.prototype.isPureReactComponent ? !ua(c, f) || !ua(g, m) : true;
    }
    function n_(r, o, c, f) {
      r = o.state, typeof o.componentWillReceiveProps == "function" && o.componentWillReceiveProps(c, f), typeof o.UNSAFE_componentWillReceiveProps == "function" && o.UNSAFE_componentWillReceiveProps(c, f), o.state !== r && vf.enqueueReplaceState(o, o.state, null);
    }
    function fs(r, o) {
      var c = o;
      if ("ref" in o) {
        c = {};
        for (var f in o) f !== "ref" && (c[f] = o[f]);
      }
      if (r = r.defaultProps) {
        c === o && (c = p({}, c));
        for (var g in r) c[g] === void 0 && (c[g] = r[g]);
      }
      return c;
    }
    var pl = typeof reportError == "function" ? reportError : function(r) {
      if (typeof window == "object" && typeof window.ErrorEvent == "function") {
        var o = new window.ErrorEvent("error", {
          bubbles: true,
          cancelable: true,
          message: typeof r == "object" && r !== null && typeof r.message == "string" ? String(r.message) : String(r),
          error: r
        });
        if (!window.dispatchEvent(o)) return;
      } else if (typeof process == "object" && typeof process.emit == "function") {
        process.emit("uncaughtException", r);
        return;
      }
      console.error(r);
    };
    function i_(r) {
      pl(r);
    }
    function s_(r) {
      console.error(r);
    }
    function r_(r) {
      pl(r);
    }
    function ml(r, o) {
      try {
        var c = r.onUncaughtError;
        c(o.value, {
          componentStack: o.stack
        });
      } catch (f) {
        setTimeout(function() {
          throw f;
        });
      }
    }
    function a_(r, o, c) {
      try {
        var f = r.onCaughtError;
        f(c.value, {
          componentStack: c.stack,
          errorBoundary: o.tag === 1 ? o.stateNode : null
        });
      } catch (g) {
        setTimeout(function() {
          throw g;
        });
      }
    }
    function Tf(r, o, c) {
      return c = mi(c), c.tag = 3, c.payload = {
        element: null
      }, c.callback = function() {
        ml(r, o);
      }, c;
    }
    function o_(r) {
      return r = mi(r), r.tag = 3, r;
    }
    function l_(r, o, c, f) {
      var g = c.type.getDerivedStateFromError;
      if (typeof g == "function") {
        var m = f.value;
        r.payload = function() {
          return g(m);
        }, r.callback = function() {
          a_(o, c, f);
        };
      }
      var b = c.stateNode;
      b !== null && typeof b.componentDidCatch == "function" && (r.callback = function() {
        a_(o, c, f), typeof g != "function" && (Ei === null ? Ei = /* @__PURE__ */ new Set([
          this
        ]) : Ei.add(this));
        var T = f.stack;
        this.componentDidCatch(f.value, {
          componentStack: T !== null ? T : ""
        });
      });
    }
    function dx(r, o, c, f, g) {
      if (c.flags |= 32768, f !== null && typeof f == "object" && typeof f.then == "function") {
        if (o = c.alternate, o !== null && pa(o, c, g, true), c = ln.current, c !== null) {
          switch (c.tag) {
            case 13:
              return Rn === null ? $f() : c.alternate === null && tt === 0 && (tt = 3), c.flags &= -257, c.flags |= 65536, c.lanes = g, f === Ku ? c.flags |= 16384 : (o = c.updateQueue, o === null ? c.updateQueue = /* @__PURE__ */ new Set([
                f
              ]) : o.add(f), Yf(r, f, g)), false;
            case 22:
              return c.flags |= 65536, f === Ku ? c.flags |= 16384 : (o = c.updateQueue, o === null ? (o = {
                transitions: null,
                markerInstances: null,
                retryQueue: /* @__PURE__ */ new Set([
                  f
                ])
              }, c.updateQueue = o) : (c = o.retryQueue, c === null ? o.retryQueue = /* @__PURE__ */ new Set([
                f
              ]) : c.add(f)), Yf(r, f, g)), false;
          }
          throw Error(i(435, c.tag));
        }
        return Yf(r, f, g), $f(), false;
      }
      if (De) return o = ln.current, o !== null ? ((o.flags & 65536) === 0 && (o.flags |= 256), o.flags |= 65536, o.lanes = g, f !== Hu && (r = Error(i(422), {
        cause: f
      }), ga(sn(r, c)))) : (f !== Hu && (o = Error(i(423), {
        cause: f
      }), ga(sn(o, c))), r = r.current.alternate, r.flags |= 65536, g &= -g, r.lanes |= g, f = sn(f, c), g = Tf(r.stateNode, f, g), Gu(r, g), tt !== 4 && (tt = 2)), false;
      var m = Error(i(520), {
        cause: f
      });
      if (m = sn(m, c), ka === null ? ka = [
        m
      ] : ka.push(m), tt !== 4 && (tt = 2), o === null) return true;
      f = sn(f, c), c = o;
      do {
        switch (c.tag) {
          case 3:
            return c.flags |= 65536, r = g & -g, c.lanes |= r, r = Tf(c.stateNode, f, r), Gu(c, r), false;
          case 1:
            if (o = c.type, m = c.stateNode, (c.flags & 128) === 0 && (typeof o.getDerivedStateFromError == "function" || m !== null && typeof m.componentDidCatch == "function" && (Ei === null || !Ei.has(m)))) return c.flags |= 65536, g &= -g, c.lanes |= g, g = o_(g), l_(g, r, c, f), Gu(c, g), false;
        }
        c = c.return;
      } while (c !== null);
      return false;
    }
    var c_ = Error(i(461)), _t = false;
    function Tt(r, o, c, f) {
      o.child = r === null ? Jm(o, null, c, f) : ar(o, r.child, c, f);
    }
    function u_(r, o, c, f, g) {
      c = c.render;
      var m = o.ref;
      if ("ref" in f) {
        var b = {};
        for (var T in f) T !== "ref" && (b[T] = f[T]);
      } else b = f;
      return ls(o), f = sf(r, o, c, b, m, g), T = rf(), r !== null && !_t ? (af(r, o, g), Qn(r, o, g)) : (De && T && Vu(o), o.flags |= 1, Tt(r, o, f, g), o.child);
    }
    function f_(r, o, c, f, g) {
      if (r === null) {
        var m = c.type;
        return typeof m == "function" && !Bu(m) && m.defaultProps === void 0 && c.compare === null ? (o.tag = 15, o.type = m, h_(r, o, m, f, g)) : (r = Ko(c.type, null, f, o, o.mode, g), r.ref = o.ref, r.return = o, o.child = r);
      }
      if (m = r.child, !Mf(r, g)) {
        var b = m.memoizedProps;
        if (c = c.compare, c = c !== null ? c : ua, c(b, f) && r.ref === o.ref) return Qn(r, o, g);
      }
      return o.flags |= 1, r = Wn(m, f), r.ref = o.ref, r.return = o, o.child = r;
    }
    function h_(r, o, c, f, g) {
      if (r !== null) {
        var m = r.memoizedProps;
        if (ua(m, f) && r.ref === o.ref) if (_t = false, o.pendingProps = f = m, Mf(r, g)) (r.flags & 131072) !== 0 && (_t = true);
        else return o.lanes = r.lanes, Qn(r, o, g);
      }
      return xf(r, o, c, f, g);
    }
    function d_(r, o, c) {
      var f = o.pendingProps, g = f.children, m = r !== null ? r.memoizedState : null;
      if (f.mode === "hidden") {
        if ((o.flags & 128) !== 0) {
          if (f = m !== null ? m.baseLanes | c : c, r !== null) {
            for (g = o.child = r.child, m = 0; g !== null; ) m = m | g.lanes | g.childLanes, g = g.sibling;
            o.childLanes = m & ~f;
          } else o.childLanes = 0, o.child = null;
          return g_(r, o, f, c);
        }
        if ((c & 536870912) !== 0) o.memoizedState = {
          baseLanes: 0,
          cachePool: null
        }, r !== null && el(o, m !== null ? m.cachePool : null), m !== null ? hm(o, m) : ef(), e_(o);
        else return o.lanes = o.childLanes = 536870912, g_(r, o, m !== null ? m.baseLanes | c : c, c);
      } else m !== null ? (el(o, m.cachePool), hm(o, m), vi(), o.memoizedState = null) : (r !== null && el(o, null), ef(), vi());
      return Tt(r, o, g, c), o.child;
    }
    function g_(r, o, c, f) {
      var g = qu();
      return g = g === null ? null : {
        parent: ft._currentValue,
        pool: g
      }, o.memoizedState = {
        baseLanes: c,
        cachePool: g
      }, r !== null && el(o, null), ef(), e_(o), r !== null && pa(r, o, f, true), null;
    }
    function _l(r, o) {
      var c = o.ref;
      if (c === null) r !== null && r.ref !== null && (o.flags |= 4194816);
      else {
        if (typeof c != "function" && typeof c != "object") throw Error(i(284));
        (r === null || r.ref !== c) && (o.flags |= 4194816);
      }
    }
    function xf(r, o, c, f, g) {
      return ls(o), c = sf(r, o, c, f, void 0, g), f = rf(), r !== null && !_t ? (af(r, o, g), Qn(r, o, g)) : (De && f && Vu(o), o.flags |= 1, Tt(r, o, c, g), o.child);
    }
    function p_(r, o, c, f, g, m) {
      return ls(o), o.updateQueue = null, c = gm(o, f, c, g), dm(r), f = rf(), r !== null && !_t ? (af(r, o, m), Qn(r, o, m)) : (De && f && Vu(o), o.flags |= 1, Tt(r, o, c, m), o.child);
    }
    function m_(r, o, c, f, g) {
      if (ls(o), o.stateNode === null) {
        var m = Zs, b = c.contextType;
        typeof b == "object" && b !== null && (m = wt(b)), m = new c(f, m), o.memoizedState = m.state !== null && m.state !== void 0 ? m.state : null, m.updater = vf, o.stateNode = m, m._reactInternals = o, m = o.stateNode, m.props = f, m.state = o.memoizedState, m.refs = {}, Zu(o), b = c.contextType, m.context = typeof b == "object" && b !== null ? wt(b) : Zs, m.state = o.memoizedState, b = c.getDerivedStateFromProps, typeof b == "function" && (bf(o, c, b, f), m.state = o.memoizedState), typeof c.getDerivedStateFromProps == "function" || typeof m.getSnapshotBeforeUpdate == "function" || typeof m.UNSAFE_componentWillMount != "function" && typeof m.componentWillMount != "function" || (b = m.state, typeof m.componentWillMount == "function" && m.componentWillMount(), typeof m.UNSAFE_componentWillMount == "function" && m.UNSAFE_componentWillMount(), b !== m.state && vf.enqueueReplaceState(m, m.state, null), xa(o, f, m, g), Ta(), m.state = o.memoizedState), typeof m.componentDidMount == "function" && (o.flags |= 4194308), f = true;
      } else if (r === null) {
        m = o.stateNode;
        var T = o.memoizedProps, w = fs(c, T);
        m.props = w;
        var z = m.context, X = c.contextType;
        b = Zs, typeof X == "object" && X !== null && (b = wt(X));
        var K = c.getDerivedStateFromProps;
        X = typeof K == "function" || typeof m.getSnapshotBeforeUpdate == "function", T = o.pendingProps !== T, X || typeof m.UNSAFE_componentWillReceiveProps != "function" && typeof m.componentWillReceiveProps != "function" || (T || z !== b) && n_(o, m, f, b), pi = false;
        var j = o.memoizedState;
        m.state = j, xa(o, f, m, g), Ta(), z = o.memoizedState, T || j !== z || pi ? (typeof K == "function" && (bf(o, c, K, f), z = o.memoizedState), (w = pi || t_(o, c, w, f, j, z, b)) ? (X || typeof m.UNSAFE_componentWillMount != "function" && typeof m.componentWillMount != "function" || (typeof m.componentWillMount == "function" && m.componentWillMount(), typeof m.UNSAFE_componentWillMount == "function" && m.UNSAFE_componentWillMount()), typeof m.componentDidMount == "function" && (o.flags |= 4194308)) : (typeof m.componentDidMount == "function" && (o.flags |= 4194308), o.memoizedProps = f, o.memoizedState = z), m.props = f, m.state = z, m.context = b, f = w) : (typeof m.componentDidMount == "function" && (o.flags |= 4194308), f = false);
      } else {
        m = o.stateNode, Qu(r, o), b = o.memoizedProps, X = fs(c, b), m.props = X, K = o.pendingProps, j = m.context, z = c.contextType, w = Zs, typeof z == "object" && z !== null && (w = wt(z)), T = c.getDerivedStateFromProps, (z = typeof T == "function" || typeof m.getSnapshotBeforeUpdate == "function") || typeof m.UNSAFE_componentWillReceiveProps != "function" && typeof m.componentWillReceiveProps != "function" || (b !== K || j !== w) && n_(o, m, f, w), pi = false, j = o.memoizedState, m.state = j, xa(o, f, m, g), Ta();
        var W = o.memoizedState;
        b !== K || j !== W || pi || r !== null && r.dependencies !== null && Go(r.dependencies) ? (typeof T == "function" && (bf(o, c, T, f), W = o.memoizedState), (X = pi || t_(o, c, X, f, j, W, w) || r !== null && r.dependencies !== null && Go(r.dependencies)) ? (z || typeof m.UNSAFE_componentWillUpdate != "function" && typeof m.componentWillUpdate != "function" || (typeof m.componentWillUpdate == "function" && m.componentWillUpdate(f, W, w), typeof m.UNSAFE_componentWillUpdate == "function" && m.UNSAFE_componentWillUpdate(f, W, w)), typeof m.componentDidUpdate == "function" && (o.flags |= 4), typeof m.getSnapshotBeforeUpdate == "function" && (o.flags |= 1024)) : (typeof m.componentDidUpdate != "function" || b === r.memoizedProps && j === r.memoizedState || (o.flags |= 4), typeof m.getSnapshotBeforeUpdate != "function" || b === r.memoizedProps && j === r.memoizedState || (o.flags |= 1024), o.memoizedProps = f, o.memoizedState = W), m.props = f, m.state = W, m.context = w, f = X) : (typeof m.componentDidUpdate != "function" || b === r.memoizedProps && j === r.memoizedState || (o.flags |= 4), typeof m.getSnapshotBeforeUpdate != "function" || b === r.memoizedProps && j === r.memoizedState || (o.flags |= 1024), f = false);
      }
      return m = f, _l(r, o), f = (o.flags & 128) !== 0, m || f ? (m = o.stateNode, c = f && typeof c.getDerivedStateFromError != "function" ? null : m.render(), o.flags |= 1, r !== null && f ? (o.child = ar(o, r.child, null, g), o.child = ar(o, null, c, g)) : Tt(r, o, c, g), o.memoizedState = m.state, r = o.child) : r = Qn(r, o, g), r;
    }
    function __(r, o, c, f) {
      return da(), o.flags |= 256, Tt(r, o, c, f), o.child;
    }
    var Sf = {
      dehydrated: null,
      treeContext: null,
      retryLane: 0,
      hydrationErrors: null
    };
    function Af(r) {
      return {
        baseLanes: r,
        cachePool: sm()
      };
    }
    function wf(r, o, c) {
      return r = r !== null ? r.childLanes & ~c : 0, o && (r |= cn), r;
    }
    function y_(r, o, c) {
      var f = o.pendingProps, g = false, m = (o.flags & 128) !== 0, b;
      if ((b = m) || (b = r !== null && r.memoizedState === null ? false : (ht.current & 2) !== 0), b && (g = true, o.flags &= -129), b = (o.flags & 32) !== 0, o.flags &= -33, r === null) {
        if (De) {
          if (g ? bi(o) : vi(), De) {
            var T = et, w;
            if (w = T) {
              e: {
                for (w = T, T = En; w.nodeType !== 8; ) {
                  if (!T) {
                    T = null;
                    break e;
                  }
                  if (w = vn(w.nextSibling), w === null) {
                    T = null;
                    break e;
                  }
                }
                T = w;
              }
              T !== null ? (o.memoizedState = {
                dehydrated: T,
                treeContext: is !== null ? {
                  id: $n,
                  overflow: Xn
                } : null,
                retryLane: 536870912,
                hydrationErrors: null
              }, w = $t(18, null, null, 0), w.stateNode = T, w.return = o, o.child = w, Nt = o, et = null, w = true) : w = false;
            }
            w || as(o);
          }
          if (T = o.memoizedState, T !== null && (T = T.dehydrated, T !== null)) return lh(T) ? o.lanes = 32 : o.lanes = 536870912, null;
          Zn(o);
        }
        return T = f.children, f = f.fallback, g ? (vi(), g = o.mode, T = yl({
          mode: "hidden",
          children: T
        }, g), f = ns(f, g, c, null), T.return = o, f.return = o, T.sibling = f, o.child = T, g = o.child, g.memoizedState = Af(c), g.childLanes = wf(r, b, c), o.memoizedState = Sf, f) : (bi(o), Ef(o, T));
      }
      if (w = r.memoizedState, w !== null && (T = w.dehydrated, T !== null)) {
        if (m) o.flags & 256 ? (bi(o), o.flags &= -257, o = Rf(r, o, c)) : o.memoizedState !== null ? (vi(), o.child = r.child, o.flags |= 128, o = null) : (vi(), g = f.fallback, T = o.mode, f = yl({
          mode: "visible",
          children: f.children
        }, T), g = ns(g, T, c, null), g.flags |= 2, f.return = o, g.return = o, f.sibling = g, o.child = f, ar(o, r.child, null, c), f = o.child, f.memoizedState = Af(c), f.childLanes = wf(r, b, c), o.memoizedState = Sf, o = g);
        else if (bi(o), lh(T)) {
          if (b = T.nextSibling && T.nextSibling.dataset, b) var z = b.dgst;
          b = z, f = Error(i(419)), f.stack = "", f.digest = b, ga({
            value: f,
            source: null,
            stack: null
          }), o = Rf(r, o, c);
        } else if (_t || pa(r, o, c, false), b = (c & r.childLanes) !== 0, _t || b) {
          if (b = qe, b !== null && (f = c & -c, f = (f & 42) !== 0 ? 1 : lu(f), f = (f & (b.suspendedLanes | c)) !== 0 ? 0 : f, f !== 0 && f !== w.retryLane)) throw w.retryLane = f, Ks(r, f), Zt(b, r, f), c_;
          T.data === "$?" || $f(), o = Rf(r, o, c);
        } else T.data === "$?" ? (o.flags |= 192, o.child = r.child, o = null) : (r = w.treeContext, et = vn(T.nextSibling), Nt = o, De = true, rs = null, En = false, r !== null && (an[on++] = $n, an[on++] = Xn, an[on++] = is, $n = r.id, Xn = r.overflow, is = o), o = Ef(o, f.children), o.flags |= 4096);
        return o;
      }
      return g ? (vi(), g = f.fallback, T = o.mode, w = r.child, z = w.sibling, f = Wn(w, {
        mode: "hidden",
        children: f.children
      }), f.subtreeFlags = w.subtreeFlags & 65011712, z !== null ? g = Wn(z, g) : (g = ns(g, T, c, null), g.flags |= 2), g.return = o, f.return = o, f.sibling = g, o.child = f, f = g, g = o.child, T = r.child.memoizedState, T === null ? T = Af(c) : (w = T.cachePool, w !== null ? (z = ft._currentValue, w = w.parent !== z ? {
        parent: z,
        pool: z
      } : w) : w = sm(), T = {
        baseLanes: T.baseLanes | c,
        cachePool: w
      }), g.memoizedState = T, g.childLanes = wf(r, b, c), o.memoizedState = Sf, f) : (bi(o), c = r.child, r = c.sibling, c = Wn(c, {
        mode: "visible",
        children: f.children
      }), c.return = o, c.sibling = null, r !== null && (b = o.deletions, b === null ? (o.deletions = [
        r
      ], o.flags |= 16) : b.push(r)), o.child = c, o.memoizedState = null, c);
    }
    function Ef(r, o) {
      return o = yl({
        mode: "visible",
        children: o
      }, r.mode), o.return = r, r.child = o;
    }
    function yl(r, o) {
      return r = $t(22, r, null, o), r.lanes = 0, r.stateNode = {
        _visibility: 1,
        _pendingMarkers: null,
        _retryCache: null,
        _transitions: null
      }, r;
    }
    function Rf(r, o, c) {
      return ar(o, r.child, null, c), r = Ef(o, o.pendingProps.children), r.flags |= 2, o.memoizedState = null, r;
    }
    function b_(r, o, c) {
      r.lanes |= o;
      var f = r.alternate;
      f !== null && (f.lanes |= o), Wu(r.return, o, c);
    }
    function Cf(r, o, c, f, g) {
      var m = r.memoizedState;
      m === null ? r.memoizedState = {
        isBackwards: o,
        rendering: null,
        renderingStartTime: 0,
        last: f,
        tail: c,
        tailMode: g
      } : (m.isBackwards = o, m.rendering = null, m.renderingStartTime = 0, m.last = f, m.tail = c, m.tailMode = g);
    }
    function v_(r, o, c) {
      var f = o.pendingProps, g = f.revealOrder, m = f.tail;
      if (Tt(r, o, f.children, c), f = ht.current, (f & 2) !== 0) f = f & 1 | 2, o.flags |= 128;
      else {
        if (r !== null && (r.flags & 128) !== 0) e: for (r = o.child; r !== null; ) {
          if (r.tag === 13) r.memoizedState !== null && b_(r, c, o);
          else if (r.tag === 19) b_(r, c, o);
          else if (r.child !== null) {
            r.child.return = r, r = r.child;
            continue;
          }
          if (r === o) break e;
          for (; r.sibling === null; ) {
            if (r.return === null || r.return === o) break e;
            r = r.return;
          }
          r.sibling.return = r.return, r = r.sibling;
        }
        f &= 1;
      }
      switch (se(ht, f), g) {
        case "forwards":
          for (c = o.child, g = null; c !== null; ) r = c.alternate, r !== null && gl(r) === null && (g = c), c = c.sibling;
          c = g, c === null ? (g = o.child, o.child = null) : (g = c.sibling, c.sibling = null), Cf(o, false, g, c, m);
          break;
        case "backwards":
          for (c = null, g = o.child, o.child = null; g !== null; ) {
            if (r = g.alternate, r !== null && gl(r) === null) {
              o.child = g;
              break;
            }
            r = g.sibling, g.sibling = c, c = g, g = r;
          }
          Cf(o, true, c, null, m);
          break;
        case "together":
          Cf(o, false, null, null, void 0);
          break;
        default:
          o.memoizedState = null;
      }
      return o.child;
    }
    function Qn(r, o, c) {
      if (r !== null && (o.dependencies = r.dependencies), wi |= o.lanes, (c & o.childLanes) === 0) if (r !== null) {
        if (pa(r, o, c, false), (c & o.childLanes) === 0) return null;
      } else return null;
      if (r !== null && o.child !== r.child) throw Error(i(153));
      if (o.child !== null) {
        for (r = o.child, c = Wn(r, r.pendingProps), o.child = c, c.return = o; r.sibling !== null; ) r = r.sibling, c = c.sibling = Wn(r, r.pendingProps), c.return = o;
        c.sibling = null;
      }
      return o.child;
    }
    function Mf(r, o) {
      return (r.lanes & o) !== 0 ? true : (r = r.dependencies, !!(r !== null && Go(r)));
    }
    function gx(r, o, c) {
      switch (o.tag) {
        case 3:
          Pe(o, o.stateNode.containerInfo), gi(o, ft, r.memoizedState.cache), da();
          break;
        case 27:
        case 5:
          ui(o);
          break;
        case 4:
          Pe(o, o.stateNode.containerInfo);
          break;
        case 10:
          gi(o, o.type, o.memoizedProps.value);
          break;
        case 13:
          var f = o.memoizedState;
          if (f !== null) return f.dehydrated !== null ? (bi(o), o.flags |= 128, null) : (c & o.child.childLanes) !== 0 ? y_(r, o, c) : (bi(o), r = Qn(r, o, c), r !== null ? r.sibling : null);
          bi(o);
          break;
        case 19:
          var g = (r.flags & 128) !== 0;
          if (f = (c & o.childLanes) !== 0, f || (pa(r, o, c, false), f = (c & o.childLanes) !== 0), g) {
            if (f) return v_(r, o, c);
            o.flags |= 128;
          }
          if (g = o.memoizedState, g !== null && (g.rendering = null, g.tail = null, g.lastEffect = null), se(ht, ht.current), f) break;
          return null;
        case 22:
        case 23:
          return o.lanes = 0, d_(r, o, c);
        case 24:
          gi(o, ft, r.memoizedState.cache);
      }
      return Qn(r, o, c);
    }
    function T_(r, o, c) {
      if (r !== null) if (r.memoizedProps !== o.pendingProps) _t = true;
      else {
        if (!Mf(r, c) && (o.flags & 128) === 0) return _t = false, gx(r, o, c);
        _t = (r.flags & 131072) !== 0;
      }
      else _t = false, De && (o.flags & 1048576) !== 0 && Qp(o, Qo, o.index);
      switch (o.lanes = 0, o.tag) {
        case 16:
          e: {
            r = o.pendingProps;
            var f = o.elementType, g = f._init;
            if (f = g(f._payload), o.type = f, typeof f == "function") Bu(f) ? (r = fs(f, r), o.tag = 1, o = m_(null, o, f, r, c)) : (o.tag = 0, o = xf(null, o, f, r, c));
            else {
              if (f != null) {
                if (g = f.$$typeof, g === U) {
                  o.tag = 11, o = u_(null, o, f, r, c);
                  break e;
                } else if (g === re) {
                  o.tag = 14, o = f_(null, o, f, r, c);
                  break e;
                }
              }
              throw o = ve(f) || f, Error(i(306, o, ""));
            }
          }
          return o;
        case 0:
          return xf(r, o, o.type, o.pendingProps, c);
        case 1:
          return f = o.type, g = fs(f, o.pendingProps), m_(r, o, f, g, c);
        case 3:
          e: {
            if (Pe(o, o.stateNode.containerInfo), r === null) throw Error(i(387));
            f = o.pendingProps;
            var m = o.memoizedState;
            g = m.element, Qu(r, o), xa(o, f, null, c);
            var b = o.memoizedState;
            if (f = b.cache, gi(o, ft, f), f !== m.cache && $u(o, [
              ft
            ], c, true), Ta(), f = b.element, m.isDehydrated) if (m = {
              element: f,
              isDehydrated: false,
              cache: b.cache
            }, o.updateQueue.baseState = m, o.memoizedState = m, o.flags & 256) {
              o = __(r, o, f, c);
              break e;
            } else if (f !== g) {
              g = sn(Error(i(424)), o), ga(g), o = __(r, o, f, c);
              break e;
            } else {
              switch (r = o.stateNode.containerInfo, r.nodeType) {
                case 9:
                  r = r.body;
                  break;
                default:
                  r = r.nodeName === "HTML" ? r.ownerDocument.body : r;
              }
              for (et = vn(r.firstChild), Nt = o, De = true, rs = null, En = true, c = Jm(o, null, f, c), o.child = c; c; ) c.flags = c.flags & -3 | 4096, c = c.sibling;
            }
            else {
              if (da(), f === g) {
                o = Qn(r, o, c);
                break e;
              }
              Tt(r, o, f, c);
            }
            o = o.child;
          }
          return o;
        case 26:
          return _l(r, o), r === null ? (c = wy(o.type, null, o.pendingProps, null)) ? o.memoizedState = c : De || (c = o.type, r = o.pendingProps, f = Nl(ue.current).createElement(c), f[At] = o, f[Dt] = r, St(f, c, r), mt(f), o.stateNode = f) : o.memoizedState = wy(o.type, r.memoizedProps, o.pendingProps, r.memoizedState), null;
        case 27:
          return ui(o), r === null && De && (f = o.stateNode = xy(o.type, o.pendingProps, ue.current), Nt = o, En = true, g = et, Mi(o.type) ? (ch = g, et = vn(f.firstChild)) : et = g), Tt(r, o, o.pendingProps.children, c), _l(r, o), r === null && (o.flags |= 4194304), o.child;
        case 5:
          return r === null && De && ((g = f = et) && (f = Hx(f, o.type, o.pendingProps, En), f !== null ? (o.stateNode = f, Nt = o, et = vn(f.firstChild), En = false, g = true) : g = false), g || as(o)), ui(o), g = o.type, m = o.pendingProps, b = r !== null ? r.memoizedProps : null, f = m.children, rh(g, m) ? f = null : b !== null && rh(g, b) && (o.flags |= 32), o.memoizedState !== null && (g = sf(r, o, ax, null, null, c), Wa._currentValue = g), _l(r, o), Tt(r, o, f, c), o.child;
        case 6:
          return r === null && De && ((r = c = et) && (c = jx(c, o.pendingProps, En), c !== null ? (o.stateNode = c, Nt = o, et = null, r = true) : r = false), r || as(o)), null;
        case 13:
          return y_(r, o, c);
        case 4:
          return Pe(o, o.stateNode.containerInfo), f = o.pendingProps, r === null ? o.child = ar(o, null, f, c) : Tt(r, o, f, c), o.child;
        case 11:
          return u_(r, o, o.type, o.pendingProps, c);
        case 7:
          return Tt(r, o, o.pendingProps, c), o.child;
        case 8:
          return Tt(r, o, o.pendingProps.children, c), o.child;
        case 12:
          return Tt(r, o, o.pendingProps.children, c), o.child;
        case 10:
          return f = o.pendingProps, gi(o, o.type, f.value), Tt(r, o, f.children, c), o.child;
        case 9:
          return g = o.type._context, f = o.pendingProps.children, ls(o), g = wt(g), f = f(g), o.flags |= 1, Tt(r, o, f, c), o.child;
        case 14:
          return f_(r, o, o.type, o.pendingProps, c);
        case 15:
          return h_(r, o, o.type, o.pendingProps, c);
        case 19:
          return v_(r, o, c);
        case 31:
          return f = o.pendingProps, c = o.mode, f = {
            mode: f.mode,
            children: f.children
          }, r === null ? (c = yl(f, c), c.ref = o.ref, o.child = c, c.return = o, o = c) : (c = Wn(r.child, f), c.ref = o.ref, o.child = c, c.return = o, o = c), o;
        case 22:
          return d_(r, o, c);
        case 24:
          return ls(o), f = wt(ft), r === null ? (g = qu(), g === null && (g = qe, m = Xu(), g.pooledCache = m, m.refCount++, m !== null && (g.pooledCacheLanes |= c), g = m), o.memoizedState = {
            parent: f,
            cache: g
          }, Zu(o), gi(o, ft, g)) : ((r.lanes & c) !== 0 && (Qu(r, o), xa(o, null, null, c), Ta()), g = r.memoizedState, m = o.memoizedState, g.parent !== f ? (g = {
            parent: f,
            cache: f
          }, o.memoizedState = g, o.lanes === 0 && (o.memoizedState = o.updateQueue.baseState = g), gi(o, ft, f)) : (f = m.cache, gi(o, ft, f), f !== g.cache && $u(o, [
            ft
          ], c, true))), Tt(r, o, o.pendingProps.children, c), o.child;
        case 29:
          throw o.pendingProps;
      }
      throw Error(i(156, o.tag));
    }
    function Gn(r) {
      r.flags |= 4;
    }
    function x_(r, o) {
      if (o.type !== "stylesheet" || (o.state.loading & 4) !== 0) r.flags &= -16777217;
      else if (r.flags |= 16777216, !Oy(o)) {
        if (o = ln.current, o !== null && ((Ie & 4194048) === Ie ? Rn !== null : (Ie & 62914560) !== Ie && (Ie & 536870912) === 0 || o !== Rn)) throw ba = Ku, rm;
        r.flags |= 8192;
      }
    }
    function bl(r, o) {
      o !== null && (r.flags |= 4), r.flags & 16384 && (o = r.tag !== 22 ? ep() : 536870912, r.lanes |= o, ur |= o);
    }
    function Ma(r, o) {
      if (!De) switch (r.tailMode) {
        case "hidden":
          o = r.tail;
          for (var c = null; o !== null; ) o.alternate !== null && (c = o), o = o.sibling;
          c === null ? r.tail = null : c.sibling = null;
          break;
        case "collapsed":
          c = r.tail;
          for (var f = null; c !== null; ) c.alternate !== null && (f = c), c = c.sibling;
          f === null ? o || r.tail === null ? r.tail = null : r.tail.sibling = null : f.sibling = null;
      }
    }
    function Je(r) {
      var o = r.alternate !== null && r.alternate.child === r.child, c = 0, f = 0;
      if (o) for (var g = r.child; g !== null; ) c |= g.lanes | g.childLanes, f |= g.subtreeFlags & 65011712, f |= g.flags & 65011712, g.return = r, g = g.sibling;
      else for (g = r.child; g !== null; ) c |= g.lanes | g.childLanes, f |= g.subtreeFlags, f |= g.flags, g.return = r, g = g.sibling;
      return r.subtreeFlags |= f, r.childLanes = c, o;
    }
    function px(r, o, c) {
      var f = o.pendingProps;
      switch (zu(o), o.tag) {
        case 31:
        case 16:
        case 15:
        case 0:
        case 11:
        case 7:
        case 8:
        case 12:
        case 9:
        case 14:
          return Je(o), null;
        case 1:
          return Je(o), null;
        case 3:
          return c = o.stateNode, f = null, r !== null && (f = r.memoizedState.cache), o.memoizedState.cache !== f && (o.flags |= 2048), qn(ft), pt(), c.pendingContext && (c.context = c.pendingContext, c.pendingContext = null), (r === null || r.child === null) && (ha(o) ? Gn(o) : r === null || r.memoizedState.isDehydrated && (o.flags & 256) === 0 || (o.flags |= 1024, em())), Je(o), null;
        case 26:
          return c = o.memoizedState, r === null ? (Gn(o), c !== null ? (Je(o), x_(o, c)) : (Je(o), o.flags &= -16777217)) : c ? c !== r.memoizedState ? (Gn(o), Je(o), x_(o, c)) : (Je(o), o.flags &= -16777217) : (r.memoizedProps !== f && Gn(o), Je(o), o.flags &= -16777217), null;
        case 27:
          zt(o), c = ue.current;
          var g = o.type;
          if (r !== null && o.stateNode != null) r.memoizedProps !== f && Gn(o);
          else {
            if (!f) {
              if (o.stateNode === null) throw Error(i(166));
              return Je(o), null;
            }
            r = ae.current, ha(o) ? Gp(o) : (r = xy(g, f, c), o.stateNode = r, Gn(o));
          }
          return Je(o), null;
        case 5:
          if (zt(o), c = o.type, r !== null && o.stateNode != null) r.memoizedProps !== f && Gn(o);
          else {
            if (!f) {
              if (o.stateNode === null) throw Error(i(166));
              return Je(o), null;
            }
            if (r = ae.current, ha(o)) Gp(o);
            else {
              switch (g = Nl(ue.current), r) {
                case 1:
                  r = g.createElementNS("http://www.w3.org/2000/svg", c);
                  break;
                case 2:
                  r = g.createElementNS("http://www.w3.org/1998/Math/MathML", c);
                  break;
                default:
                  switch (c) {
                    case "svg":
                      r = g.createElementNS("http://www.w3.org/2000/svg", c);
                      break;
                    case "math":
                      r = g.createElementNS("http://www.w3.org/1998/Math/MathML", c);
                      break;
                    case "script":
                      r = g.createElement("div"), r.innerHTML = "<script><\/script>", r = r.removeChild(r.firstChild);
                      break;
                    case "select":
                      r = typeof f.is == "string" ? g.createElement("select", {
                        is: f.is
                      }) : g.createElement("select"), f.multiple ? r.multiple = true : f.size && (r.size = f.size);
                      break;
                    default:
                      r = typeof f.is == "string" ? g.createElement(c, {
                        is: f.is
                      }) : g.createElement(c);
                  }
              }
              r[At] = o, r[Dt] = f;
              e: for (g = o.child; g !== null; ) {
                if (g.tag === 5 || g.tag === 6) r.appendChild(g.stateNode);
                else if (g.tag !== 4 && g.tag !== 27 && g.child !== null) {
                  g.child.return = g, g = g.child;
                  continue;
                }
                if (g === o) break e;
                for (; g.sibling === null; ) {
                  if (g.return === null || g.return === o) break e;
                  g = g.return;
                }
                g.sibling.return = g.return, g = g.sibling;
              }
              o.stateNode = r;
              e: switch (St(r, c, f), c) {
                case "button":
                case "input":
                case "select":
                case "textarea":
                  r = !!f.autoFocus;
                  break e;
                case "img":
                  r = true;
                  break e;
                default:
                  r = false;
              }
              r && Gn(o);
            }
          }
          return Je(o), o.flags &= -16777217, null;
        case 6:
          if (r && o.stateNode != null) r.memoizedProps !== f && Gn(o);
          else {
            if (typeof f != "string" && o.stateNode === null) throw Error(i(166));
            if (r = ue.current, ha(o)) {
              if (r = o.stateNode, c = o.memoizedProps, f = null, g = Nt, g !== null) switch (g.tag) {
                case 27:
                case 5:
                  f = g.memoizedProps;
              }
              r[At] = o, r = !!(r.nodeValue === c || f !== null && f.suppressHydrationWarning === true || py(r.nodeValue, c)), r || as(o);
            } else r = Nl(r).createTextNode(f), r[At] = o, o.stateNode = r;
          }
          return Je(o), null;
        case 13:
          if (f = o.memoizedState, r === null || r.memoizedState !== null && r.memoizedState.dehydrated !== null) {
            if (g = ha(o), f !== null && f.dehydrated !== null) {
              if (r === null) {
                if (!g) throw Error(i(318));
                if (g = o.memoizedState, g = g !== null ? g.dehydrated : null, !g) throw Error(i(317));
                g[At] = o;
              } else da(), (o.flags & 128) === 0 && (o.memoizedState = null), o.flags |= 4;
              Je(o), g = false;
            } else g = em(), r !== null && r.memoizedState !== null && (r.memoizedState.hydrationErrors = g), g = true;
            if (!g) return o.flags & 256 ? (Zn(o), o) : (Zn(o), null);
          }
          if (Zn(o), (o.flags & 128) !== 0) return o.lanes = c, o;
          if (c = f !== null, r = r !== null && r.memoizedState !== null, c) {
            f = o.child, g = null, f.alternate !== null && f.alternate.memoizedState !== null && f.alternate.memoizedState.cachePool !== null && (g = f.alternate.memoizedState.cachePool.pool);
            var m = null;
            f.memoizedState !== null && f.memoizedState.cachePool !== null && (m = f.memoizedState.cachePool.pool), m !== g && (f.flags |= 2048);
          }
          return c !== r && c && (o.child.flags |= 8192), bl(o, o.updateQueue), Je(o), null;
        case 4:
          return pt(), r === null && eh(o.stateNode.containerInfo), Je(o), null;
        case 10:
          return qn(o.type), Je(o), null;
        case 19:
          if (oe(ht), g = o.memoizedState, g === null) return Je(o), null;
          if (f = (o.flags & 128) !== 0, m = g.rendering, m === null) if (f) Ma(g, false);
          else {
            if (tt !== 0 || r !== null && (r.flags & 128) !== 0) for (r = o.child; r !== null; ) {
              if (m = gl(r), m !== null) {
                for (o.flags |= 128, Ma(g, false), r = m.updateQueue, o.updateQueue = r, bl(o, r), o.subtreeFlags = 0, r = c, c = o.child; c !== null; ) Zp(c, r), c = c.sibling;
                return se(ht, ht.current & 1 | 2), o.child;
              }
              r = r.sibling;
            }
            g.tail !== null && wn() > xl && (o.flags |= 128, f = true, Ma(g, false), o.lanes = 4194304);
          }
          else {
            if (!f) if (r = gl(m), r !== null) {
              if (o.flags |= 128, f = true, r = r.updateQueue, o.updateQueue = r, bl(o, r), Ma(g, true), g.tail === null && g.tailMode === "hidden" && !m.alternate && !De) return Je(o), null;
            } else 2 * wn() - g.renderingStartTime > xl && c !== 536870912 && (o.flags |= 128, f = true, Ma(g, false), o.lanes = 4194304);
            g.isBackwards ? (m.sibling = o.child, o.child = m) : (r = g.last, r !== null ? r.sibling = m : o.child = m, g.last = m);
          }
          return g.tail !== null ? (o = g.tail, g.rendering = o, g.tail = o.sibling, g.renderingStartTime = wn(), o.sibling = null, r = ht.current, se(ht, f ? r & 1 | 2 : r & 1), o) : (Je(o), null);
        case 22:
        case 23:
          return Zn(o), tf(), f = o.memoizedState !== null, r !== null ? r.memoizedState !== null !== f && (o.flags |= 8192) : f && (o.flags |= 8192), f ? (c & 536870912) !== 0 && (o.flags & 128) === 0 && (Je(o), o.subtreeFlags & 6 && (o.flags |= 8192)) : Je(o), c = o.updateQueue, c !== null && bl(o, c.retryQueue), c = null, r !== null && r.memoizedState !== null && r.memoizedState.cachePool !== null && (c = r.memoizedState.cachePool.pool), f = null, o.memoizedState !== null && o.memoizedState.cachePool !== null && (f = o.memoizedState.cachePool.pool), f !== c && (o.flags |= 2048), r !== null && oe(cs), null;
        case 24:
          return c = null, r !== null && (c = r.memoizedState.cache), o.memoizedState.cache !== c && (o.flags |= 2048), qn(ft), Je(o), null;
        case 25:
          return null;
        case 30:
          return null;
      }
      throw Error(i(156, o.tag));
    }
    function mx(r, o) {
      switch (zu(o), o.tag) {
        case 1:
          return r = o.flags, r & 65536 ? (o.flags = r & -65537 | 128, o) : null;
        case 3:
          return qn(ft), pt(), r = o.flags, (r & 65536) !== 0 && (r & 128) === 0 ? (o.flags = r & -65537 | 128, o) : null;
        case 26:
        case 27:
        case 5:
          return zt(o), null;
        case 13:
          if (Zn(o), r = o.memoizedState, r !== null && r.dehydrated !== null) {
            if (o.alternate === null) throw Error(i(340));
            da();
          }
          return r = o.flags, r & 65536 ? (o.flags = r & -65537 | 128, o) : null;
        case 19:
          return oe(ht), null;
        case 4:
          return pt(), null;
        case 10:
          return qn(o.type), null;
        case 22:
        case 23:
          return Zn(o), tf(), r !== null && oe(cs), r = o.flags, r & 65536 ? (o.flags = r & -65537 | 128, o) : null;
        case 24:
          return qn(ft), null;
        case 25:
          return null;
        default:
          return null;
      }
    }
    function S_(r, o) {
      switch (zu(o), o.tag) {
        case 3:
          qn(ft), pt();
          break;
        case 26:
        case 27:
        case 5:
          zt(o);
          break;
        case 4:
          pt();
          break;
        case 13:
          Zn(o);
          break;
        case 19:
          oe(ht);
          break;
        case 10:
          qn(o.type);
          break;
        case 22:
        case 23:
          Zn(o), tf(), r !== null && oe(cs);
          break;
        case 24:
          qn(ft);
      }
    }
    function Oa(r, o) {
      try {
        var c = o.updateQueue, f = c !== null ? c.lastEffect : null;
        if (f !== null) {
          var g = f.next;
          c = g;
          do {
            if ((c.tag & r) === r) {
              f = void 0;
              var m = c.create, b = c.inst;
              f = m(), b.destroy = f;
            }
            c = c.next;
          } while (c !== g);
        }
      } catch (T) {
        Ye(o, o.return, T);
      }
    }
    function Ti(r, o, c) {
      try {
        var f = o.updateQueue, g = f !== null ? f.lastEffect : null;
        if (g !== null) {
          var m = g.next;
          f = m;
          do {
            if ((f.tag & r) === r) {
              var b = f.inst, T = b.destroy;
              if (T !== void 0) {
                b.destroy = void 0, g = o;
                var w = c, z = T;
                try {
                  z();
                } catch (X) {
                  Ye(g, w, X);
                }
              }
            }
            f = f.next;
          } while (f !== m);
        }
      } catch (X) {
        Ye(o, o.return, X);
      }
    }
    function A_(r) {
      var o = r.updateQueue;
      if (o !== null) {
        var c = r.stateNode;
        try {
          fm(o, c);
        } catch (f) {
          Ye(r, r.return, f);
        }
      }
    }
    function w_(r, o, c) {
      c.props = fs(r.type, r.memoizedProps), c.state = r.memoizedState;
      try {
        c.componentWillUnmount();
      } catch (f) {
        Ye(r, o, f);
      }
    }
    function Ia(r, o) {
      try {
        var c = r.ref;
        if (c !== null) {
          switch (r.tag) {
            case 26:
            case 27:
            case 5:
              var f = r.stateNode;
              break;
            case 30:
              f = r.stateNode;
              break;
            default:
              f = r.stateNode;
          }
          typeof c == "function" ? r.refCleanup = c(f) : c.current = f;
        }
      } catch (g) {
        Ye(r, o, g);
      }
    }
    function Cn(r, o) {
      var c = r.ref, f = r.refCleanup;
      if (c !== null) if (typeof f == "function") try {
        f();
      } catch (g) {
        Ye(r, o, g);
      } finally {
        r.refCleanup = null, r = r.alternate, r != null && (r.refCleanup = null);
      }
      else if (typeof c == "function") try {
        c(null);
      } catch (g) {
        Ye(r, o, g);
      }
      else c.current = null;
    }
    function E_(r) {
      var o = r.type, c = r.memoizedProps, f = r.stateNode;
      try {
        e: switch (o) {
          case "button":
          case "input":
          case "select":
          case "textarea":
            c.autoFocus && f.focus();
            break e;
          case "img":
            c.src ? f.src = c.src : c.srcSet && (f.srcset = c.srcSet);
        }
      } catch (g) {
        Ye(r, r.return, g);
      }
    }
    function Of(r, o, c) {
      try {
        var f = r.stateNode;
        Bx(f, r.type, c, o), f[Dt] = o;
      } catch (g) {
        Ye(r, r.return, g);
      }
    }
    function R_(r) {
      return r.tag === 5 || r.tag === 3 || r.tag === 26 || r.tag === 27 && Mi(r.type) || r.tag === 4;
    }
    function If(r) {
      e: for (; ; ) {
        for (; r.sibling === null; ) {
          if (r.return === null || R_(r.return)) return null;
          r = r.return;
        }
        for (r.sibling.return = r.return, r = r.sibling; r.tag !== 5 && r.tag !== 6 && r.tag !== 18; ) {
          if (r.tag === 27 && Mi(r.type) || r.flags & 2 || r.child === null || r.tag === 4) continue e;
          r.child.return = r, r = r.child;
        }
        if (!(r.flags & 2)) return r.stateNode;
      }
    }
    function Nf(r, o, c) {
      var f = r.tag;
      if (f === 5 || f === 6) r = r.stateNode, o ? (c.nodeType === 9 ? c.body : c.nodeName === "HTML" ? c.ownerDocument.body : c).insertBefore(r, o) : (o = c.nodeType === 9 ? c.body : c.nodeName === "HTML" ? c.ownerDocument.body : c, o.appendChild(r), c = c._reactRootContainer, c != null || o.onclick !== null || (o.onclick = Il));
      else if (f !== 4 && (f === 27 && Mi(r.type) && (c = r.stateNode, o = null), r = r.child, r !== null)) for (Nf(r, o, c), r = r.sibling; r !== null; ) Nf(r, o, c), r = r.sibling;
    }
    function vl(r, o, c) {
      var f = r.tag;
      if (f === 5 || f === 6) r = r.stateNode, o ? c.insertBefore(r, o) : c.appendChild(r);
      else if (f !== 4 && (f === 27 && Mi(r.type) && (c = r.stateNode), r = r.child, r !== null)) for (vl(r, o, c), r = r.sibling; r !== null; ) vl(r, o, c), r = r.sibling;
    }
    function C_(r) {
      var o = r.stateNode, c = r.memoizedProps;
      try {
        for (var f = r.type, g = o.attributes; g.length; ) o.removeAttributeNode(g[0]);
        St(o, f, c), o[At] = r, o[Dt] = c;
      } catch (m) {
        Ye(r, r.return, m);
      }
    }
    var Jn = false, rt = false, Pf = false, M_ = typeof WeakSet == "function" ? WeakSet : Set, yt = null;
    function _x(r, o) {
      if (r = r.containerInfo, ih = Ll, r = Vp(r), Ou(r)) {
        if ("selectionStart" in r) var c = {
          start: r.selectionStart,
          end: r.selectionEnd
        };
        else e: {
          c = (c = r.ownerDocument) && c.defaultView || window;
          var f = c.getSelection && c.getSelection();
          if (f && f.rangeCount !== 0) {
            c = f.anchorNode;
            var g = f.anchorOffset, m = f.focusNode;
            f = f.focusOffset;
            try {
              c.nodeType, m.nodeType;
            } catch {
              c = null;
              break e;
            }
            var b = 0, T = -1, w = -1, z = 0, X = 0, K = r, j = null;
            t: for (; ; ) {
              for (var W; K !== c || g !== 0 && K.nodeType !== 3 || (T = b + g), K !== m || f !== 0 && K.nodeType !== 3 || (w = b + f), K.nodeType === 3 && (b += K.nodeValue.length), (W = K.firstChild) !== null; ) j = K, K = W;
              for (; ; ) {
                if (K === r) break t;
                if (j === c && ++z === g && (T = b), j === m && ++X === f && (w = b), (W = K.nextSibling) !== null) break;
                K = j, j = K.parentNode;
              }
              K = W;
            }
            c = T === -1 || w === -1 ? null : {
              start: T,
              end: w
            };
          } else c = null;
        }
        c = c || {
          start: 0,
          end: 0
        };
      } else c = null;
      for (sh = {
        focusedElem: r,
        selectionRange: c
      }, Ll = false, yt = o; yt !== null; ) if (o = yt, r = o.child, (o.subtreeFlags & 1024) !== 0 && r !== null) r.return = o, yt = r;
      else for (; yt !== null; ) {
        switch (o = yt, m = o.alternate, r = o.flags, o.tag) {
          case 0:
            break;
          case 11:
          case 15:
            break;
          case 1:
            if ((r & 1024) !== 0 && m !== null) {
              r = void 0, c = o, g = m.memoizedProps, m = m.memoizedState, f = c.stateNode;
              try {
                var be = fs(c.type, g, c.elementType === c.type);
                r = f.getSnapshotBeforeUpdate(be, m), f.__reactInternalSnapshotBeforeUpdate = r;
              } catch (pe) {
                Ye(c, c.return, pe);
              }
            }
            break;
          case 3:
            if ((r & 1024) !== 0) {
              if (r = o.stateNode.containerInfo, c = r.nodeType, c === 9) oh(r);
              else if (c === 1) switch (r.nodeName) {
                case "HEAD":
                case "HTML":
                case "BODY":
                  oh(r);
                  break;
                default:
                  r.textContent = "";
              }
            }
            break;
          case 5:
          case 26:
          case 27:
          case 6:
          case 4:
          case 17:
            break;
          default:
            if ((r & 1024) !== 0) throw Error(i(163));
        }
        if (r = o.sibling, r !== null) {
          r.return = o.return, yt = r;
          break;
        }
        yt = o.return;
      }
    }
    function O_(r, o, c) {
      var f = c.flags;
      switch (c.tag) {
        case 0:
        case 11:
        case 15:
          xi(r, c), f & 4 && Oa(5, c);
          break;
        case 1:
          if (xi(r, c), f & 4) if (r = c.stateNode, o === null) try {
            r.componentDidMount();
          } catch (b) {
            Ye(c, c.return, b);
          }
          else {
            var g = fs(c.type, o.memoizedProps);
            o = o.memoizedState;
            try {
              r.componentDidUpdate(g, o, r.__reactInternalSnapshotBeforeUpdate);
            } catch (b) {
              Ye(c, c.return, b);
            }
          }
          f & 64 && A_(c), f & 512 && Ia(c, c.return);
          break;
        case 3:
          if (xi(r, c), f & 64 && (r = c.updateQueue, r !== null)) {
            if (o = null, c.child !== null) switch (c.child.tag) {
              case 27:
              case 5:
                o = c.child.stateNode;
                break;
              case 1:
                o = c.child.stateNode;
            }
            try {
              fm(r, o);
            } catch (b) {
              Ye(c, c.return, b);
            }
          }
          break;
        case 27:
          o === null && f & 4 && C_(c);
        case 26:
        case 5:
          xi(r, c), o === null && f & 4 && E_(c), f & 512 && Ia(c, c.return);
          break;
        case 12:
          xi(r, c);
          break;
        case 13:
          xi(r, c), f & 4 && P_(r, c), f & 64 && (r = c.memoizedState, r !== null && (r = r.dehydrated, r !== null && (c = Ex.bind(null, c), Wx(r, c))));
          break;
        case 22:
          if (f = c.memoizedState !== null || Jn, !f) {
            o = o !== null && o.memoizedState !== null || rt, g = Jn;
            var m = rt;
            Jn = f, (rt = o) && !m ? Si(r, c, (c.subtreeFlags & 8772) !== 0) : xi(r, c), Jn = g, rt = m;
          }
          break;
        case 30:
          break;
        default:
          xi(r, c);
      }
    }
    function I_(r) {
      var o = r.alternate;
      o !== null && (r.alternate = null, I_(o)), r.child = null, r.deletions = null, r.sibling = null, r.tag === 5 && (o = r.stateNode, o !== null && fu(o)), r.stateNode = null, r.return = null, r.dependencies = null, r.memoizedProps = null, r.memoizedState = null, r.pendingProps = null, r.stateNode = null, r.updateQueue = null;
    }
    var Ze = null, Bt = false;
    function ei(r, o, c) {
      for (c = c.child; c !== null; ) N_(r, o, c), c = c.sibling;
    }
    function N_(r, o, c) {
      if (Ht && typeof Ht.onCommitFiberUnmount == "function") try {
        Ht.onCommitFiberUnmount(Gr, c);
      } catch {
      }
      switch (c.tag) {
        case 26:
          rt || Cn(c, o), ei(r, o, c), c.memoizedState ? c.memoizedState.count-- : c.stateNode && (c = c.stateNode, c.parentNode.removeChild(c));
          break;
        case 27:
          rt || Cn(c, o);
          var f = Ze, g = Bt;
          Mi(c.type) && (Ze = c.stateNode, Bt = false), ei(r, o, c), Va(c.stateNode), Ze = f, Bt = g;
          break;
        case 5:
          rt || Cn(c, o);
        case 6:
          if (f = Ze, g = Bt, Ze = null, ei(r, o, c), Ze = f, Bt = g, Ze !== null) if (Bt) try {
            (Ze.nodeType === 9 ? Ze.body : Ze.nodeName === "HTML" ? Ze.ownerDocument.body : Ze).removeChild(c.stateNode);
          } catch (m) {
            Ye(c, o, m);
          }
          else try {
            Ze.removeChild(c.stateNode);
          } catch (m) {
            Ye(c, o, m);
          }
          break;
        case 18:
          Ze !== null && (Bt ? (r = Ze, vy(r.nodeType === 9 ? r.body : r.nodeName === "HTML" ? r.ownerDocument.body : r, c.stateNode), qa(r)) : vy(Ze, c.stateNode));
          break;
        case 4:
          f = Ze, g = Bt, Ze = c.stateNode.containerInfo, Bt = true, ei(r, o, c), Ze = f, Bt = g;
          break;
        case 0:
        case 11:
        case 14:
        case 15:
          rt || Ti(2, c, o), rt || Ti(4, c, o), ei(r, o, c);
          break;
        case 1:
          rt || (Cn(c, o), f = c.stateNode, typeof f.componentWillUnmount == "function" && w_(c, o, f)), ei(r, o, c);
          break;
        case 21:
          ei(r, o, c);
          break;
        case 22:
          rt = (f = rt) || c.memoizedState !== null, ei(r, o, c), rt = f;
          break;
        default:
          ei(r, o, c);
      }
    }
    function P_(r, o) {
      if (o.memoizedState === null && (r = o.alternate, r !== null && (r = r.memoizedState, r !== null && (r = r.dehydrated, r !== null)))) try {
        qa(r);
      } catch (c) {
        Ye(o, o.return, c);
      }
    }
    function yx(r) {
      switch (r.tag) {
        case 13:
        case 19:
          var o = r.stateNode;
          return o === null && (o = r.stateNode = new M_()), o;
        case 22:
          return r = r.stateNode, o = r._retryCache, o === null && (o = r._retryCache = new M_()), o;
        default:
          throw Error(i(435, r.tag));
      }
    }
    function Df(r, o) {
      var c = yx(r);
      o.forEach(function(f) {
        var g = Rx.bind(null, r, f);
        c.has(f) || (c.add(f), f.then(g, g));
      });
    }
    function Xt(r, o) {
      var c = o.deletions;
      if (c !== null) for (var f = 0; f < c.length; f++) {
        var g = c[f], m = r, b = o, T = b;
        e: for (; T !== null; ) {
          switch (T.tag) {
            case 27:
              if (Mi(T.type)) {
                Ze = T.stateNode, Bt = false;
                break e;
              }
              break;
            case 5:
              Ze = T.stateNode, Bt = false;
              break e;
            case 3:
            case 4:
              Ze = T.stateNode.containerInfo, Bt = true;
              break e;
          }
          T = T.return;
        }
        if (Ze === null) throw Error(i(160));
        N_(m, b, g), Ze = null, Bt = false, m = g.alternate, m !== null && (m.return = null), g.return = null;
      }
      if (o.subtreeFlags & 13878) for (o = o.child; o !== null; ) D_(o, r), o = o.sibling;
    }
    var bn = null;
    function D_(r, o) {
      var c = r.alternate, f = r.flags;
      switch (r.tag) {
        case 0:
        case 11:
        case 14:
        case 15:
          Xt(o, r), Yt(r), f & 4 && (Ti(3, r, r.return), Oa(3, r), Ti(5, r, r.return));
          break;
        case 1:
          Xt(o, r), Yt(r), f & 512 && (rt || c === null || Cn(c, c.return)), f & 64 && Jn && (r = r.updateQueue, r !== null && (f = r.callbacks, f !== null && (c = r.shared.hiddenCallbacks, r.shared.hiddenCallbacks = c === null ? f : c.concat(f))));
          break;
        case 26:
          var g = bn;
          if (Xt(o, r), Yt(r), f & 512 && (rt || c === null || Cn(c, c.return)), f & 4) {
            var m = c !== null ? c.memoizedState : null;
            if (f = r.memoizedState, c === null) if (f === null) if (r.stateNode === null) {
              e: {
                f = r.type, c = r.memoizedProps, g = g.ownerDocument || g;
                t: switch (f) {
                  case "title":
                    m = g.getElementsByTagName("title")[0], (!m || m[ta] || m[At] || m.namespaceURI === "http://www.w3.org/2000/svg" || m.hasAttribute("itemprop")) && (m = g.createElement(f), g.head.insertBefore(m, g.querySelector("head > title"))), St(m, f, c), m[At] = r, mt(m), f = m;
                    break e;
                  case "link":
                    var b = Cy("link", "href", g).get(f + (c.href || ""));
                    if (b) {
                      for (var T = 0; T < b.length; T++) if (m = b[T], m.getAttribute("href") === (c.href == null || c.href === "" ? null : c.href) && m.getAttribute("rel") === (c.rel == null ? null : c.rel) && m.getAttribute("title") === (c.title == null ? null : c.title) && m.getAttribute("crossorigin") === (c.crossOrigin == null ? null : c.crossOrigin)) {
                        b.splice(T, 1);
                        break t;
                      }
                    }
                    m = g.createElement(f), St(m, f, c), g.head.appendChild(m);
                    break;
                  case "meta":
                    if (b = Cy("meta", "content", g).get(f + (c.content || ""))) {
                      for (T = 0; T < b.length; T++) if (m = b[T], m.getAttribute("content") === (c.content == null ? null : "" + c.content) && m.getAttribute("name") === (c.name == null ? null : c.name) && m.getAttribute("property") === (c.property == null ? null : c.property) && m.getAttribute("http-equiv") === (c.httpEquiv == null ? null : c.httpEquiv) && m.getAttribute("charset") === (c.charSet == null ? null : c.charSet)) {
                        b.splice(T, 1);
                        break t;
                      }
                    }
                    m = g.createElement(f), St(m, f, c), g.head.appendChild(m);
                    break;
                  default:
                    throw Error(i(468, f));
                }
                m[At] = r, mt(m), f = m;
              }
              r.stateNode = f;
            } else My(g, r.type, r.stateNode);
            else r.stateNode = Ry(g, f, r.memoizedProps);
            else m !== f ? (m === null ? c.stateNode !== null && (c = c.stateNode, c.parentNode.removeChild(c)) : m.count--, f === null ? My(g, r.type, r.stateNode) : Ry(g, f, r.memoizedProps)) : f === null && r.stateNode !== null && Of(r, r.memoizedProps, c.memoizedProps);
          }
          break;
        case 27:
          Xt(o, r), Yt(r), f & 512 && (rt || c === null || Cn(c, c.return)), c !== null && f & 4 && Of(r, r.memoizedProps, c.memoizedProps);
          break;
        case 5:
          if (Xt(o, r), Yt(r), f & 512 && (rt || c === null || Cn(c, c.return)), r.flags & 32) {
            g = r.stateNode;
            try {
              Hs(g, "");
            } catch (W) {
              Ye(r, r.return, W);
            }
          }
          f & 4 && r.stateNode != null && (g = r.memoizedProps, Of(r, g, c !== null ? c.memoizedProps : g)), f & 1024 && (Pf = true);
          break;
        case 6:
          if (Xt(o, r), Yt(r), f & 4) {
            if (r.stateNode === null) throw Error(i(162));
            f = r.memoizedProps, c = r.stateNode;
            try {
              c.nodeValue = f;
            } catch (W) {
              Ye(r, r.return, W);
            }
          }
          break;
        case 3:
          if (kl = null, g = bn, bn = Pl(o.containerInfo), Xt(o, r), bn = g, Yt(r), f & 4 && c !== null && c.memoizedState.isDehydrated) try {
            qa(o.containerInfo);
          } catch (W) {
            Ye(r, r.return, W);
          }
          Pf && (Pf = false, k_(r));
          break;
        case 4:
          f = bn, bn = Pl(r.stateNode.containerInfo), Xt(o, r), Yt(r), bn = f;
          break;
        case 12:
          Xt(o, r), Yt(r);
          break;
        case 13:
          Xt(o, r), Yt(r), r.child.flags & 8192 && r.memoizedState !== null != (c !== null && c.memoizedState !== null) && (Vf = wn()), f & 4 && (f = r.updateQueue, f !== null && (r.updateQueue = null, Df(r, f)));
          break;
        case 22:
          g = r.memoizedState !== null;
          var w = c !== null && c.memoizedState !== null, z = Jn, X = rt;
          if (Jn = z || g, rt = X || w, Xt(o, r), rt = X, Jn = z, Yt(r), f & 8192) e: for (o = r.stateNode, o._visibility = g ? o._visibility & -2 : o._visibility | 1, g && (c === null || w || Jn || rt || hs(r)), c = null, o = r; ; ) {
            if (o.tag === 5 || o.tag === 26) {
              if (c === null) {
                w = c = o;
                try {
                  if (m = w.stateNode, g) b = m.style, typeof b.setProperty == "function" ? b.setProperty("display", "none", "important") : b.display = "none";
                  else {
                    T = w.stateNode;
                    var K = w.memoizedProps.style, j = K != null && K.hasOwnProperty("display") ? K.display : null;
                    T.style.display = j == null || typeof j == "boolean" ? "" : ("" + j).trim();
                  }
                } catch (W) {
                  Ye(w, w.return, W);
                }
              }
            } else if (o.tag === 6) {
              if (c === null) {
                w = o;
                try {
                  w.stateNode.nodeValue = g ? "" : w.memoizedProps;
                } catch (W) {
                  Ye(w, w.return, W);
                }
              }
            } else if ((o.tag !== 22 && o.tag !== 23 || o.memoizedState === null || o === r) && o.child !== null) {
              o.child.return = o, o = o.child;
              continue;
            }
            if (o === r) break e;
            for (; o.sibling === null; ) {
              if (o.return === null || o.return === r) break e;
              c === o && (c = null), o = o.return;
            }
            c === o && (c = null), o.sibling.return = o.return, o = o.sibling;
          }
          f & 4 && (f = r.updateQueue, f !== null && (c = f.retryQueue, c !== null && (f.retryQueue = null, Df(r, c))));
          break;
        case 19:
          Xt(o, r), Yt(r), f & 4 && (f = r.updateQueue, f !== null && (r.updateQueue = null, Df(r, f)));
          break;
        case 30:
          break;
        case 21:
          break;
        default:
          Xt(o, r), Yt(r);
      }
    }
    function Yt(r) {
      var o = r.flags;
      if (o & 2) {
        try {
          for (var c, f = r.return; f !== null; ) {
            if (R_(f)) {
              c = f;
              break;
            }
            f = f.return;
          }
          if (c == null) throw Error(i(160));
          switch (c.tag) {
            case 27:
              var g = c.stateNode, m = If(r);
              vl(r, m, g);
              break;
            case 5:
              var b = c.stateNode;
              c.flags & 32 && (Hs(b, ""), c.flags &= -33);
              var T = If(r);
              vl(r, T, b);
              break;
            case 3:
            case 4:
              var w = c.stateNode.containerInfo, z = If(r);
              Nf(r, z, w);
              break;
            default:
              throw Error(i(161));
          }
        } catch (X) {
          Ye(r, r.return, X);
        }
        r.flags &= -3;
      }
      o & 4096 && (r.flags &= -4097);
    }
    function k_(r) {
      if (r.subtreeFlags & 1024) for (r = r.child; r !== null; ) {
        var o = r;
        k_(o), o.tag === 5 && o.flags & 1024 && o.stateNode.reset(), r = r.sibling;
      }
    }
    function xi(r, o) {
      if (o.subtreeFlags & 8772) for (o = o.child; o !== null; ) O_(r, o.alternate, o), o = o.sibling;
    }
    function hs(r) {
      for (r = r.child; r !== null; ) {
        var o = r;
        switch (o.tag) {
          case 0:
          case 11:
          case 14:
          case 15:
            Ti(4, o, o.return), hs(o);
            break;
          case 1:
            Cn(o, o.return);
            var c = o.stateNode;
            typeof c.componentWillUnmount == "function" && w_(o, o.return, c), hs(o);
            break;
          case 27:
            Va(o.stateNode);
          case 26:
          case 5:
            Cn(o, o.return), hs(o);
            break;
          case 22:
            o.memoizedState === null && hs(o);
            break;
          case 30:
            hs(o);
            break;
          default:
            hs(o);
        }
        r = r.sibling;
      }
    }
    function Si(r, o, c) {
      for (c = c && (o.subtreeFlags & 8772) !== 0, o = o.child; o !== null; ) {
        var f = o.alternate, g = r, m = o, b = m.flags;
        switch (m.tag) {
          case 0:
          case 11:
          case 15:
            Si(g, m, c), Oa(4, m);
            break;
          case 1:
            if (Si(g, m, c), f = m, g = f.stateNode, typeof g.componentDidMount == "function") try {
              g.componentDidMount();
            } catch (z) {
              Ye(f, f.return, z);
            }
            if (f = m, g = f.updateQueue, g !== null) {
              var T = f.stateNode;
              try {
                var w = g.shared.hiddenCallbacks;
                if (w !== null) for (g.shared.hiddenCallbacks = null, g = 0; g < w.length; g++) um(w[g], T);
              } catch (z) {
                Ye(f, f.return, z);
              }
            }
            c && b & 64 && A_(m), Ia(m, m.return);
            break;
          case 27:
            C_(m);
          case 26:
          case 5:
            Si(g, m, c), c && f === null && b & 4 && E_(m), Ia(m, m.return);
            break;
          case 12:
            Si(g, m, c);
            break;
          case 13:
            Si(g, m, c), c && b & 4 && P_(g, m);
            break;
          case 22:
            m.memoizedState === null && Si(g, m, c), Ia(m, m.return);
            break;
          case 30:
            break;
          default:
            Si(g, m, c);
        }
        o = o.sibling;
      }
    }
    function kf(r, o) {
      var c = null;
      r !== null && r.memoizedState !== null && r.memoizedState.cachePool !== null && (c = r.memoizedState.cachePool.pool), r = null, o.memoizedState !== null && o.memoizedState.cachePool !== null && (r = o.memoizedState.cachePool.pool), r !== c && (r != null && r.refCount++, c != null && ma(c));
    }
    function Uf(r, o) {
      r = null, o.alternate !== null && (r = o.alternate.memoizedState.cache), o = o.memoizedState.cache, o !== r && (o.refCount++, r != null && ma(r));
    }
    function Mn(r, o, c, f) {
      if (o.subtreeFlags & 10256) for (o = o.child; o !== null; ) U_(r, o, c, f), o = o.sibling;
    }
    function U_(r, o, c, f) {
      var g = o.flags;
      switch (o.tag) {
        case 0:
        case 11:
        case 15:
          Mn(r, o, c, f), g & 2048 && Oa(9, o);
          break;
        case 1:
          Mn(r, o, c, f);
          break;
        case 3:
          Mn(r, o, c, f), g & 2048 && (r = null, o.alternate !== null && (r = o.alternate.memoizedState.cache), o = o.memoizedState.cache, o !== r && (o.refCount++, r != null && ma(r)));
          break;
        case 12:
          if (g & 2048) {
            Mn(r, o, c, f), r = o.stateNode;
            try {
              var m = o.memoizedProps, b = m.id, T = m.onPostCommit;
              typeof T == "function" && T(b, o.alternate === null ? "mount" : "update", r.passiveEffectDuration, -0);
            } catch (w) {
              Ye(o, o.return, w);
            }
          } else Mn(r, o, c, f);
          break;
        case 13:
          Mn(r, o, c, f);
          break;
        case 23:
          break;
        case 22:
          m = o.stateNode, b = o.alternate, o.memoizedState !== null ? m._visibility & 2 ? Mn(r, o, c, f) : Na(r, o) : m._visibility & 2 ? Mn(r, o, c, f) : (m._visibility |= 2, or(r, o, c, f, (o.subtreeFlags & 10256) !== 0)), g & 2048 && kf(b, o);
          break;
        case 24:
          Mn(r, o, c, f), g & 2048 && Uf(o.alternate, o);
          break;
        default:
          Mn(r, o, c, f);
      }
    }
    function or(r, o, c, f, g) {
      for (g = g && (o.subtreeFlags & 10256) !== 0, o = o.child; o !== null; ) {
        var m = r, b = o, T = c, w = f, z = b.flags;
        switch (b.tag) {
          case 0:
          case 11:
          case 15:
            or(m, b, T, w, g), Oa(8, b);
            break;
          case 23:
            break;
          case 22:
            var X = b.stateNode;
            b.memoizedState !== null ? X._visibility & 2 ? or(m, b, T, w, g) : Na(m, b) : (X._visibility |= 2, or(m, b, T, w, g)), g && z & 2048 && kf(b.alternate, b);
            break;
          case 24:
            or(m, b, T, w, g), g && z & 2048 && Uf(b.alternate, b);
            break;
          default:
            or(m, b, T, w, g);
        }
        o = o.sibling;
      }
    }
    function Na(r, o) {
      if (o.subtreeFlags & 10256) for (o = o.child; o !== null; ) {
        var c = r, f = o, g = f.flags;
        switch (f.tag) {
          case 22:
            Na(c, f), g & 2048 && kf(f.alternate, f);
            break;
          case 24:
            Na(c, f), g & 2048 && Uf(f.alternate, f);
            break;
          default:
            Na(c, f);
        }
        o = o.sibling;
      }
    }
    var Pa = 8192;
    function lr(r) {
      if (r.subtreeFlags & Pa) for (r = r.child; r !== null; ) B_(r), r = r.sibling;
    }
    function B_(r) {
      switch (r.tag) {
        case 26:
          lr(r), r.flags & Pa && r.memoizedState !== null && iS(bn, r.memoizedState, r.memoizedProps);
          break;
        case 5:
          lr(r);
          break;
        case 3:
        case 4:
          var o = bn;
          bn = Pl(r.stateNode.containerInfo), lr(r), bn = o;
          break;
        case 22:
          r.memoizedState === null && (o = r.alternate, o !== null && o.memoizedState !== null ? (o = Pa, Pa = 16777216, lr(r), Pa = o) : lr(r));
          break;
        default:
          lr(r);
      }
    }
    function L_(r) {
      var o = r.alternate;
      if (o !== null && (r = o.child, r !== null)) {
        o.child = null;
        do
          o = r.sibling, r.sibling = null, r = o;
        while (r !== null);
      }
    }
    function Da(r) {
      var o = r.deletions;
      if ((r.flags & 16) !== 0) {
        if (o !== null) for (var c = 0; c < o.length; c++) {
          var f = o[c];
          yt = f, V_(f, r);
        }
        L_(r);
      }
      if (r.subtreeFlags & 10256) for (r = r.child; r !== null; ) F_(r), r = r.sibling;
    }
    function F_(r) {
      switch (r.tag) {
        case 0:
        case 11:
        case 15:
          Da(r), r.flags & 2048 && Ti(9, r, r.return);
          break;
        case 3:
          Da(r);
          break;
        case 12:
          Da(r);
          break;
        case 22:
          var o = r.stateNode;
          r.memoizedState !== null && o._visibility & 2 && (r.return === null || r.return.tag !== 13) ? (o._visibility &= -3, Tl(r)) : Da(r);
          break;
        default:
          Da(r);
      }
    }
    function Tl(r) {
      var o = r.deletions;
      if ((r.flags & 16) !== 0) {
        if (o !== null) for (var c = 0; c < o.length; c++) {
          var f = o[c];
          yt = f, V_(f, r);
        }
        L_(r);
      }
      for (r = r.child; r !== null; ) {
        switch (o = r, o.tag) {
          case 0:
          case 11:
          case 15:
            Ti(8, o, o.return), Tl(o);
            break;
          case 22:
            c = o.stateNode, c._visibility & 2 && (c._visibility &= -3, Tl(o));
            break;
          default:
            Tl(o);
        }
        r = r.sibling;
      }
    }
    function V_(r, o) {
      for (; yt !== null; ) {
        var c = yt;
        switch (c.tag) {
          case 0:
          case 11:
          case 15:
            Ti(8, c, o);
            break;
          case 23:
          case 22:
            if (c.memoizedState !== null && c.memoizedState.cachePool !== null) {
              var f = c.memoizedState.cachePool.pool;
              f != null && f.refCount++;
            }
            break;
          case 24:
            ma(c.memoizedState.cache);
        }
        if (f = c.child, f !== null) f.return = c, yt = f;
        else e: for (c = r; yt !== null; ) {
          f = yt;
          var g = f.sibling, m = f.return;
          if (I_(f), f === c) {
            yt = null;
            break e;
          }
          if (g !== null) {
            g.return = m, yt = g;
            break e;
          }
          yt = m;
        }
      }
    }
    var bx = {
      getCacheForType: function(r) {
        var o = wt(ft), c = o.data.get(r);
        return c === void 0 && (c = r(), o.data.set(r, c)), c;
      }
    }, vx = typeof WeakMap == "function" ? WeakMap : Map, Fe = 0, qe = null, Ce = null, Ie = 0, Ve = 0, qt = null, Ai = false, cr = false, Bf = false, ti = 0, tt = 0, wi = 0, ds = 0, Lf = 0, cn = 0, ur = 0, ka = null, Lt = null, Ff = false, Vf = 0, xl = 1 / 0, Sl = null, Ei = null, xt = 0, Ri = null, fr = null, hr = 0, zf = 0, Hf = null, z_ = null, Ua = 0, jf = null;
    function Kt() {
      if ((Fe & 2) !== 0 && Ie !== 0) return Ie & -Ie;
      if ($.T !== null) {
        var r = Js;
        return r !== 0 ? r : Zf();
      }
      return ip();
    }
    function H_() {
      cn === 0 && (cn = (Ie & 536870912) === 0 || De ? Jg() : 536870912);
      var r = ln.current;
      return r !== null && (r.flags |= 32), cn;
    }
    function Zt(r, o, c) {
      (r === qe && (Ve === 2 || Ve === 9) || r.cancelPendingCommit !== null) && (dr(r, 0), Ci(r, Ie, cn, false)), ea(r, c), ((Fe & 2) === 0 || r !== qe) && (r === qe && ((Fe & 2) === 0 && (ds |= c), tt === 4 && Ci(r, Ie, cn, false)), On(r));
    }
    function j_(r, o, c) {
      if ((Fe & 6) !== 0) throw Error(i(327));
      var f = !c && (o & 124) === 0 && (o & r.expiredLanes) === 0 || Jr(r, o), g = f ? Sx(r, o) : Xf(r, o, true), m = f;
      do {
        if (g === 0) {
          cr && !f && Ci(r, o, 0, false);
          break;
        } else {
          if (c = r.current.alternate, m && !Tx(c)) {
            g = Xf(r, o, false), m = false;
            continue;
          }
          if (g === 2) {
            if (m = o, r.errorRecoveryDisabledLanes & m) var b = 0;
            else b = r.pendingLanes & -536870913, b = b !== 0 ? b : b & 536870912 ? 536870912 : 0;
            if (b !== 0) {
              o = b;
              e: {
                var T = r;
                g = ka;
                var w = T.current.memoizedState.isDehydrated;
                if (w && (dr(T, b).flags |= 256), b = Xf(T, b, false), b !== 2) {
                  if (Bf && !w) {
                    T.errorRecoveryDisabledLanes |= m, ds |= m, g = 4;
                    break e;
                  }
                  m = Lt, Lt = g, m !== null && (Lt === null ? Lt = m : Lt.push.apply(Lt, m));
                }
                g = b;
              }
              if (m = false, g !== 2) continue;
            }
          }
          if (g === 1) {
            dr(r, 0), Ci(r, o, 0, true);
            break;
          }
          e: {
            switch (f = r, m = g, m) {
              case 0:
              case 1:
                throw Error(i(345));
              case 4:
                if ((o & 4194048) !== o) break;
              case 6:
                Ci(f, o, cn, !Ai);
                break e;
              case 2:
                Lt = null;
                break;
              case 3:
              case 5:
                break;
              default:
                throw Error(i(329));
            }
            if ((o & 62914560) === o && (g = Vf + 300 - wn(), 10 < g)) {
              if (Ci(f, o, cn, !Ai), Do(f, 0, true) !== 0) break e;
              f.timeoutHandle = yy(W_.bind(null, f, c, Lt, Sl, Ff, o, cn, ds, ur, Ai, m, 2, -0, 0), g);
              break e;
            }
            W_(f, c, Lt, Sl, Ff, o, cn, ds, ur, Ai, m, 0, -0, 0);
          }
        }
        break;
      } while (true);
      On(r);
    }
    function W_(r, o, c, f, g, m, b, T, w, z, X, K, j, W) {
      if (r.timeoutHandle = -1, K = o.subtreeFlags, (K & 8192 || (K & 16785408) === 16785408) && (ja = {
        stylesheets: null,
        count: 0,
        unsuspend: nS
      }, B_(o), K = sS(), K !== null)) {
        r.cancelPendingCommit = K(Q_.bind(null, r, o, m, c, f, g, b, T, w, X, 1, j, W)), Ci(r, m, b, !z);
        return;
      }
      Q_(r, o, m, c, f, g, b, T, w);
    }
    function Tx(r) {
      for (var o = r; ; ) {
        var c = o.tag;
        if ((c === 0 || c === 11 || c === 15) && o.flags & 16384 && (c = o.updateQueue, c !== null && (c = c.stores, c !== null))) for (var f = 0; f < c.length; f++) {
          var g = c[f], m = g.getSnapshot;
          g = g.value;
          try {
            if (!Wt(m(), g)) return false;
          } catch {
            return false;
          }
        }
        if (c = o.child, o.subtreeFlags & 16384 && c !== null) c.return = o, o = c;
        else {
          if (o === r) break;
          for (; o.sibling === null; ) {
            if (o.return === null || o.return === r) return true;
            o = o.return;
          }
          o.sibling.return = o.return, o = o.sibling;
        }
      }
      return true;
    }
    function Ci(r, o, c, f) {
      o &= ~Lf, o &= ~ds, r.suspendedLanes |= o, r.pingedLanes &= ~o, f && (r.warmLanes |= o), f = r.expirationTimes;
      for (var g = o; 0 < g; ) {
        var m = 31 - jt(g), b = 1 << m;
        f[m] = -1, g &= ~b;
      }
      c !== 0 && tp(r, c, o);
    }
    function Al() {
      return (Fe & 6) === 0 ? (Ba(0), false) : true;
    }
    function Wf() {
      if (Ce !== null) {
        if (Ve === 0) var r = Ce.return;
        else r = Ce, Yn = os = null, of(r), rr = null, Ra = 0, r = Ce;
        for (; r !== null; ) S_(r.alternate, r), r = r.return;
        Ce = null;
      }
    }
    function dr(r, o) {
      var c = r.timeoutHandle;
      c !== -1 && (r.timeoutHandle = -1, Fx(c)), c = r.cancelPendingCommit, c !== null && (r.cancelPendingCommit = null, c()), Wf(), qe = r, Ce = c = Wn(r.current, null), Ie = o, Ve = 0, qt = null, Ai = false, cr = Jr(r, o), Bf = false, ur = cn = Lf = ds = wi = tt = 0, Lt = ka = null, Ff = false, (o & 8) !== 0 && (o |= o & 32);
      var f = r.entangledLanes;
      if (f !== 0) for (r = r.entanglements, f &= o; 0 < f; ) {
        var g = 31 - jt(f), m = 1 << g;
        o |= r[g], f &= ~m;
      }
      return ti = o, Xo(), c;
    }
    function $_(r, o) {
      Ee = null, $.H = fl, o === ya || o === tl ? (o = lm(), Ve = 3) : o === rm ? (o = lm(), Ve = 4) : Ve = o === c_ ? 8 : o !== null && typeof o == "object" && typeof o.then == "function" ? 6 : 1, qt = o, Ce === null && (tt = 1, ml(r, sn(o, r.current)));
    }
    function X_() {
      var r = $.H;
      return $.H = fl, r === null ? fl : r;
    }
    function Y_() {
      var r = $.A;
      return $.A = bx, r;
    }
    function $f() {
      tt = 4, Ai || (Ie & 4194048) !== Ie && ln.current !== null || (cr = true), (wi & 134217727) === 0 && (ds & 134217727) === 0 || qe === null || Ci(qe, Ie, cn, false);
    }
    function Xf(r, o, c) {
      var f = Fe;
      Fe |= 2;
      var g = X_(), m = Y_();
      (qe !== r || Ie !== o) && (Sl = null, dr(r, o)), o = false;
      var b = tt;
      e: do
        try {
          if (Ve !== 0 && Ce !== null) {
            var T = Ce, w = qt;
            switch (Ve) {
              case 8:
                Wf(), b = 6;
                break e;
              case 3:
              case 2:
              case 9:
              case 6:
                ln.current === null && (o = true);
                var z = Ve;
                if (Ve = 0, qt = null, gr(r, T, w, z), c && cr) {
                  b = 0;
                  break e;
                }
                break;
              default:
                z = Ve, Ve = 0, qt = null, gr(r, T, w, z);
            }
          }
          xx(), b = tt;
          break;
        } catch (X) {
          $_(r, X);
        }
      while (true);
      return o && r.shellSuspendCounter++, Yn = os = null, Fe = f, $.H = g, $.A = m, Ce === null && (qe = null, Ie = 0, Xo()), b;
    }
    function xx() {
      for (; Ce !== null; ) q_(Ce);
    }
    function Sx(r, o) {
      var c = Fe;
      Fe |= 2;
      var f = X_(), g = Y_();
      qe !== r || Ie !== o ? (Sl = null, xl = wn() + 500, dr(r, o)) : cr = Jr(r, o);
      e: do
        try {
          if (Ve !== 0 && Ce !== null) {
            o = Ce;
            var m = qt;
            t: switch (Ve) {
              case 1:
                Ve = 0, qt = null, gr(r, o, m, 1);
                break;
              case 2:
              case 9:
                if (am(m)) {
                  Ve = 0, qt = null, K_(o);
                  break;
                }
                o = function() {
                  Ve !== 2 && Ve !== 9 || qe !== r || (Ve = 7), On(r);
                }, m.then(o, o);
                break e;
              case 3:
                Ve = 7;
                break e;
              case 4:
                Ve = 5;
                break e;
              case 7:
                am(m) ? (Ve = 0, qt = null, K_(o)) : (Ve = 0, qt = null, gr(r, o, m, 7));
                break;
              case 5:
                var b = null;
                switch (Ce.tag) {
                  case 26:
                    b = Ce.memoizedState;
                  case 5:
                  case 27:
                    var T = Ce;
                    if (!b || Oy(b)) {
                      Ve = 0, qt = null;
                      var w = T.sibling;
                      if (w !== null) Ce = w;
                      else {
                        var z = T.return;
                        z !== null ? (Ce = z, wl(z)) : Ce = null;
                      }
                      break t;
                    }
                }
                Ve = 0, qt = null, gr(r, o, m, 5);
                break;
              case 6:
                Ve = 0, qt = null, gr(r, o, m, 6);
                break;
              case 8:
                Wf(), tt = 6;
                break e;
              default:
                throw Error(i(462));
            }
          }
          Ax();
          break;
        } catch (X) {
          $_(r, X);
        }
      while (true);
      return Yn = os = null, $.H = f, $.A = g, Fe = c, Ce !== null ? 0 : (qe = null, Ie = 0, Xo(), tt);
    }
    function Ax() {
      for (; Ce !== null && !XT(); ) q_(Ce);
    }
    function q_(r) {
      var o = T_(r.alternate, r, ti);
      r.memoizedProps = r.pendingProps, o === null ? wl(r) : Ce = o;
    }
    function K_(r) {
      var o = r, c = o.alternate;
      switch (o.tag) {
        case 15:
        case 0:
          o = p_(c, o, o.pendingProps, o.type, void 0, Ie);
          break;
        case 11:
          o = p_(c, o, o.pendingProps, o.type.render, o.ref, Ie);
          break;
        case 5:
          of(o);
        default:
          S_(c, o), o = Ce = Zp(o, ti), o = T_(c, o, ti);
      }
      r.memoizedProps = r.pendingProps, o === null ? wl(r) : Ce = o;
    }
    function gr(r, o, c, f) {
      Yn = os = null, of(o), rr = null, Ra = 0;
      var g = o.return;
      try {
        if (dx(r, g, o, c, Ie)) {
          tt = 1, ml(r, sn(c, r.current)), Ce = null;
          return;
        }
      } catch (m) {
        if (g !== null) throw Ce = g, m;
        tt = 1, ml(r, sn(c, r.current)), Ce = null;
        return;
      }
      o.flags & 32768 ? (De || f === 1 ? r = true : cr || (Ie & 536870912) !== 0 ? r = false : (Ai = r = true, (f === 2 || f === 9 || f === 3 || f === 6) && (f = ln.current, f !== null && f.tag === 13 && (f.flags |= 16384))), Z_(o, r)) : wl(o);
    }
    function wl(r) {
      var o = r;
      do {
        if ((o.flags & 32768) !== 0) {
          Z_(o, Ai);
          return;
        }
        r = o.return;
        var c = px(o.alternate, o, ti);
        if (c !== null) {
          Ce = c;
          return;
        }
        if (o = o.sibling, o !== null) {
          Ce = o;
          return;
        }
        Ce = o = r;
      } while (o !== null);
      tt === 0 && (tt = 5);
    }
    function Z_(r, o) {
      do {
        var c = mx(r.alternate, r);
        if (c !== null) {
          c.flags &= 32767, Ce = c;
          return;
        }
        if (c = r.return, c !== null && (c.flags |= 32768, c.subtreeFlags = 0, c.deletions = null), !o && (r = r.sibling, r !== null)) {
          Ce = r;
          return;
        }
        Ce = r = c;
      } while (r !== null);
      tt = 6, Ce = null;
    }
    function Q_(r, o, c, f, g, m, b, T, w) {
      r.cancelPendingCommit = null;
      do
        El();
      while (xt !== 0);
      if ((Fe & 6) !== 0) throw Error(i(327));
      if (o !== null) {
        if (o === r.current) throw Error(i(177));
        if (m = o.lanes | o.childLanes, m |= ku, n1(r, c, m, b, T, w), r === qe && (Ce = qe = null, Ie = 0), fr = o, Ri = r, hr = c, zf = m, Hf = g, z_ = f, (o.subtreeFlags & 10256) !== 0 || (o.flags & 10256) !== 0 ? (r.callbackNode = null, r.callbackPriority = 0, Cx(Io, function() {
          return ny(), null;
        })) : (r.callbackNode = null, r.callbackPriority = 0), f = (o.flags & 13878) !== 0, (o.subtreeFlags & 13878) !== 0 || f) {
          f = $.T, $.T = null, g = ne.p, ne.p = 2, b = Fe, Fe |= 4;
          try {
            _x(r, o, c);
          } finally {
            Fe = b, ne.p = g, $.T = f;
          }
        }
        xt = 1, G_(), J_(), ey();
      }
    }
    function G_() {
      if (xt === 1) {
        xt = 0;
        var r = Ri, o = fr, c = (o.flags & 13878) !== 0;
        if ((o.subtreeFlags & 13878) !== 0 || c) {
          c = $.T, $.T = null;
          var f = ne.p;
          ne.p = 2;
          var g = Fe;
          Fe |= 4;
          try {
            D_(o, r);
            var m = sh, b = Vp(r.containerInfo), T = m.focusedElem, w = m.selectionRange;
            if (b !== T && T && T.ownerDocument && Fp(T.ownerDocument.documentElement, T)) {
              if (w !== null && Ou(T)) {
                var z = w.start, X = w.end;
                if (X === void 0 && (X = z), "selectionStart" in T) T.selectionStart = z, T.selectionEnd = Math.min(X, T.value.length);
                else {
                  var K = T.ownerDocument || document, j = K && K.defaultView || window;
                  if (j.getSelection) {
                    var W = j.getSelection(), be = T.textContent.length, pe = Math.min(w.start, be), je = w.end === void 0 ? pe : Math.min(w.end, be);
                    !W.extend && pe > je && (b = je, je = pe, pe = b);
                    var D = Lp(T, pe), C = Lp(T, je);
                    if (D && C && (W.rangeCount !== 1 || W.anchorNode !== D.node || W.anchorOffset !== D.offset || W.focusNode !== C.node || W.focusOffset !== C.offset)) {
                      var V = K.createRange();
                      V.setStart(D.node, D.offset), W.removeAllRanges(), pe > je ? (W.addRange(V), W.extend(C.node, C.offset)) : (V.setEnd(C.node, C.offset), W.addRange(V));
                    }
                  }
                }
              }
              for (K = [], W = T; W = W.parentNode; ) W.nodeType === 1 && K.push({
                element: W,
                left: W.scrollLeft,
                top: W.scrollTop
              });
              for (typeof T.focus == "function" && T.focus(), T = 0; T < K.length; T++) {
                var Y = K[T];
                Y.element.scrollLeft = Y.left, Y.element.scrollTop = Y.top;
              }
            }
            Ll = !!ih, sh = ih = null;
          } finally {
            Fe = g, ne.p = f, $.T = c;
          }
        }
        r.current = o, xt = 2;
      }
    }
    function J_() {
      if (xt === 2) {
        xt = 0;
        var r = Ri, o = fr, c = (o.flags & 8772) !== 0;
        if ((o.subtreeFlags & 8772) !== 0 || c) {
          c = $.T, $.T = null;
          var f = ne.p;
          ne.p = 2;
          var g = Fe;
          Fe |= 4;
          try {
            O_(r, o.alternate, o);
          } finally {
            Fe = g, ne.p = f, $.T = c;
          }
        }
        xt = 3;
      }
    }
    function ey() {
      if (xt === 4 || xt === 3) {
        xt = 0, YT();
        var r = Ri, o = fr, c = hr, f = z_;
        (o.subtreeFlags & 10256) !== 0 || (o.flags & 10256) !== 0 ? xt = 5 : (xt = 0, fr = Ri = null, ty(r, r.pendingLanes));
        var g = r.pendingLanes;
        if (g === 0 && (Ei = null), cu(c), o = o.stateNode, Ht && typeof Ht.onCommitFiberRoot == "function") try {
          Ht.onCommitFiberRoot(Gr, o, void 0, (o.current.flags & 128) === 128);
        } catch {
        }
        if (f !== null) {
          o = $.T, g = ne.p, ne.p = 2, $.T = null;
          try {
            for (var m = r.onRecoverableError, b = 0; b < f.length; b++) {
              var T = f[b];
              m(T.value, {
                componentStack: T.stack
              });
            }
          } finally {
            $.T = o, ne.p = g;
          }
        }
        (hr & 3) !== 0 && El(), On(r), g = r.pendingLanes, (c & 4194090) !== 0 && (g & 42) !== 0 ? r === jf ? Ua++ : (Ua = 0, jf = r) : Ua = 0, Ba(0);
      }
    }
    function ty(r, o) {
      (r.pooledCacheLanes &= o) === 0 && (o = r.pooledCache, o != null && (r.pooledCache = null, ma(o)));
    }
    function El(r) {
      return G_(), J_(), ey(), ny();
    }
    function ny() {
      if (xt !== 5) return false;
      var r = Ri, o = zf;
      zf = 0;
      var c = cu(hr), f = $.T, g = ne.p;
      try {
        ne.p = 32 > c ? 32 : c, $.T = null, c = Hf, Hf = null;
        var m = Ri, b = hr;
        if (xt = 0, fr = Ri = null, hr = 0, (Fe & 6) !== 0) throw Error(i(331));
        var T = Fe;
        if (Fe |= 4, F_(m.current), U_(m, m.current, b, c), Fe = T, Ba(0, false), Ht && typeof Ht.onPostCommitFiberRoot == "function") try {
          Ht.onPostCommitFiberRoot(Gr, m);
        } catch {
        }
        return true;
      } finally {
        ne.p = g, $.T = f, ty(r, o);
      }
    }
    function iy(r, o, c) {
      o = sn(c, o), o = Tf(r.stateNode, o, 2), r = _i(r, o, 2), r !== null && (ea(r, 2), On(r));
    }
    function Ye(r, o, c) {
      if (r.tag === 3) iy(r, r, c);
      else for (; o !== null; ) {
        if (o.tag === 3) {
          iy(o, r, c);
          break;
        } else if (o.tag === 1) {
          var f = o.stateNode;
          if (typeof o.type.getDerivedStateFromError == "function" || typeof f.componentDidCatch == "function" && (Ei === null || !Ei.has(f))) {
            r = sn(c, r), c = o_(2), f = _i(o, c, 2), f !== null && (l_(c, f, o, r), ea(f, 2), On(f));
            break;
          }
        }
        o = o.return;
      }
    }
    function Yf(r, o, c) {
      var f = r.pingCache;
      if (f === null) {
        f = r.pingCache = new vx();
        var g = /* @__PURE__ */ new Set();
        f.set(o, g);
      } else g = f.get(o), g === void 0 && (g = /* @__PURE__ */ new Set(), f.set(o, g));
      g.has(c) || (Bf = true, g.add(c), r = wx.bind(null, r, o, c), o.then(r, r));
    }
    function wx(r, o, c) {
      var f = r.pingCache;
      f !== null && f.delete(o), r.pingedLanes |= r.suspendedLanes & c, r.warmLanes &= ~c, qe === r && (Ie & c) === c && (tt === 4 || tt === 3 && (Ie & 62914560) === Ie && 300 > wn() - Vf ? (Fe & 2) === 0 && dr(r, 0) : Lf |= c, ur === Ie && (ur = 0)), On(r);
    }
    function sy(r, o) {
      o === 0 && (o = ep()), r = Ks(r, o), r !== null && (ea(r, o), On(r));
    }
    function Ex(r) {
      var o = r.memoizedState, c = 0;
      o !== null && (c = o.retryLane), sy(r, c);
    }
    function Rx(r, o) {
      var c = 0;
      switch (r.tag) {
        case 13:
          var f = r.stateNode, g = r.memoizedState;
          g !== null && (c = g.retryLane);
          break;
        case 19:
          f = r.stateNode;
          break;
        case 22:
          f = r.stateNode._retryCache;
          break;
        default:
          throw Error(i(314));
      }
      f !== null && f.delete(o), sy(r, c);
    }
    function Cx(r, o) {
      return Zi(r, o);
    }
    var Rl = null, pr = null, qf = false, Cl = false, Kf = false, gs = 0;
    function On(r) {
      r !== pr && r.next === null && (pr === null ? Rl = pr = r : pr = pr.next = r), Cl = true, qf || (qf = true, Ox());
    }
    function Ba(r, o) {
      if (!Kf && Cl) {
        Kf = true;
        do
          for (var c = false, f = Rl; f !== null; ) {
            if (r !== 0) {
              var g = f.pendingLanes;
              if (g === 0) var m = 0;
              else {
                var b = f.suspendedLanes, T = f.pingedLanes;
                m = (1 << 31 - jt(42 | r) + 1) - 1, m &= g & ~(b & ~T), m = m & 201326741 ? m & 201326741 | 1 : m ? m | 2 : 0;
              }
              m !== 0 && (c = true, ly(f, m));
            } else m = Ie, m = Do(f, f === qe ? m : 0, f.cancelPendingCommit !== null || f.timeoutHandle !== -1), (m & 3) === 0 || Jr(f, m) || (c = true, ly(f, m));
            f = f.next;
          }
        while (c);
        Kf = false;
      }
    }
    function Mx() {
      ry();
    }
    function ry() {
      Cl = qf = false;
      var r = 0;
      gs !== 0 && (Lx() && (r = gs), gs = 0);
      for (var o = wn(), c = null, f = Rl; f !== null; ) {
        var g = f.next, m = ay(f, o);
        m === 0 ? (f.next = null, c === null ? Rl = g : c.next = g, g === null && (pr = c)) : (c = f, (r !== 0 || (m & 3) !== 0) && (Cl = true)), f = g;
      }
      Ba(r);
    }
    function ay(r, o) {
      for (var c = r.suspendedLanes, f = r.pingedLanes, g = r.expirationTimes, m = r.pendingLanes & -62914561; 0 < m; ) {
        var b = 31 - jt(m), T = 1 << b, w = g[b];
        w === -1 ? ((T & c) === 0 || (T & f) !== 0) && (g[b] = t1(T, o)) : w <= o && (r.expiredLanes |= T), m &= ~T;
      }
      if (o = qe, c = Ie, c = Do(r, r === o ? c : 0, r.cancelPendingCommit !== null || r.timeoutHandle !== -1), f = r.callbackNode, c === 0 || r === o && (Ve === 2 || Ve === 9) || r.cancelPendingCommit !== null) return f !== null && f !== null && au(f), r.callbackNode = null, r.callbackPriority = 0;
      if ((c & 3) === 0 || Jr(r, c)) {
        if (o = c & -c, o === r.callbackPriority) return o;
        switch (f !== null && au(f), cu(c)) {
          case 2:
          case 8:
            c = Qg;
            break;
          case 32:
            c = Io;
            break;
          case 268435456:
            c = Gg;
            break;
          default:
            c = Io;
        }
        return f = oy.bind(null, r), c = Zi(c, f), r.callbackPriority = o, r.callbackNode = c, o;
      }
      return f !== null && f !== null && au(f), r.callbackPriority = 2, r.callbackNode = null, 2;
    }
    function oy(r, o) {
      if (xt !== 0 && xt !== 5) return r.callbackNode = null, r.callbackPriority = 0, null;
      var c = r.callbackNode;
      if (El() && r.callbackNode !== c) return null;
      var f = Ie;
      return f = Do(r, r === qe ? f : 0, r.cancelPendingCommit !== null || r.timeoutHandle !== -1), f === 0 ? null : (j_(r, f, o), ay(r, wn()), r.callbackNode != null && r.callbackNode === c ? oy.bind(null, r) : null);
    }
    function ly(r, o) {
      if (El()) return null;
      j_(r, o, true);
    }
    function Ox() {
      Vx(function() {
        (Fe & 6) !== 0 ? Zi(Zg, Mx) : ry();
      });
    }
    function Zf() {
      return gs === 0 && (gs = Jg()), gs;
    }
    function cy(r) {
      return r == null || typeof r == "symbol" || typeof r == "boolean" ? null : typeof r == "function" ? r : Fo("" + r);
    }
    function uy(r, o) {
      var c = o.ownerDocument.createElement("input");
      return c.name = o.name, c.value = o.value, r.id && c.setAttribute("form", r.id), o.parentNode.insertBefore(c, o), r = new FormData(r), c.parentNode.removeChild(c), r;
    }
    function Ix(r, o, c, f, g) {
      if (o === "submit" && c && c.stateNode === g) {
        var m = cy((g[Dt] || null).action), b = f.submitter;
        b && (o = (o = b[Dt] || null) ? cy(o.formAction) : b.getAttribute("formAction"), o !== null && (m = o, b = null));
        var T = new jo("action", "action", null, f, g);
        r.push({
          event: T,
          listeners: [
            {
              instance: null,
              listener: function() {
                if (f.defaultPrevented) {
                  if (gs !== 0) {
                    var w = b ? uy(g, b) : new FormData(g);
                    mf(c, {
                      pending: true,
                      data: w,
                      method: g.method,
                      action: m
                    }, null, w);
                  }
                } else typeof m == "function" && (T.preventDefault(), w = b ? uy(g, b) : new FormData(g), mf(c, {
                  pending: true,
                  data: w,
                  method: g.method,
                  action: m
                }, m, w));
              },
              currentTarget: g
            }
          ]
        });
      }
    }
    for (var Qf = 0; Qf < Du.length; Qf++) {
      var Gf = Du[Qf], Nx = Gf.toLowerCase(), Px = Gf[0].toUpperCase() + Gf.slice(1);
      yn(Nx, "on" + Px);
    }
    yn(jp, "onAnimationEnd"), yn(Wp, "onAnimationIteration"), yn($p, "onAnimationStart"), yn("dblclick", "onDoubleClick"), yn("focusin", "onFocus"), yn("focusout", "onBlur"), yn(Z1, "onTransitionRun"), yn(Q1, "onTransitionStart"), yn(G1, "onTransitionCancel"), yn(Xp, "onTransitionEnd"), Fs("onMouseEnter", [
      "mouseout",
      "mouseover"
    ]), Fs("onMouseLeave", [
      "mouseout",
      "mouseover"
    ]), Fs("onPointerEnter", [
      "pointerout",
      "pointerover"
    ]), Fs("onPointerLeave", [
      "pointerout",
      "pointerover"
    ]), Gi("onChange", "change click focusin focusout input keydown keyup selectionchange".split(" ")), Gi("onSelect", "focusout contextmenu dragend focusin keydown keyup mousedown mouseup selectionchange".split(" ")), Gi("onBeforeInput", [
      "compositionend",
      "keypress",
      "textInput",
      "paste"
    ]), Gi("onCompositionEnd", "compositionend focusout keydown keypress keyup mousedown".split(" ")), Gi("onCompositionStart", "compositionstart focusout keydown keypress keyup mousedown".split(" ")), Gi("onCompositionUpdate", "compositionupdate focusout keydown keypress keyup mousedown".split(" "));
    var La = "abort canplay canplaythrough durationchange emptied encrypted ended error loadeddata loadedmetadata loadstart pause play playing progress ratechange resize seeked seeking stalled suspend timeupdate volumechange waiting".split(" "), Dx = new Set("beforetoggle cancel close invalid load scroll scrollend toggle".split(" ").concat(La));
    function fy(r, o) {
      o = (o & 4) !== 0;
      for (var c = 0; c < r.length; c++) {
        var f = r[c], g = f.event;
        f = f.listeners;
        e: {
          var m = void 0;
          if (o) for (var b = f.length - 1; 0 <= b; b--) {
            var T = f[b], w = T.instance, z = T.currentTarget;
            if (T = T.listener, w !== m && g.isPropagationStopped()) break e;
            m = T, g.currentTarget = z;
            try {
              m(g);
            } catch (X) {
              pl(X);
            }
            g.currentTarget = null, m = w;
          }
          else for (b = 0; b < f.length; b++) {
            if (T = f[b], w = T.instance, z = T.currentTarget, T = T.listener, w !== m && g.isPropagationStopped()) break e;
            m = T, g.currentTarget = z;
            try {
              m(g);
            } catch (X) {
              pl(X);
            }
            g.currentTarget = null, m = w;
          }
        }
      }
    }
    function Me(r, o) {
      var c = o[uu];
      c === void 0 && (c = o[uu] = /* @__PURE__ */ new Set());
      var f = r + "__bubble";
      c.has(f) || (hy(o, r, 2, false), c.add(f));
    }
    function Jf(r, o, c) {
      var f = 0;
      o && (f |= 4), hy(c, r, f, o);
    }
    var Ml = "_reactListening" + Math.random().toString(36).slice(2);
    function eh(r) {
      if (!r[Ml]) {
        r[Ml] = true, rp.forEach(function(c) {
          c !== "selectionchange" && (Dx.has(c) || Jf(c, false, r), Jf(c, true, r));
        });
        var o = r.nodeType === 9 ? r : r.ownerDocument;
        o === null || o[Ml] || (o[Ml] = true, Jf("selectionchange", false, o));
      }
    }
    function hy(r, o, c, f) {
      switch (Uy(o)) {
        case 2:
          var g = oS;
          break;
        case 8:
          g = lS;
          break;
        default:
          g = gh;
      }
      c = g.bind(null, o, c, r), g = void 0, !Tu || o !== "touchstart" && o !== "touchmove" && o !== "wheel" || (g = true), f ? g !== void 0 ? r.addEventListener(o, c, {
        capture: true,
        passive: g
      }) : r.addEventListener(o, c, true) : g !== void 0 ? r.addEventListener(o, c, {
        passive: g
      }) : r.addEventListener(o, c, false);
    }
    function th(r, o, c, f, g) {
      var m = f;
      if ((o & 1) === 0 && (o & 2) === 0 && f !== null) e: for (; ; ) {
        if (f === null) return;
        var b = f.tag;
        if (b === 3 || b === 4) {
          var T = f.stateNode.containerInfo;
          if (T === g) break;
          if (b === 4) for (b = f.return; b !== null; ) {
            var w = b.tag;
            if ((w === 3 || w === 4) && b.stateNode.containerInfo === g) return;
            b = b.return;
          }
          for (; T !== null; ) {
            if (b = Us(T), b === null) return;
            if (w = b.tag, w === 5 || w === 6 || w === 26 || w === 27) {
              f = m = b;
              continue e;
            }
            T = T.parentNode;
          }
        }
        f = f.return;
      }
      bp(function() {
        var z = m, X = bu(c), K = [];
        e: {
          var j = Yp.get(r);
          if (j !== void 0) {
            var W = jo, be = r;
            switch (r) {
              case "keypress":
                if (zo(c) === 0) break e;
              case "keydown":
              case "keyup":
                W = C1;
                break;
              case "focusin":
                be = "focus", W = wu;
                break;
              case "focusout":
                be = "blur", W = wu;
                break;
              case "beforeblur":
              case "afterblur":
                W = wu;
                break;
              case "click":
                if (c.button === 2) break e;
              case "auxclick":
              case "dblclick":
              case "mousedown":
              case "mousemove":
              case "mouseup":
              case "mouseout":
              case "mouseover":
              case "contextmenu":
                W = xp;
                break;
              case "drag":
              case "dragend":
              case "dragenter":
              case "dragexit":
              case "dragleave":
              case "dragover":
              case "dragstart":
              case "drop":
                W = m1;
                break;
              case "touchcancel":
              case "touchend":
              case "touchmove":
              case "touchstart":
                W = I1;
                break;
              case jp:
              case Wp:
              case $p:
                W = b1;
                break;
              case Xp:
                W = P1;
                break;
              case "scroll":
              case "scrollend":
                W = g1;
                break;
              case "wheel":
                W = k1;
                break;
              case "copy":
              case "cut":
              case "paste":
                W = T1;
                break;
              case "gotpointercapture":
              case "lostpointercapture":
              case "pointercancel":
              case "pointerdown":
              case "pointermove":
              case "pointerout":
              case "pointerover":
              case "pointerup":
                W = Ap;
                break;
              case "toggle":
              case "beforetoggle":
                W = B1;
            }
            var pe = (o & 4) !== 0, je = !pe && (r === "scroll" || r === "scrollend"), D = pe ? j !== null ? j + "Capture" : null : j;
            pe = [];
            for (var C = z, V; C !== null; ) {
              var Y = C;
              if (V = Y.stateNode, Y = Y.tag, Y !== 5 && Y !== 26 && Y !== 27 || V === null || D === null || (Y = ia(C, D), Y != null && pe.push(Fa(C, Y, V))), je) break;
              C = C.return;
            }
            0 < pe.length && (j = new W(j, be, null, c, X), K.push({
              event: j,
              listeners: pe
            }));
          }
        }
        if ((o & 7) === 0) {
          e: {
            if (j = r === "mouseover" || r === "pointerover", W = r === "mouseout" || r === "pointerout", j && c !== yu && (be = c.relatedTarget || c.fromElement) && (Us(be) || be[ks])) break e;
            if ((W || j) && (j = X.window === X ? X : (j = X.ownerDocument) ? j.defaultView || j.parentWindow : window, W ? (be = c.relatedTarget || c.toElement, W = z, be = be ? Us(be) : null, be !== null && (je = a(be), pe = be.tag, be !== je || pe !== 5 && pe !== 27 && pe !== 6) && (be = null)) : (W = null, be = z), W !== be)) {
              if (pe = xp, Y = "onMouseLeave", D = "onMouseEnter", C = "mouse", (r === "pointerout" || r === "pointerover") && (pe = Ap, Y = "onPointerLeave", D = "onPointerEnter", C = "pointer"), je = W == null ? j : na(W), V = be == null ? j : na(be), j = new pe(Y, C + "leave", W, c, X), j.target = je, j.relatedTarget = V, Y = null, Us(X) === z && (pe = new pe(D, C + "enter", be, c, X), pe.target = V, pe.relatedTarget = je, Y = pe), je = Y, W && be) t: {
                for (pe = W, D = be, C = 0, V = pe; V; V = mr(V)) C++;
                for (V = 0, Y = D; Y; Y = mr(Y)) V++;
                for (; 0 < C - V; ) pe = mr(pe), C--;
                for (; 0 < V - C; ) D = mr(D), V--;
                for (; C--; ) {
                  if (pe === D || D !== null && pe === D.alternate) break t;
                  pe = mr(pe), D = mr(D);
                }
                pe = null;
              }
              else pe = null;
              W !== null && dy(K, j, W, pe, false), be !== null && je !== null && dy(K, je, be, pe, true);
            }
          }
          e: {
            if (j = z ? na(z) : window, W = j.nodeName && j.nodeName.toLowerCase(), W === "select" || W === "input" && j.type === "file") var ce = Np;
            else if (Op(j)) if (Pp) ce = Y1;
            else {
              ce = $1;
              var Re = W1;
            }
            else W = j.nodeName, !W || W.toLowerCase() !== "input" || j.type !== "checkbox" && j.type !== "radio" ? z && _u(z.elementType) && (ce = Np) : ce = X1;
            if (ce && (ce = ce(r, z))) {
              Ip(K, ce, c, X);
              break e;
            }
            Re && Re(r, j, z), r === "focusout" && z && j.type === "number" && z.memoizedProps.value != null && mu(j, "number", j.value);
          }
          switch (Re = z ? na(z) : window, r) {
            case "focusin":
              (Op(Re) || Re.contentEditable === "true") && (Xs = Re, Iu = z, fa = null);
              break;
            case "focusout":
              fa = Iu = Xs = null;
              break;
            case "mousedown":
              Nu = true;
              break;
            case "contextmenu":
            case "mouseup":
            case "dragend":
              Nu = false, zp(K, c, X);
              break;
            case "selectionchange":
              if (K1) break;
            case "keydown":
            case "keyup":
              zp(K, c, X);
          }
          var ge;
          if (Ru) e: {
            switch (r) {
              case "compositionstart":
                var me = "onCompositionStart";
                break e;
              case "compositionend":
                me = "onCompositionEnd";
                break e;
              case "compositionupdate":
                me = "onCompositionUpdate";
                break e;
            }
            me = void 0;
          }
          else $s ? Cp(r, c) && (me = "onCompositionEnd") : r === "keydown" && c.keyCode === 229 && (me = "onCompositionStart");
          me && (wp && c.locale !== "ko" && ($s || me !== "onCompositionStart" ? me === "onCompositionEnd" && $s && (ge = vp()) : (di = X, xu = "value" in di ? di.value : di.textContent, $s = true)), Re = Ol(z, me), 0 < Re.length && (me = new Sp(me, r, null, c, X), K.push({
            event: me,
            listeners: Re
          }), ge ? me.data = ge : (ge = Mp(c), ge !== null && (me.data = ge)))), (ge = F1 ? V1(r, c) : z1(r, c)) && (me = Ol(z, "onBeforeInput"), 0 < me.length && (Re = new Sp("onBeforeInput", "beforeinput", null, c, X), K.push({
            event: Re,
            listeners: me
          }), Re.data = ge)), Ix(K, r, z, c, X);
        }
        fy(K, o);
      });
    }
    function Fa(r, o, c) {
      return {
        instance: r,
        listener: o,
        currentTarget: c
      };
    }
    function Ol(r, o) {
      for (var c = o + "Capture", f = []; r !== null; ) {
        var g = r, m = g.stateNode;
        if (g = g.tag, g !== 5 && g !== 26 && g !== 27 || m === null || (g = ia(r, c), g != null && f.unshift(Fa(r, g, m)), g = ia(r, o), g != null && f.push(Fa(r, g, m))), r.tag === 3) return f;
        r = r.return;
      }
      return [];
    }
    function mr(r) {
      if (r === null) return null;
      do
        r = r.return;
      while (r && r.tag !== 5 && r.tag !== 27);
      return r || null;
    }
    function dy(r, o, c, f, g) {
      for (var m = o._reactName, b = []; c !== null && c !== f; ) {
        var T = c, w = T.alternate, z = T.stateNode;
        if (T = T.tag, w !== null && w === f) break;
        T !== 5 && T !== 26 && T !== 27 || z === null || (w = z, g ? (z = ia(c, m), z != null && b.unshift(Fa(c, z, w))) : g || (z = ia(c, m), z != null && b.push(Fa(c, z, w)))), c = c.return;
      }
      b.length !== 0 && r.push({
        event: o,
        listeners: b
      });
    }
    var kx = /\r\n?/g, Ux = /\u0000|\uFFFD/g;
    function gy(r) {
      return (typeof r == "string" ? r : "" + r).replace(kx, `
`).replace(Ux, "");
    }
    function py(r, o) {
      return o = gy(o), gy(r) === o;
    }
    function Il() {
    }
    function He(r, o, c, f, g, m) {
      switch (c) {
        case "children":
          typeof f == "string" ? o === "body" || o === "textarea" && f === "" || Hs(r, f) : (typeof f == "number" || typeof f == "bigint") && o !== "body" && Hs(r, "" + f);
          break;
        case "className":
          Uo(r, "class", f);
          break;
        case "tabIndex":
          Uo(r, "tabindex", f);
          break;
        case "dir":
        case "role":
        case "viewBox":
        case "width":
        case "height":
          Uo(r, c, f);
          break;
        case "style":
          _p(r, f, m);
          break;
        case "data":
          if (o !== "object") {
            Uo(r, "data", f);
            break;
          }
        case "src":
        case "href":
          if (f === "" && (o !== "a" || c !== "href")) {
            r.removeAttribute(c);
            break;
          }
          if (f == null || typeof f == "function" || typeof f == "symbol" || typeof f == "boolean") {
            r.removeAttribute(c);
            break;
          }
          f = Fo("" + f), r.setAttribute(c, f);
          break;
        case "action":
        case "formAction":
          if (typeof f == "function") {
            r.setAttribute(c, "javascript:throw new Error('A React form was unexpectedly submitted. If you called form.submit() manually, consider using form.requestSubmit() instead. If you\\'re trying to use event.stopPropagation() in a submit event handler, consider also calling event.preventDefault().')");
            break;
          } else typeof m == "function" && (c === "formAction" ? (o !== "input" && He(r, o, "name", g.name, g, null), He(r, o, "formEncType", g.formEncType, g, null), He(r, o, "formMethod", g.formMethod, g, null), He(r, o, "formTarget", g.formTarget, g, null)) : (He(r, o, "encType", g.encType, g, null), He(r, o, "method", g.method, g, null), He(r, o, "target", g.target, g, null)));
          if (f == null || typeof f == "symbol" || typeof f == "boolean") {
            r.removeAttribute(c);
            break;
          }
          f = Fo("" + f), r.setAttribute(c, f);
          break;
        case "onClick":
          f != null && (r.onclick = Il);
          break;
        case "onScroll":
          f != null && Me("scroll", r);
          break;
        case "onScrollEnd":
          f != null && Me("scrollend", r);
          break;
        case "dangerouslySetInnerHTML":
          if (f != null) {
            if (typeof f != "object" || !("__html" in f)) throw Error(i(61));
            if (c = f.__html, c != null) {
              if (g.children != null) throw Error(i(60));
              r.innerHTML = c;
            }
          }
          break;
        case "multiple":
          r.multiple = f && typeof f != "function" && typeof f != "symbol";
          break;
        case "muted":
          r.muted = f && typeof f != "function" && typeof f != "symbol";
          break;
        case "suppressContentEditableWarning":
        case "suppressHydrationWarning":
        case "defaultValue":
        case "defaultChecked":
        case "innerHTML":
        case "ref":
          break;
        case "autoFocus":
          break;
        case "xlinkHref":
          if (f == null || typeof f == "function" || typeof f == "boolean" || typeof f == "symbol") {
            r.removeAttribute("xlink:href");
            break;
          }
          c = Fo("" + f), r.setAttributeNS("http://www.w3.org/1999/xlink", "xlink:href", c);
          break;
        case "contentEditable":
        case "spellCheck":
        case "draggable":
        case "value":
        case "autoReverse":
        case "externalResourcesRequired":
        case "focusable":
        case "preserveAlpha":
          f != null && typeof f != "function" && typeof f != "symbol" ? r.setAttribute(c, "" + f) : r.removeAttribute(c);
          break;
        case "inert":
        case "allowFullScreen":
        case "async":
        case "autoPlay":
        case "controls":
        case "default":
        case "defer":
        case "disabled":
        case "disablePictureInPicture":
        case "disableRemotePlayback":
        case "formNoValidate":
        case "hidden":
        case "loop":
        case "noModule":
        case "noValidate":
        case "open":
        case "playsInline":
        case "readOnly":
        case "required":
        case "reversed":
        case "scoped":
        case "seamless":
        case "itemScope":
          f && typeof f != "function" && typeof f != "symbol" ? r.setAttribute(c, "") : r.removeAttribute(c);
          break;
        case "capture":
        case "download":
          f === true ? r.setAttribute(c, "") : f !== false && f != null && typeof f != "function" && typeof f != "symbol" ? r.setAttribute(c, f) : r.removeAttribute(c);
          break;
        case "cols":
        case "rows":
        case "size":
        case "span":
          f != null && typeof f != "function" && typeof f != "symbol" && !isNaN(f) && 1 <= f ? r.setAttribute(c, f) : r.removeAttribute(c);
          break;
        case "rowSpan":
        case "start":
          f == null || typeof f == "function" || typeof f == "symbol" || isNaN(f) ? r.removeAttribute(c) : r.setAttribute(c, f);
          break;
        case "popover":
          Me("beforetoggle", r), Me("toggle", r), ko(r, "popover", f);
          break;
        case "xlinkActuate":
          Hn(r, "http://www.w3.org/1999/xlink", "xlink:actuate", f);
          break;
        case "xlinkArcrole":
          Hn(r, "http://www.w3.org/1999/xlink", "xlink:arcrole", f);
          break;
        case "xlinkRole":
          Hn(r, "http://www.w3.org/1999/xlink", "xlink:role", f);
          break;
        case "xlinkShow":
          Hn(r, "http://www.w3.org/1999/xlink", "xlink:show", f);
          break;
        case "xlinkTitle":
          Hn(r, "http://www.w3.org/1999/xlink", "xlink:title", f);
          break;
        case "xlinkType":
          Hn(r, "http://www.w3.org/1999/xlink", "xlink:type", f);
          break;
        case "xmlBase":
          Hn(r, "http://www.w3.org/XML/1998/namespace", "xml:base", f);
          break;
        case "xmlLang":
          Hn(r, "http://www.w3.org/XML/1998/namespace", "xml:lang", f);
          break;
        case "xmlSpace":
          Hn(r, "http://www.w3.org/XML/1998/namespace", "xml:space", f);
          break;
        case "is":
          ko(r, "is", f);
          break;
        case "innerText":
        case "textContent":
          break;
        default:
          (!(2 < c.length) || c[0] !== "o" && c[0] !== "O" || c[1] !== "n" && c[1] !== "N") && (c = h1.get(c) || c, ko(r, c, f));
      }
    }
    function nh(r, o, c, f, g, m) {
      switch (c) {
        case "style":
          _p(r, f, m);
          break;
        case "dangerouslySetInnerHTML":
          if (f != null) {
            if (typeof f != "object" || !("__html" in f)) throw Error(i(61));
            if (c = f.__html, c != null) {
              if (g.children != null) throw Error(i(60));
              r.innerHTML = c;
            }
          }
          break;
        case "children":
          typeof f == "string" ? Hs(r, f) : (typeof f == "number" || typeof f == "bigint") && Hs(r, "" + f);
          break;
        case "onScroll":
          f != null && Me("scroll", r);
          break;
        case "onScrollEnd":
          f != null && Me("scrollend", r);
          break;
        case "onClick":
          f != null && (r.onclick = Il);
          break;
        case "suppressContentEditableWarning":
        case "suppressHydrationWarning":
        case "innerHTML":
        case "ref":
          break;
        case "innerText":
        case "textContent":
          break;
        default:
          if (!ap.hasOwnProperty(c)) e: {
            if (c[0] === "o" && c[1] === "n" && (g = c.endsWith("Capture"), o = c.slice(2, g ? c.length - 7 : void 0), m = r[Dt] || null, m = m != null ? m[c] : null, typeof m == "function" && r.removeEventListener(o, m, g), typeof f == "function")) {
              typeof m != "function" && m !== null && (c in r ? r[c] = null : r.hasAttribute(c) && r.removeAttribute(c)), r.addEventListener(o, f, g);
              break e;
            }
            c in r ? r[c] = f : f === true ? r.setAttribute(c, "") : ko(r, c, f);
          }
      }
    }
    function St(r, o, c) {
      switch (o) {
        case "div":
        case "span":
        case "svg":
        case "path":
        case "a":
        case "g":
        case "p":
        case "li":
          break;
        case "img":
          Me("error", r), Me("load", r);
          var f = false, g = false, m;
          for (m in c) if (c.hasOwnProperty(m)) {
            var b = c[m];
            if (b != null) switch (m) {
              case "src":
                f = true;
                break;
              case "srcSet":
                g = true;
                break;
              case "children":
              case "dangerouslySetInnerHTML":
                throw Error(i(137, o));
              default:
                He(r, o, m, b, c, null);
            }
          }
          g && He(r, o, "srcSet", c.srcSet, c, null), f && He(r, o, "src", c.src, c, null);
          return;
        case "input":
          Me("invalid", r);
          var T = m = b = g = null, w = null, z = null;
          for (f in c) if (c.hasOwnProperty(f)) {
            var X = c[f];
            if (X != null) switch (f) {
              case "name":
                g = X;
                break;
              case "type":
                b = X;
                break;
              case "checked":
                w = X;
                break;
              case "defaultChecked":
                z = X;
                break;
              case "value":
                m = X;
                break;
              case "defaultValue":
                T = X;
                break;
              case "children":
              case "dangerouslySetInnerHTML":
                if (X != null) throw Error(i(137, o));
                break;
              default:
                He(r, o, f, X, c, null);
            }
          }
          dp(r, m, T, w, z, b, g, false), Bo(r);
          return;
        case "select":
          Me("invalid", r), f = b = m = null;
          for (g in c) if (c.hasOwnProperty(g) && (T = c[g], T != null)) switch (g) {
            case "value":
              m = T;
              break;
            case "defaultValue":
              b = T;
              break;
            case "multiple":
              f = T;
            default:
              He(r, o, g, T, c, null);
          }
          o = m, c = b, r.multiple = !!f, o != null ? zs(r, !!f, o, false) : c != null && zs(r, !!f, c, true);
          return;
        case "textarea":
          Me("invalid", r), m = g = f = null;
          for (b in c) if (c.hasOwnProperty(b) && (T = c[b], T != null)) switch (b) {
            case "value":
              f = T;
              break;
            case "defaultValue":
              g = T;
              break;
            case "children":
              m = T;
              break;
            case "dangerouslySetInnerHTML":
              if (T != null) throw Error(i(91));
              break;
            default:
              He(r, o, b, T, c, null);
          }
          pp(r, f, g, m), Bo(r);
          return;
        case "option":
          for (w in c) if (c.hasOwnProperty(w) && (f = c[w], f != null)) switch (w) {
            case "selected":
              r.selected = f && typeof f != "function" && typeof f != "symbol";
              break;
            default:
              He(r, o, w, f, c, null);
          }
          return;
        case "dialog":
          Me("beforetoggle", r), Me("toggle", r), Me("cancel", r), Me("close", r);
          break;
        case "iframe":
        case "object":
          Me("load", r);
          break;
        case "video":
        case "audio":
          for (f = 0; f < La.length; f++) Me(La[f], r);
          break;
        case "image":
          Me("error", r), Me("load", r);
          break;
        case "details":
          Me("toggle", r);
          break;
        case "embed":
        case "source":
        case "link":
          Me("error", r), Me("load", r);
        case "area":
        case "base":
        case "br":
        case "col":
        case "hr":
        case "keygen":
        case "meta":
        case "param":
        case "track":
        case "wbr":
        case "menuitem":
          for (z in c) if (c.hasOwnProperty(z) && (f = c[z], f != null)) switch (z) {
            case "children":
            case "dangerouslySetInnerHTML":
              throw Error(i(137, o));
            default:
              He(r, o, z, f, c, null);
          }
          return;
        default:
          if (_u(o)) {
            for (X in c) c.hasOwnProperty(X) && (f = c[X], f !== void 0 && nh(r, o, X, f, c, void 0));
            return;
          }
      }
      for (T in c) c.hasOwnProperty(T) && (f = c[T], f != null && He(r, o, T, f, c, null));
    }
    function Bx(r, o, c, f) {
      switch (o) {
        case "div":
        case "span":
        case "svg":
        case "path":
        case "a":
        case "g":
        case "p":
        case "li":
          break;
        case "input":
          var g = null, m = null, b = null, T = null, w = null, z = null, X = null;
          for (W in c) {
            var K = c[W];
            if (c.hasOwnProperty(W) && K != null) switch (W) {
              case "checked":
                break;
              case "value":
                break;
              case "defaultValue":
                w = K;
              default:
                f.hasOwnProperty(W) || He(r, o, W, null, f, K);
            }
          }
          for (var j in f) {
            var W = f[j];
            if (K = c[j], f.hasOwnProperty(j) && (W != null || K != null)) switch (j) {
              case "type":
                m = W;
                break;
              case "name":
                g = W;
                break;
              case "checked":
                z = W;
                break;
              case "defaultChecked":
                X = W;
                break;
              case "value":
                b = W;
                break;
              case "defaultValue":
                T = W;
                break;
              case "children":
              case "dangerouslySetInnerHTML":
                if (W != null) throw Error(i(137, o));
                break;
              default:
                W !== K && He(r, o, j, W, f, K);
            }
          }
          pu(r, b, T, w, z, X, m, g);
          return;
        case "select":
          W = b = T = j = null;
          for (m in c) if (w = c[m], c.hasOwnProperty(m) && w != null) switch (m) {
            case "value":
              break;
            case "multiple":
              W = w;
            default:
              f.hasOwnProperty(m) || He(r, o, m, null, f, w);
          }
          for (g in f) if (m = f[g], w = c[g], f.hasOwnProperty(g) && (m != null || w != null)) switch (g) {
            case "value":
              j = m;
              break;
            case "defaultValue":
              T = m;
              break;
            case "multiple":
              b = m;
            default:
              m !== w && He(r, o, g, m, f, w);
          }
          o = T, c = b, f = W, j != null ? zs(r, !!c, j, false) : !!f != !!c && (o != null ? zs(r, !!c, o, true) : zs(r, !!c, c ? [] : "", false));
          return;
        case "textarea":
          W = j = null;
          for (T in c) if (g = c[T], c.hasOwnProperty(T) && g != null && !f.hasOwnProperty(T)) switch (T) {
            case "value":
              break;
            case "children":
              break;
            default:
              He(r, o, T, null, f, g);
          }
          for (b in f) if (g = f[b], m = c[b], f.hasOwnProperty(b) && (g != null || m != null)) switch (b) {
            case "value":
              j = g;
              break;
            case "defaultValue":
              W = g;
              break;
            case "children":
              break;
            case "dangerouslySetInnerHTML":
              if (g != null) throw Error(i(91));
              break;
            default:
              g !== m && He(r, o, b, g, f, m);
          }
          gp(r, j, W);
          return;
        case "option":
          for (var be in c) if (j = c[be], c.hasOwnProperty(be) && j != null && !f.hasOwnProperty(be)) switch (be) {
            case "selected":
              r.selected = false;
              break;
            default:
              He(r, o, be, null, f, j);
          }
          for (w in f) if (j = f[w], W = c[w], f.hasOwnProperty(w) && j !== W && (j != null || W != null)) switch (w) {
            case "selected":
              r.selected = j && typeof j != "function" && typeof j != "symbol";
              break;
            default:
              He(r, o, w, j, f, W);
          }
          return;
        case "img":
        case "link":
        case "area":
        case "base":
        case "br":
        case "col":
        case "embed":
        case "hr":
        case "keygen":
        case "meta":
        case "param":
        case "source":
        case "track":
        case "wbr":
        case "menuitem":
          for (var pe in c) j = c[pe], c.hasOwnProperty(pe) && j != null && !f.hasOwnProperty(pe) && He(r, o, pe, null, f, j);
          for (z in f) if (j = f[z], W = c[z], f.hasOwnProperty(z) && j !== W && (j != null || W != null)) switch (z) {
            case "children":
            case "dangerouslySetInnerHTML":
              if (j != null) throw Error(i(137, o));
              break;
            default:
              He(r, o, z, j, f, W);
          }
          return;
        default:
          if (_u(o)) {
            for (var je in c) j = c[je], c.hasOwnProperty(je) && j !== void 0 && !f.hasOwnProperty(je) && nh(r, o, je, void 0, f, j);
            for (X in f) j = f[X], W = c[X], !f.hasOwnProperty(X) || j === W || j === void 0 && W === void 0 || nh(r, o, X, j, f, W);
            return;
          }
      }
      for (var D in c) j = c[D], c.hasOwnProperty(D) && j != null && !f.hasOwnProperty(D) && He(r, o, D, null, f, j);
      for (K in f) j = f[K], W = c[K], !f.hasOwnProperty(K) || j === W || j == null && W == null || He(r, o, K, j, f, W);
    }
    var ih = null, sh = null;
    function Nl(r) {
      return r.nodeType === 9 ? r : r.ownerDocument;
    }
    function my(r) {
      switch (r) {
        case "http://www.w3.org/2000/svg":
          return 1;
        case "http://www.w3.org/1998/Math/MathML":
          return 2;
        default:
          return 0;
      }
    }
    function _y(r, o) {
      if (r === 0) switch (o) {
        case "svg":
          return 1;
        case "math":
          return 2;
        default:
          return 0;
      }
      return r === 1 && o === "foreignObject" ? 0 : r;
    }
    function rh(r, o) {
      return r === "textarea" || r === "noscript" || typeof o.children == "string" || typeof o.children == "number" || typeof o.children == "bigint" || typeof o.dangerouslySetInnerHTML == "object" && o.dangerouslySetInnerHTML !== null && o.dangerouslySetInnerHTML.__html != null;
    }
    var ah = null;
    function Lx() {
      var r = window.event;
      return r && r.type === "popstate" ? r === ah ? false : (ah = r, true) : (ah = null, false);
    }
    var yy = typeof setTimeout == "function" ? setTimeout : void 0, Fx = typeof clearTimeout == "function" ? clearTimeout : void 0, by = typeof Promise == "function" ? Promise : void 0, Vx = typeof queueMicrotask == "function" ? queueMicrotask : typeof by < "u" ? function(r) {
      return by.resolve(null).then(r).catch(zx);
    } : yy;
    function zx(r) {
      setTimeout(function() {
        throw r;
      });
    }
    function Mi(r) {
      return r === "head";
    }
    function vy(r, o) {
      var c = o, f = 0, g = 0;
      do {
        var m = c.nextSibling;
        if (r.removeChild(c), m && m.nodeType === 8) if (c = m.data, c === "/$") {
          if (0 < f && 8 > f) {
            c = f;
            var b = r.ownerDocument;
            if (c & 1 && Va(b.documentElement), c & 2 && Va(b.body), c & 4) for (c = b.head, Va(c), b = c.firstChild; b; ) {
              var T = b.nextSibling, w = b.nodeName;
              b[ta] || w === "SCRIPT" || w === "STYLE" || w === "LINK" && b.rel.toLowerCase() === "stylesheet" || c.removeChild(b), b = T;
            }
          }
          if (g === 0) {
            r.removeChild(m), qa(o);
            return;
          }
          g--;
        } else c === "$" || c === "$?" || c === "$!" ? g++ : f = c.charCodeAt(0) - 48;
        else f = 0;
        c = m;
      } while (c);
      qa(o);
    }
    function oh(r) {
      var o = r.firstChild;
      for (o && o.nodeType === 10 && (o = o.nextSibling); o; ) {
        var c = o;
        switch (o = o.nextSibling, c.nodeName) {
          case "HTML":
          case "HEAD":
          case "BODY":
            oh(c), fu(c);
            continue;
          case "SCRIPT":
          case "STYLE":
            continue;
          case "LINK":
            if (c.rel.toLowerCase() === "stylesheet") continue;
        }
        r.removeChild(c);
      }
    }
    function Hx(r, o, c, f) {
      for (; r.nodeType === 1; ) {
        var g = c;
        if (r.nodeName.toLowerCase() !== o.toLowerCase()) {
          if (!f && (r.nodeName !== "INPUT" || r.type !== "hidden")) break;
        } else if (f) {
          if (!r[ta]) switch (o) {
            case "meta":
              if (!r.hasAttribute("itemprop")) break;
              return r;
            case "link":
              if (m = r.getAttribute("rel"), m === "stylesheet" && r.hasAttribute("data-precedence")) break;
              if (m !== g.rel || r.getAttribute("href") !== (g.href == null || g.href === "" ? null : g.href) || r.getAttribute("crossorigin") !== (g.crossOrigin == null ? null : g.crossOrigin) || r.getAttribute("title") !== (g.title == null ? null : g.title)) break;
              return r;
            case "style":
              if (r.hasAttribute("data-precedence")) break;
              return r;
            case "script":
              if (m = r.getAttribute("src"), (m !== (g.src == null ? null : g.src) || r.getAttribute("type") !== (g.type == null ? null : g.type) || r.getAttribute("crossorigin") !== (g.crossOrigin == null ? null : g.crossOrigin)) && m && r.hasAttribute("async") && !r.hasAttribute("itemprop")) break;
              return r;
            default:
              return r;
          }
        } else if (o === "input" && r.type === "hidden") {
          var m = g.name == null ? null : "" + g.name;
          if (g.type === "hidden" && r.getAttribute("name") === m) return r;
        } else return r;
        if (r = vn(r.nextSibling), r === null) break;
      }
      return null;
    }
    function jx(r, o, c) {
      if (o === "") return null;
      for (; r.nodeType !== 3; ) if ((r.nodeType !== 1 || r.nodeName !== "INPUT" || r.type !== "hidden") && !c || (r = vn(r.nextSibling), r === null)) return null;
      return r;
    }
    function lh(r) {
      return r.data === "$!" || r.data === "$?" && r.ownerDocument.readyState === "complete";
    }
    function Wx(r, o) {
      var c = r.ownerDocument;
      if (r.data !== "$?" || c.readyState === "complete") o();
      else {
        var f = function() {
          o(), c.removeEventListener("DOMContentLoaded", f);
        };
        c.addEventListener("DOMContentLoaded", f), r._reactRetry = f;
      }
    }
    function vn(r) {
      for (; r != null; r = r.nextSibling) {
        var o = r.nodeType;
        if (o === 1 || o === 3) break;
        if (o === 8) {
          if (o = r.data, o === "$" || o === "$!" || o === "$?" || o === "F!" || o === "F") break;
          if (o === "/$") return null;
        }
      }
      return r;
    }
    var ch = null;
    function Ty(r) {
      r = r.previousSibling;
      for (var o = 0; r; ) {
        if (r.nodeType === 8) {
          var c = r.data;
          if (c === "$" || c === "$!" || c === "$?") {
            if (o === 0) return r;
            o--;
          } else c === "/$" && o++;
        }
        r = r.previousSibling;
      }
      return null;
    }
    function xy(r, o, c) {
      switch (o = Nl(c), r) {
        case "html":
          if (r = o.documentElement, !r) throw Error(i(452));
          return r;
        case "head":
          if (r = o.head, !r) throw Error(i(453));
          return r;
        case "body":
          if (r = o.body, !r) throw Error(i(454));
          return r;
        default:
          throw Error(i(451));
      }
    }
    function Va(r) {
      for (var o = r.attributes; o.length; ) r.removeAttributeNode(o[0]);
      fu(r);
    }
    var un = /* @__PURE__ */ new Map(), Sy = /* @__PURE__ */ new Set();
    function Pl(r) {
      return typeof r.getRootNode == "function" ? r.getRootNode() : r.nodeType === 9 ? r : r.ownerDocument;
    }
    var ni = ne.d;
    ne.d = {
      f: $x,
      r: Xx,
      D: Yx,
      C: qx,
      L: Kx,
      m: Zx,
      X: Gx,
      S: Qx,
      M: Jx
    };
    function $x() {
      var r = ni.f(), o = Al();
      return r || o;
    }
    function Xx(r) {
      var o = Bs(r);
      o !== null && o.tag === 5 && o.type === "form" ? jm(o) : ni.r(r);
    }
    var _r = typeof document > "u" ? null : document;
    function Ay(r, o, c) {
      var f = _r;
      if (f && typeof o == "string" && o) {
        var g = nn(o);
        g = 'link[rel="' + r + '"][href="' + g + '"]', typeof c == "string" && (g += '[crossorigin="' + c + '"]'), Sy.has(g) || (Sy.add(g), r = {
          rel: r,
          crossOrigin: c,
          href: o
        }, f.querySelector(g) === null && (o = f.createElement("link"), St(o, "link", r), mt(o), f.head.appendChild(o)));
      }
    }
    function Yx(r) {
      ni.D(r), Ay("dns-prefetch", r, null);
    }
    function qx(r, o) {
      ni.C(r, o), Ay("preconnect", r, o);
    }
    function Kx(r, o, c) {
      ni.L(r, o, c);
      var f = _r;
      if (f && r && o) {
        var g = 'link[rel="preload"][as="' + nn(o) + '"]';
        o === "image" && c && c.imageSrcSet ? (g += '[imagesrcset="' + nn(c.imageSrcSet) + '"]', typeof c.imageSizes == "string" && (g += '[imagesizes="' + nn(c.imageSizes) + '"]')) : g += '[href="' + nn(r) + '"]';
        var m = g;
        switch (o) {
          case "style":
            m = yr(r);
            break;
          case "script":
            m = br(r);
        }
        un.has(m) || (r = p({
          rel: "preload",
          href: o === "image" && c && c.imageSrcSet ? void 0 : r,
          as: o
        }, c), un.set(m, r), f.querySelector(g) !== null || o === "style" && f.querySelector(za(m)) || o === "script" && f.querySelector(Ha(m)) || (o = f.createElement("link"), St(o, "link", r), mt(o), f.head.appendChild(o)));
      }
    }
    function Zx(r, o) {
      ni.m(r, o);
      var c = _r;
      if (c && r) {
        var f = o && typeof o.as == "string" ? o.as : "script", g = 'link[rel="modulepreload"][as="' + nn(f) + '"][href="' + nn(r) + '"]', m = g;
        switch (f) {
          case "audioworklet":
          case "paintworklet":
          case "serviceworker":
          case "sharedworker":
          case "worker":
          case "script":
            m = br(r);
        }
        if (!un.has(m) && (r = p({
          rel: "modulepreload",
          href: r
        }, o), un.set(m, r), c.querySelector(g) === null)) {
          switch (f) {
            case "audioworklet":
            case "paintworklet":
            case "serviceworker":
            case "sharedworker":
            case "worker":
            case "script":
              if (c.querySelector(Ha(m))) return;
          }
          f = c.createElement("link"), St(f, "link", r), mt(f), c.head.appendChild(f);
        }
      }
    }
    function Qx(r, o, c) {
      ni.S(r, o, c);
      var f = _r;
      if (f && r) {
        var g = Ls(f).hoistableStyles, m = yr(r);
        o = o || "default";
        var b = g.get(m);
        if (!b) {
          var T = {
            loading: 0,
            preload: null
          };
          if (b = f.querySelector(za(m))) T.loading = 5;
          else {
            r = p({
              rel: "stylesheet",
              href: r,
              "data-precedence": o
            }, c), (c = un.get(m)) && uh(r, c);
            var w = b = f.createElement("link");
            mt(w), St(w, "link", r), w._p = new Promise(function(z, X) {
              w.onload = z, w.onerror = X;
            }), w.addEventListener("load", function() {
              T.loading |= 1;
            }), w.addEventListener("error", function() {
              T.loading |= 2;
            }), T.loading |= 4, Dl(b, o, f);
          }
          b = {
            type: "stylesheet",
            instance: b,
            count: 1,
            state: T
          }, g.set(m, b);
        }
      }
    }
    function Gx(r, o) {
      ni.X(r, o);
      var c = _r;
      if (c && r) {
        var f = Ls(c).hoistableScripts, g = br(r), m = f.get(g);
        m || (m = c.querySelector(Ha(g)), m || (r = p({
          src: r,
          async: true
        }, o), (o = un.get(g)) && fh(r, o), m = c.createElement("script"), mt(m), St(m, "link", r), c.head.appendChild(m)), m = {
          type: "script",
          instance: m,
          count: 1,
          state: null
        }, f.set(g, m));
      }
    }
    function Jx(r, o) {
      ni.M(r, o);
      var c = _r;
      if (c && r) {
        var f = Ls(c).hoistableScripts, g = br(r), m = f.get(g);
        m || (m = c.querySelector(Ha(g)), m || (r = p({
          src: r,
          async: true,
          type: "module"
        }, o), (o = un.get(g)) && fh(r, o), m = c.createElement("script"), mt(m), St(m, "link", r), c.head.appendChild(m)), m = {
          type: "script",
          instance: m,
          count: 1,
          state: null
        }, f.set(g, m));
      }
    }
    function wy(r, o, c, f) {
      var g = (g = ue.current) ? Pl(g) : null;
      if (!g) throw Error(i(446));
      switch (r) {
        case "meta":
        case "title":
          return null;
        case "style":
          return typeof c.precedence == "string" && typeof c.href == "string" ? (o = yr(c.href), c = Ls(g).hoistableStyles, f = c.get(o), f || (f = {
            type: "style",
            instance: null,
            count: 0,
            state: null
          }, c.set(o, f)), f) : {
            type: "void",
            instance: null,
            count: 0,
            state: null
          };
        case "link":
          if (c.rel === "stylesheet" && typeof c.href == "string" && typeof c.precedence == "string") {
            r = yr(c.href);
            var m = Ls(g).hoistableStyles, b = m.get(r);
            if (b || (g = g.ownerDocument || g, b = {
              type: "stylesheet",
              instance: null,
              count: 0,
              state: {
                loading: 0,
                preload: null
              }
            }, m.set(r, b), (m = g.querySelector(za(r))) && !m._p && (b.instance = m, b.state.loading = 5), un.has(r) || (c = {
              rel: "preload",
              as: "style",
              href: c.href,
              crossOrigin: c.crossOrigin,
              integrity: c.integrity,
              media: c.media,
              hrefLang: c.hrefLang,
              referrerPolicy: c.referrerPolicy
            }, un.set(r, c), m || eS(g, r, c, b.state))), o && f === null) throw Error(i(528, ""));
            return b;
          }
          if (o && f !== null) throw Error(i(529, ""));
          return null;
        case "script":
          return o = c.async, c = c.src, typeof c == "string" && o && typeof o != "function" && typeof o != "symbol" ? (o = br(c), c = Ls(g).hoistableScripts, f = c.get(o), f || (f = {
            type: "script",
            instance: null,
            count: 0,
            state: null
          }, c.set(o, f)), f) : {
            type: "void",
            instance: null,
            count: 0,
            state: null
          };
        default:
          throw Error(i(444, r));
      }
    }
    function yr(r) {
      return 'href="' + nn(r) + '"';
    }
    function za(r) {
      return 'link[rel="stylesheet"][' + r + "]";
    }
    function Ey(r) {
      return p({}, r, {
        "data-precedence": r.precedence,
        precedence: null
      });
    }
    function eS(r, o, c, f) {
      r.querySelector('link[rel="preload"][as="style"][' + o + "]") ? f.loading = 1 : (o = r.createElement("link"), f.preload = o, o.addEventListener("load", function() {
        return f.loading |= 1;
      }), o.addEventListener("error", function() {
        return f.loading |= 2;
      }), St(o, "link", c), mt(o), r.head.appendChild(o));
    }
    function br(r) {
      return '[src="' + nn(r) + '"]';
    }
    function Ha(r) {
      return "script[async]" + r;
    }
    function Ry(r, o, c) {
      if (o.count++, o.instance === null) switch (o.type) {
        case "style":
          var f = r.querySelector('style[data-href~="' + nn(c.href) + '"]');
          if (f) return o.instance = f, mt(f), f;
          var g = p({}, c, {
            "data-href": c.href,
            "data-precedence": c.precedence,
            href: null,
            precedence: null
          });
          return f = (r.ownerDocument || r).createElement("style"), mt(f), St(f, "style", g), Dl(f, c.precedence, r), o.instance = f;
        case "stylesheet":
          g = yr(c.href);
          var m = r.querySelector(za(g));
          if (m) return o.state.loading |= 4, o.instance = m, mt(m), m;
          f = Ey(c), (g = un.get(g)) && uh(f, g), m = (r.ownerDocument || r).createElement("link"), mt(m);
          var b = m;
          return b._p = new Promise(function(T, w) {
            b.onload = T, b.onerror = w;
          }), St(m, "link", f), o.state.loading |= 4, Dl(m, c.precedence, r), o.instance = m;
        case "script":
          return m = br(c.src), (g = r.querySelector(Ha(m))) ? (o.instance = g, mt(g), g) : (f = c, (g = un.get(m)) && (f = p({}, c), fh(f, g)), r = r.ownerDocument || r, g = r.createElement("script"), mt(g), St(g, "link", f), r.head.appendChild(g), o.instance = g);
        case "void":
          return null;
        default:
          throw Error(i(443, o.type));
      }
      else o.type === "stylesheet" && (o.state.loading & 4) === 0 && (f = o.instance, o.state.loading |= 4, Dl(f, c.precedence, r));
      return o.instance;
    }
    function Dl(r, o, c) {
      for (var f = c.querySelectorAll('link[rel="stylesheet"][data-precedence],style[data-precedence]'), g = f.length ? f[f.length - 1] : null, m = g, b = 0; b < f.length; b++) {
        var T = f[b];
        if (T.dataset.precedence === o) m = T;
        else if (m !== g) break;
      }
      m ? m.parentNode.insertBefore(r, m.nextSibling) : (o = c.nodeType === 9 ? c.head : c, o.insertBefore(r, o.firstChild));
    }
    function uh(r, o) {
      r.crossOrigin == null && (r.crossOrigin = o.crossOrigin), r.referrerPolicy == null && (r.referrerPolicy = o.referrerPolicy), r.title == null && (r.title = o.title);
    }
    function fh(r, o) {
      r.crossOrigin == null && (r.crossOrigin = o.crossOrigin), r.referrerPolicy == null && (r.referrerPolicy = o.referrerPolicy), r.integrity == null && (r.integrity = o.integrity);
    }
    var kl = null;
    function Cy(r, o, c) {
      if (kl === null) {
        var f = /* @__PURE__ */ new Map(), g = kl = /* @__PURE__ */ new Map();
        g.set(c, f);
      } else g = kl, f = g.get(c), f || (f = /* @__PURE__ */ new Map(), g.set(c, f));
      if (f.has(r)) return f;
      for (f.set(r, null), c = c.getElementsByTagName(r), g = 0; g < c.length; g++) {
        var m = c[g];
        if (!(m[ta] || m[At] || r === "link" && m.getAttribute("rel") === "stylesheet") && m.namespaceURI !== "http://www.w3.org/2000/svg") {
          var b = m.getAttribute(o) || "";
          b = r + b;
          var T = f.get(b);
          T ? T.push(m) : f.set(b, [
            m
          ]);
        }
      }
      return f;
    }
    function My(r, o, c) {
      r = r.ownerDocument || r, r.head.insertBefore(c, o === "title" ? r.querySelector("head > title") : null);
    }
    function tS(r, o, c) {
      if (c === 1 || o.itemProp != null) return false;
      switch (r) {
        case "meta":
        case "title":
          return true;
        case "style":
          if (typeof o.precedence != "string" || typeof o.href != "string" || o.href === "") break;
          return true;
        case "link":
          if (typeof o.rel != "string" || typeof o.href != "string" || o.href === "" || o.onLoad || o.onError) break;
          switch (o.rel) {
            case "stylesheet":
              return r = o.disabled, typeof o.precedence == "string" && r == null;
            default:
              return true;
          }
        case "script":
          if (o.async && typeof o.async != "function" && typeof o.async != "symbol" && !o.onLoad && !o.onError && o.src && typeof o.src == "string") return true;
      }
      return false;
    }
    function Oy(r) {
      return !(r.type === "stylesheet" && (r.state.loading & 3) === 0);
    }
    var ja = null;
    function nS() {
    }
    function iS(r, o, c) {
      if (ja === null) throw Error(i(475));
      var f = ja;
      if (o.type === "stylesheet" && (typeof c.media != "string" || matchMedia(c.media).matches !== false) && (o.state.loading & 4) === 0) {
        if (o.instance === null) {
          var g = yr(c.href), m = r.querySelector(za(g));
          if (m) {
            r = m._p, r !== null && typeof r == "object" && typeof r.then == "function" && (f.count++, f = Ul.bind(f), r.then(f, f)), o.state.loading |= 4, o.instance = m, mt(m);
            return;
          }
          m = r.ownerDocument || r, c = Ey(c), (g = un.get(g)) && uh(c, g), m = m.createElement("link"), mt(m);
          var b = m;
          b._p = new Promise(function(T, w) {
            b.onload = T, b.onerror = w;
          }), St(m, "link", c), o.instance = m;
        }
        f.stylesheets === null && (f.stylesheets = /* @__PURE__ */ new Map()), f.stylesheets.set(o, r), (r = o.state.preload) && (o.state.loading & 3) === 0 && (f.count++, o = Ul.bind(f), r.addEventListener("load", o), r.addEventListener("error", o));
      }
    }
    function sS() {
      if (ja === null) throw Error(i(475));
      var r = ja;
      return r.stylesheets && r.count === 0 && hh(r, r.stylesheets), 0 < r.count ? function(o) {
        var c = setTimeout(function() {
          if (r.stylesheets && hh(r, r.stylesheets), r.unsuspend) {
            var f = r.unsuspend;
            r.unsuspend = null, f();
          }
        }, 6e4);
        return r.unsuspend = o, function() {
          r.unsuspend = null, clearTimeout(c);
        };
      } : null;
    }
    function Ul() {
      if (this.count--, this.count === 0) {
        if (this.stylesheets) hh(this, this.stylesheets);
        else if (this.unsuspend) {
          var r = this.unsuspend;
          this.unsuspend = null, r();
        }
      }
    }
    var Bl = null;
    function hh(r, o) {
      r.stylesheets = null, r.unsuspend !== null && (r.count++, Bl = /* @__PURE__ */ new Map(), o.forEach(rS, r), Bl = null, Ul.call(r));
    }
    function rS(r, o) {
      if (!(o.state.loading & 4)) {
        var c = Bl.get(r);
        if (c) var f = c.get(null);
        else {
          c = /* @__PURE__ */ new Map(), Bl.set(r, c);
          for (var g = r.querySelectorAll("link[data-precedence],style[data-precedence]"), m = 0; m < g.length; m++) {
            var b = g[m];
            (b.nodeName === "LINK" || b.getAttribute("media") !== "not all") && (c.set(b.dataset.precedence, b), f = b);
          }
          f && c.set(null, f);
        }
        g = o.instance, b = g.getAttribute("data-precedence"), m = c.get(b) || f, m === f && c.set(null, g), c.set(b, g), this.count++, f = Ul.bind(this), g.addEventListener("load", f), g.addEventListener("error", f), m ? m.parentNode.insertBefore(g, m.nextSibling) : (r = r.nodeType === 9 ? r.head : r, r.insertBefore(g, r.firstChild)), o.state.loading |= 4;
      }
    }
    var Wa = {
      $$typeof: O,
      Provider: null,
      Consumer: null,
      _currentValue: he,
      _currentValue2: he,
      _threadCount: 0
    };
    function aS(r, o, c, f, g, m, b, T) {
      this.tag = 1, this.containerInfo = r, this.pingCache = this.current = this.pendingChildren = null, this.timeoutHandle = -1, this.callbackNode = this.next = this.pendingContext = this.context = this.cancelPendingCommit = null, this.callbackPriority = 0, this.expirationTimes = ou(-1), this.entangledLanes = this.shellSuspendCounter = this.errorRecoveryDisabledLanes = this.expiredLanes = this.warmLanes = this.pingedLanes = this.suspendedLanes = this.pendingLanes = 0, this.entanglements = ou(0), this.hiddenUpdates = ou(null), this.identifierPrefix = f, this.onUncaughtError = g, this.onCaughtError = m, this.onRecoverableError = b, this.pooledCache = null, this.pooledCacheLanes = 0, this.formState = T, this.incompleteTransitions = /* @__PURE__ */ new Map();
    }
    function Iy(r, o, c, f, g, m, b, T, w, z, X, K) {
      return r = new aS(r, o, c, b, T, w, z, K), o = 1, m === true && (o |= 24), m = $t(3, null, null, o), r.current = m, m.stateNode = r, o = Xu(), o.refCount++, r.pooledCache = o, o.refCount++, m.memoizedState = {
        element: f,
        isDehydrated: c,
        cache: o
      }, Zu(m), r;
    }
    function Ny(r) {
      return r ? (r = Zs, r) : Zs;
    }
    function Py(r, o, c, f, g, m) {
      g = Ny(g), f.context === null ? f.context = g : f.pendingContext = g, f = mi(o), f.payload = {
        element: c
      }, m = m === void 0 ? null : m, m !== null && (f.callback = m), c = _i(r, f, o), c !== null && (Zt(c, r, o), va(c, r, o));
    }
    function Dy(r, o) {
      if (r = r.memoizedState, r !== null && r.dehydrated !== null) {
        var c = r.retryLane;
        r.retryLane = c !== 0 && c < o ? c : o;
      }
    }
    function dh(r, o) {
      Dy(r, o), (r = r.alternate) && Dy(r, o);
    }
    function ky(r) {
      if (r.tag === 13) {
        var o = Ks(r, 67108864);
        o !== null && Zt(o, r, 67108864), dh(r, 67108864);
      }
    }
    var Ll = true;
    function oS(r, o, c, f) {
      var g = $.T;
      $.T = null;
      var m = ne.p;
      try {
        ne.p = 2, gh(r, o, c, f);
      } finally {
        ne.p = m, $.T = g;
      }
    }
    function lS(r, o, c, f) {
      var g = $.T;
      $.T = null;
      var m = ne.p;
      try {
        ne.p = 8, gh(r, o, c, f);
      } finally {
        ne.p = m, $.T = g;
      }
    }
    function gh(r, o, c, f) {
      if (Ll) {
        var g = ph(f);
        if (g === null) th(r, o, f, Fl, c), By(r, f);
        else if (uS(g, r, o, c, f)) f.stopPropagation();
        else if (By(r, f), o & 4 && -1 < cS.indexOf(r)) {
          for (; g !== null; ) {
            var m = Bs(g);
            if (m !== null) switch (m.tag) {
              case 3:
                if (m = m.stateNode, m.current.memoizedState.isDehydrated) {
                  var b = Qi(m.pendingLanes);
                  if (b !== 0) {
                    var T = m;
                    for (T.pendingLanes |= 2, T.entangledLanes |= 2; b; ) {
                      var w = 1 << 31 - jt(b);
                      T.entanglements[1] |= w, b &= ~w;
                    }
                    On(m), (Fe & 6) === 0 && (xl = wn() + 500, Ba(0));
                  }
                }
                break;
              case 13:
                T = Ks(m, 2), T !== null && Zt(T, m, 2), Al(), dh(m, 2);
            }
            if (m = ph(f), m === null && th(r, o, f, Fl, c), m === g) break;
            g = m;
          }
          g !== null && f.stopPropagation();
        } else th(r, o, f, null, c);
      }
    }
    function ph(r) {
      return r = bu(r), mh(r);
    }
    var Fl = null;
    function mh(r) {
      if (Fl = null, r = Us(r), r !== null) {
        var o = a(r);
        if (o === null) r = null;
        else {
          var c = o.tag;
          if (c === 13) {
            if (r = l(o), r !== null) return r;
            r = null;
          } else if (c === 3) {
            if (o.stateNode.current.memoizedState.isDehydrated) return o.tag === 3 ? o.stateNode.containerInfo : null;
            r = null;
          } else o !== r && (r = null);
        }
      }
      return Fl = r, null;
    }
    function Uy(r) {
      switch (r) {
        case "beforetoggle":
        case "cancel":
        case "click":
        case "close":
        case "contextmenu":
        case "copy":
        case "cut":
        case "auxclick":
        case "dblclick":
        case "dragend":
        case "dragstart":
        case "drop":
        case "focusin":
        case "focusout":
        case "input":
        case "invalid":
        case "keydown":
        case "keypress":
        case "keyup":
        case "mousedown":
        case "mouseup":
        case "paste":
        case "pause":
        case "play":
        case "pointercancel":
        case "pointerdown":
        case "pointerup":
        case "ratechange":
        case "reset":
        case "resize":
        case "seeked":
        case "submit":
        case "toggle":
        case "touchcancel":
        case "touchend":
        case "touchstart":
        case "volumechange":
        case "change":
        case "selectionchange":
        case "textInput":
        case "compositionstart":
        case "compositionend":
        case "compositionupdate":
        case "beforeblur":
        case "afterblur":
        case "beforeinput":
        case "blur":
        case "fullscreenchange":
        case "focus":
        case "hashchange":
        case "popstate":
        case "select":
        case "selectstart":
          return 2;
        case "drag":
        case "dragenter":
        case "dragexit":
        case "dragleave":
        case "dragover":
        case "mousemove":
        case "mouseout":
        case "mouseover":
        case "pointermove":
        case "pointerout":
        case "pointerover":
        case "scroll":
        case "touchmove":
        case "wheel":
        case "mouseenter":
        case "mouseleave":
        case "pointerenter":
        case "pointerleave":
          return 8;
        case "message":
          switch (qT()) {
            case Zg:
              return 2;
            case Qg:
              return 8;
            case Io:
            case KT:
              return 32;
            case Gg:
              return 268435456;
            default:
              return 32;
          }
        default:
          return 32;
      }
    }
    var _h = false, Oi = null, Ii = null, Ni = null, $a = /* @__PURE__ */ new Map(), Xa = /* @__PURE__ */ new Map(), Pi = [], cS = "mousedown mouseup touchcancel touchend touchstart auxclick dblclick pointercancel pointerdown pointerup dragend dragstart drop compositionend compositionstart keydown keypress keyup input textInput copy cut paste click change contextmenu reset".split(" ");
    function By(r, o) {
      switch (r) {
        case "focusin":
        case "focusout":
          Oi = null;
          break;
        case "dragenter":
        case "dragleave":
          Ii = null;
          break;
        case "mouseover":
        case "mouseout":
          Ni = null;
          break;
        case "pointerover":
        case "pointerout":
          $a.delete(o.pointerId);
          break;
        case "gotpointercapture":
        case "lostpointercapture":
          Xa.delete(o.pointerId);
      }
    }
    function Ya(r, o, c, f, g, m) {
      return r === null || r.nativeEvent !== m ? (r = {
        blockedOn: o,
        domEventName: c,
        eventSystemFlags: f,
        nativeEvent: m,
        targetContainers: [
          g
        ]
      }, o !== null && (o = Bs(o), o !== null && ky(o)), r) : (r.eventSystemFlags |= f, o = r.targetContainers, g !== null && o.indexOf(g) === -1 && o.push(g), r);
    }
    function uS(r, o, c, f, g) {
      switch (o) {
        case "focusin":
          return Oi = Ya(Oi, r, o, c, f, g), true;
        case "dragenter":
          return Ii = Ya(Ii, r, o, c, f, g), true;
        case "mouseover":
          return Ni = Ya(Ni, r, o, c, f, g), true;
        case "pointerover":
          var m = g.pointerId;
          return $a.set(m, Ya($a.get(m) || null, r, o, c, f, g)), true;
        case "gotpointercapture":
          return m = g.pointerId, Xa.set(m, Ya(Xa.get(m) || null, r, o, c, f, g)), true;
      }
      return false;
    }
    function Ly(r) {
      var o = Us(r.target);
      if (o !== null) {
        var c = a(o);
        if (c !== null) {
          if (o = c.tag, o === 13) {
            if (o = l(c), o !== null) {
              r.blockedOn = o, i1(r.priority, function() {
                if (c.tag === 13) {
                  var f = Kt();
                  f = lu(f);
                  var g = Ks(c, f);
                  g !== null && Zt(g, c, f), dh(c, f);
                }
              });
              return;
            }
          } else if (o === 3 && c.stateNode.current.memoizedState.isDehydrated) {
            r.blockedOn = c.tag === 3 ? c.stateNode.containerInfo : null;
            return;
          }
        }
      }
      r.blockedOn = null;
    }
    function Vl(r) {
      if (r.blockedOn !== null) return false;
      for (var o = r.targetContainers; 0 < o.length; ) {
        var c = ph(r.nativeEvent);
        if (c === null) {
          c = r.nativeEvent;
          var f = new c.constructor(c.type, c);
          yu = f, c.target.dispatchEvent(f), yu = null;
        } else return o = Bs(c), o !== null && ky(o), r.blockedOn = c, false;
        o.shift();
      }
      return true;
    }
    function Fy(r, o, c) {
      Vl(r) && c.delete(o);
    }
    function fS() {
      _h = false, Oi !== null && Vl(Oi) && (Oi = null), Ii !== null && Vl(Ii) && (Ii = null), Ni !== null && Vl(Ni) && (Ni = null), $a.forEach(Fy), Xa.forEach(Fy);
    }
    function zl(r, o) {
      r.blockedOn === o && (r.blockedOn = null, _h || (_h = true, n.unstable_scheduleCallback(n.unstable_NormalPriority, fS)));
    }
    var Hl = null;
    function Vy(r) {
      Hl !== r && (Hl = r, n.unstable_scheduleCallback(n.unstable_NormalPriority, function() {
        Hl === r && (Hl = null);
        for (var o = 0; o < r.length; o += 3) {
          var c = r[o], f = r[o + 1], g = r[o + 2];
          if (typeof f != "function") {
            if (mh(f || c) === null) continue;
            break;
          }
          var m = Bs(c);
          m !== null && (r.splice(o, 3), o -= 3, mf(m, {
            pending: true,
            data: g,
            method: c.method,
            action: f
          }, f, g));
        }
      }));
    }
    function qa(r) {
      function o(w) {
        return zl(w, r);
      }
      Oi !== null && zl(Oi, r), Ii !== null && zl(Ii, r), Ni !== null && zl(Ni, r), $a.forEach(o), Xa.forEach(o);
      for (var c = 0; c < Pi.length; c++) {
        var f = Pi[c];
        f.blockedOn === r && (f.blockedOn = null);
      }
      for (; 0 < Pi.length && (c = Pi[0], c.blockedOn === null); ) Ly(c), c.blockedOn === null && Pi.shift();
      if (c = (r.ownerDocument || r).$$reactFormReplay, c != null) for (f = 0; f < c.length; f += 3) {
        var g = c[f], m = c[f + 1], b = g[Dt] || null;
        if (typeof m == "function") b || Vy(c);
        else if (b) {
          var T = null;
          if (m && m.hasAttribute("formAction")) {
            if (g = m, b = m[Dt] || null) T = b.formAction;
            else if (mh(g) !== null) continue;
          } else T = b.action;
          typeof T == "function" ? c[f + 1] = T : (c.splice(f, 3), f -= 3), Vy(c);
        }
      }
    }
    function yh(r) {
      this._internalRoot = r;
    }
    jl.prototype.render = yh.prototype.render = function(r) {
      var o = this._internalRoot;
      if (o === null) throw Error(i(409));
      var c = o.current, f = Kt();
      Py(c, f, r, o, null, null);
    }, jl.prototype.unmount = yh.prototype.unmount = function() {
      var r = this._internalRoot;
      if (r !== null) {
        this._internalRoot = null;
        var o = r.containerInfo;
        Py(r.current, 2, null, r, null, null), Al(), o[ks] = null;
      }
    };
    function jl(r) {
      this._internalRoot = r;
    }
    jl.prototype.unstable_scheduleHydration = function(r) {
      if (r) {
        var o = ip();
        r = {
          blockedOn: null,
          target: r,
          priority: o
        };
        for (var c = 0; c < Pi.length && o !== 0 && o < Pi[c].priority; c++) ;
        Pi.splice(c, 0, r), c === 0 && Ly(r);
      }
    };
    var zy = e.version;
    if (zy !== "19.1.0") throw Error(i(527, zy, "19.1.0"));
    ne.findDOMNode = function(r) {
      var o = r._reactInternals;
      if (o === void 0) throw typeof r.render == "function" ? Error(i(188)) : (r = Object.keys(r).join(","), Error(i(268, r)));
      return r = h(o), r = r !== null ? d(r) : null, r = r === null ? null : r.stateNode, r;
    };
    var hS = {
      bundleType: 0,
      version: "19.1.0",
      rendererPackageName: "react-dom",
      currentDispatcherRef: $,
      reconcilerVersion: "19.1.0"
    };
    if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < "u") {
      var Wl = __REACT_DEVTOOLS_GLOBAL_HOOK__;
      if (!Wl.isDisabled && Wl.supportsFiber) try {
        Gr = Wl.inject(hS), Ht = Wl;
      } catch {
      }
    }
    return Za.createRoot = function(r, o) {
      if (!s(r)) throw Error(i(299));
      var c = false, f = "", g = i_, m = s_, b = r_, T = null;
      return o != null && (o.unstable_strictMode === true && (c = true), o.identifierPrefix !== void 0 && (f = o.identifierPrefix), o.onUncaughtError !== void 0 && (g = o.onUncaughtError), o.onCaughtError !== void 0 && (m = o.onCaughtError), o.onRecoverableError !== void 0 && (b = o.onRecoverableError), o.unstable_transitionCallbacks !== void 0 && (T = o.unstable_transitionCallbacks)), o = Iy(r, 1, false, null, null, c, f, g, m, b, T, null), r[ks] = o.current, eh(r), new yh(o);
    }, Za.hydrateRoot = function(r, o, c) {
      if (!s(r)) throw Error(i(299));
      var f = false, g = "", m = i_, b = s_, T = r_, w = null, z = null;
      return c != null && (c.unstable_strictMode === true && (f = true), c.identifierPrefix !== void 0 && (g = c.identifierPrefix), c.onUncaughtError !== void 0 && (m = c.onUncaughtError), c.onCaughtError !== void 0 && (b = c.onCaughtError), c.onRecoverableError !== void 0 && (T = c.onRecoverableError), c.unstable_transitionCallbacks !== void 0 && (w = c.unstable_transitionCallbacks), c.formState !== void 0 && (z = c.formState)), o = Iy(r, 1, true, o, c ?? null, f, g, m, b, T, w, z), o.context = Ny(null), c = o.current, f = Kt(), f = lu(f), g = mi(f), g.callback = null, _i(c, g, f), c = f, o.current.lanes = c, ea(o, c), On(o), r[ks] = o.current, eh(r), new jl(o);
    }, Za.version = "19.1.0", Za;
  }
  var Qy;
  function TS() {
    if (Qy) return Th.exports;
    Qy = 1;
    function n() {
      if (!(typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ > "u" || typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE != "function")) try {
        __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(n);
      } catch (e) {
        console.error(e);
      }
    }
    return n(), Th.exports = vS(), Th.exports;
  }
  var xS = TS();
  const SS = Hv(xS), AS = "modulepreload", wS = function(n) {
    return "/mobile-network-map/" + n;
  }, Gy = {}, ES = function(e, t, i) {
    let s = Promise.resolve();
    if (t && t.length > 0) {
      let l = function(d) {
        return Promise.all(d.map((p) => Promise.resolve(p).then((_) => ({
          status: "fulfilled",
          value: _
        }), (_) => ({
          status: "rejected",
          reason: _
        }))));
      };
      document.getElementsByTagName("link");
      const u = document.querySelector("meta[property=csp-nonce]"), h = (u == null ? void 0 : u.nonce) || (u == null ? void 0 : u.getAttribute("nonce"));
      s = l(t.map((d) => {
        if (d = wS(d), d in Gy) return;
        Gy[d] = true;
        const p = d.endsWith(".css"), _ = p ? '[rel="stylesheet"]' : "";
        if (document.querySelector(`link[href="${d}"]${_}`)) return;
        const y = document.createElement("link");
        if (y.rel = p ? "stylesheet" : AS, p || (y.as = "script"), y.crossOrigin = "", y.href = d, h && y.setAttribute("nonce", h), document.head.appendChild(y), p) return new Promise((v, S) => {
          y.addEventListener("load", v), y.addEventListener("error", () => S(new Error(`Unable to preload CSS for ${d}`)));
        });
      }));
    }
    function a(l) {
      const u = new Event("vite:preloadError", {
        cancelable: true
      });
      if (u.payload = l, window.dispatchEvent(u), !u.defaultPrevented) throw l;
    }
    return s.then((l) => {
      for (const u of l || []) u.status === "rejected" && a(u.reason);
      return e().catch(a);
    });
  }, RS = G.createContext(null);
  function CS(n, e) {
    const t = Array.isArray(n) ? n[0] : n ? n.x : 0, i = Array.isArray(n) ? n[1] : n ? n.y : 0, s = Array.isArray(e) ? e[0] : e ? e.x : 0, a = Array.isArray(e) ? e[1] : e ? e.y : 0;
    return t === s && i === a;
  }
  function Dn(n, e) {
    if (n === e) return true;
    if (!n || !e) return false;
    if (Array.isArray(n)) {
      if (!Array.isArray(e) || n.length !== e.length) return false;
      for (let t = 0; t < n.length; t++) if (!Dn(n[t], e[t])) return false;
      return true;
    } else if (Array.isArray(e)) return false;
    if (typeof n == "object" && typeof e == "object") {
      const t = Object.keys(n), i = Object.keys(e);
      if (t.length !== i.length) return false;
      for (const s of t) if (!e.hasOwnProperty(s) || !Dn(n[s], e[s])) return false;
      return true;
    }
    return false;
  }
  function Jy(n) {
    return {
      longitude: n.center.lng,
      latitude: n.center.lat,
      zoom: n.zoom,
      pitch: n.pitch,
      bearing: n.bearing,
      padding: n.padding
    };
  }
  function eb(n, e) {
    const t = e.viewState || e, i = {};
    if ("longitude" in t && "latitude" in t && (t.longitude !== n.center.lng || t.latitude !== n.center.lat)) {
      const s = n.center.constructor;
      i.center = new s(t.longitude, t.latitude);
    }
    return "zoom" in t && t.zoom !== n.zoom && (i.zoom = t.zoom), "bearing" in t && t.bearing !== n.bearing && (i.bearing = t.bearing), "pitch" in t && t.pitch !== n.pitch && (i.pitch = t.pitch), t.padding && n.padding && !Dn(t.padding, n.padding) && (i.padding = t.padding), i;
  }
  const MS = [
    "type",
    "source",
    "source-layer",
    "minzoom",
    "maxzoom",
    "filter",
    "layout"
  ];
  function tb(n) {
    if (!n) return null;
    if (typeof n == "string" || ("toJS" in n && (n = n.toJS()), !n.layers)) return n;
    const e = {};
    for (const i of n.layers) e[i.id] = i;
    const t = n.layers.map((i) => {
      let s = null;
      "interactive" in i && (s = Object.assign({}, i), delete s.interactive);
      const a = e[i.ref];
      if (a) {
        s = s || Object.assign({}, i), delete s.ref;
        for (const l of MS) l in a && (s[l] = a[l]);
      }
      return s || i;
    });
    return {
      ...n,
      layers: t
    };
  }
  const nb = {
    version: 8,
    sources: {},
    layers: []
  }, ib = {
    mousedown: "onMouseDown",
    mouseup: "onMouseUp",
    mouseover: "onMouseOver",
    mousemove: "onMouseMove",
    click: "onClick",
    dblclick: "onDblClick",
    mouseenter: "onMouseEnter",
    mouseleave: "onMouseLeave",
    mouseout: "onMouseOut",
    contextmenu: "onContextMenu",
    touchstart: "onTouchStart",
    touchend: "onTouchEnd",
    touchmove: "onTouchMove",
    touchcancel: "onTouchCancel"
  }, sb = {
    movestart: "onMoveStart",
    move: "onMove",
    moveend: "onMoveEnd",
    dragstart: "onDragStart",
    drag: "onDrag",
    dragend: "onDragEnd",
    zoomstart: "onZoomStart",
    zoom: "onZoom",
    zoomend: "onZoomEnd",
    rotatestart: "onRotateStart",
    rotate: "onRotate",
    rotateend: "onRotateEnd",
    pitchstart: "onPitchStart",
    pitch: "onPitch",
    pitchend: "onPitchEnd"
  }, rb = {
    wheel: "onWheel",
    boxzoomstart: "onBoxZoomStart",
    boxzoomend: "onBoxZoomEnd",
    boxzoomcancel: "onBoxZoomCancel",
    resize: "onResize",
    load: "onLoad",
    render: "onRender",
    idle: "onIdle",
    remove: "onRemove",
    data: "onData",
    styledata: "onStyleData",
    sourcedata: "onSourceData",
    error: "onError"
  }, OS = [
    "minZoom",
    "maxZoom",
    "minPitch",
    "maxPitch",
    "maxBounds",
    "projection",
    "renderWorldCopies"
  ], IS = [
    "scrollZoom",
    "boxZoom",
    "dragRotate",
    "dragPan",
    "keyboard",
    "doubleClickZoom",
    "touchZoomRotate",
    "touchPitch"
  ];
  class Fr {
    constructor(e, t, i) {
      this._map = null, this._internalUpdate = false, this._hoveredFeatures = null, this._propsedCameraUpdate = null, this._styleComponents = {}, this._onEvent = (s) => {
        const a = this.props[rb[s.type]];
        a ? a(s) : s.type === "error" && console.error(s.error);
      }, this._onCameraEvent = (s) => {
        if (this._internalUpdate) return;
        s.viewState = this._propsedCameraUpdate || Jy(this._map.transform);
        const a = this.props[sb[s.type]];
        a && a(s);
      }, this._onCameraUpdate = (s) => this._internalUpdate ? s : (this._propsedCameraUpdate = Jy(s), eb(s, this.props)), this._onPointerEvent = (s) => {
        (s.type === "mousemove" || s.type === "mouseout") && this._updateHover(s);
        const a = this.props[ib[s.type]];
        a && (this.props.interactiveLayerIds && s.type !== "mouseover" && s.type !== "mouseout" && (s.features = this._hoveredFeatures || this._queryRenderedFeatures(s.point)), a(s), delete s.features);
      }, this._MapClass = e, this.props = t, this._initialize(i);
    }
    get map() {
      return this._map;
    }
    setProps(e) {
      const t = this.props;
      this.props = e;
      const i = this._updateSettings(e, t), s = this._updateSize(e), a = this._updateViewState(e);
      this._updateStyle(e, t), this._updateStyleComponents(e), this._updateHandlers(e, t), (i || s || a && !this._map.isMoving()) && this.redraw();
    }
    static reuse(e, t) {
      const i = Fr.savedMaps.pop();
      if (!i) return null;
      const s = i.map, a = s.getContainer();
      for (t.className = a.className; a.childNodes.length > 0; ) t.appendChild(a.childNodes[0]);
      s._container = t;
      const l = s._resizeObserver;
      l && (l.disconnect(), l.observe(t)), i.setProps({
        ...e,
        styleDiffing: false
      }), s.resize();
      const { initialViewState: u } = e;
      return u && (u.bounds ? s.fitBounds(u.bounds, {
        ...u.fitBoundsOptions,
        duration: 0
      }) : i._updateViewState(u)), s.isStyleLoaded() ? s.fire("load") : s.once("style.load", () => s.fire("load")), s._update(), i;
    }
    _initialize(e) {
      const { props: t } = this, { mapStyle: i = nb } = t, s = {
        ...t,
        ...t.initialViewState,
        container: e,
        style: tb(i)
      }, a = s.initialViewState || s.viewState || s;
      if (Object.assign(s, {
        center: [
          a.longitude || 0,
          a.latitude || 0
        ],
        zoom: a.zoom || 0,
        pitch: a.pitch || 0,
        bearing: a.bearing || 0
      }), t.gl) {
        const u = HTMLCanvasElement.prototype.getContext;
        HTMLCanvasElement.prototype.getContext = () => (HTMLCanvasElement.prototype.getContext = u, t.gl);
      }
      const l = new this._MapClass(s);
      a.padding && l.setPadding(a.padding), t.cursor && (l.getCanvas().style.cursor = t.cursor), l.transformCameraUpdate = this._onCameraUpdate, l.on("style.load", () => {
        var _a2;
        this._styleComponents = {
          light: l.getLight(),
          sky: l.getSky(),
          projection: (_a2 = l.getProjection) == null ? void 0 : _a2.call(l),
          terrain: l.getTerrain()
        }, this._updateStyleComponents(this.props);
      }), l.on("sourcedata", () => {
        this._updateStyleComponents(this.props);
      });
      for (const u in ib) l.on(u, this._onPointerEvent);
      for (const u in sb) l.on(u, this._onCameraEvent);
      for (const u in rb) l.on(u, this._onEvent);
      this._map = l;
    }
    recycle() {
      var _a2;
      (_a2 = this.map.getContainer().querySelector("[mapboxgl-children]")) == null ? void 0 : _a2.remove(), Fr.savedMaps.push(this);
    }
    destroy() {
      this._map.remove();
    }
    redraw() {
      const e = this._map;
      e.style && (e._frame && (e._frame.cancel(), e._frame = null), e._render());
    }
    _updateSize(e) {
      const { viewState: t } = e;
      if (t) {
        const i = this._map;
        if (t.width !== i.transform.width || t.height !== i.transform.height) return i.resize(), true;
      }
      return false;
    }
    _updateViewState(e) {
      const t = this._map, i = t.transform;
      if (!t.isMoving()) {
        const a = eb(i, e);
        if (Object.keys(a).length > 0) return this._internalUpdate = true, t.jumpTo(a), this._internalUpdate = false, true;
      }
      return false;
    }
    _updateSettings(e, t) {
      var _a2;
      const i = this._map;
      let s = false;
      for (const a of OS) a in e && !Dn(e[a], t[a]) && (s = true, (_a2 = i[`set${a[0].toUpperCase()}${a.slice(1)}`]) == null ? void 0 : _a2.call(i, e[a]));
      return s;
    }
    _updateStyle(e, t) {
      if (e.cursor !== t.cursor && (this._map.getCanvas().style.cursor = e.cursor || ""), e.mapStyle !== t.mapStyle) {
        const { mapStyle: i = nb, styleDiffing: s = true } = e, a = {
          diff: s
        };
        "localIdeographFontFamily" in e && (a.localIdeographFontFamily = e.localIdeographFontFamily), this._map.setStyle(tb(i), a);
      }
    }
    _updateStyleComponents({ light: e, projection: t, sky: i, terrain: s }) {
      var _a2, _b3;
      const a = this._map, l = this._styleComponents;
      a.style._loaded && (e && !Dn(e, l.light) && (l.light = e, a.setLight(e)), t && !Dn(t, l.projection) && t !== ((_a2 = l.projection) == null ? void 0 : _a2.type) && (l.projection = typeof t == "string" ? {
        type: t
      } : t, (_b3 = a.setProjection) == null ? void 0 : _b3.call(a, l.projection)), i && !Dn(i, l.sky) && (l.sky = i, a.setSky(i)), s !== void 0 && !Dn(s, l.terrain) && (!s || a.getSource(s.source)) && (l.terrain = s, a.setTerrain(s)));
    }
    _updateHandlers(e, t) {
      const i = this._map;
      for (const s of IS) {
        const a = e[s] ?? true, l = t[s] ?? true;
        Dn(a, l) || (a ? i[s].enable(a) : i[s].disable());
      }
    }
    _queryRenderedFeatures(e) {
      const t = this._map, { interactiveLayerIds: i = [] } = this.props;
      try {
        return t.queryRenderedFeatures(e, {
          layers: i.filter(t.getLayer.bind(t))
        });
      } catch {
        return [];
      }
    }
    _updateHover(e) {
      var _a2;
      const { props: t } = this;
      if (t.interactiveLayerIds && (t.onMouseMove || t.onMouseEnter || t.onMouseLeave)) {
        const s = e.type, a = ((_a2 = this._hoveredFeatures) == null ? void 0 : _a2.length) > 0, l = this._queryRenderedFeatures(e.point), u = l.length > 0;
        !u && a && (e.type = "mouseleave", this._onPointerEvent(e)), this._hoveredFeatures = l, u && !a && (e.type = "mouseenter", this._onPointerEvent(e)), e.type = s;
      } else this._hoveredFeatures = null;
    }
  }
  Fr.savedMaps = [];
  const NS = [
    "setMaxBounds",
    "setMinZoom",
    "setMaxZoom",
    "setMinPitch",
    "setMaxPitch",
    "setRenderWorldCopies",
    "setProjection",
    "setStyle",
    "addSource",
    "removeSource",
    "addLayer",
    "removeLayer",
    "setLayerZoomRange",
    "setFilter",
    "setPaintProperty",
    "setLayoutProperty",
    "setLight",
    "setTerrain",
    "setFog",
    "remove"
  ];
  function PS(n) {
    if (!n) return null;
    const e = n.map, t = {
      getMap: () => e
    };
    for (const i of DS(e)) !(i in t) && !NS.includes(i) && (t[i] = e[i].bind(e));
    return t;
  }
  function DS(n) {
    const e = /* @__PURE__ */ new Set();
    let t = n;
    for (; t; ) {
      for (const i of Object.getOwnPropertyNames(t)) i[0] !== "_" && typeof n[i] == "function" && i !== "fire" && i !== "setEventedParent" && e.add(i);
      t = Object.getPrototypeOf(t);
    }
    return Array.from(e);
  }
  const kS = typeof document < "u" ? G.useLayoutEffect : G.useEffect;
  function US(n, e) {
    const { RTLTextPlugin: t, maxParallelImageRequests: i, workerCount: s, workerUrl: a } = e;
    if (t && n.getRTLTextPluginStatus && n.getRTLTextPluginStatus() === "unavailable") {
      const { pluginUrl: l, lazy: u = true } = typeof t == "string" ? {
        pluginUrl: t
      } : t;
      n.setRTLTextPlugin(l, (h) => {
        h && console.error(h);
      }, u);
    }
    i !== void 0 && n.setMaxParallelImageRequests(i), s !== void 0 && n.setWorkerCount(s), a !== void 0 && n.setWorkerUrl(a);
  }
  const $c = G.createContext(null);
  function BS(n, e) {
    const t = G.useContext(RS), [i, s] = G.useState(null), a = G.useRef(), { current: l } = G.useRef({
      mapLib: null,
      map: null
    });
    G.useEffect(() => {
      const d = n.mapLib;
      let p = true, _;
      return Promise.resolve(d || ES(() => import("./maplibre-gl-B_gIu0FU.js").then((y) => y.m), [])).then((y) => {
        if (!p) return;
        if (!y) throw new Error("Invalid mapLib");
        const v = "Map" in y ? y : y.default;
        if (!v.Map) throw new Error("Invalid mapLib");
        US(v, n), n.reuseMaps && (_ = Fr.reuse(n, a.current)), _ || (_ = new Fr(v.Map, n, a.current)), l.map = PS(_), l.mapLib = v, s(_), t == null ? void 0 : t.onMapMount(l.map, n.id);
      }).catch((y) => {
        const { onError: v } = n;
        v ? v({
          type: "error",
          target: null,
          originalEvent: null,
          error: y
        }) : console.error(y);
      }), () => {
        p = false, _ && (t == null ? void 0 : t.onMapUnmount(n.id), n.reuseMaps ? _.recycle() : _.destroy());
      };
    }, []), kS(() => {
      i && i.setProps(n);
    }), G.useImperativeHandle(e, () => l.map, [
      i
    ]);
    const u = G.useMemo(() => ({
      position: "relative",
      width: "100%",
      height: "100%",
      ...n.style
    }), [
      n.style
    ]), h = {
      height: "100%"
    };
    return G.createElement("div", {
      id: n.id,
      ref: a,
      style: u
    }, i && G.createElement($c.Provider, {
      value: l
    }, G.createElement("div", {
      "mapboxgl-children": "",
      style: h
    }, n.children)));
  }
  const LS = G.forwardRef(BS);
  var Wv = jv();
  const FS = /box|flex|grid|column|lineHeight|fontWeight|opacity|order|tabSize|zIndex/;
  function ci(n, e) {
    if (!n || !e) return;
    const t = n.style;
    for (const i in e) {
      const s = e[i];
      Number.isFinite(s) && !FS.test(i) ? t[i] = `${s}px` : t[i] = s;
    }
  }
  function $v(n, e) {
    if (n === e) return null;
    const t = ab(n), i = ab(e), s = [];
    for (const a of i) t.has(a) || s.push(a);
    for (const a of t) i.has(a) || s.push(a);
    return s.length === 0 ? null : s;
  }
  function ab(n) {
    return new Set(n ? n.trim().split(/\s+/) : []);
  }
  G.memo(G.forwardRef((n, e) => {
    const { map: t, mapLib: i } = G.useContext($c), s = G.useRef({
      props: n
    }), a = G.useMemo(() => {
      let F = false;
      G.Children.forEach(n.children, (U) => {
        U && (F = true);
      });
      const H = {
        ...n,
        element: F ? document.createElement("div") : void 0
      }, O = new i.Marker(H);
      return O.setLngLat([
        n.longitude,
        n.latitude
      ]), O.getElement().addEventListener("click", (U) => {
        var _a2, _b3;
        (_b3 = (_a2 = s.current.props).onClick) == null ? void 0 : _b3.call(_a2, {
          type: "click",
          target: O,
          originalEvent: U
        });
      }), O.on("dragstart", (U) => {
        var _a2, _b3;
        const B = U;
        B.lngLat = a.getLngLat(), (_b3 = (_a2 = s.current.props).onDragStart) == null ? void 0 : _b3.call(_a2, B);
      }), O.on("drag", (U) => {
        var _a2, _b3;
        const B = U;
        B.lngLat = a.getLngLat(), (_b3 = (_a2 = s.current.props).onDrag) == null ? void 0 : _b3.call(_a2, B);
      }), O.on("dragend", (U) => {
        var _a2, _b3;
        const B = U;
        B.lngLat = a.getLngLat(), (_b3 = (_a2 = s.current.props).onDragEnd) == null ? void 0 : _b3.call(_a2, B);
      }), O;
    }, []);
    G.useEffect(() => (a.addTo(t.getMap()), () => {
      a.remove();
    }), []);
    const { longitude: l, latitude: u, offset: h, style: d, draggable: p = false, popup: _ = null, rotation: y = 0, rotationAlignment: v = "auto", pitchAlignment: S = "auto" } = n;
    G.useEffect(() => {
      ci(a.getElement(), d);
    }, [
      d
    ]), G.useImperativeHandle(e, () => a, []);
    const E = s.current.props;
    (a.getLngLat().lng !== l || a.getLngLat().lat !== u) && a.setLngLat([
      l,
      u
    ]), h && !CS(a.getOffset(), h) && a.setOffset(h), a.isDraggable() !== p && a.setDraggable(p), a.getRotation() !== y && a.setRotation(y), a.getRotationAlignment() !== v && a.setRotationAlignment(v), a.getPitchAlignment() !== S && a.setPitchAlignment(S), a.getPopup() !== _ && a.setPopup(_);
    const M = $v(E.className, n.className);
    if (M) for (const F of M) a.toggleClassName(F);
    return s.current.props = n, Wv.createPortal(n.children, a.getElement());
  }));
  G.memo(G.forwardRef((n, e) => {
    const { map: t, mapLib: i } = G.useContext($c), s = G.useMemo(() => document.createElement("div"), []), a = G.useRef({
      props: n
    }), l = G.useMemo(() => {
      const u = {
        ...n
      }, h = new i.Popup(u);
      return h.setLngLat([
        n.longitude,
        n.latitude
      ]), h.once("open", (d) => {
        var _a2, _b3;
        (_b3 = (_a2 = a.current.props).onOpen) == null ? void 0 : _b3.call(_a2, d);
      }), h;
    }, []);
    if (G.useEffect(() => {
      const u = (h) => {
        var _a2, _b3;
        (_b3 = (_a2 = a.current.props).onClose) == null ? void 0 : _b3.call(_a2, h);
      };
      return l.on("close", u), l.setDOMContent(s).addTo(t.getMap()), () => {
        l.off("close", u), l.isOpen() && l.remove();
      };
    }, []), G.useEffect(() => {
      ci(l.getElement(), n.style);
    }, [
      n.style
    ]), G.useImperativeHandle(e, () => l, []), l.isOpen()) {
      const u = a.current.props;
      (l.getLngLat().lng !== n.longitude || l.getLngLat().lat !== n.latitude) && l.setLngLat([
        n.longitude,
        n.latitude
      ]), n.offset && !Dn(u.offset, n.offset) && l.setOffset(n.offset), (u.anchor !== n.anchor || u.maxWidth !== n.maxWidth) && (l.options.anchor = n.anchor, l.setMaxWidth(n.maxWidth));
      const h = $v(u.className, n.className);
      if (h) for (const d of h) l.toggleClassName(d);
      a.current.props = n;
    }
    return Wv.createPortal(n.children, s);
  }));
  function Os(n, e, t, i) {
    const s = G.useContext($c), a = G.useMemo(() => n(s), []);
    return G.useEffect(() => {
      const l = e, u = null, h = typeof e == "function" ? e : null, { map: d } = s;
      return d.hasControl(a) || (d.addControl(a, l == null ? void 0 : l.position), u && u(s)), () => {
        h && h(s), d.hasControl(a) && d.removeControl(a);
      };
    }, []), a;
  }
  function VS(n) {
    const e = Os(({ mapLib: t }) => new t.AttributionControl(n), {
      position: n.position
    });
    return G.useEffect(() => {
      ci(e._container, n.style);
    }, [
      n.style
    ]), null;
  }
  G.memo(VS);
  function zS(n) {
    const e = Os(({ mapLib: t }) => new t.FullscreenControl({
      container: n.containerId && document.getElementById(n.containerId)
    }), {
      position: n.position
    });
    return G.useEffect(() => {
      ci(e._controlContainer, n.style);
    }, [
      n.style
    ]), null;
  }
  G.memo(zS);
  function HS(n, e) {
    const t = G.useRef({
      props: n
    }), i = Os(({ mapLib: s }) => {
      const a = new s.GeolocateControl(n), l = a._setupUI;
      return a._setupUI = () => {
        a._container.hasChildNodes() || l();
      }, a.on("geolocate", (u) => {
        var _a2, _b3;
        (_b3 = (_a2 = t.current.props).onGeolocate) == null ? void 0 : _b3.call(_a2, u);
      }), a.on("error", (u) => {
        var _a2, _b3;
        (_b3 = (_a2 = t.current.props).onError) == null ? void 0 : _b3.call(_a2, u);
      }), a.on("outofmaxbounds", (u) => {
        var _a2, _b3;
        (_b3 = (_a2 = t.current.props).onOutOfMaxBounds) == null ? void 0 : _b3.call(_a2, u);
      }), a.on("trackuserlocationstart", (u) => {
        var _a2, _b3;
        (_b3 = (_a2 = t.current.props).onTrackUserLocationStart) == null ? void 0 : _b3.call(_a2, u);
      }), a.on("trackuserlocationend", (u) => {
        var _a2, _b3;
        (_b3 = (_a2 = t.current.props).onTrackUserLocationEnd) == null ? void 0 : _b3.call(_a2, u);
      }), a;
    }, {
      position: n.position
    });
    return t.current.props = n, G.useImperativeHandle(e, () => i, []), G.useEffect(() => {
      ci(i._container, n.style);
    }, [
      n.style
    ]), null;
  }
  G.memo(G.forwardRef(HS));
  function jS(n) {
    const e = Os(({ mapLib: t }) => new t.NavigationControl(n), {
      position: n.position
    });
    return G.useEffect(() => {
      ci(e._container, n.style);
    }, [
      n.style
    ]), null;
  }
  G.memo(jS);
  function WS(n) {
    const e = Os(({ mapLib: a }) => new a.ScaleControl(n), {
      position: n.position
    }), t = G.useRef(n), i = t.current;
    t.current = n;
    const { style: s } = n;
    return n.maxWidth !== void 0 && n.maxWidth !== i.maxWidth && (e.options.maxWidth = n.maxWidth), n.unit !== void 0 && n.unit !== i.unit && e.setUnit(n.unit), G.useEffect(() => {
      ci(e._container, s);
    }, [
      s
    ]), null;
  }
  G.memo(WS);
  function $S(n) {
    const e = Os(({ mapLib: t }) => new t.TerrainControl(n), {
      position: n.position
    });
    return G.useEffect(() => {
      ci(e._container, n.style);
    }, [
      n.style
    ]), null;
  }
  G.memo($S);
  function XS(n) {
    const e = Os(({ mapLib: t }) => new t.LogoControl(n), {
      position: n.position
    });
    return G.useEffect(() => {
      ci(e._container, n.style);
    }, [
      n.style
    ]), null;
  }
  G.memo(XS);
  function pc(n, e) {
    if (!n) throw new Error(e || "loader assertion failed.");
  }
  const Jd = !!(typeof process != "object" || String(process) !== "[object process]" || process.browser), ob = typeof process < "u" && process.version && /v([0-9]*)/.exec(process.version);
  ob && parseFloat(ob[1]);
  const lb = globalThis, cb = globalThis.process || {}, YS = globalThis.navigator || {};
  function Xv(n) {
    var _a2, _b3;
    if (typeof window < "u" && ((_a2 = window.process) == null ? void 0 : _a2.type) === "renderer" || typeof process < "u" && ((_b3 = process.versions) == null ? void 0 : _b3.electron)) return true;
    const t = typeof navigator < "u" && navigator.userAgent;
    return !!(t && t.indexOf("Electron") >= 0);
  }
  function Is() {
    return !(typeof process == "object" && String(process) === "[object process]" && !(process == null ? void 0 : process.browser)) || Xv();
  }
  function qS(n) {
    return Is() ? Xv() ? "Electron" : (YS.userAgent || "").indexOf("Edge") > -1 ? "Edge" : globalThis.chrome ? "Chrome" : globalThis.safari ? "Safari" : globalThis.mozInnerScreenX ? "Firefox" : "Unknown" : "Node";
  }
  const Yv = "4.1.0";
  function KS(n) {
    try {
      const e = window[n], t = "__storage_test__";
      return e.setItem(t, t), e.removeItem(t), e;
    } catch {
      return null;
    }
  }
  class ZS {
    constructor(e, t, i = "sessionStorage") {
      this.storage = KS(i), this.id = e, this.config = t, this._loadConfiguration();
    }
    getConfiguration() {
      return this.config;
    }
    setConfiguration(e) {
      if (Object.assign(this.config, e), this.storage) {
        const t = JSON.stringify(this.config);
        this.storage.setItem(this.id, t);
      }
    }
    _loadConfiguration() {
      let e = {};
      if (this.storage) {
        const t = this.storage.getItem(this.id);
        e = t ? JSON.parse(t) : {};
      }
      return Object.assign(this.config, e), this;
    }
  }
  function QS(n) {
    let e;
    return n < 10 ? e = `${n.toFixed(2)}ms` : n < 100 ? e = `${n.toFixed(1)}ms` : n < 1e3 ? e = `${n.toFixed(0)}ms` : e = `${(n / 1e3).toFixed(2)}s`, e;
  }
  function GS(n, e = 8) {
    const t = Math.max(e - n.length, 0);
    return `${" ".repeat(t)}${n}`;
  }
  var mc;
  (function(n) {
    n[n.BLACK = 30] = "BLACK", n[n.RED = 31] = "RED", n[n.GREEN = 32] = "GREEN", n[n.YELLOW = 33] = "YELLOW", n[n.BLUE = 34] = "BLUE", n[n.MAGENTA = 35] = "MAGENTA", n[n.CYAN = 36] = "CYAN", n[n.WHITE = 37] = "WHITE", n[n.BRIGHT_BLACK = 90] = "BRIGHT_BLACK", n[n.BRIGHT_RED = 91] = "BRIGHT_RED", n[n.BRIGHT_GREEN = 92] = "BRIGHT_GREEN", n[n.BRIGHT_YELLOW = 93] = "BRIGHT_YELLOW", n[n.BRIGHT_BLUE = 94] = "BRIGHT_BLUE", n[n.BRIGHT_MAGENTA = 95] = "BRIGHT_MAGENTA", n[n.BRIGHT_CYAN = 96] = "BRIGHT_CYAN", n[n.BRIGHT_WHITE = 97] = "BRIGHT_WHITE";
  })(mc || (mc = {}));
  const JS = 10;
  function ub(n) {
    return typeof n != "string" ? n : (n = n.toUpperCase(), mc[n] || mc.WHITE);
  }
  function eA(n, e, t) {
    return !Is && typeof n == "string" && (e && (n = `\x1B[${ub(e)}m${n}\x1B[39m`), t && (n = `\x1B[${ub(t) + JS}m${n}\x1B[49m`)), n;
  }
  function tA(n, e = [
    "constructor"
  ]) {
    const t = Object.getPrototypeOf(n), i = Object.getOwnPropertyNames(t), s = n;
    for (const a of i) {
      const l = s[a];
      typeof l == "function" && (e.find((u) => a === u) || (s[a] = l.bind(n)));
    }
  }
  function eg(n, e) {
    if (!n) throw new Error("Assertion failed");
  }
  function vr() {
    var _a2, _b3, _c2;
    let n;
    if (Is() && lb.performance) n = (_b3 = (_a2 = lb == null ? void 0 : lb.performance) == null ? void 0 : _a2.now) == null ? void 0 : _b3.call(_a2);
    else if ("hrtime" in cb) {
      const e = (_c2 = cb == null ? void 0 : cb.hrtime) == null ? void 0 : _c2.call(cb);
      n = e[0] * 1e3 + e[1] / 1e6;
    } else n = Date.now();
    return n;
  }
  const Tr = {
    debug: Is() && console.debug || console.log,
    log: console.log,
    info: console.info,
    warn: console.warn,
    error: console.error
  }, nA = {
    enabled: true,
    level: 0
  };
  function xr() {
  }
  const fb = {}, hb = {
    once: true
  };
  class So {
    constructor({ id: e } = {
      id: ""
    }) {
      this.VERSION = Yv, this._startTs = vr(), this._deltaTs = vr(), this.userData = {}, this.LOG_THROTTLE_TIMEOUT = 0, this.id = e, this.userData = {}, this._storage = new ZS(`__probe-${this.id}__`, nA), this.timeStamp(`${this.id} started`), tA(this), Object.seal(this);
    }
    set level(e) {
      this.setLevel(e);
    }
    get level() {
      return this.getLevel();
    }
    isEnabled() {
      return this._storage.config.enabled;
    }
    getLevel() {
      return this._storage.config.level;
    }
    getTotal() {
      return Number((vr() - this._startTs).toPrecision(10));
    }
    getDelta() {
      return Number((vr() - this._deltaTs).toPrecision(10));
    }
    set priority(e) {
      this.level = e;
    }
    get priority() {
      return this.level;
    }
    getPriority() {
      return this.level;
    }
    enable(e = true) {
      return this._storage.setConfiguration({
        enabled: e
      }), this;
    }
    setLevel(e) {
      return this._storage.setConfiguration({
        level: e
      }), this;
    }
    get(e) {
      return this._storage.config[e];
    }
    set(e, t) {
      this._storage.setConfiguration({
        [e]: t
      });
    }
    settings() {
      console.table ? console.table(this._storage.config) : console.log(this._storage.config);
    }
    assert(e, t) {
      if (!e) throw new Error(t || "Assertion failed");
    }
    warn(e) {
      return this._getLogFunction(0, e, Tr.warn, arguments, hb);
    }
    error(e) {
      return this._getLogFunction(0, e, Tr.error, arguments);
    }
    deprecated(e, t) {
      return this.warn(`\`${e}\` is deprecated and will be removed in a later version. Use \`${t}\` instead`);
    }
    removed(e, t) {
      return this.error(`\`${e}\` has been removed. Use \`${t}\` instead`);
    }
    probe(e, t) {
      return this._getLogFunction(e, t, Tr.log, arguments, {
        time: true,
        once: true
      });
    }
    log(e, t) {
      return this._getLogFunction(e, t, Tr.debug, arguments);
    }
    info(e, t) {
      return this._getLogFunction(e, t, console.info, arguments);
    }
    once(e, t) {
      return this._getLogFunction(e, t, Tr.debug || Tr.info, arguments, hb);
    }
    table(e, t, i) {
      return t ? this._getLogFunction(e, t, console.table || xr, i && [
        i
      ], {
        tag: sA(t)
      }) : xr;
    }
    time(e, t) {
      return this._getLogFunction(e, t, console.time ? console.time : console.info);
    }
    timeEnd(e, t) {
      return this._getLogFunction(e, t, console.timeEnd ? console.timeEnd : console.info);
    }
    timeStamp(e, t) {
      return this._getLogFunction(e, t, console.timeStamp || xr);
    }
    group(e, t, i = {
      collapsed: false
    }) {
      const s = db({
        logLevel: e,
        message: t,
        opts: i
      }), { collapsed: a } = i;
      return s.method = (a ? console.groupCollapsed : console.group) || console.info, this._getLogFunction(s);
    }
    groupCollapsed(e, t, i = {}) {
      return this.group(e, t, Object.assign({}, i, {
        collapsed: true
      }));
    }
    groupEnd(e) {
      return this._getLogFunction(e, "", console.groupEnd || xr);
    }
    withGroup(e, t, i) {
      this.group(e, t)();
      try {
        i();
      } finally {
        this.groupEnd(e)();
      }
    }
    trace() {
      console.trace && console.trace();
    }
    _shouldLog(e) {
      return this.isEnabled() && this.getLevel() >= qv(e);
    }
    _getLogFunction(e, t, i, s, a) {
      if (this._shouldLog(e)) {
        a = db({
          logLevel: e,
          message: t,
          args: s,
          opts: a
        }), i = i || a.method, eg(i), a.total = this.getTotal(), a.delta = this.getDelta(), this._deltaTs = vr();
        const l = a.tag || a.message;
        if (a.once && l) if (!fb[l]) fb[l] = vr();
        else return xr;
        return t = iA(this.id, a.message, a), i.bind(console, t, ...a.args);
      }
      return xr;
    }
  }
  So.VERSION = Yv;
  function qv(n) {
    if (!n) return 0;
    let e;
    switch (typeof n) {
      case "number":
        e = n;
        break;
      case "object":
        e = n.logLevel || n.priority || 0;
        break;
      default:
        return 0;
    }
    return eg(Number.isFinite(e) && e >= 0), e;
  }
  function db(n) {
    const { logLevel: e, message: t } = n;
    n.logLevel = qv(e);
    const i = n.args ? Array.from(n.args) : [];
    for (; i.length && i.shift() !== t; ) ;
    switch (typeof e) {
      case "string":
      case "function":
        t !== void 0 && i.unshift(t), n.message = e;
        break;
      case "object":
        Object.assign(n, e);
        break;
    }
    typeof n.message == "function" && (n.message = n.message());
    const s = typeof n.message;
    return eg(s === "string" || s === "object"), Object.assign(n, {
      args: i
    }, n.opts);
  }
  function iA(n, e, t) {
    if (typeof e == "string") {
      const i = t.time ? GS(QS(t.total)) : "";
      e = t.time ? `${n}: ${i}  ${e}` : `${n}: ${e}`, e = eA(e, t.color, t.background);
    }
    return e;
  }
  function sA(n) {
    for (const e in n) for (const t in n[e]) return t || "untitled";
    return "empty";
  }
  const wh = "4.3.2", rA = wh[0] >= "0" && wh[0] <= "9" ? `v${wh}` : "";
  function aA() {
    const n = new So({
      id: "loaders.gl"
    });
    return globalThis.loaders = globalThis.loaders || {}, globalThis.loaders.log = n, globalThis.loaders.version = rA, globalThis.probe = globalThis.probe || {}, globalThis.probe.loaders = n, n;
  }
  const oA = aA();
  function lA(n, e) {
    return Kv(n || {}, e);
  }
  function Kv(n, e, t = 0) {
    if (t > 3) return e;
    const i = {
      ...n
    };
    for (const [s, a] of Object.entries(e)) a && typeof a == "object" && !Array.isArray(a) ? i[s] = Kv(i[s] || {}, e[s], t + 1) : i[s] = e[s];
    return i;
  }
  const cA = "latest";
  function uA() {
    var _a2;
    return ((_a2 = globalThis._loadersgl_) == null ? void 0 : _a2.version) || (globalThis._loadersgl_ = globalThis._loadersgl_ || {}, globalThis._loadersgl_.version = "4.3.2"), globalThis._loadersgl_.version;
  }
  const fA = uA();
  function Yi(n, e) {
    if (!n) throw new Error(e || "loaders.gl assertion failed.");
  }
  const Ts = typeof process != "object" || String(process) !== "[object process]" || process.browser, hA = typeof window < "u" && typeof window.orientation < "u", gb = typeof process < "u" && process.version && /v([0-9]*)/.exec(process.version);
  gb && parseFloat(gb[1]);
  class dA {
    constructor(e, t) {
      __publicField(this, "name");
      __publicField(this, "workerThread");
      __publicField(this, "isRunning", true);
      __publicField(this, "result");
      __publicField(this, "_resolve", () => {
      });
      __publicField(this, "_reject", () => {
      });
      this.name = e, this.workerThread = t, this.result = new Promise((i, s) => {
        this._resolve = i, this._reject = s;
      });
    }
    postMessage(e, t) {
      this.workerThread.postMessage({
        source: "loaders.gl",
        type: e,
        payload: t
      });
    }
    done(e) {
      Yi(this.isRunning), this.isRunning = false, this._resolve(e);
    }
    error(e) {
      Yi(this.isRunning), this.isRunning = false, this._reject(e);
    }
  }
  class Eh {
    terminate() {
    }
  }
  const Rh = /* @__PURE__ */ new Map();
  function gA(n) {
    Yi(n.source && !n.url || !n.source && n.url);
    let e = Rh.get(n.source || n.url);
    return e || (n.url && (e = pA(n.url), Rh.set(n.url, e)), n.source && (e = Zv(n.source), Rh.set(n.source, e))), Yi(e), e;
  }
  function pA(n) {
    if (!n.startsWith("http")) return n;
    const e = mA(n);
    return Zv(e);
  }
  function Zv(n) {
    const e = new Blob([
      n
    ], {
      type: "application/javascript"
    });
    return URL.createObjectURL(e);
  }
  function mA(n) {
    return `try {
  importScripts('${n}');
} catch (error) {
  console.error(error);
  throw error;
}`;
  }
  function Qv(n, e = true, t) {
    const i = t || /* @__PURE__ */ new Set();
    if (n) {
      if (pb(n)) i.add(n);
      else if (pb(n.buffer)) i.add(n.buffer);
      else if (!ArrayBuffer.isView(n)) {
        if (e && typeof n == "object") for (const s in n) Qv(n[s], e, i);
      }
    }
    return t === void 0 ? Array.from(i) : [];
  }
  function pb(n) {
    return n ? n instanceof ArrayBuffer || typeof MessagePort < "u" && n instanceof MessagePort || typeof ImageBitmap < "u" && n instanceof ImageBitmap || typeof OffscreenCanvas < "u" && n instanceof OffscreenCanvas : false;
  }
  const Ch = () => {
  };
  class dd {
    constructor(e) {
      __publicField(this, "name");
      __publicField(this, "source");
      __publicField(this, "url");
      __publicField(this, "terminated", false);
      __publicField(this, "worker");
      __publicField(this, "onMessage");
      __publicField(this, "onError");
      __publicField(this, "_loadableURL", "");
      const { name: t, source: i, url: s } = e;
      Yi(i || s), this.name = t, this.source = i, this.url = s, this.onMessage = Ch, this.onError = (a) => console.log(a), this.worker = Ts ? this._createBrowserWorker() : this._createNodeWorker();
    }
    static isSupported() {
      return typeof Worker < "u" && Ts || typeof Eh < "u" && !Ts;
    }
    destroy() {
      this.onMessage = Ch, this.onError = Ch, this.worker.terminate(), this.terminated = true;
    }
    get isRunning() {
      return !!this.onMessage;
    }
    postMessage(e, t) {
      t = t || Qv(e), this.worker.postMessage(e, t);
    }
    _getErrorFromErrorEvent(e) {
      let t = "Failed to load ";
      return t += `worker ${this.name} from ${this.url}. `, e.message && (t += `${e.message} in `), e.lineno && (t += `:${e.lineno}:${e.colno}`), new Error(t);
    }
    _createBrowserWorker() {
      this._loadableURL = gA({
        source: this.source,
        url: this.url
      });
      const e = new Worker(this._loadableURL, {
        name: this.name
      });
      return e.onmessage = (t) => {
        t.data ? this.onMessage(t.data) : this.onError(new Error("No data received"));
      }, e.onerror = (t) => {
        this.onError(this._getErrorFromErrorEvent(t)), this.terminated = true;
      }, e.onmessageerror = (t) => console.error(t), e;
    }
    _createNodeWorker() {
      let e;
      if (this.url) {
        const i = this.url.includes(":/") || this.url.startsWith("/") ? this.url : `./${this.url}`;
        e = new Eh(i, {
          eval: false
        });
      } else if (this.source) e = new Eh(this.source, {
        eval: true
      });
      else throw new Error("no worker");
      return e.on("message", (t) => {
        this.onMessage(t);
      }), e.on("error", (t) => {
        this.onError(t);
      }), e.on("exit", (t) => {
      }), e;
    }
  }
  let _A = class {
    constructor(e) {
      __publicField(this, "name", "unnamed");
      __publicField(this, "source");
      __publicField(this, "url");
      __publicField(this, "maxConcurrency", 1);
      __publicField(this, "maxMobileConcurrency", 1);
      __publicField(this, "onDebug", () => {
      });
      __publicField(this, "reuseWorkers", true);
      __publicField(this, "props", {});
      __publicField(this, "jobQueue", []);
      __publicField(this, "idleQueue", []);
      __publicField(this, "count", 0);
      __publicField(this, "isDestroyed", false);
      this.source = e.source, this.url = e.url, this.setProps(e);
    }
    static isSupported() {
      return dd.isSupported();
    }
    destroy() {
      this.idleQueue.forEach((e) => e.destroy()), this.isDestroyed = true;
    }
    setProps(e) {
      this.props = {
        ...this.props,
        ...e
      }, e.name !== void 0 && (this.name = e.name), e.maxConcurrency !== void 0 && (this.maxConcurrency = e.maxConcurrency), e.maxMobileConcurrency !== void 0 && (this.maxMobileConcurrency = e.maxMobileConcurrency), e.reuseWorkers !== void 0 && (this.reuseWorkers = e.reuseWorkers), e.onDebug !== void 0 && (this.onDebug = e.onDebug);
    }
    async startJob(e, t = (s, a, l) => s.done(l), i = (s, a) => s.error(a)) {
      const s = new Promise((a) => (this.jobQueue.push({
        name: e,
        onMessage: t,
        onError: i,
        onStart: a
      }), this));
      return this._startQueuedJob(), await s;
    }
    async _startQueuedJob() {
      if (!this.jobQueue.length) return;
      const e = this._getAvailableWorker();
      if (!e) return;
      const t = this.jobQueue.shift();
      if (t) {
        this.onDebug({
          message: "Starting job",
          name: t.name,
          workerThread: e,
          backlog: this.jobQueue.length
        });
        const i = new dA(t.name, e);
        e.onMessage = (s) => t.onMessage(i, s.type, s.payload), e.onError = (s) => t.onError(i, s), t.onStart(i);
        try {
          await i.result;
        } catch (s) {
          console.error(`Worker exception: ${s}`);
        } finally {
          this.returnWorkerToQueue(e);
        }
      }
    }
    returnWorkerToQueue(e) {
      !Ts || this.isDestroyed || !this.reuseWorkers || this.count > this._getMaxConcurrency() ? (e.destroy(), this.count--) : this.idleQueue.push(e), this.isDestroyed || this._startQueuedJob();
    }
    _getAvailableWorker() {
      if (this.idleQueue.length > 0) return this.idleQueue.shift() || null;
      if (this.count < this._getMaxConcurrency()) {
        this.count++;
        const e = `${this.name.toLowerCase()} (#${this.count} of ${this.maxConcurrency})`;
        return new dd({
          name: e,
          source: this.source,
          url: this.url
        });
      }
      return null;
    }
    _getMaxConcurrency() {
      return hA ? this.maxMobileConcurrency : this.maxConcurrency;
    }
  };
  const yA = {
    maxConcurrency: 3,
    maxMobileConcurrency: 1,
    reuseWorkers: true,
    onDebug: () => {
    }
  };
  const _Vi = class _Vi {
    constructor(e) {
      __publicField(this, "props");
      __publicField(this, "workerPools", /* @__PURE__ */ new Map());
      this.props = {
        ...yA
      }, this.setProps(e), this.workerPools = /* @__PURE__ */ new Map();
    }
    static isSupported() {
      return dd.isSupported();
    }
    static getWorkerFarm(e = {}) {
      return _Vi._workerFarm = _Vi._workerFarm || new _Vi({}), _Vi._workerFarm.setProps(e), _Vi._workerFarm;
    }
    destroy() {
      for (const e of this.workerPools.values()) e.destroy();
      this.workerPools = /* @__PURE__ */ new Map();
    }
    setProps(e) {
      this.props = {
        ...this.props,
        ...e
      };
      for (const t of this.workerPools.values()) t.setProps(this._getWorkerPoolProps());
    }
    getWorkerPool(e) {
      const { name: t, source: i, url: s } = e;
      let a = this.workerPools.get(t);
      return a || (a = new _A({
        name: t,
        source: i,
        url: s
      }), a.setProps(this._getWorkerPoolProps()), this.workerPools.set(t, a)), a;
    }
    _getWorkerPoolProps() {
      return {
        maxConcurrency: this.props.maxConcurrency,
        maxMobileConcurrency: this.props.maxMobileConcurrency,
        reuseWorkers: this.props.reuseWorkers,
        onDebug: this.props.onDebug
      };
    }
  };
  __publicField(_Vi, "_workerFarm");
  let Vi = _Vi;
  function bA(n, e = {}) {
    const t = e[n.id] || {}, i = Ts ? `${n.id}-worker.js` : `${n.id}-worker-node.js`;
    let s = t.workerUrl;
    if (!s && n.id === "compression" && (s = e.workerUrl), e._workerType === "test" && (Ts ? s = `modules/${n.module}/dist/${i}` : s = `modules/${n.module}/src/workers/${n.id}-worker-node.ts`), !s) {
      let a = n.version;
      a === "latest" && (a = cA);
      const l = a ? `@${a}` : "";
      s = `https://unpkg.com/@loaders.gl/${n.module}${l}/dist/${i}`;
    }
    return Yi(s), s;
  }
  function vA(n, e = fA) {
    Yi(n, "no worker provided");
    const t = n.version;
    return !(!e || !t);
  }
  function TA(n, e) {
    return !Vi.isSupported() || !Ts && !(e == null ? void 0 : e._nodeWorkers) ? false : n.worker && (e == null ? void 0 : e.worker);
  }
  async function xA(n, e, t, i, s) {
    const a = n.id, l = bA(n, t), h = Vi.getWorkerFarm(t).getWorkerPool({
      name: a,
      url: l
    });
    t = JSON.parse(JSON.stringify(t)), i = JSON.parse(JSON.stringify(i || {}));
    const d = await h.startJob("process-on-worker", SA.bind(null, s));
    return d.postMessage("process", {
      input: e,
      options: t,
      context: i
    }), await (await d.result).result;
  }
  async function SA(n, e, t, i) {
    switch (t) {
      case "done":
        e.done(i);
        break;
      case "error":
        e.error(new Error(i.error));
        break;
      case "process":
        const { id: s, input: a, options: l } = i;
        try {
          const u = await n(a, l);
          e.postMessage("done", {
            id: s,
            result: u
          });
        } catch (u) {
          const h = u instanceof Error ? u.message : "unknown error";
          e.postMessage("error", {
            id: s,
            error: h
          });
        }
        break;
      default:
        console.warn(`parse-with-worker unknown message ${t}`);
    }
  }
  function AA(n, e, t) {
    if (t = t || n.byteLength, n.byteLength < t || e.byteLength < t) return false;
    const i = new Uint8Array(n), s = new Uint8Array(e);
    for (let a = 0; a < i.length; ++a) if (i[a] !== s[a]) return false;
    return true;
  }
  function wA(...n) {
    return EA(n);
  }
  function EA(n) {
    const e = n.map((a) => a instanceof ArrayBuffer ? new Uint8Array(a) : a), t = e.reduce((a, l) => a + l.byteLength, 0), i = new Uint8Array(t);
    let s = 0;
    for (const a of e) i.set(a, s), s += a.byteLength;
    return i.buffer;
  }
  async function RA(n) {
    const e = [];
    for await (const t of n) e.push(t);
    return wA(...e);
  }
  function mb() {
    let n;
    if (typeof window < "u" && window.performance) n = window.performance.now();
    else if (typeof process < "u" && process.hrtime) {
      const e = process.hrtime();
      n = e[0] * 1e3 + e[1] / 1e6;
    } else n = Date.now();
    return n;
  }
  class _b {
    constructor(e, t) {
      this.sampleSize = 1, this.time = 0, this.count = 0, this.samples = 0, this.lastTiming = 0, this.lastSampleTime = 0, this.lastSampleCount = 0, this._count = 0, this._time = 0, this._samples = 0, this._startTime = 0, this._timerPending = false, this.name = e, this.type = t, this.reset();
    }
    reset() {
      return this.time = 0, this.count = 0, this.samples = 0, this.lastTiming = 0, this.lastSampleTime = 0, this.lastSampleCount = 0, this._count = 0, this._time = 0, this._samples = 0, this._startTime = 0, this._timerPending = false, this;
    }
    setSampleSize(e) {
      return this.sampleSize = e, this;
    }
    incrementCount() {
      return this.addCount(1), this;
    }
    decrementCount() {
      return this.subtractCount(1), this;
    }
    addCount(e) {
      return this._count += e, this._samples++, this._checkSampling(), this;
    }
    subtractCount(e) {
      return this._count -= e, this._samples++, this._checkSampling(), this;
    }
    addTime(e) {
      return this._time += e, this.lastTiming = e, this._samples++, this._checkSampling(), this;
    }
    timeStart() {
      return this._startTime = mb(), this._timerPending = true, this;
    }
    timeEnd() {
      return this._timerPending ? (this.addTime(mb() - this._startTime), this._timerPending = false, this._checkSampling(), this) : this;
    }
    getSampleAverageCount() {
      return this.sampleSize > 0 ? this.lastSampleCount / this.sampleSize : 0;
    }
    getSampleAverageTime() {
      return this.sampleSize > 0 ? this.lastSampleTime / this.sampleSize : 0;
    }
    getSampleHz() {
      return this.lastSampleTime > 0 ? this.sampleSize / (this.lastSampleTime / 1e3) : 0;
    }
    getAverageCount() {
      return this.samples > 0 ? this.count / this.samples : 0;
    }
    getAverageTime() {
      return this.samples > 0 ? this.time / this.samples : 0;
    }
    getHz() {
      return this.time > 0 ? this.samples / (this.time / 1e3) : 0;
    }
    _checkSampling() {
      this._samples === this.sampleSize && (this.lastSampleTime = this._time, this.lastSampleCount = this._count, this.count += this._count, this.time += this._time, this.samples += this._samples, this._time = 0, this._count = 0, this._samples = 0);
    }
  }
  class Xc {
    constructor(e) {
      this.stats = {}, this.id = e.id, this.stats = {}, this._initializeStats(e.stats), Object.seal(this);
    }
    get(e, t = "count") {
      return this._getOrCreate({
        name: e,
        type: t
      });
    }
    get size() {
      return Object.keys(this.stats).length;
    }
    reset() {
      for (const e of Object.values(this.stats)) e.reset();
      return this;
    }
    forEach(e) {
      for (const t of Object.values(this.stats)) e(t);
    }
    getTable() {
      const e = {};
      return this.forEach((t) => {
        e[t.name] = {
          time: t.time || 0,
          count: t.count || 0,
          average: t.getAverageTime() || 0,
          hz: t.getHz() || 0
        };
      }), e;
    }
    _initializeStats(e = []) {
      e.forEach((t) => this._getOrCreate(t));
    }
    _getOrCreate(e) {
      const { name: t, type: i } = e;
      let s = this.stats[t];
      return s || (e instanceof _b ? s = e : s = new _b(t, i), this.stats[t] = s), s;
    }
  }
  let CA = "";
  const yb = {};
  function MA(n) {
    for (const e in yb) if (n.startsWith(e)) {
      const t = yb[e];
      n = n.replace(e, t);
    }
    return !n.startsWith("http://") && !n.startsWith("https://") && (n = `${CA}${n}`), n;
  }
  function OA(n) {
    return n && typeof n == "object" && n.isBuffer;
  }
  function Gv(n) {
    if (OA(n)) return n;
    if (n instanceof ArrayBuffer) return n;
    if (ArrayBuffer.isView(n)) return n.byteOffset === 0 && n.byteLength === n.buffer.byteLength ? n.buffer : n.buffer.slice(n.byteOffset, n.byteOffset + n.byteLength);
    if (typeof n == "string") {
      const e = n;
      return new TextEncoder().encode(e).buffer;
    }
    if (n && typeof n == "object" && n._toArrayBuffer) return n._toArrayBuffer();
    throw new Error("toArrayBuffer");
  }
  function Jv(n) {
    const e = n ? n.lastIndexOf("/") : -1;
    return e >= 0 ? n.substr(e + 1) : "";
  }
  function IA(n) {
    const e = n ? n.lastIndexOf("/") : -1;
    return e >= 0 ? n.substr(0, e) : "";
  }
  const NA = (n) => typeof n == "boolean", ao = (n) => typeof n == "function", Ao = (n) => n !== null && typeof n == "object", bb = (n) => Ao(n) && n.constructor === {}.constructor, PA = (n) => !!n && typeof n[Symbol.iterator] == "function", DA = (n) => n && typeof n[Symbol.asyncIterator] == "function", Ns = (n) => typeof Response < "u" && n instanceof Response || n && n.arrayBuffer && n.text && n.json, Ps = (n) => typeof Blob < "u" && n instanceof Blob, kA = (n) => n && typeof n == "object" && n.isBuffer, UA = (n) => typeof ReadableStream < "u" && n instanceof ReadableStream || Ao(n) && ao(n.tee) && ao(n.cancel) && ao(n.getReader), BA = (n) => Ao(n) && ao(n.read) && ao(n.pipe) && NA(n.readable), e3 = (n) => UA(n) || BA(n);
  class LA extends Error {
    constructor(e, t) {
      super(e);
      __publicField(this, "reason");
      __publicField(this, "url");
      __publicField(this, "response");
      this.reason = t.reason, this.url = t.url, this.response = t.response;
    }
  }
  const FA = /^data:([-\w.]+\/[-\w.+]+)(;|,)/, VA = /^([-\w.]+\/[-\w.+]+)/;
  function vb(n, e) {
    return n.toLowerCase() === e.toLowerCase();
  }
  function zA(n) {
    const e = VA.exec(n);
    return e ? e[1] : n;
  }
  function Tb(n) {
    const e = FA.exec(n);
    return e ? e[1] : "";
  }
  const t3 = /\?.*/;
  function HA(n) {
    const e = n.match(t3);
    return e && e[0];
  }
  function tg(n) {
    return n.replace(t3, "");
  }
  function jA(n) {
    if (n.length < 50) return n;
    const e = n.slice(n.length - 15);
    return `${n.substr(0, 32)}...${e}`;
  }
  function Yc(n) {
    return Ns(n) ? n.url : Ps(n) ? n.name || "" : typeof n == "string" ? n : "";
  }
  function ng(n) {
    if (Ns(n)) {
      const e = n, t = e.headers.get("content-type") || "", i = tg(e.url);
      return zA(t) || Tb(i);
    }
    return Ps(n) ? n.type || "" : typeof n == "string" ? Tb(n) : "";
  }
  function WA(n) {
    return Ns(n) ? n.headers["content-length"] || -1 : Ps(n) ? n.size : typeof n == "string" ? n.length : n instanceof ArrayBuffer || ArrayBuffer.isView(n) ? n.byteLength : -1;
  }
  async function n3(n) {
    if (Ns(n)) return n;
    const e = {}, t = WA(n);
    t >= 0 && (e["content-length"] = String(t));
    const i = Yc(n), s = ng(n);
    s && (e["content-type"] = s);
    const a = await YA(n);
    a && (e["x-first-bytes"] = a), typeof n == "string" && (n = new TextEncoder().encode(n));
    const l = new Response(n, {
      headers: e
    });
    return Object.defineProperty(l, "url", {
      value: i
    }), l;
  }
  async function $A(n) {
    if (!n.ok) throw await XA(n);
  }
  async function XA(n) {
    const e = jA(n.url);
    let t = `Failed to fetch resource (${n.status}) ${n.statusText}: ${e}`;
    t = t.length > 100 ? `${t.slice(0, 100)}...` : t;
    const i = {
      reason: n.statusText,
      url: n.url,
      response: n
    };
    try {
      const s = n.headers.get("Content-Type");
      i.reason = !n.bodyUsed && (s == null ? void 0 : s.includes("application/json")) ? await n.json() : await n.text();
    } catch {
    }
    return new LA(t, i);
  }
  async function YA(n) {
    if (typeof n == "string") return `data:,${n.slice(0, 5)}`;
    if (n instanceof Blob) {
      const t = n.slice(0, 5);
      return await new Promise((i) => {
        const s = new FileReader();
        s.onload = (a) => {
          var _a2;
          return i((_a2 = a == null ? void 0 : a.target) == null ? void 0 : _a2.result);
        }, s.readAsDataURL(t);
      });
    }
    if (n instanceof ArrayBuffer) {
      const t = n.slice(0, 5);
      return `data:base64,${qA(t)}`;
    }
    return null;
  }
  function qA(n) {
    let e = "";
    const t = new Uint8Array(n);
    for (let i = 0; i < t.byteLength; i++) e += String.fromCharCode(t[i]);
    return btoa(e);
  }
  function KA(n) {
    return !ZA(n) && !QA(n);
  }
  function ZA(n) {
    return n.startsWith("http:") || n.startsWith("https:");
  }
  function QA(n) {
    return n.startsWith("data:");
  }
  async function xb(n, e) {
    var _a2, _b3;
    if (typeof n == "string") {
      const t = MA(n);
      return KA(t) && ((_a2 = globalThis.loaders) == null ? void 0 : _a2.fetchNode) ? (_b3 = globalThis.loaders) == null ? void 0 : _b3.fetchNode(t, e) : await fetch(t, e);
    }
    return await n3(n);
  }
  const Sb = new So({
    id: "loaders.gl"
  });
  class GA {
    log() {
      return () => {
      };
    }
    info() {
      return () => {
      };
    }
    warn() {
      return () => {
      };
    }
    error() {
      return () => {
      };
    }
  }
  class JA {
    constructor() {
      __publicField(this, "console");
      this.console = console;
    }
    log(...e) {
      return this.console.log.bind(this.console, ...e);
    }
    info(...e) {
      return this.console.info.bind(this.console, ...e);
    }
    warn(...e) {
      return this.console.warn.bind(this.console, ...e);
    }
    error(...e) {
      return this.console.error.bind(this.console, ...e);
    }
  }
  const i3 = {
    fetch: null,
    mimeType: void 0,
    nothrow: false,
    log: new JA(),
    useLocalLibraries: false,
    CDN: "https://unpkg.com/@loaders.gl",
    worker: true,
    maxConcurrency: 3,
    maxMobileConcurrency: 1,
    reuseWorkers: Jd,
    _nodeWorkers: false,
    _workerType: "",
    limit: 0,
    _limitMB: 0,
    batchSize: "auto",
    batchDebounceMs: 0,
    metadata: false,
    transforms: []
  }, ew = {
    throws: "nothrow",
    dataType: "(no longer used)",
    uri: "baseUri",
    method: "fetch.method",
    headers: "fetch.headers",
    body: "fetch.body",
    mode: "fetch.mode",
    credentials: "fetch.credentials",
    cache: "fetch.cache",
    redirect: "fetch.redirect",
    referrer: "fetch.referrer",
    referrerPolicy: "fetch.referrerPolicy",
    integrity: "fetch.integrity",
    keepalive: "fetch.keepalive",
    signal: "fetch.signal"
  };
  function s3() {
    globalThis.loaders = globalThis.loaders || {};
    const { loaders: n } = globalThis;
    return n._state || (n._state = {}), n._state;
  }
  function r3() {
    const n = s3();
    return n.globalOptions = n.globalOptions || {
      ...i3
    }, n.globalOptions;
  }
  function tw(n, e, t, i) {
    return t = t || [], t = Array.isArray(t) ? t : [
      t
    ], nw(n, t), sw(e, n, i);
  }
  function nw(n, e) {
    Ab(n, null, i3, ew, e);
    for (const t of e) {
      const i = n && n[t.id] || {}, s = t.options && t.options[t.id] || {}, a = t.deprecatedOptions && t.deprecatedOptions[t.id] || {};
      Ab(i, t.id, s, a, e);
    }
  }
  function Ab(n, e, t, i, s) {
    const a = e || "Top level", l = e ? `${e}.` : "";
    for (const u in n) {
      const h = !e && Ao(n[u]), d = u === "baseUri" && !e, p = u === "workerUrl" && e;
      if (!(u in t) && !d && !p) {
        if (u in i) Sb.warn(`${a} loader option '${l}${u}' no longer supported, use '${i[u]}'`)();
        else if (!h) {
          const _ = iw(u, s);
          Sb.warn(`${a} loader option '${l}${u}' not recognized. ${_}`)();
        }
      }
    }
  }
  function iw(n, e) {
    const t = n.toLowerCase();
    let i = "";
    for (const s of e) for (const a in s.options) {
      if (n === a) return `Did you mean '${s.id}.${a}'?`;
      const l = a.toLowerCase();
      (t.startsWith(l) || l.startsWith(t)) && (i = i || `Did you mean '${s.id}.${a}'?`);
    }
    return i;
  }
  function sw(n, e, t) {
    const s = {
      ...n.options || {}
    };
    return rw(s, t), s.log === null && (s.log = new GA()), wb(s, r3()), wb(s, e), s;
  }
  function wb(n, e) {
    for (const t in e) if (t in e) {
      const i = e[t];
      bb(i) && bb(n[t]) ? n[t] = {
        ...n[t],
        ...e[t]
      } : n[t] = e[t];
    }
  }
  function rw(n, e) {
    e && !("baseUri" in n) && (n.baseUri = e);
  }
  function ig(n) {
    return n ? (Array.isArray(n) && (n = n[0]), Array.isArray(n == null ? void 0 : n.extensions)) : false;
  }
  function sg(n) {
    pc(n, "null loader"), pc(ig(n), "invalid loader");
    let e;
    return Array.isArray(n) && (e = n[1], n = n[0], n = {
      ...n,
      options: {
        ...n.options,
        ...e
      }
    }), ((n == null ? void 0 : n.parseTextSync) || (n == null ? void 0 : n.parseText)) && (n.text = true), n.text || (n.binary = true), n;
  }
  const a3 = () => {
    const n = s3();
    return n.loaderRegistry = n.loaderRegistry || [], n.loaderRegistry;
  };
  function aw(n) {
    const e = a3();
    n = Array.isArray(n) ? n : [
      n
    ];
    for (const t of n) {
      const i = sg(t);
      e.find((s) => i === s) || e.unshift(i);
    }
  }
  function ow() {
    return a3();
  }
  const lw = /\.([^.]+)$/;
  async function cw(n, e = [], t, i) {
    if (!o3(n)) return null;
    let s = Eb(n, e, {
      ...t,
      nothrow: true
    }, i);
    if (s) return s;
    if (Ps(n) && (n = await n.slice(0, 10).arrayBuffer(), s = Eb(n, e, t, i)), !s && !(t == null ? void 0 : t.nothrow)) throw new Error(l3(n));
    return s;
  }
  function Eb(n, e = [], t, i) {
    if (!o3(n)) return null;
    if (e && !Array.isArray(e)) return sg(e);
    let s = [];
    e && (s = s.concat(e)), (t == null ? void 0 : t.ignoreRegisteredLoaders) || s.push(...ow()), fw(s);
    const a = uw(n, s, t, i);
    if (!a && !(t == null ? void 0 : t.nothrow)) throw new Error(l3(n));
    return a;
  }
  function uw(n, e, t, i) {
    const s = Yc(n), a = ng(n), l = tg(s) || (i == null ? void 0 : i.url);
    let u = null, h = "";
    return (t == null ? void 0 : t.mimeType) && (u = Mh(e, t == null ? void 0 : t.mimeType), h = `match forced by supplied MIME type ${t == null ? void 0 : t.mimeType}`), u = u || hw(e, l), h = h || (u ? `matched url ${l}` : ""), u = u || Mh(e, a), h = h || (u ? `matched MIME type ${a}` : ""), u = u || gw(e, n), h = h || (u ? `matched initial data ${c3(n)}` : ""), (t == null ? void 0 : t.fallbackMimeType) && (u = u || Mh(e, t == null ? void 0 : t.fallbackMimeType), h = h || (u ? `matched fallback MIME type ${a}` : "")), h && oA.log(1, `selectLoader selected ${u == null ? void 0 : u.name}: ${h}.`), u;
  }
  function o3(n) {
    return !(n instanceof Response && n.status === 204);
  }
  function l3(n) {
    const e = Yc(n), t = ng(n);
    let i = "No valid loader found (";
    i += e ? `${Jv(e)}, ` : "no url provided, ", i += `MIME type: ${t ? `"${t}"` : "not provided"}, `;
    const s = n ? c3(n) : "";
    return i += s ? ` first bytes: "${s}"` : "first bytes: not available", i += ")", i;
  }
  function fw(n) {
    for (const e of n) sg(e);
  }
  function hw(n, e) {
    const t = e && lw.exec(e), i = t && t[1];
    return i ? dw(n, i) : null;
  }
  function dw(n, e) {
    e = e.toLowerCase();
    for (const t of n) for (const i of t.extensions) if (i.toLowerCase() === e) return t;
    return null;
  }
  function Mh(n, e) {
    var _a2;
    for (const t of n) if (((_a2 = t.mimeTypes) == null ? void 0 : _a2.some((i) => vb(e, i))) || vb(e, `application/x.${t.id}`)) return t;
    return null;
  }
  function gw(n, e) {
    if (!e) return null;
    for (const t of n) if (typeof e == "string") {
      if (pw(e, t)) return t;
    } else if (ArrayBuffer.isView(e)) {
      if (Rb(e.buffer, e.byteOffset, t)) return t;
    } else if (e instanceof ArrayBuffer && Rb(e, 0, t)) return t;
    return null;
  }
  function pw(n, e) {
    return e.testText ? e.testText(n) : (Array.isArray(e.tests) ? e.tests : [
      e.tests
    ]).some((i) => n.startsWith(i));
  }
  function Rb(n, e, t) {
    return (Array.isArray(t.tests) ? t.tests : [
      t.tests
    ]).some((s) => mw(n, e, t, s));
  }
  function mw(n, e, t, i) {
    if (i instanceof ArrayBuffer) return AA(i, n, i.byteLength);
    switch (typeof i) {
      case "function":
        return i(n);
      case "string":
        const s = gd(n, e, i.length);
        return i === s;
      default:
        return false;
    }
  }
  function c3(n, e = 5) {
    return typeof n == "string" ? n.slice(0, e) : ArrayBuffer.isView(n) ? gd(n.buffer, n.byteOffset, e) : n instanceof ArrayBuffer ? gd(n, 0, e) : "";
  }
  function gd(n, e, t) {
    if (n.byteLength < e + t) return "";
    const i = new DataView(n);
    let s = "";
    for (let a = 0; a < t; a++) s += String.fromCharCode(i.getUint8(e + a));
    return s;
  }
  const _w = 256 * 1024;
  function* yw(n, e) {
    const t = (e == null ? void 0 : e.chunkSize) || _w;
    let i = 0;
    const s = new TextEncoder();
    for (; i < n.length; ) {
      const a = Math.min(n.length - i, t), l = n.slice(i, i + a);
      i += a, yield s.encode(l);
    }
  }
  const bw = 256 * 1024;
  function* vw(n, e = {}) {
    const { chunkSize: t = bw } = e;
    let i = 0;
    for (; i < n.byteLength; ) {
      const s = Math.min(n.byteLength - i, t), a = new ArrayBuffer(s), l = new Uint8Array(n, i, s);
      new Uint8Array(a).set(l), i += s, yield a;
    }
  }
  const Tw = 1024 * 1024;
  async function* xw(n, e) {
    const t = (e == null ? void 0 : e.chunkSize) || Tw;
    let i = 0;
    for (; i < n.size; ) {
      const s = i + t, a = await n.slice(i, s).arrayBuffer();
      i = s, yield a;
    }
  }
  function Cb(n, e) {
    return Jd ? Sw(n, e) : Aw(n);
  }
  async function* Sw(n, e) {
    const t = n.getReader();
    let i;
    try {
      for (; ; ) {
        const s = i || t.read();
        (e == null ? void 0 : e._streamReadAhead) && (i = t.read());
        const { done: a, value: l } = await s;
        if (a) return;
        yield Gv(l);
      }
    } catch {
      t.releaseLock();
    }
  }
  async function* Aw(n, e) {
    for await (const t of n) yield Gv(t);
  }
  function ww(n, e) {
    if (typeof n == "string") return yw(n, e);
    if (n instanceof ArrayBuffer) return vw(n, e);
    if (Ps(n)) return xw(n, e);
    if (e3(n)) return Cb(n, e);
    if (Ns(n)) return Cb(n.body, e);
    throw new Error("makeIterator");
  }
  const u3 = "Cannot convert supplied data type";
  function Ew(n, e, t) {
    if (e.text && typeof n == "string") return n;
    if (kA(n) && (n = n.buffer), n instanceof ArrayBuffer) {
      const i = n;
      return e.text && !e.binary ? new TextDecoder("utf8").decode(i) : i;
    }
    if (ArrayBuffer.isView(n)) {
      if (e.text && !e.binary) return new TextDecoder("utf8").decode(n);
      let i = n.buffer;
      const s = n.byteLength || n.length;
      return (n.byteOffset !== 0 || s !== i.byteLength) && (i = i.slice(n.byteOffset, n.byteOffset + s)), i;
    }
    throw new Error(u3);
  }
  async function Rw(n, e, t) {
    const i = n instanceof ArrayBuffer || ArrayBuffer.isView(n);
    if (typeof n == "string" || i) return Ew(n, e);
    if (Ps(n) && (n = await n3(n)), Ns(n)) {
      const s = n;
      return await $A(s), e.binary ? await s.arrayBuffer() : await s.text();
    }
    if (e3(n) && (n = ww(n, t)), PA(n) || DA(n)) return RA(n);
    throw new Error(u3);
  }
  function f3(n, e) {
    const t = r3(), i = n || t;
    return typeof i.fetch == "function" ? i.fetch : Ao(i.fetch) ? (s) => xb(s, i.fetch) : (e == null ? void 0 : e.fetch) ? e == null ? void 0 : e.fetch : xb;
  }
  function Cw(n, e, t) {
    if (t) return t;
    const i = {
      fetch: f3(e, n),
      ...n
    };
    if (i.url) {
      const s = tg(i.url);
      i.baseUrl = s, i.queryString = HA(i.url), i.filename = Jv(s), i.baseUrl = IA(s);
    }
    return Array.isArray(i.loaders) || (i.loaders = null), i;
  }
  function Mw(n, e) {
    if (n && !Array.isArray(n)) return n;
    let t;
    if (n && (t = Array.isArray(n) ? n : [
      n
    ]), e && e.loaders) {
      const i = Array.isArray(e.loaders) ? e.loaders : [
        e.loaders
      ];
      t = t ? [
        ...t,
        ...i
      ] : i;
    }
    return t && t.length ? t : void 0;
  }
  async function _c(n, e, t, i) {
    e && !Array.isArray(e) && !ig(e) && (i = void 0, t = e, e = void 0), n = await n, t = t || {};
    const s = Yc(n), l = Mw(e, i), u = await cw(n, l, t);
    return u ? (t = tw(t, u, l, s), i = Cw({
      url: s,
      _parse: _c,
      loaders: l
    }, t, i || null), await Ow(u, n, t, i)) : null;
  }
  async function Ow(n, e, t, i) {
    if (vA(n), t = lA(n.options, t), Ns(e)) {
      const a = e, { ok: l, redirected: u, status: h, statusText: d, type: p, url: _ } = a, y = Object.fromEntries(a.headers.entries());
      i.response = {
        headers: y,
        ok: l,
        redirected: u,
        status: h,
        statusText: d,
        type: p,
        url: _
      };
    }
    e = await Rw(e, n, t);
    const s = n;
    if (s.parseTextSync && typeof e == "string") return s.parseTextSync(e, t, i);
    if (TA(n, t)) return await xA(n, e, t, i, _c);
    if (s.parseText && typeof e == "string") return await s.parseText(e, t, i);
    if (s.parse) return await s.parse(e, t, i);
    throw Yi(!s.parseSync), new Error(`${n.id} loader - no parser found and worker is disabled`);
  }
  async function pd(n, e, t, i) {
    let s, a;
    !Array.isArray(e) && !ig(e) ? (s = [], a = e) : (s = e, a = t);
    const l = f3(a);
    let u = n;
    return typeof n == "string" && (u = await l(n)), Ps(n) && (u = await l(n)), Array.isArray(s) ? await _c(u, s, a) : await _c(u, s, a);
  }
  const Iw = "4.3.2", Nw = (_a = globalThis.loaders) == null ? void 0 : _a.parseImageNode, md = typeof Image < "u", _d = typeof ImageBitmap < "u", Pw = !!Nw, yd = Jd ? true : Pw;
  function Dw(n) {
    switch (n) {
      case "auto":
        return _d || md || yd;
      case "imagebitmap":
        return _d;
      case "image":
        return md;
      case "data":
        return yd;
      default:
        throw new Error(`@loaders.gl/images: image ${n} not supported in this environment`);
    }
  }
  function kw() {
    if (_d) return "imagebitmap";
    if (md) return "image";
    if (yd) return "data";
    throw new Error("Install '@loaders.gl/polyfills' to parse images under Node.js");
  }
  function Uw(n) {
    const e = Lw(n);
    if (!e) throw new Error("Not an image");
    return e;
  }
  function Bw(n) {
    switch (Uw(n)) {
      case "data":
        return n;
      case "image":
      case "imagebitmap":
        const e = document.createElement("canvas"), t = e.getContext("2d");
        if (!t) throw new Error("getImageData");
        return e.width = n.width, e.height = n.height, t.drawImage(n, 0, 0), t.getImageData(0, 0, n.width, n.height);
      default:
        throw new Error("getImageData");
    }
  }
  function Lw(n) {
    return typeof ImageBitmap < "u" && n instanceof ImageBitmap ? "imagebitmap" : typeof Image < "u" && n instanceof Image ? "image" : n && typeof n == "object" && n.data && n.width && n.height ? "data" : null;
  }
  const Fw = /^data:image\/svg\+xml/, Vw = /\.svg((\?|#).*)?$/;
  function rg(n) {
    return n && (Fw.test(n) || Vw.test(n));
  }
  function zw(n, e) {
    if (rg(e)) {
      let i = new TextDecoder().decode(n);
      try {
        typeof unescape == "function" && typeof encodeURIComponent == "function" && (i = unescape(encodeURIComponent(i)));
      } catch (a) {
        throw new Error(a.message);
      }
      return `data:image/svg+xml;base64,${btoa(i)}`;
    }
    return h3(n, e);
  }
  function h3(n, e) {
    if (rg(e)) throw new Error("SVG cannot be parsed directly to imagebitmap");
    return new Blob([
      new Uint8Array(n)
    ]);
  }
  async function d3(n, e, t) {
    const i = zw(n, t), s = self.URL || self.webkitURL, a = typeof i != "string" && s.createObjectURL(i);
    try {
      return await Hw(a || i, e);
    } finally {
      a && s.revokeObjectURL(a);
    }
  }
  async function Hw(n, e) {
    const t = new Image();
    return t.src = n, e.image && e.image.decode && t.decode ? (await t.decode(), t) : await new Promise((i, s) => {
      try {
        t.onload = () => i(t), t.onerror = (a) => {
          const l = a instanceof Error ? a.message : "error";
          s(new Error(l));
        };
      } catch (a) {
        s(a);
      }
    });
  }
  const jw = {};
  let Mb = true;
  async function Ww(n, e, t) {
    let i;
    rg(t) ? i = await d3(n, e, t) : i = h3(n, t);
    const s = e && e.imagebitmap;
    return await $w(i, s);
  }
  async function $w(n, e = null) {
    if ((Xw(e) || !Mb) && (e = null), e) try {
      return await createImageBitmap(n, e);
    } catch (t) {
      console.warn(t), Mb = false;
    }
    return await createImageBitmap(n);
  }
  function Xw(n) {
    for (const e in n || jw) return false;
    return true;
  }
  function Yw(n) {
    return !Qw(n, "ftyp", 4) || (n[8] & 96) === 0 ? null : qw(n);
  }
  function qw(n) {
    switch (Kw(n, 8, 12).replace("\0", " ").trim()) {
      case "avif":
      case "avis":
        return {
          extension: "avif",
          mimeType: "image/avif"
        };
      default:
        return null;
    }
  }
  function Kw(n, e, t) {
    return String.fromCharCode(...n.slice(e, t));
  }
  function Zw(n) {
    return [
      ...n
    ].map((e) => e.charCodeAt(0));
  }
  function Qw(n, e, t = 0) {
    const i = Zw(e);
    for (let s = 0; s < i.length; ++s) if (i[s] !== n[s + t]) return false;
    return true;
  }
  const kn = false, oo = true;
  function g3(n) {
    const e = wo(n);
    return Jw(e) || nE(e) || eE(e) || tE(e) || Gw(e);
  }
  function Gw(n) {
    const e = new Uint8Array(n instanceof DataView ? n.buffer : n), t = Yw(e);
    return t ? {
      mimeType: t.mimeType,
      width: 0,
      height: 0
    } : null;
  }
  function Jw(n) {
    const e = wo(n);
    return e.byteLength >= 24 && e.getUint32(0, kn) === 2303741511 ? {
      mimeType: "image/png",
      width: e.getUint32(16, kn),
      height: e.getUint32(20, kn)
    } : null;
  }
  function eE(n) {
    const e = wo(n);
    return e.byteLength >= 10 && e.getUint32(0, kn) === 1195984440 ? {
      mimeType: "image/gif",
      width: e.getUint16(6, oo),
      height: e.getUint16(8, oo)
    } : null;
  }
  function tE(n) {
    const e = wo(n);
    return e.byteLength >= 14 && e.getUint16(0, kn) === 16973 && e.getUint32(2, oo) === e.byteLength ? {
      mimeType: "image/bmp",
      width: e.getUint32(18, oo),
      height: e.getUint32(22, oo)
    } : null;
  }
  function nE(n) {
    const e = wo(n);
    if (!(e.byteLength >= 3 && e.getUint16(0, kn) === 65496 && e.getUint8(2) === 255)) return null;
    const { tableMarkers: i, sofMarkers: s } = iE();
    let a = 2;
    for (; a + 9 < e.byteLength; ) {
      const l = e.getUint16(a, kn);
      if (s.has(l)) return {
        mimeType: "image/jpeg",
        height: e.getUint16(a + 5, kn),
        width: e.getUint16(a + 7, kn)
      };
      if (!i.has(l)) return null;
      a += 2, a += e.getUint16(a, kn);
    }
    return null;
  }
  function iE() {
    const n = /* @__PURE__ */ new Set([
      65499,
      65476,
      65484,
      65501,
      65534
    ]);
    for (let t = 65504; t < 65520; ++t) n.add(t);
    return {
      tableMarkers: n,
      sofMarkers: /* @__PURE__ */ new Set([
        65472,
        65473,
        65474,
        65475,
        65477,
        65478,
        65479,
        65481,
        65482,
        65483,
        65485,
        65486,
        65487,
        65502
      ])
    };
  }
  function wo(n) {
    if (n instanceof DataView) return n;
    if (ArrayBuffer.isView(n)) return new DataView(n.buffer);
    if (n instanceof ArrayBuffer) return new DataView(n);
    throw new Error("toDataView");
  }
  async function sE(n, e) {
    var _a2;
    const { mimeType: t } = g3(n) || {}, i = (_a2 = globalThis.loaders) == null ? void 0 : _a2.parseImageNode;
    return pc(i), await i(n, t);
  }
  async function rE(n, e, t) {
    e = e || {};
    const s = (e.image || {}).type || "auto", { url: a } = t || {}, l = aE(s);
    let u;
    switch (l) {
      case "imagebitmap":
        u = await Ww(n, e, a);
        break;
      case "image":
        u = await d3(n, e, a);
        break;
      case "data":
        u = await sE(n);
        break;
      default:
        pc(false);
    }
    return s === "data" && (u = Bw(u)), u;
  }
  function aE(n) {
    switch (n) {
      case "auto":
      case "data":
        return kw();
      default:
        return Dw(n), n;
    }
  }
  const oE = [
    "png",
    "jpg",
    "jpeg",
    "gif",
    "webp",
    "bmp",
    "ico",
    "svg",
    "avif"
  ], lE = [
    "image/png",
    "image/jpeg",
    "image/gif",
    "image/webp",
    "image/avif",
    "image/bmp",
    "image/vnd.microsoft.icon",
    "image/svg+xml"
  ], cE = {
    image: {
      type: "auto",
      decode: true
    }
  }, uE = {
    dataType: null,
    batchType: null,
    id: "image",
    module: "images",
    name: "Images",
    version: Iw,
    mimeTypes: lE,
    extensions: oE,
    parse: rE,
    tests: [
      (n) => !!g3(new DataView(n))
    ],
    options: cE
  }, Le = new So({
    id: "deck"
  });
  let bd = {};
  function fE(n) {
    bd = n;
  }
  function Ot(n, e, t, i) {
    Le.level > 0 && bd[n] && bd[n].call(null, e, t, i);
  }
  function hE(n) {
    const e = n[0], t = n[n.length - 1];
    return e === "{" && t === "}" || e === "[" && t === "]";
  }
  const dE = {
    dataType: null,
    batchType: null,
    id: "JSON",
    name: "JSON",
    module: "",
    version: "",
    options: {},
    extensions: [
      "json",
      "geojson"
    ],
    mimeTypes: [
      "application/json",
      "application/geo+json"
    ],
    testText: hE,
    parseTextSync: JSON.parse
  };
  function gE() {
    const n = "9.1.11", e = globalThis.deck && globalThis.deck.VERSION;
    if (e && e !== n) throw new Error(`deck.gl - multiple versions detected: ${e} vs ${n}`);
    return e || (Le.log(1, `deck.gl ${n}`)(), globalThis.deck = {
      ...globalThis.deck,
      VERSION: n,
      version: n,
      log: Le,
      _registerLoggers: fE
    }, aw([
      dE,
      [
        uE,
        {
          imagebitmap: {
            premultiplyAlpha: "none"
          }
        }
      ]
    ])), n;
  }
  const pE = gE();
  function ag(n, e) {
    if (!n) throw new Error(e || "shadertools: assertion failed.");
  }
  const Oh = {
    number: {
      type: "number",
      validate(n, e) {
        return Number.isFinite(n) && typeof e == "object" && (e.max === void 0 || n <= e.max) && (e.min === void 0 || n >= e.min);
      }
    },
    array: {
      type: "array",
      validate(n, e) {
        return Array.isArray(n) || ArrayBuffer.isView(n);
      }
    }
  };
  function mE(n) {
    const e = {};
    for (const [t, i] of Object.entries(n)) e[t] = _E(i);
    return e;
  }
  function _E(n) {
    let e = Ob(n);
    if (e !== "object") return {
      value: n,
      ...Oh[e],
      type: e
    };
    if (typeof n == "object") return n ? n.type !== void 0 ? {
      ...n,
      ...Oh[n.type],
      type: n.type
    } : n.value === void 0 ? {
      type: "object",
      value: n
    } : (e = Ob(n.value), {
      ...n,
      ...Oh[e],
      type: e
    }) : {
      type: "object",
      value: null
    };
    throw new Error("props");
  }
  function Ob(n) {
    return Array.isArray(n) || ArrayBuffer.isView(n) ? "array" : typeof n;
  }
  const yE = `#ifdef MODULE_LOGDEPTH
  logdepth_adjustPosition(gl_Position);
#endif
`, bE = `#ifdef MODULE_MATERIAL
  fragColor = material_filterColor(fragColor);
#endif

#ifdef MODULE_LIGHTING
  fragColor = lighting_filterColor(fragColor);
#endif

#ifdef MODULE_FOG
  fragColor = fog_filterColor(fragColor);
#endif

#ifdef MODULE_PICKING
  fragColor = picking_filterHighlightColor(fragColor);
  fragColor = picking_filterPickingColor(fragColor);
#endif

#ifdef MODULE_LOGDEPTH
  logdepth_setFragDepth();
#endif
`, vE = {
    vertex: yE,
    fragment: bE
  }, Ib = /void\s+main\s*\([^)]*\)\s*\{\n?/, Nb = /}\n?[^{}]*$/, Ih = [], oc = "__LUMA_INJECT_DECLARATIONS__";
  function TE(n) {
    const e = {
      vertex: {},
      fragment: {}
    };
    for (const t in n) {
      let i = n[t];
      const s = xE(t);
      typeof i == "string" && (i = {
        order: 0,
        injection: i
      }), e[s][t] = i;
    }
    return e;
  }
  function xE(n) {
    const e = n.slice(0, 2);
    switch (e) {
      case "vs":
        return "vertex";
      case "fs":
        return "fragment";
      default:
        throw new Error(e);
    }
  }
  function yc(n, e, t, i = false) {
    const s = e === "vertex";
    for (const a in t) {
      const l = t[a];
      l.sort((h, d) => h.order - d.order), Ih.length = l.length;
      for (let h = 0, d = l.length; h < d; ++h) Ih[h] = l[h].injection;
      const u = `${Ih.join(`
`)}
`;
      switch (a) {
        case "vs:#decl":
          s && (n = n.replace(oc, u));
          break;
        case "vs:#main-start":
          s && (n = n.replace(Ib, (h) => h + u));
          break;
        case "vs:#main-end":
          s && (n = n.replace(Nb, (h) => u + h));
          break;
        case "fs:#decl":
          s || (n = n.replace(oc, u));
          break;
        case "fs:#main-start":
          s || (n = n.replace(Ib, (h) => h + u));
          break;
        case "fs:#main-end":
          s || (n = n.replace(Nb, (h) => u + h));
          break;
        default:
          n = n.replace(a, (h) => h + u);
      }
    }
    return n = n.replace(oc, ""), i && (n = n.replace(/\}\s*$/, (a) => a + vE[e])), n;
  }
  function bc(n) {
    n.map((e) => SE(e));
  }
  function SE(n) {
    if (n.instance) return;
    bc(n.dependencies || []);
    const { propTypes: e = {}, deprecations: t = [], inject: i = {} } = n, s = {
      normalizedInjections: TE(i),
      parsedDeprecations: AE(t)
    };
    e && (s.propValidators = mE(e)), n.instance = s;
    let a = {};
    e && (a = Object.entries(e).reduce((l, [u, h]) => {
      const d = h == null ? void 0 : h.value;
      return d && (l[u] = d), l;
    }, {})), n.defaultUniforms = {
      ...n.defaultUniforms,
      ...a
    };
  }
  function p3(n, e, t) {
    var _a2;
    (_a2 = n.deprecations) == null ? void 0 : _a2.forEach((i) => {
      var _a3;
      ((_a3 = i.regex) == null ? void 0 : _a3.test(e)) && (i.deprecated ? t.deprecated(i.old, i.new)() : t.removed(i.old, i.new)());
    });
  }
  function AE(n) {
    return n.forEach((e) => {
      switch (e.type) {
        case "function":
          e.regex = new RegExp(`\\b${e.old}\\(`);
          break;
        default:
          e.regex = new RegExp(`${e.type} ${e.old};`);
      }
    }), n;
  }
  function og(n) {
    bc(n);
    const e = {}, t = {};
    m3({
      modules: n,
      level: 0,
      moduleMap: e,
      moduleDepth: t
    });
    const i = Object.keys(t).sort((s, a) => t[a] - t[s]).map((s) => e[s]);
    return bc(i), i;
  }
  function m3(n) {
    const { modules: e, level: t, moduleMap: i, moduleDepth: s } = n;
    if (t >= 5) throw new Error("Possible loop in shader dependency graph");
    for (const a of e) i[a.name] = a, (s[a.name] === void 0 || s[a.name] < t) && (s[a.name] = t);
    for (const a of e) a.dependencies && m3({
      modules: a.dependencies,
      level: t + 1,
      moduleMap: i,
      moduleDepth: s
    });
  }
  function wE(n) {
    switch (n == null ? void 0 : n.gpu.toLowerCase()) {
      case "apple":
        return `#define APPLE_GPU
// Apple optimizes away the calculation necessary for emulated fp64
#define LUMA_FP64_CODE_ELIMINATION_WORKAROUND 1
#define LUMA_FP32_TAN_PRECISION_WORKAROUND 1
// Intel GPU doesn't have full 32 bits precision in same cases, causes overflow
#define LUMA_FP64_HIGH_BITS_OVERFLOW_WORKAROUND 1
`;
      case "nvidia":
        return `#define NVIDIA_GPU
// Nvidia optimizes away the calculation necessary for emulated fp64
#define LUMA_FP64_CODE_ELIMINATION_WORKAROUND 1
`;
      case "intel":
        return `#define INTEL_GPU
// Intel optimizes away the calculation necessary for emulated fp64
#define LUMA_FP64_CODE_ELIMINATION_WORKAROUND 1
// Intel's built-in 'tan' function doesn't have acceptable precision
#define LUMA_FP32_TAN_PRECISION_WORKAROUND 1
// Intel GPU doesn't have full 32 bits precision in same cases, causes overflow
#define LUMA_FP64_HIGH_BITS_OVERFLOW_WORKAROUND 1
`;
      case "amd":
        return `#define AMD_GPU
`;
      default:
        return `#define DEFAULT_GPU
// Prevent driver from optimizing away the calculation necessary for emulated fp64
#define LUMA_FP64_CODE_ELIMINATION_WORKAROUND 1
// Headless Chrome's software shader 'tan' function doesn't have acceptable precision
#define LUMA_FP32_TAN_PRECISION_WORKAROUND 1
// If the GPU doesn't have full 32 bits precision, will causes overflow
#define LUMA_FP64_HIGH_BITS_OVERFLOW_WORKAROUND 1
`;
    }
  }
  function EE(n, e) {
    var _a2;
    if (Number(((_a2 = n.match(/^#version[ \t]+(\d+)/m)) == null ? void 0 : _a2[1]) || 100) !== 300) throw new Error("luma.gl v9 only supports GLSL 3.00 shader sources");
    switch (e) {
      case "vertex":
        return n = Pb(n, RE), n;
      case "fragment":
        return n = Pb(n, CE), n;
      default:
        throw new Error(e);
    }
  }
  const _3 = [
    [
      /^(#version[ \t]+(100|300[ \t]+es))?[ \t]*\n/,
      `#version 300 es
`
    ],
    [
      /\btexture(2D|2DProj|Cube)Lod(EXT)?\(/g,
      "textureLod("
    ],
    [
      /\btexture(2D|2DProj|Cube)(EXT)?\(/g,
      "texture("
    ]
  ], RE = [
    ..._3,
    [
      vd("attribute"),
      "in $1"
    ],
    [
      vd("varying"),
      "out $1"
    ]
  ], CE = [
    ..._3,
    [
      vd("varying"),
      "in $1"
    ]
  ];
  function Pb(n, e) {
    for (const [t, i] of e) n = n.replace(t, i);
    return n;
  }
  function vd(n) {
    return new RegExp(`\\b${n}[ \\t]+(\\w+[ \\t]+\\w+(\\[\\w+\\])?;)`, "g");
  }
  function y3(n, e) {
    let t = "";
    for (const i in n) {
      const s = n[i];
      if (t += `void ${s.signature} {
`, s.header && (t += `  ${s.header}`), e[i]) {
        const a = e[i];
        a.sort((l, u) => l.order - u.order);
        for (const l of a) t += `  ${l.injection}
`;
      }
      s.footer && (t += `  ${s.footer}`), t += `}
`;
    }
    return t;
  }
  function b3(n) {
    const e = {
      vertex: {},
      fragment: {}
    };
    for (const t of n) {
      let i, s;
      typeof t != "string" ? (i = t, s = i.hook) : (i = {}, s = t), s = s.trim();
      const [a, l] = s.split(":"), u = s.replace(/\(.+/, ""), h = Object.assign(i, {
        signature: l
      });
      switch (a) {
        case "vs":
          e.vertex[u] = h;
          break;
        case "fs":
          e.fragment[u] = h;
          break;
        default:
          throw new Error(a);
      }
    }
    return e;
  }
  function ME(n, e) {
    return {
      name: OE(n, e),
      language: "glsl",
      version: IE(n)
    };
  }
  function OE(n, e = "unnamed") {
    const i = /#define[^\S\r\n]*SHADER_NAME[^\S\r\n]*([A-Za-z0-9_-]+)\s*/.exec(n);
    return i ? i[1] : e;
  }
  function IE(n) {
    let e = 100;
    const t = n.match(/[^\s]+/g);
    if (t && t.length >= 2 && t[0] === "#version") {
      const i = parseInt(t[1], 10);
      Number.isFinite(i) && (e = i);
    }
    if (e !== 100 && e !== 300) throw new Error(`Invalid GLSL version ${e}`);
    return e;
  }
  const v3 = `

${oc}
`, NE = `precision highp float;
`;
  function PE(n) {
    const e = og(n.modules || []);
    return {
      source: kE(n.platformInfo, {
        ...n,
        source: n.source,
        stage: "vertex",
        modules: e
      }),
      getUniforms: T3(e)
    };
  }
  function DE(n) {
    const { vs: e, fs: t } = n, i = og(n.modules || []);
    return {
      vs: Db(n.platformInfo, {
        ...n,
        source: e,
        stage: "vertex",
        modules: i
      }),
      fs: Db(n.platformInfo, {
        ...n,
        source: t,
        stage: "fragment",
        modules: i
      }),
      getUniforms: T3(i)
    };
  }
  function kE(n, e) {
    var _a2;
    const { source: t, stage: i, modules: s, hookFunctions: a = [], inject: l = {}, log: u } = e;
    ag(typeof t == "string", "shader source must be a string");
    const h = t;
    let d = "";
    const p = b3(a), _ = {}, y = {}, v = {};
    for (const E in l) {
      const M = typeof l[E] == "string" ? {
        injection: l[E],
        order: 0
      } : l[E], F = /^(v|f)s:(#)?([\w-]+)$/.exec(E);
      if (F) {
        const H = F[2], O = F[3];
        H ? O === "decl" ? y[E] = [
          M
        ] : v[E] = [
          M
        ] : _[E] = [
          M
        ];
      } else v[E] = [
        M
      ];
    }
    const S = s;
    for (const E of S) {
      u && p3(E, h, u);
      const M = x3(E, "wgsl");
      d += M;
      const F = ((_a2 = E.injections) == null ? void 0 : _a2[i]) || {};
      for (const H in F) {
        const O = /^(v|f)s:#([\w-]+)$/.exec(H);
        if (O) {
          const B = O[2] === "decl" ? y : v;
          B[H] = B[H] || [], B[H].push(F[H]);
        } else _[H] = _[H] || [], _[H].push(F[H]);
      }
    }
    return d += v3, d = yc(d, i, y), d += y3(p[i], _), d += h, d = yc(d, i, v), d;
  }
  function Db(n, e) {
    var _a2;
    const { id: t, source: i, stage: s, language: a = "glsl", modules: l, defines: u = {}, hookFunctions: h = [], inject: d = {}, prologue: p = true, log: _ } = e;
    ag(typeof i == "string", "shader source must be a string");
    const y = a === "glsl" ? ME(i).version : -1, v = n.shaderLanguageVersion, S = y === 100 ? "#version 100" : "#version 300 es", M = i.split(`
`).slice(1).join(`
`), F = {};
    l.forEach((re) => {
      Object.assign(F, re.defines);
    }), Object.assign(F, u);
    let H = "";
    switch (a) {
      case "wgsl":
        break;
      case "glsl":
        H = p ? `${S}

// ----- PROLOGUE -------------------------
${UE({
          id: t,
          source: i,
          stage: s
        })}
${`#define SHADER_TYPE_${s.toUpperCase()}`}

${wE(n)}
${s === "fragment" ? NE : ""}

// ----- APPLICATION DEFINES -------------------------

${BE(F)}

` : `${S}
`;
        break;
    }
    const O = b3(h), U = {}, B = {}, Z = {};
    for (const re in d) {
      const le = typeof d[re] == "string" ? {
        injection: d[re],
        order: 0
      } : d[re], ee = /^(v|f)s:(#)?([\w-]+)$/.exec(re);
      if (ee) {
        const fe = ee[2], te = ee[3];
        fe ? te === "decl" ? B[re] = [
          le
        ] : Z[re] = [
          le
        ] : U[re] = [
          le
        ];
      } else Z[re] = [
        le
      ];
    }
    for (const re of l) {
      _ && p3(re, M, _);
      const le = x3(re, s);
      H += le;
      const ee = ((_a2 = re.instance) == null ? void 0 : _a2.normalizedInjections[s]) || {};
      for (const fe in ee) {
        const te = /^(v|f)s:#([\w-]+)$/.exec(fe);
        if (te) {
          const xe = te[2] === "decl" ? B : Z;
          xe[fe] = xe[fe] || [], xe[fe].push(ee[fe]);
        } else U[fe] = U[fe] || [], U[fe].push(ee[fe]);
      }
    }
    return H += "// ----- MAIN SHADER SOURCE -------------------------", H += v3, H = yc(H, s, B), H += y3(O[s], U), H += M, H = yc(H, s, Z), a === "glsl" && y !== v && (H = EE(H, s)), H.trim();
  }
  function T3(n) {
    return function(t) {
      var _a2;
      const i = {};
      for (const s of n) {
        const a = (_a2 = s.getUniforms) == null ? void 0 : _a2.call(s, t, i);
        Object.assign(i, a);
      }
      return i;
    };
  }
  function UE(n) {
    const { id: e, source: t, stage: i } = n;
    return e && t.indexOf("SHADER_NAME") === -1 ? `
#define SHADER_NAME ${e}_${i}` : "";
  }
  function BE(n = {}) {
    let e = "";
    for (const t in n) {
      const i = n[t];
      (i || Number.isFinite(i)) && (e += `#define ${t.toUpperCase()} ${n[t]}
`);
    }
    return e;
  }
  function x3(n, e) {
    let t;
    switch (e) {
      case "vertex":
        t = n.vs || "";
        break;
      case "fragment":
        t = n.fs || "";
        break;
      case "wgsl":
        t = n.source || "";
        break;
      default:
        ag(false);
    }
    if (!n.name) throw new Error("Shader module must have a name");
    const i = n.name.toUpperCase().replace(/[^0-9a-z]/gi, "_");
    let s = `// ----- MODULE ${n.name} ---------------

`;
    return e !== "wgsl" && (s += `#define MODULE_${i}
`), s += `${t}
`, s;
  }
  const LE = /^\s*\#\s*ifdef\s*([a-zA-Z_]+)\s*$/, FE = /^\s*\#\s*endif\s*$/;
  function VE(n, e) {
    var _a2;
    const t = n.split(`
`), i = [];
    let s = true, a = null;
    for (const l of t) {
      const u = l.match(LE), h = l.match(FE);
      u ? (a = u[1], s = !!((_a2 = e == null ? void 0 : e.defines) == null ? void 0 : _a2[a])) : h ? s = true : s && i.push(l);
    }
    return i.join(`
`);
  }
  const _ys = class _ys {
    constructor() {
      __publicField(this, "_hookFunctions", []);
      __publicField(this, "_defaultModules", []);
    }
    static getDefaultShaderAssembler() {
      return _ys.defaultShaderAssembler = _ys.defaultShaderAssembler || new _ys(), _ys.defaultShaderAssembler;
    }
    addDefaultModule(e) {
      this._defaultModules.find((t) => t.name === (typeof e == "string" ? e : e.name)) || this._defaultModules.push(e);
    }
    removeDefaultModule(e) {
      const t = typeof e == "string" ? e : e.name;
      this._defaultModules = this._defaultModules.filter((i) => i.name !== t);
    }
    addShaderHook(e, t) {
      t && (e = Object.assign(t, {
        hook: e
      })), this._hookFunctions.push(e);
    }
    assembleWGSLShader(e) {
      const t = this._getModuleList(e.modules), i = this._hookFunctions, { source: s, getUniforms: a } = PE({
        ...e,
        source: e.source,
        modules: t,
        hookFunctions: i
      });
      return {
        source: e.platformInfo.shaderLanguage === "wgsl" ? VE(s) : s,
        getUniforms: a,
        modules: t
      };
    }
    assembleGLSLShaderPair(e) {
      const t = this._getModuleList(e.modules), i = this._hookFunctions;
      return {
        ...DE({
          ...e,
          vs: e.vs,
          fs: e.fs,
          modules: t,
          hookFunctions: i
        }),
        modules: t
      };
    }
    _getModuleList(e = []) {
      const t = new Array(this._defaultModules.length + e.length), i = {};
      let s = 0;
      for (let a = 0, l = this._defaultModules.length; a < l; ++a) {
        const u = this._defaultModules[a], h = u.name;
        t[s++] = u, i[h] = true;
      }
      for (let a = 0, l = e.length; a < l; ++a) {
        const u = e[a], h = u.name;
        i[h] || (t[s++] = u, i[h] = true);
      }
      return t.length = s, bc(t), t;
    }
  };
  __publicField(_ys, "defaultShaderAssembler");
  let ys = _ys;
  const zE = `out vec4 transform_output;
void main() {
  transform_output = vec4(0);
}`, HE = `#version 300 es
${zE}`;
  function S3(n) {
    const { input: e, inputChannels: t, output: i } = n || {};
    if (!e) return HE;
    if (!t) throw new Error("inputChannels");
    const s = jE(t), a = WE(e, t);
    return `#version 300 es
in ${s} ${e};
out vec4 ${i};
void main() {
  ${i} = ${a};
}`;
  }
  function jE(n) {
    switch (n) {
      case 1:
        return "float";
      case 2:
        return "vec2";
      case 3:
        return "vec3";
      case 4:
        return "vec4";
      default:
        throw new Error(`invalid channels: ${n}`);
    }
  }
  function WE(n, e) {
    switch (e) {
      case 1:
        return `vec4(${n}, 0.0, 0.0, 1.0)`;
      case 2:
        return `vec4(${n}, 0.0, 1.0)`;
      case 3:
        return `vec4(${n}, 1.0)`;
      case 4:
        return n;
      default:
        throw new Error(`invalid channels: ${e}`);
    }
  }
  class $E {
    constructor() {
      __publicField(this, "stats", /* @__PURE__ */ new Map());
    }
    getStats(e) {
      return this.get(e);
    }
    get(e) {
      return this.stats.has(e) || this.stats.set(e, new Xc({
        id: e
      })), this.stats.get(e);
    }
  }
  const A3 = new $E(), J = new So({
    id: "luma.gl"
  }), Nh = {};
  function qc(n = "id") {
    Nh[n] = Nh[n] || 1;
    const e = Nh[n]++;
    return `${n}-${e}`;
  }
  let Xe = (_b2 = class {
    constructor(e, t, i) {
      __publicField(this, "id");
      __publicField(this, "props");
      __publicField(this, "userData", {});
      __publicField(this, "_device");
      __publicField(this, "destroyed", false);
      __publicField(this, "allocatedBytes", 0);
      __publicField(this, "_attachedResources", /* @__PURE__ */ new Set());
      if (!e) throw new Error("no device");
      this._device = e, this.props = XE(t, i);
      const s = this.props.id !== "undefined" ? this.props.id : qc(this[Symbol.toStringTag]);
      this.props.id = s, this.id = s, this.userData = this.props.userData || {}, this.addStats();
    }
    toString() {
      return `${this[Symbol.toStringTag] || this.constructor.name}:"${this.id}"`;
    }
    destroy() {
      this.destroyResource();
    }
    delete() {
      return this.destroy(), this;
    }
    getProps() {
      return this.props;
    }
    attachResource(e) {
      this._attachedResources.add(e);
    }
    detachResource(e) {
      this._attachedResources.delete(e);
    }
    destroyAttachedResource(e) {
      this._attachedResources.delete(e) && e.destroy();
    }
    destroyAttachedResources() {
      for (const e of Object.values(this._attachedResources)) e.destroy();
      this._attachedResources = /* @__PURE__ */ new Set();
    }
    destroyResource() {
      this.destroyAttachedResources(), this.removeStats(), this.destroyed = true;
    }
    removeStats() {
      const e = this._device.statsManager.getStats("Resource Counts"), t = this[Symbol.toStringTag];
      e.get(`${t}s Active`).decrementCount();
    }
    trackAllocatedMemory(e, t = this[Symbol.toStringTag]) {
      const i = this._device.statsManager.getStats("Resource Counts");
      i.get("GPU Memory").addCount(e), i.get(`${t} Memory`).addCount(e), this.allocatedBytes = e;
    }
    trackDeallocatedMemory(e = this[Symbol.toStringTag]) {
      const t = this._device.statsManager.getStats("Resource Counts");
      t.get("GPU Memory").subtractCount(this.allocatedBytes), t.get(`${e} Memory`).subtractCount(this.allocatedBytes), this.allocatedBytes = 0;
    }
    addStats() {
      const e = this._device.statsManager.getStats("Resource Counts"), t = this[Symbol.toStringTag];
      e.get("Resources Created").incrementCount(), e.get(`${t}s Created`).incrementCount(), e.get(`${t}s Active`).incrementCount();
    }
  }, __publicField(_b2, "defaultProps", {
    id: "undefined",
    handle: void 0,
    userData: void 0
  }), _b2);
  function XE(n, e) {
    const t = {
      ...e
    };
    for (const i in n) n[i] !== void 0 && (t[i] = n[i]);
    return t;
  }
  const _Ke = class _Ke extends Xe {
    constructor(e, t) {
      const i = {
        ...t
      };
      (t.usage || 0) & _Ke.INDEX && !t.indexType && (t.data instanceof Uint32Array ? i.indexType = "uint32" : t.data instanceof Uint16Array && (i.indexType = "uint16")), delete i.data;
      super(e, i, _Ke.defaultProps);
      __publicField(this, "usage");
      __publicField(this, "indexType");
      __publicField(this, "updateTimestamp");
      __publicField(this, "debugData", new ArrayBuffer(0));
      this.usage = i.usage || 0, this.indexType = i.indexType, this.updateTimestamp = e.incrementTimestamp();
    }
    get [Symbol.toStringTag]() {
      return "Buffer";
    }
    clone(e) {
      return this.device.createBuffer({
        ...this.props,
        ...e
      });
    }
    readSyncWebGL(e, t) {
      throw new Error("not implemented");
    }
    _setDebugData(e, t, i) {
      const s = ArrayBuffer.isView(e) ? e.buffer : e, a = Math.min(e ? e.byteLength : i, _Ke.DEBUG_DATA_MAX_LENGTH);
      s === null ? this.debugData = new ArrayBuffer(a) : t === 0 && i === s.byteLength ? this.debugData = s.slice(0, a) : this.debugData = s.slice(t, t + a);
    }
  };
  __publicField(_Ke, "defaultProps", {
    ...Xe.defaultProps,
    usage: 0,
    byteLength: 0,
    byteOffset: 0,
    data: null,
    indexType: "uint16",
    mappedAtCreation: false
  });
  __publicField(_Ke, "MAP_READ", 1);
  __publicField(_Ke, "MAP_WRITE", 2);
  __publicField(_Ke, "COPY_SRC", 4);
  __publicField(_Ke, "COPY_DST", 8);
  __publicField(_Ke, "INDEX", 16);
  __publicField(_Ke, "VERTEX", 32);
  __publicField(_Ke, "UNIFORM", 64);
  __publicField(_Ke, "STORAGE", 128);
  __publicField(_Ke, "INDIRECT", 256);
  __publicField(_Ke, "QUERY_RESOLVE", 512);
  __publicField(_Ke, "DEBUG_DATA_MAX_LENGTH", 32);
  let Ke = _Ke;
  function w3(n) {
    const e = kb[n], t = YE(e), i = n.includes("norm"), s = !i && !n.startsWith("float"), a = n.startsWith("s");
    return {
      dataType: kb[n],
      byteLength: t,
      integer: s,
      signed: a,
      normalized: i
    };
  }
  function YE(n) {
    return qE[n];
  }
  const kb = {
    uint8: "uint8",
    sint8: "sint8",
    unorm8: "uint8",
    snorm8: "sint8",
    uint16: "uint16",
    sint16: "sint16",
    unorm16: "uint16",
    snorm16: "sint16",
    float16: "float16",
    float32: "float32",
    uint32: "uint32",
    sint32: "sint32"
  }, qE = {
    uint8: 1,
    sint8: 1,
    uint16: 2,
    sint16: 2,
    float16: 2,
    float32: 4,
    uint32: 4,
    sint32: 4
  }, Rt = "texture-compression-bc", We = "texture-compression-astc", In = "texture-compression-etc2", KE = "texture-compression-etc1-webgl", $l = "texture-compression-pvrtc-webgl", Ph = "texture-compression-atc-webgl", Xl = "float32-renderable-webgl", Dh = "float16-renderable-webgl", ZE = "rgb9e5ufloat-renderable-webgl", kh = "snorm8-renderable-webgl", Qa = "norm16-renderable-webgl", Uh = "snorm16-renderable-webgl", Yl = "float32-filterable", Ub = "float16-filterable-webgl";
  function E3(n) {
    const e = QE[n];
    if (!e) throw new Error(`Unsupported texture format ${n}`);
    return e;
  }
  const QE = {
    r8unorm: {},
    r8snorm: {
      render: kh
    },
    r8uint: {},
    r8sint: {},
    rg8unorm: {},
    rg8snorm: {
      render: kh
    },
    rg8uint: {},
    rg8sint: {},
    r16uint: {},
    r16sint: {},
    r16float: {
      render: Dh,
      filter: "float16-filterable-webgl"
    },
    "r16unorm-webgl": {
      f: Qa
    },
    "r16snorm-webgl": {
      f: Uh
    },
    "rgba4unorm-webgl": {
      channels: "rgba",
      bitsPerChannel: [
        4,
        4,
        4,
        4
      ],
      packed: true
    },
    "rgb565unorm-webgl": {
      channels: "rgb",
      bitsPerChannel: [
        5,
        6,
        5,
        0
      ],
      packed: true
    },
    "rgb5a1unorm-webgl": {
      channels: "rgba",
      bitsPerChannel: [
        5,
        5,
        5,
        1
      ],
      packed: true
    },
    "rgb8unorm-webgl": {},
    "rgb8snorm-webgl": {},
    rgba8unorm: {},
    "rgba8unorm-srgb": {},
    rgba8snorm: {
      render: kh
    },
    rgba8uint: {},
    rgba8sint: {},
    bgra8unorm: {},
    "bgra8unorm-srgb": {},
    rg16uint: {},
    rg16sint: {},
    rg16float: {
      render: Dh,
      filter: Ub
    },
    "rg16unorm-webgl": {
      render: Qa
    },
    "rg16snorm-webgl": {
      render: Uh
    },
    r32uint: {},
    r32sint: {},
    r32float: {
      render: Xl,
      filter: Yl
    },
    rgb9e5ufloat: {
      channels: "rgb",
      packed: true,
      render: ZE
    },
    rg11b10ufloat: {
      channels: "rgb",
      bitsPerChannel: [
        11,
        11,
        10,
        0
      ],
      packed: true,
      p: 1,
      render: Xl
    },
    rgb10a2unorm: {
      channels: "rgba",
      bitsPerChannel: [
        10,
        10,
        10,
        2
      ],
      packed: true,
      p: 1
    },
    "rgb10a2uint-webgl": {
      channels: "rgba",
      bitsPerChannel: [
        10,
        10,
        10,
        2
      ],
      packed: true,
      p: 1,
      wgpu: false
    },
    "rgb16unorm-webgl": {
      f: Qa
    },
    "rgb16snorm-webgl": {
      f: Qa
    },
    rg32uint: {},
    rg32sint: {},
    rg32float: {
      render: false,
      filter: Yl
    },
    rgba16uint: {},
    rgba16sint: {},
    rgba16float: {
      render: Dh,
      filter: Ub
    },
    "rgba16unorm-webgl": {
      render: Qa
    },
    "rgba16snorm-webgl": {
      render: Uh
    },
    "rgb32float-webgl": {
      render: Xl,
      filter: Yl
    },
    rgba32uint: {},
    rgba32sint: {},
    rgba32float: {
      render: Xl,
      filter: Yl
    },
    stencil8: {
      attachment: "stencil",
      bitsPerChannel: [
        8,
        0,
        0,
        0
      ],
      dataType: "uint8"
    },
    depth16unorm: {
      attachment: "depth",
      bitsPerChannel: [
        16,
        0,
        0,
        0
      ],
      dataType: "uint16"
    },
    depth24plus: {
      attachment: "depth",
      bitsPerChannel: [
        24,
        0,
        0,
        0
      ],
      dataType: "uint32"
    },
    depth32float: {
      attachment: "depth",
      bitsPerChannel: [
        32,
        0,
        0,
        0
      ],
      dataType: "float32"
    },
    "depth24plus-stencil8": {
      attachment: "depth-stencil",
      bitsPerChannel: [
        24,
        8,
        0,
        0
      ],
      packed: true
    },
    "depth32float-stencil8": {
      attachment: "depth-stencil",
      bitsPerChannel: [
        32,
        8,
        0,
        0
      ],
      packed: true
    },
    "bc1-rgb-unorm-webgl": {
      f: Rt
    },
    "bc1-rgb-unorm-srgb-webgl": {
      f: Rt
    },
    "bc1-rgba-unorm": {
      f: Rt
    },
    "bc1-rgba-unorm-srgb": {
      f: Rt
    },
    "bc2-rgba-unorm": {
      f: Rt
    },
    "bc2-rgba-unorm-srgb": {
      f: Rt
    },
    "bc3-rgba-unorm": {
      f: Rt
    },
    "bc3-rgba-unorm-srgb": {
      f: Rt
    },
    "bc4-r-unorm": {
      f: Rt
    },
    "bc4-r-snorm": {
      f: Rt
    },
    "bc5-rg-unorm": {
      f: Rt
    },
    "bc5-rg-snorm": {
      f: Rt
    },
    "bc6h-rgb-ufloat": {
      f: Rt
    },
    "bc6h-rgb-float": {
      f: Rt
    },
    "bc7-rgba-unorm": {
      f: Rt
    },
    "bc7-rgba-unorm-srgb": {
      f: Rt
    },
    "etc2-rgb8unorm": {
      f: In
    },
    "etc2-rgb8unorm-srgb": {
      f: In
    },
    "etc2-rgb8a1unorm": {
      f: In
    },
    "etc2-rgb8a1unorm-srgb": {
      f: In
    },
    "etc2-rgba8unorm": {
      f: In
    },
    "etc2-rgba8unorm-srgb": {
      f: In
    },
    "eac-r11unorm": {
      f: In
    },
    "eac-r11snorm": {
      f: In
    },
    "eac-rg11unorm": {
      f: In
    },
    "eac-rg11snorm": {
      f: In
    },
    "astc-4x4-unorm": {
      f: We
    },
    "astc-4x4-unorm-srgb": {
      f: We
    },
    "astc-5x4-unorm": {
      f: We
    },
    "astc-5x4-unorm-srgb": {
      f: We
    },
    "astc-5x5-unorm": {
      f: We
    },
    "astc-5x5-unorm-srgb": {
      f: We
    },
    "astc-6x5-unorm": {
      f: We
    },
    "astc-6x5-unorm-srgb": {
      f: We
    },
    "astc-6x6-unorm": {
      f: We
    },
    "astc-6x6-unorm-srgb": {
      f: We
    },
    "astc-8x5-unorm": {
      f: We
    },
    "astc-8x5-unorm-srgb": {
      f: We
    },
    "astc-8x6-unorm": {
      f: We
    },
    "astc-8x6-unorm-srgb": {
      f: We
    },
    "astc-8x8-unorm": {
      f: We
    },
    "astc-8x8-unorm-srgb": {
      f: We
    },
    "astc-10x5-unorm": {
      f: We
    },
    "astc-10x5-unorm-srgb": {
      f: We
    },
    "astc-10x6-unorm": {
      f: We
    },
    "astc-10x6-unorm-srgb": {
      f: We
    },
    "astc-10x8-unorm": {
      f: We
    },
    "astc-10x8-unorm-srgb": {
      f: We
    },
    "astc-10x10-unorm": {
      f: We
    },
    "astc-10x10-unorm-srgb": {
      f: We
    },
    "astc-12x10-unorm": {
      f: We
    },
    "astc-12x10-unorm-srgb": {
      f: We
    },
    "astc-12x12-unorm": {
      f: We
    },
    "astc-12x12-unorm-srgb": {
      f: We
    },
    "pvrtc-rgb4unorm-webgl": {
      f: $l
    },
    "pvrtc-rgba4unorm-webgl": {
      f: $l
    },
    "pvrtc-rbg2unorm-webgl": {
      f: $l
    },
    "pvrtc-rgba2unorm-webgl": {
      f: $l
    },
    "etc1-rbg-unorm-webgl": {
      f: KE
    },
    "atc-rgb-unorm-webgl": {
      f: Ph
    },
    "atc-rgba-unorm-webgl": {
      f: Ph
    },
    "atc-rgbai-unorm-webgl": {
      f: Ph
    }
  }, GE = [
    "bc1",
    "bc2",
    "bc3",
    "bc4",
    "bc5",
    "bc6",
    "bc7",
    "etc1",
    "etc2",
    "eac",
    "atc",
    "astc",
    "pvrtc"
  ], JE = /^(r|rg|rgb|rgba|bgra)([0-9]*)([a-z]*)(-srgb)?(-webgl)?$/;
  function R3(n) {
    return GE.some((e) => n.startsWith(e));
  }
  function lg(n) {
    let e = eR(n);
    if (R3(n)) {
      e.channels = "rgb", e.components = 3, e.bytesPerPixel = 1, e.srgb = false, e.compressed = true;
      const i = tR(n);
      i && (e.blockWidth = i.blockWidth, e.blockHeight = i.blockHeight);
    }
    const t = JE.exec(n);
    if (t) {
      const [, i, s, a, l, u] = t, h = `${a}${s}`, d = w3(h), p = d.byteLength * 8, _ = i.length, y = [
        p,
        _ >= 2 ? p : 0,
        _ >= 3 ? p : 0,
        _ >= 4 ? p : 0
      ];
      e = {
        format: n,
        attachment: e.attachment,
        dataType: d.dataType,
        components: _,
        channels: i,
        integer: d.integer,
        signed: d.signed,
        normalized: d.normalized,
        bitsPerChannel: y,
        bytesPerPixel: d.byteLength * i.length,
        packed: e.packed,
        srgb: e.srgb
      }, u === "-webgl" && (e.webgl = true), l === "-srgb" && (e.srgb = true);
    }
    return n.endsWith("-webgl") && (e.webgl = true), n.endsWith("-srgb") && (e.srgb = true), e;
  }
  function eR(n) {
    var _a2;
    const e = E3(n), t = e.bytesPerPixel || 1, i = e.bitsPerChannel || [
      8,
      8,
      8,
      8
    ];
    return delete e.bitsPerChannel, delete e.bytesPerPixel, delete e.f, delete e.render, delete e.filter, delete e.blend, delete e.store, {
      ...e,
      format: n,
      attachment: e.attachment || "color",
      channels: e.channels || "r",
      components: e.components || ((_a2 = e.channels) == null ? void 0 : _a2.length) || 1,
      bytesPerPixel: t,
      bitsPerChannel: i,
      dataType: e.dataType || "uint8",
      srgb: e.srgb ?? false,
      packed: e.packed ?? false,
      webgl: e.webgl ?? false,
      integer: e.integer ?? false,
      signed: e.signed ?? false,
      normalized: e.normalized ?? false,
      compressed: e.compressed ?? false
    };
  }
  function tR(n) {
    const t = /.*-(\d+)x(\d+)-.*/.exec(n);
    if (t) {
      const [, i, s] = t;
      return {
        blockWidth: Number(i),
        blockHeight: Number(s)
      };
    }
    return null;
  }
  function nR(n) {
    const e = E3(n), t = {
      format: n,
      create: e.f ?? true,
      render: e.render ?? true,
      filter: e.filter ?? true,
      blend: e.blend ?? true,
      store: e.store ?? true
    }, i = lg(n), s = n.startsWith("depth") || n.startsWith("stencil"), a = i == null ? void 0 : i.signed, l = i == null ? void 0 : i.integer, u = i == null ? void 0 : i.webgl;
    return t.render && (t.render = !a), t.filter && (t.filter = !s && !a && !l && !u), t;
  }
  class iR {
  }
  class sR {
    constructor(e = [], t) {
      __publicField(this, "features");
      __publicField(this, "disabledFeatures");
      this.features = new Set(e), this.disabledFeatures = t || {};
    }
    *[Symbol.iterator]() {
      yield* this.features;
    }
    has(e) {
      var _a2;
      return !((_a2 = this.disabledFeatures) == null ? void 0 : _a2[e]) && this.features.has(e);
    }
  }
  const _Wi = class _Wi {
    constructor(e) {
      __publicField(this, "id");
      __publicField(this, "props");
      __publicField(this, "userData", {});
      __publicField(this, "statsManager", A3);
      __publicField(this, "timestamp", 0);
      __publicField(this, "_reused", false);
      __publicField(this, "_lumaData", {});
      this.props = {
        ..._Wi.defaultProps,
        ...e
      }, this.id = this.props.id || qc(this[Symbol.toStringTag].toLowerCase());
    }
    get [Symbol.toStringTag]() {
      return "Device";
    }
    getTextureFormatCapabilities(e) {
      const t = nR(e), i = (l) => (typeof l == "string" ? this.features.has(l) : l) ?? true, s = i(t.create), a = {
        format: e,
        create: s,
        render: s && i(t.render),
        filter: s && i(t.filter),
        blend: s && i(t.blend),
        store: s && i(t.store)
      };
      return this._getDeviceSpecificTextureFormatCapabilities(a);
    }
    isTextureFormatSupported(e, t) {
      return this.getTextureFormatCapabilities(e).create;
    }
    isTextureFormatFilterable(e) {
      return this.getTextureFormatCapabilities(e).filter;
    }
    isTextureFormatRenderable(e) {
      return this.getTextureFormatCapabilities(e).render;
    }
    isTextureFormatCompressed(e) {
      return R3(e);
    }
    loseDevice() {
      return false;
    }
    reportError(e) {
      this.props.onError(e);
    }
    getDefaultCanvasContext() {
      if (!this.canvasContext) throw new Error("Device has no default CanvasContext. See props.createCanvasContext");
      return this.canvasContext;
    }
    createCommandEncoder(e = {}) {
      throw new Error("not implemented");
    }
    incrementTimestamp() {
      return this.timestamp++;
    }
    onError(e) {
      this.props.onError(e);
    }
    getCanvasContext() {
      return this.getDefaultCanvasContext();
    }
    readPixelsToArrayWebGL(e, t) {
      throw new Error("not implemented");
    }
    readPixelsToBufferWebGL(e, t) {
      throw new Error("not implemented");
    }
    setParametersWebGL(e) {
      throw new Error("not implemented");
    }
    getParametersWebGL(e) {
      throw new Error("not implemented");
    }
    withParametersWebGL(e, t) {
      throw new Error("not implemented");
    }
    clearWebGL(e) {
      throw new Error("not implemented");
    }
    resetWebGL() {
      throw new Error("not implemented");
    }
    static _getCanvasContextProps(e) {
      return e.createCanvasContext === true ? {} : e.createCanvasContext;
    }
    _normalizeBufferProps(e) {
      (e instanceof ArrayBuffer || ArrayBuffer.isView(e)) && (e = {
        data: e
      });
      const t = {
        ...e
      };
      return (e.usage || 0) & Ke.INDEX && !e.indexType && (e.data instanceof Uint32Array ? t.indexType = "uint32" : e.data instanceof Uint16Array ? t.indexType = "uint16" : J.warn("indices buffer content must be of integer type")()), t;
    }
  };
  __publicField(_Wi, "defaultProps", {
    id: null,
    powerPreference: "high-performance",
    failIfMajorPerformanceCaveat: false,
    createCanvasContext: void 0,
    onError: (e) => J.error(e.message)(),
    _reuseDevices: false,
    _requestMaxLimits: true,
    _factoryDestroyPolicy: "unused",
    _initializeFeatures: true,
    _disabledFeatures: {
      "compilation-status-async-webgl": true
    },
    _resourceDefaults: {},
    webgl: {},
    debug: J.get("debug") || void 0,
    debugShaders: J.get("debug-shaders") || void 0,
    debugFramebuffers: !!J.get("debug-framebuffers"),
    debugWebGL: !!J.get("debug-webgl"),
    debugSpectorJS: void 0,
    debugSpectorJSUrl: void 0,
    _handle: void 0
  });
  let Wi = _Wi;
  const rR = Is() && typeof document < "u", aR = () => rR && document.readyState === "complete", oR = "set luma.log.level=1 (or higher) to trace rendering", Bb = "No matching device found. Ensure `@luma.gl/webgl` and/or `@luma.gl/webgpu` modules are imported.";
  const _Cr = class _Cr {
    constructor() {
      __publicField(this, "stats", A3);
      __publicField(this, "log", J);
      __publicField(this, "VERSION", "9.1.9");
      __publicField(this, "spector");
      __publicField(this, "preregisteredAdapters", /* @__PURE__ */ new Map());
      if (globalThis.luma) {
        if (globalThis.luma.VERSION !== this.VERSION) throw J.error(`Found luma.gl ${globalThis.luma.VERSION} while initialzing ${this.VERSION}`)(), J.error("'yarn why @luma.gl/core' can help identify the source of the conflict")(), new Error("luma.gl - multiple versions detected: see console log");
        J.error("This version of luma.gl has already been initialized")();
      }
      J.log(1, `${this.VERSION} - ${oR}`)(), globalThis.luma = this;
    }
    registerAdapters(e) {
      for (const t of e) this.preregisteredAdapters.set(t.type, t);
    }
    getSupportedAdapters(e = []) {
      const t = this.getAdapterMap(e);
      return Array.from(t).map(([, i]) => i).filter((i) => {
        var _a2;
        return (_a2 = i.isSupported) == null ? void 0 : _a2.call(i);
      }).map((i) => i.type);
    }
    getBestAvailableAdapter(e = []) {
      var _a2, _b3, _c2, _d2;
      const t = this.getAdapterMap(e);
      return ((_b3 = (_a2 = t.get("webgpu")) == null ? void 0 : _a2.isSupported) == null ? void 0 : _b3.call(_a2)) ? "webgpu" : ((_d2 = (_c2 = t.get("webgl")) == null ? void 0 : _c2.isSupported) == null ? void 0 : _d2.call(_c2)) ? "webgl" : null;
    }
    setDefaultDeviceProps(e) {
      Object.assign(_Cr.defaultProps, e);
    }
    async createDevice(e = {}) {
      var _a2, _b3;
      e = {
        ..._Cr.defaultProps,
        ...e
      }, e.waitForPageLoad && await _Cr.pageLoaded;
      const t = this.getAdapterMap(e.adapters);
      let i = e.type || "";
      i === "best-available" && (i = this.getBestAvailableAdapter(e.adapters) || i);
      const l = await ((_b3 = (_a2 = (this.getAdapterMap(e.adapters) || t).get(i)) == null ? void 0 : _a2.create) == null ? void 0 : _b3.call(_a2, e));
      if (l) return l;
      throw new Error(Bb);
    }
    async attachDevice(e) {
      var _a2, _b3;
      const t = this.getAdapterMap(e.adapters);
      let i = "";
      e.handle instanceof WebGL2RenderingContext && (i = "webgl"), e.createCanvasContext && await _Cr.pageLoaded, e.handle === null && (i = "unknown");
      const a = await ((_b3 = (_a2 = t.get(i)) == null ? void 0 : _a2.attach) == null ? void 0 : _b3.call(_a2, null));
      if (a) return a;
      throw new Error(Bb);
    }
    enforceWebGL2(e = true, t = []) {
      var _a2;
      const s = this.getAdapterMap(t).get("webgl");
      s || J.warn("enforceWebGL2: webgl adapter not found")(), (_a2 = s == null ? void 0 : s.enforceWebGL2) == null ? void 0 : _a2.call(s, e);
    }
    getAdapterMap(e = []) {
      const t = new Map(this.preregisteredAdapters);
      for (const i of e) t.set(i.type, i);
      return t;
    }
    registerDevices(e) {
      J.warn("luma.registerDevices() is deprecated, use luma.registerAdapters() instead");
      for (const t of e) {
        const i = t.adapter;
        i && this.preregisteredAdapters.set(i.type, i);
      }
    }
  };
  __publicField(_Cr, "defaultProps", {
    ...Wi.defaultProps,
    type: "best-available",
    adapters: void 0,
    waitForPageLoad: true
  });
  __publicField(_Cr, "pageLoaded", lR().then(() => {
    J.probe(2, "DOM is loaded")();
  }));
  let Cr = _Cr;
  const Td = new Cr();
  function lR() {
    return aR() || typeof window > "u" ? Promise.resolve() : new Promise((n) => {
      window.addEventListener("load", () => n());
    });
  }
  class cR {
  }
  const _cg = class _cg {
    constructor(e) {
      __publicField(this, "id");
      __publicField(this, "props");
      __publicField(this, "canvas");
      __publicField(this, "htmlCanvas");
      __publicField(this, "offscreenCanvas");
      __publicField(this, "type");
      __publicField(this, "width", 1);
      __publicField(this, "height", 1);
      __publicField(this, "resizeObserver");
      __publicField(this, "_canvasSizeInfo", {
        clientWidth: 0,
        clientHeight: 0,
        devicePixelRatio: 1
      });
      if (this.props = {
        ..._cg.defaultProps,
        ...e
      }, e = this.props, !Is()) {
        this.id = "node-canvas-context", this.type = "node", this.width = this.props.width, this.height = this.props.height, this.canvas = null;
        return;
      }
      if (e.canvas) typeof e.canvas == "string" ? this.canvas = fR(e.canvas) : this.canvas = e.canvas;
      else {
        const t = hR(e), i = uR((e == null ? void 0 : e.container) || null);
        i.insertBefore(t, i.firstChild), this.canvas = t, (e == null ? void 0 : e.visible) || (this.canvas.style.visibility = "hidden");
      }
      this.canvas instanceof HTMLCanvasElement ? (this.id = this.canvas.id, this.type = "html-canvas", this.htmlCanvas = this.canvas) : (this.id = "offscreen-canvas", this.type = "offscreen-canvas", this.offscreenCanvas = this.canvas), this.canvas instanceof HTMLCanvasElement && e.autoResize && (this.resizeObserver = new ResizeObserver((t) => {
        for (const i of t) i.target === this.canvas && this.update();
      }), this.resizeObserver.observe(this.canvas));
    }
    toString() {
      return `${this[Symbol.toStringTag]}(${this.id})`;
    }
    getDevicePixelRatio(e) {
      return typeof OffscreenCanvas < "u" && this.canvas instanceof OffscreenCanvas || (e = e === void 0 ? this.props.useDevicePixels : e, !e || e <= 0) ? 1 : e === true ? typeof window < "u" && window.devicePixelRatio || 1 : e;
    }
    getPixelSize() {
      switch (this.type) {
        case "node":
          return [
            this.width,
            this.height
          ];
        case "offscreen-canvas":
          return [
            this.canvas.width,
            this.canvas.height
          ];
        case "html-canvas":
          const e = this.getDevicePixelRatio(), t = this.canvas;
          return t.parentElement ? [
            t.clientWidth * e,
            t.clientHeight * e
          ] : [
            this.canvas.width,
            this.canvas.height
          ];
        default:
          throw new Error(this.type);
      }
    }
    getAspect() {
      const [e, t] = this.getPixelSize();
      return e / t;
    }
    cssToDeviceRatio() {
      var _a2;
      try {
        const [e] = this.getDrawingBufferSize(), t = this._canvasSizeInfo.clientWidth || ((_a2 = this.htmlCanvas) == null ? void 0 : _a2.clientWidth);
        return t ? e / t : 1;
      } catch {
        return 1;
      }
    }
    cssToDevicePixels(e, t = true) {
      const i = this.cssToDeviceRatio(), [s, a] = this.getDrawingBufferSize();
      return dR(e, i, s, a, t);
    }
    setDevicePixelRatio(e, t = {}) {
      if (!this.htmlCanvas) return;
      let i = "width" in t ? t.width : this.htmlCanvas.clientWidth, s = "height" in t ? t.height : this.htmlCanvas.clientHeight;
      (!i || !s) && (J.log(1, "Canvas clientWidth/clientHeight is 0")(), e = 1, i = this.htmlCanvas.width || 1, s = this.htmlCanvas.height || 1);
      const a = this._canvasSizeInfo;
      if (a.clientWidth !== i || a.clientHeight !== s || a.devicePixelRatio !== e) {
        let l = e;
        const u = Math.floor(i * l), h = Math.floor(s * l);
        if (this.htmlCanvas.width = u, this.htmlCanvas.height = h, this.device.gl) {
          const [p, _] = this.getDrawingBufferSize();
          (p !== u || _ !== h) && (l = Math.min(p / i, _ / s), this.htmlCanvas.width = Math.floor(i * l), this.htmlCanvas.height = Math.floor(s * l), J.warn("Device pixel ratio clamped")()), this._canvasSizeInfo.clientWidth = i, this._canvasSizeInfo.clientHeight = s, this._canvasSizeInfo.devicePixelRatio = e;
        }
      }
    }
    getDrawingBufferSize() {
      const e = this.device.gl;
      return e ? [
        e.drawingBufferWidth,
        e.drawingBufferHeight
      ] : this.getPixelSize();
    }
    _setAutoCreatedCanvasId(e) {
      var _a2;
      ((_a2 = this.htmlCanvas) == null ? void 0 : _a2.id) === "lumagl-auto-created-canvas" && (this.htmlCanvas.id = e);
    }
  };
  __publicField(_cg, "defaultProps", {
    canvas: null,
    width: 800,
    height: 600,
    useDevicePixels: true,
    autoResize: true,
    container: null,
    visible: true,
    alphaMode: "opaque",
    colorSpace: "srgb"
  });
  let cg = _cg;
  function uR(n) {
    if (typeof n == "string") {
      const e = document.getElementById(n);
      if (!e) throw new Error(`${n} is not an HTML element`);
      return e;
    } else if (n) return n;
    return document.body;
  }
  function fR(n) {
    const e = document.getElementById(n);
    if (!(e instanceof HTMLCanvasElement)) throw new Error("Object is not a canvas element");
    return e;
  }
  function hR(n) {
    const { width: e, height: t } = n, i = document.createElement("canvas");
    return i.id = qc("lumagl-auto-created-canvas"), i.width = e || 1, i.height = t || 1, i.style.width = Number.isFinite(e) ? `${e}px` : "100%", i.style.height = Number.isFinite(t) ? `${t}px` : "100%", i;
  }
  function dR(n, e, t, i, s) {
    const a = n, l = Lb(a[0], e, t);
    let u = Fb(a[1], e, i, s), h = Lb(a[0] + 1, e, t);
    const d = h === t - 1 ? h : h - 1;
    h = Fb(a[1] + 1, e, i, s);
    let p;
    return s ? (h = h === 0 ? h : h + 1, p = u, u = h) : p = h === i - 1 ? h : h - 1, {
      x: l,
      y: u,
      width: Math.max(d - l + 1, 1),
      height: Math.max(p - u + 1, 1)
    };
  }
  function Lb(n, e, t) {
    return Math.min(Math.round(n * e), t - 1);
  }
  function Fb(n, e, t, i) {
    return i ? Math.max(0, t - 1 - Math.round(n * e)) : Math.min(Math.round(n * e), t - 1);
  }
  const _$e = class _$e extends Xe {
    constructor(e, t) {
      t = _$e.normalizeProps(e, t);
      super(e, t, _$e.defaultProps);
      __publicField(this, "dimension");
      __publicField(this, "format");
      __publicField(this, "width");
      __publicField(this, "height");
      __publicField(this, "depth");
      __publicField(this, "mipLevels");
      __publicField(this, "updateTimestamp");
      if (this.dimension = this.props.dimension, this.format = this.props.format, this.width = this.props.width, this.height = this.props.height, this.depth = this.props.depth, this.props.width === void 0 || this.props.height === void 0) {
        const i = _$e.getTextureDataSize(this.props.data);
        this.width = (i == null ? void 0 : i.width) || 1, this.height = (i == null ? void 0 : i.height) || 1;
      }
      this.props.mipmaps && this.props.mipLevels === void 0 && (this.props.mipLevels = "pyramid"), this.mipLevels = this.props.mipLevels === "pyramid" ? _$e.getMipLevelCount(this.width, this.height) : this.props.mipLevels || 1, this.updateTimestamp = e.incrementTimestamp();
    }
    get [Symbol.toStringTag]() {
      return "Texture";
    }
    toString() {
      return `Texture(${this.id},${this.format},${this.width}x${this.height})`;
    }
    clone(e) {
      return this.device.createTexture({
        ...this.props,
        ...e
      });
    }
    static isExternalImage(e) {
      return typeof ImageData < "u" && e instanceof ImageData || typeof ImageBitmap < "u" && e instanceof ImageBitmap || typeof HTMLImageElement < "u" && e instanceof HTMLImageElement || typeof HTMLVideoElement < "u" && e instanceof HTMLVideoElement || typeof VideoFrame < "u" && e instanceof VideoFrame || typeof HTMLCanvasElement < "u" && e instanceof HTMLCanvasElement || typeof OffscreenCanvas < "u" && e instanceof OffscreenCanvas;
    }
    static getExternalImageSize(e) {
      if (typeof ImageData < "u" && e instanceof ImageData || typeof ImageBitmap < "u" && e instanceof ImageBitmap || typeof HTMLCanvasElement < "u" && e instanceof HTMLCanvasElement || typeof OffscreenCanvas < "u" && e instanceof OffscreenCanvas) return {
        width: e.width,
        height: e.height
      };
      if (typeof HTMLImageElement < "u" && e instanceof HTMLImageElement) return {
        width: e.naturalWidth,
        height: e.naturalHeight
      };
      if (typeof HTMLVideoElement < "u" && e instanceof HTMLVideoElement) return {
        width: e.videoWidth,
        height: e.videoHeight
      };
      if (typeof VideoFrame < "u" && e instanceof VideoFrame) return {
        width: e.displayWidth,
        height: e.displayHeight
      };
      throw new Error("Unknown image type");
    }
    static isTextureLevelData(e) {
      const t = e == null ? void 0 : e.data;
      return ArrayBuffer.isView(t);
    }
    static getTextureDataSize(e) {
      if (!e || ArrayBuffer.isView(e)) return null;
      if (Array.isArray(e)) return _$e.getTextureDataSize(e[0]);
      if (_$e.isExternalImage(e)) return _$e.getExternalImageSize(e);
      if (e && typeof e == "object" && e.constructor === Object) {
        const i = Object.values(e)[0];
        return {
          width: i.width,
          height: i.height
        };
      }
      throw new Error("texture size deduction failed");
    }
    static normalizeTextureData(e, t) {
      let i;
      return ArrayBuffer.isView(e) ? i = [
        {
          data: e,
          width: t.width,
          height: t.height
        }
      ] : Array.isArray(e) ? i = e : i = [
        e
      ], i;
    }
    static getMipLevelCount(e, t) {
      return Math.floor(Math.log2(Math.max(e, t))) + 1;
    }
    static getCubeFaceDepth(e) {
      switch (e) {
        case "+X":
          return 0;
        case "-X":
          return 1;
        case "+Y":
          return 2;
        case "-Y":
          return 3;
        case "+Z":
          return 4;
        case "-Z":
          return 5;
        default:
          throw new Error(e);
      }
    }
    static normalizeProps(e, t) {
      var _a2, _b3;
      const i = {
        ...t
      }, s = ((_b3 = (_a2 = e == null ? void 0 : e.props) == null ? void 0 : _a2._resourceDefaults) == null ? void 0 : _b3.texture) || {};
      Object.assign(i, s);
      const { width: a, height: l } = i;
      return typeof a == "number" && (i.width = Math.max(1, Math.ceil(a))), typeof l == "number" && (i.height = Math.max(1, Math.ceil(l))), i;
    }
  };
  __publicField(_$e, "COPY_SRC", 1);
  __publicField(_$e, "COPY_DST", 2);
  __publicField(_$e, "TEXTURE", 4);
  __publicField(_$e, "STORAGE", 8);
  __publicField(_$e, "RENDER_ATTACHMENT", 16);
  __publicField(_$e, "CubeFaces", [
    "+X",
    "-X",
    "+Y",
    "-Y",
    "+Z",
    "-Z"
  ]);
  __publicField(_$e, "defaultProps", {
    ...Xe.defaultProps,
    data: null,
    dimension: "2d",
    format: "rgba8unorm",
    width: void 0,
    height: void 0,
    depth: 1,
    mipmaps: false,
    compressed: false,
    usage: 0,
    mipLevels: void 0,
    samples: void 0,
    sampler: {},
    view: void 0,
    flipY: void 0
  });
  __publicField(_$e, "defaultCopyExternalImageOptions", {
    image: void 0,
    sourceX: 0,
    sourceY: 0,
    width: void 0,
    height: void 0,
    depth: 1,
    mipLevel: 0,
    x: 0,
    y: 0,
    z: 0,
    aspect: "all",
    colorSpace: "srgb",
    premultipliedAlpha: false,
    flipY: false
  });
  let $e = _$e;
  const _Kc = class _Kc extends Xe {
    get [Symbol.toStringTag]() {
      return "TextureView";
    }
    constructor(e, t) {
      super(e, t, _Kc.defaultProps);
    }
  };
  __publicField(_Kc, "defaultProps", {
    ...Xe.defaultProps,
    format: void 0,
    dimension: void 0,
    aspect: "all",
    baseMipLevel: 0,
    mipLevelCount: void 0,
    baseArrayLayer: 0,
    arrayLayerCount: void 0
  });
  let Kc = _Kc;
  function gR(n, e, t) {
    let i = "";
    const s = e.split(/\r?\n/), a = n.slice().sort((l, u) => l.lineNum - u.lineNum);
    switch ((t == null ? void 0 : t.showSourceCode) || "no") {
      case "all":
        let l = 0;
        for (let u = 1; u <= s.length; u++) for (i += C3(s[u - 1], u, t); a.length > l && a[l].lineNum === u; ) {
          const h = a[l++];
          i += Vb(h, s, h.lineNum, {
            ...t,
            inlineSource: false
          });
        }
        return i;
      case "issues":
      case "no":
        for (const u of n) i += Vb(u, s, u.lineNum, {
          inlineSource: (t == null ? void 0 : t.showSourceCode) !== "no"
        });
        return i;
    }
  }
  function Vb(n, e, t, i) {
    if (i == null ? void 0 : i.inlineSource) {
      const a = pR(e, t), l = n.linePos > 0 ? `${" ".repeat(n.linePos + 5)}^^^
` : "";
      return `
${a}${l}${n.type.toUpperCase()}: ${n.message}

`;
    }
    const s = n.type === "error" ? "red" : "#8B4000";
    return (i == null ? void 0 : i.html) ? `<div class='luma-compiler-log-error' style="color:${s};"><b> ${n.type.toUpperCase()}: ${n.message}</b></div>` : `${n.type.toUpperCase()}: ${n.message}`;
  }
  function pR(n, e, t) {
    let i = "";
    for (let s = e - 2; s <= e; s++) {
      const a = n[s - 1];
      a !== void 0 && (i += C3(a, e, t));
    }
    return i;
  }
  function C3(n, e, t) {
    const i = (t == null ? void 0 : t.html) ? _R(n) : n;
    return `${mR(String(e), 4)}: ${i}${(t == null ? void 0 : t.html) ? "<br/>" : `
`}`;
  }
  function mR(n, e) {
    let t = "";
    for (let i = n.length; i < e; ++i) t += " ";
    return t + n;
  }
  function _R(n) {
    return n.replaceAll("&", "&amp;").replaceAll("<", "&lt;").replaceAll(">", "&gt;").replaceAll('"', "&quot;").replaceAll("'", "&#039;");
  }
  const _Zc = class _Zc extends Xe {
    constructor(e, t) {
      t = {
        ...t,
        debugShaders: t.debugShaders || e.props.debugShaders || "errors"
      };
      super(e, {
        id: yR(t),
        ...t
      }, _Zc.defaultProps);
      __publicField(this, "stage");
      __publicField(this, "source");
      __publicField(this, "compilationStatus", "pending");
      this.stage = this.props.stage, this.source = this.props.source;
    }
    get [Symbol.toStringTag]() {
      return "Shader";
    }
    getCompilationInfoSync() {
      return null;
    }
    getTranslatedSource() {
      return null;
    }
    async debugShader() {
      const e = this.props.debugShaders;
      switch (e) {
        case "never":
          return;
        case "errors":
          if (this.compilationStatus === "success") return;
          break;
      }
      const t = await this.getCompilationInfo();
      e === "warnings" && (t == null ? void 0 : t.length) === 0 || this._displayShaderLog(t);
    }
    _displayShaderLog(e) {
      var _a2;
      if (typeof document > "u" || !(document == null ? void 0 : document.createElement)) return;
      const t = M3(this.source), i = `${this.stage} ${t}`;
      let s = gR(e, this.source, {
        showSourceCode: "all",
        html: true
      });
      const a = this.getTranslatedSource();
      a && (s += `<br /><br /><h1>Translated Source</h1><br /><br /><code style="user-select:text;"><pre>${a}</pre></code>`);
      const l = document.createElement("Button");
      l.innerHTML = `
<h1>Shader Compilation Error in ${i}</h1><br /><br />
<code style="user-select:text;"><pre>
${s}
</pre></code>`, l.style.top = "10px", l.style.left = "10px", l.style.position = "absolute", l.style.zIndex = "9999", l.style.width = "100%", l.style.textAlign = "left", document.body.appendChild(l), (_a2 = document.getElementsByClassName("luma-compiler-log-error")[0]) == null ? void 0 : _a2.scrollIntoView(), l.onclick = () => {
        const h = `data:text/plain,${encodeURIComponent(this.source)}`;
        navigator.clipboard.writeText(h);
      };
    }
  };
  __publicField(_Zc, "defaultProps", {
    ...Xe.defaultProps,
    language: "auto",
    stage: void 0,
    source: "",
    sourceMap: null,
    entryPoint: "main",
    debugShaders: void 0
  });
  let Zc = _Zc;
  function yR(n) {
    return M3(n.source) || n.id || qc(`unnamed ${n.stage}-shader`);
  }
  function M3(n, e = "unnamed") {
    const i = /#define[\s*]SHADER_NAME[\s*]([A-Za-z0-9_-]+)[\s*]/.exec(n);
    return i ? i[1] : e;
  }
  const _po = class _po extends Xe {
    get [Symbol.toStringTag]() {
      return "Sampler";
    }
    constructor(e, t) {
      t = _po.normalizeProps(e, t), super(e, t, _po.defaultProps);
    }
    static normalizeProps(e, t) {
      var _a2, _b3;
      const i = ((_b3 = (_a2 = e == null ? void 0 : e.props) == null ? void 0 : _a2._resourceDefaults) == null ? void 0 : _b3.sampler) || {};
      return {
        ...t,
        ...i
      };
    }
  };
  __publicField(_po, "defaultProps", {
    ...Xe.defaultProps,
    type: "color-sampler",
    addressModeU: "clamp-to-edge",
    addressModeV: "clamp-to-edge",
    addressModeW: "clamp-to-edge",
    magFilter: "nearest",
    minFilter: "nearest",
    mipmapFilter: "none",
    lodMinClamp: 0,
    lodMaxClamp: 32,
    compare: "less-equal",
    maxAnisotropy: 1
  });
  let po = _po;
  const _Qc = class _Qc extends Xe {
    constructor(e, t = {}) {
      super(e, t, _Qc.defaultProps);
      __publicField(this, "width");
      __publicField(this, "height");
      this.width = this.props.width, this.height = this.props.height;
    }
    get [Symbol.toStringTag]() {
      return "Framebuffer";
    }
    clone(e) {
      const t = this.colorAttachments.map((s) => s.texture.clone(e)), i = this.depthStencilAttachment && this.depthStencilAttachment.texture.clone(e);
      return this.device.createFramebuffer({
        ...this.props,
        colorAttachments: t,
        depthStencilAttachment: i
      });
    }
    resize(e) {
      let t = !e;
      if (e) {
        const [i, s] = Array.isArray(e) ? e : [
          e.width,
          e.height
        ];
        t = t || s !== this.height || i !== this.width, this.width = i, this.height = s;
      }
      t && (J.log(2, `Resizing framebuffer ${this.id} to ${this.width}x${this.height}`)(), this.resizeAttachments(this.width, this.height));
    }
    autoCreateAttachmentTextures() {
      if (this.props.colorAttachments.length === 0 && !this.props.depthStencilAttachment) throw new Error("Framebuffer has noattachments");
      this.colorAttachments = this.props.colorAttachments.map((t, i) => {
        if (typeof t == "string") {
          const s = this.createColorTexture(t, i);
          return this.attachResource(s), s.view;
        }
        return t instanceof $e ? t.view : t;
      });
      const e = this.props.depthStencilAttachment;
      if (e) if (typeof e == "string") {
        const t = this.createDepthStencilTexture(e);
        this.attachResource(t), this.depthStencilAttachment = t.view;
      } else e instanceof $e ? this.depthStencilAttachment = e.view : this.depthStencilAttachment = e;
    }
    createColorTexture(e, t) {
      return this.device.createTexture({
        id: `${this.id}-color-attachment-${t}`,
        usage: $e.RENDER_ATTACHMENT,
        format: e,
        width: this.width,
        height: this.height,
        sampler: {
          magFilter: "linear",
          minFilter: "linear"
        }
      });
    }
    createDepthStencilTexture(e) {
      return this.device.createTexture({
        id: `${this.id}-depth-stencil-attachment`,
        usage: $e.RENDER_ATTACHMENT,
        format: e,
        width: this.width,
        height: this.height,
        mipmaps: false
      });
    }
    resizeAttachments(e, t) {
      for (let i = 0; i < this.colorAttachments.length; ++i) if (this.colorAttachments[i]) {
        const s = this.colorAttachments[i].texture.clone({
          width: e,
          height: t
        });
        this.destroyAttachedResource(this.colorAttachments[i]), this.colorAttachments[i] = s.view, this.attachResource(s.view);
      }
      if (this.depthStencilAttachment) {
        const i = this.depthStencilAttachment.texture.clone({
          width: e,
          height: t
        });
        this.destroyAttachedResource(this.depthStencilAttachment), this.depthStencilAttachment = i.view, this.attachResource(i);
      }
      this.updateAttachments();
    }
  };
  __publicField(_Qc, "defaultProps", {
    ...Xe.defaultProps,
    width: 1,
    height: 1,
    colorAttachments: [],
    depthStencilAttachment: null
  });
  let Qc = _Qc;
  const _Vr = class _Vr extends Xe {
    constructor(e, t) {
      super(e, t, _Vr.defaultProps);
      __publicField(this, "shaderLayout");
      __publicField(this, "bufferLayout");
      __publicField(this, "linkStatus", "pending");
      __publicField(this, "hash", "");
      this.shaderLayout = this.props.shaderLayout, this.bufferLayout = this.props.bufferLayout || [];
    }
    get [Symbol.toStringTag]() {
      return "RenderPipeline";
    }
    setUniformsWebGL(e) {
      throw new Error("Use uniform blocks");
    }
  };
  __publicField(_Vr, "defaultProps", {
    ...Xe.defaultProps,
    vs: null,
    vertexEntryPoint: "vertexMain",
    vsConstants: {},
    fs: null,
    fragmentEntryPoint: "fragmentMain",
    fsConstants: {},
    shaderLayout: null,
    bufferLayout: [],
    topology: "triangle-list",
    parameters: {},
    bindings: {},
    uniforms: {}
  });
  let Vr = _Vr;
  const __s = class __s extends Xe {
    get [Symbol.toStringTag]() {
      return "RenderPass";
    }
    constructor(e, t) {
      t = __s.normalizeProps(e, t), super(e, t, __s.defaultProps);
    }
    static normalizeProps(e, t) {
      var _a2;
      return {
        ...(_a2 = e.props._resourceDefaults) == null ? void 0 : _a2.renderPass,
        ...t
      };
    }
  };
  __publicField(__s, "defaultClearColor", [
    0,
    0,
    0,
    1
  ]);
  __publicField(__s, "defaultClearDepth", 1);
  __publicField(__s, "defaultClearStencil", 0);
  __publicField(__s, "defaultProps", {
    ...Xe.defaultProps,
    framebuffer: null,
    parameters: void 0,
    clearColor: __s.defaultClearColor,
    clearColors: void 0,
    clearDepth: __s.defaultClearDepth,
    clearStencil: __s.defaultClearStencil,
    depthReadOnly: false,
    stencilReadOnly: false,
    discard: false,
    occlusionQuerySet: void 0,
    timestampQuerySet: void 0,
    beginTimestampIndex: void 0,
    endTimestampIndex: void 0
  });
  let _s = __s;
  const _vc = class _vc extends Xe {
    constructor(e, t) {
      super(e, t, _vc.defaultProps);
      __publicField(this, "hash", "");
      __publicField(this, "shaderLayout");
      this.shaderLayout = t.shaderLayout;
    }
    get [Symbol.toStringTag]() {
      return "ComputePipeline";
    }
  };
  __publicField(_vc, "defaultProps", {
    ...Xe.defaultProps,
    shader: void 0,
    entryPoint: void 0,
    constants: {},
    shaderLayout: void 0
  });
  let vc = _vc;
  const _ug = class _ug extends Xe {
    get [Symbol.toStringTag]() {
      return "CommandEncoder";
    }
    constructor(e, t) {
      super(e, t, _ug.defaultProps);
    }
  };
  __publicField(_ug, "defaultProps", {
    ...Xe.defaultProps,
    measureExecutionTime: void 0
  });
  let ug = _ug;
  const _fg = class _fg extends Xe {
    get [Symbol.toStringTag]() {
      return "CommandBuffer";
    }
    constructor(e, t) {
      super(e, t, _fg.defaultProps);
    }
  };
  __publicField(_fg, "defaultProps", {
    ...Xe.defaultProps
  });
  let fg = _fg;
  function bR(n) {
    const [e, t] = TR[n], i = e === "i32" || e === "u32", s = e !== "u32", a = xR[e] * t, l = vR(e, t);
    return {
      dataType: e,
      components: t,
      defaultVertexFormat: l,
      byteLength: a,
      integer: i,
      signed: s
    };
  }
  function vR(n, e) {
    let t;
    switch (n) {
      case "f32":
        t = "float32";
        break;
      case "i32":
        t = "sint32";
        break;
      case "u32":
        t = "uint32";
        break;
      case "f16":
        return e <= 2 ? "float16x2" : "float16x4";
    }
    return e === 1 ? t : `${t}x${e}`;
  }
  const TR = {
    f32: [
      "f32",
      1
    ],
    "vec2<f32>": [
      "f32",
      2
    ],
    "vec3<f32>": [
      "f32",
      3
    ],
    "vec4<f32>": [
      "f32",
      4
    ],
    f16: [
      "f16",
      1
    ],
    "vec2<f16>": [
      "f16",
      2
    ],
    "vec3<f16>": [
      "f16",
      3
    ],
    "vec4<f16>": [
      "f16",
      4
    ],
    i32: [
      "i32",
      1
    ],
    "vec2<i32>": [
      "i32",
      2
    ],
    "vec3<i32>": [
      "i32",
      3
    ],
    "vec4<i32>": [
      "i32",
      4
    ],
    u32: [
      "u32",
      1
    ],
    "vec2<u32>": [
      "u32",
      2
    ],
    "vec3<u32>": [
      "u32",
      3
    ],
    "vec4<u32>": [
      "u32",
      4
    ]
  }, xR = {
    f32: 4,
    f16: 2,
    i32: 4,
    u32: 4
  };
  function O3(n) {
    let e;
    n.endsWith("-webgl") && (n.replace("-webgl", ""), e = true);
    const [t, i] = n.split("x"), s = t, a = i ? parseInt(i) : 1, l = w3(s), u = {
      type: s,
      components: a,
      byteLength: l.byteLength * a,
      integer: l.integer,
      signed: l.signed,
      normalized: l.normalized
    };
    return e && (u.webglOnly = true), u;
  }
  function I3(n, e) {
    const t = {};
    for (const i of n.attributes) {
      const s = AR(n, e, i.name);
      s && (t[i.name] = s);
    }
    return t;
  }
  function SR(n, e, t = 16) {
    const i = I3(n, e), s = new Array(t).fill(null);
    for (const a of Object.values(i)) s[a.location] = a;
    return s;
  }
  function AR(n, e, t) {
    const i = wR(n, t), s = ER(e, t);
    if (!i) return null;
    const a = bR(i.type), l = (s == null ? void 0 : s.vertexFormat) || a.defaultVertexFormat, u = O3(l);
    return {
      attributeName: (s == null ? void 0 : s.attributeName) || i.name,
      bufferName: (s == null ? void 0 : s.bufferName) || i.name,
      location: i.location,
      shaderType: i.type,
      shaderDataType: a.dataType,
      shaderComponents: a.components,
      vertexFormat: l,
      bufferDataType: u.type,
      bufferComponents: u.components,
      normalized: u.normalized,
      integer: a.integer,
      stepMode: (s == null ? void 0 : s.stepMode) || i.stepMode || "vertex",
      byteOffset: (s == null ? void 0 : s.byteOffset) || 0,
      byteStride: (s == null ? void 0 : s.byteStride) || 0
    };
  }
  function wR(n, e) {
    const t = n.attributes.find((i) => i.name === e);
    return t || J.warn(`shader layout attribute "${e}" not present in shader`), t || null;
  }
  function ER(n, e) {
    RR(n);
    let t = CR(n, e);
    return t || (t = MR(n, e), t) ? t : (J.warn(`layout for attribute "${e}" not present in buffer layout`), null);
  }
  function RR(n) {
    for (const e of n) (e.attributes && e.format || !e.attributes && !e.format) && J.warn(`BufferLayout ${name} must have either 'attributes' or 'format' field`);
  }
  function CR(n, e) {
    for (const t of n) if (t.format && t.name === e) return {
      attributeName: t.name,
      bufferName: e,
      stepMode: t.stepMode,
      vertexFormat: t.format,
      byteOffset: 0,
      byteStride: t.byteStride || 0
    };
    return null;
  }
  function MR(n, e) {
    var _a2;
    for (const t of n) {
      let i = t.byteStride;
      if (typeof t.byteStride != "number") for (const a of t.attributes || []) {
        const l = O3(a.format);
        i += l.byteLength;
      }
      const s = (_a2 = t.attributes) == null ? void 0 : _a2.find((a) => a.attribute === e);
      if (s) return {
        attributeName: s.attribute,
        bufferName: t.name,
        stepMode: t.stepMode,
        vertexFormat: s.format,
        byteOffset: s.byteOffset,
        byteStride: i
      };
    }
    return null;
  }
  const _hg = class _hg extends Xe {
    constructor(e, t) {
      super(e, t, _hg.defaultProps);
      __publicField(this, "maxVertexAttributes");
      __publicField(this, "attributeInfos");
      __publicField(this, "indexBuffer", null);
      __publicField(this, "attributes");
      this.maxVertexAttributes = e.limits.maxVertexAttributes, this.attributes = new Array(this.maxVertexAttributes).fill(null);
      const { shaderLayout: i, bufferLayout: s } = t.renderPipeline || {};
      if (!i || !s) throw new Error("VertexArray");
      this.attributeInfos = SR(i, s, this.maxVertexAttributes);
    }
    get [Symbol.toStringTag]() {
      return "VertexArray";
    }
    setConstantWebGL(e, t) {
      this.device.reportError(new Error("constant attributes not supported"));
    }
  };
  __publicField(_hg, "defaultProps", {
    ...Xe.defaultProps,
    renderPipeline: null
  });
  let hg = _hg;
  const _dg = class _dg extends Xe {
    get [Symbol.toStringTag]() {
      return "TransformFeedback";
    }
    constructor(e, t) {
      super(e, t, _dg.defaultProps);
    }
  };
  __publicField(_dg, "defaultProps", {
    ...Xe.defaultProps,
    layout: void 0,
    buffers: {}
  });
  let dg = _dg;
  const _gg = class _gg extends Xe {
    get [Symbol.toStringTag]() {
      return "QuerySet";
    }
    constructor(e, t) {
      super(e, t, _gg.defaultProps);
    }
  };
  __publicField(_gg, "defaultProps", {
    ...Xe.defaultProps,
    type: void 0,
    count: void 0
  });
  let gg = _gg;
  const OR = {
    f32: {
      type: "f32",
      components: 1
    },
    i32: {
      type: "i32",
      components: 1
    },
    u32: {
      type: "u32",
      components: 1
    },
    "vec2<f32>": {
      type: "f32",
      components: 2
    },
    "vec3<f32>": {
      type: "f32",
      components: 3
    },
    "vec4<f32>": {
      type: "f32",
      components: 4
    },
    "vec2<i32>": {
      type: "i32",
      components: 2
    },
    "vec3<i32>": {
      type: "i32",
      components: 3
    },
    "vec4<i32>": {
      type: "i32",
      components: 4
    },
    "vec2<u32>": {
      type: "u32",
      components: 2
    },
    "vec3<u32>": {
      type: "u32",
      components: 3
    },
    "vec4<u32>": {
      type: "u32",
      components: 4
    },
    "mat2x2<f32>": {
      type: "f32",
      components: 4
    },
    "mat2x3<f32>": {
      type: "f32",
      components: 6
    },
    "mat2x4<f32>": {
      type: "f32",
      components: 8
    },
    "mat3x2<f32>": {
      type: "f32",
      components: 6
    },
    "mat3x3<f32>": {
      type: "f32",
      components: 9
    },
    "mat3x4<f32>": {
      type: "f32",
      components: 12
    },
    "mat4x2<f32>": {
      type: "f32",
      components: 8
    },
    "mat4x3<f32>": {
      type: "f32",
      components: 12
    },
    "mat4x4<f32>": {
      type: "f32",
      components: 16
    }
  };
  function IR(n) {
    return OR[n];
  }
  function NR(n, e) {
    switch (e) {
      case 1:
        return n;
      case 2:
        return n + n % 2;
      default:
        return n + (4 - n % 4) % 4;
    }
  }
  let ql;
  function N3(n) {
    return (!ql || ql.byteLength < n) && (ql = new ArrayBuffer(n)), ql;
  }
  function PR(n, e) {
    const t = N3(n.BYTES_PER_ELEMENT * e);
    return new n(t, 0, e);
  }
  function DR(n) {
    return ArrayBuffer.isView(n) && !(n instanceof DataView);
  }
  function Tc(n) {
    return Array.isArray(n) ? n.length === 0 || typeof n[0] == "number" : DR(n);
  }
  const zb = 1024;
  class kR {
    constructor(e) {
      __publicField(this, "layout", {});
      __publicField(this, "byteLength");
      let t = 0;
      for (const [s, a] of Object.entries(e)) {
        const l = IR(a), { type: u, components: h } = l;
        t = NR(t, h);
        const d = t;
        t += h, this.layout[s] = {
          type: u,
          size: h,
          offset: d
        };
      }
      t += (4 - t % 4) % 4;
      const i = t * 4;
      this.byteLength = Math.max(i, zb);
    }
    getData(e) {
      const t = Math.max(this.byteLength, zb), i = N3(t), s = {
        i32: new Int32Array(i),
        u32: new Uint32Array(i),
        f32: new Float32Array(i),
        f16: new Uint16Array(i)
      };
      for (const [a, l] of Object.entries(e)) {
        const u = this.layout[a];
        if (!u) {
          J.warn(`Supplied uniform value ${a} not present in uniform block layout`)();
          continue;
        }
        const { type: h, size: d, offset: p } = u, _ = s[h];
        if (d === 1) {
          if (typeof l != "number" && typeof l != "boolean") {
            J.warn(`Supplied value for single component uniform ${a} is not a number: ${l}`)();
            continue;
          }
          _[p] = Number(l);
        } else {
          if (!Tc(l)) {
            J.warn(`Supplied value for multi component / array uniform ${a} is not a numeric array: ${l}`)();
            continue;
          }
          _.set(l, p);
        }
      }
      return new Uint8Array(i);
    }
    has(e) {
      return !!this.layout[e];
    }
    get(e) {
      return this.layout[e];
    }
  }
  function UR(n, e, t = 16) {
    if (n !== e) return false;
    const i = n, s = e;
    if (!Tc(i)) return false;
    if (Tc(s) && i.length === s.length) {
      for (let a = 0; a < i.length; ++a) if (s[a] !== i[a]) return false;
    }
    return true;
  }
  function BR(n) {
    return Tc(n) ? n.slice() : n;
  }
  class LR {
    constructor(e) {
      __publicField(this, "name");
      __publicField(this, "uniforms", {});
      __publicField(this, "modifiedUniforms", {});
      __publicField(this, "modified", true);
      __publicField(this, "bindingLayout", {});
      __publicField(this, "needsRedraw", "initialized");
      var _a2;
      if (this.name = (e == null ? void 0 : e.name) || "unnamed", (e == null ? void 0 : e.name) && (e == null ? void 0 : e.shaderLayout)) {
        const t = (_a2 = e == null ? void 0 : e.shaderLayout.bindings) == null ? void 0 : _a2.find((s) => s.type === "uniform" && s.name === (e == null ? void 0 : e.name));
        if (!t) throw new Error(e == null ? void 0 : e.name);
        const i = t;
        for (const s of i.uniforms || []) this.bindingLayout[s.name] = s;
      }
    }
    setUniforms(e) {
      for (const [t, i] of Object.entries(e)) this._setUniform(t, i), this.needsRedraw || this.setNeedsRedraw(`${this.name}.${t}=${i}`);
    }
    setNeedsRedraw(e) {
      this.needsRedraw = this.needsRedraw || e;
    }
    getAllUniforms() {
      return this.modifiedUniforms = {}, this.needsRedraw = false, this.uniforms || {};
    }
    _setUniform(e, t) {
      UR(this.uniforms[e], t) || (this.uniforms[e] = BR(t), this.modifiedUniforms[e] = true, this.modified = true);
    }
  }
  class FR {
    constructor(e) {
      __publicField(this, "uniformBlocks", /* @__PURE__ */ new Map());
      __publicField(this, "uniformBufferLayouts", /* @__PURE__ */ new Map());
      __publicField(this, "uniformBuffers", /* @__PURE__ */ new Map());
      for (const [t, i] of Object.entries(e)) {
        const s = t, a = new kR(i.uniformTypes || {});
        this.uniformBufferLayouts.set(s, a);
        const l = new LR({
          name: t
        });
        l.setUniforms(i.defaultUniforms || {}), this.uniformBlocks.set(s, l);
      }
    }
    destroy() {
      for (const e of this.uniformBuffers.values()) e.destroy();
    }
    setUniforms(e) {
      var _a2;
      for (const [t, i] of Object.entries(e)) (_a2 = this.uniformBlocks.get(t)) == null ? void 0 : _a2.setUniforms(i);
      this.updateUniformBuffers();
    }
    getUniformBufferByteLength(e) {
      var _a2;
      return ((_a2 = this.uniformBufferLayouts.get(e)) == null ? void 0 : _a2.byteLength) || 0;
    }
    getUniformBufferData(e) {
      var _a2, _b3;
      const t = ((_a2 = this.uniformBlocks.get(e)) == null ? void 0 : _a2.getAllUniforms()) || {};
      return (_b3 = this.uniformBufferLayouts.get(e)) == null ? void 0 : _b3.getData(t);
    }
    createUniformBuffer(e, t, i) {
      i && this.setUniforms(i);
      const s = this.getUniformBufferByteLength(t), a = e.createBuffer({
        usage: Ke.UNIFORM | Ke.COPY_DST,
        byteLength: s
      }), l = this.getUniformBufferData(t);
      return a.write(l), a;
    }
    getManagedUniformBuffer(e, t) {
      if (!this.uniformBuffers.get(t)) {
        const i = this.getUniformBufferByteLength(t), s = e.createBuffer({
          usage: Ke.UNIFORM | Ke.COPY_DST,
          byteLength: i
        });
        this.uniformBuffers.set(t, s);
      }
      return this.uniformBuffers.get(t);
    }
    updateUniformBuffers() {
      let e = false;
      for (const t of this.uniformBlocks.keys()) {
        const i = this.updateUniformBuffer(t);
        e || (e = i);
      }
      return e && J.log(3, `UniformStore.updateUniformBuffers(): ${e}`)(), e;
    }
    updateUniformBuffer(e) {
      var _a2;
      const t = this.uniformBlocks.get(e);
      let i = this.uniformBuffers.get(e), s = false;
      if (i && (t == null ? void 0 : t.needsRedraw)) {
        s || (s = t.needsRedraw);
        const a = this.getUniformBufferData(e);
        i = this.uniformBuffers.get(e), i == null ? void 0 : i.write(a);
        const l = (_a2 = this.uniformBlocks.get(e)) == null ? void 0 : _a2.getAllUniforms();
        J.log(4, `Writing to uniform buffer ${String(e)}`, a, l)();
      }
      return s;
    }
  }
  function P3(n) {
    const e = ArrayBuffer.isView(n) ? n.constructor : n;
    switch (e) {
      case Float32Array:
        return "float32";
      case Uint16Array:
        return "uint16";
      case Uint32Array:
        return "uint32";
      case Uint8Array:
      case Uint8ClampedArray:
        return "uint8";
      case Int8Array:
        return "sint8";
      case Int16Array:
        return "sint16";
      case Int32Array:
        return "sint32";
      default:
        throw new Error(e.constructor.name);
    }
  }
  function D3(n) {
    switch (n) {
      case "float32":
        return Float32Array;
      case "uint32":
        return Uint32Array;
      case "sint32":
        return Int32Array;
      case "uint16":
      case "unorm16":
        return Uint16Array;
      case "sint16":
      case "snorm16":
        return Int16Array;
      case "uint8":
      case "unorm8":
        return Uint8Array;
      case "sint8":
      case "snorm8":
        return Int8Array;
      default:
        throw new Error(n);
    }
  }
  function VR(n, e, t) {
    if (!e || e > 4) throw new Error(`size ${e}`);
    const i = e;
    let s = P3(n);
    if (s === "uint8" && t && i === 1) return "unorm8-webgl";
    if (s === "uint8" && t && i === 3) return "unorm8x3-webgl";
    if (s === "uint8" || s === "sint8") {
      if (i === 1 || i === 3) throw new Error(`size: ${e}`);
      return t && (s = s.replace("int", "norm")), `${s}x${i}`;
    }
    if (s === "uint16" || s === "sint16") {
      if (i === 1 || i === 3) throw new Error(`size: ${e}`);
      return t && (s = s.replace("int", "norm")), `${s}x${i}`;
    }
    return i === 1 ? s : `${s}x${i}`;
  }
  class Bh {
    constructor(e) {
      __publicField(this, "bufferLayouts");
      this.bufferLayouts = e;
    }
    getBufferLayout(e) {
      return this.bufferLayouts.find((t) => t.name === e) || null;
    }
    getAttributeNamesForBuffer(e) {
      var _a2;
      return e.attributes ? (_a2 = e.attributes) == null ? void 0 : _a2.map((t) => t.attribute) : [
        e.name
      ];
    }
    mergeBufferLayouts(e, t) {
      const i = [
        ...e
      ];
      for (const s of t) {
        const a = i.findIndex((l) => l.name === s.name);
        a < 0 ? i.push(s) : i[a] = s;
      }
      return i;
    }
    getBufferIndex(e) {
      const t = this.bufferLayouts.findIndex((i) => i.name === e);
      return t === -1 && J.warn(`BufferLayout: Missing buffer for "${e}".`)(), t;
    }
  }
  function zR(n, e) {
    const t = Object.fromEntries(n.attributes.map((s) => [
      s.name,
      s.location
    ])), i = e.slice();
    return i.sort((s, a) => {
      const l = s.attributes ? s.attributes.map((p) => p.attribute) : [
        s.name
      ], u = a.attributes ? a.attributes.map((p) => p.attribute) : [
        a.name
      ], h = Math.min(...l.map((p) => t[p])), d = Math.min(...u.map((p) => t[p]));
      return h - d;
    }), i;
  }
  class dn {
    constructor(e, t) {
      this.name = e, this.attributes = t, this.size = 0;
    }
    get isArray() {
      return false;
    }
    get isStruct() {
      return false;
    }
    get isTemplate() {
      return false;
    }
    getTypeName() {
      return this.name;
    }
  }
  class Hb {
    constructor(e, t, i) {
      this.name = e, this.type = t, this.attributes = i, this.offset = 0, this.size = 0;
    }
    get isArray() {
      return this.type.isArray;
    }
    get isStruct() {
      return this.type.isStruct;
    }
    get isTemplate() {
      return this.type.isTemplate;
    }
    get align() {
      return this.type.isStruct ? this.type.align : 0;
    }
    get members() {
      return this.type.isStruct ? this.type.members : null;
    }
    get format() {
      return this.type.isArray || this.type.isTemplate ? this.type.format : null;
    }
    get count() {
      return this.type.isArray ? this.type.count : 0;
    }
    get stride() {
      return this.type.isArray ? this.type.stride : this.size;
    }
  }
  class zi extends dn {
    constructor(e, t) {
      super(e, t), this.members = [], this.align = 0, this.startLine = -1, this.endLine = -1, this.inUse = false;
    }
    get isStruct() {
      return true;
    }
  }
  class $i extends dn {
    constructor(e, t) {
      super(e, t), this.count = 0, this.stride = 0;
    }
    get isArray() {
      return true;
    }
  }
  class Es extends dn {
    constructor(e, t, i, s) {
      super(e, i), this.format = t, this.access = s;
    }
    get isTemplate() {
      return true;
    }
    getTypeName() {
      let e = this.name;
      if (this.format !== null) {
        if (e === "vec2" || e === "vec3" || e === "vec4" || e === "mat2x2" || e === "mat2x3" || e === "mat2x4" || e === "mat3x2" || e === "mat3x3" || e === "mat3x4" || e === "mat4x2" || e === "mat4x3" || e === "mat4x4") {
          if (this.format.name === "f32") return e += "f", e;
          if (this.format.name === "i32") return e += "i", e;
          if (this.format.name === "u32") return e += "u", e;
          if (this.format.name === "bool") return e += "b", e;
          if (this.format.name === "f16") return e += "h", e;
        }
        e += `<${this.format.name}>`;
      } else if (e === "vec2" || e === "vec3" || e === "vec4") return e;
      return e;
    }
  }
  var Fi;
  ((n) => {
    n[n.Uniform = 0] = "Uniform", n[n.Storage = 1] = "Storage", n[n.Texture = 2] = "Texture", n[n.Sampler = 3] = "Sampler", n[n.StorageTexture = 4] = "StorageTexture";
  })(Fi || (Fi = {}));
  class Kl {
    constructor(e, t, i, s, a, l, u) {
      this.name = e, this.type = t, this.group = i, this.binding = s, this.attributes = a, this.resourceType = l, this.access = u;
    }
    get isArray() {
      return this.type.isArray;
    }
    get isStruct() {
      return this.type.isStruct;
    }
    get isTemplate() {
      return this.type.isTemplate;
    }
    get size() {
      return this.type.size;
    }
    get align() {
      return this.type.isStruct ? this.type.align : 0;
    }
    get members() {
      return this.type.isStruct ? this.type.members : null;
    }
    get format() {
      return this.type.isArray || this.type.isTemplate ? this.type.format : null;
    }
    get count() {
      return this.type.isArray ? this.type.count : 0;
    }
    get stride() {
      return this.type.isArray ? this.type.stride : this.size;
    }
  }
  class HR {
    constructor(e, t) {
      this.name = e, this.type = t;
    }
  }
  class jR {
    constructor(e, t, i, s) {
      this.name = e, this.type = t, this.locationType = i, this.location = s, this.interpolation = null;
    }
  }
  class jb {
    constructor(e, t, i, s) {
      this.name = e, this.type = t, this.locationType = i, this.location = s;
    }
  }
  class WR {
    constructor(e, t, i, s) {
      this.name = e, this.type = t, this.attributes = i, this.id = s;
    }
  }
  class $R {
    constructor(e, t, i) {
      this.name = e, this.type = t, this.attributes = i;
    }
  }
  class XR {
    constructor(e, t = null, i) {
      this.stage = null, this.inputs = [], this.outputs = [], this.arguments = [], this.returnType = null, this.resources = [], this.overrides = [], this.startLine = -1, this.endLine = -1, this.inUse = false, this.calls = /* @__PURE__ */ new Set(), this.name = e, this.stage = t, this.attributes = i;
    }
  }
  class YR {
    constructor() {
      this.vertex = [], this.fragment = [], this.compute = [];
    }
  }
  const k3 = new Float32Array(1), qR = new Int32Array(k3.buffer), Ct = new Uint16Array(1);
  function KR(n) {
    k3[0] = n;
    const e = qR[0], t = e >> 31 & 1;
    let i = e >> 23 & 255, s = 8388607 & e;
    if (i === 255) return Ct[0] = t << 15 | 31744 | (s !== 0 ? 512 : 0), Ct[0];
    if (i === 0) {
      if (s === 0) return Ct[0] = t << 15, Ct[0];
      s |= 8388608;
      let a = 113;
      for (; !(8388608 & s); ) s <<= 1, a--;
      return i = 127 - a, s &= 8388607, i > 0 ? (s = (s >> 126 - i) + (s >> 127 - i & 1), Ct[0] = t << 15 | i << 10 | s >> 13, Ct[0]) : (Ct[0] = t << 15, Ct[0]);
    }
    return i = i - 127 + 15, i >= 31 ? (Ct[0] = t << 15 | 31744, Ct[0]) : i <= 0 ? i < -10 ? (Ct[0] = t << 15, Ct[0]) : (s = (8388608 | s) >> 1 - i, Ct[0] = t << 15 | s >> 13, Ct[0]) : (s >>= 13, Ct[0] = t << 15 | i << 10 | s, Ct[0]);
  }
  const pg = new Uint32Array(1), U3 = new Float32Array(pg.buffer, 0, 1);
  function Wb(n) {
    const e = 112 + (n >> 6 & 31) << 23 | (63 & n) << 17;
    return pg[0] = e, U3[0];
  }
  function ZR(n, e, t, i, s, a, l, u, h) {
    const d = i * (l >>= s) * (a >>= s) + t * l + e * u;
    switch (h) {
      case "r8unorm":
        return [
          ke(n, d, "8unorm", 1)[0]
        ];
      case "r8snorm":
        return [
          ke(n, d, "8snorm", 1)[0]
        ];
      case "r8uint":
        return [
          ke(n, d, "8uint", 1)[0]
        ];
      case "r8sint":
        return [
          ke(n, d, "8sint", 1)[0]
        ];
      case "rg8unorm": {
        const p = ke(n, d, "8unorm", 2);
        return [
          p[0],
          p[1]
        ];
      }
      case "rg8snorm": {
        const p = ke(n, d, "8snorm", 2);
        return [
          p[0],
          p[1]
        ];
      }
      case "rg8uint": {
        const p = ke(n, d, "8uint", 2);
        return [
          p[0],
          p[1]
        ];
      }
      case "rg8sint": {
        const p = ke(n, d, "8sint", 2);
        return [
          p[0],
          p[1]
        ];
      }
      case "rgba8unorm-srgb":
      case "rgba8unorm": {
        const p = ke(n, d, "8unorm", 4);
        return [
          p[0],
          p[1],
          p[2],
          p[3]
        ];
      }
      case "rgba8snorm": {
        const p = ke(n, d, "8snorm", 4);
        return [
          p[0],
          p[1],
          p[2],
          p[3]
        ];
      }
      case "rgba8uint": {
        const p = ke(n, d, "8uint", 4);
        return [
          p[0],
          p[1],
          p[2],
          p[3]
        ];
      }
      case "rgba8sint": {
        const p = ke(n, d, "8sint", 4);
        return [
          p[0],
          p[1],
          p[2],
          p[3]
        ];
      }
      case "bgra8unorm-srgb":
      case "bgra8unorm": {
        const p = ke(n, d, "8unorm", 4);
        return [
          p[2],
          p[1],
          p[0],
          p[3]
        ];
      }
      case "r16uint":
        return [
          ke(n, d, "16uint", 1)[0]
        ];
      case "r16sint":
        return [
          ke(n, d, "16sint", 1)[0]
        ];
      case "r16float":
        return [
          ke(n, d, "16float", 1)[0]
        ];
      case "rg16uint": {
        const p = ke(n, d, "16uint", 2);
        return [
          p[0],
          p[1]
        ];
      }
      case "rg16sint": {
        const p = ke(n, d, "16sint", 2);
        return [
          p[0],
          p[1]
        ];
      }
      case "rg16float": {
        const p = ke(n, d, "16float", 2);
        return [
          p[0],
          p[1]
        ];
      }
      case "rgba16uint": {
        const p = ke(n, d, "16uint", 4);
        return [
          p[0],
          p[1],
          p[2],
          p[3]
        ];
      }
      case "rgba16sint": {
        const p = ke(n, d, "16sint", 4);
        return [
          p[0],
          p[1],
          p[2],
          p[3]
        ];
      }
      case "rgba16float": {
        const p = ke(n, d, "16float", 4);
        return [
          p[0],
          p[1],
          p[2],
          p[3]
        ];
      }
      case "r32uint":
        return [
          ke(n, d, "32uint", 1)[0]
        ];
      case "r32sint":
        return [
          ke(n, d, "32sint", 1)[0]
        ];
      case "depth16unorm":
      case "depth24plus":
      case "depth24plus-stencil8":
      case "depth32float":
      case "depth32float-stencil8":
      case "r32float":
        return [
          ke(n, d, "32float", 1)[0]
        ];
      case "rg32uint": {
        const p = ke(n, d, "32uint", 2);
        return [
          p[0],
          p[1]
        ];
      }
      case "rg32sint": {
        const p = ke(n, d, "32sint", 2);
        return [
          p[0],
          p[1]
        ];
      }
      case "rg32float": {
        const p = ke(n, d, "32float", 2);
        return [
          p[0],
          p[1]
        ];
      }
      case "rgba32uint": {
        const p = ke(n, d, "32uint", 4);
        return [
          p[0],
          p[1],
          p[2],
          p[3]
        ];
      }
      case "rgba32sint": {
        const p = ke(n, d, "32sint", 4);
        return [
          p[0],
          p[1],
          p[2],
          p[3]
        ];
      }
      case "rgba32float": {
        const p = ke(n, d, "32float", 4);
        return [
          p[0],
          p[1],
          p[2],
          p[3]
        ];
      }
      case "rg11b10ufloat": {
        const p = new Uint32Array(n.buffer, d, 1)[0], _ = (4192256 & p) >> 11, y = (4290772992 & p) >> 22;
        return [
          Wb(2047 & p),
          Wb(_),
          function(v) {
            const S = 112 + (v >> 5 & 31) << 23 | (31 & v) << 18;
            return pg[0] = S, U3[0];
          }(y),
          1
        ];
      }
    }
    return null;
  }
  function ke(n, e, t, i) {
    const s = [
      0,
      0,
      0,
      0
    ];
    for (let d = 0; d < i; ++d) switch (t) {
      case "8unorm":
        s[d] = n[e] / 255, e++;
        break;
      case "8snorm":
        s[d] = n[e] / 255 * 2 - 1, e++;
        break;
      case "8uint":
        s[d] = n[e], e++;
        break;
      case "8sint":
        s[d] = n[e] - 127, e++;
        break;
      case "16uint":
        s[d] = n[e] | n[e + 1] << 8, e += 2;
        break;
      case "16sint":
        s[d] = (n[e] | n[e + 1] << 8) - 32768, e += 2;
        break;
      case "16float":
        s[d] = (a = n[e] | n[e + 1] << 8, l = void 0, u = void 0, h = void 0, l = (32768 & a) >> 15, h = 1023 & a, (u = (31744 & a) >> 10) == 0 ? (l ? -1 : 1) * Math.pow(2, -14) * (h / Math.pow(2, 10)) : u == 31 ? h ? NaN : 1 / 0 * (l ? -1 : 1) : (l ? -1 : 1) * Math.pow(2, u - 15) * (1 + h / Math.pow(2, 10))), e += 2;
        break;
      case "32uint":
      case "32sint":
        s[d] = n[e] | n[e + 1] << 8 | n[e + 2] << 16 | n[e + 3] << 24, e += 4;
        break;
      case "32float":
        s[d] = new Float32Array(n.buffer, e, 1)[0], e += 4;
    }
    var a, l, u, h;
    return s;
  }
  function Be(n, e, t, i, s) {
    for (let a = 0; a < i; ++a) switch (t) {
      case "8unorm":
        n[e] = 255 * s[a], e++;
        break;
      case "8snorm":
        n[e] = 0.5 * (s[a] + 1) * 255, e++;
        break;
      case "8uint":
        n[e] = s[a], e++;
        break;
      case "8sint":
        n[e] = s[a] + 127, e++;
        break;
      case "16uint":
        new Uint16Array(n.buffer, e, 1)[0] = s[a], e += 2;
        break;
      case "16sint":
        new Int16Array(n.buffer, e, 1)[0] = s[a], e += 2;
        break;
      case "16float": {
        const l = KR(s[a]);
        new Uint16Array(n.buffer, e, 1)[0] = l, e += 2;
        break;
      }
      case "32uint":
        new Uint32Array(n.buffer, e, 1)[0] = s[a], e += 4;
        break;
      case "32sint":
        new Int32Array(n.buffer, e, 1)[0] = s[a], e += 4;
        break;
      case "32float":
        new Float32Array(n.buffer, e, 1)[0] = s[a], e += 4;
    }
    return s;
  }
  const Lh = {
    r8unorm: {
      bytesPerBlock: 1,
      blockWidth: 1,
      blockHeight: 1,
      isCompressed: false,
      channels: 1
    },
    r8snorm: {
      bytesPerBlock: 1,
      blockWidth: 1,
      blockHeight: 1,
      isCompressed: false,
      channels: 1
    },
    r8uint: {
      bytesPerBlock: 1,
      blockWidth: 1,
      blockHeight: 1,
      isCompressed: false,
      channels: 1
    },
    r8sint: {
      bytesPerBlock: 1,
      blockWidth: 1,
      blockHeight: 1,
      isCompressed: false,
      channels: 1
    },
    rg8unorm: {
      bytesPerBlock: 2,
      blockWidth: 1,
      blockHeight: 1,
      isCompressed: false,
      channels: 2
    },
    rg8snorm: {
      bytesPerBlock: 2,
      blockWidth: 1,
      blockHeight: 1,
      isCompressed: false,
      channels: 2
    },
    rg8uint: {
      bytesPerBlock: 2,
      blockWidth: 1,
      blockHeight: 1,
      isCompressed: false,
      channels: 2
    },
    rg8sint: {
      bytesPerBlock: 2,
      blockWidth: 1,
      blockHeight: 1,
      isCompressed: false,
      channels: 2
    },
    rgba8unorm: {
      bytesPerBlock: 4,
      blockWidth: 1,
      blockHeight: 1,
      isCompressed: false,
      channels: 4
    },
    "rgba8unorm-srgb": {
      bytesPerBlock: 4,
      blockWidth: 1,
      blockHeight: 1,
      isCompressed: false,
      channels: 4
    },
    rgba8snorm: {
      bytesPerBlock: 4,
      blockWidth: 1,
      blockHeight: 1,
      isCompressed: false,
      channels: 4
    },
    rgba8uint: {
      bytesPerBlock: 4,
      blockWidth: 1,
      blockHeight: 1,
      isCompressed: false,
      channels: 4
    },
    rgba8sint: {
      bytesPerBlock: 4,
      blockWidth: 1,
      blockHeight: 1,
      isCompressed: false,
      channels: 4
    },
    bgra8unorm: {
      bytesPerBlock: 4,
      blockWidth: 1,
      blockHeight: 1,
      isCompressed: false,
      channels: 4
    },
    "bgra8unorm-srgb": {
      bytesPerBlock: 4,
      blockWidth: 1,
      blockHeight: 1,
      isCompressed: false,
      channels: 4
    },
    r16uint: {
      bytesPerBlock: 2,
      blockWidth: 1,
      blockHeight: 1,
      isCompressed: false,
      channels: 1
    },
    r16sint: {
      bytesPerBlock: 2,
      blockWidth: 1,
      blockHeight: 1,
      isCompressed: false,
      channels: 1
    },
    r16float: {
      bytesPerBlock: 2,
      blockWidth: 1,
      blockHeight: 1,
      isCompressed: false,
      channels: 1
    },
    rg16uint: {
      bytesPerBlock: 4,
      blockWidth: 1,
      blockHeight: 1,
      isCompressed: false,
      channels: 2
    },
    rg16sint: {
      bytesPerBlock: 4,
      blockWidth: 1,
      blockHeight: 1,
      isCompressed: false,
      channels: 2
    },
    rg16float: {
      bytesPerBlock: 4,
      blockWidth: 1,
      blockHeight: 1,
      isCompressed: false,
      channels: 2
    },
    rgba16uint: {
      bytesPerBlock: 8,
      blockWidth: 1,
      blockHeight: 1,
      isCompressed: false,
      channels: 4
    },
    rgba16sint: {
      bytesPerBlock: 8,
      blockWidth: 1,
      blockHeight: 1,
      isCompressed: false,
      channels: 4
    },
    rgba16float: {
      bytesPerBlock: 8,
      blockWidth: 1,
      blockHeight: 1,
      isCompressed: false,
      channels: 4
    },
    r32uint: {
      bytesPerBlock: 4,
      blockWidth: 1,
      blockHeight: 1,
      isCompressed: false,
      channels: 1
    },
    r32sint: {
      bytesPerBlock: 4,
      blockWidth: 1,
      blockHeight: 1,
      isCompressed: false,
      channels: 1
    },
    r32float: {
      bytesPerBlock: 4,
      blockWidth: 1,
      blockHeight: 1,
      isCompressed: false,
      channels: 1
    },
    rg32uint: {
      bytesPerBlock: 8,
      blockWidth: 1,
      blockHeight: 1,
      isCompressed: false,
      channels: 2
    },
    rg32sint: {
      bytesPerBlock: 8,
      blockWidth: 1,
      blockHeight: 1,
      isCompressed: false,
      channels: 2
    },
    rg32float: {
      bytesPerBlock: 8,
      blockWidth: 1,
      blockHeight: 1,
      isCompressed: false,
      channels: 2
    },
    rgba32uint: {
      bytesPerBlock: 16,
      blockWidth: 1,
      blockHeight: 1,
      isCompressed: false,
      channels: 4
    },
    rgba32sint: {
      bytesPerBlock: 16,
      blockWidth: 1,
      blockHeight: 1,
      isCompressed: false,
      channels: 4
    },
    rgba32float: {
      bytesPerBlock: 16,
      blockWidth: 1,
      blockHeight: 1,
      isCompressed: false,
      channels: 4
    },
    rgb10a2uint: {
      bytesPerBlock: 4,
      blockWidth: 1,
      blockHeight: 1,
      isCompressed: false,
      channels: 4
    },
    rgb10a2unorm: {
      bytesPerBlock: 4,
      blockWidth: 1,
      blockHeight: 1,
      isCompressed: false,
      channels: 4
    },
    rg11b10ufloat: {
      bytesPerBlock: 4,
      blockWidth: 1,
      blockHeight: 1,
      isCompressed: false,
      channels: 4
    },
    stencil8: {
      bytesPerBlock: 1,
      blockWidth: 1,
      blockHeight: 1,
      isCompressed: false,
      isDepthStencil: true,
      hasDepth: false,
      hasStencil: true,
      channels: 1
    },
    depth16unorm: {
      bytesPerBlock: 2,
      blockWidth: 1,
      blockHeight: 1,
      isCompressed: false,
      isDepthStencil: true,
      hasDepth: true,
      hasStencil: false,
      channels: 1
    },
    depth24plus: {
      bytesPerBlock: 4,
      blockWidth: 1,
      blockHeight: 1,
      isCompressed: false,
      isDepthStencil: true,
      hasDepth: true,
      hasStencil: false,
      depthOnlyFormat: "depth32float",
      channels: 1
    },
    "depth24plus-stencil8": {
      bytesPerBlock: 8,
      blockWidth: 1,
      blockHeight: 1,
      isCompressed: false,
      isDepthStencil: true,
      hasDepth: true,
      hasStencil: true,
      depthOnlyFormat: "depth32float",
      channels: 1
    },
    depth32float: {
      bytesPerBlock: 4,
      blockWidth: 1,
      blockHeight: 1,
      isCompressed: false,
      isDepthStencil: true,
      hasDepth: true,
      hasStencil: false,
      channels: 1
    },
    "depth32float-stencil8": {
      bytesPerBlock: 8,
      blockWidth: 1,
      blockHeight: 1,
      isCompressed: false,
      isDepthStencil: true,
      hasDepth: true,
      hasStencil: true,
      stencilOnlyFormat: "depth32float",
      channels: 1
    },
    rgb9e5ufloat: {
      bytesPerBlock: 4,
      blockWidth: 1,
      blockHeight: 1,
      isCompressed: false,
      channels: 4
    },
    "bc1-rgba-unorm": {
      bytesPerBlock: 8,
      blockWidth: 4,
      blockHeight: 4,
      isCompressed: true,
      channels: 4
    },
    "bc1-rgba-unorm-srgb": {
      bytesPerBlock: 8,
      blockWidth: 4,
      blockHeight: 4,
      isCompressed: true,
      channels: 4
    },
    "bc2-rgba-unorm": {
      bytesPerBlock: 16,
      blockWidth: 4,
      blockHeight: 4,
      isCompressed: true,
      channels: 4
    },
    "bc2-rgba-unorm-srgb": {
      bytesPerBlock: 16,
      blockWidth: 4,
      blockHeight: 4,
      isCompressed: true,
      channels: 4
    },
    "bc3-rgba-unorm": {
      bytesPerBlock: 16,
      blockWidth: 4,
      blockHeight: 4,
      isCompressed: true,
      channels: 4
    },
    "bc3-rgba-unorm-srgb": {
      bytesPerBlock: 16,
      blockWidth: 4,
      blockHeight: 4,
      isCompressed: true,
      channels: 4
    },
    "bc4-r-unorm": {
      bytesPerBlock: 8,
      blockWidth: 4,
      blockHeight: 4,
      isCompressed: true,
      channels: 1
    },
    "bc4-r-snorm": {
      bytesPerBlock: 8,
      blockWidth: 4,
      blockHeight: 4,
      isCompressed: true,
      channels: 1
    },
    "bc5-rg-unorm": {
      bytesPerBlock: 16,
      blockWidth: 4,
      blockHeight: 4,
      isCompressed: true,
      channels: 2
    },
    "bc5-rg-snorm": {
      bytesPerBlock: 16,
      blockWidth: 4,
      blockHeight: 4,
      isCompressed: true,
      channels: 2
    },
    "bc6h-rgb-ufloat": {
      bytesPerBlock: 16,
      blockWidth: 4,
      blockHeight: 4,
      isCompressed: true,
      channels: 4
    },
    "bc6h-rgb-float": {
      bytesPerBlock: 16,
      blockWidth: 4,
      blockHeight: 4,
      isCompressed: true,
      channels: 4
    },
    "bc7-rgba-unorm": {
      bytesPerBlock: 16,
      blockWidth: 4,
      blockHeight: 4,
      isCompressed: true,
      channels: 4
    },
    "bc7-rgba-unorm-srgb": {
      bytesPerBlock: 16,
      blockWidth: 4,
      blockHeight: 4,
      isCompressed: true,
      channels: 4
    },
    "etc2-rgb8unorm": {
      bytesPerBlock: 8,
      blockWidth: 4,
      blockHeight: 4,
      isCompressed: true,
      channels: 4
    },
    "etc2-rgb8unorm-srgb": {
      bytesPerBlock: 8,
      blockWidth: 4,
      blockHeight: 4,
      isCompressed: true,
      channels: 4
    },
    "etc2-rgb8a1unorm": {
      bytesPerBlock: 8,
      blockWidth: 4,
      blockHeight: 4,
      isCompressed: true,
      channels: 4
    },
    "etc2-rgb8a1unorm-srgb": {
      bytesPerBlock: 8,
      blockWidth: 4,
      blockHeight: 4,
      isCompressed: true,
      channels: 4
    },
    "etc2-rgba8unorm": {
      bytesPerBlock: 16,
      blockWidth: 4,
      blockHeight: 4,
      isCompressed: true,
      channels: 4
    },
    "etc2-rgba8unorm-srgb": {
      bytesPerBlock: 16,
      blockWidth: 4,
      blockHeight: 4,
      isCompressed: true,
      channels: 4
    },
    "eac-r11unorm": {
      bytesPerBlock: 8,
      blockWidth: 1,
      blockHeight: 1,
      isCompressed: true,
      channels: 1
    },
    "eac-r11snorm": {
      bytesPerBlock: 8,
      blockWidth: 1,
      blockHeight: 1,
      isCompressed: true,
      channels: 1
    },
    "eac-rg11unorm": {
      bytesPerBlock: 16,
      blockWidth: 1,
      blockHeight: 1,
      isCompressed: true,
      channels: 2
    },
    "eac-rg11snorm": {
      bytesPerBlock: 16,
      blockWidth: 1,
      blockHeight: 1,
      isCompressed: true,
      channels: 2
    },
    "astc-4x4-unorm": {
      bytesPerBlock: 16,
      blockWidth: 4,
      blockHeight: 4,
      isCompressed: true,
      channels: 4
    },
    "astc-4x4-unorm-srgb": {
      bytesPerBlock: 16,
      blockWidth: 4,
      blockHeight: 4,
      isCompressed: true,
      channels: 4
    },
    "astc-5x4-unorm": {
      bytesPerBlock: 16,
      blockWidth: 5,
      blockHeight: 4,
      isCompressed: true,
      channels: 4
    },
    "astc-5x4-unorm-srgb": {
      bytesPerBlock: 16,
      blockWidth: 5,
      blockHeight: 4,
      isCompressed: true,
      channels: 4
    },
    "astc-5x5-unorm": {
      bytesPerBlock: 16,
      blockWidth: 5,
      blockHeight: 5,
      isCompressed: true,
      channels: 4
    },
    "astc-5x5-unorm-srgb": {
      bytesPerBlock: 16,
      blockWidth: 5,
      blockHeight: 5,
      isCompressed: true,
      channels: 4
    },
    "astc-6x5-unorm": {
      bytesPerBlock: 16,
      blockWidth: 6,
      blockHeight: 5,
      isCompressed: true,
      channels: 4
    },
    "astc-6x5-unorm-srgb": {
      bytesPerBlock: 16,
      blockWidth: 6,
      blockHeight: 5,
      isCompressed: true,
      channels: 4
    },
    "astc-6x6-unorm": {
      bytesPerBlock: 16,
      blockWidth: 6,
      blockHeight: 6,
      isCompressed: true,
      channels: 4
    },
    "astc-6x6-unorm-srgb": {
      bytesPerBlock: 16,
      blockWidth: 6,
      blockHeight: 6,
      isCompressed: true,
      channels: 4
    },
    "astc-8x5-unorm": {
      bytesPerBlock: 16,
      blockWidth: 8,
      blockHeight: 5,
      isCompressed: true,
      channels: 4
    },
    "astc-8x5-unorm-srgb": {
      bytesPerBlock: 16,
      blockWidth: 8,
      blockHeight: 5,
      isCompressed: true,
      channels: 4
    },
    "astc-8x6-unorm": {
      bytesPerBlock: 16,
      blockWidth: 8,
      blockHeight: 6,
      isCompressed: true,
      channels: 4
    },
    "astc-8x6-unorm-srgb": {
      bytesPerBlock: 16,
      blockWidth: 8,
      blockHeight: 6,
      isCompressed: true,
      channels: 4
    },
    "astc-8x8-unorm": {
      bytesPerBlock: 16,
      blockWidth: 8,
      blockHeight: 8,
      isCompressed: true,
      channels: 4
    },
    "astc-8x8-unorm-srgb": {
      bytesPerBlock: 16,
      blockWidth: 8,
      blockHeight: 8,
      isCompressed: true,
      channels: 4
    },
    "astc-10x5-unorm": {
      bytesPerBlock: 16,
      blockWidth: 10,
      blockHeight: 5,
      isCompressed: true,
      channels: 4
    },
    "astc-10x5-unorm-srgb": {
      bytesPerBlock: 16,
      blockWidth: 10,
      blockHeight: 5,
      isCompressed: true,
      channels: 4
    },
    "astc-10x6-unorm": {
      bytesPerBlock: 16,
      blockWidth: 10,
      blockHeight: 6,
      isCompressed: true,
      channels: 4
    },
    "astc-10x6-unorm-srgb": {
      bytesPerBlock: 16,
      blockWidth: 10,
      blockHeight: 6,
      isCompressed: true,
      channels: 4
    },
    "astc-10x8-unorm": {
      bytesPerBlock: 16,
      blockWidth: 10,
      blockHeight: 8,
      isCompressed: true,
      channels: 4
    },
    "astc-10x8-unorm-srgb": {
      bytesPerBlock: 16,
      blockWidth: 10,
      blockHeight: 8,
      isCompressed: true,
      channels: 4
    },
    "astc-10x10-unorm": {
      bytesPerBlock: 16,
      blockWidth: 10,
      blockHeight: 10,
      isCompressed: true,
      channels: 4
    },
    "astc-10x10-unorm-srgb": {
      bytesPerBlock: 16,
      blockWidth: 10,
      blockHeight: 10,
      isCompressed: true,
      channels: 4
    },
    "astc-12x10-unorm": {
      bytesPerBlock: 16,
      blockWidth: 12,
      blockHeight: 10,
      isCompressed: true,
      channels: 4
    },
    "astc-12x10-unorm-srgb": {
      bytesPerBlock: 16,
      blockWidth: 12,
      blockHeight: 10,
      isCompressed: true,
      channels: 4
    },
    "astc-12x12-unorm": {
      bytesPerBlock: 16,
      blockWidth: 12,
      blockHeight: 12,
      isCompressed: true,
      channels: 4
    },
    "astc-12x12-unorm-srgb": {
      bytesPerBlock: 16,
      blockWidth: 12,
      blockHeight: 12,
      isCompressed: true,
      channels: 4
    }
  };
  class _n {
    constructor() {
      this.id = _n._id++, this.line = 0;
    }
    get isAstNode() {
      return true;
    }
    get astNodeType() {
      return "";
    }
    search(e) {
      e(this);
    }
    searchBlock(e, t) {
      if (e) {
        t(xc.instance);
        for (const i of e) i instanceof Array ? this.searchBlock(i, t) : i.search(t);
        t(Sc.instance);
      }
    }
    constEvaluate(e, t) {
      throw new Error("Cannot evaluate node");
    }
    constEvaluateString(e) {
      return this.constEvaluate(e).toString();
    }
  }
  _n._id = 0;
  class xc extends _n {
  }
  xc.instance = new xc();
  class Sc extends _n {
  }
  Sc.instance = new Sc();
  const B3 = /* @__PURE__ */ new Set([
    "all",
    "all",
    "any",
    "select",
    "arrayLength",
    "abs",
    "acos",
    "acosh",
    "asin",
    "asinh",
    "atan",
    "atanh",
    "atan2",
    "ceil",
    "clamp",
    "cos",
    "cosh",
    "countLeadingZeros",
    "countOneBits",
    "countTrailingZeros",
    "cross",
    "degrees",
    "determinant",
    "distance",
    "dot",
    "dot4U8Packed",
    "dot4I8Packed",
    "exp",
    "exp2",
    "extractBits",
    "faceForward",
    "firstLeadingBit",
    "firstTrailingBit",
    "floor",
    "fma",
    "fract",
    "frexp",
    "insertBits",
    "inverseSqrt",
    "ldexp",
    "length",
    "log",
    "log2",
    "max",
    "min",
    "mix",
    "modf",
    "normalize",
    "pow",
    "quantizeToF16",
    "radians",
    "reflect",
    "refract",
    "reverseBits",
    "round",
    "saturate",
    "sign",
    "sin",
    "sinh",
    "smoothStep",
    "sqrt",
    "step",
    "tan",
    "tanh",
    "transpose",
    "trunc",
    "dpdx",
    "dpdxCoarse",
    "dpdxFine",
    "dpdy",
    "dpdyCoarse",
    "dpdyFine",
    "fwidth",
    "fwidthCoarse",
    "fwidthFine",
    "textureDimensions",
    "textureGather",
    "textureGatherCompare",
    "textureLoad",
    "textureNumLayers",
    "textureNumLevels",
    "textureNumSamples",
    "textureSample",
    "textureSampleBias",
    "textureSampleCompare",
    "textureSampleCompareLevel",
    "textureSampleGrad",
    "textureSampleLevel",
    "textureSampleBaseClampToEdge",
    "textureStore",
    "atomicLoad",
    "atomicStore",
    "atomicAdd",
    "atomicSub",
    "atomicMax",
    "atomicMin",
    "atomicAnd",
    "atomicOr",
    "atomicXor",
    "atomicExchange",
    "atomicCompareExchangeWeak",
    "pack4x8snorm",
    "pack4x8unorm",
    "pack4xI8",
    "pack4xU8",
    "pack4x8Clamp",
    "pack4xU8Clamp",
    "pack2x16snorm",
    "pack2x16unorm",
    "pack2x16float",
    "unpack4x8snorm",
    "unpack4x8unorm",
    "unpack4xI8",
    "unpack4xU8",
    "unpack2x16snorm",
    "unpack2x16unorm",
    "unpack2x16float",
    "storageBarrier",
    "textureBarrier",
    "workgroupBarrier",
    "workgroupUniformLoad",
    "subgroupAdd",
    "subgroupExclusiveAdd",
    "subgroupInclusiveAdd",
    "subgroupAll",
    "subgroupAnd",
    "subgroupAny",
    "subgroupBallot",
    "subgroupBroadcast",
    "subgroupBroadcastFirst",
    "subgroupElect",
    "subgroupMax",
    "subgroupMin",
    "subgroupMul",
    "subgroupExclusiveMul",
    "subgroupInclusiveMul",
    "subgroupOr",
    "subgroupShuffle",
    "subgroupShuffleDown",
    "subgroupShuffleUp",
    "subgroupShuffleXor",
    "subgroupXor",
    "quadBroadcast",
    "quadSwapDiagonal",
    "quadSwapX",
    "quadSwapY"
  ]);
  class Qe extends _n {
    constructor() {
      super();
    }
  }
  class mo extends Qe {
    constructor(e, t, i, s, a, l) {
      super(), this.calls = /* @__PURE__ */ new Set(), this.name = e, this.args = t, this.returnType = i, this.body = s, this.startLine = a, this.endLine = l;
    }
    get astNodeType() {
      return "function";
    }
    search(e) {
      if (this.attributes) for (const t of this.attributes) e(t);
      e(this);
      for (const t of this.args) e(t);
      this.searchBlock(this.body, e);
    }
  }
  class QR extends Qe {
    constructor(e) {
      super(), this.expression = e;
    }
    get astNodeType() {
      return "staticAssert";
    }
    search(e) {
      this.expression.search(e);
    }
  }
  class L3 extends Qe {
    constructor(e, t) {
      super(), this.condition = e, this.body = t;
    }
    get astNodeType() {
      return "while";
    }
    search(e) {
      this.condition.search(e), this.searchBlock(this.body, e);
    }
  }
  class xd extends Qe {
    constructor(e, t) {
      super(), this.body = e, this.loopId = t;
    }
    get astNodeType() {
      return "continuing";
    }
    search(e) {
      this.searchBlock(this.body, e);
    }
  }
  class F3 extends Qe {
    constructor(e, t, i, s) {
      super(), this.init = e, this.condition = t, this.increment = i, this.body = s;
    }
    get astNodeType() {
      return "for";
    }
    search(e) {
      var t, i, s;
      (t = this.init) === null || t === void 0 || t.search(e), (i = this.condition) === null || i === void 0 || i.search(e), (s = this.increment) === null || s === void 0 || s.search(e), this.searchBlock(this.body, e);
    }
  }
  class ai extends Qe {
    constructor(e, t, i, s, a) {
      super(), this.attributes = null, this.name = e, this.type = t, this.storage = i, this.access = s, this.value = a;
    }
    get astNodeType() {
      return "var";
    }
    search(e) {
      var t;
      e(this), (t = this.value) === null || t === void 0 || t.search(e);
    }
  }
  class mg extends Qe {
    constructor(e, t, i) {
      super(), this.attributes = null, this.name = e, this.type = t, this.value = i;
    }
    get astNodeType() {
      return "override";
    }
    search(e) {
      var t;
      (t = this.value) === null || t === void 0 || t.search(e);
    }
  }
  class lo extends Qe {
    constructor(e, t, i, s, a) {
      super(), this.attributes = null, this.name = e, this.type = t, this.storage = i, this.access = s, this.value = a;
    }
    get astNodeType() {
      return "let";
    }
    search(e) {
      var t;
      e(this), (t = this.value) === null || t === void 0 || t.search(e);
    }
  }
  class lc extends Qe {
    constructor(e, t, i, s, a) {
      super(), this.attributes = null, this.name = e, this.type = t, this.storage = i, this.access = s, this.value = a;
    }
    get astNodeType() {
      return "const";
    }
    constEvaluate(e, t) {
      return this.value.constEvaluate(e, t);
    }
    search(e) {
      var t;
      e(this), (t = this.value) === null || t === void 0 || t.search(e);
    }
  }
  var Mr, to, L, N;
  ((n) => {
    n.increment = "++", n.decrement = "--";
  })(Mr || (Mr = {})), ((n) => {
    n.parse = function(e) {
      const t = e;
      if (t == "parse") throw new Error("Invalid value for IncrementOperator");
      return n[t];
    };
  })(Mr || (Mr = {}));
  class V3 extends Qe {
    constructor(e, t) {
      super(), this.operator = e, this.variable = t;
    }
    get astNodeType() {
      return "increment";
    }
    search(e) {
      this.variable.search(e);
    }
  }
  ((n) => {
    n.assign = "=", n.addAssign = "+=", n.subtractAssin = "-=", n.multiplyAssign = "*=", n.divideAssign = "/=", n.moduloAssign = "%=", n.andAssign = "&=", n.orAssign = "|=", n.xorAssign = "^=", n.shiftLeftAssign = "<<=", n.shiftRightAssign = ">>=";
  })(to || (to = {})), ((n) => {
    n.parse = function(e) {
      const t = e;
      if (t == "parse") throw new Error("Invalid value for AssignOperator");
      return t;
    };
  })(to || (to = {}));
  class z3 extends Qe {
    constructor(e, t, i) {
      super(), this.operator = e, this.variable = t, this.value = i;
    }
    get astNodeType() {
      return "assign";
    }
    search(e) {
      this.variable.search(e), this.value.search(e);
    }
  }
  class _g extends Qe {
    constructor(e, t) {
      super(), this.name = e, this.args = t;
    }
    get astNodeType() {
      return "call";
    }
    isBuiltin() {
      return B3.has(this.name);
    }
    search(e) {
      for (const t of this.args) t.search(e);
      e(this);
    }
  }
  class H3 extends Qe {
    constructor(e, t) {
      super(), this.body = e, this.continuing = t;
    }
    get astNodeType() {
      return "loop";
    }
  }
  class j3 extends Qe {
    constructor(e, t) {
      super(), this.condition = e, this.cases = t;
    }
    get astNodeType() {
      return "switch";
    }
  }
  class W3 extends Qe {
    constructor(e, t, i, s) {
      super(), this.condition = e, this.body = t, this.elseif = i, this.else = s;
    }
    get astNodeType() {
      return "if";
    }
    search(e) {
      this.condition.search(e), this.searchBlock(this.body, e), this.searchBlock(this.elseif, e), this.searchBlock(this.else, e);
    }
  }
  class $3 extends Qe {
    constructor(e) {
      super(), this.value = e;
    }
    get astNodeType() {
      return "return";
    }
    search(e) {
      var t;
      (t = this.value) === null || t === void 0 || t.search(e);
    }
  }
  class GR extends Qe {
    constructor(e) {
      super(), this.name = e;
    }
    get astNodeType() {
      return "enable";
    }
  }
  class JR extends Qe {
    constructor(e) {
      super(), this.extensions = e;
    }
    get astNodeType() {
      return "requires";
    }
  }
  class X3 extends Qe {
    constructor(e, t) {
      super(), this.severity = e, this.rule = t;
    }
    get astNodeType() {
      return "diagnostic";
    }
  }
  class yg extends Qe {
    constructor(e, t) {
      super(), this.name = e, this.type = t;
    }
    get astNodeType() {
      return "alias";
    }
  }
  class eC extends Qe {
    constructor() {
      super();
    }
    get astNodeType() {
      return "discard";
    }
  }
  class Y3 extends Qe {
    constructor() {
      super(), this.condition = null, this.loopId = -1;
    }
    get astNodeType() {
      return "break";
    }
  }
  class q3 extends Qe {
    constructor() {
      super(), this.loopId = -1;
    }
    get astNodeType() {
      return "continue";
    }
  }
  class q extends Qe {
    constructor(e) {
      super(), this.attributes = null, this.name = e;
    }
    get astNodeType() {
      return "type";
    }
    get isStruct() {
      return false;
    }
    get isArray() {
      return false;
    }
    static maxFormatType(e) {
      let t = e[0];
      if (t.name === "f32") return t;
      for (let i = 1; i < e.length; ++i) {
        const s = q._priority.get(t.name);
        q._priority.get(e[i].name) < s && (t = e[i]);
      }
      return t.name === "x32" ? q.i32 : t;
    }
    getTypeName() {
      return this.name;
    }
  }
  q.x32 = new q("x32"), q.f32 = new q("f32"), q.i32 = new q("i32"), q.u32 = new q("u32"), q.f16 = new q("f16"), q.bool = new q("bool"), q.void = new q("void"), q._priority = /* @__PURE__ */ new Map([
    [
      "f32",
      0
    ],
    [
      "f16",
      1
    ],
    [
      "u32",
      2
    ],
    [
      "i32",
      3
    ],
    [
      "x32",
      3
    ]
  ]);
  let $b = class extends q {
    constructor(e) {
      super(e);
    }
  };
  class si extends q {
    constructor(e, t, i, s) {
      super(e), this.members = t, this.startLine = i, this.endLine = s;
    }
    get astNodeType() {
      return "struct";
    }
    get isStruct() {
      return true;
    }
    getMemberIndex(e) {
      for (let t = 0; t < this.members.length; t++) if (this.members[t].name == e) return t;
      return -1;
    }
    search(e) {
      for (const t of this.members) e(t);
    }
  }
  class k extends q {
    constructor(e, t, i) {
      super(e), this.format = t, this.access = i;
    }
    get astNodeType() {
      return "template";
    }
    getTypeName() {
      let e = this.name;
      if (this.format !== null) {
        if (e === "vec2" || e === "vec3" || e === "vec4" || e === "mat2x2" || e === "mat2x3" || e === "mat2x4" || e === "mat3x2" || e === "mat3x3" || e === "mat3x4" || e === "mat4x2" || e === "mat4x3" || e === "mat4x4") {
          if (this.format.name === "f32") return e += "f", e;
          if (this.format.name === "i32") return e += "i", e;
          if (this.format.name === "u32") return e += "u", e;
          if (this.format.name === "bool") return e += "b", e;
          if (this.format.name === "f16") return e += "h", e;
        }
        e += `<${this.format.name}>`;
      } else if (e === "vec2" || e === "vec3" || e === "vec4") return e;
      return e;
    }
  }
  k.vec2f = new k("vec2", q.f32, null), k.vec3f = new k("vec3", q.f32, null), k.vec4f = new k("vec4", q.f32, null), k.vec2i = new k("vec2", q.i32, null), k.vec3i = new k("vec3", q.i32, null), k.vec4i = new k("vec4", q.i32, null), k.vec2u = new k("vec2", q.u32, null), k.vec3u = new k("vec3", q.u32, null), k.vec4u = new k("vec4", q.u32, null), k.vec2h = new k("vec2", q.f16, null), k.vec3h = new k("vec3", q.f16, null), k.vec4h = new k("vec4", q.f16, null), k.vec2b = new k("vec2", q.bool, null), k.vec3b = new k("vec3", q.bool, null), k.vec4b = new k("vec4", q.bool, null), k.mat2x2f = new k("mat2x2", q.f32, null), k.mat2x3f = new k("mat2x3", q.f32, null), k.mat2x4f = new k("mat2x4", q.f32, null), k.mat3x2f = new k("mat3x2", q.f32, null), k.mat3x3f = new k("mat3x3", q.f32, null), k.mat3x4f = new k("mat3x4", q.f32, null), k.mat4x2f = new k("mat4x2", q.f32, null), k.mat4x3f = new k("mat4x3", q.f32, null), k.mat4x4f = new k("mat4x4", q.f32, null), k.mat2x2h = new k("mat2x2", q.f16, null), k.mat2x3h = new k("mat2x3", q.f16, null), k.mat2x4h = new k("mat2x4", q.f16, null), k.mat3x2h = new k("mat3x2", q.f16, null), k.mat3x3h = new k("mat3x3", q.f16, null), k.mat3x4h = new k("mat3x4", q.f16, null), k.mat4x2h = new k("mat4x2", q.f16, null), k.mat4x3h = new k("mat4x3", q.f16, null), k.mat4x4h = new k("mat4x4", q.f16, null), k.mat2x2i = new k("mat2x2", q.i32, null), k.mat2x3i = new k("mat2x3", q.i32, null), k.mat2x4i = new k("mat2x4", q.i32, null), k.mat3x2i = new k("mat3x2", q.i32, null), k.mat3x3i = new k("mat3x3", q.i32, null), k.mat3x4i = new k("mat3x4", q.i32, null), k.mat4x2i = new k("mat4x2", q.i32, null), k.mat4x3i = new k("mat4x3", q.i32, null), k.mat4x4i = new k("mat4x4", q.i32, null), k.mat2x2u = new k("mat2x2", q.u32, null), k.mat2x3u = new k("mat2x3", q.u32, null), k.mat2x4u = new k("mat2x4", q.u32, null), k.mat3x2u = new k("mat3x2", q.u32, null), k.mat3x3u = new k("mat3x3", q.u32, null), k.mat3x4u = new k("mat3x4", q.u32, null), k.mat4x2u = new k("mat4x2", q.u32, null), k.mat4x3u = new k("mat4x3", q.u32, null), k.mat4x4u = new k("mat4x4", q.u32, null);
  class Fh extends q {
    constructor(e, t, i, s) {
      super(e), this.storage = t, this.type = i, this.access = s;
    }
    get astNodeType() {
      return "pointer";
    }
  }
  class co extends q {
    constructor(e, t, i, s) {
      super(e), this.attributes = t, this.format = i, this.count = s;
    }
    get astNodeType() {
      return "array";
    }
    get isArray() {
      return true;
    }
  }
  class no extends q {
    constructor(e, t, i) {
      super(e), this.format = t, this.access = i;
    }
    get astNodeType() {
      return "sampler";
    }
  }
  class zn extends _n {
    constructor() {
      super(), this.postfix = null;
    }
  }
  class Rs extends zn {
    constructor(e) {
      super(), this.value = e;
    }
    get astNodeType() {
      return "stringExpr";
    }
    toString() {
      return this.value;
    }
    constEvaluateString() {
      return this.value;
    }
  }
  class Pn extends zn {
    constructor(e, t) {
      super(), this.type = e, this.args = t;
    }
    get astNodeType() {
      return "createExpr";
    }
    search(e) {
      if (e(this), this.args) for (const t of this.args) t.search(e);
    }
    constEvaluate(e, t) {
      return t && (t[0] = this.type), e.evalExpression(this, e.context);
    }
  }
  class bg extends zn {
    constructor(e, t) {
      super(), this.cachedReturnValue = null, this.name = e, this.args = t;
    }
    get astNodeType() {
      return "callExpr";
    }
    setCachedReturnValue(e) {
      this.cachedReturnValue = e;
    }
    get isBuiltin() {
      return B3.has(this.name);
    }
    constEvaluate(e, t) {
      return e.evalExpression(this, e.context);
    }
    search(e) {
      for (const t of this.args) t.search(e);
      e(this);
    }
  }
  class en extends zn {
    constructor(e) {
      super(), this.name = e;
    }
    get astNodeType() {
      return "varExpr";
    }
    search(e) {
      e(this), this.postfix && this.postfix.search(e);
    }
    constEvaluate(e, t) {
      return e.evalExpression(this, e.context);
    }
  }
  class K3 extends zn {
    constructor(e, t) {
      super(), this.name = e, this.initializer = t;
    }
    get astNodeType() {
      return "constExpr";
    }
    constEvaluate(e, t) {
      if (this.initializer) {
        const i = e.evalExpression(this.initializer, e.context);
        return i !== null && this.postfix ? i.getSubData(e, this.postfix, e.context) : i;
      }
      return null;
    }
    search(e) {
      this.initializer.search(e);
    }
  }
  class dt extends zn {
    constructor(e, t) {
      super(), this.value = e, this.type = t;
    }
    get astNodeType() {
      return "literalExpr";
    }
    constEvaluate(e, t) {
      return t !== void 0 && (t[0] = this.type), this.value;
    }
    get isScalar() {
      return this.value instanceof I;
    }
    get isVector() {
      return this.value instanceof A || this.value instanceof _e;
    }
    get scalarValue() {
      return this.value instanceof I ? this.value.value : (console.error("Value is not scalar."), 0);
    }
    get vectorValue() {
      return this.value instanceof A || this.value instanceof _e ? this.value.data : (console.error("Value is not a vector or matrix."), new Float32Array(0));
    }
  }
  class Z3 extends zn {
    constructor(e, t) {
      super(), this.type = e, this.value = t;
    }
    get astNodeType() {
      return "bitcastExpr";
    }
    search(e) {
      this.value.search(e);
    }
  }
  class zr extends zn {
    constructor(e) {
      super(), this.index = e;
    }
    search(e) {
      this.index.search(e);
    }
  }
  class Q3 extends zn {
    constructor() {
      super();
    }
  }
  class ct extends Q3 {
    constructor(e, t) {
      super(), this.operator = e, this.right = t;
    }
    get astNodeType() {
      return "unaryOp";
    }
    constEvaluate(e, t) {
      return e.evalExpression(this, e.context);
    }
    search(e) {
      this.right.search(e);
    }
  }
  class xn extends Q3 {
    constructor(e, t, i) {
      super(), this.operator = e, this.left = t, this.right = i;
    }
    get astNodeType() {
      return "binaryOp";
    }
    _getPromotedType(e, t) {
      return e.name === t.name ? e : e.name === "f32" || t.name === "f32" ? q.f32 : e.name === "u32" || t.name === "u32" ? q.u32 : q.i32;
    }
    constEvaluate(e, t) {
      return e.evalExpression(this, e.context);
    }
    search(e) {
      this.left.search(e), this.right.search(e);
    }
  }
  class G3 extends _n {
    constructor(e) {
      super(), this.body = e;
    }
  }
  class cc extends zn {
    constructor() {
      super();
    }
    get astNodeType() {
      return "default";
    }
  }
  class J3 extends G3 {
    constructor(e, t) {
      super(t), this.selectors = e;
    }
    get astNodeType() {
      return "case";
    }
    search(e) {
      this.searchBlock(this.body, e);
    }
  }
  class e2 extends G3 {
    constructor(e) {
      super(e);
    }
    get astNodeType() {
      return "default";
    }
    search(e) {
      this.searchBlock(this.body, e);
    }
  }
  class Xb extends _n {
    constructor(e, t, i) {
      super(), this.name = e, this.type = t, this.attributes = i;
    }
    get astNodeType() {
      return "argument";
    }
  }
  class tC extends _n {
    constructor(e, t) {
      super(), this.condition = e, this.body = t;
    }
    get astNodeType() {
      return "elseif";
    }
    search(e) {
      this.condition.search(e), this.searchBlock(this.body, e);
    }
  }
  class Yb extends _n {
    constructor(e, t, i) {
      super(), this.name = e, this.type = t, this.attributes = i;
    }
    get astNodeType() {
      return "member";
    }
  }
  class t2 extends _n {
    constructor(e, t) {
      super(), this.name = e, this.value = t;
    }
    get astNodeType() {
      return "attribute";
    }
  }
  class mn {
    constructor(e, t) {
      this.parent = null, this.typeInfo = e, this.parent = t, this.id = mn._id++;
    }
    clone() {
      throw `Clone: Not implemented for ${this.constructor.name}`;
    }
    setDataValue(e, t, i, s) {
      console.error(`SetDataValue: Not implemented for ${this.constructor.name}`);
    }
    getSubData(e, t, i) {
      return console.error(`GetDataValue: Not implemented for ${this.constructor.name}`), null;
    }
    toString() {
      return `<${this.typeInfo.name}>`;
    }
  }
  mn._id = 0;
  class Sd extends mn {
    constructor() {
      super(new dn("void", null), null);
    }
    toString() {
      return "void";
    }
  }
  Sd.void = new Sd();
  class Sr extends mn {
    constructor(e) {
      super(new dn("pointer", null), null), this.reference = e;
    }
    clone() {
      return this;
    }
    setDataValue(e, t, i, s) {
      this.reference.setDataValue(e, t, i, s);
    }
    getSubData(e, t, i) {
      return t ? this.reference.getSubData(e, t, i) : this;
    }
  }
  class I extends mn {
    constructor(e, t, i = null) {
      super(t, i), e instanceof Int32Array || e instanceof Uint32Array || e instanceof Float32Array ? this.data = e : this.typeInfo.name === "x32" ? e - Math.floor(e) != 0 ? this.data = new Float32Array([
        e
      ]) : this.data = e >= 0 ? new Uint32Array([
        e
      ]) : new Int32Array([
        e
      ]) : this.typeInfo.name === "i32" || this.typeInfo.name === "bool" ? this.data = new Int32Array([
        e
      ]) : this.typeInfo.name === "u32" ? this.data = new Uint32Array([
        e
      ]) : this.typeInfo.name === "f32" || this.typeInfo.name === "f16" ? this.data = new Float32Array([
        e
      ]) : console.error("ScalarData2: Invalid type", t);
    }
    clone() {
      if (this.data instanceof Float32Array) return new I(new Float32Array(this.data), this.typeInfo, null);
      if (this.data instanceof Int32Array) return new I(new Int32Array(this.data), this.typeInfo, null);
      if (this.data instanceof Uint32Array) return new I(new Uint32Array(this.data), this.typeInfo, null);
      throw "ScalarData: Invalid data type";
    }
    get value() {
      return this.data[0];
    }
    set value(e) {
      this.data[0] = e;
    }
    setDataValue(e, t, i, s) {
      if (i) return void console.error("SetDataValue: Scalar data does not support postfix", i);
      if (!(t instanceof I)) return void console.error("SetDataValue: Invalid value", t);
      let a = t.data[0];
      this.typeInfo.name === "i32" || this.typeInfo.name === "u32" ? a = Math.floor(a) : this.typeInfo.name === "bool" && (a = a ? 1 : 0), this.data[0] = a;
    }
    getSubData(e, t, i) {
      return t ? (console.error("getSubData: Scalar data does not support postfix", t), null) : this;
    }
    toString() {
      return `${this.value}`;
    }
  }
  function nC(n, e, t) {
    const i = e.length;
    return i === 2 ? t === "f32" ? new A(new Float32Array(e), n.getTypeInfo("vec2f")) : t === "i32" || t === "bool" ? new A(new Int32Array(e), n.getTypeInfo("vec2i")) : t === "u32" ? new A(new Uint32Array(e), n.getTypeInfo("vec2u")) : t === "f16" ? new A(new Float32Array(e), n.getTypeInfo("vec2h")) : (console.error(`getSubData: Unknown format ${t}`), null) : i === 3 ? t === "f32" ? new A(new Float32Array(e), n.getTypeInfo("vec3f")) : t === "i32" || t === "bool" ? new A(new Int32Array(e), n.getTypeInfo("vec3i")) : t === "u32" ? new A(new Uint32Array(e), n.getTypeInfo("vec3u")) : t === "f16" ? new A(new Float32Array(e), n.getTypeInfo("vec3h")) : (console.error(`getSubData: Unknown format ${t}`), null) : i === 4 ? t === "f32" ? new A(new Float32Array(e), n.getTypeInfo("vec4f")) : t === "i32" || t === "bool" ? new A(new Int32Array(e), n.getTypeInfo("vec4i")) : t === "u32" ? new A(new Uint32Array(e), n.getTypeInfo("vec4u")) : t === "f16" ? new A(new Float32Array(e), n.getTypeInfo("vec4h")) : (console.error(`getSubData: Unknown format ${t}`), null) : (console.error(`getSubData: Invalid vector size ${e.length}`), null);
  }
  class A extends mn {
    constructor(e, t, i = null) {
      if (super(t, i), e instanceof Float32Array || e instanceof Uint32Array || e instanceof Int32Array) this.data = e;
      else {
        const s = this.typeInfo.name;
        s === "vec2f" || s === "vec3f" || s === "vec4f" ? this.data = new Float32Array(e) : s === "vec2i" || s === "vec3i" || s === "vec4i" ? this.data = new Int32Array(e) : s === "vec2u" || s === "vec3u" || s === "vec4u" ? this.data = new Uint32Array(e) : s === "vec2h" || s === "vec3h" || s === "vec4h" ? this.data = new Float32Array(e) : s === "vec2b" || s === "vec3b" || s === "vec4b" ? this.data = new Int32Array(e) : s === "vec2" || s === "vec3" || s === "vec4" ? this.data = new Float32Array(e) : console.error(`VectorData: Invalid type ${s}`);
      }
    }
    clone() {
      if (this.data instanceof Float32Array) return new A(new Float32Array(this.data), this.typeInfo, null);
      if (this.data instanceof Int32Array) return new A(new Int32Array(this.data), this.typeInfo, null);
      if (this.data instanceof Uint32Array) return new A(new Uint32Array(this.data), this.typeInfo, null);
      throw "VectorData: Invalid data type";
    }
    setDataValue(e, t, i, s) {
      i instanceof Rs ? console.error("TODO: Set vector postfix") : t instanceof A ? this.data = t.data : console.error("SetDataValue: Invalid value", t);
    }
    getSubData(e, t, i) {
      if (t === null) return this;
      let s = e.getTypeInfo("f32");
      if (this.typeInfo instanceof Es) s = this.typeInfo.format || s;
      else {
        const l = this.typeInfo.name;
        l === "vec2f" || l === "vec3f" || l === "vec4f" ? s = e.getTypeInfo("f32") : l === "vec2i" || l === "vec3i" || l === "vec4i" ? s = e.getTypeInfo("i32") : l === "vec2b" || l === "vec3b" || l === "vec4b" ? s = e.getTypeInfo("bool") : l === "vec2u" || l === "vec3u" || l === "vec4u" ? s = e.getTypeInfo("u32") : l === "vec2h" || l === "vec3h" || l === "vec4h" ? s = e.getTypeInfo("f16") : console.error(`GetSubData: Unknown type ${l}`);
      }
      let a = this;
      for (; t !== null && a !== null; ) {
        if (t instanceof zr) {
          const l = t.index;
          let u = -1;
          if (l instanceof dt) {
            if (!(l.value instanceof I)) return console.error(`GetSubData: Invalid array index ${l.value}`), null;
            u = l.value.value;
          } else {
            const h = e.evalExpression(l, i);
            if (!(h instanceof I)) return console.error("GetSubData: Unknown index type", l), null;
            u = h.value;
          }
          if (u < 0 || u >= a.data.length) return console.error("GetSubData: Index out of range", u), null;
          if (a.data instanceof Float32Array) {
            const h = new Float32Array(a.data.buffer, a.data.byteOffset + 4 * u, 1);
            return new I(h, s);
          }
          if (a.data instanceof Int32Array) {
            const h = new Int32Array(a.data.buffer, a.data.byteOffset + 4 * u, 1);
            return new I(h, s);
          }
          if (a.data instanceof Uint32Array) {
            const h = new Uint32Array(a.data.buffer, a.data.byteOffset + 4 * u, 1);
            return new I(h, s);
          }
          throw "GetSubData: Invalid data type";
        }
        if (!(t instanceof Rs)) return console.error("GetSubData: Unknown postfix", t), null;
        {
          const l = t.value.toLowerCase();
          if (l.length === 1) {
            let h = 0;
            if (l === "x" || l === "r") h = 0;
            else if (l === "y" || l === "g") h = 1;
            else if (l === "z" || l === "b") h = 2;
            else {
              if (l !== "w" && l !== "a") return console.error(`GetSubData: Unknown member ${l}`), null;
              h = 3;
            }
            if (this.data instanceof Float32Array) {
              let d = new Float32Array(this.data.buffer, this.data.byteOffset + 4 * h, 1);
              return new I(d, s, this);
            }
            if (this.data instanceof Int32Array) {
              let d = new Int32Array(this.data.buffer, this.data.byteOffset + 4 * h, 1);
              return new I(d, s, this);
            }
            if (this.data instanceof Uint32Array) {
              let d = new Uint32Array(this.data.buffer, this.data.byteOffset + 4 * h, 1);
              return new I(d, s, this);
            }
          }
          const u = [];
          for (const h of l) h === "x" || h === "r" ? u.push(this.data[0]) : h === "y" || h === "g" ? u.push(this.data[1]) : h === "z" || h === "b" ? u.push(this.data[2]) : h === "w" || h === "a" ? u.push(this.data[3]) : console.error(`GetDataValue: Unknown member ${h}`);
          a = nC(e, u, s.name);
        }
        t = t.postfix;
      }
      return a;
    }
    toString() {
      let e = `${this.data[0]}`;
      for (let t = 1; t < this.data.length; ++t) e += `, ${this.data[t]}`;
      return e;
    }
  }
  class _e extends mn {
    constructor(e, t, i = null) {
      super(t, i), e instanceof Float32Array ? this.data = e : this.data = new Float32Array(e);
    }
    clone() {
      return new _e(new Float32Array(this.data), this.typeInfo, null);
    }
    setDataValue(e, t, i, s) {
      i instanceof Rs ? console.error("TODO: Set matrix postfix") : t instanceof _e ? this.data = t.data : console.error("SetDataValue: Invalid value", t);
    }
    getSubData(e, t, i) {
      if (t === null) return this;
      const s = this.typeInfo.name;
      if (e.getTypeInfo("f32"), this.typeInfo instanceof Es) this.typeInfo.format;
      else if (s.endsWith("f")) e.getTypeInfo("f32");
      else if (s.endsWith("i")) e.getTypeInfo("i32");
      else if (s.endsWith("u")) e.getTypeInfo("u32");
      else {
        if (!s.endsWith("h")) return console.error(`GetDataValue: Unknown type ${s}`), null;
        e.getTypeInfo("f16");
      }
      if (t instanceof zr) {
        const a = t.index;
        let l = -1;
        if (a instanceof dt) {
          if (!(a.value instanceof I)) return console.error(`GetDataValue: Invalid array index ${a.value}`), null;
          l = a.value.value;
        } else {
          const d = e.evalExpression(a, i);
          if (!(d instanceof I)) return console.error("GetDataValue: Unknown index type", a), null;
          l = d.value;
        }
        if (l < 0 || l >= this.data.length) return console.error("GetDataValue: Index out of range", l), null;
        const u = s.endsWith("h") ? "h" : "f";
        let h;
        if (s === "mat2x2" || s === "mat2x2f" || s === "mat2x2h" || s === "mat3x2" || s === "mat3x2f" || s === "mat3x2h" || s === "mat4x2" || s === "mat4x2f" || s === "mat4x2h") h = new A(new Float32Array(this.data.buffer, this.data.byteOffset + 2 * l * 4, 2), e.getTypeInfo(`vec2${u}`));
        else if (s === "mat2x3" || s === "mat2x3f" || s === "mat2x3h" || s === "mat3x3" || s === "mat3x3f" || s === "mat3x3h" || s === "mat4x3" || s === "mat4x3f" || s === "mat4x3h") h = new A(new Float32Array(this.data.buffer, this.data.byteOffset + 3 * l * 4, 3), e.getTypeInfo(`vec3${u}`));
        else {
          if (s !== "mat2x4" && s !== "mat2x4f" && s !== "mat2x4h" && s !== "mat3x4" && s !== "mat3x4f" && s !== "mat3x4h" && s !== "mat4x4" && s !== "mat4x4f" && s !== "mat4x4h") return console.error(`GetDataValue: Unknown type ${s}`), null;
          h = new A(new Float32Array(this.data.buffer, this.data.byteOffset + 4 * l * 4, 4), e.getTypeInfo(`vec4${u}`));
        }
        return t.postfix ? h.getSubData(e, t.postfix, i) : h;
      }
      return console.error("GetDataValue: Invalid postfix", t), null;
    }
    toString() {
      let e = `${this.data[0]}`;
      for (let t = 1; t < this.data.length; ++t) e += `, ${this.data[t]}`;
      return e;
    }
  }
  class it extends mn {
    constructor(e, t, i = 0, s = null) {
      super(t, s), this.buffer = e instanceof ArrayBuffer ? e : e.buffer, this.offset = i;
    }
    clone() {
      const e = new Uint8Array(new Uint8Array(this.buffer, this.offset, this.typeInfo.size));
      return new it(e.buffer, this.typeInfo, 0, null);
    }
    setDataValue(e, t, i, s) {
      if (t === null) return void console.log("setDataValue: NULL data.");
      let a = this.offset, l = this.typeInfo;
      for (; i; ) {
        if (i instanceof zr) if (l instanceof $i) {
          const u = i.index;
          if (u instanceof dt) {
            if (!(u.value instanceof I)) return void console.error(`SetDataValue: Invalid index type ${u.value}`);
            a += u.value.value * l.stride;
          } else {
            const h = e.evalExpression(u, s);
            if (!(h instanceof I)) return void console.error("SetDataValue: Unknown index type", u);
            a += h.value * l.stride;
          }
          l = l.format;
        } else console.error(`SetDataValue: Type ${l.getTypeName()} is not an array`);
        else {
          if (!(i instanceof Rs)) return void console.error("SetDataValue: Unknown postfix type", i);
          {
            const u = i.value;
            if (l instanceof zi) {
              let h = false;
              for (const d of l.members) if (d.name === u) {
                a += d.offset, l = d.type, h = true;
                break;
              }
              if (!h) return void console.error(`SetDataValue: Member ${u} not found`);
            } else if (l instanceof dn) {
              const h = l.getTypeName();
              let d = 0;
              if (u === "x" || u === "r") d = 0;
              else if (u === "y" || u === "g") d = 1;
              else if (u === "z" || u === "b") d = 2;
              else {
                if (u !== "w" && u !== "a") return void console.error(`SetDataValue: Unknown member ${u}`);
                d = 3;
              }
              if (!(t instanceof I)) return void console.error("SetDataValue: Invalid value", t);
              const p = t.value;
              return h === "vec2f" ? void (new Float32Array(this.buffer, a, 2)[d] = p) : h === "vec3f" ? void (new Float32Array(this.buffer, a, 3)[d] = p) : h === "vec4f" ? void (new Float32Array(this.buffer, a, 4)[d] = p) : h === "vec2i" ? void (new Int32Array(this.buffer, a, 2)[d] = p) : h === "vec3i" ? void (new Int32Array(this.buffer, a, 3)[d] = p) : h === "vec4i" ? void (new Int32Array(this.buffer, a, 4)[d] = p) : h === "vec2u" ? void (new Uint32Array(this.buffer, a, 2)[d] = p) : h === "vec3u" ? void (new Uint32Array(this.buffer, a, 3)[d] = p) : h === "vec4u" ? void (new Uint32Array(this.buffer, a, 4)[d] = p) : void console.error(`SetDataValue: Type ${h} is not a struct`);
            }
          }
        }
        i = i.postfix;
      }
      this.setData(e, t, l, a, s);
    }
    setData(e, t, i, s, a) {
      const l = i.getTypeName();
      if (l !== "f32" && l !== "f16") if (l !== "i32" && l !== "atomic<i32>" && l !== "x32") if (l !== "u32" && l !== "atomic<u32>") if (l !== "bool") if (l !== "vec2f" && l !== "vec2h") if (l !== "vec3f" && l !== "vec3h") if (l !== "vec4f" && l !== "vec4h") if (l !== "vec2i") if (l !== "vec3i") if (l !== "vec4i") if (l !== "vec2u") if (l !== "vec3u") if (l !== "vec4u") if (l !== "vec2b") if (l !== "vec3b") if (l !== "vec4b") if (l !== "mat2x2f" && l !== "mat2x2h") if (l !== "mat2x3f" && l !== "mat2x3h") if (l !== "mat2x4f" && l !== "mat2x4h") if (l !== "mat3x2f" && l !== "mat3x2h") if (l !== "mat3x3f" && l !== "mat3x3h") if (l !== "mat3x4f" && l !== "mat3x4h") if (l !== "mat4x2f" && l !== "mat4x2h") if (l !== "mat4x3f" && l !== "mat4x3h") if (l !== "mat4x4f" && l !== "mat4x4h") if (t instanceof it) {
        if (i === t.typeInfo) return void new Uint8Array(this.buffer, s, t.buffer.byteLength).set(new Uint8Array(t.buffer));
        console.error("SetDataValue: Type mismatch", l, t.typeInfo.getTypeName());
      } else console.error(`SetData: Unknown type ${l}`);
      else {
        const u = new Float32Array(this.buffer, s, 16);
        t instanceof _e ? (u[0] = t.data[0], u[1] = t.data[1], u[2] = t.data[2], u[3] = t.data[3], u[4] = t.data[4], u[5] = t.data[5], u[6] = t.data[6], u[7] = t.data[7], u[8] = t.data[8], u[9] = t.data[9], u[10] = t.data[10], u[11] = t.data[11], u[12] = t.data[12], u[13] = t.data[13], u[14] = t.data[14], u[15] = t.data[15]) : (u[0] = t[0], u[1] = t[1], u[2] = t[2], u[3] = t[3], u[4] = t[4], u[5] = t[5], u[6] = t[6], u[7] = t[7], u[8] = t[8], u[9] = t[9], u[10] = t[10], u[11] = t[11], u[12] = t[12], u[13] = t[13], u[14] = t[14], u[15] = t[15]);
      }
      else {
        const u = new Float32Array(this.buffer, s, 12);
        t instanceof _e ? (u[0] = t.data[0], u[1] = t.data[1], u[2] = t.data[2], u[3] = t.data[3], u[4] = t.data[4], u[5] = t.data[5], u[6] = t.data[6], u[7] = t.data[7], u[8] = t.data[8], u[9] = t.data[9], u[10] = t.data[10], u[11] = t.data[11]) : (u[0] = t[0], u[1] = t[1], u[2] = t[2], u[3] = t[3], u[4] = t[4], u[5] = t[5], u[6] = t[6], u[7] = t[7], u[8] = t[8], u[9] = t[9], u[10] = t[10], u[11] = t[11]);
      }
      else {
        const u = new Float32Array(this.buffer, s, 8);
        t instanceof _e ? (u[0] = t.data[0], u[1] = t.data[1], u[2] = t.data[2], u[3] = t.data[3], u[4] = t.data[4], u[5] = t.data[5], u[6] = t.data[6], u[7] = t.data[7]) : (u[0] = t[0], u[1] = t[1], u[2] = t[2], u[3] = t[3], u[4] = t[4], u[5] = t[5], u[6] = t[6], u[7] = t[7]);
      }
      else {
        const u = new Float32Array(this.buffer, s, 12);
        t instanceof _e ? (u[0] = t.data[0], u[1] = t.data[1], u[2] = t.data[2], u[3] = t.data[3], u[4] = t.data[4], u[5] = t.data[5], u[6] = t.data[6], u[7] = t.data[7], u[8] = t.data[8], u[9] = t.data[9], u[10] = t.data[10], u[11] = t.data[11]) : (u[0] = t[0], u[1] = t[1], u[2] = t[2], u[3] = t[3], u[4] = t[4], u[5] = t[5], u[6] = t[6], u[7] = t[7], u[8] = t[8], u[9] = t[9], u[10] = t[10], u[11] = t[11]);
      }
      else {
        const u = new Float32Array(this.buffer, s, 9);
        t instanceof _e ? (u[0] = t.data[0], u[1] = t.data[1], u[2] = t.data[2], u[3] = t.data[3], u[4] = t.data[4], u[5] = t.data[5], u[6] = t.data[6], u[7] = t.data[7], u[8] = t.data[8]) : (u[0] = t[0], u[1] = t[1], u[2] = t[2], u[3] = t[3], u[4] = t[4], u[5] = t[5], u[6] = t[6], u[7] = t[7], u[8] = t[8]);
      }
      else {
        const u = new Float32Array(this.buffer, s, 6);
        t instanceof _e ? (u[0] = t.data[0], u[1] = t.data[1], u[2] = t.data[2], u[3] = t.data[3], u[4] = t.data[4], u[5] = t.data[5]) : (u[0] = t[0], u[1] = t[1], u[2] = t[2], u[3] = t[3], u[4] = t[4], u[5] = t[5]);
      }
      else {
        const u = new Float32Array(this.buffer, s, 8);
        t instanceof _e ? (u[0] = t.data[0], u[1] = t.data[1], u[2] = t.data[2], u[3] = t.data[3], u[4] = t.data[4], u[5] = t.data[5], u[6] = t.data[6], u[7] = t.data[7]) : (u[0] = t[0], u[1] = t[1], u[2] = t[2], u[3] = t[3], u[4] = t[4], u[5] = t[5], u[6] = t[6], u[7] = t[7]);
      }
      else {
        const u = new Float32Array(this.buffer, s, 6);
        t instanceof _e ? (u[0] = t.data[0], u[1] = t.data[1], u[2] = t.data[2], u[3] = t.data[3], u[4] = t.data[4], u[5] = t.data[5]) : (u[0] = t[0], u[1] = t[1], u[2] = t[2], u[3] = t[3], u[4] = t[4], u[5] = t[5]);
      }
      else {
        const u = new Float32Array(this.buffer, s, 4);
        t instanceof _e ? (u[0] = t.data[0], u[1] = t.data[1], u[2] = t.data[2], u[3] = t.data[3]) : (u[0] = t[0], u[1] = t[1], u[2] = t[2], u[3] = t[3]);
      }
      else {
        const u = new Uint32Array(this.buffer, s, 4);
        t instanceof A ? (u[0] = t.data[0], u[1] = t.data[1], u[2] = t.data[2], u[3] = t.data[3]) : (u[0] = t[0], u[1] = t[1], u[2] = t[2], u[3] = t[3]);
      }
      else {
        const u = new Uint32Array(this.buffer, s, 3);
        t instanceof A ? (u[0] = t.data[0], u[1] = t.data[1], u[2] = t.data[2]) : (u[0] = t[0], u[1] = t[1], u[2] = t[2]);
      }
      else {
        const u = new Uint32Array(this.buffer, s, 2);
        t instanceof A ? (u[0] = t.data[0], u[1] = t.data[1]) : (u[0] = t[0], u[1] = t[1]);
      }
      else {
        const u = new Uint32Array(this.buffer, s, 4);
        t instanceof A ? (u[0] = t.data[0], u[1] = t.data[1], u[2] = t.data[2], u[3] = t.data[3]) : (u[0] = t[0], u[1] = t[1], u[2] = t[2], u[3] = t[3]);
      }
      else {
        const u = new Uint32Array(this.buffer, s, 3);
        t instanceof A ? (u[0] = t.data[0], u[1] = t.data[1], u[2] = t.data[2]) : (u[0] = t[0], u[1] = t[1], u[2] = t[2]);
      }
      else {
        const u = new Uint32Array(this.buffer, s, 2);
        t instanceof A ? (u[0] = t.data[0], u[1] = t.data[1]) : (u[0] = t[0], u[1] = t[1]);
      }
      else {
        const u = new Int32Array(this.buffer, s, 4);
        t instanceof A ? (u[0] = t.data[0], u[1] = t.data[1], u[2] = t.data[2], u[3] = t.data[3]) : (u[0] = t[0], u[1] = t[1], u[2] = t[2], u[3] = t[3]);
      }
      else {
        const u = new Int32Array(this.buffer, s, 3);
        t instanceof A ? (u[0] = t.data[0], u[1] = t.data[1], u[2] = t.data[2]) : (u[0] = t[0], u[1] = t[1], u[2] = t[2]);
      }
      else {
        const u = new Int32Array(this.buffer, s, 2);
        t instanceof A ? (u[0] = t.data[0], u[1] = t.data[1]) : (u[0] = t[0], u[1] = t[1]);
      }
      else {
        const u = new Float32Array(this.buffer, s, 4);
        t instanceof A ? (u[0] = t.data[0], u[1] = t.data[1], u[2] = t.data[2], u[3] = t.data[3]) : (u[0] = t[0], u[1] = t[1], u[2] = t[2], u[3] = t[3]);
      }
      else {
        const u = new Float32Array(this.buffer, s, 3);
        t instanceof A ? (u[0] = t.data[0], u[1] = t.data[1], u[2] = t.data[2]) : (u[0] = t[0], u[1] = t[1], u[2] = t[2]);
      }
      else {
        const u = new Float32Array(this.buffer, s, 2);
        t instanceof A ? (u[0] = t.data[0], u[1] = t.data[1]) : (u[0] = t[0], u[1] = t[1]);
      }
      else t instanceof I && (new Int32Array(this.buffer, s, 1)[0] = t.value);
      else t instanceof I && (new Uint32Array(this.buffer, s, 1)[0] = t.value);
      else t instanceof I && (new Int32Array(this.buffer, s, 1)[0] = t.value);
      else t instanceof I && (new Float32Array(this.buffer, s, 1)[0] = t.value);
    }
    getSubData(e, t, i) {
      var s, a, l;
      if (t === null) return this;
      let u = this.offset, h = this.typeInfo;
      for (; t; ) {
        if (t instanceof zr) {
          const p = t.index, _ = e.evalExpression(p, i);
          let y = 0;
          if (_ instanceof I ? y = _.value : console.error("GetDataValue: Invalid index type", p), h instanceof $i) u += y * h.stride, h = h.format;
          else {
            const v = h.getTypeName();
            v === "mat4x4" || v === "mat4x4f" || v === "mat4x4h" ? (u += 16 * y, h = e.getTypeInfo("vec4f")) : console.error(`getDataValue: Type ${h.getTypeName()} is not an array`);
          }
        } else {
          if (!(t instanceof Rs)) return console.error("GetDataValue: Unknown postfix type", t), null;
          {
            const p = t.value;
            if (h instanceof zi) {
              let _ = false;
              for (const y of h.members) if (y.name === p) {
                u += y.offset, h = y.type, _ = true;
                break;
              }
              if (!_) return console.error(`GetDataValue: Member ${p} not found`), null;
            } else if (h instanceof dn) {
              const _ = h.getTypeName();
              if (_ === "vec2f" || _ === "vec3f" || _ === "vec4f" || _ === "vec2i" || _ === "vec3i" || _ === "vec4i" || _ === "vec2u" || _ === "vec3u" || _ === "vec4u" || _ === "vec2b" || _ === "vec3b" || _ === "vec4b" || _ === "vec2h" || _ === "vec3h" || _ === "vec4h" || _ === "vec2" || _ === "vec3" || _ === "vec4") {
                if (p.length > 0 && p.length < 5) {
                  let y = "f";
                  const v = [];
                  for (let S = 0; S < p.length; ++S) {
                    const E = p[S].toLowerCase();
                    let M = 0;
                    if (E === "x" || E === "r") M = 0;
                    else if (E === "y" || E === "g") M = 1;
                    else if (E === "z" || E === "b") M = 2;
                    else {
                      if (E !== "w" && E !== "a") return console.error(`Unknown member ${p}`), null;
                      M = 3;
                    }
                    if (p.length === 1) {
                      if (_.endsWith("f")) return this.buffer.byteLength < u + 4 * M + 4 ? (console.log("Insufficient buffer data"), null) : new I(new Float32Array(this.buffer, u + 4 * M, 1), e.getTypeInfo("f32"), this);
                      if (_.endsWith("h")) return new I(new Float32Array(this.buffer, u + 4 * M, 1), e.getTypeInfo("f16"), this);
                      if (_.endsWith("i")) return new I(new Int32Array(this.buffer, u + 4 * M, 1), e.getTypeInfo("i32"), this);
                      if (_.endsWith("b")) return new I(new Int32Array(this.buffer, u + 4 * M, 1), e.getTypeInfo("bool"), this);
                      if (_.endsWith("u")) return new I(new Uint32Array(this.buffer, u + 4 * M, 1), e.getTypeInfo("i32"), this);
                    }
                    if (_ === "vec2f") v.push(new Float32Array(this.buffer, u, 2)[M]);
                    else if (_ === "vec3f") {
                      if (u + 12 >= this.buffer.byteLength) return console.log("Insufficient buffer data"), null;
                      const F = new Float32Array(this.buffer, u, 3);
                      v.push(F[M]);
                    } else if (_ === "vec4f") v.push(new Float32Array(this.buffer, u, 4)[M]);
                    else if (_ === "vec2i") y = "i", v.push(new Int32Array(this.buffer, u, 2)[M]);
                    else if (_ === "vec3i") y = "i", v.push(new Int32Array(this.buffer, u, 3)[M]);
                    else if (_ === "vec4i") y = "i", v.push(new Int32Array(this.buffer, u, 4)[M]);
                    else if (_ === "vec2u") {
                      y = "u";
                      const F = new Uint32Array(this.buffer, u, 2);
                      v.push(F[M]);
                    } else _ === "vec3u" ? (y = "u", v.push(new Uint32Array(this.buffer, u, 3)[M])) : _ === "vec4u" && (y = "u", v.push(new Uint32Array(this.buffer, u, 4)[M]));
                  }
                  return v.length === 2 ? h = e.getTypeInfo(`vec2${y}`) : v.length === 3 ? h = e.getTypeInfo(`vec3${y}`) : v.length === 4 ? h = e.getTypeInfo(`vec4${y}`) : console.error(`GetDataValue: Invalid vector length ${v.length}`), new A(v, h, null);
                }
                return console.error(`GetDataValue: Unknown member ${p}`), null;
              }
              return console.error(`GetDataValue: Type ${_} is not a struct`), null;
            }
          }
        }
        t = t.postfix;
      }
      const d = h.getTypeName();
      return d === "f32" ? new I(new Float32Array(this.buffer, u, 1), h, this) : d === "i32" ? new I(new Int32Array(this.buffer, u, 1), h, this) : d === "u32" ? new I(new Uint32Array(this.buffer, u, 1), h, this) : d === "vec2f" ? new A(new Float32Array(this.buffer, u, 2), h, this) : d === "vec3f" ? new A(new Float32Array(this.buffer, u, 3), h, this) : d === "vec4f" ? new A(new Float32Array(this.buffer, u, 4), h, this) : d === "vec2i" ? new A(new Int32Array(this.buffer, u, 2), h, this) : d === "vec3i" ? new A(new Int32Array(this.buffer, u, 3), h, this) : d === "vec4i" ? new A(new Int32Array(this.buffer, u, 4), h, this) : d === "vec2u" ? new A(new Uint32Array(this.buffer, u, 2), h, this) : d === "vec3u" ? new A(new Uint32Array(this.buffer, u, 3), h, this) : d === "vec4u" ? new A(new Uint32Array(this.buffer, u, 4), h, this) : h instanceof Es && h.name === "atomic" ? ((s = h.format) === null || s === void 0 ? void 0 : s.name) === "u32" ? new I(new Uint32Array(this.buffer, u, 1)[0], h.format, this) : ((a = h.format) === null || a === void 0 ? void 0 : a.name) === "i32" ? new I(new Int32Array(this.buffer, u, 1)[0], h.format, this) : (console.error(`GetDataValue: Invalid atomic format ${(l = h.format) === null || l === void 0 ? void 0 : l.name}`), null) : new it(this.buffer, h, u, this);
    }
    toString() {
      let e = "";
      if (this.typeInfo instanceof $i) if (this.typeInfo.format.name === "f32") {
        const t = new Float32Array(this.buffer, this.offset);
        e = `[${t[0]}`;
        for (let i = 1; i < t.length; ++i) e += `, ${t[i]}`;
      } else if (this.typeInfo.format.name === "i32") {
        const t = new Int32Array(this.buffer, this.offset);
        e = `[${t[0]}`;
        for (let i = 1; i < t.length; ++i) e += `, ${t[i]}`;
      } else if (this.typeInfo.format.name === "u32") {
        const t = new Uint32Array(this.buffer, this.offset);
        e = `[${t[0]}`;
        for (let i = 1; i < t.length; ++i) e += `, ${t[i]}`;
      } else if (this.typeInfo.format.name === "vec2f") {
        const t = new Float32Array(this.buffer, this.offset);
        e = `[${t[0]}, ${t[1]}]`;
        for (let i = 1; i < t.length / 2; ++i) e += `, [${t[2 * i]}, ${t[2 * i + 1]}]`;
      } else if (this.typeInfo.format.name === "vec3f") {
        const t = new Float32Array(this.buffer, this.offset);
        e = `[${t[0]}, ${t[1]}, ${t[2]}]`;
        for (let i = 4; i < t.length; i += 4) e += `, [${t[i]}, ${t[i + 1]}, ${t[i + 2]}]`;
      } else if (this.typeInfo.format.name === "vec4f") {
        const t = new Float32Array(this.buffer, this.offset);
        e = `[${t[0]}, ${t[1]}, ${t[2]}, ${t[3]}]`;
        for (let i = 4; i < t.length; i += 4) e += `, [${t[i]}, ${t[i + 1]}, ${t[i + 2]}, ${t[i + 3]}]`;
      } else e = "[...]";
      else this.typeInfo instanceof zi ? e += "{...}" : e = "[...]";
      return e;
    }
  }
  class ri extends mn {
    constructor(e, t, i, s) {
      super(t, null), this.data = e, this.descriptor = i, this.view = s;
    }
    clone() {
      return new ri(this.data, this.typeInfo, this.descriptor, this.view);
    }
    get width() {
      var e, t;
      const i = this.descriptor.size;
      return i instanceof Array && i.length > 0 ? (e = i[0]) !== null && e !== void 0 ? e : 0 : i instanceof Object && (t = i.width) !== null && t !== void 0 ? t : 0;
    }
    get height() {
      var e, t;
      const i = this.descriptor.size;
      return i instanceof Array && i.length > 1 ? (e = i[1]) !== null && e !== void 0 ? e : 0 : i instanceof Object && (t = i.height) !== null && t !== void 0 ? t : 0;
    }
    get depthOrArrayLayers() {
      var e, t;
      const i = this.descriptor.size;
      return i instanceof Array && i.length > 2 ? (e = i[2]) !== null && e !== void 0 ? e : 0 : i instanceof Object && (t = i.depthOrArrayLayers) !== null && t !== void 0 ? t : 0;
    }
    get format() {
      var e;
      return this.descriptor && (e = this.descriptor.format) !== null && e !== void 0 ? e : "rgba8unorm";
    }
    get sampleCount() {
      var e;
      return this.descriptor && (e = this.descriptor.sampleCount) !== null && e !== void 0 ? e : 1;
    }
    get mipLevelCount() {
      var e;
      return this.descriptor && (e = this.descriptor.mipLevelCount) !== null && e !== void 0 ? e : 1;
    }
    get dimension() {
      var e;
      return this.descriptor && (e = this.descriptor.dimension) !== null && e !== void 0 ? e : "2d";
    }
    getMipLevelSize(e) {
      if (e >= this.mipLevelCount) return [
        0,
        0,
        0
      ];
      const t = [
        this.width,
        this.height,
        this.depthOrArrayLayers
      ];
      for (let i = 0; i < t.length; ++i) t[i] = Math.max(1, t[i] >> e);
      return t;
    }
    get texelByteSize() {
      const e = this.format, t = Lh[e];
      return t ? t.isDepthStencil ? 4 : t.bytesPerBlock : 0;
    }
    get bytesPerRow() {
      return this.width * this.texelByteSize;
    }
    get isDepthStencil() {
      const e = this.format, t = Lh[e];
      return !!t && t.isDepthStencil;
    }
    getGpuSize() {
      const e = this.format, t = Lh[e], i = this.width;
      if (!e || i <= 0 || !t) return -1;
      const s = this.height, a = this.depthOrArrayLayers, l = this.dimension;
      return i / t.blockWidth * (l === "1d" ? 1 : s / t.blockHeight) * t.bytesPerBlock * a;
    }
    getPixel(e, t, i = 0, s = 0) {
      const a = this.texelByteSize, l = this.bytesPerRow, u = this.height, h = this.data[s];
      return ZR(new Uint8Array(h), e, t, i, s, u, l, a, this.format);
    }
    setPixel(e, t, i, s, a) {
      const l = this.texelByteSize, u = this.bytesPerRow, h = this.height, d = this.data[s];
      (function(p, _, y, v, S, E, M, F, H, O) {
        const U = v * (M >>= S) * (E >>= S) + y * M + _ * F;
        switch (H) {
          case "r8unorm":
            return void Be(p, U, "8unorm", 1, O);
          case "r8snorm":
            return void Be(p, U, "8snorm", 1, O);
          case "r8uint":
            return void Be(p, U, "8uint", 1, O);
          case "r8sint":
            return void Be(p, U, "8sint", 1, O);
          case "rg8unorm":
            return void Be(p, U, "8unorm", 2, O);
          case "rg8snorm":
            return void Be(p, U, "8snorm", 2, O);
          case "rg8uint":
            return void Be(p, U, "8uint", 2, O);
          case "rg8sint":
            return void Be(p, U, "8sint", 2, O);
          case "rgba8unorm-srgb":
          case "rgba8unorm":
          case "bgra8unorm-srgb":
          case "bgra8unorm":
            return void Be(p, U, "8unorm", 4, O);
          case "rgba8snorm":
            return void Be(p, U, "8snorm", 4, O);
          case "rgba8uint":
            return void Be(p, U, "8uint", 4, O);
          case "rgba8sint":
            return void Be(p, U, "8sint", 4, O);
          case "r16uint":
            return void Be(p, U, "16uint", 1, O);
          case "r16sint":
            return void Be(p, U, "16sint", 1, O);
          case "r16float":
            return void Be(p, U, "16float", 1, O);
          case "rg16uint":
            return void Be(p, U, "16uint", 2, O);
          case "rg16sint":
            return void Be(p, U, "16sint", 2, O);
          case "rg16float":
            return void Be(p, U, "16float", 2, O);
          case "rgba16uint":
            return void Be(p, U, "16uint", 4, O);
          case "rgba16sint":
            return void Be(p, U, "16sint", 4, O);
          case "rgba16float":
            return void Be(p, U, "16float", 4, O);
          case "r32uint":
            return void Be(p, U, "32uint", 1, O);
          case "r32sint":
            return void Be(p, U, "32sint", 1, O);
          case "depth16unorm":
          case "depth24plus":
          case "depth24plus-stencil8":
          case "depth32float":
          case "depth32float-stencil8":
          case "r32float":
            return void Be(p, U, "32float", 1, O);
          case "rg32uint":
            return void Be(p, U, "32uint", 2, O);
          case "rg32sint":
            return void Be(p, U, "32sint", 2, O);
          case "rg32float":
            return void Be(p, U, "32float", 2, O);
          case "rgba32uint":
            return void Be(p, U, "32uint", 4, O);
          case "rgba32sint":
            return void Be(p, U, "32sint", 4, O);
          case "rgba32float":
            return void Be(p, U, "32float", 4, O);
          case "rg11b10ufloat":
            console.error("TODO: rg11b10ufloat not supported for writing");
        }
      })(new Uint8Array(d), e, t, i, s, h, u, l, this.format, a);
    }
  }
  ((n) => {
    n[n.token = 0] = "token", n[n.keyword = 1] = "keyword", n[n.reserved = 2] = "reserved";
  })(N || (N = {}));
  class P {
    constructor(e, t, i) {
      this.name = e, this.type = t, this.rule = i;
    }
    toString() {
      return this.name;
    }
  }
  class x {
  }
  L = x, x.none = new P("", N.reserved, ""), x.eof = new P("EOF", N.token, ""), x.reserved = {
    asm: new P("asm", N.reserved, "asm"),
    bf16: new P("bf16", N.reserved, "bf16"),
    do: new P("do", N.reserved, "do"),
    enum: new P("enum", N.reserved, "enum"),
    f16: new P("f16", N.reserved, "f16"),
    f64: new P("f64", N.reserved, "f64"),
    handle: new P("handle", N.reserved, "handle"),
    i8: new P("i8", N.reserved, "i8"),
    i16: new P("i16", N.reserved, "i16"),
    i64: new P("i64", N.reserved, "i64"),
    mat: new P("mat", N.reserved, "mat"),
    premerge: new P("premerge", N.reserved, "premerge"),
    regardless: new P("regardless", N.reserved, "regardless"),
    typedef: new P("typedef", N.reserved, "typedef"),
    u8: new P("u8", N.reserved, "u8"),
    u16: new P("u16", N.reserved, "u16"),
    u64: new P("u64", N.reserved, "u64"),
    unless: new P("unless", N.reserved, "unless"),
    using: new P("using", N.reserved, "using"),
    vec: new P("vec", N.reserved, "vec"),
    void: new P("void", N.reserved, "void")
  }, x.keywords = {
    array: new P("array", N.keyword, "array"),
    atomic: new P("atomic", N.keyword, "atomic"),
    bool: new P("bool", N.keyword, "bool"),
    f32: new P("f32", N.keyword, "f32"),
    i32: new P("i32", N.keyword, "i32"),
    mat2x2: new P("mat2x2", N.keyword, "mat2x2"),
    mat2x3: new P("mat2x3", N.keyword, "mat2x3"),
    mat2x4: new P("mat2x4", N.keyword, "mat2x4"),
    mat3x2: new P("mat3x2", N.keyword, "mat3x2"),
    mat3x3: new P("mat3x3", N.keyword, "mat3x3"),
    mat3x4: new P("mat3x4", N.keyword, "mat3x4"),
    mat4x2: new P("mat4x2", N.keyword, "mat4x2"),
    mat4x3: new P("mat4x3", N.keyword, "mat4x3"),
    mat4x4: new P("mat4x4", N.keyword, "mat4x4"),
    ptr: new P("ptr", N.keyword, "ptr"),
    sampler: new P("sampler", N.keyword, "sampler"),
    sampler_comparison: new P("sampler_comparison", N.keyword, "sampler_comparison"),
    struct: new P("struct", N.keyword, "struct"),
    texture_1d: new P("texture_1d", N.keyword, "texture_1d"),
    texture_2d: new P("texture_2d", N.keyword, "texture_2d"),
    texture_2d_array: new P("texture_2d_array", N.keyword, "texture_2d_array"),
    texture_3d: new P("texture_3d", N.keyword, "texture_3d"),
    texture_cube: new P("texture_cube", N.keyword, "texture_cube"),
    texture_cube_array: new P("texture_cube_array", N.keyword, "texture_cube_array"),
    texture_multisampled_2d: new P("texture_multisampled_2d", N.keyword, "texture_multisampled_2d"),
    texture_storage_1d: new P("texture_storage_1d", N.keyword, "texture_storage_1d"),
    texture_storage_2d: new P("texture_storage_2d", N.keyword, "texture_storage_2d"),
    texture_storage_2d_array: new P("texture_storage_2d_array", N.keyword, "texture_storage_2d_array"),
    texture_storage_3d: new P("texture_storage_3d", N.keyword, "texture_storage_3d"),
    texture_depth_2d: new P("texture_depth_2d", N.keyword, "texture_depth_2d"),
    texture_depth_2d_array: new P("texture_depth_2d_array", N.keyword, "texture_depth_2d_array"),
    texture_depth_cube: new P("texture_depth_cube", N.keyword, "texture_depth_cube"),
    texture_depth_cube_array: new P("texture_depth_cube_array", N.keyword, "texture_depth_cube_array"),
    texture_depth_multisampled_2d: new P("texture_depth_multisampled_2d", N.keyword, "texture_depth_multisampled_2d"),
    texture_external: new P("texture_external", N.keyword, "texture_external"),
    u32: new P("u32", N.keyword, "u32"),
    vec2: new P("vec2", N.keyword, "vec2"),
    vec3: new P("vec3", N.keyword, "vec3"),
    vec4: new P("vec4", N.keyword, "vec4"),
    bitcast: new P("bitcast", N.keyword, "bitcast"),
    block: new P("block", N.keyword, "block"),
    break: new P("break", N.keyword, "break"),
    case: new P("case", N.keyword, "case"),
    continue: new P("continue", N.keyword, "continue"),
    continuing: new P("continuing", N.keyword, "continuing"),
    default: new P("default", N.keyword, "default"),
    diagnostic: new P("diagnostic", N.keyword, "diagnostic"),
    discard: new P("discard", N.keyword, "discard"),
    else: new P("else", N.keyword, "else"),
    enable: new P("enable", N.keyword, "enable"),
    fallthrough: new P("fallthrough", N.keyword, "fallthrough"),
    false: new P("false", N.keyword, "false"),
    fn: new P("fn", N.keyword, "fn"),
    for: new P("for", N.keyword, "for"),
    function: new P("function", N.keyword, "function"),
    if: new P("if", N.keyword, "if"),
    let: new P("let", N.keyword, "let"),
    const: new P("const", N.keyword, "const"),
    loop: new P("loop", N.keyword, "loop"),
    while: new P("while", N.keyword, "while"),
    private: new P("private", N.keyword, "private"),
    read: new P("read", N.keyword, "read"),
    read_write: new P("read_write", N.keyword, "read_write"),
    return: new P("return", N.keyword, "return"),
    requires: new P("requires", N.keyword, "requires"),
    storage: new P("storage", N.keyword, "storage"),
    switch: new P("switch", N.keyword, "switch"),
    true: new P("true", N.keyword, "true"),
    alias: new P("alias", N.keyword, "alias"),
    type: new P("type", N.keyword, "type"),
    uniform: new P("uniform", N.keyword, "uniform"),
    var: new P("var", N.keyword, "var"),
    override: new P("override", N.keyword, "override"),
    workgroup: new P("workgroup", N.keyword, "workgroup"),
    write: new P("write", N.keyword, "write"),
    r8unorm: new P("r8unorm", N.keyword, "r8unorm"),
    r8snorm: new P("r8snorm", N.keyword, "r8snorm"),
    r8uint: new P("r8uint", N.keyword, "r8uint"),
    r8sint: new P("r8sint", N.keyword, "r8sint"),
    r16uint: new P("r16uint", N.keyword, "r16uint"),
    r16sint: new P("r16sint", N.keyword, "r16sint"),
    r16float: new P("r16float", N.keyword, "r16float"),
    rg8unorm: new P("rg8unorm", N.keyword, "rg8unorm"),
    rg8snorm: new P("rg8snorm", N.keyword, "rg8snorm"),
    rg8uint: new P("rg8uint", N.keyword, "rg8uint"),
    rg8sint: new P("rg8sint", N.keyword, "rg8sint"),
    r32uint: new P("r32uint", N.keyword, "r32uint"),
    r32sint: new P("r32sint", N.keyword, "r32sint"),
    r32float: new P("r32float", N.keyword, "r32float"),
    rg16uint: new P("rg16uint", N.keyword, "rg16uint"),
    rg16sint: new P("rg16sint", N.keyword, "rg16sint"),
    rg16float: new P("rg16float", N.keyword, "rg16float"),
    rgba8unorm: new P("rgba8unorm", N.keyword, "rgba8unorm"),
    rgba8unorm_srgb: new P("rgba8unorm_srgb", N.keyword, "rgba8unorm_srgb"),
    rgba8snorm: new P("rgba8snorm", N.keyword, "rgba8snorm"),
    rgba8uint: new P("rgba8uint", N.keyword, "rgba8uint"),
    rgba8sint: new P("rgba8sint", N.keyword, "rgba8sint"),
    bgra8unorm: new P("bgra8unorm", N.keyword, "bgra8unorm"),
    bgra8unorm_srgb: new P("bgra8unorm_srgb", N.keyword, "bgra8unorm_srgb"),
    rgb10a2unorm: new P("rgb10a2unorm", N.keyword, "rgb10a2unorm"),
    rg11b10float: new P("rg11b10float", N.keyword, "rg11b10float"),
    rg32uint: new P("rg32uint", N.keyword, "rg32uint"),
    rg32sint: new P("rg32sint", N.keyword, "rg32sint"),
    rg32float: new P("rg32float", N.keyword, "rg32float"),
    rgba16uint: new P("rgba16uint", N.keyword, "rgba16uint"),
    rgba16sint: new P("rgba16sint", N.keyword, "rgba16sint"),
    rgba16float: new P("rgba16float", N.keyword, "rgba16float"),
    rgba32uint: new P("rgba32uint", N.keyword, "rgba32uint"),
    rgba32sint: new P("rgba32sint", N.keyword, "rgba32sint"),
    rgba32float: new P("rgba32float", N.keyword, "rgba32float"),
    static_assert: new P("static_assert", N.keyword, "static_assert")
  }, x.tokens = {
    decimal_float_literal: new P("decimal_float_literal", N.token, /((-?[0-9]*\.[0-9]+|-?[0-9]+\.[0-9]*)((e|E)(\+|-)?[0-9]+)?[fh]?)|(-?[0-9]+(e|E)(\+|-)?[0-9]+[fh]?)|(-?[0-9]+[fh])/),
    hex_float_literal: new P("hex_float_literal", N.token, /-?0x((([0-9a-fA-F]*\.[0-9a-fA-F]+|[0-9a-fA-F]+\.[0-9a-fA-F]*)((p|P)(\+|-)?[0-9]+[fh]?)?)|([0-9a-fA-F]+(p|P)(\+|-)?[0-9]+[fh]?))/),
    int_literal: new P("int_literal", N.token, /-?0x[0-9a-fA-F]+|0i?|-?[1-9][0-9]*i?/),
    uint_literal: new P("uint_literal", N.token, /0x[0-9a-fA-F]+u|0u|[1-9][0-9]*u/),
    name: new P("name", N.token, /([_\p{XID_Start}][\p{XID_Continue}]+)|([\p{XID_Start}])/u),
    ident: new P("ident", N.token, /[_a-zA-Z][0-9a-zA-Z_]*/),
    and: new P("and", N.token, "&"),
    and_and: new P("and_and", N.token, "&&"),
    arrow: new P("arrow ", N.token, "->"),
    attr: new P("attr", N.token, "@"),
    forward_slash: new P("forward_slash", N.token, "/"),
    bang: new P("bang", N.token, "!"),
    bracket_left: new P("bracket_left", N.token, "["),
    bracket_right: new P("bracket_right", N.token, "]"),
    brace_left: new P("brace_left", N.token, "{"),
    brace_right: new P("brace_right", N.token, "}"),
    colon: new P("colon", N.token, ":"),
    comma: new P("comma", N.token, ","),
    equal: new P("equal", N.token, "="),
    equal_equal: new P("equal_equal", N.token, "=="),
    not_equal: new P("not_equal", N.token, "!="),
    greater_than: new P("greater_than", N.token, ">"),
    greater_than_equal: new P("greater_than_equal", N.token, ">="),
    shift_right: new P("shift_right", N.token, ">>"),
    less_than: new P("less_than", N.token, "<"),
    less_than_equal: new P("less_than_equal", N.token, "<="),
    shift_left: new P("shift_left", N.token, "<<"),
    modulo: new P("modulo", N.token, "%"),
    minus: new P("minus", N.token, "-"),
    minus_minus: new P("minus_minus", N.token, "--"),
    period: new P("period", N.token, "."),
    plus: new P("plus", N.token, "+"),
    plus_plus: new P("plus_plus", N.token, "++"),
    or: new P("or", N.token, "|"),
    or_or: new P("or_or", N.token, "||"),
    paren_left: new P("paren_left", N.token, "("),
    paren_right: new P("paren_right", N.token, ")"),
    semicolon: new P("semicolon", N.token, ";"),
    star: new P("star", N.token, "*"),
    tilde: new P("tilde", N.token, "~"),
    underscore: new P("underscore", N.token, "_"),
    xor: new P("xor", N.token, "^"),
    plus_equal: new P("plus_equal", N.token, "+="),
    minus_equal: new P("minus_equal", N.token, "-="),
    times_equal: new P("times_equal", N.token, "*="),
    division_equal: new P("division_equal", N.token, "/="),
    modulo_equal: new P("modulo_equal", N.token, "%="),
    and_equal: new P("and_equal", N.token, "&="),
    or_equal: new P("or_equal", N.token, "|="),
    xor_equal: new P("xor_equal", N.token, "^="),
    shift_right_equal: new P("shift_right_equal", N.token, ">>="),
    shift_left_equal: new P("shift_left_equal", N.token, "<<=")
  }, x.simpleTokens = {
    "@": L.tokens.attr,
    "{": L.tokens.brace_left,
    "}": L.tokens.brace_right,
    ":": L.tokens.colon,
    ",": L.tokens.comma,
    "(": L.tokens.paren_left,
    ")": L.tokens.paren_right,
    ";": L.tokens.semicolon
  }, x.literalTokens = {
    "&": L.tokens.and,
    "&&": L.tokens.and_and,
    "->": L.tokens.arrow,
    "/": L.tokens.forward_slash,
    "!": L.tokens.bang,
    "[": L.tokens.bracket_left,
    "]": L.tokens.bracket_right,
    "=": L.tokens.equal,
    "==": L.tokens.equal_equal,
    "!=": L.tokens.not_equal,
    ">": L.tokens.greater_than,
    ">=": L.tokens.greater_than_equal,
    ">>": L.tokens.shift_right,
    "<": L.tokens.less_than,
    "<=": L.tokens.less_than_equal,
    "<<": L.tokens.shift_left,
    "%": L.tokens.modulo,
    "-": L.tokens.minus,
    "--": L.tokens.minus_minus,
    ".": L.tokens.period,
    "+": L.tokens.plus,
    "++": L.tokens.plus_plus,
    "|": L.tokens.or,
    "||": L.tokens.or_or,
    "*": L.tokens.star,
    "~": L.tokens.tilde,
    _: L.tokens.underscore,
    "^": L.tokens.xor,
    "+=": L.tokens.plus_equal,
    "-=": L.tokens.minus_equal,
    "*=": L.tokens.times_equal,
    "/=": L.tokens.division_equal,
    "%=": L.tokens.modulo_equal,
    "&=": L.tokens.and_equal,
    "|=": L.tokens.or_equal,
    "^=": L.tokens.xor_equal,
    ">>=": L.tokens.shift_right_equal,
    "<<=": L.tokens.shift_left_equal
  }, x.regexTokens = {
    decimal_float_literal: L.tokens.decimal_float_literal,
    hex_float_literal: L.tokens.hex_float_literal,
    int_literal: L.tokens.int_literal,
    uint_literal: L.tokens.uint_literal,
    ident: L.tokens.ident
  }, x.storage_class = [
    L.keywords.function,
    L.keywords.private,
    L.keywords.workgroup,
    L.keywords.uniform,
    L.keywords.storage
  ], x.access_mode = [
    L.keywords.read,
    L.keywords.write,
    L.keywords.read_write
  ], x.sampler_type = [
    L.keywords.sampler,
    L.keywords.sampler_comparison
  ], x.sampled_texture_type = [
    L.keywords.texture_1d,
    L.keywords.texture_2d,
    L.keywords.texture_2d_array,
    L.keywords.texture_3d,
    L.keywords.texture_cube,
    L.keywords.texture_cube_array
  ], x.multisampled_texture_type = [
    L.keywords.texture_multisampled_2d
  ], x.storage_texture_type = [
    L.keywords.texture_storage_1d,
    L.keywords.texture_storage_2d,
    L.keywords.texture_storage_2d_array,
    L.keywords.texture_storage_3d
  ], x.depth_texture_type = [
    L.keywords.texture_depth_2d,
    L.keywords.texture_depth_2d_array,
    L.keywords.texture_depth_cube,
    L.keywords.texture_depth_cube_array,
    L.keywords.texture_depth_multisampled_2d
  ], x.texture_external_type = [
    L.keywords.texture_external
  ], x.any_texture_type = [
    ...L.sampled_texture_type,
    ...L.multisampled_texture_type,
    ...L.storage_texture_type,
    ...L.depth_texture_type,
    ...L.texture_external_type
  ], x.texel_format = [
    L.keywords.r8unorm,
    L.keywords.r8snorm,
    L.keywords.r8uint,
    L.keywords.r8sint,
    L.keywords.r16uint,
    L.keywords.r16sint,
    L.keywords.r16float,
    L.keywords.rg8unorm,
    L.keywords.rg8snorm,
    L.keywords.rg8uint,
    L.keywords.rg8sint,
    L.keywords.r32uint,
    L.keywords.r32sint,
    L.keywords.r32float,
    L.keywords.rg16uint,
    L.keywords.rg16sint,
    L.keywords.rg16float,
    L.keywords.rgba8unorm,
    L.keywords.rgba8unorm_srgb,
    L.keywords.rgba8snorm,
    L.keywords.rgba8uint,
    L.keywords.rgba8sint,
    L.keywords.bgra8unorm,
    L.keywords.bgra8unorm_srgb,
    L.keywords.rgb10a2unorm,
    L.keywords.rg11b10float,
    L.keywords.rg32uint,
    L.keywords.rg32sint,
    L.keywords.rg32float,
    L.keywords.rgba16uint,
    L.keywords.rgba16sint,
    L.keywords.rgba16float,
    L.keywords.rgba32uint,
    L.keywords.rgba32sint,
    L.keywords.rgba32float
  ], x.const_literal = [
    L.tokens.int_literal,
    L.tokens.uint_literal,
    L.tokens.decimal_float_literal,
    L.tokens.hex_float_literal,
    L.keywords.true,
    L.keywords.false
  ], x.literal_or_ident = [
    L.tokens.ident,
    L.tokens.int_literal,
    L.tokens.uint_literal,
    L.tokens.decimal_float_literal,
    L.tokens.hex_float_literal,
    L.tokens.name
  ], x.element_count_expression = [
    L.tokens.int_literal,
    L.tokens.uint_literal,
    L.tokens.ident
  ], x.template_types = [
    L.keywords.vec2,
    L.keywords.vec3,
    L.keywords.vec4,
    L.keywords.mat2x2,
    L.keywords.mat2x3,
    L.keywords.mat2x4,
    L.keywords.mat3x2,
    L.keywords.mat3x3,
    L.keywords.mat3x4,
    L.keywords.mat4x2,
    L.keywords.mat4x3,
    L.keywords.mat4x4,
    L.keywords.atomic,
    L.keywords.bitcast,
    ...L.any_texture_type
  ], x.attribute_name = [
    L.tokens.ident,
    L.keywords.block,
    L.keywords.diagnostic
  ], x.assignment_operators = [
    L.tokens.equal,
    L.tokens.plus_equal,
    L.tokens.minus_equal,
    L.tokens.times_equal,
    L.tokens.division_equal,
    L.tokens.modulo_equal,
    L.tokens.and_equal,
    L.tokens.or_equal,
    L.tokens.xor_equal,
    L.tokens.shift_right_equal,
    L.tokens.shift_left_equal
  ], x.increment_operators = [
    L.tokens.plus_plus,
    L.tokens.minus_minus
  ];
  class qb {
    constructor(e, t, i, s, a) {
      this.type = e, this.lexeme = t, this.line = i, this.start = s, this.end = a;
    }
    toString() {
      return this.lexeme;
    }
    isTemplateType() {
      return x.template_types.indexOf(this.type) != -1;
    }
    isArrayType() {
      return this.type == x.keywords.array;
    }
    isArrayOrTemplateType() {
      return this.isArrayType() || this.isTemplateType();
    }
  }
  class iC {
    constructor(e) {
      this._tokens = [], this._start = 0, this._current = 0, this._line = 1, this._source = e ?? "";
    }
    scanTokens() {
      for (; !this._isAtEnd(); ) if (this._start = this._current, !this.scanToken()) throw `Invalid syntax at line ${this._line}`;
      return this._tokens.push(new qb(x.eof, "", this._line, this._current, this._current)), this._tokens;
    }
    scanToken() {
      let e = this._advance();
      if (e == `
`) return this._line++, true;
      if (this._isWhitespace(e)) return true;
      if (e == "/") {
        if (this._peekAhead() == "/") {
          for (; e != `
`; ) {
            if (this._isAtEnd()) return true;
            e = this._advance();
          }
          return this._line++, true;
        }
        if (this._peekAhead() == "*") {
          this._advance();
          let l = 1;
          for (; l > 0; ) {
            if (this._isAtEnd()) return true;
            if (e = this._advance(), e == `
`) this._line++;
            else if (e == "*") {
              if (this._peekAhead() == "/" && (this._advance(), l--, l == 0)) return true;
            } else e == "/" && this._peekAhead() == "*" && (this._advance(), l++);
          }
          return true;
        }
      }
      const t = x.simpleTokens[e];
      if (t) return this._addToken(t), true;
      let i = x.none;
      const s = this._isAlpha(e), a = e === "_";
      if (this._isAlphaNumeric(e)) {
        let l = this._peekAhead();
        for (; this._isAlphaNumeric(l); ) e += this._advance(), l = this._peekAhead();
      }
      if (s) {
        const l = x.keywords[e];
        if (l) return this._addToken(l), true;
      }
      if (s || a) return this._addToken(x.tokens.ident), true;
      for (; ; ) {
        let l = this._findType(e);
        const u = this._peekAhead();
        if (e == "-" && this._tokens.length > 0) {
          if (u == "=") return this._current++, e += u, this._addToken(x.tokens.minus_equal), true;
          if (u == "-") return this._current++, e += u, this._addToken(x.tokens.minus_minus), true;
          const h = this._tokens.length - 1;
          if ((x.literal_or_ident.indexOf(this._tokens[h].type) != -1 || this._tokens[h].type == x.tokens.paren_right) && u != ">") return this._addToken(l), true;
        }
        if (e == ">" && (u == ">" || u == "=")) {
          let h = false, d = this._tokens.length - 1;
          for (let p = 0; p < 5 && d >= 0 && x.assignment_operators.indexOf(this._tokens[d].type) === -1; ++p, --d) if (this._tokens[d].type === x.tokens.less_than) {
            d > 0 && this._tokens[d - 1].isArrayOrTemplateType() && (h = true);
            break;
          }
          if (h) return this._addToken(l), true;
        }
        if (l === x.none) {
          let h = e, d = 0;
          const p = 2;
          for (let _ = 0; _ < p; ++_) if (h += this._peekAhead(_), l = this._findType(h), l !== x.none) {
            d = _;
            break;
          }
          if (l === x.none) return i !== x.none && (this._current--, this._addToken(i), true);
          e = h, this._current += d + 1;
        }
        if (i = l, this._isAtEnd()) break;
        e += this._advance();
      }
      return i !== x.none && (this._addToken(i), true);
    }
    _findType(e) {
      for (const i in x.regexTokens) {
        const s = x.regexTokens[i];
        if (this._match(e, s.rule)) return s;
      }
      return x.literalTokens[e] || x.none;
    }
    _match(e, t) {
      const i = t.exec(e);
      return i && i.index == 0 && i[0] == e;
    }
    _isAtEnd() {
      return this._current >= this._source.length;
    }
    _isAlpha(e) {
      return !this._isNumeric(e) && !this._isWhitespace(e) && e !== "_" && e !== "." && e !== "(" && e !== ")" && e !== "[" && e !== "]" && e !== "{" && e !== "}" && e !== "," && e !== ";" && e !== ":" && e !== "=" && e !== "!" && e !== "<" && e !== ">" && e !== "+" && e !== "-" && e !== "*" && e !== "/" && e !== "%" && e !== "&" && e !== "|" && e !== "^" && e !== "~" && e !== "@" && e !== "#" && e !== "?" && e !== "'" && e !== "`" && e !== '"' && e !== "\\" && e !== `
` && e !== "\r" && e !== "	" && e !== "\0";
    }
    _isNumeric(e) {
      return e >= "0" && e <= "9";
    }
    _isAlphaNumeric(e) {
      return this._isAlpha(e) || this._isNumeric(e) || e === "_";
    }
    _isWhitespace(e) {
      return e == " " || e == "	" || e == "\r";
    }
    _advance(e = 0) {
      let t = this._source[this._current];
      return e = e || 0, e++, this._current += e, t;
    }
    _peekAhead(e = 0) {
      return e = e || 0, this._current + e >= this._source.length ? "\0" : this._source[this._current + e];
    }
    _addToken(e) {
      const t = this._source.substring(this._start, this._current);
      this._tokens.push(new qb(e, t, this._line, this._start, this._current));
    }
  }
  function ie(n) {
    return Array.isArray(n) || (n == null ? void 0 : n.buffer) instanceof ArrayBuffer;
  }
  const Ac = new Float32Array(1), sC = new Uint32Array(Ac.buffer), rC = new Uint32Array(Ac.buffer), wc = new Int32Array(1), aC = new Float32Array(wc.buffer), oC = new Uint32Array(wc.buffer), Ec = new Uint32Array(1), lC = new Float32Array(Ec.buffer), cC = new Int32Array(Ec.buffer);
  function Kb(n, e, t) {
    if (e === t) return n;
    if (e === "f32") {
      if (t === "i32" || t === "x32") return Ac[0] = n, sC[0];
      if (t === "u32") return Ac[0] = n, rC[0];
    } else if (e === "i32" || e === "x32") {
      if (t === "f32") return wc[0] = n, aC[0];
      if (t === "u32") return wc[0] = n, oC[0];
    } else if (e === "u32") {
      if (t === "f32") return Ec[0] = n, lC[0];
      if (t === "i32" || t === "x32") return Ec[0] = n, cC[0];
    }
    return console.error(`Unsupported cast from ${e} to ${t}`), n;
  }
  class uC {
    constructor(e) {
      this.resources = null, this.inUse = false, this.info = null, this.node = e;
    }
  }
  class Zl {
    constructor(e, t) {
      this.align = e, this.size = t;
    }
  }
  class Un {
    constructor() {
      this.uniforms = [], this.storage = [], this.textures = [], this.samplers = [], this.aliases = [], this.overrides = [], this.structs = [], this.entry = new YR(), this.functions = [], this._types = /* @__PURE__ */ new Map(), this._functions = /* @__PURE__ */ new Map();
    }
    _isStorageTexture(e) {
      return e.name == "texture_storage_1d" || e.name == "texture_storage_2d" || e.name == "texture_storage_2d_array" || e.name == "texture_storage_3d";
    }
    updateAST(e) {
      for (const t of e) t instanceof mo && this._functions.set(t.name, new uC(t));
      for (const t of e) if (t instanceof si) {
        const i = this.getTypeInfo(t, null);
        i instanceof zi && this.structs.push(i);
      }
      for (const t of e) if (t instanceof yg) this.aliases.push(this._getAliasInfo(t));
      else if (t instanceof mg) {
        const i = t, s = this._getAttributeNum(i.attributes, "id", 0), a = i.type != null ? this.getTypeInfo(i.type, i.attributes) : null;
        this.overrides.push(new WR(i.name, a, i.attributes, s));
      } else if (this._isUniformVar(t)) {
        const i = t, s = this._getAttributeNum(i.attributes, "group", 0), a = this._getAttributeNum(i.attributes, "binding", 0), l = this.getTypeInfo(i.type, i.attributes), u = new Kl(i.name, l, s, a, i.attributes, Fi.Uniform, i.access);
        u.access || (u.access = "read"), this.uniforms.push(u);
      } else if (this._isStorageVar(t)) {
        const i = t, s = this._getAttributeNum(i.attributes, "group", 0), a = this._getAttributeNum(i.attributes, "binding", 0), l = this.getTypeInfo(i.type, i.attributes), u = this._isStorageTexture(l), h = new Kl(i.name, l, s, a, i.attributes, u ? Fi.StorageTexture : Fi.Storage, i.access);
        h.access || (h.access = "read"), this.storage.push(h);
      } else if (this._isTextureVar(t)) {
        const i = t, s = this._getAttributeNum(i.attributes, "group", 0), a = this._getAttributeNum(i.attributes, "binding", 0), l = this.getTypeInfo(i.type, i.attributes), u = this._isStorageTexture(l), h = new Kl(i.name, l, s, a, i.attributes, u ? Fi.StorageTexture : Fi.Texture, i.access);
        h.access || (h.access = "read"), u ? this.storage.push(h) : this.textures.push(h);
      } else if (this._isSamplerVar(t)) {
        const i = t, s = this._getAttributeNum(i.attributes, "group", 0), a = this._getAttributeNum(i.attributes, "binding", 0), l = this.getTypeInfo(i.type, i.attributes), u = new Kl(i.name, l, s, a, i.attributes, Fi.Sampler, i.access);
        this.samplers.push(u);
      } else if (t instanceof mo) {
        const i = this._getAttribute(t, "vertex"), s = this._getAttribute(t, "fragment"), a = this._getAttribute(t, "compute"), l = i || s || a, u = new XR(t.name, l == null ? void 0 : l.name, t.attributes);
        u.attributes = t.attributes, u.startLine = t.startLine, u.endLine = t.endLine, this.functions.push(u), this._functions.get(t.name).info = u, l && (this._functions.get(t.name).inUse = true, u.inUse = true, u.resources = this._findResources(t, !!l), u.inputs = this._getInputs(t.args), u.outputs = this._getOutputs(t.returnType), this.entry[l.name].push(u)), u.arguments = t.args.map((h) => new $R(h.name, this.getTypeInfo(h.type, h.attributes), h.attributes)), u.returnType = t.returnType ? this.getTypeInfo(t.returnType, t.attributes) : null;
      }
      for (const t of this._functions.values()) t.info && (t.info.inUse = t.inUse, this._addCalls(t.node, t.info.calls));
      for (const t of this._functions.values()) t.node.search((i) => {
        var s, a, l;
        if (i instanceof t2) {
          if (i.value) if (ie(i.value)) for (const u of i.value) for (const h of this.overrides) u === h.name && ((s = t.info) === null || s === void 0 || s.overrides.push(h));
          else for (const u of this.overrides) i.value === u.name && ((a = t.info) === null || a === void 0 || a.overrides.push(u));
        } else if (i instanceof en) for (const u of this.overrides) i.name === u.name && ((l = t.info) === null || l === void 0 || l.overrides.push(u));
      });
      for (const t of this.uniforms) this._markStructsInUse(t.type);
      for (const t of this.storage) this._markStructsInUse(t.type);
    }
    getStructInfo(e) {
      for (const t of this.structs) if (t.name == e) return t;
      return null;
    }
    getOverrideInfo(e) {
      for (const t of this.overrides) if (t.name == e) return t;
      return null;
    }
    _markStructsInUse(e) {
      if (e) if (e.isStruct) {
        if (e.inUse = true, e.members) for (const t of e.members) this._markStructsInUse(t.type);
      } else if (e.isArray) this._markStructsInUse(e.format);
      else if (e.isTemplate) e.format && this._markStructsInUse(e.format);
      else {
        const t = this._getAlias(e.name);
        t && this._markStructsInUse(t);
      }
    }
    _addCalls(e, t) {
      var i;
      for (const s of e.calls) {
        const a = (i = this._functions.get(s.name)) === null || i === void 0 ? void 0 : i.info;
        a && t.add(a);
      }
    }
    findResource(e, t, i) {
      if (i) {
        for (const s of this.entry.compute) if (s.name === i) {
          for (const a of s.resources) if (a.group == e && a.binding == t) return a;
        }
        for (const s of this.entry.vertex) if (s.name === i) {
          for (const a of s.resources) if (a.group == e && a.binding == t) return a;
        }
        for (const s of this.entry.fragment) if (s.name === i) {
          for (const a of s.resources) if (a.group == e && a.binding == t) return a;
        }
      }
      for (const s of this.uniforms) if (s.group == e && s.binding == t) return s;
      for (const s of this.storage) if (s.group == e && s.binding == t) return s;
      for (const s of this.textures) if (s.group == e && s.binding == t) return s;
      for (const s of this.samplers) if (s.group == e && s.binding == t) return s;
      return null;
    }
    _findResource(e) {
      for (const t of this.uniforms) if (t.name == e) return t;
      for (const t of this.storage) if (t.name == e) return t;
      for (const t of this.textures) if (t.name == e) return t;
      for (const t of this.samplers) if (t.name == e) return t;
      return null;
    }
    _markStructsFromAST(e) {
      const t = this.getTypeInfo(e, null);
      this._markStructsInUse(t);
    }
    _findResources(e, t) {
      const i = [], s = this, a = [];
      return e.search((l) => {
        if (l instanceof xc) a.push({});
        else if (l instanceof Sc) a.pop();
        else if (l instanceof ai) {
          const u = l;
          t && u.type !== null && this._markStructsFromAST(u.type), a.length > 0 && (a[a.length - 1][u.name] = u);
        } else if (l instanceof Pn) {
          const u = l;
          t && u.type !== null && this._markStructsFromAST(u.type);
        } else if (l instanceof lo) {
          const u = l;
          t && u.type !== null && this._markStructsFromAST(u.type), a.length > 0 && (a[a.length - 1][u.name] = u);
        } else if (l instanceof en) {
          const u = l;
          if (a.length > 0 && a[a.length - 1][u.name]) return;
          const h = s._findResource(u.name);
          h && i.push(h);
        } else if (l instanceof bg) {
          const u = l, h = s._functions.get(u.name);
          h && (t && (h.inUse = true), e.calls.add(h.node), h.resources === null && (h.resources = s._findResources(h.node, t)), i.push(...h.resources));
        } else if (l instanceof _g) {
          const u = l, h = s._functions.get(u.name);
          h && (t && (h.inUse = true), e.calls.add(h.node), h.resources === null && (h.resources = s._findResources(h.node, t)), i.push(...h.resources));
        }
      }), [
        ...new Map(i.map((l) => [
          l.name,
          l
        ])).values()
      ];
    }
    getBindGroups() {
      const e = [];
      function t(i, s) {
        i >= e.length && (e.length = i + 1), e[i] === void 0 && (e[i] = []), s >= e[i].length && (e[i].length = s + 1);
      }
      for (const i of this.uniforms) t(i.group, i.binding), e[i.group][i.binding] = i;
      for (const i of this.storage) t(i.group, i.binding), e[i.group][i.binding] = i;
      for (const i of this.textures) t(i.group, i.binding), e[i.group][i.binding] = i;
      for (const i of this.samplers) t(i.group, i.binding), e[i.group][i.binding] = i;
      return e;
    }
    _getOutputs(e, t = void 0) {
      if (t === void 0 && (t = []), e instanceof si) this._getStructOutputs(e, t);
      else {
        const i = this._getOutputInfo(e);
        i !== null && t.push(i);
      }
      return t;
    }
    _getStructOutputs(e, t) {
      for (const i of e.members) if (i.type instanceof si) this._getStructOutputs(i.type, t);
      else {
        const s = this._getAttribute(i, "location") || this._getAttribute(i, "builtin");
        if (s !== null) {
          const a = this.getTypeInfo(i.type, i.type.attributes), l = this._parseInt(s.value), u = new jb(i.name, a, s.name, l);
          t.push(u);
        }
      }
    }
    _getOutputInfo(e) {
      const t = this._getAttribute(e, "location") || this._getAttribute(e, "builtin");
      if (t !== null) {
        const i = this.getTypeInfo(e, e.attributes), s = this._parseInt(t.value);
        return new jb("", i, t.name, s);
      }
      return null;
    }
    _getInputs(e, t = void 0) {
      t === void 0 && (t = []);
      for (const i of e) if (i.type instanceof si) this._getStructInputs(i.type, t);
      else {
        const s = this._getInputInfo(i);
        s !== null && t.push(s);
      }
      return t;
    }
    _getStructInputs(e, t) {
      for (const i of e.members) if (i.type instanceof si) this._getStructInputs(i.type, t);
      else {
        const s = this._getInputInfo(i);
        s !== null && t.push(s);
      }
    }
    _getInputInfo(e) {
      const t = this._getAttribute(e, "location") || this._getAttribute(e, "builtin");
      if (t !== null) {
        const i = this._getAttribute(e, "interpolation"), s = this.getTypeInfo(e.type, e.attributes), a = this._parseInt(t.value), l = new jR(e.name, s, t.name, a);
        return i !== null && (l.interpolation = this._parseString(i.value)), l;
      }
      return null;
    }
    _parseString(e) {
      return e instanceof Array && (e = e[0]), e;
    }
    _parseInt(e) {
      e instanceof Array && (e = e[0]);
      const t = parseInt(e);
      return isNaN(t) ? e : t;
    }
    _getAlias(e) {
      for (const t of this.aliases) if (t.name == e) return t.type;
      return null;
    }
    _getAliasInfo(e) {
      return new HR(e.name, this.getTypeInfo(e.type, null));
    }
    getTypeInfoByName(e) {
      for (const t of this.structs) if (t.name == e) return t;
      for (const t of this.aliases) if (t.name == e) return t.type;
      return null;
    }
    getTypeInfo(e, t = null) {
      if (this._types.has(e)) return this._types.get(e);
      if (e instanceof co) {
        const s = e, a = s.format ? this.getTypeInfo(s.format, s.attributes) : null, l = new $i(s.name, t);
        return l.format = a, l.count = s.count, this._types.set(e, l), this._updateTypeInfo(l), l;
      }
      if (e instanceof si) {
        const s = e, a = new zi(s.name, t);
        a.startLine = s.startLine, a.endLine = s.endLine;
        for (const l of s.members) {
          const u = this.getTypeInfo(l.type, l.attributes);
          a.members.push(new Hb(l.name, u, l.attributes));
        }
        return this._types.set(e, a), this._updateTypeInfo(a), a;
      }
      if (e instanceof no) {
        const s = e, a = s.format instanceof q, l = s.format ? a ? this.getTypeInfo(s.format, null) : new dn(s.format, null) : null, u = new Es(s.name, l, t, s.access);
        return this._types.set(e, u), this._updateTypeInfo(u), u;
      }
      if (e instanceof k) {
        const s = e, a = s.format ? this.getTypeInfo(s.format, null) : null, l = new Es(s.name, a, t, s.access);
        return this._types.set(e, l), this._updateTypeInfo(l), l;
      }
      const i = new dn(e.name, t);
      return this._types.set(e, i), this._updateTypeInfo(i), i;
    }
    _updateTypeInfo(e) {
      var t, i, s;
      const a = this._getTypeSize(e);
      if (e.size = (t = a == null ? void 0 : a.size) !== null && t !== void 0 ? t : 0, e instanceof $i && e.format) {
        const l = this._getTypeSize(e.format);
        e.stride = Math.max((i = l == null ? void 0 : l.size) !== null && i !== void 0 ? i : 0, (s = l == null ? void 0 : l.align) !== null && s !== void 0 ? s : 0), this._updateTypeInfo(e.format);
      }
      e instanceof zi && this._updateStructInfo(e);
    }
    _updateStructInfo(e) {
      var t;
      let i = 0, s = 0, a = 0, l = 0;
      for (let u = 0, h = e.members.length; u < h; ++u) {
        const d = e.members[u], p = this._getTypeSize(d);
        if (!p) continue;
        (t = this._getAlias(d.type.name)) !== null && t !== void 0 || d.type;
        const _ = p.align, y = p.size;
        i = this._roundUp(_, i + s), s = y, a = i, l = Math.max(l, _), d.offset = i, d.size = y, this._updateTypeInfo(d.type);
      }
      e.size = this._roundUp(l, a + s), e.align = l;
    }
    _getTypeSize(e) {
      var t, i;
      if (e == null) return null;
      const s = this._getAttributeNum(e.attributes, "size", 0), a = this._getAttributeNum(e.attributes, "align", 0);
      if (e instanceof Hb && (e = e.type), e instanceof dn) {
        const l = this._getAlias(e.name);
        l !== null && (e = l);
      }
      {
        const l = Un._typeInfo[e.name];
        if (l !== void 0) {
          const u = ((t = e.format) === null || t === void 0 ? void 0 : t.name) === "f16" ? 2 : 1;
          return new Zl(Math.max(a, l.align / u), Math.max(s, l.size / u));
        }
      }
      {
        const l = Un._typeInfo[e.name.substring(0, e.name.length - 1)];
        if (l) {
          const u = e.name[e.name.length - 1] === "h" ? 2 : 1;
          return new Zl(Math.max(a, l.align / u), Math.max(s, l.size / u));
        }
      }
      if (e instanceof $i) {
        let l = e, u = 8, h = 8;
        const d = this._getTypeSize(l.format);
        return d !== null && (h = d.size, u = d.align), h = l.count * this._getAttributeNum((i = e == null ? void 0 : e.attributes) !== null && i !== void 0 ? i : null, "stride", this._roundUp(u, h)), s && (h = s), new Zl(Math.max(a, u), Math.max(s, h));
      }
      if (e instanceof zi) {
        let l = 0, u = 0, h = 0, d = 0, p = 0;
        for (const _ of e.members) {
          const y = this._getTypeSize(_.type);
          y !== null && (l = Math.max(y.align, l), h = this._roundUp(y.align, h + d), d = y.size, p = h);
        }
        return u = this._roundUp(l, p + d), new Zl(Math.max(a, l), Math.max(s, u));
      }
      return null;
    }
    _isUniformVar(e) {
      return e instanceof ai && e.storage == "uniform";
    }
    _isStorageVar(e) {
      return e instanceof ai && e.storage == "storage";
    }
    _isTextureVar(e) {
      return e instanceof ai && e.type !== null && Un._textureTypes.indexOf(e.type.name) != -1;
    }
    _isSamplerVar(e) {
      return e instanceof ai && e.type !== null && Un._samplerTypes.indexOf(e.type.name) != -1;
    }
    _getAttribute(e, t) {
      const i = e;
      if (!i || !i.attributes) return null;
      const s = i.attributes;
      for (let a of s) if (a.name == t) return a;
      return null;
    }
    _getAttributeNum(e, t, i) {
      if (e === null) return i;
      for (let s of e) if (s.name == t) {
        let a = s !== null && s.value !== null ? s.value : i;
        return a instanceof Array && (a = a[0]), typeof a == "number" ? a : typeof a == "string" ? parseInt(a) : i;
      }
      return i;
    }
    _roundUp(e, t) {
      return Math.ceil(t / e) * e;
    }
  }
  Un._typeInfo = {
    f16: {
      align: 2,
      size: 2
    },
    i32: {
      align: 4,
      size: 4
    },
    u32: {
      align: 4,
      size: 4
    },
    f32: {
      align: 4,
      size: 4
    },
    atomic: {
      align: 4,
      size: 4
    },
    vec2: {
      align: 8,
      size: 8
    },
    vec3: {
      align: 16,
      size: 12
    },
    vec4: {
      align: 16,
      size: 16
    },
    mat2x2: {
      align: 8,
      size: 16
    },
    mat3x2: {
      align: 8,
      size: 24
    },
    mat4x2: {
      align: 8,
      size: 32
    },
    mat2x3: {
      align: 16,
      size: 32
    },
    mat3x3: {
      align: 16,
      size: 48
    },
    mat4x3: {
      align: 16,
      size: 64
    },
    mat2x4: {
      align: 16,
      size: 32
    },
    mat3x4: {
      align: 16,
      size: 48
    },
    mat4x4: {
      align: 16,
      size: 64
    }
  }, Un._textureTypes = x.any_texture_type.map((n) => n.name), Un._samplerTypes = x.sampler_type.map((n) => n.name);
  class vg {
    constructor(e, t, i) {
      this.name = e, this.value = t, this.node = i;
    }
    clone() {
      return new vg(this.name, this.value, this.node);
    }
  }
  class Tg {
    constructor(e) {
      this.name = e.name, this.node = e;
    }
    clone() {
      return new Tg(this.node);
    }
  }
  class xg {
    constructor(e) {
      this.parent = null, this.variables = /* @__PURE__ */ new Map(), this.functions = /* @__PURE__ */ new Map(), this.currentFunctionName = "", e && (this.parent = e, this.currentFunctionName = e.currentFunctionName);
    }
    getVariable(e) {
      var t;
      return this.variables.has(e) ? (t = this.variables.get(e)) !== null && t !== void 0 ? t : null : this.parent ? this.parent.getVariable(e) : null;
    }
    getFunction(e) {
      var t;
      return this.functions.has(e) ? (t = this.functions.get(e)) !== null && t !== void 0 ? t : null : this.parent ? this.parent.getFunction(e) : null;
    }
    createVariable(e, t, i) {
      this.variables.set(e, new vg(e, t, i ?? null));
    }
    setVariable(e, t, i) {
      const s = this.getVariable(e);
      s !== null ? s.value = t : this.createVariable(e, t, i);
    }
    getVariableValue(e) {
      var t;
      const i = this.getVariable(e);
      return (t = i == null ? void 0 : i.value) !== null && t !== void 0 ? t : null;
    }
    clone() {
      return new xg(this);
    }
  }
  class fC {
    evalExpression(e, t) {
      return null;
    }
    getTypeInfo(e) {
      return null;
    }
    getVariableName(e, t) {
      return "";
    }
  }
  class hC {
    constructor(e) {
      this.exec = e;
    }
    getTypeInfo(e) {
      return this.exec.getTypeInfo(e);
    }
    All(e, t) {
      const i = this.exec.evalExpression(e.args[0], t);
      let s = true;
      if (i instanceof A) return i.data.forEach((a) => {
        a || (s = false);
      }), new I(s ? 1 : 0, this.getTypeInfo("bool"));
      throw new Error(`All() expects a vector argument. Line ${e.line}`);
    }
    Any(e, t) {
      const i = this.exec.evalExpression(e.args[0], t);
      if (i instanceof A) {
        const s = i.data.some((a) => a);
        return new I(s ? 1 : 0, this.getTypeInfo("bool"));
      }
      throw new Error(`Any() expects a vector argument. Line ${e.line}`);
    }
    Select(e, t) {
      const i = this.exec.evalExpression(e.args[2], t);
      if (!(i instanceof I)) throw new Error(`Select() expects a bool condition. Line ${e.line}`);
      return i.value ? this.exec.evalExpression(e.args[1], t) : this.exec.evalExpression(e.args[0], t);
    }
    ArrayLength(e, t) {
      let i = e.args[0];
      i instanceof ct && (i = i.right);
      const s = this.exec.evalExpression(i, t);
      if (s instanceof it && s.typeInfo.size === 0) {
        const a = s.typeInfo, l = s.buffer.byteLength / a.stride;
        return new I(l, this.getTypeInfo("u32"));
      }
      return new I(s.typeInfo.size, this.getTypeInfo("u32"));
    }
    Abs(e, t) {
      const i = this.exec.evalExpression(e.args[0], t);
      if (i instanceof A) return new A(i.data.map((a) => Math.abs(a)), i.typeInfo);
      const s = i;
      return new I(Math.abs(s.value), s.typeInfo);
    }
    Acos(e, t) {
      const i = this.exec.evalExpression(e.args[0], t);
      if (i instanceof A) return new A(i.data.map((a) => Math.acos(a)), i.typeInfo);
      const s = i;
      return new I(Math.acos(s.value), i.typeInfo);
    }
    Acosh(e, t) {
      const i = this.exec.evalExpression(e.args[0], t);
      if (i instanceof A) return new A(i.data.map((a) => Math.acosh(a)), i.typeInfo);
      const s = i;
      return new I(Math.acosh(s.value), i.typeInfo);
    }
    Asin(e, t) {
      const i = this.exec.evalExpression(e.args[0], t);
      if (i instanceof A) return new A(i.data.map((a) => Math.asin(a)), i.typeInfo);
      const s = i;
      return new I(Math.asin(s.value), i.typeInfo);
    }
    Asinh(e, t) {
      const i = this.exec.evalExpression(e.args[0], t);
      if (i instanceof A) return new A(i.data.map((a) => Math.asinh(a)), i.typeInfo);
      const s = i;
      return new I(Math.asinh(s.value), i.typeInfo);
    }
    Atan(e, t) {
      const i = this.exec.evalExpression(e.args[0], t);
      if (i instanceof A) return new A(i.data.map((a) => Math.atan(a)), i.typeInfo);
      const s = i;
      return new I(Math.atan(s.value), i.typeInfo);
    }
    Atanh(e, t) {
      const i = this.exec.evalExpression(e.args[0], t);
      if (i instanceof A) return new A(i.data.map((a) => Math.atanh(a)), i.typeInfo);
      const s = i;
      return new I(Math.atanh(s.value), i.typeInfo);
    }
    Atan2(e, t) {
      const i = this.exec.evalExpression(e.args[0], t), s = this.exec.evalExpression(e.args[1], t);
      if (i instanceof A && s instanceof A) return new A(i.data.map((u, h) => Math.atan2(u, s.data[h])), i.typeInfo);
      const a = i, l = s;
      return new I(Math.atan2(a.value, l.value), i.typeInfo);
    }
    Ceil(e, t) {
      const i = this.exec.evalExpression(e.args[0], t);
      if (i instanceof A) return new A(i.data.map((a) => Math.ceil(a)), i.typeInfo);
      const s = i;
      return new I(Math.ceil(s.value), i.typeInfo);
    }
    _clamp(e, t, i) {
      return Math.min(Math.max(e, t), i);
    }
    Clamp(e, t) {
      const i = this.exec.evalExpression(e.args[0], t), s = this.exec.evalExpression(e.args[1], t), a = this.exec.evalExpression(e.args[2], t);
      if (i instanceof A && s instanceof A && a instanceof A) return new A(i.data.map((d, p) => this._clamp(d, s.data[p], a.data[p])), i.typeInfo);
      const l = i, u = s, h = a;
      return new I(this._clamp(l.value, u.value, h.value), i.typeInfo);
    }
    Cos(e, t) {
      const i = this.exec.evalExpression(e.args[0], t);
      if (i instanceof A) return new A(i.data.map((a) => Math.cos(a)), i.typeInfo);
      const s = i;
      return new I(Math.cos(s.value), i.typeInfo);
    }
    Cosh(e, t) {
      const i = this.exec.evalExpression(e.args[0], t);
      if (i instanceof A) return new A(i.data.map((a) => Math.cosh(a)), i.typeInfo);
      const s = i;
      return new I(Math.cos(s.value), i.typeInfo);
    }
    CountLeadingZeros(e, t) {
      const i = this.exec.evalExpression(e.args[0], t);
      if (i instanceof A) return new A(i.data.map((a) => Math.clz32(a)), i.typeInfo);
      const s = i;
      return new I(Math.clz32(s.value), i.typeInfo);
    }
    _countOneBits(e) {
      let t = 0;
      for (; e !== 0; ) 1 & e && t++, e >>= 1;
      return t;
    }
    CountOneBits(e, t) {
      const i = this.exec.evalExpression(e.args[0], t);
      if (i instanceof A) return new A(i.data.map((a) => this._countOneBits(a)), i.typeInfo);
      const s = i;
      return new I(this._countOneBits(s.value), i.typeInfo);
    }
    _countTrailingZeros(e) {
      if (e === 0) return 32;
      let t = 0;
      for (; !(1 & e); ) e >>= 1, t++;
      return t;
    }
    CountTrailingZeros(e, t) {
      const i = this.exec.evalExpression(e.args[0], t);
      if (i instanceof A) return new A(i.data.map((a) => this._countTrailingZeros(a)), i.typeInfo);
      const s = i;
      return new I(this._countTrailingZeros(s.value), i.typeInfo);
    }
    Cross(e, t) {
      const i = this.exec.evalExpression(e.args[0], t), s = this.exec.evalExpression(e.args[1], t);
      if (i instanceof A && s instanceof A) {
        if (i.data.length !== 3 || s.data.length !== 3) return console.error(`Cross() expects 3D vectors. Line ${e.line}`), null;
        const a = i.data, l = s.data;
        return new A([
          a[1] * l[2] - l[1] * a[2],
          a[2] * l[0] - l[2] * a[0],
          a[0] * l[1] - l[0] * a[1]
        ], i.typeInfo);
      }
      return console.error(`Cross() expects vector arguments. Line ${e.line}`), null;
    }
    Degrees(e, t) {
      const i = this.exec.evalExpression(e.args[0], t), s = 180 / Math.PI;
      return i instanceof A ? new A(i.data.map((a) => a * s), i.typeInfo) : new I(i.value * s, this.getTypeInfo("f32"));
    }
    Determinant(e, t) {
      const i = this.exec.evalExpression(e.args[0], t);
      if (i instanceof _e) {
        const s = i.data, a = i.typeInfo.getTypeName(), l = a.endsWith("h") ? this.getTypeInfo("f16") : this.getTypeInfo("f32");
        if (a === "mat2x2" || a === "mat2x2f" || a === "mat2x2h") return new I(s[0] * s[3] - s[1] * s[2], l);
        if (a === "mat2x3" || a === "mat2x3f" || a === "mat2x3h") return new I(s[0] * (s[4] * s[8] - s[5] * s[7]) - s[1] * (s[3] * s[8] - s[5] * s[6]) + s[2] * (s[3] * s[7] - s[4] * s[6]), l);
        if (a === "mat2x4" || a === "mat2x4f" || a === "mat2x4h") console.error(`TODO: Determinant for ${a}`);
        else if (a === "mat3x2" || a === "mat3x2f" || a === "mat3x2h") console.error(`TODO: Determinant for ${a}`);
        else {
          if (a === "mat3x3" || a === "mat3x3f" || a === "mat3x3h") return new I(s[0] * (s[4] * s[8] - s[5] * s[7]) - s[1] * (s[3] * s[8] - s[5] * s[6]) + s[2] * (s[3] * s[7] - s[4] * s[6]), l);
          a === "mat3x4" || a === "mat3x4f" || a === "mat3x4h" || a === "mat4x2" || a === "mat4x2f" || a === "mat4x2h" || a === "mat4x3" || a === "mat4x3f" || a === "mat4x3h" ? console.error(`TODO: Determinant for ${a}`) : a !== "mat4x4" && a !== "mat4x4f" && a !== "mat4x4h" || console.error(`TODO: Determinant for ${a}`);
        }
      }
      return console.error(`Determinant expects a matrix argument. Line ${e.line}`), null;
    }
    Distance(e, t) {
      const i = this.exec.evalExpression(e.args[0], t), s = this.exec.evalExpression(e.args[1], t);
      if (i instanceof A && s instanceof A) {
        let u = 0;
        for (let h = 0; h < i.data.length; ++h) u += (i.data[h] - s.data[h]) * (i.data[h] - s.data[h]);
        return new I(Math.sqrt(u), this.getTypeInfo("f32"));
      }
      const a = i, l = s;
      return new I(Math.abs(a.value - l.value), i.typeInfo);
    }
    _dot(e, t) {
      let i = 0;
      for (let s = 0; s < e.length; ++s) i += t[s] * e[s];
      return i;
    }
    Dot(e, t) {
      const i = this.exec.evalExpression(e.args[0], t), s = this.exec.evalExpression(e.args[1], t);
      return i instanceof A && s instanceof A ? new I(this._dot(i.data, s.data), this.getTypeInfo("f32")) : (console.error(`Dot() expects vector arguments. Line ${e.line}`), null);
    }
    Dot4U8Packed(e, t) {
      return console.error(`TODO: dot4U8Packed. Line ${e.line}`), null;
    }
    Dot4I8Packed(e, t) {
      return console.error(`TODO: dot4I8Packed. Line ${e.line}`), null;
    }
    Exp(e, t) {
      const i = this.exec.evalExpression(e.args[0], t);
      if (i instanceof A) return new A(i.data.map((a) => Math.exp(a)), i.typeInfo);
      const s = i;
      return new I(Math.exp(s.value), i.typeInfo);
    }
    Exp2(e, t) {
      const i = this.exec.evalExpression(e.args[0], t);
      if (i instanceof A) return new A(i.data.map((a) => Math.pow(2, a)), i.typeInfo);
      const s = i;
      return new I(Math.pow(2, s.value), i.typeInfo);
    }
    ExtractBits(e, t) {
      const i = this.exec.evalExpression(e.args[0], t), s = this.exec.evalExpression(e.args[1], t), a = this.exec.evalExpression(e.args[2], t);
      if (s.typeInfo.name !== "u32" && s.typeInfo.name !== "x32") return console.error(`ExtractBits() expects an i32 offset argument. Line ${e.line}`), null;
      if (a.typeInfo.name !== "u32" && a.typeInfo.name !== "x32") return console.error(`ExtractBits() expects an i32 count argument. Line ${e.line}`), null;
      const l = s.value, u = a.value;
      if (i instanceof A) return new A(i.data.map((d) => d >> l & (1 << u) - 1), i.typeInfo);
      if (i.typeInfo.name !== "i32" && i.typeInfo.name !== "x32") return console.error(`ExtractBits() expects an i32 argument. Line ${e.line}`), null;
      const h = i.value;
      return new I(h >> l & (1 << u) - 1, this.getTypeInfo("i32"));
    }
    FaceForward(e, t) {
      const i = this.exec.evalExpression(e.args[0], t), s = this.exec.evalExpression(e.args[1], t), a = this.exec.evalExpression(e.args[2], t);
      if (i instanceof A && s instanceof A && a instanceof A) {
        const l = this._dot(s.data, a.data);
        return new A(l < 0 ? Array.from(i.data) : i.data.map((u) => -u), i.typeInfo);
      }
      return console.error(`FaceForward() expects vector arguments. Line ${e.line}`), null;
    }
    _firstLeadingBit(e) {
      return e === 0 ? -1 : 31 - Math.clz32(e);
    }
    FirstLeadingBit(e, t) {
      const i = this.exec.evalExpression(e.args[0], t);
      if (i instanceof A) return new A(i.data.map((a) => this._firstLeadingBit(a)), i.typeInfo);
      const s = i;
      return new I(this._firstLeadingBit(s.value), i.typeInfo);
    }
    _firstTrailingBit(e) {
      return e === 0 ? -1 : Math.log2(e & -e);
    }
    FirstTrailingBit(e, t) {
      const i = this.exec.evalExpression(e.args[0], t);
      if (i instanceof A) return new A(i.data.map((a) => this._firstTrailingBit(a)), i.typeInfo);
      const s = i;
      return new I(this._firstTrailingBit(s.value), i.typeInfo);
    }
    Floor(e, t) {
      const i = this.exec.evalExpression(e.args[0], t);
      if (i instanceof A) return new A(i.data.map((a) => Math.floor(a)), i.typeInfo);
      const s = i;
      return new I(Math.floor(s.value), i.typeInfo);
    }
    Fma(e, t) {
      const i = this.exec.evalExpression(e.args[0], t), s = this.exec.evalExpression(e.args[1], t), a = this.exec.evalExpression(e.args[2], t);
      if (i instanceof A && s instanceof A && a instanceof A) return i.data.length !== s.data.length || i.data.length !== a.data.length ? (console.error(`Fma() expects vectors of the same length. Line ${e.line}`), null) : new A(i.data.map((d, p) => d * s.data[p] + a.data[p]), i.typeInfo);
      const l = i, u = s, h = a;
      return new I(l.value * u.value + h.value, l.typeInfo);
    }
    Fract(e, t) {
      const i = this.exec.evalExpression(e.args[0], t);
      if (i instanceof A) return new A(i.data.map((a) => a - Math.floor(a)), i.typeInfo);
      const s = i;
      return new I(s.value - Math.floor(s.value), i.typeInfo);
    }
    Frexp(e, t) {
      return console.error(`TODO: frexp. Line ${e.line}`), null;
    }
    InsertBits(e, t) {
      const i = this.exec.evalExpression(e.args[0], t), s = this.exec.evalExpression(e.args[1], t), a = this.exec.evalExpression(e.args[2], t), l = this.exec.evalExpression(e.args[3], t);
      if (a.typeInfo.name !== "u32" && a.typeInfo.name !== "x32") return console.error(`InsertBits() expects an i32 offset argument. Line ${e.line}`), null;
      const u = a.value, h = (1 << l.value) - 1 << u, d = ~h;
      if (i instanceof A && s instanceof A) return new A(i.data.map((y, v) => y & d | s.data[v] << u & h), i.typeInfo);
      const p = i.value, _ = s.value;
      return new I(p & d | _ << u & h, i.typeInfo);
    }
    InverseSqrt(e, t) {
      const i = this.exec.evalExpression(e.args[0], t);
      if (i instanceof A) return new A(i.data.map((a) => 1 / Math.sqrt(a)), i.typeInfo);
      const s = i;
      return new I(1 / Math.sqrt(s.value), i.typeInfo);
    }
    Ldexp(e, t) {
      return console.error(`TODO: ldexp. Line ${e.line}`), null;
    }
    Length(e, t) {
      const i = this.exec.evalExpression(e.args[0], t);
      if (i instanceof A) {
        let a = 0;
        return i.data.forEach((l) => {
          a += l * l;
        }), new I(Math.sqrt(a), this.getTypeInfo("f32"));
      }
      const s = i;
      return new I(Math.abs(s.value), i.typeInfo);
    }
    Log(e, t) {
      const i = this.exec.evalExpression(e.args[0], t);
      if (i instanceof A) return new A(i.data.map((a) => Math.log(a)), i.typeInfo);
      const s = i;
      return new I(Math.log(s.value), i.typeInfo);
    }
    Log2(e, t) {
      const i = this.exec.evalExpression(e.args[0], t);
      if (i instanceof A) return new A(i.data.map((a) => Math.log2(a)), i.typeInfo);
      const s = i;
      return new I(Math.log2(s.value), i.typeInfo);
    }
    Max(e, t) {
      const i = this.exec.evalExpression(e.args[0], t), s = this.exec.evalExpression(e.args[1], t);
      if (i instanceof A && s instanceof A) return new A(i.data.map((u, h) => Math.max(u, s.data[h])), i.typeInfo);
      const a = i, l = s;
      return new I(Math.max(a.value, l.value), i.typeInfo);
    }
    Min(e, t) {
      const i = this.exec.evalExpression(e.args[0], t), s = this.exec.evalExpression(e.args[1], t);
      if (i instanceof A && s instanceof A) return new A(i.data.map((u, h) => Math.min(u, s.data[h])), i.typeInfo);
      const a = i, l = s;
      return new I(Math.min(a.value, l.value), i.typeInfo);
    }
    Mix(e, t) {
      const i = this.exec.evalExpression(e.args[0], t), s = this.exec.evalExpression(e.args[1], t), a = this.exec.evalExpression(e.args[2], t);
      if (i instanceof A && s instanceof A && a instanceof A) return new A(i.data.map((h, d) => i.data[d] * (1 - a.data[d]) + s.data[d] * a.data[d]), i.typeInfo);
      const l = s, u = a;
      return new I(i.value * (1 - u.value) + l.value * u.value, i.typeInfo);
    }
    Modf(e, t) {
      const i = this.exec.evalExpression(e.args[0], t), s = this.exec.evalExpression(e.args[1], t);
      if (i instanceof A && s instanceof A) return new A(i.data.map((l, u) => l % s.data[u]), i.typeInfo);
      const a = s;
      return new I(i.value % a.value, i.typeInfo);
    }
    Normalize(e, t) {
      const i = this.exec.evalExpression(e.args[0], t);
      if (i instanceof A) {
        const s = this.Length(e, t).value;
        return new A(i.data.map((a) => a / s), i.typeInfo);
      }
      return console.error(`Normalize() expects a vector argument. Line ${e.line}`), null;
    }
    Pow(e, t) {
      const i = this.exec.evalExpression(e.args[0], t), s = this.exec.evalExpression(e.args[1], t);
      if (i instanceof A && s instanceof A) return new A(i.data.map((u, h) => Math.pow(u, s.data[h])), i.typeInfo);
      const a = i, l = s;
      return new I(Math.pow(a.value, l.value), i.typeInfo);
    }
    QuantizeToF16(e, t) {
      const i = this.exec.evalExpression(e.args[0], t);
      return i instanceof A ? new A(i.data.map((s) => s), i.typeInfo) : new I(i.value, i.typeInfo);
    }
    Radians(e, t) {
      const i = this.exec.evalExpression(e.args[0], t);
      return i instanceof A ? new A(i.data.map((s) => s * Math.PI / 180), i.typeInfo) : new I(i.value * Math.PI / 180, this.getTypeInfo("f32"));
    }
    Reflect(e, t) {
      let i = this.exec.evalExpression(e.args[0], t), s = this.exec.evalExpression(e.args[1], t);
      if (i instanceof A && s instanceof A) {
        const a = this._dot(i.data, s.data);
        return new A(i.data.map((l, u) => l - 2 * a * s.data[u]), i.typeInfo);
      }
      return console.error(`Reflect() expects vector arguments. Line ${e.line}`), null;
    }
    Refract(e, t) {
      let i = this.exec.evalExpression(e.args[0], t), s = this.exec.evalExpression(e.args[1], t), a = this.exec.evalExpression(e.args[2], t);
      if (i instanceof A && s instanceof A && a instanceof I) {
        const l = this._dot(s.data, i.data);
        return new A(i.data.map((u, h) => {
          const d = 1 - a.value * a.value * (1 - l * l);
          if (d < 0) return 0;
          const p = Math.sqrt(d);
          return a.value * u - (a.value * l + p) * s.data[h];
        }), i.typeInfo);
      }
      return console.error(`Refract() expects vector arguments and a scalar argument. Line ${e.line}`), null;
    }
    ReverseBits(e, t) {
      return console.error(`TODO: reverseBits. Line ${e.line}`), null;
    }
    Round(e, t) {
      const i = this.exec.evalExpression(e.args[0], t);
      if (i instanceof A) return new A(i.data.map((a) => Math.round(a)), i.typeInfo);
      const s = i;
      return new I(Math.round(s.value), i.typeInfo);
    }
    Saturate(e, t) {
      const i = this.exec.evalExpression(e.args[0], t);
      if (i instanceof A) return new A(i.data.map((a) => Math.min(Math.max(a, 0), 1)), i.typeInfo);
      const s = i;
      return new I(Math.min(Math.max(s.value, 0), 1), i.typeInfo);
    }
    Sign(e, t) {
      const i = this.exec.evalExpression(e.args[0], t);
      if (i instanceof A) return new A(i.data.map((a) => Math.sign(a)), i.typeInfo);
      const s = i;
      return new I(Math.sign(s.value), i.typeInfo);
    }
    Sin(e, t) {
      const i = this.exec.evalExpression(e.args[0], t);
      if (i instanceof A) return new A(i.data.map((a) => Math.sin(a)), i.typeInfo);
      const s = i;
      return new I(Math.sin(s.value), i.typeInfo);
    }
    Sinh(e, t) {
      const i = this.exec.evalExpression(e.args[0], t);
      if (i instanceof A) return new A(i.data.map((a) => Math.sinh(a)), i.typeInfo);
      const s = i;
      return new I(Math.sinh(s.value), i.typeInfo);
    }
    _smoothstep(e, t, i) {
      const s = Math.min(Math.max((i - e) / (t - e), 0), 1);
      return s * s * (3 - 2 * s);
    }
    SmoothStep(e, t) {
      const i = this.exec.evalExpression(e.args[0], t), s = this.exec.evalExpression(e.args[1], t), a = this.exec.evalExpression(e.args[2], t);
      if (a instanceof A && i instanceof A && s instanceof A) return new A(a.data.map((d, p) => this._smoothstep(i.data[p], s.data[p], d)), a.typeInfo);
      const l = i, u = s, h = a;
      return new I(this._smoothstep(l.value, u.value, h.value), a.typeInfo);
    }
    Sqrt(e, t) {
      const i = this.exec.evalExpression(e.args[0], t);
      if (i instanceof A) return new A(i.data.map((a) => Math.sqrt(a)), i.typeInfo);
      const s = i;
      return new I(Math.sqrt(s.value), i.typeInfo);
    }
    Step(e, t) {
      const i = this.exec.evalExpression(e.args[0], t), s = this.exec.evalExpression(e.args[1], t);
      if (s instanceof A && i instanceof A) return new A(s.data.map((l, u) => l < i.data[u] ? 0 : 1), s.typeInfo);
      const a = i;
      return new I(s.value < a.value ? 0 : 1, a.typeInfo);
    }
    Tan(e, t) {
      const i = this.exec.evalExpression(e.args[0], t);
      if (i instanceof A) return new A(i.data.map((a) => Math.tan(a)), i.typeInfo);
      const s = i;
      return new I(Math.tan(s.value), i.typeInfo);
    }
    Tanh(e, t) {
      const i = this.exec.evalExpression(e.args[0], t);
      if (i instanceof A) return new A(i.data.map((a) => Math.tanh(a)), i.typeInfo);
      const s = i;
      return new I(Math.tanh(s.value), i.typeInfo);
    }
    _getTransposeType(e) {
      const t = e.getTypeName();
      return t === "mat2x2f" || t === "mat2x2h" ? e : t === "mat2x3f" ? this.getTypeInfo("mat3x2f") : t === "mat2x3h" ? this.getTypeInfo("mat3x2h") : t === "mat2x4f" ? this.getTypeInfo("mat4x2f") : t === "mat2x4h" ? this.getTypeInfo("mat4x2h") : t === "mat3x2f" ? this.getTypeInfo("mat2x3f") : t === "mat3x2h" ? this.getTypeInfo("mat2x3h") : t === "mat3x3f" || t === "mat3x3h" ? e : t === "mat3x4f" ? this.getTypeInfo("mat4x3f") : t === "mat3x4h" ? this.getTypeInfo("mat4x3h") : t === "mat4x2f" ? this.getTypeInfo("mat2x4f") : t === "mat4x2h" ? this.getTypeInfo("mat2x4h") : t === "mat4x3f" ? this.getTypeInfo("mat3x4f") : t === "mat4x3h" ? this.getTypeInfo("mat3x4h") : (t === "mat4x4f" || t === "mat4x4h" || console.error(`Invalid matrix type ${t}`), e);
    }
    Transpose(e, t) {
      const i = this.exec.evalExpression(e.args[0], t);
      if (!(i instanceof _e)) return console.error(`Transpose() expects a matrix argument. Line ${e.line}`), null;
      const s = this._getTransposeType(i.typeInfo);
      if (i.typeInfo.name === "mat2x2" || i.typeInfo.name === "mat2x2f" || i.typeInfo.name === "mat2x2h") {
        const a = i.data;
        return new _e([
          a[0],
          a[2],
          a[1],
          a[3]
        ], s);
      }
      if (i.typeInfo.name === "mat2x3" || i.typeInfo.name === "mat2x3f" || i.typeInfo.name === "mat2x3h") {
        const a = i.data;
        return new _e([
          a[0],
          a[3],
          a[6],
          a[1],
          a[4],
          a[7]
        ], s);
      }
      if (i.typeInfo.name === "mat2x4" || i.typeInfo.name === "mat2x4f" || i.typeInfo.name === "mat2x4h") {
        const a = i.data;
        return new _e([
          a[0],
          a[4],
          a[8],
          a[12],
          a[1],
          a[5],
          a[9],
          a[13]
        ], s);
      }
      if (i.typeInfo.name === "mat3x2" || i.typeInfo.name === "mat3x2f" || i.typeInfo.name === "mat3x2h") {
        const a = i.data;
        return new _e([
          a[0],
          a[3],
          a[1],
          a[4],
          a[2],
          a[5]
        ], s);
      }
      if (i.typeInfo.name === "mat3x3" || i.typeInfo.name === "mat3x3f" || i.typeInfo.name === "mat3x3h") {
        const a = i.data;
        return new _e([
          a[0],
          a[3],
          a[6],
          a[1],
          a[4],
          a[7],
          a[2],
          a[5],
          a[8]
        ], s);
      }
      if (i.typeInfo.name === "mat3x4" || i.typeInfo.name === "mat3x4f" || i.typeInfo.name === "mat3x4h") {
        const a = i.data;
        return new _e([
          a[0],
          a[4],
          a[8],
          a[12],
          a[1],
          a[5],
          a[9],
          a[13],
          a[2],
          a[6],
          a[10],
          a[14]
        ], s);
      }
      if (i.typeInfo.name === "mat4x2" || i.typeInfo.name === "mat4x2f" || i.typeInfo.name === "mat4x2h") {
        const a = i.data;
        return new _e([
          a[0],
          a[4],
          a[1],
          a[5],
          a[2],
          a[6]
        ], s);
      }
      if (i.typeInfo.name === "mat4x3" || i.typeInfo.name === "mat4x3f" || i.typeInfo.name === "mat4x3h") {
        const a = i.data;
        return new _e([
          a[0],
          a[4],
          a[8],
          a[1],
          a[5],
          a[9],
          a[2],
          a[6],
          a[10]
        ], s);
      }
      if (i.typeInfo.name === "mat4x4" || i.typeInfo.name === "mat4x4f" || i.typeInfo.name === "mat4x4h") {
        const a = i.data;
        return new _e([
          a[0],
          a[4],
          a[8],
          a[12],
          a[1],
          a[5],
          a[9],
          a[13],
          a[2],
          a[6],
          a[10],
          a[14],
          a[3],
          a[7],
          a[11],
          a[15]
        ], s);
      }
      return console.error(`Invalid matrix type ${i.typeInfo.name}`), null;
    }
    Trunc(e, t) {
      const i = this.exec.evalExpression(e.args[0], t);
      if (i instanceof A) return new A(i.data.map((a) => Math.trunc(a)), i.typeInfo);
      const s = i;
      return new I(Math.trunc(s.value), i.typeInfo);
    }
    Dpdx(e, t) {
      return console.error(`TODO: dpdx. Line ${e.line}`), null;
    }
    DpdxCoarse(e, t) {
      return console.error(`TODO: dpdxCoarse. Line ${e.line}`), null;
    }
    DpdxFine(e, t) {
      return console.error("TODO: dpdxFine"), null;
    }
    Dpdy(e, t) {
      return console.error("TODO: dpdy"), null;
    }
    DpdyCoarse(e, t) {
      return console.error("TODO: dpdyCoarse"), null;
    }
    DpdyFine(e, t) {
      return console.error("TODO: dpdyFine"), null;
    }
    Fwidth(e, t) {
      return console.error("TODO: fwidth"), null;
    }
    FwidthCoarse(e, t) {
      return console.error("TODO: fwidthCoarse"), null;
    }
    FwidthFine(e, t) {
      return console.error("TODO: fwidthFine"), null;
    }
    TextureDimensions(e, t) {
      const i = e.args[0], s = e.args.length > 1 ? this.exec.evalExpression(e.args[1], t).value : 0;
      if (i instanceof en) {
        const a = i.name, l = t.getVariableValue(a);
        if (l instanceof ri) {
          if (s < 0 || s >= l.mipLevelCount) return console.error(`Invalid mip level for textureDimensions. Line ${e.line}`), null;
          const u = l.getMipLevelSize(s), h = l.dimension;
          return h === "1d" ? new I(u[0], this.getTypeInfo("u32")) : h === "3d" ? new A(u, this.getTypeInfo("vec3u")) : h === "2d" ? new A(u.slice(0, 2), this.getTypeInfo("vec2u")) : (console.error(`Invalid texture dimension ${h} not found. Line ${e.line}`), null);
        }
        return console.error(`Texture ${a} not found. Line ${e.line}`), null;
      }
      return console.error(`Invalid texture argument for textureDimensions. Line ${e.line}`), null;
    }
    TextureGather(e, t) {
      return console.error("TODO: textureGather"), null;
    }
    TextureGatherCompare(e, t) {
      return console.error("TODO: textureGatherCompare"), null;
    }
    TextureLoad(e, t) {
      const i = e.args[0], s = this.exec.evalExpression(e.args[1], t), a = e.args.length > 2 ? this.exec.evalExpression(e.args[2], t).value : 0;
      if (!(s instanceof A) || s.data.length !== 2) return console.error(`Invalid UV argument for textureLoad. Line ${e.line}`), null;
      if (i instanceof en) {
        const l = i.name, u = t.getVariableValue(l);
        if (u instanceof ri) {
          const h = Math.floor(s.data[0]), d = Math.floor(s.data[1]);
          if (h < 0 || h >= u.width || d < 0 || d >= u.height) return console.error(`Texture ${l} out of bounds. Line ${e.line}`), null;
          const p = u.getPixel(h, d, 0, a);
          return p === null ? (console.error(`Invalid texture format for textureLoad. Line ${e.line}`), null) : new A(p, this.getTypeInfo("vec4f"));
        }
        return console.error(`Texture ${l} not found. Line ${e.line}`), null;
      }
      return console.error(`Invalid texture argument for textureLoad. Line ${e.line}`), null;
    }
    TextureNumLayers(e, t) {
      const i = e.args[0];
      if (i instanceof en) {
        const s = i.name, a = t.getVariableValue(s);
        return a instanceof ri ? new I(a.depthOrArrayLayers, this.getTypeInfo("u32")) : (console.error(`Texture ${s} not found. Line ${e.line}`), null);
      }
      return console.error(`Invalid texture argument for textureNumLayers. Line ${e.line}`), null;
    }
    TextureNumLevels(e, t) {
      const i = e.args[0];
      if (i instanceof en) {
        const s = i.name, a = t.getVariableValue(s);
        return a instanceof ri ? new I(a.mipLevelCount, this.getTypeInfo("u32")) : (console.error(`Texture ${s} not found. Line ${e.line}`), null);
      }
      return console.error(`Invalid texture argument for textureNumLevels. Line ${e.line}`), null;
    }
    TextureNumSamples(e, t) {
      const i = e.args[0];
      if (i instanceof en) {
        const s = i.name, a = t.getVariableValue(s);
        return a instanceof ri ? new I(a.sampleCount, this.getTypeInfo("u32")) : (console.error(`Texture ${s} not found. Line ${e.line}`), null);
      }
      return console.error(`Invalid texture argument for textureNumSamples. Line ${e.line}`), null;
    }
    TextureSample(e, t) {
      return console.error("TODO: textureSample"), null;
    }
    TextureSampleBias(e, t) {
      return console.error("TODO: textureSampleBias"), null;
    }
    TextureSampleCompare(e, t) {
      return console.error("TODO: textureSampleCompare"), null;
    }
    TextureSampleCompareLevel(e, t) {
      return console.error("TODO: textureSampleCompareLevel"), null;
    }
    TextureSampleGrad(e, t) {
      return console.error("TODO: textureSampleGrad"), null;
    }
    TextureSampleLevel(e, t) {
      return console.error("TODO: textureSampleLevel"), null;
    }
    TextureSampleBaseClampToEdge(e, t) {
      return console.error("TODO: textureSampleBaseClampToEdge"), null;
    }
    TextureStore(e, t) {
      const i = e.args[0], s = this.exec.evalExpression(e.args[1], t), a = e.args.length === 4 ? this.exec.evalExpression(e.args[2], t).value : 0, l = e.args.length === 4 ? this.exec.evalExpression(e.args[3], t).data : this.exec.evalExpression(e.args[2], t).data;
      if (l.length !== 4) return console.error(`Invalid value argument for textureStore. Line ${e.line}`), null;
      if (!(s instanceof A) || s.data.length !== 2) return console.error(`Invalid UV argument for textureStore. Line ${e.line}`), null;
      if (i instanceof en) {
        const u = i.name, h = t.getVariableValue(u);
        if (h instanceof ri) {
          const d = h.getMipLevelSize(0), p = Math.floor(s.data[0]), _ = Math.floor(s.data[1]);
          return p < 0 || p >= d[0] || _ < 0 || _ >= d[1] ? (console.error(`Texture ${u} out of bounds. Line ${e.line}`), null) : (h.setPixel(p, _, 0, a, Array.from(l)), null);
        }
        return console.error(`Texture ${u} not found. Line ${e.line}`), null;
      }
      return console.error(`Invalid texture argument for textureStore. Line ${e.line}`), null;
    }
    AtomicLoad(e, t) {
      let i = e.args[0];
      i instanceof ct && (i = i.right);
      const s = this.exec.getVariableName(i, t);
      return t.getVariable(s).value.getSubData(this.exec, i.postfix, t);
    }
    AtomicStore(e, t) {
      let i = e.args[0];
      i instanceof ct && (i = i.right);
      const s = this.exec.getVariableName(i, t), a = t.getVariable(s);
      let l = e.args[1];
      const u = this.exec.evalExpression(l, t), h = a.value.getSubData(this.exec, i.postfix, t);
      return h instanceof I && u instanceof I && (h.value = u.value), a.value instanceof it && a.value.setDataValue(this.exec, h, i.postfix, t), null;
    }
    AtomicAdd(e, t) {
      let i = e.args[0];
      i instanceof ct && (i = i.right);
      const s = this.exec.getVariableName(i, t), a = t.getVariable(s);
      let l = e.args[1];
      const u = this.exec.evalExpression(l, t), h = a.value.getSubData(this.exec, i.postfix, t), d = new I(h.value, h.typeInfo);
      return h instanceof I && u instanceof I && (h.value += u.value), a.value instanceof it && a.value.setDataValue(this.exec, h, i.postfix, t), d;
    }
    AtomicSub(e, t) {
      let i = e.args[0];
      i instanceof ct && (i = i.right);
      const s = this.exec.getVariableName(i, t), a = t.getVariable(s);
      let l = e.args[1];
      const u = this.exec.evalExpression(l, t), h = a.value.getSubData(this.exec, i.postfix, t), d = new I(h.value, h.typeInfo);
      return h instanceof I && u instanceof I && (h.value -= u.value), a.value instanceof it && a.value.setDataValue(this.exec, h, i.postfix, t), d;
    }
    AtomicMax(e, t) {
      let i = e.args[0];
      i instanceof ct && (i = i.right);
      const s = this.exec.getVariableName(i, t), a = t.getVariable(s);
      let l = e.args[1];
      const u = this.exec.evalExpression(l, t), h = a.value.getSubData(this.exec, i.postfix, t), d = new I(h.value, h.typeInfo);
      return h instanceof I && u instanceof I && (h.value = Math.max(h.value, u.value)), a.value instanceof it && a.value.setDataValue(this.exec, h, i.postfix, t), d;
    }
    AtomicMin(e, t) {
      let i = e.args[0];
      i instanceof ct && (i = i.right);
      const s = this.exec.getVariableName(i, t), a = t.getVariable(s);
      let l = e.args[1];
      const u = this.exec.evalExpression(l, t), h = a.value.getSubData(this.exec, i.postfix, t), d = new I(h.value, h.typeInfo);
      return h instanceof I && u instanceof I && (h.value = Math.min(h.value, u.value)), a.value instanceof it && a.value.setDataValue(this.exec, h, i.postfix, t), d;
    }
    AtomicAnd(e, t) {
      let i = e.args[0];
      i instanceof ct && (i = i.right);
      const s = this.exec.getVariableName(i, t), a = t.getVariable(s);
      let l = e.args[1];
      const u = this.exec.evalExpression(l, t), h = a.value.getSubData(this.exec, i.postfix, t), d = new I(h.value, h.typeInfo);
      return h instanceof I && u instanceof I && (h.value = h.value & u.value), a.value instanceof it && a.value.setDataValue(this.exec, h, i.postfix, t), d;
    }
    AtomicOr(e, t) {
      let i = e.args[0];
      i instanceof ct && (i = i.right);
      const s = this.exec.getVariableName(i, t), a = t.getVariable(s);
      let l = e.args[1];
      const u = this.exec.evalExpression(l, t), h = a.value.getSubData(this.exec, i.postfix, t), d = new I(h.value, h.typeInfo);
      return h instanceof I && u instanceof I && (h.value = h.value | u.value), a.value instanceof it && a.value.setDataValue(this.exec, h, i.postfix, t), d;
    }
    AtomicXor(e, t) {
      let i = e.args[0];
      i instanceof ct && (i = i.right);
      const s = this.exec.getVariableName(i, t), a = t.getVariable(s);
      let l = e.args[1];
      const u = this.exec.evalExpression(l, t), h = a.value.getSubData(this.exec, i.postfix, t), d = new I(h.value, h.typeInfo);
      return h instanceof I && u instanceof I && (h.value = h.value ^ u.value), a.value instanceof it && a.value.setDataValue(this.exec, h, i.postfix, t), d;
    }
    AtomicExchange(e, t) {
      let i = e.args[0];
      i instanceof ct && (i = i.right);
      const s = this.exec.getVariableName(i, t), a = t.getVariable(s);
      let l = e.args[1];
      const u = this.exec.evalExpression(l, t), h = a.value.getSubData(this.exec, i.postfix, t), d = new I(h.value, h.typeInfo);
      return h instanceof I && u instanceof I && (h.value = u.value), a.value instanceof it && a.value.setDataValue(this.exec, h, i.postfix, t), d;
    }
    AtomicCompareExchangeWeak(e, t) {
      return console.error("TODO: atomicCompareExchangeWeak"), null;
    }
    Pack4x8snorm(e, t) {
      return console.error("TODO: pack4x8snorm"), null;
    }
    Pack4x8unorm(e, t) {
      return console.error("TODO: pack4x8unorm"), null;
    }
    Pack4xI8(e, t) {
      return console.error("TODO: pack4xI8"), null;
    }
    Pack4xU8(e, t) {
      return console.error("TODO: pack4xU8"), null;
    }
    Pack4x8Clamp(e, t) {
      return console.error("TODO: pack4x8Clamp"), null;
    }
    Pack4xU8Clamp(e, t) {
      return console.error("TODO: pack4xU8Clamp"), null;
    }
    Pack2x16snorm(e, t) {
      return console.error("TODO: pack2x16snorm"), null;
    }
    Pack2x16unorm(e, t) {
      return console.error("TODO: pack2x16unorm"), null;
    }
    Pack2x16float(e, t) {
      return console.error("TODO: pack2x16float"), null;
    }
    Unpack4x8snorm(e, t) {
      return console.error("TODO: unpack4x8snorm"), null;
    }
    Unpack4x8unorm(e, t) {
      return console.error("TODO: unpack4x8unorm"), null;
    }
    Unpack4xI8(e, t) {
      return console.error("TODO: unpack4xI8"), null;
    }
    Unpack4xU8(e, t) {
      return console.error("TODO: unpack4xU8"), null;
    }
    Unpack2x16snorm(e, t) {
      return console.error("TODO: unpack2x16snorm"), null;
    }
    Unpack2x16unorm(e, t) {
      return console.error("TODO: unpack2x16unorm"), null;
    }
    Unpack2x16float(e, t) {
      return console.error("TODO: unpack2x16float"), null;
    }
    StorageBarrier(e, t) {
      return null;
    }
    TextureBarrier(e, t) {
      return null;
    }
    WorkgroupBarrier(e, t) {
      return null;
    }
    WorkgroupUniformLoad(e, t) {
      return null;
    }
    SubgroupAdd(e, t) {
      return console.error("TODO: subgroupAdd"), null;
    }
    SubgroupExclusiveAdd(e, t) {
      return console.error("TODO: subgroupExclusiveAdd"), null;
    }
    SubgroupInclusiveAdd(e, t) {
      return console.error("TODO: subgroupInclusiveAdd"), null;
    }
    SubgroupAll(e, t) {
      return console.error("TODO: subgroupAll"), null;
    }
    SubgroupAnd(e, t) {
      return console.error("TODO: subgroupAnd"), null;
    }
    SubgroupAny(e, t) {
      return console.error("TODO: subgroupAny"), null;
    }
    SubgroupBallot(e, t) {
      return console.error("TODO: subgroupBallot"), null;
    }
    SubgroupBroadcast(e, t) {
      return console.error("TODO: subgroupBroadcast"), null;
    }
    SubgroupBroadcastFirst(e, t) {
      return console.error("TODO: subgroupBroadcastFirst"), null;
    }
    SubgroupElect(e, t) {
      return console.error("TODO: subgroupElect"), null;
    }
    SubgroupMax(e, t) {
      return console.error("TODO: subgroupMax"), null;
    }
    SubgroupMin(e, t) {
      return console.error("TODO: subgroupMin"), null;
    }
    SubgroupMul(e, t) {
      return console.error("TODO: subgroupMul"), null;
    }
    SubgroupExclusiveMul(e, t) {
      return console.error("TODO: subgroupExclusiveMul"), null;
    }
    SubgroupInclusiveMul(e, t) {
      return console.error("TODO: subgroupInclusiveMul"), null;
    }
    SubgroupOr(e, t) {
      return console.error("TODO: subgroupOr"), null;
    }
    SubgroupShuffle(e, t) {
      return console.error("TODO: subgroupShuffle"), null;
    }
    SubgroupShuffleDown(e, t) {
      return console.error("TODO: subgroupShuffleDown"), null;
    }
    SubgroupShuffleUp(e, t) {
      return console.error("TODO: subgroupShuffleUp"), null;
    }
    SubgroupShuffleXor(e, t) {
      return console.error("TODO: subgroupShuffleXor"), null;
    }
    SubgroupXor(e, t) {
      return console.error("TODO: subgroupXor"), null;
    }
    QuadBroadcast(e, t) {
      return console.error("TODO: quadBroadcast"), null;
    }
    QuadSwapDiagonal(e, t) {
      return console.error("TODO: quadSwapDiagonal"), null;
    }
    QuadSwapX(e, t) {
      return console.error("TODO: quadSwapX"), null;
    }
    QuadSwapY(e, t) {
      return console.error("TODO: quadSwapY"), null;
    }
  }
  const Vh = {
    vec2: 2,
    vec2f: 2,
    vec2i: 2,
    vec2u: 2,
    vec2b: 2,
    vec2h: 2,
    vec3: 3,
    vec3f: 3,
    vec3i: 3,
    vec3u: 3,
    vec3b: 3,
    vec3h: 3,
    vec4: 4,
    vec4f: 4,
    vec4i: 4,
    vec4u: 4,
    vec4b: 4,
    vec4h: 4
  }, Pt = {
    mat2x2: [
      2,
      2,
      4
    ],
    mat2x2f: [
      2,
      2,
      4
    ],
    mat2x2h: [
      2,
      2,
      4
    ],
    mat2x3: [
      2,
      3,
      6
    ],
    mat2x3f: [
      2,
      3,
      6
    ],
    mat2x3h: [
      2,
      3,
      6
    ],
    mat2x4: [
      2,
      4,
      8
    ],
    mat2x4f: [
      2,
      4,
      8
    ],
    mat2x4h: [
      2,
      4,
      8
    ],
    mat3x2: [
      3,
      2,
      6
    ],
    mat3x2f: [
      3,
      2,
      6
    ],
    mat3x2h: [
      3,
      2,
      6
    ],
    mat3x3: [
      3,
      3,
      9
    ],
    mat3x3f: [
      3,
      3,
      9
    ],
    mat3x3h: [
      3,
      3,
      9
    ],
    mat3x4: [
      3,
      4,
      12
    ],
    mat3x4f: [
      3,
      4,
      12
    ],
    mat3x4h: [
      3,
      4,
      12
    ],
    mat4x2: [
      4,
      2,
      8
    ],
    mat4x2f: [
      4,
      2,
      8
    ],
    mat4x2h: [
      4,
      2,
      8
    ],
    mat4x3: [
      4,
      3,
      12
    ],
    mat4x3f: [
      4,
      3,
      12
    ],
    mat4x3h: [
      4,
      3,
      12
    ],
    mat4x4: [
      4,
      4,
      16
    ],
    mat4x4f: [
      4,
      4,
      16
    ],
    mat4x4h: [
      4,
      4,
      16
    ]
  };
  class Mt extends fC {
    constructor(e, t) {
      var i;
      super(), this.ast = e ?? [], this.reflection = new Un(), this.reflection.updateAST(this.ast), this.context = (i = t == null ? void 0 : t.clone()) !== null && i !== void 0 ? i : new xg(), this.builtins = new hC(this), this.typeInfo = {
        bool: this.getTypeInfo(q.bool),
        i32: this.getTypeInfo(q.i32),
        u32: this.getTypeInfo(q.u32),
        f32: this.getTypeInfo(q.f32),
        f16: this.getTypeInfo(q.f16),
        vec2f: this.getTypeInfo(k.vec2f),
        vec2u: this.getTypeInfo(k.vec2u),
        vec2i: this.getTypeInfo(k.vec2i),
        vec2h: this.getTypeInfo(k.vec2h),
        vec3f: this.getTypeInfo(k.vec3f),
        vec3u: this.getTypeInfo(k.vec3u),
        vec3i: this.getTypeInfo(k.vec3i),
        vec3h: this.getTypeInfo(k.vec3h),
        vec4f: this.getTypeInfo(k.vec4f),
        vec4u: this.getTypeInfo(k.vec4u),
        vec4i: this.getTypeInfo(k.vec4i),
        vec4h: this.getTypeInfo(k.vec4h),
        mat2x2f: this.getTypeInfo(k.mat2x2f),
        mat2x3f: this.getTypeInfo(k.mat2x3f),
        mat2x4f: this.getTypeInfo(k.mat2x4f),
        mat3x2f: this.getTypeInfo(k.mat3x2f),
        mat3x3f: this.getTypeInfo(k.mat3x3f),
        mat3x4f: this.getTypeInfo(k.mat3x4f),
        mat4x2f: this.getTypeInfo(k.mat4x2f),
        mat4x3f: this.getTypeInfo(k.mat4x3f),
        mat4x4f: this.getTypeInfo(k.mat4x4f)
      };
    }
    getVariableValue(e) {
      var t, i;
      const s = (i = (t = this.context.getVariable(e)) === null || t === void 0 ? void 0 : t.value) !== null && i !== void 0 ? i : null;
      if (s === null) return null;
      if (s instanceof I) return s.value;
      if (s instanceof A || s instanceof _e) return Array.from(s.data);
      if (s instanceof it && s.typeInfo instanceof $i) {
        if (s.typeInfo.format.name === "u32") return Array.from(new Uint32Array(s.buffer, s.offset, s.typeInfo.count));
        if (s.typeInfo.format.name === "i32") return Array.from(new Int32Array(s.buffer, s.offset, s.typeInfo.count));
        if (s.typeInfo.format.name === "f32") return Array.from(new Float32Array(s.buffer, s.offset, s.typeInfo.count));
      }
      return console.error(`Unsupported return variable type ${s.typeInfo.name}`), null;
    }
    execute(e) {
      (e = e ?? {}).constants && this._setOverrides(e.constants, this.context), this._execStatements(this.ast, this.context);
    }
    dispatchWorkgroups(e, t, i, s) {
      const a = this.context.clone();
      (s = s ?? {}).constants && this._setOverrides(s.constants, a), this._execStatements(this.ast, a);
      const l = a.getFunction(e);
      if (!l) return void console.error(`Function ${e} not found`);
      if (typeof t == "number") t = [
        t,
        1,
        1
      ];
      else {
        if (t.length === 0) return void console.error("Invalid dispatch count");
        t.length === 1 ? t = [
          t[0],
          1,
          1
        ] : t.length === 2 ? t = [
          t[0],
          t[1],
          1
        ] : t.length > 3 && (t = [
          t[0],
          t[1],
          t[2]
        ]);
      }
      const u = t[0], h = t[1], d = t[2], p = this.getTypeInfo("vec3u");
      a.setVariable("@num_workgroups", new A(t, p));
      for (const _ in i) for (const y in i[_]) {
        const v = i[_][y];
        a.variables.forEach((S) => {
          var E;
          const M = S.node;
          if (M == null ? void 0 : M.attributes) {
            let F = null, H = null;
            for (const O of M.attributes) O.name === "binding" ? F = O.value : O.name === "group" && (H = O.value);
            if (y == F && _ == H) if (v.texture !== void 0 && v.descriptor !== void 0) {
              const O = new ri(v.texture, this.getTypeInfo(M.type), v.descriptor, (E = v.texture.view) !== null && E !== void 0 ? E : null);
              S.value = O;
            } else v.uniform !== void 0 ? S.value = new it(v.uniform, this.getTypeInfo(M.type)) : S.value = new it(v, this.getTypeInfo(M.type));
          }
        });
      }
      for (let _ = 0; _ < d; ++_) for (let y = 0; y < h; ++y) for (let v = 0; v < u; ++v) a.setVariable("@workgroup_id", new A([
        v,
        y,
        _
      ], this.getTypeInfo("vec3u"))), this._dispatchWorkgroup(l, [
        v,
        y,
        _
      ], a);
    }
    execStatement(e, t) {
      if (e instanceof $3) return this.evalExpression(e.value, t);
      if (e instanceof Y3) {
        if (e.condition) {
          const i = this.evalExpression(e.condition, t);
          if (!(i instanceof I)) throw new Error("Invalid break-if condition");
          if (!i.value) return null;
        }
        return Mt._breakObj;
      }
      if (e instanceof q3) return Mt._continueObj;
      if (e instanceof lo) this._let(e, t);
      else if (e instanceof ai) this._var(e, t);
      else if (e instanceof lc) this._const(e, t);
      else if (e instanceof mo) this._function(e, t);
      else {
        if (e instanceof W3) return this._if(e, t);
        if (e instanceof j3) return this._switch(e, t);
        if (e instanceof F3) return this._for(e, t);
        if (e instanceof L3) return this._while(e, t);
        if (e instanceof H3) return this._loop(e, t);
        if (e instanceof xd) {
          const i = t.clone();
          return i.currentFunctionName = t.currentFunctionName, this._execStatements(e.body, i);
        }
        if (e instanceof z3) this._assign(e, t);
        else if (e instanceof V3) this._increment(e, t);
        else {
          if (e instanceof si) return null;
          if (e instanceof mg) {
            const i = e.name;
            t.getVariable(i) === null && t.setVariable(i, new I(0, this.getTypeInfo("u32")));
          } else if (e instanceof _g) this._call(e, t);
          else {
            if (e instanceof X3 || e instanceof yg) return null;
            console.error("Invalid statement type.", e, `Line ${e.line}`);
          }
        }
      }
      return null;
    }
    evalExpression(e, t) {
      return e instanceof xn ? this._evalBinaryOp(e, t) : e instanceof dt ? this._evalLiteral(e, t) : e instanceof en ? this._evalVariable(e, t) : e instanceof bg ? this._evalCall(e, t) : e instanceof Pn ? this._evalCreate(e, t) : e instanceof K3 ? this._evalConst(e, t) : e instanceof Z3 ? this._evalBitcast(e, t) : e instanceof ct ? this._evalUnaryOp(e, t) : (console.error("Invalid expression type", e, `Line ${e.line}`), null);
    }
    getTypeInfo(e) {
      var t;
      if (e instanceof q) {
        const s = this.reflection.getTypeInfo(e);
        if (s !== null) return s;
      }
      let i = (t = this.typeInfo[e]) !== null && t !== void 0 ? t : null;
      return i !== null || (i = this.reflection.getTypeInfoByName(e)), i;
    }
    _setOverrides(e, t) {
      for (const i in e) {
        const s = e[i], a = this.reflection.getOverrideInfo(i);
        a !== null ? (a.type === null && (a.type = this.getTypeInfo("u32")), a.type.name === "u32" || a.type.name === "i32" || a.type.name === "f32" || a.type.name === "f16" ? t.setVariable(i, new I(s, a.type)) : a.type.name === "bool" ? t.setVariable(i, new I(s ? 1 : 0, a.type)) : a.type.name === "vec2" || a.type.name === "vec3" || a.type.name === "vec4" || a.type.name === "vec2f" || a.type.name === "vec3f" || a.type.name === "vec4f" || a.type.name === "vec2i" || a.type.name === "vec3i" || a.type.name === "vec4i" || a.type.name === "vec2u" || a.type.name === "vec3u" || a.type.name === "vec4u" || a.type.name === "vec2h" || a.type.name === "vec3h" || a.type.name === "vec4h" ? t.setVariable(i, new A(s, a.type)) : console.error(`Invalid constant type for ${i}`)) : console.error(`Override ${i} does not exist in the shader.`);
      }
    }
    _dispatchWorkgroup(e, t, i) {
      const s = [
        1,
        1,
        1
      ];
      for (const p of e.node.attributes) if (p.name === "workgroup_size") {
        if (p.value.length > 0) {
          const _ = i.getVariableValue(p.value[0]);
          s[0] = _ instanceof I ? _.value : parseInt(p.value[0]);
        }
        if (p.value.length > 1) {
          const _ = i.getVariableValue(p.value[1]);
          s[1] = _ instanceof I ? _.value : parseInt(p.value[1]);
        }
        if (p.value.length > 2) {
          const _ = i.getVariableValue(p.value[2]);
          s[2] = _ instanceof I ? _.value : parseInt(p.value[2]);
        }
      }
      const a = this.getTypeInfo("vec3u"), l = this.getTypeInfo("u32");
      i.setVariable("@workgroup_size", new A(s, a));
      const u = s[0], h = s[1], d = s[2];
      for (let p = 0, _ = 0; p < d; ++p) for (let y = 0; y < h; ++y) for (let v = 0; v < u; ++v, ++_) {
        const S = [
          v,
          y,
          p
        ], E = [
          v + t[0] * s[0],
          y + t[1] * s[1],
          p + t[2] * s[2]
        ];
        i.setVariable("@local_invocation_id", new A(S, a)), i.setVariable("@global_invocation_id", new A(E, a)), i.setVariable("@local_invocation_index", new I(_, l)), this._dispatchExec(e, i);
      }
    }
    _dispatchExec(e, t) {
      for (const i of e.node.args) for (const s of i.attributes) if (s.name === "builtin") {
        const a = `@${s.value}`, l = t.getVariable(a);
        l !== void 0 && t.variables.set(i.name, l);
      }
      this._execStatements(e.node.body, t);
    }
    getVariableName(e, t) {
      for (; e instanceof ct; ) e = e.right;
      return e instanceof en ? e.name : (console.error("Unknown variable type", e, "Line", e.line), null);
    }
    _execStatements(e, t) {
      for (const i of e) {
        if (i instanceof Array) {
          const a = t.clone(), l = this._execStatements(i, a);
          if (l) return l;
          continue;
        }
        const s = this.execStatement(i, t);
        if (s) return s;
      }
      return null;
    }
    _call(e, t) {
      const i = t.clone();
      i.currentFunctionName = e.name;
      const s = t.getFunction(e.name);
      if (s) {
        for (let a = 0; a < s.node.args.length; ++a) {
          const l = s.node.args[a], u = this.evalExpression(e.args[a], i);
          i.setVariable(l.name, u, l);
        }
        this._execStatements(s.node.body, i);
      } else e.isBuiltin ? this._callBuiltinFunction(e, i) : this.getTypeInfo(e.name) && this._evalCreate(e, t);
    }
    _increment(e, t) {
      const i = this.getVariableName(e.variable, t), s = t.getVariable(i);
      s ? e.operator === "++" ? s.value instanceof I ? s.value.value++ : console.error(`Variable ${i} is not a scalar. Line ${e.line}`) : e.operator === "--" ? s.value instanceof I ? s.value.value-- : console.error(`Variable ${i} is not a scalar. Line ${e.line}`) : console.error(`Unknown increment operator ${e.operator}. Line ${e.line}`) : console.error(`Variable ${i} not found. Line ${e.line}`);
    }
    _getVariableData(e, t) {
      if (e instanceof en) {
        const i = this.getVariableName(e, t), s = t.getVariable(i);
        return s === null ? (console.error(`Variable ${i} not found. Line ${e.line}`), null) : s.value.getSubData(this, e.postfix, t);
      }
      if (e instanceof ct) {
        if (e.operator === "*") {
          const i = this._getVariableData(e.right, t);
          return i instanceof Sr ? i.reference.getSubData(this, e.postfix, t) : (console.error(`Variable ${e.right} is not a pointer. Line ${e.line}`), null);
        }
        if (e.operator === "&") {
          const i = this._getVariableData(e.right, t);
          return new Sr(i);
        }
      }
      return null;
    }
    _assign(e, t) {
      let i = null, s = "<var>", a = null;
      if (e.variable instanceof ct) {
        const h = this._getVariableData(e.variable, t), d = this.evalExpression(e.value, t), p = e.operator;
        if (p === "=") {
          if (h instanceof I || h instanceof A || h instanceof _e) {
            if (d instanceof I || d instanceof A || d instanceof _e && h.data.length === d.data.length) return void h.data.set(d.data);
            console.error(`Invalid assignment. Line ${e.line}`);
          } else if (h instanceof it && d instanceof it && h.buffer.byteLength - h.offset >= d.buffer.byteLength - d.offset) return void (h.buffer.byteLength % 4 == 0 ? new Uint32Array(h.buffer, h.offset, h.typeInfo.size / 4).set(new Uint32Array(d.buffer, d.offset, d.typeInfo.size / 4)) : new Uint8Array(h.buffer, h.offset, h.typeInfo.size).set(new Uint8Array(d.buffer, d.offset, d.typeInfo.size)));
          return console.error(`Invalid assignment. Line ${e.line}`), null;
        }
        if (p === "+=") return h instanceof I || h instanceof A || h instanceof _e ? d instanceof I || d instanceof A || d instanceof _e ? void h.data.set(d.data.map((_, y) => h.data[y] + _)) : void console.error(`Invalid assignment . Line ${e.line}`) : void console.error(`Invalid assignment. Line ${e.line}`);
        if (p === "-=") return (h instanceof I || h instanceof A || h instanceof _e) && (d instanceof I || d instanceof A || d instanceof _e) ? void h.data.set(d.data.map((_, y) => h.data[y] - _)) : void console.error(`Invalid assignment. Line ${e.line}`);
      }
      if (e.variable instanceof ct) {
        if (e.variable.operator === "*") {
          s = this.getVariableName(e.variable.right, t);
          const h = t.getVariable(s);
          if (!(h && h.value instanceof Sr)) return void console.error(`Variable ${s} is not a pointer. Line ${e.line}`);
          i = h.value.reference;
          let d = e.variable.postfix;
          if (!d) {
            let p = e.variable.right;
            for (; p instanceof ct; ) {
              if (p.postfix) {
                d = p.postfix;
                break;
              }
              p = p.right;
            }
          }
          d && (i = i.getSubData(this, d, t));
        }
      } else {
        a = e.variable.postfix, s = this.getVariableName(e.variable, t);
        const h = t.getVariable(s);
        if (h === null) return void console.error(`Variable ${s} not found. Line ${e.line}`);
        i = h.value;
      }
      if (i instanceof Sr && (i = i.reference), i === null) return void console.error(`Variable ${s} not found. Line ${e.line}`);
      const l = this.evalExpression(e.value, t), u = e.operator;
      if (u === "=") if (i instanceof it) i.setDataValue(this, l, a, t);
      else if (a) {
        if (!(i instanceof A || i instanceof _e)) return void console.error(`Variable ${s} is not a vector or matrix. Line ${e.line}`);
        if (a instanceof zr) {
          const h = this.evalExpression(a.index, t).value;
          if (i instanceof A) {
            if (!(l instanceof I)) return void console.error(`Invalid assignment to ${s}. Line ${e.line}`);
            i.data[h] = l.value;
          } else {
            if (!(i instanceof _e)) return void console.error(`Invalid assignment to ${s}. Line ${e.line}`);
            {
              const d = this.evalExpression(a.index, t).value;
              if (d < 0) return void console.error(`Invalid assignment to ${s}. Line ${e.line}`);
              if (!(l instanceof A)) return void console.error(`Invalid assignment to ${s}. Line ${e.line}`);
              {
                const p = i.typeInfo.getTypeName();
                if (p === "mat2x2" || p === "mat2x2f" || p === "mat2x2h") {
                  if (!(d < 2 && l.data.length === 2)) return void console.error(`Invalid assignment to ${s}. Line ${e.line}`);
                  i.data[2 * d] = l.data[0], i.data[2 * d + 1] = l.data[1];
                } else if (p === "mat2x3" || p === "mat2x3f" || p === "mat2x3h") {
                  if (!(d < 2 && l.data.length === 3)) return void console.error(`Invalid assignment to ${s}. Line ${e.line}`);
                  i.data[3 * d] = l.data[0], i.data[3 * d + 1] = l.data[1], i.data[3 * d + 2] = l.data[2];
                } else if (p === "mat2x4" || p === "mat2x4f" || p === "mat2x4h") {
                  if (!(d < 2 && l.data.length === 4)) return void console.error(`Invalid assignment to ${s}. Line ${e.line}`);
                  i.data[4 * d] = l.data[0], i.data[4 * d + 1] = l.data[1], i.data[4 * d + 2] = l.data[2], i.data[4 * d + 3] = l.data[3];
                } else if (p === "mat3x2" || p === "mat3x2f" || p === "mat3x2h") {
                  if (!(d < 3 && l.data.length === 2)) return void console.error(`Invalid assignment to ${s}. Line ${e.line}`);
                  i.data[2 * d] = l.data[0], i.data[2 * d + 1] = l.data[1];
                } else if (p === "mat3x3" || p === "mat3x3f" || p === "mat3x3h") {
                  if (!(d < 3 && l.data.length === 3)) return void console.error(`Invalid assignment to ${s}. Line ${e.line}`);
                  i.data[3 * d] = l.data[0], i.data[3 * d + 1] = l.data[1], i.data[3 * d + 2] = l.data[2];
                } else if (p === "mat3x4" || p === "mat3x4f" || p === "mat3x4h") {
                  if (!(d < 3 && l.data.length === 4)) return void console.error(`Invalid assignment to ${s}. Line ${e.line}`);
                  i.data[4 * d] = l.data[0], i.data[4 * d + 1] = l.data[1], i.data[4 * d + 2] = l.data[2], i.data[4 * d + 3] = l.data[3];
                } else if (p === "mat4x2" || p === "mat4x2f" || p === "mat4x2h") {
                  if (!(d < 4 && l.data.length === 2)) return void console.error(`Invalid assignment to ${s}. Line ${e.line}`);
                  i.data[2 * d] = l.data[0], i.data[2 * d + 1] = l.data[1];
                } else if (p === "mat4x3" || p === "mat4x3f" || p === "mat4x3h") {
                  if (!(d < 4 && l.data.length === 3)) return void console.error(`Invalid assignment to ${s}. Line ${e.line}`);
                  i.data[3 * d] = l.data[0], i.data[3 * d + 1] = l.data[1], i.data[3 * d + 2] = l.data[2];
                } else {
                  if (p !== "mat4x4" && p !== "mat4x4f" && p !== "mat4x4h") return void console.error(`Invalid assignment to ${s}. Line ${e.line}`);
                  if (!(d < 4 && l.data.length === 4)) return void console.error(`Invalid assignment to ${s}. Line ${e.line}`);
                  i.data[4 * d] = l.data[0], i.data[4 * d + 1] = l.data[1], i.data[4 * d + 2] = l.data[2], i.data[4 * d + 3] = l.data[3];
                }
              }
            }
          }
        } else if (a instanceof Rs) {
          const h = a.value;
          if (!(i instanceof A)) return void console.error(`Invalid assignment to ${h}. Variable ${s} is not a vector. Line ${e.line}`);
          if (l instanceof I) {
            if (h.length > 1) return void console.error(`Invalid assignment to ${h} for variable ${s}. Line ${e.line}`);
            if (h === "x") i.data[0] = l.value;
            else if (h === "y") {
              if (i.data.length < 2) return void console.error(`Invalid assignment to ${h} for variable ${s}. Line ${e.line}`);
              i.data[1] = l.value;
            } else if (h === "z") {
              if (i.data.length < 3) return void console.error(`Invalid assignment to ${h} for variable ${s}. Line ${e.line}`);
              i.data[2] = l.value;
            } else if (h === "w") {
              if (i.data.length < 4) return void console.error(`Invalid assignment to ${h} for variable ${s}. Line ${e.line}`);
              i.data[3] = l.value;
            }
          } else {
            if (!(l instanceof A)) return void console.error(`Invalid assignment to ${s}. Line ${e.line}`);
            if (h.length !== l.data.length) return void console.error(`Invalid assignment to ${h} for variable ${s}. Line ${e.line}`);
            for (let d = 0; d < h.length; ++d) {
              const p = h[d];
              if (p === "x" || p === "r") i.data[0] = l.data[d];
              else if (p === "y" || p === "g") {
                if (l.data.length < 2) return void console.error(`Invalid assignment to ${p} for variable ${s}. Line ${e.line}`);
                i.data[1] = l.data[d];
              } else if (p === "z" || p === "b") {
                if (l.data.length < 3) return void console.error(`Invalid assignment to ${p} for variable ${s}. Line ${e.line}`);
                i.data[2] = l.data[d];
              } else {
                if (p !== "w" && p !== "a") return void console.error(`Invalid assignment to ${p} for variable ${s}. Line ${e.line}`);
                if (l.data.length < 4) return void console.error(`Invalid assignment to ${p} for variable ${s}. Line ${e.line}`);
                i.data[3] = l.data[d];
              }
            }
          }
        }
      } else i instanceof I && l instanceof I ? i.value = l.value : i instanceof A && l instanceof A || i instanceof _e && l instanceof _e ? i.data.set(l.data) : console.error(`Invalid assignment to ${s}. Line ${e.line}`);
      else {
        const h = i.getSubData(this, a, t);
        if (h instanceof A && l instanceof I) {
          const d = h.data, p = l.value;
          if (u === "+=") for (let _ = 0; _ < d.length; ++_) d[_] += p;
          else if (u === "-=") for (let _ = 0; _ < d.length; ++_) d[_] -= p;
          else if (u === "*=") for (let _ = 0; _ < d.length; ++_) d[_] *= p;
          else if (u === "/=") for (let _ = 0; _ < d.length; ++_) d[_] /= p;
          else if (u === "%=") for (let _ = 0; _ < d.length; ++_) d[_] %= p;
          else if (u === "&=") for (let _ = 0; _ < d.length; ++_) d[_] &= p;
          else if (u === "|=") for (let _ = 0; _ < d.length; ++_) d[_] |= p;
          else if (u === "^=") for (let _ = 0; _ < d.length; ++_) d[_] ^= p;
          else if (u === "<<=") for (let _ = 0; _ < d.length; ++_) d[_] <<= p;
          else if (u === ">>=") for (let _ = 0; _ < d.length; ++_) d[_] >>= p;
          else console.error(`Invalid operator ${u}. Line ${e.line}`);
        } else if (h instanceof A && l instanceof A) {
          const d = h.data, p = l.data;
          if (d.length !== p.length) return void console.error(`Vector length mismatch. Line ${e.line}`);
          if (u === "+=") for (let _ = 0; _ < d.length; ++_) d[_] += p[_];
          else if (u === "-=") for (let _ = 0; _ < d.length; ++_) d[_] -= p[_];
          else if (u === "*=") for (let _ = 0; _ < d.length; ++_) d[_] *= p[_];
          else if (u === "/=") for (let _ = 0; _ < d.length; ++_) d[_] /= p[_];
          else if (u === "%=") for (let _ = 0; _ < d.length; ++_) d[_] %= p[_];
          else if (u === "&=") for (let _ = 0; _ < d.length; ++_) d[_] &= p[_];
          else if (u === "|=") for (let _ = 0; _ < d.length; ++_) d[_] |= p[_];
          else if (u === "^=") for (let _ = 0; _ < d.length; ++_) d[_] ^= p[_];
          else if (u === "<<=") for (let _ = 0; _ < d.length; ++_) d[_] <<= p[_];
          else if (u === ">>=") for (let _ = 0; _ < d.length; ++_) d[_] >>= p[_];
          else console.error(`Invalid operator ${u}. Line ${e.line}`);
        } else {
          if (!(h instanceof I && l instanceof I)) return void console.error(`Invalid type for ${e.operator} operator. Line ${e.line}`);
          u === "+=" ? h.value += l.value : u === "-=" ? h.value -= l.value : u === "*=" ? h.value *= l.value : u === "/=" ? h.value /= l.value : u === "%=" ? h.value %= l.value : u === "&=" ? h.value &= l.value : u === "|=" ? h.value |= l.value : u === "^=" ? h.value ^= l.value : u === "<<=" ? h.value <<= l.value : u === ">>=" ? h.value >>= l.value : console.error(`Invalid operator ${u}. Line ${e.line}`);
        }
        i instanceof it && i.setDataValue(this, h, a, t);
      }
    }
    _function(e, t) {
      const i = new Tg(e);
      t.functions.set(e.name, i);
    }
    _const(e, t) {
      let i = null;
      e.value !== null && (i = this.evalExpression(e.value, t)), t.createVariable(e.name, i, e);
    }
    _let(e, t) {
      let i = null;
      if (e.value !== null) {
        if (i = this.evalExpression(e.value, t), i === null) return void console.error(`Invalid value for variable ${e.name}. Line ${e.line}`);
        e.value instanceof ct || (i = i.clone());
      } else {
        const s = e.type.name;
        if (s === "f32" || s === "i32" || s === "u32" || s === "bool" || s === "f16" || s === "vec2" || s === "vec3" || s === "vec4" || s === "vec2f" || s === "vec3f" || s === "vec4f" || s === "vec2i" || s === "vec3i" || s === "vec4i" || s === "vec2u" || s === "vec3u" || s === "vec4u" || s === "vec2h" || s === "vec3h" || s === "vec4h" || s === "vec2b" || s === "vec3b" || s === "vec4b" || s === "mat2x2" || s === "mat2x3" || s === "mat2x4" || s === "mat3x2" || s === "mat3x3" || s === "mat3x4" || s === "mat4x2" || s === "mat4x3" || s === "mat4x4" || s === "mat2x2f" || s === "mat2x3f" || s === "mat2x4f" || s === "mat3x2f" || s === "mat3x3f" || s === "mat3x4f" || s === "mat4x2f" || s === "mat4x3f" || s === "mat4x4f" || s === "mat2x2h" || s === "mat2x3h" || s === "mat2x4h" || s === "mat3x2h" || s === "mat3x3h" || s === "mat3x4h" || s === "mat4x2h" || s === "mat4x3h" || s === "mat4x4h" || s === "array") {
          const a = new Pn(e.type, []);
          i = this._evalCreate(a, t);
        }
      }
      t.createVariable(e.name, i, e);
    }
    _var(e, t) {
      let i = null;
      if (e.value !== null) {
        if (i = this.evalExpression(e.value, t), i === null) return void console.error(`Invalid value for variable ${e.name}. Line ${e.line}`);
        e.value instanceof ct || (i = i.clone());
      } else {
        if (e.type === null) return void console.error(`Variable ${e.name} has no type. Line ${e.line}`);
        const s = e.type.name;
        if (s === "f32" || s === "i32" || s === "u32" || s === "bool" || s === "f16" || s === "vec2" || s === "vec3" || s === "vec4" || s === "vec2f" || s === "vec3f" || s === "vec4f" || s === "vec2i" || s === "vec3i" || s === "vec4i" || s === "vec2u" || s === "vec3u" || s === "vec4u" || s === "vec2h" || s === "vec3h" || s === "vec4h" || s === "vec2b" || s === "vec3b" || s === "vec4b" || s === "mat2x2" || s === "mat2x3" || s === "mat2x4" || s === "mat3x2" || s === "mat3x3" || s === "mat3x4" || s === "mat4x2" || s === "mat4x3" || s === "mat4x4" || s === "mat2x2f" || s === "mat2x3f" || s === "mat2x4f" || s === "mat3x2f" || s === "mat3x3f" || s === "mat3x4f" || s === "mat4x2f" || s === "mat4x3f" || s === "mat4x4f" || s === "mat2x2h" || s === "mat2x3h" || s === "mat2x4h" || s === "mat3x2h" || s === "mat3x3h" || s === "mat3x4h" || s === "mat4x2h" || s === "mat4x3h" || s === "mat4x4h" || e.type instanceof co || e.type instanceof si || e.type instanceof k) {
          const a = new Pn(e.type, []);
          i = this._evalCreate(a, t);
        }
      }
      t.createVariable(e.name, i, e);
    }
    _switch(e, t) {
      t = t.clone();
      const i = this.evalExpression(e.condition, t);
      if (!(i instanceof I)) return console.error(`Invalid if condition. Line ${e.line}`), null;
      let s = null;
      for (const a of e.cases) if (a instanceof J3) for (const l of a.selectors) {
        if (l instanceof cc) {
          s = a;
          continue;
        }
        const u = this.evalExpression(l, t);
        if (!(u instanceof I)) return console.error(`Invalid case selector. Line ${e.line}`), null;
        if (u.value === i.value) return this._execStatements(a.body, t);
      }
      else a instanceof e2 && (s = a);
      return s ? this._execStatements(s.body, t) : null;
    }
    _if(e, t) {
      t = t.clone();
      const i = this.evalExpression(e.condition, t);
      if (!(i instanceof I)) return console.error(`Invalid if condition. Line ${e.line}`), null;
      if (i.value) return this._execStatements(e.body, t);
      for (const s of e.elseif) {
        const a = this.evalExpression(s.condition, t);
        if (!(a instanceof I)) return console.error(`Invalid if condition. Line ${e.line}`), null;
        if (a.value) return this._execStatements(s.body, t);
      }
      return e.else ? this._execStatements(e.else, t) : null;
    }
    _getScalarValue(e) {
      return e instanceof I ? e.value : (console.error("Expected scalar value.", e), 0);
    }
    _for(e, t) {
      for (t = t.clone(), this.execStatement(e.init, t); this._getScalarValue(this.evalExpression(e.condition, t)); ) {
        const i = this._execStatements(e.body, t);
        if (i === Mt._breakObj) break;
        if (i !== null && i !== Mt._continueObj) return i;
        this.execStatement(e.increment, t);
      }
      return null;
    }
    _loop(e, t) {
      for (t = t.clone(); ; ) {
        const i = this._execStatements(e.body, t);
        if (i === Mt._breakObj) break;
        if (i === Mt._continueObj) {
          if (e.continuing && this._execStatements(e.continuing.body, t) === Mt._breakObj) break;
        } else if (i !== null) return i;
      }
      return null;
    }
    _while(e, t) {
      for (t = t.clone(); this._getScalarValue(this.evalExpression(e.condition, t)); ) {
        const i = this._execStatements(e.body, t);
        if (i === Mt._breakObj) break;
        if (i !== Mt._continueObj && i !== null) return i;
      }
      return null;
    }
    _evalBitcast(e, t) {
      const i = this.evalExpression(e.value, t), s = e.type;
      if (i instanceof I) {
        const a = Kb(i.value, i.typeInfo.name, s.name);
        return new I(a, this.getTypeInfo(s));
      }
      if (i instanceof A) {
        const a = i.typeInfo.getTypeName();
        let l = "";
        if (a.endsWith("f")) l = "f32";
        else if (a.endsWith("i")) l = "i32";
        else if (a.endsWith("u")) l = "u32";
        else if (a.endsWith("b")) l = "bool";
        else {
          if (!a.endsWith("h")) return console.error(`Unknown vector type ${a}. Line ${e.line}`), null;
          l = "f16";
        }
        const u = s.getTypeName();
        let h = "";
        if (u.endsWith("f")) h = "f32";
        else if (u.endsWith("i")) h = "i32";
        else if (u.endsWith("u")) h = "u32";
        else if (u.endsWith("b")) h = "bool";
        else {
          if (!u.endsWith("h")) return console.error(`Unknown vector type ${h}. Line ${e.line}`), null;
          h = "f16";
        }
        const d = function(p, _, y) {
          if (_ === y) return p;
          const v = new Array(p.length);
          for (let S = 0; S < p.length; S++) v[S] = Kb(p[S], _, y);
          return v;
        }(Array.from(i.data), l, h);
        return new A(d, this.getTypeInfo(s));
      }
      return console.error(`TODO: bitcast for ${i.typeInfo.name}. Line ${e.line}`), null;
    }
    _evalConst(e, t) {
      return t.getVariableValue(e.name).clone().getSubData(this, e.postfix, t);
    }
    _evalCreate(e, t) {
      var i;
      if (e instanceof Pn) {
        if (e.type === null) return Sd.void;
        switch (e.type.getTypeName()) {
          case "bool":
          case "i32":
          case "u32":
          case "f32":
          case "f16":
            return this._callConstructorValue(e, t);
          case "vec2":
          case "vec3":
          case "vec4":
          case "vec2f":
          case "vec3f":
          case "vec4f":
          case "vec2h":
          case "vec3h":
          case "vec4h":
          case "vec2i":
          case "vec3i":
          case "vec4i":
          case "vec2u":
          case "vec3u":
          case "vec4u":
          case "vec2b":
          case "vec3b":
          case "vec4b":
            return this._callConstructorVec(e, t);
          case "mat2x2":
          case "mat2x2f":
          case "mat2x2h":
          case "mat2x3":
          case "mat2x3f":
          case "mat2x3h":
          case "mat2x4":
          case "mat2x4f":
          case "mat2x4h":
          case "mat3x2":
          case "mat3x2f":
          case "mat3x2h":
          case "mat3x3":
          case "mat3x3f":
          case "mat3x3h":
          case "mat3x4":
          case "mat3x4f":
          case "mat3x4h":
          case "mat4x2":
          case "mat4x2f":
          case "mat4x2h":
          case "mat4x3":
          case "mat4x3f":
          case "mat4x3h":
          case "mat4x4":
          case "mat4x4f":
          case "mat4x4h":
            return this._callConstructorMatrix(e, t);
        }
      }
      const s = e instanceof Pn ? e.type.name : e.name, a = e instanceof Pn ? this.getTypeInfo(e.type) : this.getTypeInfo(e.name);
      if (a === null) return console.error(`Unknown type ${s}. Line ${e.line}`), null;
      if (a.size === 0) return null;
      const l = new it(new ArrayBuffer(a.size), a, 0);
      if (a instanceof zi) {
        if (e.args) for (let u = 0; u < e.args.length; ++u) {
          const h = a.members[u], d = e.args[u], p = this.evalExpression(d, t);
          l.setData(this, p, h.type, h.offset, t);
        }
      } else if (a instanceof $i) {
        let u = 0;
        if (e.args) for (let h = 0; h < e.args.length; ++h) {
          const d = e.args[h], p = this.evalExpression(d, t);
          a.format === null && (((i = p.typeInfo) === null || i === void 0 ? void 0 : i.name) === "x32" ? a.format = this.getTypeInfo("i32") : a.format = p.typeInfo), l.setData(this, p, a.format, u, t), u += a.stride;
        }
      } else console.error(`Unknown type "${s}". Line ${e.line}`);
      return e instanceof Pn ? l.getSubData(this, e.postfix, t) : l;
    }
    _evalLiteral(e, t) {
      const i = this.getTypeInfo(e.type), s = i.name;
      return s === "x32" || s === "u32" || s === "f32" || s === "f16" || s === "i32" || s === "bool" ? new I(e.scalarValue, i) : s === "vec2" || s === "vec3" || s === "vec4" || s === "vec2f" || s === "vec3f" || s === "vec4f" || s === "vec2h" || s === "vec3h" || s === "vec4h" || s === "vec2i" || s === "vec3i" || s === "vec4i" || s === "vec2u" || s === "vec3u" || s === "vec4u" ? this._callConstructorVec(e, t) : s === "mat2x2" || s === "mat2x3" || s === "mat2x4" || s === "mat3x2" || s === "mat3x3" || s === "mat3x4" || s === "mat4x2" || s === "mat4x3" || s === "mat4x4" || s === "mat2x2f" || s === "mat2x3f" || s === "mat2x4f" || s === "mat3x2f" || s === "mat3x3f" || s === "mat3x4f" || s === "mat4x2f" || s === "mat4x3f" || s === "mat4x4f" || s === "mat2x2h" || s === "mat2x3h" || s === "mat2x4h" || s === "mat3x2h" || s === "mat3x3h" || s === "mat3x4h" || s === "mat4x2h" || s === "mat4x3h" || s === "mat4x4h" ? this._callConstructorMatrix(e, t) : e.value;
    }
    _evalVariable(e, t) {
      const i = t.getVariableValue(e.name);
      return i === null ? i : i.getSubData(this, e.postfix, t);
    }
    _maxFormatTypeInfo(e) {
      let t = e[0];
      if (t.name === "f32") return t;
      for (let i = 1; i < e.length; ++i) {
        const s = Mt._priority.get(t.name);
        Mt._priority.get(e[i].name) < s && (t = e[i]);
      }
      return t.name === "x32" ? this.getTypeInfo("i32") : t;
    }
    _evalUnaryOp(e, t) {
      const i = this.evalExpression(e.right, t);
      if (e.operator === "&") return new Sr(i);
      if (e.operator === "*") return i instanceof Sr ? i.reference.getSubData(this, e.postfix, t) : (console.error(`Invalid dereference. Line ${e.line}`), null);
      const s = i instanceof I ? i.value : i instanceof A ? Array.from(i.data) : null;
      switch (e.operator) {
        case "+": {
          if (ie(s)) {
            const u = s.map((h, d) => +h);
            return new A(u, i.typeInfo);
          }
          const a = s, l = this._maxFormatTypeInfo([
            i.typeInfo,
            i.typeInfo
          ]);
          return new I(+a, l);
        }
        case "-": {
          if (ie(s)) {
            const u = s.map((h, d) => -h);
            return new A(u, i.typeInfo);
          }
          const a = s, l = this._maxFormatTypeInfo([
            i.typeInfo,
            i.typeInfo
          ]);
          return new I(-a, l);
        }
        case "!": {
          if (ie(s)) {
            const u = s.map((h, d) => h ? 0 : 1);
            return new A(u, i.typeInfo);
          }
          const a = s, l = this._maxFormatTypeInfo([
            i.typeInfo,
            i.typeInfo
          ]);
          return new I(a ? 0 : 1, l);
        }
        case "~": {
          if (ie(s)) {
            const u = s.map((h, d) => ~h);
            return new A(u, i.typeInfo);
          }
          const a = s, l = this._maxFormatTypeInfo([
            i.typeInfo,
            i.typeInfo
          ]);
          return new I(~a, l);
        }
      }
      return console.error(`Invalid unary operator ${e.operator}. Line ${e.line}`), null;
    }
    _evalBinaryOp(e, t) {
      const i = this.evalExpression(e.left, t), s = this.evalExpression(e.right, t), a = i instanceof I ? i.value : i instanceof A || i instanceof _e ? Array.from(i.data) : null, l = s instanceof I ? s.value : s instanceof A || s instanceof _e ? Array.from(s.data) : null;
      switch (e.operator) {
        case "+": {
          if (ie(a) && ie(l)) {
            const p = a, _ = l;
            if (p.length !== _.length) return console.error(`Vector length mismatch. Line ${e.line}.`), null;
            const y = p.map((v, S) => v + _[S]);
            return new A(y, i.typeInfo);
          }
          if (ie(a)) {
            const p = l, _ = a.map((y, v) => y + p);
            return new A(_, i.typeInfo);
          }
          if (ie(l)) {
            const p = a, _ = l.map((y, v) => p + y);
            return new A(_, s.typeInfo);
          }
          const u = a, h = l, d = this._maxFormatTypeInfo([
            i.typeInfo,
            s.typeInfo
          ]);
          return new I(u + h, d);
        }
        case "-": {
          if (ie(a) && ie(l)) {
            const p = a, _ = l;
            if (p.length !== _.length) return console.error(`Vector length mismatch. Line ${e.line}.`), null;
            const y = p.map((v, S) => v - _[S]);
            return new A(y, i.typeInfo);
          }
          if (ie(a)) {
            const p = l, _ = a.map((y, v) => y - p);
            return new A(_, i.typeInfo);
          }
          if (ie(l)) {
            const p = a, _ = l.map((y, v) => p - y);
            return new A(_, s.typeInfo);
          }
          const u = a, h = l, d = this._maxFormatTypeInfo([
            i.typeInfo,
            s.typeInfo
          ]);
          return new I(u - h, d);
        }
        case "*": {
          if (ie(a) && ie(l)) {
            const p = a, _ = l;
            if (i instanceof _e && s instanceof _e) {
              const y = function(M, F, H, O) {
                if (Pt[F.name] === void 0 || Pt[O.name] === void 0) return null;
                const U = Pt[F.name][0], B = Pt[F.name][1], Z = Pt[O.name][0];
                if (U !== Pt[O.name][1]) return null;
                const re = new Array(Z * B);
                for (let le = 0; le < B; le++) for (let ee = 0; ee < Z; ee++) {
                  let fe = 0;
                  for (let te = 0; te < U; te++) fe += M[te * B + le] * H[ee * U + te];
                  re[le * Z + ee] = fe;
                }
                return re;
              }(p, i.typeInfo, _, s.typeInfo);
              if (y === null) return console.error(`Matrix multiplication failed. Line ${e.line}.`), null;
              const v = Pt[s.typeInfo.name][0], S = Pt[i.typeInfo.name][1], E = this.getTypeInfo(`mat${v}x${S}f`);
              return new _e(y, E);
            }
            if (i instanceof _e && s instanceof A) {
              const y = function(v, S, E, M) {
                if (Pt[S.name] === void 0 || Vh[M.name] === void 0) return null;
                const F = Pt[S.name][0], H = Pt[S.name][1];
                if (F !== E.length) return null;
                const O = new Array(H);
                for (let U = 0; U < H; U++) {
                  let B = 0;
                  for (let Z = 0; Z < F; Z++) B += v[Z * H + U] * E[Z];
                  O[U] = B;
                }
                return O;
              }(p, i.typeInfo, _, s.typeInfo);
              return y === null ? (console.error(`Matrix vector multiplication failed. Line ${e.line}.`), null) : new A(y, s.typeInfo);
            }
            if (i instanceof A && s instanceof _e) {
              const y = function(v, S, E, M) {
                if (Vh[S.name] === void 0 || Pt[M.name] === void 0) return null;
                const F = Pt[M.name][0], H = Pt[M.name][1];
                if (H !== v.length) return null;
                const O = [];
                for (let U = 0; U < F; U++) {
                  let B = 0;
                  for (let Z = 0; Z < H; Z++) B += v[Z] * E[Z * F + U];
                  O[U] = B;
                }
                return O;
              }(p, i.typeInfo, _, s.typeInfo);
              return y === null ? (console.error(`Matrix vector multiplication failed. Line ${e.line}.`), null) : new A(y, i.typeInfo);
            }
            {
              if (p.length !== _.length) return console.error(`Vector length mismatch. Line ${e.line}.`), null;
              const y = p.map((v, S) => v * _[S]);
              return new A(y, i.typeInfo);
            }
          }
          if (ie(a)) {
            const p = l, _ = a.map((y, v) => y * p);
            return i instanceof _e ? new _e(_, i.typeInfo) : new A(_, i.typeInfo);
          }
          if (ie(l)) {
            const p = a, _ = l.map((y, v) => p * y);
            return s instanceof _e ? new _e(_, s.typeInfo) : new A(_, s.typeInfo);
          }
          const u = a, h = l, d = this._maxFormatTypeInfo([
            i.typeInfo,
            s.typeInfo
          ]);
          return new I(u * h, d);
        }
        case "%": {
          if (ie(a) && ie(l)) {
            const p = a, _ = l;
            if (p.length !== _.length) return console.error(`Vector length mismatch. Line ${e.line}.`), null;
            const y = p.map((v, S) => v % _[S]);
            return new A(y, i.typeInfo);
          }
          if (ie(a)) {
            const p = l, _ = a.map((y, v) => y % p);
            return new A(_, i.typeInfo);
          }
          if (ie(l)) {
            const p = a, _ = l.map((y, v) => p % y);
            return new A(_, s.typeInfo);
          }
          const u = a, h = l, d = this._maxFormatTypeInfo([
            i.typeInfo,
            s.typeInfo
          ]);
          return new I(u % h, d);
        }
        case "/": {
          if (ie(a) && ie(l)) {
            const p = a, _ = l;
            if (p.length !== _.length) return console.error(`Vector length mismatch. Line ${e.line}.`), null;
            const y = p.map((v, S) => v / _[S]);
            return new A(y, i.typeInfo);
          }
          if (ie(a)) {
            const p = l, _ = a.map((y, v) => y / p);
            return new A(_, i.typeInfo);
          }
          if (ie(l)) {
            const p = a, _ = l.map((y, v) => p / y);
            return new A(_, s.typeInfo);
          }
          const u = a, h = l, d = this._maxFormatTypeInfo([
            i.typeInfo,
            s.typeInfo
          ]);
          return new I(u / h, d);
        }
        case "&": {
          if (ie(a) && ie(l)) {
            const p = a, _ = l;
            if (p.length !== _.length) return console.error(`Vector length mismatch. Line ${e.line}.`), null;
            const y = p.map((v, S) => v & _[S]);
            return new A(y, i.typeInfo);
          }
          if (ie(a)) {
            const p = l, _ = a.map((y, v) => y & p);
            return new A(_, i.typeInfo);
          }
          if (ie(l)) {
            const p = a, _ = l.map((y, v) => p & y);
            return new A(_, s.typeInfo);
          }
          const u = a, h = l, d = this._maxFormatTypeInfo([
            i.typeInfo,
            s.typeInfo
          ]);
          return new I(u & h, d);
        }
        case "|": {
          if (ie(a) && ie(l)) {
            const p = a, _ = l;
            if (p.length !== _.length) return console.error(`Vector length mismatch. Line ${e.line}.`), null;
            const y = p.map((v, S) => v | _[S]);
            return new A(y, i.typeInfo);
          }
          if (ie(a)) {
            const p = l, _ = a.map((y, v) => y | p);
            return new A(_, i.typeInfo);
          }
          if (ie(l)) {
            const p = a, _ = l.map((y, v) => p | y);
            return new A(_, s.typeInfo);
          }
          const u = a, h = l, d = this._maxFormatTypeInfo([
            i.typeInfo,
            s.typeInfo
          ]);
          return new I(u | h, d);
        }
        case "^": {
          if (ie(a) && ie(l)) {
            const p = a, _ = l;
            if (p.length !== _.length) return console.error(`Vector length mismatch. Line ${e.line}.`), null;
            const y = p.map((v, S) => v ^ _[S]);
            return new A(y, i.typeInfo);
          }
          if (ie(a)) {
            const p = l, _ = a.map((y, v) => y ^ p);
            return new A(_, i.typeInfo);
          }
          if (ie(l)) {
            const p = a, _ = l.map((y, v) => p ^ y);
            return new A(_, s.typeInfo);
          }
          const u = a, h = l, d = this._maxFormatTypeInfo([
            i.typeInfo,
            s.typeInfo
          ]);
          return new I(u ^ h, d);
        }
        case "<<": {
          if (ie(a) && ie(l)) {
            const p = a, _ = l;
            if (p.length !== _.length) return console.error(`Vector length mismatch. Line ${e.line}.`), null;
            const y = p.map((v, S) => v << _[S]);
            return new A(y, i.typeInfo);
          }
          if (ie(a)) {
            const p = l, _ = a.map((y, v) => y << p);
            return new A(_, i.typeInfo);
          }
          if (ie(l)) {
            const p = a, _ = l.map((y, v) => p << y);
            return new A(_, s.typeInfo);
          }
          const u = a, h = l, d = this._maxFormatTypeInfo([
            i.typeInfo,
            s.typeInfo
          ]);
          return new I(u << h, d);
        }
        case ">>": {
          if (ie(a) && ie(l)) {
            const p = a, _ = l;
            if (p.length !== _.length) return console.error(`Vector length mismatch. Line ${e.line}.`), null;
            const y = p.map((v, S) => v >> _[S]);
            return new A(y, i.typeInfo);
          }
          if (ie(a)) {
            const p = l, _ = a.map((y, v) => y >> p);
            return new A(_, i.typeInfo);
          }
          if (ie(l)) {
            const p = a, _ = l.map((y, v) => p >> y);
            return new A(_, s.typeInfo);
          }
          const u = a, h = l, d = this._maxFormatTypeInfo([
            i.typeInfo,
            s.typeInfo
          ]);
          return new I(u >> h, d);
        }
        case ">":
          if (ie(a) && ie(l)) {
            const u = a, h = l;
            if (u.length !== h.length) return console.error(`Vector length mismatch. Line ${e.line}.`), null;
            const d = u.map((p, _) => p > h[_] ? 1 : 0);
            return new A(d, i.typeInfo);
          }
          if (ie(a)) {
            const u = l, h = a.map((d, p) => d > u ? 1 : 0);
            return new A(h, i.typeInfo);
          }
          if (ie(l)) {
            const u = a, h = l.map((d, p) => u > d ? 1 : 0);
            return new A(h, s.typeInfo);
          }
          return new I(a > l ? 1 : 0, this.getTypeInfo("bool"));
        case "<":
          if (ie(a) && ie(l)) {
            const u = a, h = l;
            if (u.length !== h.length) return console.error(`Vector length mismatch. Line ${e.line}.`), null;
            const d = u.map((p, _) => p < h[_] ? 1 : 0);
            return new A(d, i.typeInfo);
          }
          if (ie(a)) {
            const u = l, h = a.map((d, p) => d < u ? 1 : 0);
            return new A(h, i.typeInfo);
          }
          if (ie(l)) {
            const u = a, h = l.map((d, p) => u < d ? 1 : 0);
            return new A(h, s.typeInfo);
          }
          return new I(a < l ? 1 : 0, this.getTypeInfo("bool"));
        case "==":
          if (ie(a) && ie(l)) {
            const u = a, h = l;
            if (u.length !== h.length) return console.error(`Vector length mismatch. Line ${e.line}.`), null;
            const d = u.map((p, _) => p === h[_] ? 1 : 0);
            return new A(d, i.typeInfo);
          }
          if (ie(a)) {
            const u = l, h = a.map((d, p) => d == u ? 1 : 0);
            return new A(h, i.typeInfo);
          }
          if (ie(l)) {
            const u = a, h = l.map((d, p) => u == d ? 1 : 0);
            return new A(h, s.typeInfo);
          }
          return new I(a === l ? 1 : 0, this.getTypeInfo("bool"));
        case "!=":
          if (ie(a) && ie(l)) {
            const u = a, h = l;
            if (u.length !== h.length) return console.error(`Vector length mismatch. Line ${e.line}.`), null;
            const d = u.map((p, _) => p !== h[_] ? 1 : 0);
            return new A(d, i.typeInfo);
          }
          if (ie(a)) {
            const u = l, h = a.map((d, p) => d !== u ? 1 : 0);
            return new A(h, i.typeInfo);
          }
          if (ie(l)) {
            const u = a, h = l.map((d, p) => u !== d ? 1 : 0);
            return new A(h, s.typeInfo);
          }
          return new I(a !== l ? 1 : 0, this.getTypeInfo("bool"));
        case ">=":
          if (ie(a) && ie(l)) {
            const u = a, h = l;
            if (u.length !== h.length) return console.error(`Vector length mismatch. Line ${e.line}.`), null;
            const d = u.map((p, _) => p >= h[_] ? 1 : 0);
            return new A(d, i.typeInfo);
          }
          if (ie(a)) {
            const u = l, h = a.map((d, p) => d >= u ? 1 : 0);
            return new A(h, i.typeInfo);
          }
          if (ie(l)) {
            const u = a, h = l.map((d, p) => u >= d ? 1 : 0);
            return new A(h, s.typeInfo);
          }
          return new I(a >= l ? 1 : 0, this.getTypeInfo("bool"));
        case "<=":
          if (ie(a) && ie(l)) {
            const u = a, h = l;
            if (u.length !== h.length) return console.error(`Vector length mismatch. Line ${e.line}.`), null;
            const d = u.map((p, _) => p <= h[_] ? 1 : 0);
            return new A(d, i.typeInfo);
          }
          if (ie(a)) {
            const u = l, h = a.map((d, p) => d <= u ? 1 : 0);
            return new A(h, i.typeInfo);
          }
          if (ie(l)) {
            const u = a, h = l.map((d, p) => u <= d ? 1 : 0);
            return new A(h, s.typeInfo);
          }
          return new I(a <= l ? 1 : 0, this.getTypeInfo("bool"));
        case "&&":
          if (ie(a) && ie(l)) {
            const u = a, h = l;
            if (u.length !== h.length) return console.error(`Vector length mismatch. Line ${e.line}.`), null;
            const d = u.map((p, _) => p && h[_] ? 1 : 0);
            return new A(d, i.typeInfo);
          }
          if (ie(a)) {
            const u = l, h = a.map((d, p) => d && u ? 1 : 0);
            return new A(h, i.typeInfo);
          }
          if (ie(l)) {
            const u = a, h = l.map((d, p) => u && d ? 1 : 0);
            return new A(h, s.typeInfo);
          }
          return new I(a && l ? 1 : 0, this.getTypeInfo("bool"));
        case "||":
          if (ie(a) && ie(l)) {
            const u = a, h = l;
            if (u.length !== h.length) return console.error(`Vector length mismatch. Line ${e.line}.`), null;
            const d = u.map((p, _) => p || h[_] ? 1 : 0);
            return new A(d, i.typeInfo);
          }
          if (ie(a)) {
            const u = l, h = a.map((d, p) => d || u ? 1 : 0);
            return new A(h, i.typeInfo);
          }
          if (ie(l)) {
            const u = a, h = l.map((d, p) => u || d ? 1 : 0);
            return new A(h, s.typeInfo);
          }
          return new I(a || l ? 1 : 0, this.getTypeInfo("bool"));
      }
      return console.error(`Unknown operator ${e.operator}. Line ${e.line}`), null;
    }
    _evalCall(e, t) {
      if (e.cachedReturnValue !== null) return e.cachedReturnValue;
      const i = t.clone();
      i.currentFunctionName = e.name;
      const s = t.getFunction(e.name);
      if (!s) return e.isBuiltin ? this._callBuiltinFunction(e, i) : this.getTypeInfo(e.name) ? this._evalCreate(e, t) : (console.error(`Unknown function "${e.name}". Line ${e.line}`), null);
      for (let a = 0; a < s.node.args.length; ++a) {
        const l = s.node.args[a], u = this.evalExpression(e.args[a], i);
        i.createVariable(l.name, u, l);
      }
      return this._execStatements(s.node.body, i);
    }
    _callBuiltinFunction(e, t) {
      switch (e.name) {
        case "all":
          return this.builtins.All(e, t);
        case "any":
          return this.builtins.Any(e, t);
        case "select":
          return this.builtins.Select(e, t);
        case "arrayLength":
          return this.builtins.ArrayLength(e, t);
        case "abs":
          return this.builtins.Abs(e, t);
        case "acos":
          return this.builtins.Acos(e, t);
        case "acosh":
          return this.builtins.Acosh(e, t);
        case "asin":
          return this.builtins.Asin(e, t);
        case "asinh":
          return this.builtins.Asinh(e, t);
        case "atan":
          return this.builtins.Atan(e, t);
        case "atanh":
          return this.builtins.Atanh(e, t);
        case "atan2":
          return this.builtins.Atan2(e, t);
        case "ceil":
          return this.builtins.Ceil(e, t);
        case "clamp":
          return this.builtins.Clamp(e, t);
        case "cos":
          return this.builtins.Cos(e, t);
        case "cosh":
          return this.builtins.Cosh(e, t);
        case "countLeadingZeros":
          return this.builtins.CountLeadingZeros(e, t);
        case "countOneBits":
          return this.builtins.CountOneBits(e, t);
        case "countTrailingZeros":
          return this.builtins.CountTrailingZeros(e, t);
        case "cross":
          return this.builtins.Cross(e, t);
        case "degrees":
          return this.builtins.Degrees(e, t);
        case "determinant":
          return this.builtins.Determinant(e, t);
        case "distance":
          return this.builtins.Distance(e, t);
        case "dot":
          return this.builtins.Dot(e, t);
        case "dot4U8Packed":
          return this.builtins.Dot4U8Packed(e, t);
        case "dot4I8Packed":
          return this.builtins.Dot4I8Packed(e, t);
        case "exp":
          return this.builtins.Exp(e, t);
        case "exp2":
          return this.builtins.Exp2(e, t);
        case "extractBits":
          return this.builtins.ExtractBits(e, t);
        case "faceForward":
          return this.builtins.FaceForward(e, t);
        case "firstLeadingBit":
          return this.builtins.FirstLeadingBit(e, t);
        case "firstTrailingBit":
          return this.builtins.FirstTrailingBit(e, t);
        case "floor":
          return this.builtins.Floor(e, t);
        case "fma":
          return this.builtins.Fma(e, t);
        case "fract":
          return this.builtins.Fract(e, t);
        case "frexp":
          return this.builtins.Frexp(e, t);
        case "insertBits":
          return this.builtins.InsertBits(e, t);
        case "inverseSqrt":
          return this.builtins.InverseSqrt(e, t);
        case "ldexp":
          return this.builtins.Ldexp(e, t);
        case "length":
          return this.builtins.Length(e, t);
        case "log":
          return this.builtins.Log(e, t);
        case "log2":
          return this.builtins.Log2(e, t);
        case "max":
          return this.builtins.Max(e, t);
        case "min":
          return this.builtins.Min(e, t);
        case "mix":
          return this.builtins.Mix(e, t);
        case "modf":
          return this.builtins.Modf(e, t);
        case "normalize":
          return this.builtins.Normalize(e, t);
        case "pow":
          return this.builtins.Pow(e, t);
        case "quantizeToF16":
          return this.builtins.QuantizeToF16(e, t);
        case "radians":
          return this.builtins.Radians(e, t);
        case "reflect":
          return this.builtins.Reflect(e, t);
        case "refract":
          return this.builtins.Refract(e, t);
        case "reverseBits":
          return this.builtins.ReverseBits(e, t);
        case "round":
          return this.builtins.Round(e, t);
        case "saturate":
          return this.builtins.Saturate(e, t);
        case "sign":
          return this.builtins.Sign(e, t);
        case "sin":
          return this.builtins.Sin(e, t);
        case "sinh":
          return this.builtins.Sinh(e, t);
        case "smoothStep":
          return this.builtins.SmoothStep(e, t);
        case "sqrt":
          return this.builtins.Sqrt(e, t);
        case "step":
          return this.builtins.Step(e, t);
        case "tan":
          return this.builtins.Tan(e, t);
        case "tanh":
          return this.builtins.Tanh(e, t);
        case "transpose":
          return this.builtins.Transpose(e, t);
        case "trunc":
          return this.builtins.Trunc(e, t);
        case "dpdx":
          return this.builtins.Dpdx(e, t);
        case "dpdxCoarse":
          return this.builtins.DpdxCoarse(e, t);
        case "dpdxFine":
          return this.builtins.DpdxFine(e, t);
        case "dpdy":
          return this.builtins.Dpdy(e, t);
        case "dpdyCoarse":
          return this.builtins.DpdyCoarse(e, t);
        case "dpdyFine":
          return this.builtins.DpdyFine(e, t);
        case "fwidth":
          return this.builtins.Fwidth(e, t);
        case "fwidthCoarse":
          return this.builtins.FwidthCoarse(e, t);
        case "fwidthFine":
          return this.builtins.FwidthFine(e, t);
        case "textureDimensions":
          return this.builtins.TextureDimensions(e, t);
        case "textureGather":
          return this.builtins.TextureGather(e, t);
        case "textureGatherCompare":
          return this.builtins.TextureGatherCompare(e, t);
        case "textureLoad":
          return this.builtins.TextureLoad(e, t);
        case "textureNumLayers":
          return this.builtins.TextureNumLayers(e, t);
        case "textureNumLevels":
          return this.builtins.TextureNumLevels(e, t);
        case "textureNumSamples":
          return this.builtins.TextureNumSamples(e, t);
        case "textureSample":
          return this.builtins.TextureSample(e, t);
        case "textureSampleBias":
          return this.builtins.TextureSampleBias(e, t);
        case "textureSampleCompare":
          return this.builtins.TextureSampleCompare(e, t);
        case "textureSampleCompareLevel":
          return this.builtins.TextureSampleCompareLevel(e, t);
        case "textureSampleGrad":
          return this.builtins.TextureSampleGrad(e, t);
        case "textureSampleLevel":
          return this.builtins.TextureSampleLevel(e, t);
        case "textureSampleBaseClampToEdge":
          return this.builtins.TextureSampleBaseClampToEdge(e, t);
        case "textureStore":
          return this.builtins.TextureStore(e, t);
        case "atomicLoad":
          return this.builtins.AtomicLoad(e, t);
        case "atomicStore":
          return this.builtins.AtomicStore(e, t);
        case "atomicAdd":
          return this.builtins.AtomicAdd(e, t);
        case "atomicSub":
          return this.builtins.AtomicSub(e, t);
        case "atomicMax":
          return this.builtins.AtomicMax(e, t);
        case "atomicMin":
          return this.builtins.AtomicMin(e, t);
        case "atomicAnd":
          return this.builtins.AtomicAnd(e, t);
        case "atomicOr":
          return this.builtins.AtomicOr(e, t);
        case "atomicXor":
          return this.builtins.AtomicXor(e, t);
        case "atomicExchange":
          return this.builtins.AtomicExchange(e, t);
        case "atomicCompareExchangeWeak":
          return this.builtins.AtomicCompareExchangeWeak(e, t);
        case "pack4x8snorm":
          return this.builtins.Pack4x8snorm(e, t);
        case "pack4x8unorm":
          return this.builtins.Pack4x8unorm(e, t);
        case "pack4xI8":
          return this.builtins.Pack4xI8(e, t);
        case "pack4xU8":
          return this.builtins.Pack4xU8(e, t);
        case "pack4x8Clamp":
          return this.builtins.Pack4x8Clamp(e, t);
        case "pack4xU8Clamp":
          return this.builtins.Pack4xU8Clamp(e, t);
        case "pack2x16snorm":
          return this.builtins.Pack2x16snorm(e, t);
        case "pack2x16unorm":
          return this.builtins.Pack2x16unorm(e, t);
        case "pack2x16float":
          return this.builtins.Pack2x16float(e, t);
        case "unpack4x8snorm":
          return this.builtins.Unpack4x8snorm(e, t);
        case "unpack4x8unorm":
          return this.builtins.Unpack4x8unorm(e, t);
        case "unpack4xI8":
          return this.builtins.Unpack4xI8(e, t);
        case "unpack4xU8":
          return this.builtins.Unpack4xU8(e, t);
        case "unpack2x16snorm":
          return this.builtins.Unpack2x16snorm(e, t);
        case "unpack2x16unorm":
          return this.builtins.Unpack2x16unorm(e, t);
        case "unpack2x16float":
          return this.builtins.Unpack2x16float(e, t);
        case "storageBarrier":
          return this.builtins.StorageBarrier(e, t);
        case "textureBarrier":
          return this.builtins.TextureBarrier(e, t);
        case "workgroupBarrier":
          return this.builtins.WorkgroupBarrier(e, t);
        case "workgroupUniformLoad":
          return this.builtins.WorkgroupUniformLoad(e, t);
        case "subgroupAdd":
          return this.builtins.SubgroupAdd(e, t);
        case "subgroupExclusiveAdd":
          return this.builtins.SubgroupExclusiveAdd(e, t);
        case "subgroupInclusiveAdd":
          return this.builtins.SubgroupInclusiveAdd(e, t);
        case "subgroupAll":
          return this.builtins.SubgroupAll(e, t);
        case "subgroupAnd":
          return this.builtins.SubgroupAnd(e, t);
        case "subgroupAny":
          return this.builtins.SubgroupAny(e, t);
        case "subgroupBallot":
          return this.builtins.SubgroupBallot(e, t);
        case "subgroupBroadcast":
          return this.builtins.SubgroupBroadcast(e, t);
        case "subgroupBroadcastFirst":
          return this.builtins.SubgroupBroadcastFirst(e, t);
        case "subgroupElect":
          return this.builtins.SubgroupElect(e, t);
        case "subgroupMax":
          return this.builtins.SubgroupMax(e, t);
        case "subgroupMin":
          return this.builtins.SubgroupMin(e, t);
        case "subgroupMul":
          return this.builtins.SubgroupMul(e, t);
        case "subgroupExclusiveMul":
          return this.builtins.SubgroupExclusiveMul(e, t);
        case "subgroupInclusiveMul":
          return this.builtins.SubgroupInclusiveMul(e, t);
        case "subgroupOr":
          return this.builtins.SubgroupOr(e, t);
        case "subgroupShuffle":
          return this.builtins.SubgroupShuffle(e, t);
        case "subgroupShuffleDown":
          return this.builtins.SubgroupShuffleDown(e, t);
        case "subgroupShuffleUp":
          return this.builtins.SubgroupShuffleUp(e, t);
        case "subgroupShuffleXor":
          return this.builtins.SubgroupShuffleXor(e, t);
        case "subgroupXor":
          return this.builtins.SubgroupXor(e, t);
        case "quadBroadcast":
          return this.builtins.QuadBroadcast(e, t);
        case "quadSwapDiagonal":
          return this.builtins.QuadSwapDiagonal(e, t);
        case "quadSwapX":
          return this.builtins.QuadSwapX(e, t);
        case "quadSwapY":
          return this.builtins.QuadSwapY(e, t);
      }
      const i = t.getFunction(e.name);
      if (i) {
        const s = t.clone();
        for (let a = 0; a < i.node.args.length; ++a) {
          const l = i.node.args[a], u = this.evalExpression(e.args[a], s);
          s.setVariable(l.name, u, l);
        }
        return this._execStatements(i.node.body, s);
      }
      return null;
    }
    _callConstructorValue(e, t) {
      if (!e.args || e.args.length === 0) return new I(0, this.getTypeInfo(e.type));
      const i = this.evalExpression(e.args[0], t);
      return i.typeInfo = this.getTypeInfo(e.type), i.getSubData(this, e.postfix, t).clone();
    }
    _callConstructorVec(e, t) {
      const i = this.getTypeInfo(e.type), s = e.type.getTypeName(), a = Vh[s];
      if (a === void 0) return console.error(`Invalid vec constructor ${s}. Line ${e.line}`), null;
      const l = [];
      if (e instanceof dt) if (e.isVector) {
        const u = e.vectorValue;
        for (const h of u) l.push(h);
      } else l.push(e.scalarValue);
      else if (e.args) for (const u of e.args) {
        const h = this.evalExpression(u, t);
        if (h instanceof A) {
          const d = h.data;
          for (let p = 0; p < d.length; ++p) {
            let _ = d[p];
            l.push(_);
          }
        } else if (h instanceof I) {
          let d = h.value;
          l.push(d);
        }
      }
      if (e.type instanceof k && e.type.format === null && (e.type.format = k.f32), l.length === 0) {
        const u = new Array(a).fill(0);
        return new A(u, i).getSubData(this, e.postfix, t);
      }
      if (l.length === 1) for (; l.length < a; ) l.push(l[0]);
      return l.length < a ? (console.error(`Invalid vec constructor. Line ${e.line}`), null) : new A(l.length > a ? l.slice(0, a) : l, i).getSubData(this, e.postfix, t);
    }
    _callConstructorMatrix(e, t) {
      const i = this.getTypeInfo(e.type), s = e.type.getTypeName(), a = Pt[s];
      if (a === void 0) return console.error(`Invalid matrix constructor ${s}. Line ${e.line}`), null;
      const l = [];
      if (e instanceof dt) if (e.isVector) {
        const u = e.vectorValue;
        for (const h of u) l.push(h);
      } else l.push(e.scalarValue);
      else if (e.args) for (const u of e.args) {
        const h = this.evalExpression(u, t);
        h instanceof A ? l.push(...h.data) : h instanceof I ? l.push(h.value) : h instanceof _e && l.push(...h.data);
      }
      if (i instanceof Es && i.format === null && (i.format = this.getTypeInfo("f32")), l.length === 0) {
        const u = new Array(a[2]).fill(0);
        return new _e(u, i).getSubData(this, e.postfix, t);
      }
      return l.length !== a[2] ? (console.error(`Invalid matrix constructor. Line ${e.line}`), null) : new _e(l, i).getSubData(this, e.postfix, t);
    }
  }
  Mt._breakObj = new mn(new dn("BREAK", null), null), Mt._continueObj = new mn(new dn("CONTINUE", null), null), Mt._priority = /* @__PURE__ */ new Map([
    [
      "f32",
      0
    ],
    [
      "f16",
      1
    ],
    [
      "u32",
      2
    ],
    [
      "i32",
      3
    ],
    [
      "x32",
      3
    ]
  ]);
  class dC {
    constructor() {
      this.constants = /* @__PURE__ */ new Map(), this.aliases = /* @__PURE__ */ new Map(), this.structs = /* @__PURE__ */ new Map();
    }
  }
  class gC {
    constructor() {
      this._tokens = [], this._current = 0, this._currentLine = 1, this._deferArrayCountEval = [], this._currentLoop = [], this._context = new dC(), this._exec = new Mt(), this._forwardTypeCount = 0;
    }
    parse(e) {
      this._initialize(e), this._deferArrayCountEval.length = 0;
      const t = [];
      for (; !this._isAtEnd(); ) {
        const i = this._global_decl_or_directive();
        if (!i) break;
        t.push(i);
      }
      if (this._deferArrayCountEval.length > 0) {
        for (const i of this._deferArrayCountEval) {
          const s = i.arrayType, a = i.countNode;
          if (a instanceof en) {
            const l = a.name, u = this._context.constants.get(l);
            if (u) try {
              const h = u.constEvaluate(this._exec);
              s.count = h;
            } catch {
            }
          }
        }
        this._deferArrayCountEval.length = 0;
      }
      if (this._forwardTypeCount > 0) for (const i of t) i.search((s) => {
        s instanceof Yb || s instanceof Fh ? s.type = this._forwardType(s.type) : s instanceof co ? s.format = this._forwardType(s.format) : s instanceof ai || s instanceof lo || s instanceof lc ? s.type = this._forwardType(s.type) : s instanceof mo ? s.returnType = this._forwardType(s.returnType) : s instanceof Xb && (s.type = this._forwardType(s.type));
      });
      return t;
    }
    _forwardType(e) {
      if (e instanceof $b) {
        const t = this._getType(e.name);
        if (t) return t;
      } else e instanceof Fh ? e.type = this._forwardType(e.type) : e instanceof co && (e.format = this._forwardType(e.format));
      return e;
    }
    _initialize(e) {
      if (e) if (typeof e == "string") {
        const t = new iC(e);
        this._tokens = t.scanTokens();
      } else this._tokens = e;
      else this._tokens = [];
      this._current = 0;
    }
    _updateNode(e, t) {
      return e.line = t ?? this._currentLine, e;
    }
    _error(e, t) {
      return {
        token: e,
        message: t,
        toString: () => `${t}`
      };
    }
    _isAtEnd() {
      return this._current >= this._tokens.length || this._peek().type == x.eof;
    }
    _match(e) {
      if (e instanceof P) return !!this._check(e) && (this._advance(), true);
      for (let t = 0, i = e.length; t < i; ++t) {
        const s = e[t];
        if (this._check(s)) return this._advance(), true;
      }
      return false;
    }
    _consume(e, t) {
      if (this._check(e)) return this._advance();
      throw this._error(this._peek(), `${t}. Line:${this._currentLine}`);
    }
    _check(e) {
      if (this._isAtEnd()) return false;
      const t = this._peek();
      if (e instanceof Array) {
        const i = t.type;
        let s = false;
        for (const a of e) {
          if (i === a) return true;
          a === x.tokens.name && (s = true);
        }
        if (s) {
          const a = x.tokens.name.rule.exec(t.lexeme);
          if (a && a.index == 0 && a[0] == t.lexeme) return true;
        }
        return false;
      }
      if (t.type === e) return true;
      if (e === x.tokens.name) {
        const i = x.tokens.name.rule.exec(t.lexeme);
        return i && i.index == 0 && i[0] == t.lexeme;
      }
      return false;
    }
    _advance() {
      var e, t;
      return this._currentLine = (t = (e = this._peek()) === null || e === void 0 ? void 0 : e.line) !== null && t !== void 0 ? t : -1, this._isAtEnd() || this._current++, this._previous();
    }
    _peek() {
      return this._tokens[this._current];
    }
    _previous() {
      return this._tokens[this._current - 1];
    }
    _global_decl_or_directive() {
      for (; this._match(x.tokens.semicolon) && !this._isAtEnd(); ) ;
      if (this._match(x.keywords.alias)) {
        const t = this._type_alias();
        return this._consume(x.tokens.semicolon, "Expected ';'"), this._exec.reflection.updateAST([
          t
        ]), t;
      }
      if (this._match(x.keywords.diagnostic)) {
        const t = this._diagnostic();
        return this._consume(x.tokens.semicolon, "Expected ';'"), this._exec.reflection.updateAST([
          t
        ]), t;
      }
      if (this._match(x.keywords.requires)) {
        const t = this._requires_directive();
        return this._consume(x.tokens.semicolon, "Expected ';'"), this._exec.reflection.updateAST([
          t
        ]), t;
      }
      if (this._match(x.keywords.enable)) {
        const t = this._enable_directive();
        return this._consume(x.tokens.semicolon, "Expected ';'"), this._exec.reflection.updateAST([
          t
        ]), t;
      }
      const e = this._attribute();
      if (this._check(x.keywords.var)) {
        const t = this._global_variable_decl();
        return t != null && (t.attributes = e), this._consume(x.tokens.semicolon, "Expected ';'."), this._exec.reflection.updateAST([
          t
        ]), t;
      }
      if (this._check(x.keywords.override)) {
        const t = this._override_variable_decl();
        return t != null && (t.attributes = e), this._consume(x.tokens.semicolon, "Expected ';'."), this._exec.reflection.updateAST([
          t
        ]), t;
      }
      if (this._check(x.keywords.let)) {
        const t = this._global_let_decl();
        return t != null && (t.attributes = e), this._consume(x.tokens.semicolon, "Expected ';'."), this._exec.reflection.updateAST([
          t
        ]), t;
      }
      if (this._check(x.keywords.const)) {
        const t = this._global_const_decl();
        return t != null && (t.attributes = e), this._consume(x.tokens.semicolon, "Expected ';'."), this._exec.reflection.updateAST([
          t
        ]), t;
      }
      if (this._check(x.keywords.struct)) {
        const t = this._struct_decl();
        return t != null && (t.attributes = e), this._exec.reflection.updateAST([
          t
        ]), t;
      }
      if (this._check(x.keywords.fn)) {
        const t = this._function_decl();
        return t != null && (t.attributes = e), this._exec.reflection.updateAST([
          t
        ]), t;
      }
      return null;
    }
    _function_decl() {
      if (!this._match(x.keywords.fn)) return null;
      const e = this._currentLine, t = this._consume(x.tokens.ident, "Expected function name.").toString();
      this._consume(x.tokens.paren_left, "Expected '(' for function arguments.");
      const i = [];
      if (!this._check(x.tokens.paren_right)) do {
        if (this._check(x.tokens.paren_right)) break;
        const u = this._attribute(), h = this._consume(x.tokens.name, "Expected argument name.").toString();
        this._consume(x.tokens.colon, "Expected ':' for argument type.");
        const d = this._attribute(), p = this._type_decl();
        p != null && (p.attributes = d, i.push(this._updateNode(new Xb(h, p, u))));
      } while (this._match(x.tokens.comma));
      this._consume(x.tokens.paren_right, "Expected ')' after function arguments.");
      let s = null;
      if (this._match(x.tokens.arrow)) {
        const u = this._attribute();
        s = this._type_decl(), s != null && (s.attributes = u);
      }
      const a = this._compound_statement(), l = this._currentLine;
      return this._updateNode(new mo(t, i, s, a, e, l), e);
    }
    _compound_statement() {
      const e = [];
      for (this._consume(x.tokens.brace_left, "Expected '{' for block."); !this._check(x.tokens.brace_right); ) {
        const t = this._statement();
        t !== null && e.push(t);
      }
      return this._consume(x.tokens.brace_right, "Expected '}' for block."), e;
    }
    _statement() {
      for (; this._match(x.tokens.semicolon) && !this._isAtEnd(); ) ;
      if (this._check(x.tokens.attr) && this._attribute(), this._check(x.keywords.if)) return this._if_statement();
      if (this._check(x.keywords.switch)) return this._switch_statement();
      if (this._check(x.keywords.loop)) return this._loop_statement();
      if (this._check(x.keywords.for)) return this._for_statement();
      if (this._check(x.keywords.while)) return this._while_statement();
      if (this._check(x.keywords.continuing)) return this._continuing_statement();
      if (this._check(x.keywords.static_assert)) return this._static_assert_statement();
      if (this._check(x.tokens.brace_left)) return this._compound_statement();
      let e = null;
      if (this._check(x.keywords.return)) e = this._return_statement();
      else if (this._check([
        x.keywords.var,
        x.keywords.let,
        x.keywords.const
      ])) e = this._variable_statement();
      else if (this._match(x.keywords.discard)) e = this._updateNode(new eC());
      else if (this._match(x.keywords.break)) {
        const t = this._updateNode(new Y3());
        if (this._currentLoop.length > 0) {
          const i = this._currentLoop[this._currentLoop.length - 1];
          t.loopId = i.id;
        }
        e = t, this._check(x.keywords.if) && (this._advance(), t.condition = this._optional_paren_expression());
      } else if (this._match(x.keywords.continue)) {
        const t = this._updateNode(new q3());
        if (!(this._currentLoop.length > 0)) throw this._error(this._peek(), `Continue statement must be inside a loop. Line: ${t.line}`);
        {
          const i = this._currentLoop[this._currentLoop.length - 1];
          t.loopId = i.id;
        }
        e = t;
      } else e = this._increment_decrement_statement() || this._func_call_statement() || this._assignment_statement();
      return e != null && this._consume(x.tokens.semicolon, "Expected ';' after statement."), e;
    }
    _static_assert_statement() {
      if (!this._match(x.keywords.static_assert)) return null;
      const e = this._currentLine, t = this._optional_paren_expression();
      return this._updateNode(new QR(t), e);
    }
    _while_statement() {
      if (!this._match(x.keywords.while)) return null;
      const e = this._updateNode(new L3(null, null));
      return this._currentLoop.push(e), e.condition = this._optional_paren_expression(), this._check(x.tokens.attr) && this._attribute(), e.body = this._compound_statement(), this._currentLoop.pop(), e;
    }
    _continuing_statement() {
      const e = this._currentLoop.length > 0 ? this._currentLoop[this._currentLoop.length - 1].id : -1;
      if (!this._match(x.keywords.continuing)) return null;
      const t = this._currentLine, i = this._compound_statement();
      return this._updateNode(new xd(i, e), t);
    }
    _for_statement() {
      if (!this._match(x.keywords.for)) return null;
      this._consume(x.tokens.paren_left, "Expected '('.");
      const e = this._updateNode(new F3(null, null, null, null));
      return this._currentLoop.push(e), e.init = this._check(x.tokens.semicolon) ? null : this._for_init(), this._consume(x.tokens.semicolon, "Expected ';'."), e.condition = this._check(x.tokens.semicolon) ? null : this._short_circuit_or_expression(), this._consume(x.tokens.semicolon, "Expected ';'."), e.increment = this._check(x.tokens.paren_right) ? null : this._for_increment(), this._consume(x.tokens.paren_right, "Expected ')'."), this._check(x.tokens.attr) && this._attribute(), e.body = this._compound_statement(), this._currentLoop.pop(), e;
    }
    _for_init() {
      return this._variable_statement() || this._func_call_statement() || this._assignment_statement();
    }
    _for_increment() {
      return this._func_call_statement() || this._increment_decrement_statement() || this._assignment_statement();
    }
    _variable_statement() {
      if (this._check(x.keywords.var)) {
        const e = this._variable_decl();
        if (e === null) throw this._error(this._peek(), "Variable declaration expected.");
        let t = null;
        return this._match(x.tokens.equal) && (t = this._short_circuit_or_expression()), this._updateNode(new ai(e.name, e.type, e.storage, e.access, t), e.line);
      }
      if (this._match(x.keywords.let)) {
        const e = this._currentLine, t = this._consume(x.tokens.name, "Expected name for let.").toString();
        let i = null;
        if (this._match(x.tokens.colon)) {
          const a = this._attribute();
          i = this._type_decl(), i != null && (i.attributes = a);
        }
        this._consume(x.tokens.equal, "Expected '=' for let.");
        const s = this._short_circuit_or_expression();
        return this._updateNode(new lo(t, i, null, null, s), e);
      }
      if (this._match(x.keywords.const)) {
        const e = this._currentLine, t = this._consume(x.tokens.name, "Expected name for const.").toString();
        let i = null;
        if (this._match(x.tokens.colon)) {
          const a = this._attribute();
          i = this._type_decl(), i != null && (i.attributes = a);
        }
        this._consume(x.tokens.equal, "Expected '=' for const.");
        const s = this._short_circuit_or_expression();
        return i === null && s instanceof dt && (i = s.type), this._updateNode(new lc(t, i, null, null, s), e);
      }
      return null;
    }
    _increment_decrement_statement() {
      const e = this._current, t = this._unary_expression();
      if (t == null) return null;
      if (!this._check(x.increment_operators)) return this._current = e, null;
      const i = this._consume(x.increment_operators, "Expected increment operator");
      return this._updateNode(new V3(i.type === x.tokens.plus_plus ? Mr.increment : Mr.decrement, t));
    }
    _assignment_statement() {
      let e = null;
      const t = this._currentLine;
      if (this._check(x.tokens.brace_right)) return null;
      let i = this._match(x.tokens.underscore);
      if (i || (e = this._unary_expression()), !i && e == null) return null;
      const s = this._consume(x.assignment_operators, "Expected assignment operator."), a = this._short_circuit_or_expression();
      return this._updateNode(new z3(to.parse(s.lexeme), e, a), t);
    }
    _func_call_statement() {
      if (!this._check(x.tokens.ident)) return null;
      const e = this._currentLine, t = this._current, i = this._consume(x.tokens.ident, "Expected function name."), s = this._argument_expression_list();
      return s === null ? (this._current = t, null) : this._updateNode(new _g(i.lexeme, s), e);
    }
    _loop_statement() {
      if (!this._match(x.keywords.loop)) return null;
      this._check(x.tokens.attr) && this._attribute(), this._consume(x.tokens.brace_left, "Expected '{' for loop.");
      const e = this._updateNode(new H3([], null));
      this._currentLoop.push(e);
      let t = this._statement();
      for (; t !== null; ) {
        if (Array.isArray(t)) for (let i of t) e.body.push(i);
        else e.body.push(t);
        if (t instanceof xd) {
          e.continuing = t;
          break;
        }
        t = this._statement();
      }
      return this._currentLoop.pop(), this._consume(x.tokens.brace_right, "Expected '}' for loop."), e;
    }
    _switch_statement() {
      if (!this._match(x.keywords.switch)) return null;
      const e = this._updateNode(new j3(null, []));
      if (this._currentLoop.push(e), e.condition = this._optional_paren_expression(), this._check(x.tokens.attr) && this._attribute(), this._consume(x.tokens.brace_left, "Expected '{' for switch."), e.cases = this._switch_body(), e.cases == null || e.cases.length == 0) throw this._error(this._previous(), "Expected 'case' or 'default'.");
      return this._consume(x.tokens.brace_right, "Expected '}' for switch."), this._currentLoop.pop(), e;
    }
    _switch_body() {
      const e = [];
      let t = false;
      for (; this._check([
        x.keywords.default,
        x.keywords.case
      ]); ) {
        if (this._match(x.keywords.case)) {
          const i = this._case_selectors();
          for (const a of i) if (a instanceof cc) {
            if (t) throw this._error(this._previous(), "Multiple default cases in switch statement.");
            t = true;
            break;
          }
          this._match(x.tokens.colon), this._check(x.tokens.attr) && this._attribute(), this._consume(x.tokens.brace_left, "Exected '{' for switch case.");
          const s = this._case_body();
          this._consume(x.tokens.brace_right, "Exected '}' for switch case."), e.push(this._updateNode(new J3(i, s)));
        }
        if (this._match(x.keywords.default)) {
          if (t) throw this._error(this._previous(), "Multiple default cases in switch statement.");
          this._match(x.tokens.colon), this._check(x.tokens.attr) && this._attribute(), this._consume(x.tokens.brace_left, "Exected '{' for switch default.");
          const i = this._case_body();
          this._consume(x.tokens.brace_right, "Exected '}' for switch default."), e.push(this._updateNode(new e2(i)));
        }
      }
      return e;
    }
    _case_selectors() {
      const e = [];
      for (this._match(x.keywords.default) ? e.push(this._updateNode(new cc())) : e.push(this._shift_expression()); this._match(x.tokens.comma); ) this._match(x.keywords.default) ? e.push(this._updateNode(new cc())) : e.push(this._shift_expression());
      return e;
    }
    _case_body() {
      if (this._match(x.keywords.fallthrough)) return this._consume(x.tokens.semicolon, "Expected ';'"), [];
      let e = this._statement();
      if (e == null) return [];
      e instanceof Array || (e = [
        e
      ]);
      const t = this._case_body();
      return t.length == 0 ? e : [
        ...e,
        t[0]
      ];
    }
    _if_statement() {
      if (!this._match(x.keywords.if)) return null;
      const e = this._currentLine, t = this._optional_paren_expression();
      this._check(x.tokens.attr) && this._attribute();
      const i = this._compound_statement();
      let s = [];
      this._match_elseif() && (this._check(x.tokens.attr) && this._attribute(), s = this._elseif_statement(s));
      let a = null;
      return this._match(x.keywords.else) && (this._check(x.tokens.attr) && this._attribute(), a = this._compound_statement()), this._updateNode(new W3(t, i, s, a), e);
    }
    _match_elseif() {
      return this._tokens[this._current].type === x.keywords.else && this._tokens[this._current + 1].type === x.keywords.if && (this._advance(), this._advance(), true);
    }
    _elseif_statement(e = []) {
      const t = this._optional_paren_expression(), i = this._compound_statement();
      return e.push(this._updateNode(new tC(t, i))), this._match_elseif() && (this._check(x.tokens.attr) && this._attribute(), this._elseif_statement(e)), e;
    }
    _return_statement() {
      if (!this._match(x.keywords.return)) return null;
      const e = this._short_circuit_or_expression();
      return this._updateNode(new $3(e));
    }
    _short_circuit_or_expression() {
      let e = this._short_circuit_and_expr();
      for (; this._match(x.tokens.or_or); ) e = this._updateNode(new xn(this._previous().toString(), e, this._short_circuit_and_expr()));
      return e;
    }
    _short_circuit_and_expr() {
      let e = this._inclusive_or_expression();
      for (; this._match(x.tokens.and_and); ) e = this._updateNode(new xn(this._previous().toString(), e, this._inclusive_or_expression()));
      return e;
    }
    _inclusive_or_expression() {
      let e = this._exclusive_or_expression();
      for (; this._match(x.tokens.or); ) e = this._updateNode(new xn(this._previous().toString(), e, this._exclusive_or_expression()));
      return e;
    }
    _exclusive_or_expression() {
      let e = this._and_expression();
      for (; this._match(x.tokens.xor); ) e = this._updateNode(new xn(this._previous().toString(), e, this._and_expression()));
      return e;
    }
    _and_expression() {
      let e = this._equality_expression();
      for (; this._match(x.tokens.and); ) e = this._updateNode(new xn(this._previous().toString(), e, this._equality_expression()));
      return e;
    }
    _equality_expression() {
      const e = this._relational_expression();
      return this._match([
        x.tokens.equal_equal,
        x.tokens.not_equal
      ]) ? this._updateNode(new xn(this._previous().toString(), e, this._relational_expression())) : e;
    }
    _relational_expression() {
      let e = this._shift_expression();
      for (; this._match([
        x.tokens.less_than,
        x.tokens.greater_than,
        x.tokens.less_than_equal,
        x.tokens.greater_than_equal
      ]); ) e = this._updateNode(new xn(this._previous().toString(), e, this._shift_expression()));
      return e;
    }
    _shift_expression() {
      let e = this._additive_expression();
      for (; this._match([
        x.tokens.shift_left,
        x.tokens.shift_right
      ]); ) e = this._updateNode(new xn(this._previous().toString(), e, this._additive_expression()));
      return e;
    }
    _additive_expression() {
      let e = this._multiplicative_expression();
      for (; this._match([
        x.tokens.plus,
        x.tokens.minus
      ]); ) e = this._updateNode(new xn(this._previous().toString(), e, this._multiplicative_expression()));
      return e;
    }
    _multiplicative_expression() {
      let e = this._unary_expression();
      for (; this._match([
        x.tokens.star,
        x.tokens.forward_slash,
        x.tokens.modulo
      ]); ) e = this._updateNode(new xn(this._previous().toString(), e, this._unary_expression()));
      return e;
    }
    _unary_expression() {
      return this._match([
        x.tokens.minus,
        x.tokens.bang,
        x.tokens.tilde,
        x.tokens.star,
        x.tokens.and
      ]) ? this._updateNode(new ct(this._previous().toString(), this._unary_expression())) : this._singular_expression();
    }
    _singular_expression() {
      const e = this._primary_expression(), t = this._postfix_expression();
      return t && (e.postfix = t), e;
    }
    _postfix_expression() {
      if (this._match(x.tokens.bracket_left)) {
        const e = this._short_circuit_or_expression();
        this._consume(x.tokens.bracket_right, "Expected ']'.");
        const t = this._updateNode(new zr(e)), i = this._postfix_expression();
        return i && (t.postfix = i), t;
      }
      if (this._match(x.tokens.period)) {
        const e = this._consume(x.tokens.name, "Expected member name."), t = this._postfix_expression(), i = this._updateNode(new Rs(e.lexeme));
        return t && (i.postfix = t), i;
      }
      return null;
    }
    _getStruct(e) {
      return this._context.aliases.has(e) ? this._context.aliases.get(e).type : this._context.structs.has(e) ? this._context.structs.get(e) : null;
    }
    _getType(e) {
      const t = this._getStruct(e);
      if (t !== null) return t;
      switch (e) {
        case "void":
          return q.void;
        case "bool":
          return q.bool;
        case "i32":
          return q.i32;
        case "u32":
          return q.u32;
        case "f32":
          return q.f32;
        case "f16":
          return q.f16;
        case "vec2f":
          return k.vec2f;
        case "vec3f":
          return k.vec3f;
        case "vec4f":
          return k.vec4f;
        case "vec2i":
          return k.vec2i;
        case "vec3i":
          return k.vec3i;
        case "vec4i":
          return k.vec4i;
        case "vec2u":
          return k.vec2u;
        case "vec3u":
          return k.vec3u;
        case "vec4u":
          return k.vec4u;
        case "vec2h":
          return k.vec2h;
        case "vec3h":
          return k.vec3h;
        case "vec4h":
          return k.vec4h;
        case "mat2x2f":
          return k.mat2x2f;
        case "mat2x3f":
          return k.mat2x3f;
        case "mat2x4f":
          return k.mat2x4f;
        case "mat3x2f":
          return k.mat3x2f;
        case "mat3x3f":
          return k.mat3x3f;
        case "mat3x4f":
          return k.mat3x4f;
        case "mat4x2f":
          return k.mat4x2f;
        case "mat4x3f":
          return k.mat4x3f;
        case "mat4x4f":
          return k.mat4x4f;
        case "mat2x2h":
          return k.mat2x2h;
        case "mat2x3h":
          return k.mat2x3h;
        case "mat2x4h":
          return k.mat2x4h;
        case "mat3x2h":
          return k.mat3x2h;
        case "mat3x3h":
          return k.mat3x3h;
        case "mat3x4h":
          return k.mat3x4h;
        case "mat4x2h":
          return k.mat4x2h;
        case "mat4x3h":
          return k.mat4x3h;
        case "mat4x4h":
          return k.mat4x4h;
        case "mat2x2i":
          return k.mat2x2i;
        case "mat2x3i":
          return k.mat2x3i;
        case "mat2x4i":
          return k.mat2x4i;
        case "mat3x2i":
          return k.mat3x2i;
        case "mat3x3i":
          return k.mat3x3i;
        case "mat3x4i":
          return k.mat3x4i;
        case "mat4x2i":
          return k.mat4x2i;
        case "mat4x3i":
          return k.mat4x3i;
        case "mat4x4i":
          return k.mat4x4i;
        case "mat2x2u":
          return k.mat2x2u;
        case "mat2x3u":
          return k.mat2x3u;
        case "mat2x4u":
          return k.mat2x4u;
        case "mat3x2u":
          return k.mat3x2u;
        case "mat3x3u":
          return k.mat3x3u;
        case "mat3x4u":
          return k.mat3x4u;
        case "mat4x2u":
          return k.mat4x2u;
        case "mat4x3u":
          return k.mat4x3u;
        case "mat4x4u":
          return k.mat4x4u;
      }
      return null;
    }
    _validateTypeRange(e, t) {
      if (t.name === "i32") {
        if (e < -2147483648 || e > 2147483647) throw this._error(this._previous(), `Value out of range for i32: ${e}. Line: ${this._currentLine}.`);
      } else if (t.name === "u32" && (e < 0 || e > 4294967295)) throw this._error(this._previous(), `Value out of range for u32: ${e}. Line: ${this._currentLine}.`);
    }
    _primary_expression() {
      if (this._match(x.tokens.ident)) {
        const i = this._previous().toString();
        if (this._check(x.tokens.paren_left)) {
          const s = this._argument_expression_list(), a = this._getType(i);
          return a !== null ? this._updateNode(new Pn(a, s)) : this._updateNode(new bg(i, s));
        }
        if (this._context.constants.has(i)) {
          const s = this._context.constants.get(i);
          return this._updateNode(new K3(i, s.value));
        }
        return this._updateNode(new en(i));
      }
      if (this._match(x.tokens.int_literal)) {
        const i = this._previous().toString();
        let s = i.endsWith("i") || i.endsWith("i") ? q.i32 : i.endsWith("u") || i.endsWith("U") ? q.u32 : q.x32;
        const a = parseInt(i);
        return this._validateTypeRange(a, s), this._updateNode(new dt(new I(a, this._exec.getTypeInfo(s)), s));
      }
      if (this._match(x.tokens.uint_literal)) {
        const i = parseInt(this._previous().toString());
        return this._validateTypeRange(i, q.u32), this._updateNode(new dt(new I(i, this._exec.getTypeInfo(q.u32)), q.u32));
      }
      if (this._match([
        x.tokens.decimal_float_literal,
        x.tokens.hex_float_literal
      ])) {
        let i = this._previous().toString(), s = i.endsWith("h");
        s && (i = i.substring(0, i.length - 1));
        const a = parseFloat(i);
        this._validateTypeRange(a, s ? q.f16 : q.f32);
        const l = s ? q.f16 : q.f32;
        return this._updateNode(new dt(new I(a, this._exec.getTypeInfo(l)), l));
      }
      if (this._match([
        x.keywords.true,
        x.keywords.false
      ])) {
        let i = this._previous().toString() === x.keywords.true.rule;
        return this._updateNode(new dt(new I(i ? 1 : 0, this._exec.getTypeInfo(q.bool)), q.bool));
      }
      if (this._check(x.tokens.paren_left)) return this._paren_expression();
      if (this._match(x.keywords.bitcast)) {
        this._consume(x.tokens.less_than, "Expected '<'.");
        const i = this._type_decl();
        this._consume(x.tokens.greater_than, "Expected '>'.");
        const s = this._paren_expression();
        return this._updateNode(new Z3(i, s));
      }
      const e = this._type_decl(), t = this._argument_expression_list();
      return this._updateNode(new Pn(e, t));
    }
    _argument_expression_list() {
      if (!this._match(x.tokens.paren_left)) return null;
      const e = [];
      do {
        if (this._check(x.tokens.paren_right)) break;
        const t = this._short_circuit_or_expression();
        e.push(t);
      } while (this._match(x.tokens.comma));
      return this._consume(x.tokens.paren_right, "Expected ')' for agument list"), e;
    }
    _optional_paren_expression() {
      this._match(x.tokens.paren_left);
      const e = this._short_circuit_or_expression();
      return this._match(x.tokens.paren_right), e;
    }
    _paren_expression() {
      this._consume(x.tokens.paren_left, "Expected '('.");
      const e = this._short_circuit_or_expression();
      return this._consume(x.tokens.paren_right, "Expected ')'."), e;
    }
    _struct_decl() {
      if (!this._match(x.keywords.struct)) return null;
      const e = this._currentLine, t = this._consume(x.tokens.ident, "Expected name for struct.").toString();
      this._consume(x.tokens.brace_left, "Expected '{' for struct body.");
      const i = [];
      for (; !this._check(x.tokens.brace_right); ) {
        const l = this._attribute(), u = this._consume(x.tokens.name, "Expected variable name.").toString();
        this._consume(x.tokens.colon, "Expected ':' for struct member type.");
        const h = this._attribute(), d = this._type_decl();
        d != null && (d.attributes = h), this._check(x.tokens.brace_right) ? this._match(x.tokens.comma) : this._consume(x.tokens.comma, "Expected ',' for struct member."), i.push(this._updateNode(new Yb(u, d, l)));
      }
      this._consume(x.tokens.brace_right, "Expected '}' after struct body.");
      const s = this._currentLine, a = this._updateNode(new si(t, i, e, s), e);
      return this._context.structs.set(t, a), a;
    }
    _global_variable_decl() {
      const e = this._variable_decl();
      if (!e) return null;
      if (this._match(x.tokens.equal)) {
        const t = this._const_expression();
        e.value = t;
      }
      if (e.type !== null && e.value instanceof dt) {
        if (e.value.type.name !== "x32" && e.type.getTypeName() !== e.value.type.getTypeName()) throw this._error(this._peek(), `Invalid cast from ${e.value.type.name} to ${e.type.name}. Line:${this._currentLine}`);
        e.value.isScalar && this._validateTypeRange(e.value.scalarValue, e.type), e.value.type = e.type;
      } else e.type === null && e.value instanceof dt && (e.type = e.value.type.name === "x32" ? q.i32 : e.value.type, e.value.isScalar && this._validateTypeRange(e.value.scalarValue, e.type));
      return e;
    }
    _override_variable_decl() {
      const e = this._override_decl();
      return e && this._match(x.tokens.equal) && (e.value = this._const_expression()), e;
    }
    _global_const_decl() {
      var e;
      if (!this._match(x.keywords.const)) return null;
      const t = this._consume(x.tokens.name, "Expected variable name"), i = this._currentLine;
      let s = null;
      if (this._match(x.tokens.colon)) {
        const h = this._attribute();
        s = this._type_decl(), s != null && (s.attributes = h);
      }
      let a = null;
      this._consume(x.tokens.equal, "const declarations require an assignment");
      const l = this._short_circuit_or_expression();
      try {
        let h = [
          q.f32
        ], d = l.constEvaluate(this._exec, h);
        d instanceof I && this._validateTypeRange(d.value, h[0]), h[0] instanceof k && h[0].format === null && d.typeInfo instanceof Es && d.typeInfo.format !== null && (d.typeInfo.format.name === "f16" ? h[0].format = q.f16 : d.typeInfo.format.name === "f32" ? h[0].format = q.f32 : d.typeInfo.format.name === "i32" ? h[0].format = q.i32 : d.typeInfo.format.name === "u32" ? h[0].format = q.u32 : d.typeInfo.format.name === "bool" ? h[0].format = q.bool : console.error(`TODO: impelement template format type ${d.typeInfo.format.name}`)), a = this._updateNode(new dt(d, h[0])), this._exec.context.setVariable(t.toString(), d);
      } catch {
        a = l;
      }
      if (s !== null && a instanceof dt) {
        if (a.type.name !== "x32" && s.getTypeName() !== a.type.getTypeName()) throw this._error(this._peek(), `Invalid cast from ${a.type.name} to ${s.name}. Line:${this._currentLine}`);
        a.type = s, a.isScalar && this._validateTypeRange(a.scalarValue, a.type);
      } else s === null && a instanceof dt && (s = (e = a == null ? void 0 : a.type) !== null && e !== void 0 ? e : q.f32, s === q.x32 && (s = q.i32));
      const u = this._updateNode(new lc(t.toString(), s, "", "", a), i);
      return this._context.constants.set(u.name, u), u;
    }
    _global_let_decl() {
      if (!this._match(x.keywords.let)) return null;
      const e = this._currentLine, t = this._consume(x.tokens.name, "Expected variable name");
      let i = null;
      if (this._match(x.tokens.colon)) {
        const a = this._attribute();
        i = this._type_decl(), i != null && (i.attributes = a);
      }
      let s = null;
      if (this._match(x.tokens.equal) && (s = this._const_expression()), i !== null && s instanceof dt) {
        if (s.type.name !== "x32" && i.getTypeName() !== s.type.getTypeName()) throw this._error(this._peek(), `Invalid cast from ${s.type.name} to ${i.name}. Line:${this._currentLine}`);
        s.type = i;
      } else i === null && s instanceof dt && (i = s.type.name === "x32" ? q.i32 : s.type);
      return s instanceof dt && s.isScalar && this._validateTypeRange(s.scalarValue, i), this._updateNode(new lo(t.toString(), i, "", "", s), e);
    }
    _const_expression() {
      return this._short_circuit_or_expression();
    }
    _variable_decl() {
      if (!this._match(x.keywords.var)) return null;
      const e = this._currentLine;
      let t = "", i = "";
      this._match(x.tokens.less_than) && (t = this._consume(x.storage_class, "Expected storage_class.").toString(), this._match(x.tokens.comma) && (i = this._consume(x.access_mode, "Expected access_mode.").toString()), this._consume(x.tokens.greater_than, "Expected '>'."));
      const s = this._consume(x.tokens.name, "Expected variable name");
      let a = null;
      if (this._match(x.tokens.colon)) {
        const l = this._attribute();
        a = this._type_decl(), a != null && (a.attributes = l);
      }
      return this._updateNode(new ai(s.toString(), a, t, i, null), e);
    }
    _override_decl() {
      if (!this._match(x.keywords.override)) return null;
      const e = this._consume(x.tokens.name, "Expected variable name");
      let t = null;
      if (this._match(x.tokens.colon)) {
        const i = this._attribute();
        t = this._type_decl(), t != null && (t.attributes = i);
      }
      return this._updateNode(new mg(e.toString(), t, null));
    }
    _diagnostic() {
      this._consume(x.tokens.paren_left, "Expected '('");
      const e = this._consume(x.tokens.ident, "Expected severity control name.");
      this._consume(x.tokens.comma, "Expected ','");
      let t = this._consume(x.tokens.ident, "Expected diagnostic rule name.").toString();
      return this._match(x.tokens.period) && (t += `.${this._consume(x.tokens.ident, "Expected diagnostic message.").toString()}`), this._consume(x.tokens.paren_right, "Expected ')'"), this._updateNode(new X3(e.toString(), t));
    }
    _enable_directive() {
      const e = this._consume(x.tokens.ident, "identity expected.");
      return this._updateNode(new GR(e.toString()));
    }
    _requires_directive() {
      const e = [
        this._consume(x.tokens.ident, "identity expected.").toString()
      ];
      for (; this._match(x.tokens.comma); ) {
        const t = this._consume(x.tokens.ident, "identity expected.");
        e.push(t.toString());
      }
      return this._updateNode(new JR(e));
    }
    _type_alias() {
      const e = this._consume(x.tokens.ident, "identity expected.");
      this._consume(x.tokens.equal, "Expected '=' for type alias.");
      let t = this._type_decl();
      if (t === null) throw this._error(this._peek(), "Expected Type for Alias.");
      this._context.aliases.has(t.name) && (t = this._context.aliases.get(t.name).type);
      const i = this._updateNode(new yg(e.toString(), t));
      return this._context.aliases.set(i.name, i), i;
    }
    _type_decl() {
      if (this._check([
        x.tokens.ident,
        ...x.texel_format,
        x.keywords.bool,
        x.keywords.f32,
        x.keywords.i32,
        x.keywords.u32
      ])) {
        const i = this._advance().toString();
        if (this._context.structs.has(i)) return this._context.structs.get(i);
        if (this._context.aliases.has(i)) return this._context.aliases.get(i).type;
        if (!this._getType(i)) {
          const s = this._updateNode(new $b(i));
          return this._forwardTypeCount++, s;
        }
        return this._updateNode(new q(i));
      }
      let e = this._texture_sampler_types();
      if (e) return e;
      if (this._check(x.template_types)) {
        let i = this._advance().toString(), s = null, a = null;
        return this._match(x.tokens.less_than) && (s = this._type_decl(), a = null, this._match(x.tokens.comma) && (a = this._consume(x.access_mode, "Expected access_mode for pointer").toString()), this._consume(x.tokens.greater_than, "Expected '>' for type.")), this._updateNode(new k(i, s, a));
      }
      if (this._match(x.keywords.ptr)) {
        let i = this._previous().toString();
        this._consume(x.tokens.less_than, "Expected '<' for pointer.");
        const s = this._consume(x.storage_class, "Expected storage_class for pointer");
        this._consume(x.tokens.comma, "Expected ',' for pointer.");
        const a = this._type_decl();
        let l = null;
        return this._match(x.tokens.comma) && (l = this._consume(x.access_mode, "Expected access_mode for pointer").toString()), this._consume(x.tokens.greater_than, "Expected '>' for pointer."), this._updateNode(new Fh(i, s.toString(), a, l));
      }
      const t = this._attribute();
      if (this._match(x.keywords.array)) {
        let i = null, s = -1;
        const a = this._previous();
        let l = null;
        if (this._match(x.tokens.less_than)) {
          i = this._type_decl(), this._context.aliases.has(i.name) && (i = this._context.aliases.get(i.name).type);
          let h = "";
          if (this._match(x.tokens.comma)) {
            l = this._shift_expression();
            try {
              h = l.constEvaluate(this._exec).toString(), l = null;
            } catch {
              h = "1";
            }
          }
          this._consume(x.tokens.greater_than, "Expected '>' for array."), s = h ? parseInt(h) : 0;
        }
        const u = this._updateNode(new co(a.toString(), t, i, s));
        return l && this._deferArrayCountEval.push({
          arrayType: u,
          countNode: l
        }), u;
      }
      return null;
    }
    _texture_sampler_types() {
      if (this._match(x.sampler_type)) return this._updateNode(new no(this._previous().toString(), null, null));
      if (this._match(x.depth_texture_type)) return this._updateNode(new no(this._previous().toString(), null, null));
      if (this._match(x.sampled_texture_type) || this._match(x.multisampled_texture_type)) {
        const e = this._previous();
        this._consume(x.tokens.less_than, "Expected '<' for sampler type.");
        const t = this._type_decl();
        return this._consume(x.tokens.greater_than, "Expected '>' for sampler type."), this._updateNode(new no(e.toString(), t, null));
      }
      if (this._match(x.storage_texture_type)) {
        const e = this._previous();
        this._consume(x.tokens.less_than, "Expected '<' for sampler type.");
        const t = this._consume(x.texel_format, "Invalid texel format.").toString();
        this._consume(x.tokens.comma, "Expected ',' after texel format.");
        const i = this._consume(x.access_mode, "Expected access mode for storage texture type.").toString();
        return this._consume(x.tokens.greater_than, "Expected '>' for sampler type."), this._updateNode(new no(e.toString(), t, i));
      }
      return null;
    }
    _attribute() {
      let e = [];
      for (; this._match(x.tokens.attr); ) {
        const t = this._consume(x.attribute_name, "Expected attribute name"), i = this._updateNode(new t2(t.toString(), null));
        if (this._match(x.tokens.paren_left)) {
          if (i.value = this._consume(x.literal_or_ident, "Expected attribute value").toString(), this._check(x.tokens.comma)) {
            this._advance();
            do {
              const s = this._consume(x.literal_or_ident, "Expected attribute value").toString();
              i.value instanceof Array || (i.value = [
                i.value
              ]), i.value.push(s);
            } while (this._match(x.tokens.comma));
          }
          this._consume(x.tokens.paren_right, "Expected ')'");
        }
        e.push(i);
      }
      return e.length == 0 ? null : e;
    }
  }
  class pC extends Un {
    constructor(e) {
      super(), e && this.update(e);
    }
    update(e) {
      const t = new gC().parse(e);
      this.updateAST(t);
    }
  }
  function mC(n) {
    var _a2;
    const e = {
      attributes: [],
      bindings: []
    };
    let t;
    try {
      t = _C(n);
    } catch (a) {
      return J.error(a.message)(), e;
    }
    for (const a of t.uniforms) {
      const l = [];
      for (const u of ((_a2 = a.type) == null ? void 0 : _a2.members) || []) l.push({
        name: u.name,
        type: Zb(u.type)
      });
      e.bindings.push({
        type: "uniform",
        name: a.name,
        group: a.group,
        location: a.binding,
        members: l
      });
    }
    for (const a of t.textures) e.bindings.push({
      type: "texture",
      name: a.name,
      group: a.group,
      location: a.binding
    });
    for (const a of t.samplers) e.bindings.push({
      type: "sampler",
      name: a.name,
      group: a.group,
      location: a.binding
    });
    const i = t.entry.vertex[0], s = (i == null ? void 0 : i.inputs.length) || 0;
    for (let a = 0; a < s; a++) {
      const l = i.inputs[a];
      if (l.locationType === "location") {
        const u = Zb(l.type);
        e.attributes.push({
          name: l.name,
          location: Number(l.location),
          type: u
        });
      }
    }
    return e;
  }
  function Zb(n) {
    return n.format ? `${n.name}<${n.format.name}>` : n.name;
  }
  function _C(n) {
    try {
      return new pC(n);
    } catch (e) {
      if (e instanceof Error) throw e;
      let t = "WGSL parse error";
      throw typeof e == "object" && (e == null ? void 0 : e.message) && (t += `: ${e.message} `), typeof e == "object" && (e == null ? void 0 : e.token) && (t += e.token.line || ""), new Error(t, {
        cause: e
      });
    }
  }
  const yC = {
    EPSILON: 1e-12,
    debug: false,
    precision: 4,
    printTypes: false,
    printDegrees: false,
    printRowMajor: true,
    _cartographicRadians: false
  };
  globalThis.mathgl = globalThis.mathgl || {
    config: {
      ...yC
    }
  };
  const gn = globalThis.mathgl.config;
  function bC(n, { precision: e = gn.precision } = {}) {
    return n = vC(n), `${parseFloat(n.toPrecision(e))}`;
  }
  function Hr(n) {
    return Array.isArray(n) || ArrayBuffer.isView(n) && !(n instanceof DataView);
  }
  function Hi(n, e, t) {
    return xC(n, (i) => Math.max(e, Math.min(t, i)));
  }
  function Rc(n, e, t) {
    return Hr(n) ? n.map((i, s) => Rc(i, e[s], t)) : t * e + (1 - t) * n;
  }
  function _o(n, e, t) {
    const i = gn.EPSILON;
    try {
      if (n === e) return true;
      if (Hr(n) && Hr(e)) {
        if (n.length !== e.length) return false;
        for (let s = 0; s < n.length; ++s) if (!_o(n[s], e[s])) return false;
        return true;
      }
      return n && n.equals ? n.equals(e) : e && e.equals ? e.equals(n) : typeof n == "number" && typeof e == "number" ? Math.abs(n - e) <= gn.EPSILON * Math.max(1, Math.abs(n), Math.abs(e)) : false;
    } finally {
      gn.EPSILON = i;
    }
  }
  function vC(n) {
    return Math.round(n / gn.EPSILON) * gn.EPSILON;
  }
  function TC(n) {
    return n.clone ? n.clone() : new Array(n.length);
  }
  function xC(n, e, t) {
    if (Hr(n)) {
      const i = n;
      t = t || TC(i);
      for (let s = 0; s < t.length && s < i.length; ++s) {
        const a = typeof n == "number" ? n : n[s];
        t[s] = e(a, s, t);
      }
      return t;
    }
    return e(n);
  }
  class n2 extends Array {
    clone() {
      return new this.constructor().copy(this);
    }
    fromArray(e, t = 0) {
      for (let i = 0; i < this.ELEMENTS; ++i) this[i] = e[i + t];
      return this.check();
    }
    toArray(e = [], t = 0) {
      for (let i = 0; i < this.ELEMENTS; ++i) e[t + i] = this[i];
      return e;
    }
    toObject(e) {
      return e;
    }
    from(e) {
      return Array.isArray(e) ? this.copy(e) : this.fromObject(e);
    }
    to(e) {
      return e === this ? this : Hr(e) ? this.toArray(e) : this.toObject(e);
    }
    toTarget(e) {
      return e ? this.to(e) : this;
    }
    toFloat32Array() {
      return new Float32Array(this);
    }
    toString() {
      return this.formatString(gn);
    }
    formatString(e) {
      let t = "";
      for (let i = 0; i < this.ELEMENTS; ++i) t += (i > 0 ? ", " : "") + bC(this[i], e);
      return `${e.printTypes ? this.constructor.name : ""}[${t}]`;
    }
    equals(e) {
      if (!e || this.length !== e.length) return false;
      for (let t = 0; t < this.ELEMENTS; ++t) if (!_o(this[t], e[t])) return false;
      return true;
    }
    exactEquals(e) {
      if (!e || this.length !== e.length) return false;
      for (let t = 0; t < this.ELEMENTS; ++t) if (this[t] !== e[t]) return false;
      return true;
    }
    negate() {
      for (let e = 0; e < this.ELEMENTS; ++e) this[e] = -this[e];
      return this.check();
    }
    lerp(e, t, i) {
      if (i === void 0) return this.lerp(this, e, t);
      for (let s = 0; s < this.ELEMENTS; ++s) {
        const a = e[s], l = typeof t == "number" ? t : t[s];
        this[s] = a + i * (l - a);
      }
      return this.check();
    }
    min(e) {
      for (let t = 0; t < this.ELEMENTS; ++t) this[t] = Math.min(e[t], this[t]);
      return this.check();
    }
    max(e) {
      for (let t = 0; t < this.ELEMENTS; ++t) this[t] = Math.max(e[t], this[t]);
      return this.check();
    }
    clamp(e, t) {
      for (let i = 0; i < this.ELEMENTS; ++i) this[i] = Math.min(Math.max(this[i], e[i]), t[i]);
      return this.check();
    }
    add(...e) {
      for (const t of e) for (let i = 0; i < this.ELEMENTS; ++i) this[i] += t[i];
      return this.check();
    }
    subtract(...e) {
      for (const t of e) for (let i = 0; i < this.ELEMENTS; ++i) this[i] -= t[i];
      return this.check();
    }
    scale(e) {
      if (typeof e == "number") for (let t = 0; t < this.ELEMENTS; ++t) this[t] *= e;
      else for (let t = 0; t < this.ELEMENTS && t < e.length; ++t) this[t] *= e[t];
      return this.check();
    }
    multiplyByScalar(e) {
      for (let t = 0; t < this.ELEMENTS; ++t) this[t] *= e;
      return this.check();
    }
    check() {
      if (gn.debug && !this.validate()) throw new Error(`math.gl: ${this.constructor.name} some fields set to invalid numbers'`);
      return this;
    }
    validate() {
      let e = this.length === this.ELEMENTS;
      for (let t = 0; t < this.ELEMENTS; ++t) e = e && Number.isFinite(this[t]);
      return e;
    }
    sub(e) {
      return this.subtract(e);
    }
    setScalar(e) {
      for (let t = 0; t < this.ELEMENTS; ++t) this[t] = e;
      return this.check();
    }
    addScalar(e) {
      for (let t = 0; t < this.ELEMENTS; ++t) this[t] += e;
      return this.check();
    }
    subScalar(e) {
      return this.addScalar(-e);
    }
    multiplyScalar(e) {
      for (let t = 0; t < this.ELEMENTS; ++t) this[t] *= e;
      return this.check();
    }
    divideScalar(e) {
      return this.multiplyByScalar(1 / e);
    }
    clampScalar(e, t) {
      for (let i = 0; i < this.ELEMENTS; ++i) this[i] = Math.min(Math.max(this[i], e), t);
      return this.check();
    }
    get elements() {
      return this;
    }
  }
  function SC(n, e) {
    if (n.length !== e) return false;
    for (let t = 0; t < n.length; ++t) if (!Number.isFinite(n[t])) return false;
    return true;
  }
  function Jt(n) {
    if (!Number.isFinite(n)) throw new Error(`Invalid number ${JSON.stringify(n)}`);
    return n;
  }
  function zh(n, e, t = "") {
    if (gn.debug && !SC(n, e)) throw new Error(`math.gl: ${t} some fields set to invalid numbers'`);
    return n;
  }
  function Qb(n, e) {
    if (!n) throw new Error(`math.gl assertion ${e}`);
  }
  class AC extends n2 {
    get x() {
      return this[0];
    }
    set x(e) {
      this[0] = Jt(e);
    }
    get y() {
      return this[1];
    }
    set y(e) {
      this[1] = Jt(e);
    }
    len() {
      return Math.sqrt(this.lengthSquared());
    }
    magnitude() {
      return this.len();
    }
    lengthSquared() {
      let e = 0;
      for (let t = 0; t < this.ELEMENTS; ++t) e += this[t] * this[t];
      return e;
    }
    magnitudeSquared() {
      return this.lengthSquared();
    }
    distance(e) {
      return Math.sqrt(this.distanceSquared(e));
    }
    distanceSquared(e) {
      let t = 0;
      for (let i = 0; i < this.ELEMENTS; ++i) {
        const s = this[i] - e[i];
        t += s * s;
      }
      return Jt(t);
    }
    dot(e) {
      let t = 0;
      for (let i = 0; i < this.ELEMENTS; ++i) t += this[i] * e[i];
      return Jt(t);
    }
    normalize() {
      const e = this.magnitude();
      if (e !== 0) for (let t = 0; t < this.ELEMENTS; ++t) this[t] /= e;
      return this.check();
    }
    multiply(...e) {
      for (const t of e) for (let i = 0; i < this.ELEMENTS; ++i) this[i] *= t[i];
      return this.check();
    }
    divide(...e) {
      for (const t of e) for (let i = 0; i < this.ELEMENTS; ++i) this[i] /= t[i];
      return this.check();
    }
    lengthSq() {
      return this.lengthSquared();
    }
    distanceTo(e) {
      return this.distance(e);
    }
    distanceToSquared(e) {
      return this.distanceSquared(e);
    }
    getComponent(e) {
      return Qb(e >= 0 && e < this.ELEMENTS, "index is out of range"), Jt(this[e]);
    }
    setComponent(e, t) {
      return Qb(e >= 0 && e < this.ELEMENTS, "index is out of range"), this[e] = t, this.check();
    }
    addVectors(e, t) {
      return this.copy(e).add(t);
    }
    subVectors(e, t) {
      return this.copy(e).subtract(t);
    }
    multiplyVectors(e, t) {
      return this.copy(e).multiply(t);
    }
    addScaledVector(e, t) {
      return this.add(new this.constructor(e).multiplyScalar(t));
    }
  }
  const uc = 1e-6;
  let jr = typeof Float32Array < "u" ? Float32Array : Array;
  function wC() {
    const n = new jr(2);
    return jr != Float32Array && (n[0] = 0, n[1] = 0), n;
  }
  function Gb(n, e, t) {
    return n[0] = e[0] + t[0], n[1] = e[1] + t[1], n;
  }
  function EC(n, e) {
    return n[0] = -e[0], n[1] = -e[1], n;
  }
  function i2(n, e, t, i) {
    const s = e[0], a = e[1];
    return n[0] = s + i * (t[0] - s), n[1] = a + i * (t[1] - a), n;
  }
  function RC(n, e, t) {
    const i = e[0], s = e[1];
    return n[0] = t[0] * i + t[4] * s + t[12], n[1] = t[1] * i + t[5] * s + t[13], n;
  }
  (function() {
    const n = wC();
    return function(e, t, i, s, a, l) {
      let u, h;
      for (t || (t = 2), i || (i = 0), s ? h = Math.min(s * t + i, e.length) : h = e.length, u = i; u < h; u += t) n[0] = e[u], n[1] = e[u + 1], a(n, n, l), e[u] = n[0], e[u + 1] = n[1];
      return e;
    };
  })();
  function CC(n, e, t) {
    const i = e[0], s = e[1], a = t[3] * i + t[7] * s || 1;
    return n[0] = (t[0] * i + t[4] * s) / a, n[1] = (t[1] * i + t[5] * s) / a, n;
  }
  function s2(n, e, t) {
    const i = e[0], s = e[1], a = e[2], l = t[3] * i + t[7] * s + t[11] * a || 1;
    return n[0] = (t[0] * i + t[4] * s + t[8] * a) / l, n[1] = (t[1] * i + t[5] * s + t[9] * a) / l, n[2] = (t[2] * i + t[6] * s + t[10] * a) / l, n;
  }
  function MC(n, e, t) {
    const i = e[0], s = e[1];
    return n[0] = t[0] * i + t[2] * s, n[1] = t[1] * i + t[3] * s, n[2] = e[2], n;
  }
  function OC() {
    const n = new jr(3);
    return jr != Float32Array && (n[0] = 0, n[1] = 0, n[2] = 0), n;
  }
  function IC(n, e, t) {
    return n[0] = e[0] - t[0], n[1] = e[1] - t[1], n[2] = e[2] - t[2], n;
  }
  function NC(n, e) {
    return n[0] = -e[0], n[1] = -e[1], n[2] = -e[2], n;
  }
  function PC(n, e) {
    return n[0] * e[0] + n[1] * e[1] + n[2] * e[2];
  }
  function DC(n, e, t) {
    const i = e[0], s = e[1], a = e[2], l = t[0], u = t[1], h = t[2];
    return n[0] = s * h - a * u, n[1] = a * l - i * h, n[2] = i * u - s * l, n;
  }
  function r2(n, e, t) {
    const i = e[0], s = e[1], a = e[2];
    let l = t[3] * i + t[7] * s + t[11] * a + t[15];
    return l = l || 1, n[0] = (t[0] * i + t[4] * s + t[8] * a + t[12]) / l, n[1] = (t[1] * i + t[5] * s + t[9] * a + t[13]) / l, n[2] = (t[2] * i + t[6] * s + t[10] * a + t[14]) / l, n;
  }
  function kC(n, e, t) {
    const i = e[0], s = e[1], a = e[2];
    return n[0] = i * t[0] + s * t[3] + a * t[6], n[1] = i * t[1] + s * t[4] + a * t[7], n[2] = i * t[2] + s * t[5] + a * t[8], n;
  }
  function UC(n, e, t) {
    const i = t[0], s = t[1], a = t[2], l = t[3], u = e[0], h = e[1], d = e[2];
    let p = s * d - a * h, _ = a * u - i * d, y = i * h - s * u, v = s * y - a * _, S = a * p - i * y, E = i * _ - s * p;
    const M = l * 2;
    return p *= M, _ *= M, y *= M, v *= 2, S *= 2, E *= 2, n[0] = u + p + v, n[1] = h + _ + S, n[2] = d + y + E, n;
  }
  function BC(n, e, t, i) {
    const s = [], a = [];
    return s[0] = e[0] - t[0], s[1] = e[1] - t[1], s[2] = e[2] - t[2], a[0] = s[0], a[1] = s[1] * Math.cos(i) - s[2] * Math.sin(i), a[2] = s[1] * Math.sin(i) + s[2] * Math.cos(i), n[0] = a[0] + t[0], n[1] = a[1] + t[1], n[2] = a[2] + t[2], n;
  }
  function LC(n, e, t, i) {
    const s = [], a = [];
    return s[0] = e[0] - t[0], s[1] = e[1] - t[1], s[2] = e[2] - t[2], a[0] = s[2] * Math.sin(i) + s[0] * Math.cos(i), a[1] = s[1], a[2] = s[2] * Math.cos(i) - s[0] * Math.sin(i), n[0] = a[0] + t[0], n[1] = a[1] + t[1], n[2] = a[2] + t[2], n;
  }
  function FC(n, e, t, i) {
    const s = [], a = [];
    return s[0] = e[0] - t[0], s[1] = e[1] - t[1], s[2] = e[2] - t[2], a[0] = s[0] * Math.cos(i) - s[1] * Math.sin(i), a[1] = s[0] * Math.sin(i) + s[1] * Math.cos(i), a[2] = s[2], n[0] = a[0] + t[0], n[1] = a[1] + t[1], n[2] = a[2] + t[2], n;
  }
  function VC(n, e) {
    const t = n[0], i = n[1], s = n[2], a = e[0], l = e[1], u = e[2], h = Math.sqrt((t * t + i * i + s * s) * (a * a + l * l + u * u)), d = h && PC(n, e) / h;
    return Math.acos(Math.min(Math.max(d, -1), 1));
  }
  const zC = IC;
  (function() {
    const n = OC();
    return function(e, t, i, s, a, l) {
      let u, h;
      for (t || (t = 3), i || (i = 0), s ? h = Math.min(s * t + i, e.length) : h = e.length, u = i; u < h; u += t) n[0] = e[u], n[1] = e[u + 1], n[2] = e[u + 2], a(n, n, l), e[u] = n[0], e[u + 1] = n[1], e[u + 2] = n[2];
      return e;
    };
  })();
  const Hh = [
    0,
    0,
    0
  ];
  let Ql;
  class Ln extends AC {
    static get ZERO() {
      return Ql || (Ql = new Ln(0, 0, 0), Object.freeze(Ql)), Ql;
    }
    constructor(e = 0, t = 0, i = 0) {
      super(-0, -0, -0), arguments.length === 1 && Hr(e) ? this.copy(e) : (gn.debug && (Jt(e), Jt(t), Jt(i)), this[0] = e, this[1] = t, this[2] = i);
    }
    set(e, t, i) {
      return this[0] = e, this[1] = t, this[2] = i, this.check();
    }
    copy(e) {
      return this[0] = e[0], this[1] = e[1], this[2] = e[2], this.check();
    }
    fromObject(e) {
      return gn.debug && (Jt(e.x), Jt(e.y), Jt(e.z)), this[0] = e.x, this[1] = e.y, this[2] = e.z, this.check();
    }
    toObject(e) {
      return e.x = this[0], e.y = this[1], e.z = this[2], e;
    }
    get ELEMENTS() {
      return 3;
    }
    get z() {
      return this[2];
    }
    set z(e) {
      this[2] = Jt(e);
    }
    angle(e) {
      return VC(this, e);
    }
    cross(e) {
      return DC(this, this, e), this.check();
    }
    rotateX({ radians: e, origin: t = Hh }) {
      return BC(this, this, t, e), this.check();
    }
    rotateY({ radians: e, origin: t = Hh }) {
      return LC(this, this, t, e), this.check();
    }
    rotateZ({ radians: e, origin: t = Hh }) {
      return FC(this, this, t, e), this.check();
    }
    transform(e) {
      return this.transformAsPoint(e);
    }
    transformAsPoint(e) {
      return r2(this, this, e), this.check();
    }
    transformAsVector(e) {
      return s2(this, this, e), this.check();
    }
    transformByMatrix3(e) {
      return kC(this, this, e), this.check();
    }
    transformByMatrix2(e) {
      return MC(this, this, e), this.check();
    }
    transformByQuaternion(e) {
      return UC(this, this, e), this.check();
    }
  }
  class HC extends n2 {
    toString() {
      let e = "[";
      if (gn.printRowMajor) {
        e += "row-major:";
        for (let t = 0; t < this.RANK; ++t) for (let i = 0; i < this.RANK; ++i) e += ` ${this[i * this.RANK + t]}`;
      } else {
        e += "column-major:";
        for (let t = 0; t < this.ELEMENTS; ++t) e += ` ${this[t]}`;
      }
      return e += "]", e;
    }
    getElementIndex(e, t) {
      return t * this.RANK + e;
    }
    getElement(e, t) {
      return this[t * this.RANK + e];
    }
    setElement(e, t, i) {
      return this[t * this.RANK + e] = Jt(i), this;
    }
    getColumn(e, t = new Array(this.RANK).fill(-0)) {
      const i = e * this.RANK;
      for (let s = 0; s < this.RANK; ++s) t[s] = this[i + s];
      return t;
    }
    setColumn(e, t) {
      const i = e * this.RANK;
      for (let s = 0; s < this.RANK; ++s) this[i + s] = t[s];
      return this;
    }
  }
  function jC(n) {
    return n[0] = 1, n[1] = 0, n[2] = 0, n[3] = 0, n[4] = 0, n[5] = 1, n[6] = 0, n[7] = 0, n[8] = 0, n[9] = 0, n[10] = 1, n[11] = 0, n[12] = 0, n[13] = 0, n[14] = 0, n[15] = 1, n;
  }
  function WC(n, e) {
    if (n === e) {
      const t = e[1], i = e[2], s = e[3], a = e[6], l = e[7], u = e[11];
      n[1] = e[4], n[2] = e[8], n[3] = e[12], n[4] = t, n[6] = e[9], n[7] = e[13], n[8] = i, n[9] = a, n[11] = e[14], n[12] = s, n[13] = l, n[14] = u;
    } else n[0] = e[0], n[1] = e[4], n[2] = e[8], n[3] = e[12], n[4] = e[1], n[5] = e[5], n[6] = e[9], n[7] = e[13], n[8] = e[2], n[9] = e[6], n[10] = e[10], n[11] = e[14], n[12] = e[3], n[13] = e[7], n[14] = e[11], n[15] = e[15];
    return n;
  }
  function Ad(n, e) {
    const t = e[0], i = e[1], s = e[2], a = e[3], l = e[4], u = e[5], h = e[6], d = e[7], p = e[8], _ = e[9], y = e[10], v = e[11], S = e[12], E = e[13], M = e[14], F = e[15], H = t * u - i * l, O = t * h - s * l, U = t * d - a * l, B = i * h - s * u, Z = i * d - a * u, re = s * d - a * h, le = p * E - _ * S, ee = p * M - y * S, fe = p * F - v * S, te = _ * M - y * E, ye = _ * F - v * E, xe = y * F - v * M;
    let ve = H * xe - O * ye + U * te + B * fe - Z * ee + re * le;
    return ve ? (ve = 1 / ve, n[0] = (u * xe - h * ye + d * te) * ve, n[1] = (s * ye - i * xe - a * te) * ve, n[2] = (E * re - M * Z + F * B) * ve, n[3] = (y * Z - _ * re - v * B) * ve, n[4] = (h * fe - l * xe - d * ee) * ve, n[5] = (t * xe - s * fe + a * ee) * ve, n[6] = (M * U - S * re - F * O) * ve, n[7] = (p * re - y * U + v * O) * ve, n[8] = (l * ye - u * fe + d * le) * ve, n[9] = (i * fe - t * ye - a * le) * ve, n[10] = (S * Z - E * U + F * H) * ve, n[11] = (_ * U - p * Z - v * H) * ve, n[12] = (u * ee - l * te - h * le) * ve, n[13] = (t * te - i * ee + s * le) * ve, n[14] = (E * O - S * B - M * H) * ve, n[15] = (p * B - _ * O + y * H) * ve, n) : null;
  }
  function $C(n) {
    const e = n[0], t = n[1], i = n[2], s = n[3], a = n[4], l = n[5], u = n[6], h = n[7], d = n[8], p = n[9], _ = n[10], y = n[11], v = n[12], S = n[13], E = n[14], M = n[15], F = e * l - t * a, H = e * u - i * a, O = t * u - i * l, U = d * S - p * v, B = d * E - _ * v, Z = p * E - _ * S, re = e * Z - t * B + i * U, le = a * Z - l * B + u * U, ee = d * O - p * H + _ * F, fe = v * O - S * H + E * F;
    return h * re - s * le + M * ee - y * fe;
  }
  function xs(n, e, t) {
    const i = e[0], s = e[1], a = e[2], l = e[3], u = e[4], h = e[5], d = e[6], p = e[7], _ = e[8], y = e[9], v = e[10], S = e[11], E = e[12], M = e[13], F = e[14], H = e[15];
    let O = t[0], U = t[1], B = t[2], Z = t[3];
    return n[0] = O * i + U * u + B * _ + Z * E, n[1] = O * s + U * h + B * y + Z * M, n[2] = O * a + U * d + B * v + Z * F, n[3] = O * l + U * p + B * S + Z * H, O = t[4], U = t[5], B = t[6], Z = t[7], n[4] = O * i + U * u + B * _ + Z * E, n[5] = O * s + U * h + B * y + Z * M, n[6] = O * a + U * d + B * v + Z * F, n[7] = O * l + U * p + B * S + Z * H, O = t[8], U = t[9], B = t[10], Z = t[11], n[8] = O * i + U * u + B * _ + Z * E, n[9] = O * s + U * h + B * y + Z * M, n[10] = O * a + U * d + B * v + Z * F, n[11] = O * l + U * p + B * S + Z * H, O = t[12], U = t[13], B = t[14], Z = t[15], n[12] = O * i + U * u + B * _ + Z * E, n[13] = O * s + U * h + B * y + Z * M, n[14] = O * a + U * d + B * v + Z * F, n[15] = O * l + U * p + B * S + Z * H, n;
  }
  function Cc(n, e, t) {
    const i = t[0], s = t[1], a = t[2];
    let l, u, h, d, p, _, y, v, S, E, M, F;
    return e === n ? (n[12] = e[0] * i + e[4] * s + e[8] * a + e[12], n[13] = e[1] * i + e[5] * s + e[9] * a + e[13], n[14] = e[2] * i + e[6] * s + e[10] * a + e[14], n[15] = e[3] * i + e[7] * s + e[11] * a + e[15]) : (l = e[0], u = e[1], h = e[2], d = e[3], p = e[4], _ = e[5], y = e[6], v = e[7], S = e[8], E = e[9], M = e[10], F = e[11], n[0] = l, n[1] = u, n[2] = h, n[3] = d, n[4] = p, n[5] = _, n[6] = y, n[7] = v, n[8] = S, n[9] = E, n[10] = M, n[11] = F, n[12] = l * i + p * s + S * a + e[12], n[13] = u * i + _ * s + E * a + e[13], n[14] = h * i + y * s + M * a + e[14], n[15] = d * i + v * s + F * a + e[15]), n;
  }
  function Sg(n, e, t) {
    const i = t[0], s = t[1], a = t[2];
    return n[0] = e[0] * i, n[1] = e[1] * i, n[2] = e[2] * i, n[3] = e[3] * i, n[4] = e[4] * s, n[5] = e[5] * s, n[6] = e[6] * s, n[7] = e[7] * s, n[8] = e[8] * a, n[9] = e[9] * a, n[10] = e[10] * a, n[11] = e[11] * a, n[12] = e[12], n[13] = e[13], n[14] = e[14], n[15] = e[15], n;
  }
  function XC(n, e, t, i) {
    let s = i[0], a = i[1], l = i[2], u = Math.sqrt(s * s + a * a + l * l), h, d, p, _, y, v, S, E, M, F, H, O, U, B, Z, re, le, ee, fe, te, ye, xe, ve, Ue;
    return u < uc ? null : (u = 1 / u, s *= u, a *= u, l *= u, d = Math.sin(t), h = Math.cos(t), p = 1 - h, _ = e[0], y = e[1], v = e[2], S = e[3], E = e[4], M = e[5], F = e[6], H = e[7], O = e[8], U = e[9], B = e[10], Z = e[11], re = s * s * p + h, le = a * s * p + l * d, ee = l * s * p - a * d, fe = s * a * p - l * d, te = a * a * p + h, ye = l * a * p + s * d, xe = s * l * p + a * d, ve = a * l * p - s * d, Ue = l * l * p + h, n[0] = _ * re + E * le + O * ee, n[1] = y * re + M * le + U * ee, n[2] = v * re + F * le + B * ee, n[3] = S * re + H * le + Z * ee, n[4] = _ * fe + E * te + O * ye, n[5] = y * fe + M * te + U * ye, n[6] = v * fe + F * te + B * ye, n[7] = S * fe + H * te + Z * ye, n[8] = _ * xe + E * ve + O * Ue, n[9] = y * xe + M * ve + U * Ue, n[10] = v * xe + F * ve + B * Ue, n[11] = S * xe + H * ve + Z * Ue, e !== n && (n[12] = e[12], n[13] = e[13], n[14] = e[14], n[15] = e[15]), n);
  }
  function a2(n, e, t) {
    const i = Math.sin(t), s = Math.cos(t), a = e[4], l = e[5], u = e[6], h = e[7], d = e[8], p = e[9], _ = e[10], y = e[11];
    return e !== n && (n[0] = e[0], n[1] = e[1], n[2] = e[2], n[3] = e[3], n[12] = e[12], n[13] = e[13], n[14] = e[14], n[15] = e[15]), n[4] = a * s + d * i, n[5] = l * s + p * i, n[6] = u * s + _ * i, n[7] = h * s + y * i, n[8] = d * s - a * i, n[9] = p * s - l * i, n[10] = _ * s - u * i, n[11] = y * s - h * i, n;
  }
  function YC(n, e, t) {
    const i = Math.sin(t), s = Math.cos(t), a = e[0], l = e[1], u = e[2], h = e[3], d = e[8], p = e[9], _ = e[10], y = e[11];
    return e !== n && (n[4] = e[4], n[5] = e[5], n[6] = e[6], n[7] = e[7], n[12] = e[12], n[13] = e[13], n[14] = e[14], n[15] = e[15]), n[0] = a * s - d * i, n[1] = l * s - p * i, n[2] = u * s - _ * i, n[3] = h * s - y * i, n[8] = a * i + d * s, n[9] = l * i + p * s, n[10] = u * i + _ * s, n[11] = h * i + y * s, n;
  }
  function o2(n, e, t) {
    const i = Math.sin(t), s = Math.cos(t), a = e[0], l = e[1], u = e[2], h = e[3], d = e[4], p = e[5], _ = e[6], y = e[7];
    return e !== n && (n[8] = e[8], n[9] = e[9], n[10] = e[10], n[11] = e[11], n[12] = e[12], n[13] = e[13], n[14] = e[14], n[15] = e[15]), n[0] = a * s + d * i, n[1] = l * s + p * i, n[2] = u * s + _ * i, n[3] = h * s + y * i, n[4] = d * s - a * i, n[5] = p * s - l * i, n[6] = _ * s - u * i, n[7] = y * s - h * i, n;
  }
  function qC(n, e) {
    const t = e[0], i = e[1], s = e[2], a = e[3], l = t + t, u = i + i, h = s + s, d = t * l, p = i * l, _ = i * u, y = s * l, v = s * u, S = s * h, E = a * l, M = a * u, F = a * h;
    return n[0] = 1 - _ - S, n[1] = p + F, n[2] = y - M, n[3] = 0, n[4] = p - F, n[5] = 1 - d - S, n[6] = v + E, n[7] = 0, n[8] = y + M, n[9] = v - E, n[10] = 1 - d - _, n[11] = 0, n[12] = 0, n[13] = 0, n[14] = 0, n[15] = 1, n;
  }
  function KC(n, e, t, i, s, a, l) {
    const u = 1 / (t - e), h = 1 / (s - i), d = 1 / (a - l);
    return n[0] = a * 2 * u, n[1] = 0, n[2] = 0, n[3] = 0, n[4] = 0, n[5] = a * 2 * h, n[6] = 0, n[7] = 0, n[8] = (t + e) * u, n[9] = (s + i) * h, n[10] = (l + a) * d, n[11] = -1, n[12] = 0, n[13] = 0, n[14] = l * a * 2 * d, n[15] = 0, n;
  }
  function ZC(n, e, t, i, s) {
    const a = 1 / Math.tan(e / 2);
    if (n[0] = a / t, n[1] = 0, n[2] = 0, n[3] = 0, n[4] = 0, n[5] = a, n[6] = 0, n[7] = 0, n[8] = 0, n[9] = 0, n[11] = -1, n[12] = 0, n[13] = 0, n[15] = 0, s != null && s !== 1 / 0) {
      const l = 1 / (i - s);
      n[10] = (s + i) * l, n[14] = 2 * s * i * l;
    } else n[10] = -1, n[14] = -2 * i;
    return n;
  }
  const QC = ZC;
  function GC(n, e, t, i, s, a, l) {
    const u = 1 / (e - t), h = 1 / (i - s), d = 1 / (a - l);
    return n[0] = -2 * u, n[1] = 0, n[2] = 0, n[3] = 0, n[4] = 0, n[5] = -2 * h, n[6] = 0, n[7] = 0, n[8] = 0, n[9] = 0, n[10] = 2 * d, n[11] = 0, n[12] = (e + t) * u, n[13] = (s + i) * h, n[14] = (l + a) * d, n[15] = 1, n;
  }
  const JC = GC;
  function eM(n, e, t, i) {
    let s, a, l, u, h, d, p, _, y, v;
    const S = e[0], E = e[1], M = e[2], F = i[0], H = i[1], O = i[2], U = t[0], B = t[1], Z = t[2];
    return Math.abs(S - U) < uc && Math.abs(E - B) < uc && Math.abs(M - Z) < uc ? jC(n) : (_ = S - U, y = E - B, v = M - Z, s = 1 / Math.sqrt(_ * _ + y * y + v * v), _ *= s, y *= s, v *= s, a = H * v - O * y, l = O * _ - F * v, u = F * y - H * _, s = Math.sqrt(a * a + l * l + u * u), s ? (s = 1 / s, a *= s, l *= s, u *= s) : (a = 0, l = 0, u = 0), h = y * u - v * l, d = v * a - _ * u, p = _ * l - y * a, s = Math.sqrt(h * h + d * d + p * p), s ? (s = 1 / s, h *= s, d *= s, p *= s) : (h = 0, d = 0, p = 0), n[0] = a, n[1] = h, n[2] = _, n[3] = 0, n[4] = l, n[5] = d, n[6] = y, n[7] = 0, n[8] = u, n[9] = p, n[10] = v, n[11] = 0, n[12] = -(a * S + l * E + u * M), n[13] = -(h * S + d * E + p * M), n[14] = -(_ * S + y * E + v * M), n[15] = 1, n);
  }
  function tM() {
    const n = new jr(4);
    return jr != Float32Array && (n[0] = 0, n[1] = 0, n[2] = 0, n[3] = 0), n;
  }
  function nM(n, e, t) {
    return n[0] = e[0] * t, n[1] = e[1] * t, n[2] = e[2] * t, n[3] = e[3] * t, n;
  }
  function Eo(n, e, t) {
    const i = e[0], s = e[1], a = e[2], l = e[3];
    return n[0] = t[0] * i + t[4] * s + t[8] * a + t[12] * l, n[1] = t[1] * i + t[5] * s + t[9] * a + t[13] * l, n[2] = t[2] * i + t[6] * s + t[10] * a + t[14] * l, n[3] = t[3] * i + t[7] * s + t[11] * a + t[15] * l, n;
  }
  (function() {
    const n = tM();
    return function(e, t, i, s, a, l) {
      let u, h;
      for (t || (t = 4), i || (i = 0), s ? h = Math.min(s * t + i, e.length) : h = e.length, u = i; u < h; u += t) n[0] = e[u], n[1] = e[u + 1], n[2] = e[u + 2], n[3] = e[u + 3], a(n, n, l), e[u] = n[0], e[u + 1] = n[1], e[u + 2] = n[2], e[u + 3] = n[3];
      return e;
    };
  })();
  var wd;
  (function(n) {
    n[n.COL0ROW0 = 0] = "COL0ROW0", n[n.COL0ROW1 = 1] = "COL0ROW1", n[n.COL0ROW2 = 2] = "COL0ROW2", n[n.COL0ROW3 = 3] = "COL0ROW3", n[n.COL1ROW0 = 4] = "COL1ROW0", n[n.COL1ROW1 = 5] = "COL1ROW1", n[n.COL1ROW2 = 6] = "COL1ROW2", n[n.COL1ROW3 = 7] = "COL1ROW3", n[n.COL2ROW0 = 8] = "COL2ROW0", n[n.COL2ROW1 = 9] = "COL2ROW1", n[n.COL2ROW2 = 10] = "COL2ROW2", n[n.COL2ROW3 = 11] = "COL2ROW3", n[n.COL3ROW0 = 12] = "COL3ROW0", n[n.COL3ROW1 = 13] = "COL3ROW1", n[n.COL3ROW2 = 14] = "COL3ROW2", n[n.COL3ROW3 = 15] = "COL3ROW3";
  })(wd || (wd = {}));
  const iM = 45 * Math.PI / 180, sM = 1, jh = 0.1, Wh = 500, rM = Object.freeze([
    1,
    0,
    0,
    0,
    0,
    1,
    0,
    0,
    0,
    0,
    1,
    0,
    0,
    0,
    0,
    1
  ]);
  class Fn extends HC {
    static get IDENTITY() {
      return oM();
    }
    static get ZERO() {
      return aM();
    }
    get ELEMENTS() {
      return 16;
    }
    get RANK() {
      return 4;
    }
    get INDICES() {
      return wd;
    }
    constructor(e) {
      super(-0, -0, -0, -0, -0, -0, -0, -0, -0, -0, -0, -0, -0, -0, -0, -0), arguments.length === 1 && Array.isArray(e) ? this.copy(e) : this.identity();
    }
    copy(e) {
      return this[0] = e[0], this[1] = e[1], this[2] = e[2], this[3] = e[3], this[4] = e[4], this[5] = e[5], this[6] = e[6], this[7] = e[7], this[8] = e[8], this[9] = e[9], this[10] = e[10], this[11] = e[11], this[12] = e[12], this[13] = e[13], this[14] = e[14], this[15] = e[15], this.check();
    }
    set(e, t, i, s, a, l, u, h, d, p, _, y, v, S, E, M) {
      return this[0] = e, this[1] = t, this[2] = i, this[3] = s, this[4] = a, this[5] = l, this[6] = u, this[7] = h, this[8] = d, this[9] = p, this[10] = _, this[11] = y, this[12] = v, this[13] = S, this[14] = E, this[15] = M, this.check();
    }
    setRowMajor(e, t, i, s, a, l, u, h, d, p, _, y, v, S, E, M) {
      return this[0] = e, this[1] = a, this[2] = d, this[3] = v, this[4] = t, this[5] = l, this[6] = p, this[7] = S, this[8] = i, this[9] = u, this[10] = _, this[11] = E, this[12] = s, this[13] = h, this[14] = y, this[15] = M, this.check();
    }
    toRowMajor(e) {
      return e[0] = this[0], e[1] = this[4], e[2] = this[8], e[3] = this[12], e[4] = this[1], e[5] = this[5], e[6] = this[9], e[7] = this[13], e[8] = this[2], e[9] = this[6], e[10] = this[10], e[11] = this[14], e[12] = this[3], e[13] = this[7], e[14] = this[11], e[15] = this[15], e;
    }
    identity() {
      return this.copy(rM);
    }
    fromObject(e) {
      return this.check();
    }
    fromQuaternion(e) {
      return qC(this, e), this.check();
    }
    frustum(e) {
      const { left: t, right: i, bottom: s, top: a, near: l = jh, far: u = Wh } = e;
      return u === 1 / 0 ? lM(this, t, i, s, a, l) : KC(this, t, i, s, a, l, u), this.check();
    }
    lookAt(e) {
      const { eye: t, center: i = [
        0,
        0,
        0
      ], up: s = [
        0,
        1,
        0
      ] } = e;
      return eM(this, t, i, s), this.check();
    }
    ortho(e) {
      const { left: t, right: i, bottom: s, top: a, near: l = jh, far: u = Wh } = e;
      return JC(this, t, i, s, a, l, u), this.check();
    }
    orthographic(e) {
      const { fovy: t = iM, aspect: i = sM, focalDistance: s = 1, near: a = jh, far: l = Wh } = e;
      Jb(t);
      const u = t / 2, h = s * Math.tan(u), d = h * i;
      return this.ortho({
        left: -d,
        right: d,
        bottom: -h,
        top: h,
        near: a,
        far: l
      });
    }
    perspective(e) {
      const { fovy: t = 45 * Math.PI / 180, aspect: i = 1, near: s = 0.1, far: a = 500 } = e;
      return Jb(t), QC(this, t, i, s, a), this.check();
    }
    determinant() {
      return $C(this);
    }
    getScale(e = [
      -0,
      -0,
      -0
    ]) {
      return e[0] = Math.sqrt(this[0] * this[0] + this[1] * this[1] + this[2] * this[2]), e[1] = Math.sqrt(this[4] * this[4] + this[5] * this[5] + this[6] * this[6]), e[2] = Math.sqrt(this[8] * this[8] + this[9] * this[9] + this[10] * this[10]), e;
    }
    getTranslation(e = [
      -0,
      -0,
      -0
    ]) {
      return e[0] = this[12], e[1] = this[13], e[2] = this[14], e;
    }
    getRotation(e, t) {
      e = e || [
        -0,
        -0,
        -0,
        -0,
        -0,
        -0,
        -0,
        -0,
        -0,
        -0,
        -0,
        -0,
        -0,
        -0,
        -0,
        -0
      ], t = t || [
        -0,
        -0,
        -0
      ];
      const i = this.getScale(t), s = 1 / i[0], a = 1 / i[1], l = 1 / i[2];
      return e[0] = this[0] * s, e[1] = this[1] * a, e[2] = this[2] * l, e[3] = 0, e[4] = this[4] * s, e[5] = this[5] * a, e[6] = this[6] * l, e[7] = 0, e[8] = this[8] * s, e[9] = this[9] * a, e[10] = this[10] * l, e[11] = 0, e[12] = 0, e[13] = 0, e[14] = 0, e[15] = 1, e;
    }
    getRotationMatrix3(e, t) {
      e = e || [
        -0,
        -0,
        -0,
        -0,
        -0,
        -0,
        -0,
        -0,
        -0
      ], t = t || [
        -0,
        -0,
        -0
      ];
      const i = this.getScale(t), s = 1 / i[0], a = 1 / i[1], l = 1 / i[2];
      return e[0] = this[0] * s, e[1] = this[1] * a, e[2] = this[2] * l, e[3] = this[4] * s, e[4] = this[5] * a, e[5] = this[6] * l, e[6] = this[8] * s, e[7] = this[9] * a, e[8] = this[10] * l, e;
    }
    transpose() {
      return WC(this, this), this.check();
    }
    invert() {
      return Ad(this, this), this.check();
    }
    multiplyLeft(e) {
      return xs(this, e, this), this.check();
    }
    multiplyRight(e) {
      return xs(this, this, e), this.check();
    }
    rotateX(e) {
      return a2(this, this, e), this.check();
    }
    rotateY(e) {
      return YC(this, this, e), this.check();
    }
    rotateZ(e) {
      return o2(this, this, e), this.check();
    }
    rotateXYZ(e) {
      return this.rotateX(e[0]).rotateY(e[1]).rotateZ(e[2]);
    }
    rotateAxis(e, t) {
      return XC(this, this, e, t), this.check();
    }
    scale(e) {
      return Sg(this, this, Array.isArray(e) ? e : [
        e,
        e,
        e
      ]), this.check();
    }
    translate(e) {
      return Cc(this, this, e), this.check();
    }
    transform(e, t) {
      return e.length === 4 ? (t = Eo(t || [
        -0,
        -0,
        -0,
        -0
      ], e, this), zh(t, 4), t) : this.transformAsPoint(e, t);
    }
    transformAsPoint(e, t) {
      const { length: i } = e;
      let s;
      switch (i) {
        case 2:
          s = RC(t || [
            -0,
            -0
          ], e, this);
          break;
        case 3:
          s = r2(t || [
            -0,
            -0,
            -0
          ], e, this);
          break;
        default:
          throw new Error("Illegal vector");
      }
      return zh(s, e.length), s;
    }
    transformAsVector(e, t) {
      let i;
      switch (e.length) {
        case 2:
          i = CC(t || [
            -0,
            -0
          ], e, this);
          break;
        case 3:
          i = s2(t || [
            -0,
            -0,
            -0
          ], e, this);
          break;
        default:
          throw new Error("Illegal vector");
      }
      return zh(i, e.length), i;
    }
    transformPoint(e, t) {
      return this.transformAsPoint(e, t);
    }
    transformVector(e, t) {
      return this.transformAsPoint(e, t);
    }
    transformDirection(e, t) {
      return this.transformAsVector(e, t);
    }
    makeRotationX(e) {
      return this.identity().rotateX(e);
    }
    makeTranslation(e, t, i) {
      return this.identity().translate([
        e,
        t,
        i
      ]);
    }
  }
  let Gl, Jl;
  function aM() {
    return Gl || (Gl = new Fn([
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ]), Object.freeze(Gl)), Gl;
  }
  function oM() {
    return Jl || (Jl = new Fn(), Object.freeze(Jl)), Jl;
  }
  function Jb(n) {
    if (n > Math.PI * 2) throw Error("expected radians");
  }
  function lM(n, e, t, i, s, a) {
    const l = 2 * a / (t - e), u = 2 * a / (s - i), h = (t + e) / (t - e), d = (s + i) / (s - i), p = -1, _ = -1, y = -2 * a;
    return n[0] = l, n[1] = 0, n[2] = 0, n[3] = 0, n[4] = 0, n[5] = u, n[6] = 0, n[7] = 0, n[8] = h, n[9] = d, n[10] = p, n[11] = _, n[12] = 0, n[13] = 0, n[14] = y, n[15] = 0, n;
  }
  function l2(n, e = [], t = 0) {
    const i = Math.fround(n), s = n - i;
    return e[t] = i, e[t + 1] = s, e;
  }
  function cM(n) {
    return n - Math.fround(n);
  }
  function uM(n) {
    const e = new Float32Array(32);
    for (let t = 0; t < 4; ++t) for (let i = 0; i < 4; ++i) {
      const s = t * 4 + i;
      l2(n[i * 4 + t], e, s * 2);
    }
    return e;
  }
  const fM = `#ifdef LUMA_FP32_TAN_PRECISION_WORKAROUND

// All these functions are for substituting tan() function from Intel GPU only
const float TWO_PI = 6.2831854820251465;
const float PI_2 = 1.5707963705062866;
const float PI_16 = 0.1963495463132858;

const float SIN_TABLE_0 = 0.19509032368659973;
const float SIN_TABLE_1 = 0.3826834261417389;
const float SIN_TABLE_2 = 0.5555702447891235;
const float SIN_TABLE_3 = 0.7071067690849304;

const float COS_TABLE_0 = 0.9807852506637573;
const float COS_TABLE_1 = 0.9238795042037964;
const float COS_TABLE_2 = 0.8314695954322815;
const float COS_TABLE_3 = 0.7071067690849304;

const float INVERSE_FACTORIAL_3 = 1.666666716337204e-01; // 1/3!
const float INVERSE_FACTORIAL_5 = 8.333333767950535e-03; // 1/5!
const float INVERSE_FACTORIAL_7 = 1.9841270113829523e-04; // 1/7!
const float INVERSE_FACTORIAL_9 = 2.75573188446287533e-06; // 1/9!

float sin_taylor_fp32(float a) {
  float r, s, t, x;

  if (a == 0.0) {
    return 0.0;
  }

  x = -a * a;
  s = a;
  r = a;

  r = r * x;
  t = r * INVERSE_FACTORIAL_3;
  s = s + t;

  r = r * x;
  t = r * INVERSE_FACTORIAL_5;
  s = s + t;

  r = r * x;
  t = r * INVERSE_FACTORIAL_7;
  s = s + t;

  r = r * x;
  t = r * INVERSE_FACTORIAL_9;
  s = s + t;

  return s;
}

void sincos_taylor_fp32(float a, out float sin_t, out float cos_t) {
  if (a == 0.0) {
    sin_t = 0.0;
    cos_t = 1.0;
  }
  sin_t = sin_taylor_fp32(a);
  cos_t = sqrt(1.0 - sin_t * sin_t);
}

float tan_taylor_fp32(float a) {
    float sin_a;
    float cos_a;

    if (a == 0.0) {
        return 0.0;
    }

    // 2pi range reduction
    float z = floor(a / TWO_PI);
    float r = a - TWO_PI * z;

    float t;
    float q = floor(r / PI_2 + 0.5);
    int j = int(q);

    if (j < -2 || j > 2) {
        return 1.0 / 0.0;
    }

    t = r - PI_2 * q;

    q = floor(t / PI_16 + 0.5);
    int k = int(q);
    int abs_k = int(abs(float(k)));

    if (abs_k > 4) {
        return 1.0 / 0.0;
    } else {
        t = t - PI_16 * q;
    }

    float u = 0.0;
    float v = 0.0;

    float sin_t, cos_t;
    float s, c;
    sincos_taylor_fp32(t, sin_t, cos_t);

    if (k == 0) {
        s = sin_t;
        c = cos_t;
    } else {
        if (abs(float(abs_k) - 1.0) < 0.5) {
            u = COS_TABLE_0;
            v = SIN_TABLE_0;
        } else if (abs(float(abs_k) - 2.0) < 0.5) {
            u = COS_TABLE_1;
            v = SIN_TABLE_1;
        } else if (abs(float(abs_k) - 3.0) < 0.5) {
            u = COS_TABLE_2;
            v = SIN_TABLE_2;
        } else if (abs(float(abs_k) - 4.0) < 0.5) {
            u = COS_TABLE_3;
            v = SIN_TABLE_3;
        }
        if (k > 0) {
            s = u * sin_t + v * cos_t;
            c = u * cos_t - v * sin_t;
        } else {
            s = u * sin_t - v * cos_t;
            c = u * cos_t + v * sin_t;
        }
    }

    if (j == 0) {
        sin_a = s;
        cos_a = c;
    } else if (j == 1) {
        sin_a = c;
        cos_a = -s;
    } else if (j == -1) {
        sin_a = -c;
        cos_a = s;
    } else {
        sin_a = -s;
        cos_a = -c;
    }
    return sin_a / cos_a;
}
#endif

float tan_fp32(float a) {
#ifdef LUMA_FP32_TAN_PRECISION_WORKAROUND
  return tan_taylor_fp32(a);
#else
  return tan(a);
#endif
}
`, hM = {
    name: "fp32",
    vs: fM
  }, dM = `
uniform fp64arithmeticUniforms {
  uniform float ONE;
} fp64;

/*
About LUMA_FP64_CODE_ELIMINATION_WORKAROUND

The purpose of this workaround is to prevent shader compilers from
optimizing away necessary arithmetic operations by swapping their sequences
or transform the equation to some 'equivalent' form.

The method is to multiply an artifical variable, ONE, which will be known to
the compiler to be 1 only at runtime. The whole expression is then represented
as a polynomial with respective to ONE. In the coefficients of all terms, only one a
and one b should appear

err = (a + b) * ONE^6 - a * ONE^5 - (a + b) * ONE^4 + a * ONE^3 - b - (a + b) * ONE^2 + a * ONE
*/

// Divide float number to high and low floats to extend fraction bits
vec2 split(float a) {
  const float SPLIT = 4097.0;
  float t = a * SPLIT;
#if defined(LUMA_FP64_CODE_ELIMINATION_WORKAROUND)
  float a_hi = t * fp64.ONE - (t - a);
  float a_lo = a * fp64.ONE - a_hi;
#else
  float a_hi = t - (t - a);
  float a_lo = a - a_hi;
#endif
  return vec2(a_hi, a_lo);
}

// Divide float number again when high float uses too many fraction bits
vec2 split2(vec2 a) {
  vec2 b = split(a.x);
  b.y += a.y;
  return b;
}

// Special sum operation when a > b
vec2 quickTwoSum(float a, float b) {
#if defined(LUMA_FP64_CODE_ELIMINATION_WORKAROUND)
  float sum = (a + b) * fp64.ONE;
  float err = b - (sum - a) * fp64.ONE;
#else
  float sum = a + b;
  float err = b - (sum - a);
#endif
  return vec2(sum, err);
}

// General sum operation
vec2 twoSum(float a, float b) {
  float s = (a + b);
#if defined(LUMA_FP64_CODE_ELIMINATION_WORKAROUND)
  float v = (s * fp64.ONE - a) * fp64.ONE;
  float err = (a - (s - v) * fp64.ONE) * fp64.ONE * fp64.ONE * fp64.ONE + (b - v);
#else
  float v = s - a;
  float err = (a - (s - v)) + (b - v);
#endif
  return vec2(s, err);
}

vec2 twoSub(float a, float b) {
  float s = (a - b);
#if defined(LUMA_FP64_CODE_ELIMINATION_WORKAROUND)
  float v = (s * fp64.ONE - a) * fp64.ONE;
  float err = (a - (s - v) * fp64.ONE) * fp64.ONE * fp64.ONE * fp64.ONE - (b + v);
#else
  float v = s - a;
  float err = (a - (s - v)) - (b + v);
#endif
  return vec2(s, err);
}

vec2 twoSqr(float a) {
  float prod = a * a;
  vec2 a_fp64 = split(a);
#if defined(LUMA_FP64_CODE_ELIMINATION_WORKAROUND)
  float err = ((a_fp64.x * a_fp64.x - prod) * fp64.ONE + 2.0 * a_fp64.x *
    a_fp64.y * fp64.ONE * fp64.ONE) + a_fp64.y * a_fp64.y * fp64.ONE * fp64.ONE * fp64.ONE;
#else
  float err = ((a_fp64.x * a_fp64.x - prod) + 2.0 * a_fp64.x * a_fp64.y) + a_fp64.y * a_fp64.y;
#endif
  return vec2(prod, err);
}

vec2 twoProd(float a, float b) {
  float prod = a * b;
  vec2 a_fp64 = split(a);
  vec2 b_fp64 = split(b);
  float err = ((a_fp64.x * b_fp64.x - prod) + a_fp64.x * b_fp64.y +
    a_fp64.y * b_fp64.x) + a_fp64.y * b_fp64.y;
  return vec2(prod, err);
}

vec2 sum_fp64(vec2 a, vec2 b) {
  vec2 s, t;
  s = twoSum(a.x, b.x);
  t = twoSum(a.y, b.y);
  s.y += t.x;
  s = quickTwoSum(s.x, s.y);
  s.y += t.y;
  s = quickTwoSum(s.x, s.y);
  return s;
}

vec2 sub_fp64(vec2 a, vec2 b) {
  vec2 s, t;
  s = twoSub(a.x, b.x);
  t = twoSub(a.y, b.y);
  s.y += t.x;
  s = quickTwoSum(s.x, s.y);
  s.y += t.y;
  s = quickTwoSum(s.x, s.y);
  return s;
}

vec2 mul_fp64(vec2 a, vec2 b) {
  vec2 prod = twoProd(a.x, b.x);
  // y component is for the error
  prod.y += a.x * b.y;
#if defined(LUMA_FP64_HIGH_BITS_OVERFLOW_WORKAROUND)
  prod = split2(prod);
#endif
  prod = quickTwoSum(prod.x, prod.y);
  prod.y += a.y * b.x;
#if defined(LUMA_FP64_HIGH_BITS_OVERFLOW_WORKAROUND)
  prod = split2(prod);
#endif
  prod = quickTwoSum(prod.x, prod.y);
  return prod;
}

vec2 div_fp64(vec2 a, vec2 b) {
  float xn = 1.0 / b.x;
#if defined(LUMA_FP64_HIGH_BITS_OVERFLOW_WORKAROUND)
  vec2 yn = mul_fp64(a, vec2(xn, 0));
#else
  vec2 yn = a * xn;
#endif
  float diff = (sub_fp64(a, mul_fp64(b, yn))).x;
  vec2 prod = twoProd(xn, diff);
  return sum_fp64(yn, prod);
}

vec2 sqrt_fp64(vec2 a) {
  if (a.x == 0.0 && a.y == 0.0) return vec2(0.0, 0.0);
  if (a.x < 0.0) return vec2(0.0 / 0.0, 0.0 / 0.0);

  float x = 1.0 / sqrt(a.x);
  float yn = a.x * x;
#if defined(LUMA_FP64_CODE_ELIMINATION_WORKAROUND)
  vec2 yn_sqr = twoSqr(yn) * fp64.ONE;
#else
  vec2 yn_sqr = twoSqr(yn);
#endif
  float diff = sub_fp64(a, yn_sqr).x;
  vec2 prod = twoProd(x * 0.5, diff);
#if defined(LUMA_FP64_HIGH_BITS_OVERFLOW_WORKAROUND)
  return sum_fp64(split(yn), prod);
#else
  return sum_fp64(vec2(yn, 0.0), prod);
#endif
}
`, gM = {
    ONE: 1
  }, pM = {
    name: "fp64arithmetic",
    vs: dM,
    defaultUniforms: gM,
    uniformTypes: {
      ONE: "f32"
    },
    fp64ify: l2,
    fp64LowPart: cM,
    fp64ifyMatrix4: uM
  }, mM = [
    0,
    1,
    1,
    1
  ], _M = `uniform pickingUniforms {
  float isActive;
  float isAttribute;
  float isHighlightActive;
  float useFloatColors;
  vec3 highlightedObjectColor;
  vec4 highlightColor;
} picking;

out vec4 picking_vRGBcolor_Avalid;

// Normalize unsigned byte color to 0-1 range
vec3 picking_normalizeColor(vec3 color) {
  return picking.useFloatColors > 0.5 ? color : color / 255.0;
}

// Normalize unsigned byte color to 0-1 range
vec4 picking_normalizeColor(vec4 color) {
  return picking.useFloatColors > 0.5 ? color : color / 255.0;
}

bool picking_isColorZero(vec3 color) {
  return dot(color, vec3(1.0)) < 0.00001;
}

bool picking_isColorValid(vec3 color) {
  return dot(color, vec3(1.0)) > 0.00001;
}

// Check if this vertex is highlighted 
bool isVertexHighlighted(vec3 vertexColor) {
  vec3 highlightedObjectColor = picking_normalizeColor(picking.highlightedObjectColor);
  return
    bool(picking.isHighlightActive) && picking_isColorZero(abs(vertexColor - highlightedObjectColor));
}

// Set the current picking color
void picking_setPickingColor(vec3 pickingColor) {
  pickingColor = picking_normalizeColor(pickingColor);

  if (bool(picking.isActive)) {
    // Use alpha as the validity flag. If pickingColor is [0, 0, 0] fragment is non-pickable
    picking_vRGBcolor_Avalid.a = float(picking_isColorValid(pickingColor));

    if (!bool(picking.isAttribute)) {
      // Stores the picking color so that the fragment shader can render it during picking
      picking_vRGBcolor_Avalid.rgb = pickingColor;
    }
  } else {
    // Do the comparison with selected item color in vertex shader as it should mean fewer compares
    picking_vRGBcolor_Avalid.a = float(isVertexHighlighted(pickingColor));
  }
}

void picking_setPickingAttribute(float value) {
  if (bool(picking.isAttribute)) {
    picking_vRGBcolor_Avalid.r = value;
  }
}

void picking_setPickingAttribute(vec2 value) {
  if (bool(picking.isAttribute)) {
    picking_vRGBcolor_Avalid.rg = value;
  }
}

void picking_setPickingAttribute(vec3 value) {
  if (bool(picking.isAttribute)) {
    picking_vRGBcolor_Avalid.rgb = value;
  }
}
`, yM = `uniform pickingUniforms {
  float isActive;
  float isAttribute;
  float isHighlightActive;
  float useFloatColors;
  vec3 highlightedObjectColor;
  vec4 highlightColor;
} picking;

in vec4 picking_vRGBcolor_Avalid;

/*
 * Returns highlight color if this item is selected.
 */
vec4 picking_filterHighlightColor(vec4 color) {
  // If we are still picking, we don't highlight
  if (picking.isActive > 0.5) {
    return color;
  }

  bool selected = bool(picking_vRGBcolor_Avalid.a);

  if (selected) {
    // Blend in highlight color based on its alpha value
    float highLightAlpha = picking.highlightColor.a;
    float blendedAlpha = highLightAlpha + color.a * (1.0 - highLightAlpha);
    float highLightRatio = highLightAlpha / blendedAlpha;

    vec3 blendedRGB = mix(color.rgb, picking.highlightColor.rgb, highLightRatio);
    return vec4(blendedRGB, blendedAlpha);
  } else {
    return color;
  }
}

/*
 * Returns picking color if picking enabled else unmodified argument.
 */
vec4 picking_filterPickingColor(vec4 color) {
  if (bool(picking.isActive)) {
    if (picking_vRGBcolor_Avalid.a == 0.0) {
      discard;
    }
    return picking_vRGBcolor_Avalid;
  }
  return color;
}

/*
 * Returns picking color if picking is enabled if not
 * highlight color if this item is selected, otherwise unmodified argument.
 */
vec4 picking_filterColor(vec4 color) {
  vec4 highlightColor = picking_filterHighlightColor(color);
  return picking_filterPickingColor(highlightColor);
}
`, e0 = {
    props: {},
    uniforms: {},
    name: "picking",
    uniformTypes: {
      isActive: "f32",
      isAttribute: "f32",
      isHighlightActive: "f32",
      useFloatColors: "f32",
      highlightedObjectColor: "vec3<f32>",
      highlightColor: "vec4<f32>"
    },
    defaultUniforms: {
      isActive: false,
      isAttribute: false,
      isHighlightActive: false,
      useFloatColors: true,
      highlightedObjectColor: [
        0,
        0,
        0
      ],
      highlightColor: mM
    },
    vs: _M,
    fs: yM,
    getUniforms: bM
  };
  function bM(n = {}, e) {
    const t = {};
    if (n.highlightedObjectColor !== void 0) if (n.highlightedObjectColor === null) t.isHighlightActive = false;
    else {
      t.isHighlightActive = true;
      const i = n.highlightedObjectColor.slice(0, 3);
      t.highlightedObjectColor = i;
    }
    if (n.highlightColor) {
      const i = Array.from(n.highlightColor, (s) => s / 255);
      Number.isFinite(i[3]) || (i[3] = 1), t.highlightColor = i;
    }
    return n.isActive !== void 0 && (t.isActive = !!n.isActive, t.isAttribute = !!n.isAttribute), n.useFloatColors !== void 0 && (t.useFloatColors = !!n.useFloatColors), t;
  }
  const t0 = `precision highp int;

// #if (defined(SHADER_TYPE_FRAGMENT) && defined(LIGHTING_FRAGMENT)) || (defined(SHADER_TYPE_VERTEX) && defined(LIGHTING_VERTEX))
struct AmbientLight {
  vec3 color;
};

struct PointLight {
  vec3 color;
  vec3 position;
  vec3 attenuation; // 2nd order x:Constant-y:Linear-z:Exponential
};

struct DirectionalLight {
  vec3 color;
  vec3 direction;
};

uniform lightingUniforms {
  int enabled;
  int lightType;

  int directionalLightCount;
  int pointLightCount;

  vec3 ambientColor;

  vec3 lightColor0;
  vec3 lightPosition0;
  vec3 lightDirection0;
  vec3 lightAttenuation0;

  vec3 lightColor1;
  vec3 lightPosition1;
  vec3 lightDirection1;
  vec3 lightAttenuation1;

  vec3 lightColor2;
  vec3 lightPosition2;
  vec3 lightDirection2;
  vec3 lightAttenuation2;
} lighting;

PointLight lighting_getPointLight(int index) {
  switch (index) {
    case 0:
      return PointLight(lighting.lightColor0, lighting.lightPosition0, lighting.lightAttenuation0);
    case 1:
      return PointLight(lighting.lightColor1, lighting.lightPosition1, lighting.lightAttenuation1);
    case 2:
    default:  
      return PointLight(lighting.lightColor2, lighting.lightPosition2, lighting.lightAttenuation2);
  }
}

DirectionalLight lighting_getDirectionalLight(int index) {
  switch (index) {
    case 0:
      return DirectionalLight(lighting.lightColor0, lighting.lightDirection0);
    case 1:
      return DirectionalLight(lighting.lightColor1, lighting.lightDirection1);
    case 2:
    default:   
      return DirectionalLight(lighting.lightColor2, lighting.lightDirection2);
  }
} 

float getPointLightAttenuation(PointLight pointLight, float distance) {
  return pointLight.attenuation.x
       + pointLight.attenuation.y * distance
       + pointLight.attenuation.z * distance * distance;
}

// #endif
`, vM = `// #if (defined(SHADER_TYPE_FRAGMENT) && defined(LIGHTING_FRAGMENT)) || (defined(SHADER_TYPE_VERTEX) && defined(LIGHTING_VERTEX))
struct AmbientLight {
  color: vec3<f32>,
};

struct PointLight {
  color: vec3<f32>,
  position: vec3<f32>,
  attenuation: vec3<f32>, // 2nd order x:Constant-y:Linear-z:Exponential
};

struct DirectionalLight {
  color: vec3<f32>,
  direction: vec3<f32>,
};

struct lightingUniforms {
  enabled: i32,
  pointLightCount: i32,
  directionalLightCount: i32,

  ambientColor: vec3<f32>,

  // TODO - support multiple lights by uncommenting arrays below
  lightType: i32,
  lightColor: vec3<f32>,
  lightDirection: vec3<f32>,
  lightPosition: vec3<f32>,
  lightAttenuation: vec3<f32>,

  // AmbientLight ambientLight;
  // PointLight pointLight[MAX_LIGHTS];
  // DirectionalLight directionalLight[MAX_LIGHTS];
};

// Binding 0:1 is reserved for lighting (Note: could go into separate bind group as it is stable across draw calls)
@binding(1) @group(0) var<uniform> lighting : lightingUniforms;

fn lighting_getPointLight(index: i32) -> PointLight {
  return PointLight(lighting.lightColor, lighting.lightPosition, lighting.lightAttenuation);
}

fn lighting_getDirectionalLight(index: i32) -> DirectionalLight {
  return DirectionalLight(lighting.lightColor, lighting.lightDirection);
} 

fn getPointLightAttenuation(pointLight: PointLight, distance: f32) -> f32 {
  return pointLight.attenuation.x
       + pointLight.attenuation.y * distance
       + pointLight.attenuation.z * distance * distance;
}
`, c2 = 3, TM = 255;
  var yo;
  (function(n) {
    n[n.POINT = 0] = "POINT", n[n.DIRECTIONAL = 1] = "DIRECTIONAL";
  })(yo || (yo = {}));
  const uo = {
    props: {},
    uniforms: {},
    name: "lighting",
    defines: {
      MAX_LIGHTS: c2
    },
    uniformTypes: {
      enabled: "i32",
      lightType: "i32",
      directionalLightCount: "i32",
      pointLightCount: "i32",
      ambientLightColor: "vec3<f32>",
      lightColor0: "vec3<f32>",
      lightPosition0: "vec3<f32>",
      lightDirection0: "vec3<f32>",
      lightAttenuation0: "vec3<f32>",
      lightColor1: "vec3<f32>",
      lightPosition1: "vec3<f32>",
      lightDirection1: "vec3<f32>",
      lightAttenuation1: "vec3<f32>",
      lightColor2: "vec3<f32>",
      lightPosition2: "vec3<f32>",
      lightDirection2: "vec3<f32>",
      lightAttenuation2: "vec3<f32>"
    },
    defaultUniforms: {
      enabled: 1,
      lightType: yo.POINT,
      directionalLightCount: 0,
      pointLightCount: 0,
      ambientLightColor: [
        0.1,
        0.1,
        0.1
      ],
      lightColor0: [
        1,
        1,
        1
      ],
      lightPosition0: [
        1,
        1,
        2
      ],
      lightDirection0: [
        1,
        1,
        1
      ],
      lightAttenuation0: [
        1,
        0,
        0
      ],
      lightColor1: [
        1,
        1,
        1
      ],
      lightPosition1: [
        1,
        1,
        2
      ],
      lightDirection1: [
        1,
        1,
        1
      ],
      lightAttenuation1: [
        1,
        0,
        0
      ],
      lightColor2: [
        1,
        1,
        1
      ],
      lightPosition2: [
        1,
        1,
        2
      ],
      lightDirection2: [
        1,
        1,
        1
      ],
      lightAttenuation2: [
        1,
        0,
        0
      ]
    },
    source: vM,
    vs: t0,
    fs: t0,
    getUniforms: xM
  };
  function xM(n, e = {}) {
    if (n = n && {
      ...n
    }, !n) return {
      ...uo.defaultUniforms
    };
    n.lights && (n = {
      ...n,
      ...AM(n.lights),
      lights: void 0
    });
    const { ambientLight: t, pointLights: i, directionalLights: s } = n || {};
    if (!(t || i && i.length > 0 || s && s.length > 0)) return {
      ...uo.defaultUniforms,
      enabled: 0
    };
    const l = {
      ...uo.defaultUniforms,
      ...e,
      ...SM({
        ambientLight: t,
        pointLights: i,
        directionalLights: s
      })
    };
    return n.enabled !== void 0 && (l.enabled = n.enabled ? 1 : 0), l;
  }
  function SM({ ambientLight: n, pointLights: e = [], directionalLights: t = [] }) {
    const i = {};
    i.ambientLightColor = $h(n);
    let s = 0;
    for (const a of e) {
      i.lightType = yo.POINT;
      const l = s;
      i[`lightColor${l}`] = $h(a), i[`lightPosition${l}`] = a.position, i[`lightAttenuation${l}`] = a.attenuation || [
        1,
        0,
        0
      ], s++;
    }
    for (const a of t) {
      i.lightType = yo.DIRECTIONAL;
      const l = s;
      i[`lightColor${l}`] = $h(a), i[`lightDirection${l}`] = a.direction, s++;
    }
    return s > c2 && J.warn("MAX_LIGHTS exceeded")(), i.directionalLightCount = t.length, i.pointLightCount = e.length, i;
  }
  function AM(n) {
    var _a2, _b3;
    const e = {
      pointLights: [],
      directionalLights: []
    };
    for (const t of n || []) switch (t.type) {
      case "ambient":
        e.ambientLight = t;
        break;
      case "directional":
        (_a2 = e.directionalLights) == null ? void 0 : _a2.push(t);
        break;
      case "point":
        (_b3 = e.pointLights) == null ? void 0 : _b3.push(t);
        break;
    }
    return e;
  }
  function $h(n = {}) {
    const { color: e = [
      0,
      0,
      0
    ], intensity: t = 1 } = n;
    return e.map((i) => i * t / TM);
  }
  const u2 = `uniform phongMaterialUniforms {
  uniform float ambient;
  uniform float diffuse;
  uniform float shininess;
  uniform vec3  specularColor;
} material;
`, f2 = `uniform phongMaterialUniforms {
  uniform float ambient;
  uniform float diffuse;
  uniform float shininess;
  uniform vec3  specularColor;
} material;

vec3 lighting_getLightColor(vec3 surfaceColor, vec3 light_direction, vec3 view_direction, vec3 normal_worldspace, vec3 color) {
  vec3 halfway_direction = normalize(light_direction + view_direction);
  float lambertian = dot(light_direction, normal_worldspace);
  float specular = 0.0;
  if (lambertian > 0.0) {
    float specular_angle = max(dot(normal_worldspace, halfway_direction), 0.0);
    specular = pow(specular_angle, material.shininess);
  }
  lambertian = max(lambertian, 0.0);
  return (lambertian * material.diffuse * surfaceColor + specular * material.specularColor) * color;
}

vec3 lighting_getLightColor(vec3 surfaceColor, vec3 cameraPosition, vec3 position_worldspace, vec3 normal_worldspace) {
  vec3 lightColor = surfaceColor;

  if (lighting.enabled == 0) {
    return lightColor;
  }

  vec3 view_direction = normalize(cameraPosition - position_worldspace);
  lightColor = material.ambient * surfaceColor * lighting.ambientColor;

  for (int i = 0; i < lighting.pointLightCount; i++) {
    PointLight pointLight = lighting_getPointLight(i);
    vec3 light_position_worldspace = pointLight.position;
    vec3 light_direction = normalize(light_position_worldspace - position_worldspace);
    float light_attenuation = getPointLightAttenuation(pointLight, distance(light_position_worldspace, position_worldspace));
    lightColor += lighting_getLightColor(surfaceColor, light_direction, view_direction, normal_worldspace, pointLight.color / light_attenuation);
  }

  int totalLights = min(MAX_LIGHTS, lighting.pointLightCount + lighting.directionalLightCount);
  for (int i = lighting.pointLightCount; i < totalLights; i++) {
    DirectionalLight directionalLight = lighting_getDirectionalLight(i);
    lightColor += lighting_getLightColor(surfaceColor, -directionalLight.direction, view_direction, normal_worldspace, directionalLight.color);
  }
  
  return lightColor;
}
`, h2 = `struct phongMaterialUniforms {
  ambient: f32,
  diffuse: f32,
  shininess: f32,
  specularColor: vec3<f32>,
};

@binding(2) @group(0) var<uniform> phongMaterial : phongMaterialUniforms;

fn lighting_getLightColor(surfaceColor: vec3<f32>, light_direction: vec3<f32>, view_direction: vec3<f32>, normal_worldspace: vec3<f32>, color: vec3<f32>) -> vec3<f32> {
  let halfway_direction: vec3<f32> = normalize(light_direction + view_direction);
  var lambertian: f32 = dot(light_direction, normal_worldspace);
  var specular: f32 = 0.0;
  if (lambertian > 0.0) {
    let specular_angle = max(dot(normal_worldspace, halfway_direction), 0.0);
    specular = pow(specular_angle, phongMaterial.shininess);
  }
  lambertian = max(lambertian, 0.0);
  return (lambertian * phongMaterial.diffuse * surfaceColor + specular * phongMaterial.specularColor) * color;
}

fn lighting_getLightColor2(surfaceColor: vec3<f32>, cameraPosition: vec3<f32>, position_worldspace: vec3<f32>, normal_worldspace: vec3<f32>) -> vec3<f32> {
  var lightColor: vec3<f32> = surfaceColor;

  if (lighting.enabled == 0) {
    return lightColor;
  }

  let view_direction: vec3<f32> = normalize(cameraPosition - position_worldspace);
  lightColor = phongMaterial.ambient * surfaceColor * lighting.ambientColor;

  if (lighting.lightType == 0) {
    let pointLight: PointLight  = lighting_getPointLight(0);
    let light_position_worldspace: vec3<f32> = pointLight.position;
    let light_direction: vec3<f32> = normalize(light_position_worldspace - position_worldspace);
    lightColor += lighting_getLightColor(surfaceColor, light_direction, view_direction, normal_worldspace, pointLight.color);
  } else if (lighting.lightType == 1) {
    var directionalLight: DirectionalLight = lighting_getDirectionalLight(0);
    lightColor += lighting_getLightColor(surfaceColor, -directionalLight.direction, view_direction, normal_worldspace, directionalLight.color);
  }
  
  return lightColor;
  /*
  for (int i = 0; i < MAX_LIGHTS; i++) {
    if (i >= lighting.pointLightCount) {
      break;
    }
    PointLight pointLight = lighting.pointLight[i];
    vec3 light_position_worldspace = pointLight.position;
    vec3 light_direction = normalize(light_position_worldspace - position_worldspace);
    lightColor += lighting_getLightColor(surfaceColor, light_direction, view_direction, normal_worldspace, pointLight.color);
  }

  for (int i = 0; i < MAX_LIGHTS; i++) {
    if (i >= lighting.directionalLightCount) {
      break;
    }
    DirectionalLight directionalLight = lighting.directionalLight[i];
    lightColor += lighting_getLightColor(surfaceColor, -directionalLight.direction, view_direction, normal_worldspace, directionalLight.color);
  }
  */
}

fn lighting_getSpecularLightColor(cameraPosition: vec3<f32>, position_worldspace: vec3<f32>, normal_worldspace: vec3<f32>) -> vec3<f32>{
  var lightColor = vec3<f32>(0, 0, 0);
  let surfaceColor = vec3<f32>(0, 0, 0);

  if (lighting.enabled == 0) {
    let view_direction = normalize(cameraPosition - position_worldspace);

    switch (lighting.lightType) {
      case 0, default: {
        let pointLight: PointLight = lighting_getPointLight(0);
        let light_position_worldspace: vec3<f32> = pointLight.position;
        let light_direction: vec3<f32> = normalize(light_position_worldspace - position_worldspace);
        lightColor += lighting_getLightColor(surfaceColor, light_direction, view_direction, normal_worldspace, pointLight.color);
      }
      case 1: {
        let directionalLight: DirectionalLight = lighting_getDirectionalLight(0);
        lightColor += lighting_getLightColor(surfaceColor, -directionalLight.direction, view_direction, normal_worldspace, directionalLight.color);
      }
    }
  }
  return lightColor;
}
`, d2 = {
    props: {},
    name: "gouraudMaterial",
    vs: f2.replace("phongMaterial", "gouraudMaterial"),
    fs: u2.replace("phongMaterial", "gouraudMaterial"),
    source: h2.replaceAll("phongMaterial", "gouraudMaterial"),
    defines: {
      LIGHTING_VERTEX: 1
    },
    dependencies: [
      uo
    ],
    uniformTypes: {
      ambient: "f32",
      diffuse: "f32",
      shininess: "f32",
      specularColor: "vec3<f32>"
    },
    defaultUniforms: {
      ambient: 0.35,
      diffuse: 0.6,
      shininess: 32,
      specularColor: [
        0.15,
        0.15,
        0.15
      ]
    },
    getUniforms(n) {
      const e = {
        ...n
      };
      return e.specularColor && (e.specularColor = e.specularColor.map((t) => t / 255)), {
        ...d2.defaultUniforms,
        ...e
      };
    }
  }, g2 = {
    name: "phongMaterial",
    dependencies: [
      uo
    ],
    source: h2,
    vs: u2,
    fs: f2,
    defines: {
      LIGHTING_FRAGMENT: 1
    },
    uniformTypes: {
      ambient: "f32",
      diffuse: "f32",
      shininess: "f32",
      specularColor: "vec3<f32>"
    },
    defaultUniforms: {
      ambient: 0.35,
      diffuse: 0.6,
      shininess: 32,
      specularColor: [
        0.15,
        0.15,
        0.15
      ]
    },
    getUniforms(n) {
      const e = {
        ...n
      };
      return e.specularColor && (e.specularColor = e.specularColor.map((t) => t / 255)), {
        ...g2.defaultUniforms,
        ...e
      };
    }
  }, n0 = `uniform layerUniforms {
  uniform float opacity;
} layer;
`, wM = {
    name: "layer",
    vs: n0,
    fs: n0,
    getUniforms: (n) => ({
      opacity: Math.pow(n.opacity, 1 / 2.2)
    }),
    uniformTypes: {
      opacity: "f32"
    }
  }, EM = `const SMOOTH_EDGE_RADIUS: f32 = 0.5;

struct VertexGeometry {
  position: vec4<f32>,
  worldPosition: vec3<f32>,
  worldPositionAlt: vec3<f32>,
  normal: vec3<f32>,
  uv: vec2<f32>,
  pickingColor: vec3<f32>,
};

var<private> geometry_: VertexGeometry = VertexGeometry(
  vec4<f32>(0.0, 0.0, 1.0, 0.0),
  vec3<f32>(0.0, 0.0, 0.0),
  vec3<f32>(0.0, 0.0, 0.0),
  vec3<f32>(0.0, 0.0, 0.0),
  vec2<f32>(0.0, 0.0),
  vec3<f32>(0.0, 0.0, 0.0)
);

struct FragmentGeometry {
  uv: vec2<f32>,
};

var<private> fragmentGeometry: FragmentGeometry;

fn smoothedge(edge: f32, x: f32) -> f32 {
  return smoothstep(edge - SMOOTH_EDGE_RADIUS, edge + SMOOTH_EDGE_RADIUS, x);
}
`, p2 = "#define SMOOTH_EDGE_RADIUS 0.5", RM = `${p2}

struct VertexGeometry {
  vec4 position;
  vec3 worldPosition;
  vec3 worldPositionAlt;
  vec3 normal;
  vec2 uv;
  vec3 pickingColor;
} geometry = VertexGeometry(
  vec4(0.0, 0.0, 1.0, 0.0),
  vec3(0.0),
  vec3(0.0),
  vec3(0.0),
  vec2(0.0),
  vec3(0.0)
);
`, CM = `${p2}

struct FragmentGeometry {
  vec2 uv;
} geometry;

float smoothedge(float edge, float x) {
  return smoothstep(edge - SMOOTH_EDGE_RADIUS, edge + SMOOTH_EDGE_RADIUS, x);
}
`, m2 = {
    name: "geometry",
    source: EM,
    vs: RM,
    fs: CM
  }, MM = 25;
  var ut;
  (function(n) {
    n[n.Start = 1] = "Start", n[n.Move = 2] = "Move", n[n.End = 4] = "End", n[n.Cancel = 8] = "Cancel";
  })(ut || (ut = {}));
  var gt;
  (function(n) {
    n[n.None = 0] = "None", n[n.Left = 1] = "Left", n[n.Right = 2] = "Right", n[n.Up = 4] = "Up", n[n.Down = 8] = "Down", n[n.Horizontal = 3] = "Horizontal", n[n.Vertical = 12] = "Vertical", n[n.All = 15] = "All";
  })(gt || (gt = {}));
  var Se;
  (function(n) {
    n[n.Possible = 1] = "Possible", n[n.Began = 2] = "Began", n[n.Changed = 4] = "Changed", n[n.Ended = 8] = "Ended", n[n.Recognized = 8] = "Recognized", n[n.Cancelled = 16] = "Cancelled", n[n.Failed = 32] = "Failed";
  })(Se || (Se = {}));
  const OM = "compute", IM = "auto", Ed = "manipulation", fc = "none", Rd = "pan-x", Cd = "pan-y";
  function NM(n) {
    if (n.includes(fc)) return fc;
    const e = n.includes(Rd), t = n.includes(Cd);
    return e && t ? fc : e || t ? e ? Rd : Cd : n.includes(Ed) ? Ed : IM;
  }
  class PM {
    constructor(e, t) {
      this.actions = "", this.manager = e, this.set(t);
    }
    set(e) {
      e === OM && (e = this.compute()), this.manager.element && (this.manager.element.style.touchAction = e, this.actions = e);
    }
    update() {
      this.set(this.manager.options.touchAction);
    }
    compute() {
      let e = [];
      for (const t of this.manager.recognizers) t.options.enable && (e = e.concat(t.getTouchAction()));
      return NM(e.join(" "));
    }
  }
  function Mc(n) {
    return n.trim().split(/\s+/g);
  }
  function Xh(n, e, t) {
    if (n) for (const i of Mc(e)) n.addEventListener(i, t, false);
  }
  function Yh(n, e, t) {
    if (n) for (const i of Mc(e)) n.removeEventListener(i, t, false);
  }
  function i0(n) {
    return (n.ownerDocument || n).defaultView;
  }
  function DM(n, e) {
    let t = n;
    for (; t; ) {
      if (t === e) return true;
      t = t.parentNode;
    }
    return false;
  }
  function _2(n) {
    const e = n.length;
    if (e === 1) return {
      x: Math.round(n[0].clientX),
      y: Math.round(n[0].clientY)
    };
    let t = 0, i = 0, s = 0;
    for (; s < e; ) t += n[s].clientX, i += n[s].clientY, s++;
    return {
      x: Math.round(t / e),
      y: Math.round(i / e)
    };
  }
  function s0(n) {
    const e = [];
    let t = 0;
    for (; t < n.pointers.length; ) e[t] = {
      clientX: Math.round(n.pointers[t].clientX),
      clientY: Math.round(n.pointers[t].clientY)
    }, t++;
    return {
      timeStamp: Date.now(),
      pointers: e,
      center: _2(e),
      deltaX: n.deltaX,
      deltaY: n.deltaY
    };
  }
  function y2(n, e) {
    const t = e.x - n.x, i = e.y - n.y;
    return Math.sqrt(t * t + i * i);
  }
  function r0(n, e) {
    const t = e.clientX - n.clientX, i = e.clientY - n.clientY;
    return Math.sqrt(t * t + i * i);
  }
  function kM(n, e) {
    const t = e.x - n.x, i = e.y - n.y;
    return Math.atan2(i, t) * 180 / Math.PI;
  }
  function a0(n, e) {
    const t = e.clientX - n.clientX, i = e.clientY - n.clientY;
    return Math.atan2(i, t) * 180 / Math.PI;
  }
  function b2(n, e) {
    return n === e ? gt.None : Math.abs(n) >= Math.abs(e) ? n < 0 ? gt.Left : gt.Right : e < 0 ? gt.Up : gt.Down;
  }
  function UM(n, e) {
    const t = e.center;
    let i = n.offsetDelta, s = n.prevDelta;
    const a = n.prevInput;
    return (e.eventType === ut.Start || (a == null ? void 0 : a.eventType) === ut.End) && (s = n.prevDelta = {
      x: (a == null ? void 0 : a.deltaX) || 0,
      y: (a == null ? void 0 : a.deltaY) || 0
    }, i = n.offsetDelta = {
      x: t.x,
      y: t.y
    }), {
      deltaX: s.x + (t.x - i.x),
      deltaY: s.y + (t.y - i.y)
    };
  }
  function v2(n, e, t) {
    return {
      x: e / n || 0,
      y: t / n || 0
    };
  }
  function BM(n, e) {
    return r0(e[0], e[1]) / r0(n[0], n[1]);
  }
  function LM(n, e) {
    return a0(e[1], e[0]) - a0(n[1], n[0]);
  }
  function FM(n, e) {
    const t = n.lastInterval || e, i = e.timeStamp - t.timeStamp;
    let s, a, l, u;
    if (e.eventType !== ut.Cancel && (i > MM || t.velocity === void 0)) {
      const h = e.deltaX - t.deltaX, d = e.deltaY - t.deltaY, p = v2(i, h, d);
      a = p.x, l = p.y, s = Math.abs(p.x) > Math.abs(p.y) ? p.x : p.y, u = b2(h, d), n.lastInterval = e;
    } else s = t.velocity, a = t.velocityX, l = t.velocityY, u = t.direction;
    e.velocity = s, e.velocityX = a, e.velocityY = l, e.direction = u;
  }
  function VM(n, e) {
    const { session: t } = n, { pointers: i } = e, { length: s } = i;
    t.firstInput || (t.firstInput = s0(e)), s > 1 && !t.firstMultiple ? t.firstMultiple = s0(e) : s === 1 && (t.firstMultiple = false);
    const { firstInput: a, firstMultiple: l } = t, u = l ? l.center : a.center, h = e.center = _2(i);
    e.timeStamp = Date.now(), e.deltaTime = e.timeStamp - a.timeStamp, e.angle = kM(u, h), e.distance = y2(u, h);
    const { deltaX: d, deltaY: p } = UM(t, e);
    e.deltaX = d, e.deltaY = p, e.offsetDirection = b2(e.deltaX, e.deltaY);
    const _ = v2(e.deltaTime, e.deltaX, e.deltaY);
    e.overallVelocityX = _.x, e.overallVelocityY = _.y, e.overallVelocity = Math.abs(_.x) > Math.abs(_.y) ? _.x : _.y, e.scale = l ? BM(l.pointers, i) : 1, e.rotation = l ? LM(l.pointers, i) : 0, e.maxPointers = t.prevInput ? e.pointers.length > t.prevInput.maxPointers ? e.pointers.length : t.prevInput.maxPointers : e.pointers.length;
    let y = n.element;
    return DM(e.srcEvent.target, y) && (y = e.srcEvent.target), e.target = y, FM(t, e), e;
  }
  function zM(n, e, t) {
    const i = t.pointers.length, s = t.changedPointers.length, a = e & ut.Start && i - s === 0, l = e & (ut.End | ut.Cancel) && i - s === 0;
    t.isFirst = !!a, t.isFinal = !!l, a && (n.session = {}), t.eventType = e;
    const u = VM(n, t);
    n.emit("hammer.input", u), n.recognize(u), n.session.prevInput = u;
  }
  let HM = class {
    constructor(e) {
      this.evEl = "", this.evWin = "", this.evTarget = "", this.domHandler = (t) => {
        this.manager.options.enable && this.handler(t);
      }, this.manager = e, this.element = e.element, this.target = e.options.inputTarget || e.element;
    }
    callback(e, t) {
      zM(this.manager, e, t);
    }
    init() {
      Xh(this.element, this.evEl, this.domHandler), Xh(this.target, this.evTarget, this.domHandler), Xh(i0(this.element), this.evWin, this.domHandler);
    }
    destroy() {
      Yh(this.element, this.evEl, this.domHandler), Yh(this.target, this.evTarget, this.domHandler), Yh(i0(this.element), this.evWin, this.domHandler);
    }
  };
  const jM = {
    pointerdown: ut.Start,
    pointermove: ut.Move,
    pointerup: ut.End,
    pointercancel: ut.Cancel,
    pointerout: ut.Cancel
  }, WM = "pointerdown", $M = "pointermove pointerup pointercancel";
  class XM extends HM {
    constructor(e) {
      super(e), this.evEl = WM, this.evWin = $M, this.store = this.manager.session.pointerEvents = [], this.init();
    }
    handler(e) {
      const { store: t } = this;
      let i = false;
      const s = jM[e.type], a = e.pointerType, l = a === "touch";
      let u = t.findIndex((h) => h.pointerId === e.pointerId);
      s & ut.Start && (e.buttons || l) ? u < 0 && (t.push(e), u = t.length - 1) : s & (ut.End | ut.Cancel) && (i = true), !(u < 0) && (t[u] = e, this.callback(s, {
        pointers: t,
        changedPointers: [
          e
        ],
        eventType: s,
        pointerType: a,
        srcEvent: e
      }), i && t.splice(u, 1));
    }
  }
  const YM = [
    "",
    "webkit",
    "Moz",
    "MS",
    "ms",
    "o"
  ];
  function qM(n, e) {
    const t = e[0].toUpperCase() + e.slice(1);
    for (const i of YM) {
      const s = i ? i + t : e;
      if (s in n) return s;
    }
  }
  const KM = 1, o0 = 2, l0 = {
    touchAction: "compute",
    enable: true,
    inputTarget: null,
    cssProps: {
      userSelect: "none",
      userDrag: "none",
      touchCallout: "none",
      tapHighlightColor: "rgba(0,0,0,0)"
    }
  };
  class ZM {
    constructor(e, t) {
      this.options = {
        ...l0,
        ...t,
        cssProps: {
          ...l0.cssProps,
          ...t.cssProps
        },
        inputTarget: t.inputTarget || e
      }, this.handlers = {}, this.session = {}, this.recognizers = [], this.oldCssProps = {}, this.element = e, this.input = new XM(this), this.touchAction = new PM(this, this.options.touchAction), this.toggleCssProps(true);
    }
    set(e) {
      return Object.assign(this.options, e), e.touchAction && this.touchAction.update(), e.inputTarget && (this.input.destroy(), this.input.target = e.inputTarget, this.input.init()), this;
    }
    stop(e) {
      this.session.stopped = e ? o0 : KM;
    }
    recognize(e) {
      const { session: t } = this;
      if (t.stopped) return;
      this.session.prevented && e.srcEvent.preventDefault();
      let i;
      const { recognizers: s } = this;
      let { curRecognizer: a } = t;
      (!a || a && a.state & Se.Recognized) && (a = t.curRecognizer = null);
      let l = 0;
      for (; l < s.length; ) i = s[l], t.stopped !== o0 && (!a || i === a || i.canRecognizeWith(a)) ? i.recognize(e) : i.reset(), !a && i.state & (Se.Began | Se.Changed | Se.Ended) && (a = t.curRecognizer = i), l++;
    }
    get(e) {
      const { recognizers: t } = this;
      for (let i = 0; i < t.length; i++) if (t[i].options.event === e) return t[i];
      return null;
    }
    add(e) {
      if (Array.isArray(e)) {
        for (const i of e) this.add(i);
        return this;
      }
      const t = this.get(e.options.event);
      return t && this.remove(t), this.recognizers.push(e), e.manager = this, this.touchAction.update(), e;
    }
    remove(e) {
      if (Array.isArray(e)) {
        for (const i of e) this.remove(i);
        return this;
      }
      const t = typeof e == "string" ? this.get(e) : e;
      if (t) {
        const { recognizers: i } = this, s = i.indexOf(t);
        s !== -1 && (i.splice(s, 1), this.touchAction.update());
      }
      return this;
    }
    on(e, t) {
      if (!e || !t) return;
      const { handlers: i } = this;
      for (const s of Mc(e)) i[s] = i[s] || [], i[s].push(t);
    }
    off(e, t) {
      if (!e) return;
      const { handlers: i } = this;
      for (const s of Mc(e)) t ? i[s] && i[s].splice(i[s].indexOf(t), 1) : delete i[s];
    }
    emit(e, t) {
      const i = this.handlers[e] && this.handlers[e].slice();
      if (!i || !i.length) return;
      const s = t;
      s.type = e, s.preventDefault = function() {
        t.srcEvent.preventDefault();
      };
      let a = 0;
      for (; a < i.length; ) i[a](s), a++;
    }
    destroy() {
      this.toggleCssProps(false), this.handlers = {}, this.session = {}, this.input.destroy(), this.element = null;
    }
    toggleCssProps(e) {
      const { element: t } = this;
      if (t) {
        for (const [i, s] of Object.entries(this.options.cssProps)) {
          const a = qM(t.style, i);
          e ? (this.oldCssProps[a] = t.style[a], t.style[a] = s) : t.style[a] = this.oldCssProps[a] || "";
        }
        e || (this.oldCssProps = {});
      }
    }
  }
  let QM = 1;
  function GM() {
    return QM++;
  }
  function c0(n) {
    return n & Se.Cancelled ? "cancel" : n & Se.Ended ? "end" : n & Se.Changed ? "move" : n & Se.Began ? "start" : "";
  }
  class T2 {
    constructor(e) {
      this.options = e, this.id = GM(), this.state = Se.Possible, this.simultaneous = {}, this.requireFail = [];
    }
    set(e) {
      return Object.assign(this.options, e), this.manager.touchAction.update(), this;
    }
    recognizeWith(e) {
      if (Array.isArray(e)) {
        for (const s of e) this.recognizeWith(s);
        return this;
      }
      let t;
      if (typeof e == "string") {
        if (t = this.manager.get(e), !t) throw new Error(`Cannot find recognizer ${e}`);
      } else t = e;
      const { simultaneous: i } = this;
      return i[t.id] || (i[t.id] = t, t.recognizeWith(this)), this;
    }
    dropRecognizeWith(e) {
      if (Array.isArray(e)) {
        for (const i of e) this.dropRecognizeWith(i);
        return this;
      }
      let t;
      return typeof e == "string" ? t = this.manager.get(e) : t = e, t && delete this.simultaneous[t.id], this;
    }
    requireFailure(e) {
      if (Array.isArray(e)) {
        for (const s of e) this.requireFailure(s);
        return this;
      }
      let t;
      if (typeof e == "string") {
        if (t = this.manager.get(e), !t) throw new Error(`Cannot find recognizer ${e}`);
      } else t = e;
      const { requireFail: i } = this;
      return i.indexOf(t) === -1 && (i.push(t), t.requireFailure(this)), this;
    }
    dropRequireFailure(e) {
      if (Array.isArray(e)) {
        for (const i of e) this.dropRequireFailure(i);
        return this;
      }
      let t;
      if (typeof e == "string" ? t = this.manager.get(e) : t = e, t) {
        const i = this.requireFail.indexOf(t);
        i > -1 && this.requireFail.splice(i, 1);
      }
      return this;
    }
    hasRequireFailures() {
      return !!this.requireFail.find((e) => e.options.enable);
    }
    canRecognizeWith(e) {
      return !!this.simultaneous[e.id];
    }
    emit(e) {
      if (!e) return;
      const { state: t } = this;
      t < Se.Ended && this.manager.emit(this.options.event + c0(t), e), this.manager.emit(this.options.event, e), e.additionalEvent && this.manager.emit(e.additionalEvent, e), t >= Se.Ended && this.manager.emit(this.options.event + c0(t), e);
    }
    tryEmit(e) {
      this.canEmit() ? this.emit(e) : this.state = Se.Failed;
    }
    canEmit() {
      let e = 0;
      for (; e < this.requireFail.length; ) {
        if (!(this.requireFail[e].state & (Se.Failed | Se.Possible))) return false;
        e++;
      }
      return true;
    }
    recognize(e) {
      const t = {
        ...e
      };
      if (!this.options.enable) {
        this.reset(), this.state = Se.Failed;
        return;
      }
      this.state & (Se.Recognized | Se.Cancelled | Se.Failed) && (this.state = Se.Possible), this.state = this.process(t), this.state & (Se.Began | Se.Changed | Se.Ended | Se.Cancelled) && this.tryEmit(t);
    }
    getEventNames() {
      return [
        this.options.event
      ];
    }
    reset() {
    }
  }
  class x2 extends T2 {
    attrTest(e) {
      const t = this.options.pointers;
      return t === 0 || e.pointers.length === t;
    }
    process(e) {
      const { state: t } = this, { eventType: i } = e, s = t & (Se.Began | Se.Changed), a = this.attrTest(e);
      return s && (i & ut.Cancel || !a) ? t | Se.Cancelled : s || a ? i & ut.End ? t | Se.Ended : t & Se.Began ? t | Se.Changed : Se.Began : Se.Failed;
    }
  }
  class u0 extends T2 {
    constructor(e = {}) {
      super({
        enable: true,
        event: "tap",
        pointers: 1,
        taps: 1,
        interval: 300,
        time: 250,
        threshold: 9,
        posThreshold: 10,
        ...e
      }), this.pTime = null, this.pCenter = null, this._timer = null, this._input = null, this.count = 0;
    }
    getTouchAction() {
      return [
        Ed
      ];
    }
    process(e) {
      const { options: t } = this, i = e.pointers.length === t.pointers, s = e.distance < t.threshold, a = e.deltaTime < t.time;
      if (this.reset(), e.eventType & ut.Start && this.count === 0) return this.failTimeout();
      if (s && a && i) {
        if (e.eventType !== ut.End) return this.failTimeout();
        const l = this.pTime ? e.timeStamp - this.pTime < t.interval : true, u = !this.pCenter || y2(this.pCenter, e.center) < t.posThreshold;
        if (this.pTime = e.timeStamp, this.pCenter = e.center, !u || !l ? this.count = 1 : this.count += 1, this._input = e, this.count % t.taps === 0) return this.hasRequireFailures() ? (this._timer = setTimeout(() => {
          this.state = Se.Recognized, this.tryEmit(this._input);
        }, t.interval), Se.Began) : Se.Recognized;
      }
      return Se.Failed;
    }
    failTimeout() {
      return this._timer = setTimeout(() => {
        this.state = Se.Failed;
      }, this.options.interval), Se.Failed;
    }
    reset() {
      clearTimeout(this._timer);
    }
    emit(e) {
      this.state === Se.Recognized && (e.tapCount = this.count, this.manager.emit(this.options.event, e));
    }
  }
  const JM = [
    "",
    "start",
    "move",
    "end",
    "cancel",
    "up",
    "down",
    "left",
    "right"
  ];
  class f0 extends x2 {
    constructor(e = {}) {
      super({
        enable: true,
        pointers: 1,
        event: "pan",
        threshold: 10,
        direction: gt.All,
        ...e
      }), this.pX = null, this.pY = null;
    }
    getTouchAction() {
      const { options: { direction: e } } = this, t = [];
      return e & gt.Horizontal && t.push(Cd), e & gt.Vertical && t.push(Rd), t;
    }
    getEventNames() {
      return JM.map((e) => this.options.event + e);
    }
    directionTest(e) {
      const { options: t } = this;
      let i = true, { distance: s } = e, { direction: a } = e;
      const l = e.deltaX, u = e.deltaY;
      return a & t.direction || (t.direction & gt.Horizontal ? (a = l === 0 ? gt.None : l < 0 ? gt.Left : gt.Right, i = l !== this.pX, s = Math.abs(e.deltaX)) : (a = u === 0 ? gt.None : u < 0 ? gt.Up : gt.Down, i = u !== this.pY, s = Math.abs(e.deltaY))), e.direction = a, i && s > t.threshold && !!(a & t.direction);
    }
    attrTest(e) {
      return super.attrTest(e) && (!!(this.state & Se.Began) || !(this.state & Se.Began) && this.directionTest(e));
    }
    emit(e) {
      this.pX = e.deltaX, this.pY = e.deltaY;
      const t = gt[e.direction].toLowerCase();
      t && (e.additionalEvent = this.options.event + t), super.emit(e);
    }
  }
  const eO = [
    "",
    "start",
    "move",
    "end",
    "cancel",
    "in",
    "out"
  ];
  class tO extends x2 {
    constructor(e = {}) {
      super({
        enable: true,
        event: "pinch",
        threshold: 0,
        pointers: 2,
        ...e
      });
    }
    getTouchAction() {
      return [
        fc
      ];
    }
    getEventNames() {
      return eO.map((e) => this.options.event + e);
    }
    attrTest(e) {
      return super.attrTest(e) && (Math.abs(e.scale - 1) > this.options.threshold || !!(this.state & Se.Began));
    }
    emit(e) {
      if (e.scale !== 1) {
        const t = e.scale < 1 ? "in" : "out";
        e.additionalEvent = this.options.event + t;
      }
      super.emit(e);
    }
  }
  class Gc {
    constructor(e, t, i) {
      this.element = e, this.callback = t, this.options = i;
    }
  }
  const nO = typeof navigator < "u" && navigator.userAgent ? navigator.userAgent.toLowerCase() : "", iO = nO.indexOf("firefox") !== -1, h0 = 4.000244140625, sO = 40, rO = 0.25;
  class aO extends Gc {
    constructor(e, t, i) {
      super(e, t, {
        enable: true,
        ...i
      }), this.handleEvent = (s) => {
        if (!this.options.enable) return;
        let a = s.deltaY;
        globalThis.WheelEvent && (iO && s.deltaMode === globalThis.WheelEvent.DOM_DELTA_PIXEL && (a /= globalThis.devicePixelRatio), s.deltaMode === globalThis.WheelEvent.DOM_DELTA_LINE && (a *= sO)), a !== 0 && a % h0 === 0 && (a = Math.floor(a / h0)), s.shiftKey && a && (a = a * rO), this.callback({
          type: "wheel",
          center: {
            x: s.clientX,
            y: s.clientY
          },
          delta: -a,
          srcEvent: s,
          pointerType: "mouse",
          target: s.target
        });
      }, e.addEventListener("wheel", this.handleEvent, {
        passive: false
      });
    }
    destroy() {
      this.element.removeEventListener("wheel", this.handleEvent);
    }
    enableEventType(e, t) {
      e === "wheel" && (this.options.enable = t);
    }
  }
  const d0 = [
    "mousedown",
    "mousemove",
    "mouseup",
    "mouseover",
    "mouseout",
    "mouseleave"
  ];
  class oO extends Gc {
    constructor(e, t, i) {
      super(e, t, {
        enable: true,
        ...i
      }), this.handleEvent = (a) => {
        this.handleOverEvent(a), this.handleOutEvent(a), this.handleEnterEvent(a), this.handleLeaveEvent(a), this.handleMoveEvent(a);
      }, this.pressed = false;
      const { enable: s } = this.options;
      this.enableMoveEvent = s, this.enableLeaveEvent = s, this.enableEnterEvent = s, this.enableOutEvent = s, this.enableOverEvent = s, d0.forEach((a) => e.addEventListener(a, this.handleEvent));
    }
    destroy() {
      d0.forEach((e) => this.element.removeEventListener(e, this.handleEvent));
    }
    enableEventType(e, t) {
      switch (e) {
        case "pointermove":
          this.enableMoveEvent = t;
          break;
        case "pointerover":
          this.enableOverEvent = t;
          break;
        case "pointerout":
          this.enableOutEvent = t;
          break;
        case "pointerenter":
          this.enableEnterEvent = t;
          break;
        case "pointerleave":
          this.enableLeaveEvent = t;
          break;
      }
    }
    handleOverEvent(e) {
      this.enableOverEvent && e.type === "mouseover" && this._emit("pointerover", e);
    }
    handleOutEvent(e) {
      this.enableOutEvent && e.type === "mouseout" && this._emit("pointerout", e);
    }
    handleEnterEvent(e) {
      this.enableEnterEvent && e.type === "mouseenter" && this._emit("pointerenter", e);
    }
    handleLeaveEvent(e) {
      this.enableLeaveEvent && e.type === "mouseleave" && this._emit("pointerleave", e);
    }
    handleMoveEvent(e) {
      if (this.enableMoveEvent) switch (e.type) {
        case "mousedown":
          e.button >= 0 && (this.pressed = true);
          break;
        case "mousemove":
          e.buttons === 0 && (this.pressed = false), this.pressed || this._emit("pointermove", e);
          break;
        case "mouseup":
          this.pressed = false;
          break;
      }
    }
    _emit(e, t) {
      this.callback({
        type: e,
        center: {
          x: t.clientX,
          y: t.clientY
        },
        srcEvent: t,
        pointerType: "mouse",
        target: t.target
      });
    }
  }
  const g0 = [
    "keydown",
    "keyup"
  ];
  class lO extends Gc {
    constructor(e, t, i) {
      super(e, t, {
        enable: true,
        tabIndex: 0,
        ...i
      }), this.handleEvent = (s) => {
        const a = s.target || s.srcElement;
        a.tagName === "INPUT" && a.type === "text" || a.tagName === "TEXTAREA" || (this.enableDownEvent && s.type === "keydown" && this.callback({
          type: "keydown",
          srcEvent: s,
          key: s.key,
          target: s.target
        }), this.enableUpEvent && s.type === "keyup" && this.callback({
          type: "keyup",
          srcEvent: s,
          key: s.key,
          target: s.target
        }));
      }, this.enableDownEvent = this.options.enable, this.enableUpEvent = this.options.enable, e.tabIndex = this.options.tabIndex, e.style.outline = "none", g0.forEach((s) => e.addEventListener(s, this.handleEvent));
    }
    destroy() {
      g0.forEach((e) => this.element.removeEventListener(e, this.handleEvent));
    }
    enableEventType(e, t) {
      e === "keydown" && (this.enableDownEvent = t), e === "keyup" && (this.enableUpEvent = t);
    }
  }
  class cO extends Gc {
    constructor(e, t, i) {
      super(e, t, i), this.handleEvent = (s) => {
        this.options.enable && this.callback({
          type: "contextmenu",
          center: {
            x: s.clientX,
            y: s.clientY
          },
          srcEvent: s,
          pointerType: "mouse",
          target: s.target
        });
      }, e.addEventListener("contextmenu", this.handleEvent);
    }
    destroy() {
      this.element.removeEventListener("contextmenu", this.handleEvent);
    }
    enableEventType(e, t) {
      e === "contextmenu" && (this.options.enable = t);
    }
  }
  const p0 = 1, Md = 2, m0 = 4, uO = {
    pointerdown: p0,
    pointermove: Md,
    pointerup: m0,
    mousedown: p0,
    mousemove: Md,
    mouseup: m0
  }, fO = 0, hO = 1, dO = 2, gO = 1, pO = 2, mO = 4;
  function _O(n) {
    const e = uO[n.srcEvent.type];
    if (!e) return null;
    const { buttons: t, button: i } = n.srcEvent;
    let s = false, a = false, l = false;
    return e === Md ? (s = !!(t & gO), a = !!(t & mO), l = !!(t & pO)) : (s = i === fO, a = i === hO, l = i === dO), {
      leftButton: s,
      middleButton: a,
      rightButton: l
    };
  }
  function yO(n, e) {
    const t = n.center;
    if (!t) return null;
    const i = e.getBoundingClientRect(), s = i.width / e.offsetWidth || 1, a = i.height / e.offsetHeight || 1, l = {
      x: (t.x - i.left - e.clientLeft) / s,
      y: (t.y - i.top - e.clientTop) / a
    };
    return {
      center: t,
      offsetCenter: l
    };
  }
  const bO = {
    srcElement: "root",
    priority: 0
  };
  class vO {
    constructor(e, t) {
      this.handleEvent = (i) => {
        if (this.isEmpty()) return;
        const s = this._normalizeEvent(i);
        let a = i.srcEvent.target;
        for (; a && a !== s.rootElement; ) {
          if (this._emit(s, a), s.handled) return;
          a = a.parentNode;
        }
        this._emit(s, "root");
      }, this.eventManager = e, this.recognizerName = t, this.handlers = [], this.handlersByElement = /* @__PURE__ */ new Map(), this._active = false;
    }
    isEmpty() {
      return !this._active;
    }
    add(e, t, i, s = false, a = false) {
      const { handlers: l, handlersByElement: u } = this, h = {
        ...bO,
        ...i
      };
      let d = u.get(h.srcElement);
      d || (d = [], u.set(h.srcElement, d));
      const p = {
        type: e,
        handler: t,
        srcElement: h.srcElement,
        priority: h.priority
      };
      s && (p.once = true), a && (p.passive = true), l.push(p), this._active = this._active || !p.passive;
      let _ = d.length - 1;
      for (; _ >= 0 && !(d[_].priority >= p.priority); ) _--;
      d.splice(_ + 1, 0, p);
    }
    remove(e, t) {
      const { handlers: i, handlersByElement: s } = this;
      for (let a = i.length - 1; a >= 0; a--) {
        const l = i[a];
        if (l.type === e && l.handler === t) {
          i.splice(a, 1);
          const u = s.get(l.srcElement);
          u.splice(u.indexOf(l), 1), u.length === 0 && s.delete(l.srcElement);
        }
      }
      this._active = i.some((a) => !a.passive);
    }
    _emit(e, t) {
      const i = this.handlersByElement.get(t);
      if (i) {
        let s = false;
        const a = () => {
          e.handled = true;
        }, l = () => {
          e.handled = true, s = true;
        }, u = [];
        for (let h = 0; h < i.length; h++) {
          const { type: d, handler: p, once: _ } = i[h];
          if (p({
            ...e,
            type: d,
            stopPropagation: a,
            stopImmediatePropagation: l
          }), _ && u.push(i[h]), s) break;
        }
        for (let h = 0; h < u.length; h++) {
          const { type: d, handler: p } = u[h];
          this.remove(d, p);
        }
      }
    }
    _normalizeEvent(e) {
      const t = this.eventManager.getElement();
      return {
        ...e,
        ..._O(e),
        ...yO(e, t),
        preventDefault: () => {
          e.srcEvent.preventDefault();
        },
        stopImmediatePropagation: null,
        stopPropagation: null,
        handled: false,
        rootElement: t
      };
    }
  }
  function TO(n) {
    if ("recognizer" in n) return n;
    let e;
    const t = Array.isArray(n) ? [
      ...n
    ] : [
      n
    ];
    if (typeof t[0] == "function") {
      const i = t.shift(), s = t.shift() || {};
      e = new i(s);
    } else e = t.shift();
    return {
      recognizer: e,
      recognizeWith: typeof t[0] == "string" ? [
        t[0]
      ] : t[0],
      requireFailure: typeof t[1] == "string" ? [
        t[1]
      ] : t[1]
    };
  }
  class xO {
    constructor(e = null, t = {}) {
      if (this._onBasicInput = (i) => {
        this.manager.emit(i.srcEvent.type, i);
      }, this._onOtherEvent = (i) => {
        this.manager.emit(i.type, i);
      }, this.options = {
        recognizers: [],
        events: {},
        touchAction: "compute",
        tabIndex: 0,
        cssProps: {},
        ...t
      }, this.events = /* @__PURE__ */ new Map(), this.element = e, !!e) {
        this.manager = new ZM(e, this.options);
        for (const i of this.options.recognizers) {
          const { recognizer: s, recognizeWith: a, requireFailure: l } = TO(i);
          this.manager.add(s), a && s.recognizeWith(a), l && s.requireFailure(l);
        }
        this.manager.on("hammer.input", this._onBasicInput), this.wheelInput = new aO(e, this._onOtherEvent, {
          enable: false
        }), this.moveInput = new oO(e, this._onOtherEvent, {
          enable: false
        }), this.keyInput = new lO(e, this._onOtherEvent, {
          enable: false,
          tabIndex: t.tabIndex
        }), this.contextmenuInput = new cO(e, this._onOtherEvent, {
          enable: false
        }), this.on(this.options.events);
      }
    }
    getElement() {
      return this.element;
    }
    destroy() {
      this.element && (this.wheelInput.destroy(), this.moveInput.destroy(), this.keyInput.destroy(), this.contextmenuInput.destroy(), this.manager.destroy());
    }
    on(e, t, i) {
      this._addEventHandler(e, t, i, false);
    }
    once(e, t, i) {
      this._addEventHandler(e, t, i, true);
    }
    watch(e, t, i) {
      this._addEventHandler(e, t, i, false, true);
    }
    off(e, t) {
      this._removeEventHandler(e, t);
    }
    _toggleRecognizer(e, t) {
      var _a2, _b3, _c2, _d2;
      const { manager: i } = this;
      if (!i) return;
      const s = i.get(e);
      s && (s.set({
        enable: t
      }), i.touchAction.update()), (_a2 = this.wheelInput) == null ? void 0 : _a2.enableEventType(e, t), (_b3 = this.moveInput) == null ? void 0 : _b3.enableEventType(e, t), (_c2 = this.keyInput) == null ? void 0 : _c2.enableEventType(e, t), (_d2 = this.contextmenuInput) == null ? void 0 : _d2.enableEventType(e, t);
    }
    _addEventHandler(e, t, i, s, a) {
      if (typeof e != "string") {
        i = t;
        for (const [d, p] of Object.entries(e)) this._addEventHandler(d, p, i, s, a);
        return;
      }
      const { manager: l, events: u } = this;
      if (!l) return;
      let h = u.get(e);
      if (!h) {
        const d = this._getRecognizerName(e) || e;
        h = new vO(this, d), u.set(e, h), l && l.on(e, h.handleEvent);
      }
      h.add(e, t, i, s, a), h.isEmpty() || this._toggleRecognizer(h.recognizerName, true);
    }
    _removeEventHandler(e, t) {
      if (typeof e != "string") {
        for (const [a, l] of Object.entries(e)) this._removeEventHandler(a, l);
        return;
      }
      const { events: i } = this, s = i.get(e);
      if (s && (s.remove(e, t), s.isEmpty())) {
        const { recognizerName: a } = s;
        let l = false;
        for (const u of i.values()) if (u.recognizerName === a && !u.isEmpty()) {
          l = true;
          break;
        }
        l || this._toggleRecognizer(a, false);
      }
    }
    _getRecognizerName(e) {
      var _a2;
      return (_a2 = this.manager.recognizers.find((t) => t.getEventNames().includes(e))) == null ? void 0 : _a2.options.event;
    }
  }
  const Oe = {
    DEFAULT: -1,
    LNGLAT: 1,
    METER_OFFSETS: 2,
    LNGLAT_OFFSETS: 3,
    CARTESIAN: 0
  };
  Object.defineProperty(Oe, "IDENTITY", {
    get: () => (Le.deprecated("COORDINATE_SYSTEM.IDENTITY", "COORDINATE_SYSTEM.CARTESIAN")(), 0)
  });
  const hn = {
    WEB_MERCATOR: 1,
    GLOBE: 2,
    WEB_MERCATOR_AUTO_OFFSET: 4,
    IDENTITY: 0
  }, qi = {
    common: 0,
    meters: 1,
    pixels: 2
  }, Od = {
    click: "onClick",
    panstart: "onDragStart",
    panmove: "onDrag",
    panend: "onDragEnd"
  }, _0 = {
    multipan: [
      f0,
      {
        threshold: 10,
        direction: gt.Vertical,
        pointers: 2
      }
    ],
    pinch: [
      tO,
      {},
      null,
      [
        "multipan"
      ]
    ],
    pan: [
      f0,
      {
        threshold: 1
      },
      [
        "pinch"
      ],
      [
        "multipan"
      ]
    ],
    dblclick: [
      u0,
      {
        event: "dblclick",
        taps: 2
      }
    ],
    click: [
      u0,
      {
        event: "click"
      },
      null,
      [
        "dblclick"
      ]
    ]
  };
  function SO(n, e) {
    if (n === e) return true;
    if (Array.isArray(n)) {
      const t = n.length;
      if (!e || e.length !== t) return false;
      for (let i = 0; i < t; i++) if (n[i] !== e[i]) return false;
      return true;
    }
    return false;
  }
  function Ro(n) {
    let e = {}, t;
    return (i) => {
      for (const s in i) if (!SO(i[s], e[s])) {
        t = n(i), e = i;
        break;
      }
      return t;
    };
  }
  const y0 = [
    0,
    0,
    0,
    0
  ], AO = [
    1,
    0,
    0,
    0,
    0,
    1,
    0,
    0,
    0,
    0,
    1,
    0,
    0,
    0,
    0,
    0
  ], S2 = [
    1,
    0,
    0,
    0,
    0,
    1,
    0,
    0,
    0,
    0,
    1,
    0,
    0,
    0,
    0,
    1
  ], wO = [
    0,
    0,
    0
  ], A2 = [
    0,
    0,
    0
  ], EO = Ro(MO);
  function w2(n, e, t = A2) {
    t.length < 3 && (t = [
      t[0],
      t[1],
      0
    ]);
    let i = t, s, a = true;
    switch (e === Oe.LNGLAT_OFFSETS || e === Oe.METER_OFFSETS ? s = t : s = n.isGeospatial ? [
      Math.fround(n.longitude),
      Math.fround(n.latitude),
      0
    ] : null, n.projectionMode) {
      case hn.WEB_MERCATOR:
        (e === Oe.LNGLAT || e === Oe.CARTESIAN) && (s = [
          0,
          0,
          0
        ], a = false);
        break;
      case hn.WEB_MERCATOR_AUTO_OFFSET:
        e === Oe.LNGLAT ? i = s : e === Oe.CARTESIAN && (i = [
          Math.fround(n.center[0]),
          Math.fround(n.center[1]),
          0
        ], s = n.unprojectPosition(i), i[0] -= t[0], i[1] -= t[1], i[2] -= t[2]);
        break;
      case hn.IDENTITY:
        i = n.position.map(Math.fround), i[2] = i[2] || 0;
        break;
      case hn.GLOBE:
        a = false, s = null;
        break;
      default:
        a = false;
    }
    return {
      geospatialOrigin: s,
      shaderCoordinateOrigin: i,
      offsetMode: a
    };
  }
  function RO(n, e, t) {
    const { viewMatrixUncentered: i, projectionMatrix: s } = n;
    let { viewMatrix: a, viewProjectionMatrix: l } = n, u = y0, h = y0, d = n.cameraPosition;
    const { geospatialOrigin: p, shaderCoordinateOrigin: _, offsetMode: y } = w2(n, e, t);
    return y && (h = n.projectPosition(p || _), d = [
      d[0] - h[0],
      d[1] - h[1],
      d[2] - h[2]
    ], h[3] = 1, u = Eo([], h, l), a = i || a, l = xs([], s, a), l = xs([], l, AO)), {
      viewMatrix: a,
      viewProjectionMatrix: l,
      projectionCenter: u,
      originCommon: h,
      cameraPosCommon: d,
      shaderCoordinateOrigin: _,
      geospatialOrigin: p
    };
  }
  function CO({ viewport: n, devicePixelRatio: e = 1, modelMatrix: t = null, coordinateSystem: i = Oe.DEFAULT, coordinateOrigin: s = A2, autoWrapLongitude: a = false }) {
    i === Oe.DEFAULT && (i = n.isGeospatial ? Oe.LNGLAT : Oe.CARTESIAN);
    const l = EO({
      viewport: n,
      devicePixelRatio: e,
      coordinateSystem: i,
      coordinateOrigin: s
    });
    return l.wrapLongitude = a, l.modelMatrix = t || S2, l;
  }
  function MO({ viewport: n, devicePixelRatio: e, coordinateSystem: t, coordinateOrigin: i }) {
    const { projectionCenter: s, viewProjectionMatrix: a, originCommon: l, cameraPosCommon: u, shaderCoordinateOrigin: h, geospatialOrigin: d } = RO(n, t, i), p = n.getDistanceScales(), _ = [
      n.width * e,
      n.height * e
    ], y = Eo([], [
      0,
      0,
      -n.focalDistance,
      1
    ], n.projectionMatrix)[3] || 1, v = {
      coordinateSystem: t,
      projectionMode: n.projectionMode,
      coordinateOrigin: h,
      commonOrigin: l.slice(0, 3),
      center: s,
      pseudoMeters: !!n._pseudoMeters,
      viewportSize: _,
      devicePixelRatio: e,
      focalDistance: y,
      commonUnitsPerMeter: p.unitsPerMeter,
      commonUnitsPerWorldUnit: p.unitsPerMeter,
      commonUnitsPerWorldUnit2: wO,
      scale: n.scale,
      wrapLongitude: false,
      viewProjectionMatrix: a,
      modelMatrix: S2,
      cameraPosition: u
    };
    if (d) {
      const S = n.getDistanceScales(d);
      switch (t) {
        case Oe.METER_OFFSETS:
          v.commonUnitsPerWorldUnit = S.unitsPerMeter, v.commonUnitsPerWorldUnit2 = S.unitsPerMeter2;
          break;
        case Oe.LNGLAT:
        case Oe.LNGLAT_OFFSETS:
          n._pseudoMeters || (v.commonUnitsPerMeter = S.unitsPerMeter), v.commonUnitsPerWorldUnit = S.unitsPerDegree, v.commonUnitsPerWorldUnit2 = S.unitsPerDegree2;
          break;
        case Oe.CARTESIAN:
          v.commonUnitsPerWorldUnit = [
            1,
            1,
            S.unitsPerMeter[2]
          ], v.commonUnitsPerWorldUnit2 = [
            0,
            0,
            S.unitsPerMeter2[2]
          ];
          break;
      }
    }
    return v;
  }
  const OO = Object.keys(Oe).map((n) => `const COORDINATE_SYSTEM_${n}: i32 = ${Oe[n]};`).join(""), IO = Object.keys(hn).map((n) => `const PROJECTION_MODE_${n}: i32 = ${hn[n]};`).join(""), NO = Object.keys(qi).map((n) => `const UNIT_${n.toUpperCase()}: i32 = ${qi[n]};`).join(""), PO = `${OO}
${IO}
${NO}

const TILE_SIZE: f32 = 512.0;
const PI: f32 = 3.1415926536;
const WORLD_SCALE: f32 = TILE_SIZE / (PI * 2.0);
const ZERO_64_LOW: vec3<f32> = vec3<f32>(0.0, 0.0, 0.0);
const EARTH_RADIUS: f32 = 6370972.0; // meters
const GLOBE_RADIUS: f32 = 256.0;

// -----------------------------------------------------------------------------
// Uniform block (converted from GLSL uniform block)
// -----------------------------------------------------------------------------
struct ProjectUniforms {
  wrapLongitude: i32,
  coordinateSystem: i32,
  commonUnitsPerMeter: vec3<f32>,
  projectionMode: i32,
  scale: f32,
  commonUnitsPerWorldUnit: vec3<f32>,
  commonUnitsPerWorldUnit2: vec3<f32>,
  center: vec4<f32>,
  modelMatrix: mat4x4<f32>,
  viewProjectionMatrix: mat4x4<f32>,
  viewportSize: vec2<f32>,
  devicePixelRatio: f32,
  focalDistance: f32,
  cameraPosition: vec3<f32>,
  coordinateOrigin: vec3<f32>,
  commonOrigin: vec3<f32>,
  pseudoMeters: i32,
};

@group(0) @binding(0)
var<uniform> project: ProjectUniforms;

// -----------------------------------------------------------------------------
// Geometry data
// (In your GLSL code, "geometry" was assumed to be available globally. In WGSL,
// you might supply this via vertex attributes or a uniform. Here we define a
// uniform struct for demonstration.)
// -----------------------------------------------------------------------------

// Structure to carry additional geometry data used by deck.gl filters.
struct Geometry {
  worldPosition: vec3<f32>,
  worldPositionAlt: vec3<f32>,
  position: vec4<f32>,
  uv: vec2<f32>,
  pickingColor: vec3<f32>,
};

// @group(0) @binding(1)
var<private> geometry: Geometry;
`, DO = `${PO}

// -----------------------------------------------------------------------------
// Functions
// -----------------------------------------------------------------------------

// Returns an adjustment factor for commonUnitsPerMeter
fn _project_size_at_latitude(lat: f32) -> f32 {
  let y = clamp(lat, -89.9, 89.9);
  return 1.0 / cos(radians(y));
}

// Overloaded version: scales a value in meters at a given latitude.
fn _project_size_at_latitude_m(meters: f32, lat: f32) -> f32 {
  return meters * project.commonUnitsPerMeter.z * _project_size_at_latitude(lat);
}

// Computes a non-linear scale factor based on geometry.
// (Note: This function relies on "geometry" being provided.)
fn project_size() -> f32 {
  if (project.projectionMode == PROJECTION_MODE_WEB_MERCATOR &&
      project.coordinateSystem == COORDINATE_SYSTEM_LNGLAT &&
      project.pseudoMeters == 0) {
    if (geometry.position.w == 0.0) {
      return _project_size_at_latitude(geometry.worldPosition.y);
    }
    let y: f32 = geometry.position.y / TILE_SIZE * 2.0 - 1.0;
    let y2 = y * y;
    let y4 = y2 * y2;
    let y6 = y4 * y2;
    return 1.0 + 4.9348 * y2 + 4.0587 * y4 + 1.5642 * y6;
  }
  return 1.0;
}

// Overloads to scale offsets (meters to world units)
fn project_size_float(meters: f32) -> f32 {
  return meters * project.commonUnitsPerMeter.z * project_size();
}

fn project_size_vec2(meters: vec2<f32>) -> vec2<f32> {
  return meters * project.commonUnitsPerMeter.xy * project_size();
}

fn project_size_vec3(meters: vec3<f32>) -> vec3<f32> {
  return meters * project.commonUnitsPerMeter * project_size();
}

fn project_size_vec4(meters: vec4<f32>) -> vec4<f32> {
  return vec4<f32>(meters.xyz * project.commonUnitsPerMeter, meters.w);
}

// Returns a rotation matrix aligning the z\u2011axis with the given up vector.
fn project_get_orientation_matrix(up: vec3<f32>) -> mat3x3<f32> {
  let uz = normalize(up);
  let ux = select(
    vec3<f32>(1.0, 0.0, 0.0),
    normalize(vec3<f32>(uz.y, -uz.x, 0.0)),
    abs(uz.z) == 1.0
  );
  let uy = cross(uz, ux);
  return mat3x3<f32>(ux, uy, uz);
}

// Since WGSL does not support "out" parameters, we return a struct.
struct RotationResult {
  needsRotation: bool,
  transform: mat3x3<f32>,
};

fn project_needs_rotation(commonPosition: vec3<f32>) -> RotationResult {
  if (project.projectionMode == PROJECTION_MODE_GLOBE) {
    return RotationResult(true, project_get_orientation_matrix(commonPosition));
  } else {
    return RotationResult(false, mat3x3<f32>());  // identity alternative if needed
  };
}

// Projects a normal vector from the current coordinate system to world space.
fn project_normal(vector: vec3<f32>) -> vec3<f32> {
  let normal_modelspace = project.modelMatrix * vec4<f32>(vector, 0.0);
  var n = normalize(normal_modelspace.xyz * project.commonUnitsPerMeter);
  let rotResult = project_needs_rotation(geometry.position.xyz);
  if (rotResult.needsRotation) {
    n = rotResult.transform * n;
  }
  return n;
}

// Applies a scale offset based on y-offset (dy)
fn project_offset_(offset: vec4<f32>) -> vec4<f32> {
  let dy: f32 = offset.y;
  let commonUnitsPerWorldUnit = project.commonUnitsPerWorldUnit + project.commonUnitsPerWorldUnit2 * dy;
  return vec4<f32>(offset.xyz * commonUnitsPerWorldUnit, offset.w);
}

// Projects lng/lat coordinates to a unit tile [0,1]
fn project_mercator_(lnglat: vec2<f32>) -> vec2<f32> {
  var x = lnglat.x;
  if (project.wrapLongitude != 0) {
    x = ((x + 180.0) % 360.0) - 180.0;
  }
  let y = clamp(lnglat.y, -89.9, 89.9);
  return vec2<f32>(
    radians(x) + PI,
    PI + log(tan(PI * 0.25 + radians(y) * 0.5))
  ) * WORLD_SCALE;
}

// Projects lng/lat/z coordinates for a globe projection.
fn project_globe_(lnglatz: vec3<f32>) -> vec3<f32> {
  let lambda = radians(lnglatz.x);
  let phi = radians(lnglatz.y);
  let cosPhi = cos(phi);
  let D = (lnglatz.z / EARTH_RADIUS + 1.0) * GLOBE_RADIUS;
  return vec3<f32>(
    sin(lambda) * cosPhi,
    -cos(lambda) * cosPhi,
    sin(phi)
  ) * D;
}

// Projects positions (with an optional 64-bit low part) from the input
// coordinate system to the common space.
fn project_position_vec4_f64(position: vec4<f32>, position64Low: vec3<f32>) -> vec4<f32> {
  var position_world = project.modelMatrix * position;

  // Work around for a Mac+NVIDIA bug:
  if (project.projectionMode == PROJECTION_MODE_WEB_MERCATOR) {
    if (project.coordinateSystem == COORDINATE_SYSTEM_LNGLAT) {
      return vec4<f32>(
        project_mercator_(position_world.xy),
        _project_size_at_latitude_m(position_world.z, position_world.y),
        position_world.w
      );
    }
    if (project.coordinateSystem == COORDINATE_SYSTEM_CARTESIAN) {
      position_world = vec4f(position_world.xyz + project.coordinateOrigin, position_world.w);
    }
  }
  if (project.projectionMode == PROJECTION_MODE_GLOBE) {
    if (project.coordinateSystem == COORDINATE_SYSTEM_LNGLAT) {
      return vec4<f32>(
        project_globe_(position_world.xyz),
        position_world.w
      );
    }
  }
  if (project.projectionMode == PROJECTION_MODE_WEB_MERCATOR_AUTO_OFFSET) {
    if (project.coordinateSystem == COORDINATE_SYSTEM_LNGLAT) {
      if (abs(position_world.y - project.coordinateOrigin.y) > 0.25) {
        return vec4<f32>(
          project_mercator_(position_world.xy) - project.commonOrigin.xy,
          project_size_float(position_world.z),
          position_world.w
        );
      }
    }
  }
  if (project.projectionMode == PROJECTION_MODE_IDENTITY ||
      (project.projectionMode == PROJECTION_MODE_WEB_MERCATOR_AUTO_OFFSET &&
       (project.coordinateSystem == COORDINATE_SYSTEM_LNGLAT ||
        project.coordinateSystem == COORDINATE_SYSTEM_CARTESIAN))) {
    position_world = vec4f(position_world.xyz - project.coordinateOrigin, position_world.w);
  }

  return project_offset_(position_world) +
         project_offset_(project.modelMatrix * vec4<f32>(position64Low, 0.0));
}

// Overloaded versions for different input types.
fn project_position_vec4_f32(position: vec4<f32>) -> vec4<f32> {
  return project_position_vec4_f64(position, ZERO_64_LOW);
}

fn project_position_vec3_f64(position: vec3<f32>, position64Low: vec3<f32>) -> vec3<f32> {
  let projected_position = project_position_vec4_f64(vec4<f32>(position, 1.0), position64Low);
  return projected_position.xyz;
}

fn project_position_vec3_f32(position: vec3<f32>) -> vec3<f32> {
  let projected_position = project_position_vec4_f64(vec4<f32>(position, 1.0), ZERO_64_LOW);
  return projected_position.xyz;
}

fn project_position_vec2_f32(position: vec2<f32>) -> vec2<f32> {
  let projected_position = project_position_vec4_f64(vec4<f32>(position, 0.0, 1.0), ZERO_64_LOW);
  return projected_position.xy;
}

// Transforms a common space position to clip space.
fn project_common_position_to_clipspace_with_projection(position: vec4<f32>, viewProjectionMatrix: mat4x4<f32>, center: vec4<f32>) -> vec4<f32> {
  return viewProjectionMatrix * position + center;
}

// Uses the project viewProjectionMatrix and center.
fn project_common_position_to_clipspace(position: vec4<f32>) -> vec4<f32> {
  return project_common_position_to_clipspace_with_projection(position, project.viewProjectionMatrix, project.center);
}

// Returns a clip space offset corresponding to a given number of screen pixels.
fn project_pixel_size_to_clipspace(pixels: vec2<f32>) -> vec2<f32> {
  let offset = pixels / project.viewportSize * project.devicePixelRatio * 2.0;
  return offset * project.focalDistance;
}

fn project_meter_size_to_pixel(meters: f32) -> f32 {
  return project_size_float(meters) * project.scale;
}

fn project_unit_size_to_pixel(size: f32, unit: i32) -> f32 {
  if (unit == UNIT_METERS) {
    return project_meter_size_to_pixel(size);
  } else if (unit == UNIT_COMMON) {
    return size * project.scale;
  }
  // UNIT_PIXELS: no scaling applied.
  return size;
}

fn project_pixel_size_float(pixels: f32) -> f32 {
  return pixels / project.scale;
}

fn project_pixel_size_vec2(pixels: vec2<f32>) -> vec2<f32> {
  return pixels / project.scale;
}
`, kO = Object.keys(Oe).map((n) => `const int COORDINATE_SYSTEM_${n} = ${Oe[n]};`).join(""), UO = Object.keys(hn).map((n) => `const int PROJECTION_MODE_${n} = ${hn[n]};`).join(""), BO = Object.keys(qi).map((n) => `const int UNIT_${n.toUpperCase()} = ${qi[n]};`).join(""), LO = `${kO}
${UO}
${BO}
uniform projectUniforms {
bool wrapLongitude;
int coordinateSystem;
vec3 commonUnitsPerMeter;
int projectionMode;
float scale;
vec3 commonUnitsPerWorldUnit;
vec3 commonUnitsPerWorldUnit2;
vec4 center;
mat4 modelMatrix;
mat4 viewProjectionMatrix;
vec2 viewportSize;
float devicePixelRatio;
float focalDistance;
vec3 cameraPosition;
vec3 coordinateOrigin;
vec3 commonOrigin;
bool pseudoMeters;
} project;
const float TILE_SIZE = 512.0;
const float PI = 3.1415926536;
const float WORLD_SCALE = TILE_SIZE / (PI * 2.0);
const vec3 ZERO_64_LOW = vec3(0.0);
const float EARTH_RADIUS = 6370972.0;
const float GLOBE_RADIUS = 256.0;
float project_size_at_latitude(float lat) {
float y = clamp(lat, -89.9, 89.9);
return 1.0 / cos(radians(y));
}
float project_size() {
if (project.projectionMode == PROJECTION_MODE_WEB_MERCATOR &&
project.coordinateSystem == COORDINATE_SYSTEM_LNGLAT &&
project.pseudoMeters == false) {
if (geometry.position.w == 0.0) {
return project_size_at_latitude(geometry.worldPosition.y);
}
float y = geometry.position.y / TILE_SIZE * 2.0 - 1.0;
float y2 = y * y;
float y4 = y2 * y2;
float y6 = y4 * y2;
return 1.0 + 4.9348 * y2 + 4.0587 * y4 + 1.5642 * y6;
}
return 1.0;
}
float project_size_at_latitude(float meters, float lat) {
return meters * project.commonUnitsPerMeter.z * project_size_at_latitude(lat);
}
float project_size(float meters) {
return meters * project.commonUnitsPerMeter.z * project_size();
}
vec2 project_size(vec2 meters) {
return meters * project.commonUnitsPerMeter.xy * project_size();
}
vec3 project_size(vec3 meters) {
return meters * project.commonUnitsPerMeter * project_size();
}
vec4 project_size(vec4 meters) {
return vec4(meters.xyz * project.commonUnitsPerMeter, meters.w);
}
mat3 project_get_orientation_matrix(vec3 up) {
vec3 uz = normalize(up);
vec3 ux = abs(uz.z) == 1.0 ? vec3(1.0, 0.0, 0.0) : normalize(vec3(uz.y, -uz.x, 0));
vec3 uy = cross(uz, ux);
return mat3(ux, uy, uz);
}
bool project_needs_rotation(vec3 commonPosition, out mat3 transform) {
if (project.projectionMode == PROJECTION_MODE_GLOBE) {
transform = project_get_orientation_matrix(commonPosition);
return true;
}
return false;
}
vec3 project_normal(vec3 vector) {
vec4 normal_modelspace = project.modelMatrix * vec4(vector, 0.0);
vec3 n = normalize(normal_modelspace.xyz * project.commonUnitsPerMeter);
mat3 rotation;
if (project_needs_rotation(geometry.position.xyz, rotation)) {
n = rotation * n;
}
return n;
}
vec4 project_offset_(vec4 offset) {
float dy = offset.y;
vec3 commonUnitsPerWorldUnit = project.commonUnitsPerWorldUnit + project.commonUnitsPerWorldUnit2 * dy;
return vec4(offset.xyz * commonUnitsPerWorldUnit, offset.w);
}
vec2 project_mercator_(vec2 lnglat) {
float x = lnglat.x;
if (project.wrapLongitude) {
x = mod(x + 180., 360.0) - 180.;
}
float y = clamp(lnglat.y, -89.9, 89.9);
return vec2(
radians(x) + PI,
PI + log(tan_fp32(PI * 0.25 + radians(y) * 0.5))
) * WORLD_SCALE;
}
vec3 project_globe_(vec3 lnglatz) {
float lambda = radians(lnglatz.x);
float phi = radians(lnglatz.y);
float cosPhi = cos(phi);
float D = (lnglatz.z / EARTH_RADIUS + 1.0) * GLOBE_RADIUS;
return vec3(
sin(lambda) * cosPhi,
-cos(lambda) * cosPhi,
sin(phi)
) * D;
}
vec4 project_position(vec4 position, vec3 position64Low) {
vec4 position_world = project.modelMatrix * position;
if (project.projectionMode == PROJECTION_MODE_WEB_MERCATOR) {
if (project.coordinateSystem == COORDINATE_SYSTEM_LNGLAT) {
return vec4(
project_mercator_(position_world.xy),
project_size_at_latitude(position_world.z, position_world.y),
position_world.w
);
}
if (project.coordinateSystem == COORDINATE_SYSTEM_CARTESIAN) {
position_world.xyz += project.coordinateOrigin;
}
}
if (project.projectionMode == PROJECTION_MODE_GLOBE) {
if (project.coordinateSystem == COORDINATE_SYSTEM_LNGLAT) {
return vec4(
project_globe_(position_world.xyz),
position_world.w
);
}
}
if (project.projectionMode == PROJECTION_MODE_WEB_MERCATOR_AUTO_OFFSET) {
if (project.coordinateSystem == COORDINATE_SYSTEM_LNGLAT) {
if (abs(position_world.y - project.coordinateOrigin.y) > 0.25) {
return vec4(
project_mercator_(position_world.xy) - project.commonOrigin.xy,
project_size(position_world.z),
position_world.w
);
}
}
}
if (project.projectionMode == PROJECTION_MODE_IDENTITY ||
(project.projectionMode == PROJECTION_MODE_WEB_MERCATOR_AUTO_OFFSET &&
(project.coordinateSystem == COORDINATE_SYSTEM_LNGLAT ||
project.coordinateSystem == COORDINATE_SYSTEM_CARTESIAN))) {
position_world.xyz -= project.coordinateOrigin;
}
return project_offset_(position_world) + project_offset_(project.modelMatrix * vec4(position64Low, 0.0));
}
vec4 project_position(vec4 position) {
return project_position(position, ZERO_64_LOW);
}
vec3 project_position(vec3 position, vec3 position64Low) {
vec4 projected_position = project_position(vec4(position, 1.0), position64Low);
return projected_position.xyz;
}
vec3 project_position(vec3 position) {
vec4 projected_position = project_position(vec4(position, 1.0), ZERO_64_LOW);
return projected_position.xyz;
}
vec2 project_position(vec2 position) {
vec4 projected_position = project_position(vec4(position, 0.0, 1.0), ZERO_64_LOW);
return projected_position.xy;
}
vec4 project_common_position_to_clipspace(vec4 position, mat4 viewProjectionMatrix, vec4 center) {
return viewProjectionMatrix * position + center;
}
vec4 project_common_position_to_clipspace(vec4 position) {
return project_common_position_to_clipspace(position, project.viewProjectionMatrix, project.center);
}
vec2 project_pixel_size_to_clipspace(vec2 pixels) {
vec2 offset = pixels / project.viewportSize * project.devicePixelRatio * 2.0;
return offset * project.focalDistance;
}
float project_size_to_pixel(float meters) {
return project_size(meters) * project.scale;
}
float project_size_to_pixel(float size, int unit) {
if (unit == UNIT_METERS) return project_size_to_pixel(size);
if (unit == UNIT_COMMON) return size * project.scale;
return size;
}
float project_pixel_size(float pixels) {
return pixels / project.scale;
}
vec2 project_pixel_size(vec2 pixels) {
return pixels / project.scale;
}
`, FO = {};
  function VO(n = FO) {
    return "viewport" in n ? CO(n) : {};
  }
  const Ag = {
    name: "project",
    dependencies: [
      hM,
      m2
    ],
    source: DO,
    vs: LO,
    getUniforms: VO,
    uniformTypes: {
      wrapLongitude: "f32",
      coordinateSystem: "i32",
      commonUnitsPerMeter: "vec3<f32>",
      projectionMode: "i32",
      scale: "f32",
      commonUnitsPerWorldUnit: "vec3<f32>",
      commonUnitsPerWorldUnit2: "vec3<f32>",
      center: "vec4<f32>",
      modelMatrix: "mat4x4<f32>",
      viewProjectionMatrix: "mat4x4<f32>",
      viewportSize: "vec2<f32>",
      devicePixelRatio: "f32",
      focalDistance: "f32",
      cameraPosition: "vec3<f32>",
      coordinateOrigin: "vec3<f32>",
      commonOrigin: "vec3<f32>",
      pseudoMeters: "f32"
    }
  }, zO = `// Define a structure to hold both the clip-space position and the common position.
struct ProjectResult {
  clipPosition: vec4<f32>,
  commonPosition: vec4<f32>,
};

// This function mimics the GLSL version with the 'out' parameter by returning both values.
fn project_position_to_clipspace_and_commonspace(
    position: vec3<f32>,
    position64Low: vec3<f32>,
    offset: vec3<f32>
) -> ProjectResult {
  // Compute the projected position.
  let projectedPosition: vec3<f32> = project_position_vec3_f64(position, position64Low);

  // Start with the provided offset.
  var finalOffset: vec3<f32> = offset;

  // Get whether a rotation is needed and the rotation matrix.
  let rotationResult = project_needs_rotation(projectedPosition);

  // If rotation is needed, update the offset.
  if (rotationResult.needsRotation) {
    finalOffset = rotationResult.transform * offset;
  }

  // Compute the common position.
  let commonPosition: vec4<f32> = vec4<f32>(projectedPosition + finalOffset, 1.0);

  // Convert to clip-space.
  let clipPosition: vec4<f32> = project_common_position_to_clipspace(commonPosition);

  return ProjectResult(clipPosition, commonPosition);
}

// A convenience overload that returns only the clip-space position.
fn project_position_to_clipspace(
    position: vec3<f32>,
    position64Low: vec3<f32>,
    offset: vec3<f32>
) -> vec4<f32> {
  return project_position_to_clipspace_and_commonspace(position, position64Low, offset).clipPosition;
}
`, HO = `vec4 project_position_to_clipspace(
  vec3 position, vec3 position64Low, vec3 offset, out vec4 commonPosition
) {
  vec3 projectedPosition = project_position(position, position64Low);
  mat3 rotation;
  if (project_needs_rotation(projectedPosition, rotation)) {
    // offset is specified as ENU
    // when in globe projection, rotate offset so that the ground alighs with the surface of the globe
    offset = rotation * offset;
  }
  commonPosition = vec4(projectedPosition + offset, 1.0);
  return project_common_position_to_clipspace(commonPosition);
}

vec4 project_position_to_clipspace(
  vec3 position, vec3 position64Low, vec3 offset
) {
  vec4 commonPosition;
  return project_position_to_clipspace(position, position64Low, offset, commonPosition);
}
`, Co = {
    name: "project32",
    dependencies: [
      Ag
    ],
    source: zO,
    vs: HO
  };
  function jO() {
    return [
      1,
      0,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      1
    ];
  }
  function Ur(n, e) {
    const t = Eo([], e, n);
    return nM(t, t, 1 / t[3]), t;
  }
  function b0(n, e) {
    const t = n % e;
    return t < 0 ? e + t : t;
  }
  function Id(n, e, t) {
    return n < e ? e : n > t ? t : n;
  }
  function WO(n) {
    return Math.log(n) * Math.LOG2E;
  }
  const wg = Math.log2 || WO;
  function li(n, e) {
    if (!n) throw new Error(e || "@math.gl/web-mercator: assertion failed.");
  }
  const An = Math.PI, E2 = An / 4, pn = An / 180, Nd = 180 / An, Wr = 512, Oc = 4003e4, v0 = 85.051129, $O = 1.5;
  function XO(n) {
    return wg(n);
  }
  function Ic(n) {
    const [e, t] = n;
    li(Number.isFinite(e)), li(Number.isFinite(t) && t >= -90 && t <= 90, "invalid latitude");
    const i = e * pn, s = t * pn, a = Wr * (i + An) / (2 * An), l = Wr * (An + Math.log(Math.tan(E2 + s * 0.5))) / (2 * An);
    return [
      a,
      l
    ];
  }
  function $r(n) {
    const [e, t] = n, i = e / Wr * (2 * An) - An, s = 2 * (Math.atan(Math.exp(t / Wr * (2 * An) - An)) - E2);
    return [
      i * Nd,
      s * Nd
    ];
  }
  function YO(n) {
    const { latitude: e } = n;
    li(Number.isFinite(e));
    const t = Math.cos(e * pn);
    return XO(Oc * t) - 9;
  }
  function qh(n) {
    const e = Math.cos(n * pn);
    return Wr / Oc / e;
  }
  function Pd(n) {
    const { latitude: e, longitude: t, highPrecision: i = false } = n;
    li(Number.isFinite(e) && Number.isFinite(t));
    const s = Wr, a = Math.cos(e * pn), l = s / 360, u = l / a, h = s / Oc / a, d = {
      unitsPerMeter: [
        h,
        h,
        h
      ],
      metersPerUnit: [
        1 / h,
        1 / h,
        1 / h
      ],
      unitsPerDegree: [
        l,
        u,
        h
      ],
      degreesPerUnit: [
        1 / l,
        1 / u,
        1 / h
      ]
    };
    if (i) {
      const p = pn * Math.tan(e * pn) / a, _ = l * p / 2, y = s / Oc * p, v = y / u * h;
      d.unitsPerDegree2 = [
        0,
        _,
        y
      ], d.unitsPerMeter2 = [
        v,
        0,
        v
      ];
    }
    return d;
  }
  function R2(n, e) {
    const [t, i, s] = n, [a, l, u] = e, { unitsPerMeter: h, unitsPerMeter2: d } = Pd({
      longitude: t,
      latitude: i,
      highPrecision: true
    }), p = Ic(n);
    p[0] += a * (h[0] + d[0] * l), p[1] += l * (h[1] + d[1] * l);
    const _ = $r(p), y = (s || 0) + (u || 0);
    return Number.isFinite(s) || Number.isFinite(u) ? [
      _[0],
      _[1],
      y
    ] : _;
  }
  function qO(n) {
    const { height: e, pitch: t, bearing: i, altitude: s, scale: a, center: l } = n, u = jO();
    Cc(u, u, [
      0,
      0,
      -s
    ]), a2(u, u, -t * pn), o2(u, u, i * pn);
    const h = a / e;
    return Sg(u, u, [
      h,
      h,
      h
    ]), l && Cc(u, u, NC([], l)), u;
  }
  function KO(n) {
    const { width: e, height: t, altitude: i, pitch: s = 0, offset: a, center: l, scale: u, nearZMultiplier: h = 1, farZMultiplier: d = 1 } = n;
    let { fovy: p = Nc($O) } = n;
    i !== void 0 && (p = Nc(i));
    const _ = p * pn, y = s * pn, v = C2(p);
    let S = v;
    l && (S += l[2] * u / Math.cos(y) / t);
    const E = _ * (0.5 + (a ? a[1] : 0) / t), M = Math.sin(E) * S / Math.sin(Id(Math.PI / 2 - y - E, 0.01, Math.PI - 0.01)), F = Math.sin(y) * M + S, H = S * 10, O = Math.min(F * d, H);
    return {
      fov: _,
      aspect: e / t,
      focalDistance: v,
      near: h,
      far: O
    };
  }
  function Nc(n) {
    return 2 * Math.atan(0.5 / n) * Nd;
  }
  function C2(n) {
    return 0.5 / Math.tan(0.5 * n * pn);
  }
  function M2(n, e) {
    const [t, i, s = 0] = n;
    return li(Number.isFinite(t) && Number.isFinite(i) && Number.isFinite(s)), Ur(e, [
      t,
      i,
      s,
      1
    ]);
  }
  function Eg(n, e, t = 0) {
    const [i, s, a] = n;
    if (li(Number.isFinite(i) && Number.isFinite(s), "invalid pixel coordinate"), Number.isFinite(a)) return Ur(e, [
      i,
      s,
      a,
      1
    ]);
    const l = Ur(e, [
      i,
      s,
      0,
      1
    ]), u = Ur(e, [
      i,
      s,
      1,
      1
    ]), h = l[2], d = u[2], p = h === d ? 0 : ((t || 0) - h) / (d - h);
    return i2([], l, u, p);
  }
  function ZO(n) {
    const { width: e, height: t, bounds: i, minExtent: s = 0, maxZoom: a = 24, offset: l = [
      0,
      0
    ] } = n, [[u, h], [d, p]] = i, _ = QO(n.padding), y = Ic([
      u,
      Id(p, -85.051129, v0)
    ]), v = Ic([
      d,
      Id(h, -85.051129, v0)
    ]), S = [
      Math.max(Math.abs(v[0] - y[0]), s),
      Math.max(Math.abs(v[1] - y[1]), s)
    ], E = [
      e - _.left - _.right - Math.abs(l[0]) * 2,
      t - _.top - _.bottom - Math.abs(l[1]) * 2
    ];
    li(E[0] > 0 && E[1] > 0);
    const M = E[0] / S[0], F = E[1] / S[1], H = (_.right - _.left) / 2 / M, O = (_.top - _.bottom) / 2 / F, U = [
      (v[0] + y[0]) / 2 + H,
      (v[1] + y[1]) / 2 + O
    ], B = $r(U), Z = Math.min(a, wg(Math.abs(Math.min(M, F))));
    return li(Number.isFinite(Z)), {
      longitude: B[0],
      latitude: B[1],
      zoom: Z
    };
  }
  function QO(n = 0) {
    return typeof n == "number" ? {
      top: n,
      bottom: n,
      left: n,
      right: n
    } : (li(Number.isFinite(n.top) && Number.isFinite(n.bottom) && Number.isFinite(n.left) && Number.isFinite(n.right)), n);
  }
  const T0 = Math.PI / 180;
  function GO(n, e = 0) {
    const { width: t, height: i, unproject: s } = n, a = {
      targetZ: e
    }, l = s([
      0,
      i
    ], a), u = s([
      t,
      i
    ], a);
    let h, d;
    const p = n.fovy ? 0.5 * n.fovy * T0 : Math.atan(0.5 / n.altitude), _ = (90 - n.pitch) * T0;
    return p > _ - 0.01 ? (h = x0(n, 0, e), d = x0(n, t, e)) : (h = s([
      0,
      0
    ], a), d = s([
      t,
      0
    ], a)), [
      l,
      u,
      d,
      h
    ];
  }
  function x0(n, e, t) {
    const { pixelUnprojectionMatrix: i } = n, s = Ur(i, [
      e,
      0,
      1,
      1
    ]), a = Ur(i, [
      e,
      n.height,
      1,
      1
    ]), u = (t * n.distanceScales.unitsPerMeter[2] - s[2]) / (a[2] - s[2]), h = i2([], s, a, u), d = $r(h);
    return d.push(t), d;
  }
  const S0 = 512;
  function JO(n) {
    const { width: e, height: t, pitch: i = 0 } = n;
    let { longitude: s, latitude: a, zoom: l, bearing: u = 0 } = n;
    (s < -180 || s > 180) && (s = b0(s + 180, 360) - 180), (u < -180 || u > 180) && (u = b0(u + 180, 360) - 180);
    const h = wg(t / S0);
    if (l <= h) l = h, a = 0;
    else {
      const d = t / 2 / Math.pow(2, l), p = $r([
        0,
        d
      ])[1];
      if (a < p) a = p;
      else {
        const _ = $r([
          0,
          S0 - d
        ])[1];
        a > _ && (a = _);
      }
    }
    return {
      width: e,
      height: t,
      longitude: s,
      latitude: a,
      zoom: l,
      pitch: i,
      bearing: u
    };
  }
  const O2 = `
uniform shadowUniforms {
  bool drawShadowMap;
  bool useShadowMap;
  vec4 color;
  highp int lightId;
  float lightCount;
  mat4 viewProjectionMatrix0;
  mat4 viewProjectionMatrix1;
  vec4 projectCenter0;
  vec4 projectCenter1;
} shadow;
`, eI = `
const int max_lights = 2;

out vec3 shadow_vPosition[max_lights];

vec4 shadow_setVertexPosition(vec4 position_commonspace) {
  mat4 viewProjectionMatrices[max_lights];
  viewProjectionMatrices[0] = shadow.viewProjectionMatrix0;
  viewProjectionMatrices[1] = shadow.viewProjectionMatrix1;
  vec4 projectCenters[max_lights];
  projectCenters[0] = shadow.projectCenter0;
  projectCenters[1] = shadow.projectCenter1;

  if (shadow.drawShadowMap) {
    return project_common_position_to_clipspace(position_commonspace, viewProjectionMatrices[shadow.lightId], projectCenters[shadow.lightId]);
  }
  if (shadow.useShadowMap) {
    for (int i = 0; i < max_lights; i++) {
      if(i < int(shadow.lightCount)) {
        vec4 shadowMap_position = project_common_position_to_clipspace(position_commonspace, viewProjectionMatrices[i], projectCenters[i]);
        shadow_vPosition[i] = (shadowMap_position.xyz / shadowMap_position.w + 1.0) / 2.0;
      }
    }
  }
  return gl_Position;
}
`, tI = `
${O2}
${eI}
`, nI = `
const int max_lights = 2;
uniform sampler2D shadow_uShadowMap0;
uniform sampler2D shadow_uShadowMap1;

in vec3 shadow_vPosition[max_lights];

const vec4 bitPackShift = vec4(1.0, 255.0, 65025.0, 16581375.0);
const vec4 bitUnpackShift = 1.0 / bitPackShift;
const vec4 bitMask = vec4(1.0 / 255.0, 1.0 / 255.0, 1.0 / 255.0,  0.0);

float shadow_getShadowWeight(vec3 position, sampler2D shadowMap) {
  vec4 rgbaDepth = texture(shadowMap, position.xy);

  float z = dot(rgbaDepth, bitUnpackShift);
  return smoothstep(0.001, 0.01, position.z - z);
}

vec4 shadow_filterShadowColor(vec4 color) {
  if (shadow.drawShadowMap) {
    vec4 rgbaDepth = fract(gl_FragCoord.z * bitPackShift);
    rgbaDepth -= rgbaDepth.gbaa * bitMask;
    return rgbaDepth;
  }
  if (shadow.useShadowMap) {
    float shadowAlpha = 0.0;
    shadowAlpha += shadow_getShadowWeight(shadow_vPosition[0], shadow_uShadowMap0);
    if(shadow.lightCount > 1.0) {
      shadowAlpha += shadow_getShadowWeight(shadow_vPosition[1], shadow_uShadowMap1);
    }
    shadowAlpha *= shadow.color.a / shadow.lightCount;
    float blendedAlpha = shadowAlpha + color.a * (1.0 - shadowAlpha);

    return vec4(
      mix(color.rgb, shadow.color.rgb, shadowAlpha / blendedAlpha),
      blendedAlpha
    );
  }
  return color;
}
`, iI = `
${O2}
${nI}
`, sI = Ro(cI), rI = Ro(uI), aI = [
    0,
    0,
    0,
    1
  ], oI = [
    1,
    0,
    0,
    0,
    0,
    1,
    0,
    0,
    0,
    0,
    1,
    0,
    0,
    0,
    0,
    0
  ];
  function lI(n, e) {
    const [t, i, s] = n, a = Eg([
      t,
      i,
      s
    ], e);
    return Number.isFinite(s) ? a : [
      a[0],
      a[1],
      0
    ];
  }
  function cI({ viewport: n, center: e }) {
    return new Fn(n.viewProjectionMatrix).invert().transform(e);
  }
  function uI({ viewport: n, shadowMatrices: e }) {
    const t = [], i = n.pixelUnprojectionMatrix, s = n.isGeospatial ? void 0 : 1, a = [
      [
        0,
        0,
        s
      ],
      [
        n.width,
        0,
        s
      ],
      [
        0,
        n.height,
        s
      ],
      [
        n.width,
        n.height,
        s
      ],
      [
        0,
        0,
        -1
      ],
      [
        n.width,
        0,
        -1
      ],
      [
        0,
        n.height,
        -1
      ],
      [
        n.width,
        n.height,
        -1
      ]
    ].map((l) => lI(l, i));
    for (const l of e) {
      const u = l.clone().translate(new Ln(n.center).negate()), h = a.map((p) => u.transform(p)), d = new Fn().ortho({
        left: Math.min(...h.map((p) => p[0])),
        right: Math.max(...h.map((p) => p[0])),
        bottom: Math.min(...h.map((p) => p[1])),
        top: Math.max(...h.map((p) => p[1])),
        near: Math.min(...h.map((p) => -p[2])),
        far: Math.max(...h.map((p) => -p[2]))
      });
      t.push(d.multiplyRight(l));
    }
    return t;
  }
  function fI(n) {
    const { shadowEnabled: e = true, project: t } = n;
    if (!e || !t || !n.shadowMatrices || !n.shadowMatrices.length) return {
      drawShadowMap: false,
      useShadowMap: false,
      shadow_uShadowMap0: n.dummyShadowMap,
      shadow_uShadowMap1: n.dummyShadowMap
    };
    const i = Ag.getUniforms(t), s = sI({
      viewport: t.viewport,
      center: i.center
    }), a = [], l = rI({
      shadowMatrices: n.shadowMatrices,
      viewport: t.viewport
    }).slice();
    for (let h = 0; h < n.shadowMatrices.length; h++) {
      const d = l[h], p = d.clone().translate(new Ln(t.viewport.center).negate());
      i.coordinateSystem === Oe.LNGLAT && i.projectionMode === hn.WEB_MERCATOR ? (l[h] = p, a[h] = s) : (l[h] = d.clone().multiplyRight(oI), a[h] = p.transform(s));
    }
    const u = {
      drawShadowMap: !!n.drawToShadowMap,
      useShadowMap: n.shadowMaps ? n.shadowMaps.length > 0 : false,
      color: n.shadowColor || aI,
      lightId: n.shadowLightId || 0,
      lightCount: n.shadowMatrices.length,
      shadow_uShadowMap0: n.dummyShadowMap,
      shadow_uShadowMap1: n.dummyShadowMap
    };
    for (let h = 0; h < l.length; h++) u[`viewProjectionMatrix${h}`] = l[h], u[`projectCenter${h}`] = a[h];
    for (let h = 0; h < 2; h++) u[`shadow_uShadowMap${h}`] = n.shadowMaps && n.shadowMaps[h] || n.dummyShadowMap;
    return u;
  }
  const A0 = {
    name: "shadow",
    dependencies: [
      Ag
    ],
    vs: tI,
    fs: iI,
    inject: {
      "vs:DECKGL_FILTER_GL_POSITION": `
    position = shadow_setVertexPosition(geometry.position);
    `,
      "fs:DECKGL_FILTER_COLOR": `
    color = shadow_filterShadowColor(color);
    `
    },
    getUniforms: fI,
    uniformTypes: {
      drawShadowMap: "f32",
      useShadowMap: "f32",
      color: "vec4<f32>",
      lightId: "i32",
      lightCount: "f32",
      viewProjectionMatrix0: "mat4x4<f32>",
      viewProjectionMatrix1: "mat4x4<f32>",
      projectCenter0: "vec4<f32>",
      projectCenter1: "vec4<f32>"
    }
  }, I2 = {
    ...e0,
    defaultUniforms: {
      ...e0.defaultUniforms,
      useFloatColors: false
    },
    inject: {
      "vs:DECKGL_FILTER_GL_POSITION": `
    // for picking depth values
    picking_setPickingAttribute(position.z / position.w);
  `,
      "vs:DECKGL_FILTER_COLOR": `
  picking_setPickingColor(geometry.pickingColor);
  `,
      "fs:DECKGL_FILTER_COLOR": {
        order: 99,
        injection: `
  // use highlight color if this fragment belongs to the selected object.
  color = picking_filterHighlightColor(color);

  // use picking color if rendering to picking FBO.
  color = picking_filterPickingColor(color);
    `
      }
    }
  }, hI = [
    m2
  ], dI = [
    "vs:DECKGL_FILTER_SIZE(inout vec3 size, VertexGeometry geometry)",
    "vs:DECKGL_FILTER_GL_POSITION(inout vec4 position, VertexGeometry geometry)",
    "vs:DECKGL_FILTER_COLOR(inout vec4 color, VertexGeometry geometry)",
    "fs:DECKGL_FILTER_COLOR(inout vec4 color, FragmentGeometry geometry)"
  ], gI = [];
  function pI(n) {
    const e = ys.getDefaultShaderAssembler();
    for (const i of hI) e.addDefaultModule(i);
    const t = n === "glsl" ? dI : gI;
    for (const i of t) e.addShaderHook(i);
    return e;
  }
  const mI = [
    255,
    255,
    255
  ], _I = 1;
  let yI = 0;
  class N2 {
    constructor(e = {}) {
      this.type = "ambient";
      const { color: t = mI } = e, { intensity: i = _I } = e;
      this.id = e.id || `ambient-${yI++}`, this.color = t, this.intensity = i;
    }
  }
  const bI = [
    255,
    255,
    255
  ], vI = 1, TI = [
    0,
    0,
    -1
  ];
  let xI = 0;
  class Dd {
    constructor(e = {}) {
      this.type = "directional";
      const { color: t = bI } = e, { intensity: i = vI } = e, { direction: s = TI } = e, { _shadow: a = false } = e;
      this.id = e.id || `directional-${xI++}`, this.color = t, this.intensity = i, this.type = "directional", this.direction = new Ln(s).normalize().toArray(), this.shadow = a;
    }
    getProjectedLight(e) {
      return this;
    }
  }
  class SI {
    constructor(e, t = {
      id: "pass"
    }) {
      const { id: i } = t;
      this.id = i, this.device = e, this.props = {
        ...t
      };
    }
    setProps(e) {
      Object.assign(this.props, e);
    }
    render(e) {
    }
    cleanup() {
    }
  }
  class Rg extends SI {
    constructor() {
      super(...arguments), this._lastRenderIndex = -1;
    }
    render(e) {
      const [t, i] = this.device.canvasContext.getDrawingBufferSize(), s = e.clearCanvas ?? true, a = e.clearColor ?? (s ? [
        0,
        0,
        0,
        0
      ] : false), l = s ? 1 : false, u = s ? 0 : false, h = e.colorMask ?? 15, d = {
        viewport: [
          0,
          0,
          t,
          i
        ]
      };
      e.colorMask && (d.colorMask = h), e.scissorRect && (d.scissorRect = e.scissorRect);
      const p = this.device.beginRenderPass({
        framebuffer: e.target,
        parameters: d,
        clearColor: a,
        clearDepth: l,
        clearStencil: u
      });
      try {
        return this._drawLayers(p, e);
      } finally {
        p.end(), this.device.submit();
      }
    }
    _drawLayers(e, t) {
      const { target: i, shaderModuleProps: s, viewports: a, views: l, onViewportActive: u, clearStack: h = true } = t;
      t.pass = t.pass || "unknown", h && (this._lastRenderIndex = -1);
      const d = [];
      for (const p of a) {
        const _ = l && l[p.id];
        u == null ? void 0 : u(p);
        const y = this._getDrawLayerParams(p, t), v = p.subViewports || [
          p
        ];
        for (const S of v) {
          const E = this._drawLayersInViewport(e, {
            target: i,
            shaderModuleProps: s,
            viewport: S,
            view: _,
            pass: t.pass,
            layers: t.layers
          }, y);
          d.push(E);
        }
      }
      return d;
    }
    _getDrawLayerParams(e, { layers: t, pass: i, isPicking: s = false, layerFilter: a, cullRect: l, effects: u, shaderModuleProps: h }, d = false) {
      var _a2;
      const p = [], _ = P2(this._lastRenderIndex + 1), y = {
        layer: t[0],
        viewport: e,
        isPicking: s,
        renderPass: i,
        cullRect: l
      }, v = {};
      for (let S = 0; S < t.length; S++) {
        const E = t[S], M = this._shouldDrawLayer(E, y, a, v), F = {
          shouldDrawLayer: M
        };
        M && !d && (F.shouldDrawLayer = true, F.layerRenderIndex = _(E, M), F.shaderModuleProps = this._getShaderModuleProps(E, u, i, h), F.layerParameters = {
          ...(_a2 = E.context.deck) == null ? void 0 : _a2.props.parameters,
          ...this.getLayerParameters(E, S, e)
        }), p[S] = F;
      }
      return p;
    }
    _drawLayersInViewport(e, { layers: t, shaderModuleProps: i, pass: s, target: a, viewport: l, view: u }, h) {
      const d = AI(this.device, {
        shaderModuleProps: i,
        target: a,
        viewport: l
      });
      if (u && u.props.clear) {
        const _ = u.props.clear === true ? {
          color: true,
          depth: true
        } : u.props.clear;
        this.device.beginRenderPass({
          framebuffer: a,
          parameters: {
            viewport: d,
            scissorRect: d
          },
          clearColor: _.color ? [
            0,
            0,
            0,
            0
          ] : false,
          clearDepth: _.depth ? 1 : false
        }).end();
      }
      const p = {
        totalCount: t.length,
        visibleCount: 0,
        compositeCount: 0,
        pickableCount: 0
      };
      e.setParameters({
        viewport: d
      });
      for (let _ = 0; _ < t.length; _++) {
        const y = t[_], v = h[_], { shouldDrawLayer: S } = v;
        if (S && y.props.pickable && p.pickableCount++, y.isComposite && p.compositeCount++, y.isDrawable && v.shouldDrawLayer) {
          const { layerRenderIndex: E, shaderModuleProps: M, layerParameters: F } = v;
          p.visibleCount++, this._lastRenderIndex = Math.max(this._lastRenderIndex, E), M.project && (M.project.viewport = l), y.context.renderPass = e;
          try {
            y._drawLayer({
              renderPass: e,
              shaderModuleProps: M,
              uniforms: {
                layerIndex: E
              },
              parameters: F
            });
          } catch (H) {
            y.raiseError(H, `drawing ${y} to ${s}`);
          }
        }
      }
      return p;
    }
    shouldDrawLayer(e) {
      return true;
    }
    getShaderModuleProps(e, t, i) {
      return null;
    }
    getLayerParameters(e, t, i) {
      return e.props.parameters;
    }
    _shouldDrawLayer(e, t, i, s) {
      if (!(e.props.visible && this.shouldDrawLayer(e))) return false;
      t.layer = e;
      let l = e.parent;
      for (; l; ) {
        if (!l.props.visible || !l.filterSubLayer(t)) return false;
        t.layer = l, l = l.parent;
      }
      if (i) {
        const u = t.layer.id;
        if (u in s || (s[u] = i(t)), !s[u]) return false;
      }
      return e.activateViewport(t.viewport), true;
    }
    _getShaderModuleProps(e, t, i, s) {
      var _a2, _b3;
      const a = this.device.canvasContext.cssToDeviceRatio(), l = ((_a2 = e.internalState) == null ? void 0 : _a2.propsInTransition) || e.props, u = {
        layer: l,
        picking: {
          isActive: false
        },
        project: {
          viewport: e.context.viewport,
          devicePixelRatio: a,
          modelMatrix: l.modelMatrix,
          coordinateSystem: l.coordinateSystem,
          coordinateOrigin: l.coordinateOrigin,
          autoWrapLongitude: e.wrapLongitude
        }
      };
      if (t) for (const h of t) w0(u, (_b3 = h.getShaderModuleProps) == null ? void 0 : _b3.call(h, e, u));
      return w0(u, this.getShaderModuleProps(e, t, u), s);
    }
  }
  function P2(n = 0, e = {}) {
    const t = {}, i = (s, a) => {
      const l = s.props._offset, u = s.id, h = s.parent && s.parent.id;
      let d;
      if (h && !(h in e) && i(s.parent, false), h in t) {
        const p = t[h] = t[h] || P2(e[h], e);
        d = p(s, a), t[u] = p;
      } else Number.isFinite(l) ? (d = l + (e[h] || 0), t[u] = null) : d = n;
      return a && d >= n && (n = d + 1), e[u] = d, d;
    };
    return i;
  }
  function AI(n, { shaderModuleProps: e, target: t, viewport: i }) {
    var _a2;
    const s = ((_a2 = e == null ? void 0 : e.project) == null ? void 0 : _a2.devicePixelRatio) ?? n.canvasContext.cssToDeviceRatio(), [, a] = n.canvasContext.getDrawingBufferSize(), l = t ? t.height : a, u = i;
    return [
      u.x * s,
      l - (u.y + u.height) * s,
      u.width * s,
      u.height * s
    ];
  }
  function w0(n, ...e) {
    for (const t of e) if (t) for (const i in t) n[i] ? Object.assign(n[i], t[i]) : n[i] = t[i];
    return n;
  }
  class wI extends Rg {
    constructor(e, t) {
      super(e, t);
      const i = e.createTexture({
        format: "rgba8unorm",
        width: 1,
        height: 1,
        sampler: {
          minFilter: "linear",
          magFilter: "linear",
          addressModeU: "clamp-to-edge",
          addressModeV: "clamp-to-edge"
        },
        mipmaps: true
      }), s = e.createTexture({
        format: "depth16unorm",
        width: 1,
        height: 1,
        mipmaps: false
      });
      this.fbo = e.createFramebuffer({
        id: "shadowmap",
        width: 1,
        height: 1,
        colorAttachments: [
          i
        ],
        depthStencilAttachment: s
      });
    }
    delete() {
      this.fbo && (this.fbo.destroy(), this.fbo = null);
    }
    getShadowMap() {
      return this.fbo.colorAttachments[0].texture;
    }
    render(e) {
      const t = this.fbo, i = this.device.canvasContext.cssToDeviceRatio(), s = e.viewports[0], a = s.width * i, l = s.height * i, u = [
        1,
        1,
        1,
        1
      ];
      (a !== t.width || l !== t.height) && t.resize({
        width: a,
        height: l
      }), super.render({
        ...e,
        clearColor: u,
        target: t,
        pass: "shadow"
      });
    }
    getLayerParameters(e, t, i) {
      return {
        ...e.props.parameters,
        blend: false,
        depthWriteEnabled: true,
        depthCompare: "less-equal"
      };
    }
    shouldDrawLayer(e) {
      return e.props.shadowEnabled !== false;
    }
    getShaderModuleProps(e, t, i) {
      return {
        shadow: {
          project: i.project,
          drawToShadowMap: true
        }
      };
    }
  }
  const EI = {
    color: [
      255,
      255,
      255
    ],
    intensity: 1
  }, E0 = [
    {
      color: [
        255,
        255,
        255
      ],
      intensity: 1,
      direction: [
        -1,
        3,
        -1
      ]
    },
    {
      color: [
        255,
        255,
        255
      ],
      intensity: 0.9,
      direction: [
        1,
        -8,
        -2.5
      ]
    }
  ], RI = [
    0,
    0,
    0,
    200 / 255
  ];
  class Cg {
    constructor(e = {}) {
      this.id = "lighting-effect", this.shadowColor = RI, this.shadow = false, this.directionalLights = [], this.pointLights = [], this.shadowPasses = [], this.dummyShadowMap = null, this.setProps(e);
    }
    setup(e) {
      this.context = e;
      const { device: t, deck: i } = e;
      this.shadow && !this.dummyShadowMap && (this._createShadowPasses(t), i._addDefaultShaderModule(A0), this.dummyShadowMap = t.createTexture({
        width: 1,
        height: 1
      }));
    }
    setProps(e) {
      this.ambientLight = void 0, this.directionalLights = [], this.pointLights = [];
      for (const t in e) {
        const i = e[t];
        switch (i.type) {
          case "ambient":
            this.ambientLight = i;
            break;
          case "directional":
            this.directionalLights.push(i);
            break;
          case "point":
            this.pointLights.push(i);
            break;
        }
      }
      this._applyDefaultLights(), this.shadow = this.directionalLights.some((t) => t.shadow), this.context && this.setup(this.context), this.props = e;
    }
    preRender({ layers: e, layerFilter: t, viewports: i, onViewportActive: s, views: a }) {
      if (this.shadow) {
        this.shadowMatrices = this._calculateMatrices();
        for (let l = 0; l < this.shadowPasses.length; l++) this.shadowPasses[l].render({
          layers: e,
          layerFilter: t,
          viewports: i,
          onViewportActive: s,
          views: a,
          shaderModuleProps: {
            shadow: {
              shadowLightId: l,
              dummyShadowMap: this.dummyShadowMap,
              shadowMatrices: this.shadowMatrices
            }
          }
        });
      }
    }
    getShaderModuleProps(e, t) {
      const i = this.shadow ? {
        project: t.project,
        shadowMaps: this.shadowPasses.map((l) => l.getShadowMap()),
        dummyShadowMap: this.dummyShadowMap,
        shadowColor: this.shadowColor,
        shadowMatrices: this.shadowMatrices
      } : {}, s = {
        enabled: true,
        ambientLight: this.ambientLight,
        directionalLights: this.directionalLights.map((l) => l.getProjectedLight({
          layer: e
        })),
        pointLights: this.pointLights.map((l) => l.getProjectedLight({
          layer: e
        }))
      }, a = e.props.material;
      return {
        shadow: i,
        lighting: s,
        phongMaterial: a,
        gouraudMaterial: a
      };
    }
    cleanup(e) {
      for (const t of this.shadowPasses) t.delete();
      this.shadowPasses.length = 0, this.dummyShadowMap && (this.dummyShadowMap.destroy(), this.dummyShadowMap = null, e.deck._removeDefaultShaderModule(A0));
    }
    _calculateMatrices() {
      const e = [];
      for (const t of this.directionalLights) {
        const i = new Fn().lookAt({
          eye: new Ln(t.direction).negate()
        });
        e.push(i);
      }
      return e;
    }
    _createShadowPasses(e) {
      for (let t = 0; t < this.directionalLights.length; t++) {
        const i = new wI(e);
        this.shadowPasses[t] = i;
      }
    }
    _applyDefaultLights() {
      const { ambientLight: e, pointLights: t, directionalLights: i } = this;
      !e && t.length === 0 && i.length === 0 && (this.ambientLight = new N2(EI), this.directionalLights.push(new Dd(E0[0]), new Dd(E0[1])));
    }
  }
  class CI {
    constructor(e = {}) {
      this._pool = [], this.opts = {
        overAlloc: 2,
        poolSize: 100
      }, this.setOptions(e);
    }
    setOptions(e) {
      Object.assign(this.opts, e);
    }
    allocate(e, t, { size: i = 1, type: s, padding: a = 0, copy: l = false, initialize: u = false, maxCount: h }) {
      const d = s || e && e.constructor || Float32Array, p = t * i + a;
      if (ArrayBuffer.isView(e)) {
        if (p <= e.length) return e;
        if (p * e.BYTES_PER_ELEMENT <= e.buffer.byteLength) return new d(e.buffer, 0, p);
      }
      let _ = 1 / 0;
      h && (_ = h * i + a);
      const y = this._allocate(d, p, u, _);
      return e && l ? y.set(e) : u || y.fill(0, 0, 4), this._release(e), y;
    }
    release(e) {
      this._release(e);
    }
    _allocate(e, t, i, s) {
      let a = Math.max(Math.ceil(t * this.opts.overAlloc), 1);
      a > s && (a = s);
      const l = this._pool, u = e.BYTES_PER_ELEMENT * a, h = l.findIndex((d) => d.byteLength >= u);
      if (h >= 0) {
        const d = new e(l.splice(h, 1)[0], 0, a);
        return i && d.fill(0), d;
      }
      return new e(a);
    }
    _release(e) {
      if (!ArrayBuffer.isView(e)) return;
      const t = this._pool, { buffer: i } = e, { byteLength: s } = i, a = t.findIndex((l) => l.byteLength >= s);
      a < 0 ? t.push(i) : (a > 0 || t.length < this.opts.poolSize) && t.splice(a, 0, i), t.length > this.opts.poolSize && t.shift();
    }
  }
  const bo = new CI();
  function io() {
    return [
      1,
      0,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      1,
      0,
      0,
      0,
      0,
      1
    ];
  }
  function MI(n) {
    return [
      n[12],
      n[13],
      n[14]
    ];
  }
  function OI(n) {
    return {
      left: Ar(n[3] + n[0], n[7] + n[4], n[11] + n[8], n[15] + n[12]),
      right: Ar(n[3] - n[0], n[7] - n[4], n[11] - n[8], n[15] - n[12]),
      bottom: Ar(n[3] + n[1], n[7] + n[5], n[11] + n[9], n[15] + n[13]),
      top: Ar(n[3] - n[1], n[7] - n[5], n[11] - n[9], n[15] - n[13]),
      near: Ar(n[3] + n[2], n[7] + n[6], n[11] + n[10], n[15] + n[14]),
      far: Ar(n[3] - n[2], n[7] - n[6], n[11] - n[10], n[15] - n[14])
    };
  }
  const R0 = new Ln();
  function Ar(n, e, t, i) {
    R0.set(n, e, t);
    const s = R0.len();
    return {
      distance: i / s,
      normal: new Ln(-n / s, -e / s, -t / s)
    };
  }
  function II(n) {
    return n - Math.fround(n);
  }
  let Ga;
  function Kh(n, e) {
    const { size: t = 1, startIndex: i = 0 } = e, s = e.endIndex !== void 0 ? e.endIndex : n.length, a = (s - i) / t;
    Ga = bo.allocate(Ga, a, {
      type: Float32Array,
      size: t * 2
    });
    let l = i, u = 0;
    for (; l < s; ) {
      for (let h = 0; h < t; h++) {
        const d = n[l++];
        Ga[u + h] = d, Ga[u + h + t] = II(d);
      }
      u += t * 2;
    }
    return Ga.subarray(0, a * t * 2);
  }
  function NI(n) {
    let e = null, t = false;
    for (const i of n) i && (e ? (t || (e = [
      [
        e[0][0],
        e[0][1]
      ],
      [
        e[1][0],
        e[1][1]
      ]
    ], t = true), e[0][0] = Math.min(e[0][0], i[0][0]), e[0][1] = Math.min(e[0][1], i[0][1]), e[1][0] = Math.max(e[1][0], i[1][0]), e[1][1] = Math.max(e[1][1], i[1][1])) : e = i);
    return e;
  }
  const PI = Math.PI / 180, DI = io(), C0 = [
    0,
    0,
    0
  ], kI = {
    unitsPerMeter: [
      1,
      1,
      1
    ],
    metersPerUnit: [
      1,
      1,
      1
    ]
  };
  function UI({ width: n, height: e, orthographic: t, fovyRadians: i, focalDistance: s, padding: a, near: l, far: u }) {
    const h = n / e, d = t ? new Fn().orthographic({
      fovy: i,
      aspect: h,
      focalDistance: s,
      near: l,
      far: u
    }) : new Fn().perspective({
      fovy: i,
      aspect: h,
      near: l,
      far: u
    });
    if (a) {
      const { left: p = 0, right: _ = 0, top: y = 0, bottom: v = 0 } = a, S = Hi((p + n - _) / 2, 0, n) - n / 2, E = Hi((y + e - v) / 2, 0, e) - e / 2;
      d[8] -= S * 2 / n, d[9] += E * 2 / e;
    }
    return d;
  }
  class Zr {
    constructor(e = {}) {
      this._frustumPlanes = {}, this.id = e.id || this.constructor.displayName || "viewport", this.x = e.x || 0, this.y = e.y || 0, this.width = e.width || 1, this.height = e.height || 1, this.zoom = e.zoom || 0, this.padding = e.padding, this.distanceScales = e.distanceScales || kI, this.focalDistance = e.focalDistance || 1, this.position = e.position || C0, this.modelMatrix = e.modelMatrix || null;
      const { longitude: t, latitude: i } = e;
      this.isGeospatial = Number.isFinite(i) && Number.isFinite(t), this._initProps(e), this._initMatrices(e), this.equals = this.equals.bind(this), this.project = this.project.bind(this), this.unproject = this.unproject.bind(this), this.projectPosition = this.projectPosition.bind(this), this.unprojectPosition = this.unprojectPosition.bind(this), this.projectFlat = this.projectFlat.bind(this), this.unprojectFlat = this.unprojectFlat.bind(this);
    }
    get subViewports() {
      return null;
    }
    get metersPerPixel() {
      return this.distanceScales.metersPerUnit[2] / this.scale;
    }
    get projectionMode() {
      return this.isGeospatial ? this.zoom < 12 ? hn.WEB_MERCATOR : hn.WEB_MERCATOR_AUTO_OFFSET : hn.IDENTITY;
    }
    equals(e) {
      return e instanceof Zr ? this === e ? true : e.width === this.width && e.height === this.height && e.scale === this.scale && _o(e.projectionMatrix, this.projectionMatrix) && _o(e.viewMatrix, this.viewMatrix) : false;
    }
    project(e, { topLeft: t = true } = {}) {
      const i = this.projectPosition(e), s = M2(i, this.pixelProjectionMatrix), [a, l] = s, u = t ? l : this.height - l;
      return e.length === 2 ? [
        a,
        u
      ] : [
        a,
        u,
        s[2]
      ];
    }
    unproject(e, { topLeft: t = true, targetZ: i } = {}) {
      const [s, a, l] = e, u = t ? a : this.height - a, h = i && i * this.distanceScales.unitsPerMeter[2], d = Eg([
        s,
        u,
        l
      ], this.pixelUnprojectionMatrix, h), [p, _, y] = this.unprojectPosition(d);
      return Number.isFinite(l) ? [
        p,
        _,
        y
      ] : Number.isFinite(i) ? [
        p,
        _,
        i
      ] : [
        p,
        _
      ];
    }
    projectPosition(e) {
      const [t, i] = this.projectFlat(e), s = (e[2] || 0) * this.distanceScales.unitsPerMeter[2];
      return [
        t,
        i,
        s
      ];
    }
    unprojectPosition(e) {
      const [t, i] = this.unprojectFlat(e), s = (e[2] || 0) * this.distanceScales.metersPerUnit[2];
      return [
        t,
        i,
        s
      ];
    }
    projectFlat(e) {
      if (this.isGeospatial) {
        const t = Ic(e);
        return t[1] = Hi(t[1], -318, 830), t;
      }
      return e;
    }
    unprojectFlat(e) {
      return this.isGeospatial ? $r(e) : e;
    }
    getBounds(e = {}) {
      const t = {
        targetZ: e.z || 0
      }, i = this.unproject([
        0,
        0
      ], t), s = this.unproject([
        this.width,
        0
      ], t), a = this.unproject([
        0,
        this.height
      ], t), l = this.unproject([
        this.width,
        this.height
      ], t);
      return [
        Math.min(i[0], s[0], a[0], l[0]),
        Math.min(i[1], s[1], a[1], l[1]),
        Math.max(i[0], s[0], a[0], l[0]),
        Math.max(i[1], s[1], a[1], l[1])
      ];
    }
    getDistanceScales(e) {
      return e && this.isGeospatial ? Pd({
        longitude: e[0],
        latitude: e[1],
        highPrecision: true
      }) : this.distanceScales;
    }
    containsPixel({ x: e, y: t, width: i = 1, height: s = 1 }) {
      return e < this.x + this.width && this.x < e + i && t < this.y + this.height && this.y < t + s;
    }
    getFrustumPlanes() {
      return this._frustumPlanes.near ? this._frustumPlanes : (Object.assign(this._frustumPlanes, OI(this.viewProjectionMatrix)), this._frustumPlanes);
    }
    panByPosition(e, t) {
      return null;
    }
    _initProps(e) {
      const t = e.longitude, i = e.latitude;
      this.isGeospatial && (Number.isFinite(e.zoom) || (this.zoom = YO({
        latitude: i
      }) + Math.log2(this.focalDistance)), this.distanceScales = e.distanceScales || Pd({
        latitude: i,
        longitude: t
      }));
      const s = Math.pow(2, this.zoom);
      this.scale = s;
      const { position: a, modelMatrix: l } = e;
      let u = C0;
      if (a && (u = l ? new Fn(l).transformAsVector(a, []) : a), this.isGeospatial) {
        const h = this.projectPosition([
          t,
          i,
          0
        ]);
        this.center = new Ln(u).scale(this.distanceScales.unitsPerMeter).add(h);
      } else this.center = this.projectPosition(u);
    }
    _initMatrices(e) {
      const { viewMatrix: t = DI, projectionMatrix: i = null, orthographic: s = false, fovyRadians: a, fovy: l = 75, near: u = 0.1, far: h = 1e3, padding: d = null, focalDistance: p = 1 } = e;
      this.viewMatrixUncentered = t, this.viewMatrix = new Fn().multiplyRight(t).translate(new Ln(this.center).negate()), this.projectionMatrix = i || UI({
        width: this.width,
        height: this.height,
        orthographic: s,
        fovyRadians: a || l * PI,
        focalDistance: p,
        padding: d,
        near: u,
        far: h
      });
      const _ = io();
      xs(_, _, this.projectionMatrix), xs(_, _, this.viewMatrix), this.viewProjectionMatrix = _, this.viewMatrixInverse = Ad([], this.viewMatrix) || this.viewMatrix, this.cameraPosition = MI(this.viewMatrixInverse);
      const y = io(), v = io();
      Sg(y, y, [
        this.width / 2,
        -this.height / 2,
        1
      ]), Cc(y, y, [
        1,
        -1,
        0
      ]), xs(v, y, this.viewProjectionMatrix), this.pixelProjectionMatrix = v, this.pixelUnprojectionMatrix = Ad(io(), this.pixelProjectionMatrix), this.pixelUnprojectionMatrix || Le.warn("Pixel project matrix not invertible")();
    }
  }
  Zr.displayName = "Viewport";
  class Xr extends Zr {
    constructor(e = {}) {
      const { latitude: t = 0, longitude: i = 0, zoom: s = 0, pitch: a = 0, bearing: l = 0, nearZMultiplier: u = 0.1, farZMultiplier: h = 1.01, nearZ: d, farZ: p, orthographic: _ = false, projectionMatrix: y, repeat: v = false, worldOffset: S = 0, position: E, padding: M, legacyMeterSizes: F = false } = e;
      let { width: H, height: O, altitude: U = 1.5 } = e;
      const B = Math.pow(2, s);
      H = H || 1, O = O || 1;
      let Z, re = null;
      if (y) U = y[5] / 2, Z = Nc(U);
      else {
        e.fovy ? (Z = e.fovy, U = C2(Z)) : Z = Nc(U);
        let ee;
        if (M) {
          const { top: fe = 0, bottom: te = 0 } = M;
          ee = [
            0,
            Hi((fe + O - te) / 2, 0, O) - O / 2
          ];
        }
        re = KO({
          width: H,
          height: O,
          scale: B,
          center: E && [
            0,
            0,
            E[2] * qh(t)
          ],
          offset: ee,
          pitch: a,
          fovy: Z,
          nearZMultiplier: u,
          farZMultiplier: h
        }), Number.isFinite(d) && (re.near = d), Number.isFinite(p) && (re.far = p);
      }
      let le = qO({
        height: O,
        pitch: a,
        bearing: l,
        scale: B,
        altitude: U
      });
      S && (le = new Fn().translate([
        512 * S,
        0,
        0
      ]).multiplyLeft(le)), super({
        ...e,
        width: H,
        height: O,
        viewMatrix: le,
        longitude: i,
        latitude: t,
        zoom: s,
        ...re,
        fovy: Z,
        focalDistance: U
      }), this.latitude = t, this.longitude = i, this.zoom = s, this.pitch = a, this.bearing = l, this.altitude = U, this.fovy = Z, this.orthographic = _, this._subViewports = v ? [] : null, this._pseudoMeters = F, Object.freeze(this);
    }
    get subViewports() {
      if (this._subViewports && !this._subViewports.length) {
        const e = this.getBounds(), t = Math.floor((e[0] + 180) / 360), i = Math.ceil((e[2] - 180) / 360);
        for (let s = t; s <= i; s++) {
          const a = s ? new Xr({
            ...this,
            worldOffset: s
          }) : this;
          this._subViewports.push(a);
        }
      }
      return this._subViewports;
    }
    projectPosition(e) {
      if (this._pseudoMeters) return super.projectPosition(e);
      const [t, i] = this.projectFlat(e), s = (e[2] || 0) * qh(e[1]);
      return [
        t,
        i,
        s
      ];
    }
    unprojectPosition(e) {
      if (this._pseudoMeters) return super.unprojectPosition(e);
      const [t, i] = this.unprojectFlat(e), s = (e[2] || 0) / qh(i);
      return [
        t,
        i,
        s
      ];
    }
    addMetersToLngLat(e, t) {
      return R2(e, t);
    }
    panByPosition(e, t) {
      const i = Eg(t, this.pixelUnprojectionMatrix), s = this.projectFlat(e), a = Gb([], s, EC([], i)), l = Gb([], this.center, a), [u, h] = this.unprojectFlat(l);
      return {
        longitude: u,
        latitude: h
      };
    }
    getBounds(e = {}) {
      const t = GO(this, e.z || 0);
      return [
        Math.min(t[0][0], t[1][0], t[2][0], t[3][0]),
        Math.min(t[0][1], t[1][1], t[2][1], t[3][1]),
        Math.max(t[0][0], t[1][0], t[2][0], t[3][0]),
        Math.max(t[0][1], t[1][1], t[2][1], t[3][1])
      ];
    }
    fitBounds(e, t = {}) {
      const { width: i, height: s } = this, { longitude: a, latitude: l, zoom: u } = ZO({
        width: i,
        height: s,
        bounds: e,
        ...t
      });
      return new Xr({
        width: i,
        height: s,
        longitude: a,
        latitude: l,
        zoom: u
      });
    }
  }
  Xr.displayName = "WebMercatorViewport";
  const M0 = [
    0,
    0,
    0
  ];
  function Zh(n, e, t = false) {
    const i = e.projectPosition(n);
    if (t && e instanceof Xr) {
      const [s, a, l = 0] = n, u = e.getDistanceScales([
        s,
        a
      ]);
      i[2] = l * u.unitsPerMeter[2];
    }
    return i;
  }
  function BI(n) {
    const { viewport: e, modelMatrix: t, coordinateOrigin: i } = n;
    let { coordinateSystem: s, fromCoordinateSystem: a, fromCoordinateOrigin: l } = n;
    return s === Oe.DEFAULT && (s = e.isGeospatial ? Oe.LNGLAT : Oe.CARTESIAN), a === void 0 && (a = s), l === void 0 && (l = i), {
      viewport: e,
      coordinateSystem: s,
      coordinateOrigin: i,
      modelMatrix: t,
      fromCoordinateSystem: a,
      fromCoordinateOrigin: l
    };
  }
  function D2(n, { viewport: e, modelMatrix: t, coordinateSystem: i, coordinateOrigin: s, offsetMode: a }) {
    let [l, u, h = 0] = n;
    switch (t && ([l, u, h] = Eo([], [
      l,
      u,
      h,
      1
    ], t)), i) {
      case Oe.LNGLAT:
        return Zh([
          l,
          u,
          h
        ], e, a);
      case Oe.LNGLAT_OFFSETS:
        return Zh([
          l + s[0],
          u + s[1],
          h + (s[2] || 0)
        ], e, a);
      case Oe.METER_OFFSETS:
        return Zh(R2(s, [
          l,
          u,
          h
        ]), e, a);
      case Oe.CARTESIAN:
      default:
        return e.isGeospatial ? [
          l + s[0],
          u + s[1],
          h + s[2]
        ] : e.projectPosition([
          l,
          u,
          h
        ]);
    }
  }
  function k2(n, e) {
    const { viewport: t, coordinateSystem: i, coordinateOrigin: s, modelMatrix: a, fromCoordinateSystem: l, fromCoordinateOrigin: u } = BI(e), { autoOffset: h = true } = e, { geospatialOrigin: d = M0, shaderCoordinateOrigin: p = M0, offsetMode: _ = false } = h ? w2(t, i, s) : {}, y = D2(n, {
      viewport: t,
      modelMatrix: a,
      coordinateSystem: l,
      coordinateOrigin: u,
      offsetMode: _
    });
    if (_) {
      const v = t.projectPosition(d || p);
      zC(y, y, v);
    }
    return y;
  }
  const LI = [
    255,
    255,
    255
  ], FI = 1, VI = [
    1,
    0,
    0
  ], zI = [
    0,
    0,
    1
  ];
  let HI = 0;
  class Mg {
    constructor(e = {}) {
      this.type = "point";
      const { color: t = LI } = e, { intensity: i = FI } = e, { position: s = zI } = e;
      this.id = e.id || `point-${HI++}`, this.color = t, this.intensity = i, this.type = "point", this.position = s, this.attenuation = jI(e), this.projectedLight = {
        ...this
      };
    }
    getProjectedLight({ layer: e }) {
      const { projectedLight: t } = this, i = e.context.viewport, { coordinateSystem: s, coordinateOrigin: a } = e.props, l = k2(this.position, {
        viewport: i,
        coordinateSystem: s,
        coordinateOrigin: a,
        fromCoordinateSystem: i.isGeospatial ? Oe.LNGLAT : Oe.CARTESIAN,
        fromCoordinateOrigin: [
          0,
          0,
          0
        ]
      });
      return t.color = this.color, t.intensity = this.intensity, t.position = l, t;
    }
  }
  function jI(n) {
    return n.attenuation ? n.attenuation : VI;
  }
  let WI = 1, $I = 1;
  class U2 {
    constructor() {
      __publicField(this, "time", 0);
      __publicField(this, "channels", /* @__PURE__ */ new Map());
      __publicField(this, "animations", /* @__PURE__ */ new Map());
      __publicField(this, "playing", false);
      __publicField(this, "lastEngineTime", -1);
    }
    addChannel(e) {
      const { delay: t = 0, duration: i = Number.POSITIVE_INFINITY, rate: s = 1, repeat: a = 1 } = e, l = WI++, u = {
        time: 0,
        delay: t,
        duration: i,
        rate: s,
        repeat: a
      };
      return this._setChannelTime(u, this.time), this.channels.set(l, u), l;
    }
    removeChannel(e) {
      this.channels.delete(e);
      for (const [t, i] of this.animations) i.channel === e && this.detachAnimation(t);
    }
    isFinished(e) {
      const t = this.channels.get(e);
      return t === void 0 ? false : this.time >= t.delay + t.duration * t.repeat;
    }
    getTime(e) {
      if (e === void 0) return this.time;
      const t = this.channels.get(e);
      return t === void 0 ? -1 : t.time;
    }
    setTime(e) {
      this.time = Math.max(0, e);
      const t = this.channels.values();
      for (const s of t) this._setChannelTime(s, this.time);
      const i = this.animations.values();
      for (const s of i) {
        const { animation: a, channel: l } = s;
        a.setTime(this.getTime(l));
      }
    }
    play() {
      this.playing = true;
    }
    pause() {
      this.playing = false, this.lastEngineTime = -1;
    }
    reset() {
      this.setTime(0);
    }
    attachAnimation(e, t) {
      const i = $I++;
      return this.animations.set(i, {
        animation: e,
        channel: t
      }), e.setTime(this.getTime(t)), i;
    }
    detachAnimation(e) {
      this.animations.delete(e);
    }
    update(e) {
      this.playing && (this.lastEngineTime === -1 && (this.lastEngineTime = e), this.setTime(this.time + (e - this.lastEngineTime)), this.lastEngineTime = e);
    }
    _setChannelTime(e, t) {
      const i = t - e.delay, s = e.duration * e.repeat;
      i >= s ? e.time = e.duration * e.rate : (e.time = Math.max(0, i) % e.duration, e.time *= e.rate);
    }
  }
  function XI(n) {
    return typeof window < "u" && window.requestAnimationFrame ? window.requestAnimationFrame(n) : setTimeout(n, 1e3 / 60);
  }
  function YI(n) {
    return typeof window < "u" && window.cancelAnimationFrame ? window.cancelAnimationFrame(n) : clearTimeout(n);
  }
  let qI = 0;
  const KI = {
    device: null,
    onAddHTML: () => "",
    onInitialize: async () => null,
    onRender: () => {
    },
    onFinalize: () => {
    },
    onError: (n) => console.error(n),
    stats: Td.stats.get(`animation-loop-${qI++}`),
    useDevicePixels: true,
    autoResizeViewport: false,
    autoResizeDrawingBuffer: false
  };
  class ZI {
    constructor(e) {
      __publicField(this, "device", null);
      __publicField(this, "canvas", null);
      __publicField(this, "props");
      __publicField(this, "animationProps", null);
      __publicField(this, "timeline", null);
      __publicField(this, "stats");
      __publicField(this, "cpuTime");
      __publicField(this, "gpuTime");
      __publicField(this, "frameRate");
      __publicField(this, "display");
      __publicField(this, "needsRedraw", "initialized");
      __publicField(this, "_initialized", false);
      __publicField(this, "_running", false);
      __publicField(this, "_animationFrameId", null);
      __publicField(this, "_nextFramePromise", null);
      __publicField(this, "_resolveNextFrame", null);
      __publicField(this, "_cpuStartTime", 0);
      __publicField(this, "_error", null);
      if (this.props = {
        ...KI,
        ...e
      }, e = this.props, !e.device) throw new Error("No device provided");
      const { useDevicePixels: t = true } = this.props;
      this.stats = e.stats || new Xc({
        id: "animation-loop-stats"
      }), this.cpuTime = this.stats.get("CPU Time"), this.gpuTime = this.stats.get("GPU Time"), this.frameRate = this.stats.get("Frame Rate"), this.setProps({
        autoResizeViewport: e.autoResizeViewport,
        autoResizeDrawingBuffer: e.autoResizeDrawingBuffer,
        useDevicePixels: t
      }), this.start = this.start.bind(this), this.stop = this.stop.bind(this), this._onMousemove = this._onMousemove.bind(this), this._onMouseleave = this._onMouseleave.bind(this);
    }
    destroy() {
      this.stop(), this._setDisplay(null);
    }
    delete() {
      this.destroy();
    }
    setError(e) {
      var _a2, _b3;
      if (this.props.onError(e), this._error = Error(), ((_b3 = (_a2 = this.device) == null ? void 0 : _a2.canvasContext) == null ? void 0 : _b3.canvas) instanceof HTMLCanvasElement) {
        const i = document.createElement("h1");
        i.innerHTML = e.message, i.style.position = "absolute", i.style.top = "20%", i.style.left = "10px", i.style.color = "black", i.style.backgroundColor = "red", document.body.appendChild(i);
      }
    }
    setNeedsRedraw(e) {
      return this.needsRedraw = this.needsRedraw || e, this;
    }
    setProps(e) {
      return "autoResizeViewport" in e && (this.props.autoResizeViewport = e.autoResizeViewport || false), "autoResizeDrawingBuffer" in e && (this.props.autoResizeDrawingBuffer = e.autoResizeDrawingBuffer || false), "useDevicePixels" in e && (this.props.useDevicePixels = e.useDevicePixels || false), this;
    }
    async start() {
      if (this._running) return this;
      this._running = true;
      try {
        let e;
        return this._initialized || (this._initialized = true, await this._initDevice(), this._initialize(), await this.props.onInitialize(this._getAnimationProps())), this._running ? (e !== false && (this._cancelAnimationFrame(), this._requestAnimationFrame()), this) : null;
      } catch (e) {
        const t = e instanceof Error ? e : new Error("Unknown error");
        throw this.props.onError(t), t;
      }
    }
    stop() {
      return this._running && (this.animationProps && !this._error && this.props.onFinalize(this.animationProps), this._cancelAnimationFrame(), this._nextFramePromise = null, this._resolveNextFrame = null, this._running = false), this;
    }
    redraw() {
      var _a2;
      return ((_a2 = this.device) == null ? void 0 : _a2.isLost) || this._error ? this : (this._beginFrameTimers(), this._setupFrame(), this._updateAnimationProps(), this._renderFrame(this._getAnimationProps()), this._clearNeedsRedraw(), this._resolveNextFrame && (this._resolveNextFrame(this), this._nextFramePromise = null, this._resolveNextFrame = null), this._endFrameTimers(), this);
    }
    attachTimeline(e) {
      return this.timeline = e, this.timeline;
    }
    detachTimeline() {
      this.timeline = null;
    }
    waitForRender() {
      return this.setNeedsRedraw("waitForRender"), this._nextFramePromise || (this._nextFramePromise = new Promise((e) => {
        this._resolveNextFrame = e;
      })), this._nextFramePromise;
    }
    async toDataURL() {
      if (this.setNeedsRedraw("toDataURL"), await this.waitForRender(), this.canvas instanceof HTMLCanvasElement) return this.canvas.toDataURL();
      throw new Error("OffscreenCanvas");
    }
    _initialize() {
      this._startEventHandling(), this._initializeAnimationProps(), this._updateAnimationProps(), this._resizeCanvasDrawingBuffer(), this._resizeViewport();
    }
    _setDisplay(e) {
      this.display && (this.display.destroy(), this.display.animationLoop = null), e && (e.animationLoop = this), this.display = e;
    }
    _requestAnimationFrame() {
      this._running && (this._animationFrameId = XI(this._animationFrame.bind(this)));
    }
    _cancelAnimationFrame() {
      this._animationFrameId !== null && (YI(this._animationFrameId), this._animationFrameId = null);
    }
    _animationFrame() {
      this._running && (this.redraw(), this._requestAnimationFrame());
    }
    _renderFrame(e) {
      var _a2;
      if (this.display) {
        this.display._renderFrame(e);
        return;
      }
      this.props.onRender(this._getAnimationProps()), (_a2 = this.device) == null ? void 0 : _a2.submit();
    }
    _clearNeedsRedraw() {
      this.needsRedraw = false;
    }
    _setupFrame() {
      this._resizeCanvasDrawingBuffer(), this._resizeViewport();
    }
    _initializeAnimationProps() {
      var _a2, _b3;
      const e = (_b3 = (_a2 = this.device) == null ? void 0 : _a2.canvasContext) == null ? void 0 : _b3.canvas;
      if (!this.device || !e) throw new Error("loop");
      this.animationProps = {
        animationLoop: this,
        device: this.device,
        canvas: e,
        timeline: this.timeline,
        useDevicePixels: this.props.useDevicePixels,
        needsRedraw: false,
        width: 1,
        height: 1,
        aspect: 1,
        time: 0,
        startTime: Date.now(),
        engineTime: 0,
        tick: 0,
        tock: 0,
        _mousePosition: null
      };
    }
    _getAnimationProps() {
      if (!this.animationProps) throw new Error("animationProps");
      return this.animationProps;
    }
    _updateAnimationProps() {
      if (!this.animationProps) return;
      const { width: e, height: t, aspect: i } = this._getSizeAndAspect();
      (e !== this.animationProps.width || t !== this.animationProps.height) && this.setNeedsRedraw("drawing buffer resized"), i !== this.animationProps.aspect && this.setNeedsRedraw("drawing buffer aspect changed"), this.animationProps.width = e, this.animationProps.height = t, this.animationProps.aspect = i, this.animationProps.needsRedraw = this.needsRedraw, this.animationProps.engineTime = Date.now() - this.animationProps.startTime, this.timeline && this.timeline.update(this.animationProps.engineTime), this.animationProps.tick = Math.floor(this.animationProps.time / 1e3 * 60), this.animationProps.tock++, this.animationProps.time = this.timeline ? this.timeline.getTime() : this.animationProps.engineTime;
    }
    async _initDevice() {
      var _a2;
      if (this.device = await this.props.device, !this.device) throw new Error("No device provided");
      this.canvas = ((_a2 = this.device.canvasContext) == null ? void 0 : _a2.canvas) || null;
    }
    _createInfoDiv() {
      if (this.canvas && this.props.onAddHTML) {
        const e = document.createElement("div");
        document.body.appendChild(e), e.style.position = "relative";
        const t = document.createElement("div");
        t.style.position = "absolute", t.style.left = "10px", t.style.bottom = "10px", t.style.width = "300px", t.style.background = "white", this.canvas instanceof HTMLCanvasElement && e.appendChild(this.canvas), e.appendChild(t);
        const i = this.props.onAddHTML(t);
        i && (t.innerHTML = i);
      }
    }
    _getSizeAndAspect() {
      var _a2, _b3, _c2, _d2;
      if (!this.device) return {
        width: 1,
        height: 1,
        aspect: 1
      };
      const [e, t] = ((_b3 = (_a2 = this.device) == null ? void 0 : _a2.canvasContext) == null ? void 0 : _b3.getPixelSize()) || [
        1,
        1
      ];
      let i = 1;
      const s = (_d2 = (_c2 = this.device) == null ? void 0 : _c2.canvasContext) == null ? void 0 : _d2.canvas;
      return s && s.clientHeight ? i = s.clientWidth / s.clientHeight : e > 0 && t > 0 && (i = e / t), {
        width: e,
        height: t,
        aspect: i
      };
    }
    _resizeViewport() {
      this.props.autoResizeViewport && this.device.gl && this.device.gl.viewport(0, 0, this.device.gl.drawingBufferWidth, this.device.gl.drawingBufferHeight);
    }
    _resizeCanvasDrawingBuffer() {
      var _a2, _b3;
      this.props.autoResizeDrawingBuffer && ((_b3 = (_a2 = this.device) == null ? void 0 : _a2.canvasContext) == null ? void 0 : _b3.resize({
        useDevicePixels: this.props.useDevicePixels
      }));
    }
    _beginFrameTimers() {
      this.frameRate.timeEnd(), this.frameRate.timeStart(), this.cpuTime.timeStart();
    }
    _endFrameTimers() {
      this.cpuTime.timeEnd();
    }
    _startEventHandling() {
      this.canvas && (this.canvas.addEventListener("mousemove", this._onMousemove.bind(this)), this.canvas.addEventListener("mouseleave", this._onMouseleave.bind(this)));
    }
    _onMousemove(e) {
      e instanceof MouseEvent && (this._getAnimationProps()._mousePosition = [
        e.offsetX,
        e.offsetY
      ]);
    }
    _onMouseleave(e) {
      this._getAnimationProps()._mousePosition = null;
    }
  }
  const Qh = {};
  function Jc(n = "id") {
    Qh[n] = Qh[n] || 1;
    const e = Qh[n]++;
    return `${n}-${e}`;
  }
  class O0 {
    constructor(e) {
      __publicField(this, "id");
      __publicField(this, "userData", {});
      __publicField(this, "topology");
      __publicField(this, "bufferLayout", []);
      __publicField(this, "vertexCount");
      __publicField(this, "indices");
      __publicField(this, "attributes");
      if (this.id = e.id || Jc("geometry"), this.topology = e.topology, this.indices = e.indices || null, this.attributes = e.attributes, this.vertexCount = e.vertexCount, this.bufferLayout = e.bufferLayout || [], this.indices && !(this.indices.usage & Ke.INDEX)) throw new Error("Index buffer must have INDEX usage");
    }
    destroy() {
      var _a2;
      (_a2 = this.indices) == null ? void 0 : _a2.destroy();
      for (const e of Object.values(this.attributes)) e.destroy();
    }
    getVertexCount() {
      return this.vertexCount;
    }
    getAttributes() {
      return this.attributes;
    }
    getIndexes() {
      return this.indices || null;
    }
    _calculateVertexCount(e) {
      return e.byteLength / 12;
    }
  }
  function QI(n, e) {
    if (e instanceof O0) return e;
    const t = GI(n, e), { attributes: i, bufferLayout: s } = JI(n, e);
    return new O0({
      topology: e.topology || "triangle-list",
      bufferLayout: s,
      vertexCount: e.vertexCount,
      indices: t,
      attributes: i
    });
  }
  function GI(n, e) {
    if (!e.indices) return;
    const t = e.indices.value;
    return n.createBuffer({
      usage: Ke.INDEX,
      data: t
    });
  }
  function JI(n, e) {
    const t = [], i = {};
    for (const [a, l] of Object.entries(e.attributes)) {
      let u = a;
      switch (a) {
        case "POSITION":
          u = "positions";
          break;
        case "NORMAL":
          u = "normals";
          break;
        case "TEXCOORD_0":
          u = "texCoords";
          break;
        case "COLOR_0":
          u = "colors";
          break;
      }
      if (l) {
        i[u] = n.createBuffer({
          data: l.value,
          id: `${a}-buffer`
        });
        const { value: h, size: d, normalized: p } = l;
        t.push({
          name: u,
          format: VR(h, d, p)
        });
      }
    }
    const s = e._calculateVertexCount(e.attributes, e.indices);
    return {
      attributes: i,
      bufferLayout: t,
      vertexCount: s
    };
  }
  const _Og = class _Og {
    constructor(e) {
      __publicField(this, "device");
      __publicField(this, "destroyPolicy");
      __publicField(this, "_hashCounter", 0);
      __publicField(this, "_hashes", {});
      __publicField(this, "_renderPipelineCache", {});
      __publicField(this, "_computePipelineCache", {});
      this.device = e, this.destroyPolicy = e.props._factoryDestroyPolicy;
    }
    static getDefaultPipelineFactory(e) {
      return e._lumaData.defaultPipelineFactory = e._lumaData.defaultPipelineFactory || new _Og(e), e._lumaData.defaultPipelineFactory;
    }
    createRenderPipeline(e) {
      const t = {
        ...Vr.defaultProps,
        ...e
      }, i = this._hashRenderPipeline(t);
      if (!this._renderPipelineCache[i]) {
        const s = this.device.createRenderPipeline({
          ...t,
          id: t.id ? `${t.id}-cached` : void 0
        });
        s.hash = i, this._renderPipelineCache[i] = {
          pipeline: s,
          useCount: 0
        };
      }
      return this._renderPipelineCache[i].useCount++, this._renderPipelineCache[i].pipeline;
    }
    createComputePipeline(e) {
      const t = {
        ...vc.defaultProps,
        ...e
      }, i = this._hashComputePipeline(t);
      if (!this._computePipelineCache[i]) {
        const s = this.device.createComputePipeline({
          ...t,
          id: t.id ? `${t.id}-cached` : void 0
        });
        s.hash = i, this._computePipelineCache[i] = {
          pipeline: s,
          useCount: 0
        };
      }
      return this._computePipelineCache[i].useCount++, this._computePipelineCache[i].pipeline;
    }
    release(e) {
      const t = e.hash, i = e instanceof vc ? this._computePipelineCache : this._renderPipelineCache;
      i[t].useCount--, i[t].useCount === 0 && this.destroyPolicy === "unused" && (i[t].pipeline.destroy(), delete i[t]);
    }
    _hashComputePipeline(e) {
      return `${this._getHash(e.shader.source)}`;
    }
    _hashRenderPipeline(e) {
      const t = e.vs ? this._getHash(e.vs.source) : 0, i = e.fs ? this._getHash(e.fs.source) : 0, s = "-", a = this._getHash(JSON.stringify(e.bufferLayout));
      switch (this.device.type) {
        case "webgl":
          return `${t}/${i}V${s}BL${a}`;
        default:
          const l = this._getHash(JSON.stringify(e.parameters));
          return `${t}/${i}V${s}T${e.topology}P${l}BL${a}`;
      }
    }
    _getHash(e) {
      return this._hashes[e] === void 0 && (this._hashes[e] = this._hashCounter++), this._hashes[e];
    }
  };
  __publicField(_Og, "defaultProps", {
    ...Vr.defaultProps
  });
  let Og = _Og;
  const _Ig = class _Ig {
    constructor(e) {
      __publicField(this, "device");
      __publicField(this, "destroyPolicy");
      __publicField(this, "_cache", {});
      this.device = e, this.destroyPolicy = e.props._factoryDestroyPolicy;
    }
    static getDefaultShaderFactory(e) {
      var _a2;
      return (_a2 = e._lumaData).defaultShaderFactory || (_a2.defaultShaderFactory = new _Ig(e)), e._lumaData.defaultShaderFactory;
    }
    createShader(e) {
      const t = this._hashShader(e);
      let i = this._cache[t];
      if (!i) {
        const s = this.device.createShader({
          ...e,
          id: e.id ? `${e.id}-cached` : void 0
        });
        this._cache[t] = i = {
          shader: s,
          useCount: 0
        };
      }
      return i.useCount++, i.shader;
    }
    release(e) {
      const t = this._hashShader(e), i = this._cache[t];
      i && (i.useCount--, i.useCount === 0 && this.destroyPolicy === "unused" && (delete this._cache[t], i.shader.destroy()));
    }
    _hashShader(e) {
      return `${e.stage}:${e.source}`;
    }
  };
  __publicField(_Ig, "defaultProps", {
    ...Zc.defaultProps
  });
  let Ig = _Ig;
  function e4(n, e) {
    var _a2;
    const t = {}, i = "Values";
    if (n.attributes.length === 0 && !((_a2 = n.varyings) == null ? void 0 : _a2.length)) return {
      "No attributes or varyings": {
        [i]: "N/A"
      }
    };
    for (const s of n.attributes) if (s) {
      const a = `${s.location} ${s.name}: ${s.type}`;
      t[`in ${a}`] = {
        [i]: s.stepMode || "vertex"
      };
    }
    for (const s of n.varyings || []) {
      const a = `${s.location} ${s.name}`;
      t[`out ${a}`] = {
        [i]: JSON.stringify(s)
      };
    }
    return t;
  }
  let vt = null, Gh = null;
  function t4(n, { id: e, minimap: t, opaque: i, top: s = "0", left: a = "0", rgbaScale: l = 1 }) {
    vt || (vt = document.createElement("canvas"), vt.id = e, vt.title = e, vt.style.zIndex = "100", vt.style.position = "absolute", vt.style.top = s, vt.style.left = a, vt.style.border = "blue 5px solid", vt.style.transform = "scaleY(-1)", document.body.appendChild(vt), Gh = vt.getContext("2d")), (vt.width !== n.width || vt.height !== n.height) && (vt.width = n.width / 2, vt.height = n.height / 2, vt.style.width = "400px", vt.style.height = "400px");
    const u = n.device.readPixelsToArrayWebGL(n), h = Gh == null ? void 0 : Gh.createImageData(n.width, n.height);
    if (h) {
      for (let p = 0; p < u.length; p += 4) h.data[0 + p + 0] = u[p + 0] * l, h.data[0 + p + 1] = u[p + 1] * l, h.data[0 + p + 2] = u[p + 2] * l, h.data[0 + p + 3] = i ? 255 : u[p + 3] * l;
      Gh == null ? void 0 : Gh.putImageData(h, 0, 0);
    }
  }
  function kd(n, e, t) {
    if (n === e) return true;
    if (!t || !n || !e) return false;
    if (Array.isArray(n)) {
      if (!Array.isArray(e) || n.length !== e.length) return false;
      for (let i = 0; i < n.length; i++) if (!kd(n[i], e[i], t - 1)) return false;
      return true;
    }
    if (Array.isArray(e)) return false;
    if (typeof n == "object" && typeof e == "object") {
      const i = Object.keys(n), s = Object.keys(e);
      if (i.length !== s.length) return false;
      for (const a of i) if (!e.hasOwnProperty(a) || !kd(n[a], e[a], t - 1)) return false;
      return true;
    }
    return false;
  }
  function n4(n) {
    return ArrayBuffer.isView(n) && !(n instanceof DataView);
  }
  function i4(n) {
    return Array.isArray(n) ? n.length === 0 || typeof n[0] == "number" : false;
  }
  function B2(n) {
    return n4(n) || i4(n);
  }
  function s4(n) {
    return B2(n) || typeof n == "number" || typeof n == "boolean";
  }
  function L2(n) {
    const e = {
      bindings: {},
      uniforms: {}
    };
    return Object.keys(n).forEach((t) => {
      const i = n[t];
      s4(i) ? e.uniforms[t] = i : e.bindings[t] = i;
    }), e;
  }
  class r4 {
    constructor(e, t) {
      __publicField(this, "options", {
        disableWarnings: false
      });
      __publicField(this, "modules");
      __publicField(this, "moduleUniforms");
      __publicField(this, "moduleBindings");
      Object.assign(this.options, t);
      const i = og(Object.values(e).filter((s) => s.dependencies));
      for (const s of i) e[s.name] = s;
      J.log(1, "Creating ShaderInputs with modules", Object.keys(e))(), this.modules = e, this.moduleUniforms = {}, this.moduleBindings = {};
      for (const [s, a] of Object.entries(e)) this._addModule(a), a.name && s !== a.name && !this.options.disableWarnings && J.warn(`Module name: ${s} vs ${a.name}`)();
    }
    destroy() {
    }
    setProps(e) {
      var _a2;
      for (const t of Object.keys(e)) {
        const i = t, s = e[i] || {}, a = this.modules[i];
        if (!a) {
          this.options.disableWarnings || J.warn(`Module ${t} not found`)();
          continue;
        }
        const l = this.moduleUniforms[i], u = this.moduleBindings[i], h = ((_a2 = a.getUniforms) == null ? void 0 : _a2.call(a, s, l)) || s, { uniforms: d, bindings: p } = L2(h);
        this.moduleUniforms[i] = {
          ...l,
          ...d
        }, this.moduleBindings[i] = {
          ...u,
          ...p
        };
      }
    }
    getModules() {
      return Object.values(this.modules);
    }
    getUniformValues() {
      return this.moduleUniforms;
    }
    getBindingValues() {
      const e = {};
      for (const t of Object.values(this.moduleBindings)) Object.assign(e, t);
      return e;
    }
    getDebugTable() {
      var _a2;
      const e = {};
      for (const [t, i] of Object.entries(this.moduleUniforms)) for (const [s, a] of Object.entries(i)) e[`${t}.${s}`] = {
        type: (_a2 = this.modules[t].uniformTypes) == null ? void 0 : _a2[s],
        value: String(a)
      };
      return e;
    }
    _addModule(e) {
      const t = e.name;
      this.moduleUniforms[t] = e.defaultUniforms || {}, this.moduleBindings[t] = {};
    }
  }
  let a4 = "";
  async function o4(n, e) {
    const t = new Image();
    return t.crossOrigin = "anonymous", t.src = n.startsWith("http") ? n : a4 + n, await t.decode(), e ? await createImageBitmap(t, e) : await createImageBitmap(t);
  }
  class Jh {
    constructor(e, t) {
      __publicField(this, "device");
      __publicField(this, "id");
      __publicField(this, "texture");
      __publicField(this, "sampler");
      __publicField(this, "view");
      __publicField(this, "ready");
      __publicField(this, "isReady", false);
      __publicField(this, "destroyed", false);
      __publicField(this, "resolveReady", () => {
      });
      __publicField(this, "rejectReady", () => {
      });
      this.device = e, this.id = t.id || Jc("async-texture"), typeof (t == null ? void 0 : t.data) == "string" && t.dimension === "2d" && (t = {
        ...t,
        data: o4(t.data)
      }), this.ready = new Promise((i, s) => {
        this.resolveReady = () => {
          this.isReady = true, i();
        }, this.rejectReady = s;
      }), this.initAsync(t);
    }
    get [Symbol.toStringTag]() {
      return "AsyncTexture";
    }
    toString() {
      return `AsyncTexture:"${this.id}"(${this.isReady ? "ready" : "loading"})`;
    }
    async initAsync(e) {
      const t = e.data;
      let i;
      try {
        i = await F2(t);
      } catch (a) {
        this.rejectReady(a);
      }
      if (this.destroyed) return;
      const s = {
        ...e,
        data: i
      };
      this.texture = this.device.createTexture(s), this.sampler = this.texture.sampler, this.view = this.texture.view, this.isReady = true, this.resolveReady();
    }
    destroy() {
      this.texture && (this.texture.destroy(), this.texture = null), this.destroyed = true;
    }
    resize(e) {
      if (!this.isReady) throw new Error("Cannot resize texture before it is ready");
      if (e.width === this.texture.width && e.height === this.texture.height) return false;
      if (this.texture) {
        const t = this.texture;
        this.texture = t.clone(e), t.destroy();
      }
      return true;
    }
  }
  async function F2(n) {
    if (n = await n, Array.isArray(n)) return await Promise.all(n.map(F2));
    if (n && typeof n == "object" && n.constructor === Object) {
      const e = n, t = await Promise.all(Object.values(e)), i = Object.keys(e), s = {};
      for (let a = 0; a < i.length; a++) s[i[a]] = t[a];
      return s;
    }
    return n;
  }
  const ps = 2, l4 = 1e4;
  const _Vn = class _Vn {
    constructor(e, t) {
      __publicField(this, "device");
      __publicField(this, "id");
      __publicField(this, "source");
      __publicField(this, "vs");
      __publicField(this, "fs");
      __publicField(this, "pipelineFactory");
      __publicField(this, "shaderFactory");
      __publicField(this, "userData", {});
      __publicField(this, "parameters");
      __publicField(this, "topology");
      __publicField(this, "bufferLayout");
      __publicField(this, "isInstanced");
      __publicField(this, "instanceCount", 0);
      __publicField(this, "vertexCount");
      __publicField(this, "indexBuffer", null);
      __publicField(this, "bufferAttributes", {});
      __publicField(this, "constantAttributes", {});
      __publicField(this, "bindings", {});
      __publicField(this, "uniforms", {});
      __publicField(this, "vertexArray");
      __publicField(this, "transformFeedback", null);
      __publicField(this, "pipeline");
      __publicField(this, "shaderInputs");
      __publicField(this, "_uniformStore");
      __publicField(this, "_attributeInfos", {});
      __publicField(this, "_gpuGeometry", null);
      __publicField(this, "_getModuleUniforms");
      __publicField(this, "props");
      __publicField(this, "_pipelineNeedsUpdate", "newly created");
      __publicField(this, "_needsRedraw", "initializing");
      __publicField(this, "_destroyed", false);
      __publicField(this, "_lastDrawTimestamp", -1);
      __publicField(this, "_lastLogTime", 0);
      __publicField(this, "_logOpen", false);
      __publicField(this, "_drawCount", 0);
      var _a2, _b3, _c2, _d2;
      this.props = {
        ..._Vn.defaultProps,
        ...t
      }, t = this.props, this.id = t.id || Jc("model"), this.device = e, Object.assign(this.userData, t.userData);
      const i = Object.fromEntries(((_a2 = this.props.modules) == null ? void 0 : _a2.map((h) => [
        h.name,
        h
      ])) || []), s = t.shaderInputs || new r4(i, {
        disableWarnings: this.props.disableWarnings
      });
      this.setShaderInputs(s);
      const a = u4(e), l = (((_b3 = this.props.modules) == null ? void 0 : _b3.length) > 0 ? this.props.modules : (_c2 = this.shaderInputs) == null ? void 0 : _c2.getModules()) || [];
      if (this.device.type === "webgpu" && this.props.source) {
        const { source: h, getUniforms: d } = this.props.shaderAssembler.assembleWGSLShader({
          platformInfo: a,
          ...this.props,
          modules: l
        });
        this.source = h, this._getModuleUniforms = d, (_d2 = this.props).shaderLayout || (_d2.shaderLayout = mC(this.source));
      } else {
        const { vs: h, fs: d, getUniforms: p } = this.props.shaderAssembler.assembleGLSLShaderPair({
          platformInfo: a,
          ...this.props,
          modules: l
        });
        this.vs = h, this.fs = d, this._getModuleUniforms = p;
      }
      this.vertexCount = this.props.vertexCount, this.instanceCount = this.props.instanceCount, this.topology = this.props.topology, this.bufferLayout = this.props.bufferLayout, this.parameters = this.props.parameters, t.geometry && this.setGeometry(t.geometry), this.pipelineFactory = t.pipelineFactory || Og.getDefaultPipelineFactory(this.device), this.shaderFactory = t.shaderFactory || Ig.getDefaultShaderFactory(this.device), this.pipeline = this._updatePipeline(), this.vertexArray = e.createVertexArray({
        renderPipeline: this.pipeline
      }), this._gpuGeometry && this._setGeometryAttributes(this._gpuGeometry), "isInstanced" in t && (this.isInstanced = t.isInstanced), t.instanceCount && this.setInstanceCount(t.instanceCount), t.vertexCount && this.setVertexCount(t.vertexCount), t.indexBuffer && this.setIndexBuffer(t.indexBuffer), t.attributes && this.setAttributes(t.attributes), t.constantAttributes && this.setConstantAttributes(t.constantAttributes), t.bindings && this.setBindings(t.bindings), t.uniforms && this.setUniformsWebGL(t.uniforms), t.moduleSettings && this.updateModuleSettingsWebGL(t.moduleSettings), t.transformFeedback && (this.transformFeedback = t.transformFeedback), Object.seal(this);
    }
    get [Symbol.toStringTag]() {
      return "Model";
    }
    toString() {
      return `Model(${this.id})`;
    }
    destroy() {
      var _a2;
      this._destroyed || (this.pipelineFactory.release(this.pipeline), this.shaderFactory.release(this.pipeline.vs), this.pipeline.fs && this.shaderFactory.release(this.pipeline.fs), this._uniformStore.destroy(), (_a2 = this._gpuGeometry) == null ? void 0 : _a2.destroy(), this._destroyed = true);
    }
    needsRedraw() {
      this._getBindingsUpdateTimestamp() > this._lastDrawTimestamp && this.setNeedsRedraw("contents of bound textures or buffers updated");
      const e = this._needsRedraw;
      return this._needsRedraw = false, e;
    }
    setNeedsRedraw(e) {
      this._needsRedraw || (this._needsRedraw = e);
    }
    predraw() {
      this.updateShaderInputs(), this.pipeline = this._updatePipeline();
    }
    draw(e) {
      const t = this._areBindingsLoading();
      if (t) return J.info(ps, `>>> DRAWING ABORTED ${this.id}: ${t} not loaded`)(), false;
      try {
        e.pushDebugGroup(`${this}.predraw(${e})`), this.predraw();
      } finally {
        e.popDebugGroup();
      }
      let i;
      try {
        e.pushDebugGroup(`${this}.draw(${e})`), this._logDrawCallStart(), this.pipeline = this._updatePipeline();
        const s = this._getBindings();
        this.pipeline.setBindings(s, {
          disableWarnings: this.props.disableWarnings
        }), Ud(this.uniforms) || this.pipeline.setUniformsWebGL(this.uniforms);
        const { indexBuffer: a } = this.vertexArray, l = a ? a.byteLength / (a.indexType === "uint32" ? 4 : 2) : void 0;
        i = this.pipeline.draw({
          renderPass: e,
          vertexArray: this.vertexArray,
          isInstanced: this.isInstanced,
          vertexCount: this.vertexCount,
          instanceCount: this.instanceCount,
          indexCount: l,
          transformFeedback: this.transformFeedback || void 0,
          parameters: this.parameters,
          topology: this.topology
        });
      } finally {
        e.popDebugGroup(), this._logDrawCallEnd();
      }
      return this._logFramebuffer(e), i ? (this._lastDrawTimestamp = this.device.timestamp, this._needsRedraw = false) : this._needsRedraw = "waiting for resource initialization", i;
    }
    setGeometry(e) {
      var _a2;
      (_a2 = this._gpuGeometry) == null ? void 0 : _a2.destroy();
      const t = e && QI(this.device, e);
      if (t) {
        this.setTopology(t.topology || "triangle-list");
        const i = new Bh(this.bufferLayout);
        this.bufferLayout = i.mergeBufferLayouts(t.bufferLayout, this.bufferLayout), this.vertexArray && this._setGeometryAttributes(t);
      }
      this._gpuGeometry = t;
    }
    setTopology(e) {
      e !== this.topology && (this.topology = e, this._setPipelineNeedsUpdate("topology"));
    }
    setBufferLayout(e) {
      const t = new Bh(this.bufferLayout);
      this.bufferLayout = this._gpuGeometry ? t.mergeBufferLayouts(e, this._gpuGeometry.bufferLayout) : e, this._setPipelineNeedsUpdate("bufferLayout"), this.pipeline = this._updatePipeline(), this.vertexArray = this.device.createVertexArray({
        renderPipeline: this.pipeline
      }), this._gpuGeometry && this._setGeometryAttributes(this._gpuGeometry);
    }
    setParameters(e) {
      kd(e, this.parameters, 2) || (this.parameters = e, this._setPipelineNeedsUpdate("parameters"));
    }
    setInstanceCount(e) {
      this.instanceCount = e, this.isInstanced === void 0 && e > 0 && (this.isInstanced = true), this.setNeedsRedraw("instanceCount");
    }
    setVertexCount(e) {
      this.vertexCount = e, this.setNeedsRedraw("vertexCount");
    }
    setShaderInputs(e) {
      this.shaderInputs = e, this._uniformStore = new FR(this.shaderInputs.modules);
      for (const [t, i] of Object.entries(this.shaderInputs.modules)) if (c4(i)) {
        const s = this._uniformStore.getManagedUniformBuffer(this.device, t);
        this.bindings[`${t}Uniforms`] = s;
      }
      this.setNeedsRedraw("shaderInputs");
    }
    updateShaderInputs() {
      this._uniformStore.setUniforms(this.shaderInputs.getUniformValues()), this.setBindings(this.shaderInputs.getBindingValues()), this.setNeedsRedraw("shaderInputs");
    }
    setBindings(e) {
      Object.assign(this.bindings, e), this.setNeedsRedraw("bindings");
    }
    setTransformFeedback(e) {
      this.transformFeedback = e, this.setNeedsRedraw("transformFeedback");
    }
    setIndexBuffer(e) {
      this.vertexArray.setIndexBuffer(e), this.setNeedsRedraw("indexBuffer");
    }
    setAttributes(e, t) {
      const i = (t == null ? void 0 : t.disableWarnings) ?? this.props.disableWarnings;
      e.indices && J.warn(`Model:${this.id} setAttributes() - indexBuffer should be set using setIndexBuffer()`)(), this.bufferLayout = zR(this.pipeline.shaderLayout, this.bufferLayout);
      const s = new Bh(this.bufferLayout);
      for (const [a, l] of Object.entries(e)) {
        const u = s.getBufferLayout(a);
        if (!u) {
          i || J.warn(`Model(${this.id}): Missing layout for buffer "${a}".`)();
          continue;
        }
        const h = s.getAttributeNamesForBuffer(u);
        let d = false;
        for (const p of h) {
          const _ = this._attributeInfos[p];
          if (_) {
            const y = this.device.type === "webgpu" ? s.getBufferIndex(_.bufferName) : _.location;
            this.vertexArray.setBuffer(y, l), d = true;
          }
        }
        !d && !i && J.warn(`Model(${this.id}): Ignoring buffer "${l.id}" for unknown attribute "${a}"`)();
      }
      this.setNeedsRedraw("attributes");
    }
    setConstantAttributes(e, t) {
      for (const [i, s] of Object.entries(e)) {
        const a = this._attributeInfos[i];
        a ? this.vertexArray.setConstantWebGL(a.location, s) : ((t == null ? void 0 : t.disableWarnings) ?? this.props.disableWarnings) || J.warn(`Model "${this.id}: Ignoring constant supplied for unknown attribute "${i}"`)();
      }
      this.setNeedsRedraw("constants");
    }
    setUniforms(e) {
      this.setUniformsWebGL(e);
    }
    setUniformsWebGL(e) {
      Ud(e) || (this.pipeline.setUniformsWebGL(e), Object.assign(this.uniforms, e)), this.setNeedsRedraw("uniforms");
    }
    updateModuleSettingsWebGL(e) {
      const { bindings: t, uniforms: i } = L2(this._getModuleUniforms(e));
      Object.assign(this.bindings, t), Object.assign(this.uniforms, i), this.setNeedsRedraw("moduleSettings");
    }
    _areBindingsLoading() {
      for (const e of Object.values(this.bindings)) if (e instanceof Jh && !e.isReady) return e.id;
      return false;
    }
    _getBindings() {
      const e = {};
      for (const [t, i] of Object.entries(this.bindings)) i instanceof Jh ? i.isReady && (e[t] = i.texture) : e[t] = i;
      return e;
    }
    _getBindingsUpdateTimestamp() {
      let e = 0;
      for (const t of Object.values(this.bindings)) t instanceof Kc ? e = Math.max(e, t.texture.updateTimestamp) : t instanceof Ke || t instanceof $e ? e = Math.max(e, t.updateTimestamp) : t instanceof Jh ? e = t.texture ? Math.max(e, t.texture.updateTimestamp) : 1 / 0 : t instanceof po || (e = Math.max(e, t.buffer.updateTimestamp));
      return e;
    }
    _setGeometryAttributes(e) {
      const t = {
        ...e.attributes
      };
      for (const [i] of Object.entries(t)) !this.pipeline.shaderLayout.attributes.find((s) => s.name === i) && i !== "positions" && delete t[i];
      this.vertexCount = e.vertexCount, this.setIndexBuffer(e.indices || null), this.setAttributes(e.attributes, {
        disableWarnings: true
      }), this.setAttributes(t, {
        disableWarnings: this.props.disableWarnings
      }), this.setNeedsRedraw("geometry attributes");
    }
    _setPipelineNeedsUpdate(e) {
      this._pipelineNeedsUpdate || (this._pipelineNeedsUpdate = e), this.setNeedsRedraw(e);
    }
    _updatePipeline() {
      if (this._pipelineNeedsUpdate) {
        let e = null, t = null;
        this.pipeline && (J.log(1, `Model ${this.id}: Recreating pipeline because "${this._pipelineNeedsUpdate}".`)(), e = this.pipeline.vs, t = this.pipeline.fs), this._pipelineNeedsUpdate = false;
        const i = this.shaderFactory.createShader({
          id: `${this.id}-vertex`,
          stage: "vertex",
          source: this.source || this.vs,
          debugShaders: this.props.debugShaders
        });
        let s = null;
        this.source ? s = i : this.fs && (s = this.shaderFactory.createShader({
          id: `${this.id}-fragment`,
          stage: "fragment",
          source: this.source || this.fs,
          debugShaders: this.props.debugShaders
        })), this.pipeline = this.pipelineFactory.createRenderPipeline({
          ...this.props,
          bufferLayout: this.bufferLayout,
          topology: this.topology,
          parameters: this.parameters,
          bindings: this._getBindings(),
          vs: i,
          fs: s
        }), this._attributeInfos = I3(this.pipeline.shaderLayout, this.bufferLayout), e && this.shaderFactory.release(e), t && this.shaderFactory.release(t);
      }
      return this.pipeline;
    }
    _logDrawCallStart() {
      const e = J.level > 3 ? 0 : l4;
      J.level < 2 || Date.now() - this._lastLogTime < e || (this._lastLogTime = Date.now(), this._logOpen = true, J.group(ps, `>>> DRAWING MODEL ${this.id}`, {
        collapsed: J.level <= 2
      })());
    }
    _logDrawCallEnd() {
      if (this._logOpen) {
        const e = e4(this.pipeline.shaderLayout, this.id);
        J.table(ps, e)();
        const t = this.shaderInputs.getDebugTable();
        for (const [s, a] of Object.entries(this.uniforms)) t[s] = {
          value: a
        };
        J.table(ps, t)();
        const i = this._getAttributeDebugTable();
        J.table(ps, this._attributeInfos)(), J.table(ps, i)(), J.groupEnd(ps)(), this._logOpen = false;
      }
    }
    _logFramebuffer(e) {
      const t = this.device.props.debugFramebuffers;
      if (this._drawCount++, !t) return;
      const i = e.props.framebuffer;
      i && t4(i, {
        id: i.id,
        minimap: true
      });
    }
    _getAttributeDebugTable() {
      const e = {};
      for (const [t, i] of Object.entries(this._attributeInfos)) {
        const s = this.vertexArray.attributes[i.location];
        e[i.location] = {
          name: t,
          type: i.shaderType,
          values: s ? this._getBufferOrConstantValues(s, i.bufferDataType) : "null"
        };
      }
      if (this.vertexArray.indexBuffer) {
        const { indexBuffer: t } = this.vertexArray, i = t.indexType === "uint32" ? new Uint32Array(t.debugData) : new Uint16Array(t.debugData);
        e.indices = {
          name: "indices",
          type: t.indexType,
          values: i.toString()
        };
      }
      return e;
    }
    _getBufferOrConstantValues(e, t) {
      const i = D3(t);
      return (e instanceof Ke ? new i(e.debugData) : e).toString();
    }
  };
  __publicField(_Vn, "defaultProps", {
    ...Vr.defaultProps,
    source: void 0,
    vs: null,
    fs: null,
    id: "unnamed",
    handle: void 0,
    userData: {},
    defines: {},
    modules: [],
    moduleSettings: void 0,
    geometry: null,
    indexBuffer: null,
    attributes: {},
    constantAttributes: {},
    varyings: [],
    isInstanced: void 0,
    instanceCount: 0,
    vertexCount: 0,
    shaderInputs: void 0,
    pipelineFactory: void 0,
    shaderFactory: void 0,
    transformFeedback: void 0,
    shaderAssembler: ys.getDefaultShaderAssembler(),
    debugShaders: void 0,
    disableWarnings: void 0
  });
  let Vn = _Vn;
  function c4(n) {
    return !!(n.uniformTypes && !Ud(n.uniformTypes));
  }
  function u4(n) {
    return {
      type: n.type,
      shaderLanguage: n.info.shadingLanguage,
      shaderLanguageVersion: n.info.shadingLanguageVersion,
      gpu: n.info.gpu,
      features: n.features
    };
  }
  function Ud(n) {
    for (const e in n) return false;
    return true;
  }
  const _Cs = class _Cs {
    constructor(e, t = _Cs.defaultProps) {
      __publicField(this, "device");
      __publicField(this, "model");
      __publicField(this, "transformFeedback");
      if (!_Cs.isSupported(e)) throw new Error("BufferTransform not yet implemented on WebGPU");
      this.device = e, this.model = new Vn(this.device, {
        id: t.id || "buffer-transform-model",
        fs: t.fs || S3(),
        topology: t.topology || "point-list",
        varyings: t.outputs || t.varyings,
        ...t
      }), this.transformFeedback = this.device.createTransformFeedback({
        layout: this.model.pipeline.shaderLayout,
        buffers: t.feedbackBuffers
      }), this.model.setTransformFeedback(this.transformFeedback), Object.seal(this);
    }
    static isSupported(e) {
      var _a2;
      return ((_a2 = e == null ? void 0 : e.info) == null ? void 0 : _a2.type) === "webgl";
    }
    destroy() {
      this.model && this.model.destroy();
    }
    delete() {
      this.destroy();
    }
    run(e) {
      (e == null ? void 0 : e.inputBuffers) && this.model.setAttributes(e.inputBuffers), (e == null ? void 0 : e.outputBuffers) && this.transformFeedback.setBuffers(e.outputBuffers);
      const t = this.device.beginRenderPass(e);
      this.model.draw(t), t.end();
    }
    getBuffer(e) {
      return this.transformFeedback.getBuffer(e);
    }
    readAsync(e) {
      const t = this.getBuffer(e);
      if (!t) throw new Error("BufferTransform#getBuffer");
      if (t instanceof Ke) return t.readAsync();
      const { buffer: i, byteOffset: s = 0, byteLength: a = i.byteLength } = t;
      return i.readAsync(s, a);
    }
  };
  __publicField(_Cs, "defaultProps", {
    ...Vn.defaultProps,
    outputs: void 0,
    feedbackBuffers: void 0
  });
  let Cs = _Cs;
  const f4 = "transform_output";
  class I0 {
    constructor(e, t) {
      __publicField(this, "device");
      __publicField(this, "model");
      __publicField(this, "sampler");
      __publicField(this, "currentIndex", 0);
      __publicField(this, "samplerTextureMap", null);
      __publicField(this, "bindings", []);
      __publicField(this, "resources", {});
      this.device = e, this.sampler = e.createSampler({
        addressModeU: "clamp-to-edge",
        addressModeV: "clamp-to-edge",
        minFilter: "nearest",
        magFilter: "nearest",
        mipmapFilter: "nearest"
      }), this.model = new Vn(this.device, {
        id: t.id || "texture-transform-model",
        fs: t.fs || S3({
          input: t.targetTextureVarying,
          inputChannels: t.targetTextureChannels,
          output: f4
        }),
        vertexCount: t.vertexCount,
        ...t
      }), this._initialize(t), Object.seal(this);
    }
    destroy() {
      var _a2;
      this.model.destroy();
      for (const e of this.bindings) (_a2 = e.framebuffer) == null ? void 0 : _a2.destroy();
    }
    delete() {
      this.destroy();
    }
    run(e) {
      const { framebuffer: t } = this.bindings[this.currentIndex], i = this.device.beginRenderPass({
        framebuffer: t,
        ...e
      });
      this.model.draw(i), i.end();
    }
    getTargetTexture() {
      const { targetTexture: e } = this.bindings[this.currentIndex];
      return e;
    }
    getFramebuffer() {
      return this.bindings[this.currentIndex].framebuffer;
    }
    _initialize(e) {
      this._updateBindings(e);
    }
    _updateBindings(e) {
      this.bindings[this.currentIndex] = this._updateBinding(this.bindings[this.currentIndex], e);
    }
    _updateBinding(e, { sourceBuffers: t, sourceTextures: i, targetTexture: s }) {
      if (e || (e = {
        sourceBuffers: {},
        sourceTextures: {},
        targetTexture: null
      }), Object.assign(e.sourceTextures, i), Object.assign(e.sourceBuffers, t), s) {
        e.targetTexture = s;
        const { width: a, height: l } = s;
        e.framebuffer && e.framebuffer.destroy(), e.framebuffer = this.device.createFramebuffer({
          id: "transform-framebuffer",
          width: a,
          height: l,
          colorAttachments: [
            s
          ]
        }), e.framebuffer.resize({
          width: a,
          height: l
        });
      }
      return e;
    }
    _setSourceTextureParameters() {
      const e = this.currentIndex, { sourceTextures: t } = this.bindings[e];
      for (const i in t) t[i].sampler = this.sampler;
    }
  }
  class V2 {
    constructor(e) {
      __publicField(this, "id");
      __publicField(this, "topology");
      __publicField(this, "vertexCount");
      __publicField(this, "indices");
      __publicField(this, "attributes");
      __publicField(this, "userData", {});
      const { attributes: t = {}, indices: i = null, vertexCount: s = null } = e;
      this.id = e.id || Jc("geometry"), this.topology = e.topology, i && (this.indices = ArrayBuffer.isView(i) ? {
        value: i,
        size: 1
      } : i), this.attributes = {};
      for (const [a, l] of Object.entries(t)) {
        const u = ArrayBuffer.isView(l) ? {
          value: l
        } : l;
        if (!ArrayBuffer.isView(u.value)) throw new Error(`${this._print(a)}: must be typed array or object with value as typed array`);
        if ((a === "POSITION" || a === "positions") && !u.size && (u.size = 3), a === "indices") {
          if (this.indices) throw new Error("Multiple indices detected");
          this.indices = u;
        } else this.attributes[a] = u;
      }
      this.indices && this.indices.isIndexed !== void 0 && (this.indices = Object.assign({}, this.indices), delete this.indices.isIndexed), this.vertexCount = s || this._calculateVertexCount(this.attributes, this.indices);
    }
    getVertexCount() {
      return this.vertexCount;
    }
    getAttributes() {
      return this.indices ? {
        indices: this.indices,
        ...this.attributes
      } : this.attributes;
    }
    _print(e) {
      return `Geometry ${this.id} attribute ${e}`;
    }
    _setAttributes(e, t) {
      return this;
    }
    _calculateVertexCount(e, t) {
      if (t) return t.value.length;
      let i = 1 / 0;
      for (const s of Object.values(e)) {
        const { value: a, size: l, constant: u } = s;
        !u && a && l !== void 0 && l >= 1 && (i = Math.min(i, a.length / l));
      }
      return i;
    }
  }
  const h4 = {
    blendColorOperation: "add",
    blendColorSrcFactor: "one",
    blendColorDstFactor: "zero",
    blendAlphaOperation: "add",
    blendAlphaSrcFactor: "constant-alpha",
    blendAlphaDstFactor: "zero"
  };
  class z2 extends Rg {
    constructor() {
      super(...arguments), this._colorEncoderState = null;
    }
    render(e) {
      return "pickingFBO" in e ? this._drawPickingBuffer(e) : super.render(e);
    }
    _drawPickingBuffer({ layers: e, layerFilter: t, views: i, viewports: s, onViewportActive: a, pickingFBO: l, deviceRect: { x: u, y: h, width: d, height: p }, cullRect: _, effects: y, pass: v = "picking", pickZ: S, shaderModuleProps: E }) {
      this.pickZ = S;
      const M = this._resetColorEncoder(S), F = [
        u,
        h,
        d,
        p
      ], H = super.render({
        target: l,
        layers: e,
        layerFilter: t,
        views: i,
        viewports: s,
        onViewportActive: a,
        cullRect: _,
        effects: y == null ? void 0 : y.filter((U) => U.useInPicking),
        pass: v,
        isPicking: true,
        shaderModuleProps: E,
        clearColor: [
          0,
          0,
          0,
          0
        ],
        colorMask: 15,
        scissorRect: F
      });
      return this._colorEncoderState = null, {
        decodePickingColor: M && g4.bind(null, M),
        stats: H
      };
    }
    shouldDrawLayer(e) {
      const { pickable: t, operation: i } = e.props;
      return t && i.includes("draw") || i.includes("terrain") || i.includes("mask");
    }
    getShaderModuleProps(e, t, i) {
      return {
        picking: {
          isActive: 1,
          isAttribute: this.pickZ
        },
        lighting: {
          enabled: false
        }
      };
    }
    getLayerParameters(e, t, i) {
      const s = {
        ...e.props.parameters
      }, { pickable: a, operation: l } = e.props;
      return !this._colorEncoderState || l.includes("terrain") ? s.blend = false : a && l.includes("draw") && (Object.assign(s, h4), s.blend = true, s.blendColor = d4(this._colorEncoderState, e, i)), s;
    }
    _resetColorEncoder(e) {
      return this._colorEncoderState = e ? null : {
        byLayer: /* @__PURE__ */ new Map(),
        byAlpha: []
      }, this._colorEncoderState;
    }
  }
  function d4(n, e, t) {
    const { byLayer: i, byAlpha: s } = n;
    let a, l = i.get(e);
    return l ? (l.viewports.push(t), a = l.a) : (a = i.size + 1, a <= 255 ? (l = {
      a,
      layer: e,
      viewports: [
        t
      ]
    }, i.set(e, l), s[a] = l) : (Le.warn("Too many pickable layers, only picking the first 255")(), a = 0)), [
      0,
      0,
      0,
      a / 255
    ];
  }
  function g4(n, e) {
    const t = n.byAlpha[e[3]];
    return t && {
      pickedLayer: t.layer,
      pickedViewports: t.viewports,
      pickedObjectIndex: t.layer.decodePickingColor(e)
    };
  }
  const Rr = {
    NO_STATE: "Awaiting state",
    MATCHED: "Matched. State transferred from previous layer",
    INITIALIZED: "Initialized",
    AWAITING_GC: "Discarded. Awaiting garbage collection",
    AWAITING_FINALIZATION: "No longer matched. Awaiting garbage collection",
    FINALIZED: "Finalized! Awaiting garbage collection"
  }, Pc = Symbol.for("component"), Xi = Symbol.for("propTypes"), ed = Symbol.for("deprecatedProps"), Br = Symbol.for("asyncPropDefaults"), Ms = Symbol.for("asyncPropOriginal"), ji = Symbol.for("asyncPropResolved");
  function Ng(n, e = () => true) {
    return Array.isArray(n) ? H2(n, e, []) : e(n) ? [
      n
    ] : [];
  }
  function H2(n, e, t) {
    let i = -1;
    for (; ++i < n.length; ) {
      const s = n[i];
      Array.isArray(s) ? H2(s, e, t) : e(s) && t.push(s);
    }
    return t;
  }
  function p4({ target: n, source: e, start: t = 0, count: i = 1 }) {
    const s = e.length, a = i * s;
    let l = 0;
    for (let u = t; l < s; l++) n[u++] = e[l];
    for (; l < a; ) l < a - l ? (n.copyWithin(t + l, t, t + l), l *= 2) : (n.copyWithin(t + l, t, t + a - l), l = a);
    return n;
  }
  class m4 {
    constructor(e, t, i) {
      this._loadCount = 0, this._subscribers = /* @__PURE__ */ new Set(), this.id = e, this.context = i, this.setData(t);
    }
    subscribe(e) {
      this._subscribers.add(e);
    }
    unsubscribe(e) {
      this._subscribers.delete(e);
    }
    inUse() {
      return this._subscribers.size > 0;
    }
    delete() {
    }
    getData() {
      return this.isLoaded ? this._error ? Promise.reject(this._error) : this._content : this._loader.then(() => this.getData());
    }
    setData(e, t) {
      if (e === this._data && !t) return;
      this._data = e;
      const i = ++this._loadCount;
      let s = e;
      typeof e == "string" && (s = pd(e)), s instanceof Promise ? (this.isLoaded = false, this._loader = s.then((a) => {
        this._loadCount === i && (this.isLoaded = true, this._error = void 0, this._content = a);
      }).catch((a) => {
        this._loadCount === i && (this.isLoaded = true, this._error = a || true);
      })) : (this.isLoaded = true, this._error = void 0, this._content = e);
      for (const a of this._subscribers) a.onChange(this.getData());
    }
  }
  class _4 {
    constructor(e) {
      var _a2;
      this.protocol = e.protocol || "resource://", this._context = {
        device: e.device,
        gl: (_a2 = e.device) == null ? void 0 : _a2.gl,
        resourceManager: this
      }, this._resources = {}, this._consumers = {}, this._pruneRequest = null;
    }
    contains(e) {
      return e.startsWith(this.protocol) ? true : e in this._resources;
    }
    add({ resourceId: e, data: t, forceUpdate: i = false, persistent: s = true }) {
      let a = this._resources[e];
      a ? a.setData(t, i) : (a = new m4(e, t, this._context), this._resources[e] = a), a.persistent = s;
    }
    remove(e) {
      const t = this._resources[e];
      t && (t.delete(), delete this._resources[e]);
    }
    unsubscribe({ consumerId: e }) {
      const t = this._consumers[e];
      if (t) {
        for (const i in t) {
          const s = t[i], a = this._resources[s.resourceId];
          a && a.unsubscribe(s);
        }
        delete this._consumers[e], this.prune();
      }
    }
    subscribe({ resourceId: e, onChange: t, consumerId: i, requestId: s = "default" }) {
      const { _resources: a, protocol: l } = this;
      e.startsWith(l) && (e = e.replace(l, ""), a[e] || this.add({
        resourceId: e,
        data: null,
        persistent: false
      }));
      const u = a[e];
      if (this._track(i, s, u, t), u) return u.getData();
    }
    prune() {
      this._pruneRequest || (this._pruneRequest = setTimeout(() => this._prune(), 0));
    }
    finalize() {
      for (const e in this._resources) this._resources[e].delete();
    }
    _track(e, t, i, s) {
      const a = this._consumers, l = a[e] = a[e] || {};
      let u = l[t];
      const h = u && u.resourceId && this._resources[u.resourceId];
      h && (h.unsubscribe(u), this.prune()), i && (u ? (u.onChange = s, u.resourceId = i.id) : u = {
        onChange: s,
        resourceId: i.id
      }, l[t] = u, i.subscribe(u));
    }
    _prune() {
      this._pruneRequest = null;
      for (const e of Object.keys(this._resources)) {
        const t = this._resources[e];
        !t.persistent && !t.inUse() && (t.delete(), delete this._resources[e]);
      }
    }
  }
  const y4 = "layerManager.setLayers", b4 = "layerManager.activateViewport";
  class v4 {
    constructor(e, t) {
      var _a2;
      this._lastRenderedLayers = [], this._needsRedraw = false, this._needsUpdate = false, this._nextLayers = null, this._debug = false, this._defaultShaderModulesChanged = false, this.activateViewport = (u) => {
        Ot(b4, this, u), u && (this.context.viewport = u);
      };
      const { deck: i, stats: s, viewport: a, timeline: l } = t || {};
      this.layers = [], this.resourceManager = new _4({
        device: e,
        protocol: "deck://"
      }), this.context = {
        mousePosition: null,
        userData: {},
        layerManager: this,
        device: e,
        gl: e == null ? void 0 : e.gl,
        deck: i,
        shaderAssembler: pI(((_a2 = e == null ? void 0 : e.info) == null ? void 0 : _a2.shadingLanguage) || "glsl"),
        defaultShaderModules: [
          wM
        ],
        renderPass: void 0,
        stats: s || new Xc({
          id: "deck.gl"
        }),
        viewport: a || new Zr({
          id: "DEFAULT-INITIAL-VIEWPORT"
        }),
        timeline: l || new U2(),
        resourceManager: this.resourceManager,
        onError: void 0
      }, Object.seal(this);
    }
    finalize() {
      this.resourceManager.finalize();
      for (const e of this.layers) this._finalizeLayer(e);
    }
    needsRedraw(e = {
      clearRedrawFlags: false
    }) {
      let t = this._needsRedraw;
      e.clearRedrawFlags && (this._needsRedraw = false);
      for (const i of this.layers) {
        const s = i.getNeedsRedraw(e);
        t = t || s;
      }
      return t;
    }
    needsUpdate() {
      return this._nextLayers && this._nextLayers !== this._lastRenderedLayers ? "layers changed" : this._defaultShaderModulesChanged ? "shader modules changed" : this._needsUpdate;
    }
    setNeedsRedraw(e) {
      this._needsRedraw = this._needsRedraw || e;
    }
    setNeedsUpdate(e) {
      this._needsUpdate = this._needsUpdate || e;
    }
    getLayers({ layerIds: e } = {}) {
      return e ? this.layers.filter((t) => e.find((i) => t.id.indexOf(i) === 0)) : this.layers;
    }
    setProps(e) {
      "debug" in e && (this._debug = e.debug), "userData" in e && (this.context.userData = e.userData), "layers" in e && (this._nextLayers = e.layers), "onError" in e && (this.context.onError = e.onError);
    }
    setLayers(e, t) {
      Ot(y4, this, t, e), this._lastRenderedLayers = e;
      const i = Ng(e, Boolean);
      for (const s of i) s.context = this.context;
      this._updateLayers(this.layers, i);
    }
    updateLayers() {
      const e = this.needsUpdate();
      e && (this.setNeedsRedraw(`updating layers: ${e}`), this.setLayers(this._nextLayers || this._lastRenderedLayers, e)), this._nextLayers = null;
    }
    addDefaultShaderModule(e) {
      const { defaultShaderModules: t } = this.context;
      t.find((i) => i.name === e.name) || (t.push(e), this._defaultShaderModulesChanged = true);
    }
    removeDefaultShaderModule(e) {
      const { defaultShaderModules: t } = this.context, i = t.findIndex((s) => s.name === e.name);
      i >= 0 && (t.splice(i, 1), this._defaultShaderModulesChanged = true);
    }
    _handleError(e, t, i) {
      i.raiseError(t, `${e} of ${i}`);
    }
    _updateLayers(e, t) {
      const i = {};
      for (const l of e) i[l.id] ? Le.warn(`Multiple old layers with same id ${l.id}`)() : i[l.id] = l;
      if (this._defaultShaderModulesChanged) {
        for (const l of e) l.setNeedsUpdate(), l.setChangeFlags({
          extensionsChanged: true
        });
        this._defaultShaderModulesChanged = false;
      }
      const s = [];
      this._updateSublayersRecursively(t, i, s), this._finalizeOldLayers(i);
      let a = false;
      for (const l of s) if (l.hasUniformTransition()) {
        a = `Uniform transition in ${l}`;
        break;
      }
      this._needsUpdate = a, this.layers = s;
    }
    _updateSublayersRecursively(e, t, i) {
      for (const s of e) {
        s.context = this.context;
        const a = t[s.id];
        a === null && Le.warn(`Multiple new layers with same id ${s.id}`)(), t[s.id] = null;
        let l = null;
        try {
          this._debug && a !== s && s.validateProps(), a ? (this._transferLayerState(a, s), this._updateLayer(s)) : this._initializeLayer(s), i.push(s), l = s.isComposite ? s.getSubLayers() : null;
        } catch (u) {
          this._handleError("matching", u, s);
        }
        l && this._updateSublayersRecursively(l, t, i);
      }
    }
    _finalizeOldLayers(e) {
      for (const t in e) {
        const i = e[t];
        i && this._finalizeLayer(i);
      }
    }
    _initializeLayer(e) {
      try {
        e._initialize(), e.lifecycle = Rr.INITIALIZED;
      } catch (t) {
        this._handleError("initialization", t, e);
      }
    }
    _transferLayerState(e, t) {
      t._transferState(e), t.lifecycle = Rr.MATCHED, t !== e && (e.lifecycle = Rr.AWAITING_GC);
    }
    _updateLayer(e) {
      try {
        e._update();
      } catch (t) {
        this._handleError("update", t, e);
      }
    }
    _finalizeLayer(e) {
      this._needsRedraw = this._needsRedraw || `finalized ${e}`, e.lifecycle = Rr.AWAITING_FINALIZATION;
      try {
        e._finalize(), e.lifecycle = Rr.FINALIZED;
      } catch (t) {
        this._handleError("finalization", t, e);
      }
    }
  }
  function Ft(n, e, t) {
    if (n === e) return true;
    if (!t || !n || !e) return false;
    if (Array.isArray(n)) {
      if (!Array.isArray(e) || n.length !== e.length) return false;
      for (let i = 0; i < n.length; i++) if (!Ft(n[i], e[i], t - 1)) return false;
      return true;
    }
    if (Array.isArray(e)) return false;
    if (typeof n == "object" && typeof e == "object") {
      const i = Object.keys(n), s = Object.keys(e);
      if (i.length !== s.length) return false;
      for (const a of i) if (!e.hasOwnProperty(a) || !Ft(n[a], e[a], t - 1)) return false;
      return true;
    }
    return false;
  }
  class T4 {
    constructor(e) {
      this.views = [], this.width = 100, this.height = 100, this.viewState = {}, this.controllers = {}, this.timeline = e.timeline, this._viewports = [], this._viewportMap = {}, this._isUpdating = false, this._needsRedraw = "First render", this._needsUpdate = "Initialize", this._eventManager = e.eventManager, this._eventCallbacks = {
        onViewStateChange: e.onViewStateChange,
        onInteractionStateChange: e.onInteractionStateChange
      }, Object.seal(this), this.setProps(e);
    }
    finalize() {
      for (const e in this.controllers) {
        const t = this.controllers[e];
        t && t.finalize();
      }
      this.controllers = {};
    }
    needsRedraw(e = {
      clearRedrawFlags: false
    }) {
      const t = this._needsRedraw;
      return e.clearRedrawFlags && (this._needsRedraw = false), t;
    }
    setNeedsUpdate(e) {
      this._needsUpdate = this._needsUpdate || e, this._needsRedraw = this._needsRedraw || e;
    }
    updateViewStates() {
      for (const e in this.controllers) {
        const t = this.controllers[e];
        t && t.updateTransition();
      }
    }
    getViewports(e) {
      return e ? this._viewports.filter((t) => t.containsPixel(e)) : this._viewports;
    }
    getViews() {
      const e = {};
      return this.views.forEach((t) => {
        e[t.id] = t;
      }), e;
    }
    getView(e) {
      return this.views.find((t) => t.id === e);
    }
    getViewState(e) {
      const t = typeof e == "string" ? this.getView(e) : e, i = t && this.viewState[t.getViewStateId()] || this.viewState;
      return t ? t.filterViewState(i) : i;
    }
    getViewport(e) {
      return this._viewportMap[e];
    }
    unproject(e, t) {
      const i = this.getViewports(), s = {
        x: e[0],
        y: e[1]
      };
      for (let a = i.length - 1; a >= 0; --a) {
        const l = i[a];
        if (l.containsPixel(s)) {
          const u = e.slice();
          return u[0] -= l.x, u[1] -= l.y, l.unproject(u, t);
        }
      }
      return null;
    }
    setProps(e) {
      e.views && this._setViews(e.views), e.viewState && this._setViewState(e.viewState), ("width" in e || "height" in e) && this._setSize(e.width, e.height), this._isUpdating || this._update();
    }
    _update() {
      this._isUpdating = true, this._needsUpdate && (this._needsUpdate = false, this._rebuildViewports()), this._needsUpdate && (this._needsUpdate = false, this._rebuildViewports()), this._isUpdating = false;
    }
    _setSize(e, t) {
      (e !== this.width || t !== this.height) && (this.width = e, this.height = t, this.setNeedsUpdate("Size changed"));
    }
    _setViews(e) {
      e = Ng(e, Boolean), this._diffViews(e, this.views) && this.setNeedsUpdate("views changed"), this.views = e;
    }
    _setViewState(e) {
      e ? (!Ft(e, this.viewState, 3) && this.setNeedsUpdate("viewState changed"), this.viewState = e) : Le.warn("missing `viewState` or `initialViewState`")();
    }
    _createController(e, t) {
      const i = t.type;
      return new i({
        timeline: this.timeline,
        eventManager: this._eventManager,
        onViewStateChange: this._eventCallbacks.onViewStateChange,
        onStateChange: this._eventCallbacks.onInteractionStateChange,
        makeViewport: (a) => {
          var _a2;
          return (_a2 = this.getView(e.id)) == null ? void 0 : _a2.makeViewport({
            viewState: a,
            width: this.width,
            height: this.height
          });
        }
      });
    }
    _updateController(e, t, i, s) {
      const a = e.controller;
      if (a && i) {
        const l = {
          ...t,
          ...a,
          id: e.id,
          x: i.x,
          y: i.y,
          width: i.width,
          height: i.height
        };
        return (!s || s.constructor !== a.type) && (s = this._createController(e, l)), s && s.setProps(l), s;
      }
      return null;
    }
    _rebuildViewports() {
      const { views: e } = this, t = this.controllers;
      this._viewports = [], this.controllers = {};
      let i = false;
      for (let s = e.length; s--; ) {
        const a = e[s], l = this.getViewState(a), u = a.makeViewport({
          viewState: l,
          width: this.width,
          height: this.height
        });
        let h = t[a.id];
        const d = !!a.controller;
        d && !h && (i = true), (i || !d) && h && (h.finalize(), h = null), this.controllers[a.id] = this._updateController(a, l, u, h), u && this._viewports.unshift(u);
      }
      for (const s in t) {
        const a = t[s];
        a && !this.controllers[s] && a.finalize();
      }
      this._buildViewportMap();
    }
    _buildViewportMap() {
      this._viewportMap = {}, this._viewports.forEach((e) => {
        e.id && (this._viewportMap[e.id] = this._viewportMap[e.id] || e);
      });
    }
    _diffViews(e, t) {
      return e.length !== t.length ? true : e.some((i, s) => !e[s].equals(t[s]));
    }
  }
  const x4 = /([0-9]+\.?[0-9]*)(%|px)/;
  function ki(n) {
    switch (typeof n) {
      case "number":
        return {
          position: n,
          relative: false
        };
      case "string":
        const e = x4.exec(n);
        if (e && e.length >= 3) {
          const t = e[2] === "%", i = parseFloat(e[1]);
          return {
            position: t ? i / 100 : i,
            relative: t
          };
        }
      default:
        throw new Error(`Could not parse position string ${n}`);
    }
  }
  function Ui(n, e) {
    return n.relative ? Math.round(n.position * e) : n.position;
  }
  class Yr {
    constructor(e) {
      const { id: t, x: i = 0, y: s = 0, width: a = "100%", height: l = "100%", padding: u = null } = e;
      this.id = t || this.constructor.displayName || "view", this.props = {
        ...e,
        id: this.id
      }, this._x = ki(i), this._y = ki(s), this._width = ki(a), this._height = ki(l), this._padding = u && {
        left: ki(u.left || 0),
        right: ki(u.right || 0),
        top: ki(u.top || 0),
        bottom: ki(u.bottom || 0)
      }, this.equals = this.equals.bind(this), Object.seal(this);
    }
    equals(e) {
      return this === e ? true : this.constructor === e.constructor && Ft(this.props, e.props, 2);
    }
    makeViewport({ width: e, height: t, viewState: i }) {
      i = this.filterViewState(i);
      const s = this.getDimensions({
        width: e,
        height: t
      });
      if (!s.height || !s.width) return null;
      const a = this.getViewportType(i);
      return new a({
        ...i,
        ...this.props,
        ...s
      });
    }
    getViewStateId() {
      const { viewState: e } = this.props;
      return typeof e == "string" ? e : (e == null ? void 0 : e.id) || this.id;
    }
    filterViewState(e) {
      if (this.props.viewState && typeof this.props.viewState == "object") {
        if (!this.props.viewState.id) return this.props.viewState;
        const t = {
          ...e
        };
        for (const i in this.props.viewState) i !== "id" && (t[i] = this.props.viewState[i]);
        return t;
      }
      return e;
    }
    getDimensions({ width: e, height: t }) {
      const i = {
        x: Ui(this._x, e),
        y: Ui(this._y, t),
        width: Ui(this._width, e),
        height: Ui(this._height, t)
      };
      return this._padding && (i.padding = {
        left: Ui(this._padding.left, e),
        top: Ui(this._padding.top, t),
        right: Ui(this._padding.right, e),
        bottom: Ui(this._padding.bottom, t)
      }), i;
    }
    get controller() {
      const e = this.props.controller;
      return e ? e === true ? {
        type: this.ControllerType
      } : typeof e == "function" ? {
        type: e
      } : {
        type: this.ControllerType,
        ...e
      } : null;
    }
  }
  class eu {
    constructor(e) {
      this._inProgress = false, this._handle = null, this.time = 0, this.settings = {
        duration: 0
      }, this._timeline = e;
    }
    get inProgress() {
      return this._inProgress;
    }
    start(e) {
      var _a2, _b3;
      this.cancel(), this.settings = e, this._inProgress = true, (_b3 = (_a2 = this.settings).onStart) == null ? void 0 : _b3.call(_a2, this);
    }
    end() {
      var _a2, _b3;
      this._inProgress && (this._timeline.removeChannel(this._handle), this._handle = null, this._inProgress = false, (_b3 = (_a2 = this.settings).onEnd) == null ? void 0 : _b3.call(_a2, this));
    }
    cancel() {
      var _a2, _b3;
      this._inProgress && ((_b3 = (_a2 = this.settings).onInterrupt) == null ? void 0 : _b3.call(_a2, this), this._timeline.removeChannel(this._handle), this._handle = null, this._inProgress = false);
    }
    update() {
      var _a2, _b3;
      if (!this._inProgress) return false;
      if (this._handle === null) {
        const { _timeline: e, settings: t } = this;
        this._handle = e.addChannel({
          delay: e.getTime(),
          duration: t.duration
        });
      }
      return this.time = this._timeline.getTime(this._handle), this._onUpdate(), (_b3 = (_a2 = this.settings).onUpdate) == null ? void 0 : _b3.call(_a2, this), this._timeline.isFinished(this._handle) && this.end(), true;
    }
    _onUpdate() {
    }
  }
  const N0 = () => {
  }, Bd = {
    BREAK: 1,
    SNAP_TO_END: 2,
    IGNORE: 3
  }, S4 = (n) => n, A4 = Bd.BREAK;
  class w4 {
    constructor(e) {
      this._onTransitionUpdate = (t) => {
        const { time: i, settings: { interpolator: s, startProps: a, endProps: l, duration: u, easing: h } } = t, d = h(i / u), p = s.interpolateProps(a, l, d);
        this.propsInTransition = this.getControllerState({
          ...this.props,
          ...p
        }).getViewportProps(), this.onViewStateChange({
          viewState: this.propsInTransition,
          oldViewState: this.props
        });
      }, this.getControllerState = e.getControllerState, this.propsInTransition = null, this.transition = new eu(e.timeline), this.onViewStateChange = e.onViewStateChange || N0, this.onStateChange = e.onStateChange || N0;
    }
    finalize() {
      this.transition.cancel();
    }
    getViewportInTransition() {
      return this.propsInTransition;
    }
    processViewStateChange(e) {
      let t = false;
      const i = this.props;
      if (this.props = e, !i || this._shouldIgnoreViewportChange(i, e)) return false;
      if (this._isTransitionEnabled(e)) {
        let s = i;
        if (this.transition.inProgress) {
          const { interruption: a, endProps: l } = this.transition.settings;
          s = {
            ...i,
            ...a === Bd.SNAP_TO_END ? l : this.propsInTransition || i
          };
        }
        this._triggerTransition(s, e), t = true;
      } else this.transition.cancel();
      return t;
    }
    updateTransition() {
      this.transition.update();
    }
    _isTransitionEnabled(e) {
      const { transitionDuration: t, transitionInterpolator: i } = e;
      return (t > 0 || t === "auto") && !!i;
    }
    _isUpdateDueToCurrentTransition(e) {
      return this.transition.inProgress && this.propsInTransition ? this.transition.settings.interpolator.arePropsEqual(e, this.propsInTransition) : false;
    }
    _shouldIgnoreViewportChange(e, t) {
      return this.transition.inProgress ? this.transition.settings.interruption === Bd.IGNORE || this._isUpdateDueToCurrentTransition(t) : this._isTransitionEnabled(t) ? t.transitionInterpolator.arePropsEqual(e, t) : true;
    }
    _triggerTransition(e, t) {
      const i = this.getControllerState(e), s = this.getControllerState(t).shortestPathFrom(i), a = t.transitionInterpolator, l = a.getDuration ? a.getDuration(e, t) : t.transitionDuration;
      if (l === 0) return;
      const u = a.initializeProps(e, s);
      this.propsInTransition = {};
      const h = {
        duration: l,
        easing: t.transitionEasing || S4,
        interpolator: a,
        interruption: t.transitionInterruption || A4,
        startProps: u.start,
        endProps: u.end,
        onStart: t.onTransitionStart,
        onUpdate: this._onTransitionUpdate,
        onInterrupt: this._onTransitionEnd(t.onTransitionInterrupt),
        onEnd: this._onTransitionEnd(t.onTransitionEnd)
      };
      this.transition.start(h), this.onStateChange({
        inTransition: true
      }), this.updateTransition();
    }
    _onTransitionEnd(e) {
      return (t) => {
        this.propsInTransition = null, this.onStateChange({
          inTransition: false,
          isZooming: false,
          isPanning: false,
          isRotating: false
        }), e == null ? void 0 : e(t);
      };
    }
  }
  function It(n, e) {
    if (!n) throw new Error(e || "deck.gl: assertion failed.");
  }
  class E4 {
    constructor(e) {
      const { compare: t, extract: i, required: s } = e;
      this._propsToCompare = t, this._propsToExtract = i || t, this._requiredProps = s;
    }
    arePropsEqual(e, t) {
      for (const i of this._propsToCompare) if (!(i in e) || !(i in t) || !_o(e[i], t[i])) return false;
      return true;
    }
    initializeProps(e, t) {
      const i = {}, s = {};
      for (const a of this._propsToExtract) (a in e || a in t) && (i[a] = e[a], s[a] = t[a]);
      return this._checkRequiredProps(i), this._checkRequiredProps(s), {
        start: i,
        end: s
      };
    }
    getDuration(e, t) {
      return t.transitionDuration;
    }
    _checkRequiredProps(e) {
      this._requiredProps && this._requiredProps.forEach((t) => {
        const i = e[t];
        It(Number.isFinite(i) || Array.isArray(i), `${t} is required for transition`);
      });
    }
  }
  const R4 = [
    "longitude",
    "latitude",
    "zoom",
    "bearing",
    "pitch"
  ], C4 = [
    "longitude",
    "latitude",
    "zoom"
  ];
  class j2 extends E4 {
    constructor(e = {}) {
      const t = Array.isArray(e) ? e : e.transitionProps, i = Array.isArray(e) ? {} : e;
      i.transitionProps = Array.isArray(t) ? {
        compare: t,
        required: t
      } : t || {
        compare: R4,
        required: C4
      }, super(i.transitionProps), this.opts = i;
    }
    initializeProps(e, t) {
      const i = super.initializeProps(e, t), { makeViewport: s, around: a } = this.opts;
      if (s && a) {
        const l = s(e), u = s(t), h = l.unproject(a);
        i.start.around = a, Object.assign(i.end, {
          around: u.project(h),
          aroundPosition: h,
          width: t.width,
          height: t.height
        });
      }
      return i;
    }
    interpolateProps(e, t, i) {
      const s = {};
      for (const a of this._propsToExtract) s[a] = Rc(e[a] || 0, t[a] || 0, i);
      if (t.aroundPosition && this.opts.makeViewport) {
        const a = this.opts.makeViewport({
          ...t,
          ...s
        });
        Object.assign(s, a.panByPosition(t.aroundPosition, Rc(e.around, t.around, i)));
      }
      return s;
    }
  }
  const Bi = {
    transitionDuration: 0
  }, M4 = 300, ec = (n) => 1 - (1 - n) * (1 - n), wr = {
    WHEEL: [
      "wheel"
    ],
    PAN: [
      "panstart",
      "panmove",
      "panend"
    ],
    PINCH: [
      "pinchstart",
      "pinchmove",
      "pinchend"
    ],
    MULTI_PAN: [
      "multipanstart",
      "multipanmove",
      "multipanend"
    ],
    DOUBLE_CLICK: [
      "dblclick"
    ],
    KEYBOARD: [
      "keydown"
    ]
  }, ms = {};
  class O4 {
    constructor(e) {
      this.state = {}, this._events = {}, this._interactionState = {
        isDragging: false
      }, this._customEvents = [], this._eventStartBlocked = null, this._panMove = false, this.invertPan = false, this.dragMode = "rotate", this.inertia = 0, this.scrollZoom = true, this.dragPan = true, this.dragRotate = true, this.doubleClickZoom = true, this.touchZoom = true, this.touchRotate = false, this.keyboard = true, this.transitionManager = new w4({
        ...e,
        getControllerState: (t) => new this.ControllerState(t),
        onViewStateChange: this._onTransition.bind(this),
        onStateChange: this._setInteractionState.bind(this)
      }), this.handleEvent = this.handleEvent.bind(this), this.eventManager = e.eventManager, this.onViewStateChange = e.onViewStateChange || (() => {
      }), this.onStateChange = e.onStateChange || (() => {
      }), this.makeViewport = e.makeViewport;
    }
    set events(e) {
      this.toggleEvents(this._customEvents, false), this.toggleEvents(e, true), this._customEvents = e, this.props && this.setProps(this.props);
    }
    finalize() {
      var _a2;
      for (const e in this._events) this._events[e] && ((_a2 = this.eventManager) == null ? void 0 : _a2.off(e, this.handleEvent));
      this.transitionManager.finalize();
    }
    handleEvent(e) {
      this._controllerState = void 0;
      const t = this._eventStartBlocked;
      switch (e.type) {
        case "panstart":
          return t ? false : this._onPanStart(e);
        case "panmove":
          return this._onPan(e);
        case "panend":
          return this._onPanEnd(e);
        case "pinchstart":
          return t ? false : this._onPinchStart(e);
        case "pinchmove":
          return this._onPinch(e);
        case "pinchend":
          return this._onPinchEnd(e);
        case "multipanstart":
          return t ? false : this._onMultiPanStart(e);
        case "multipanmove":
          return this._onMultiPan(e);
        case "multipanend":
          return this._onMultiPanEnd(e);
        case "dblclick":
          return this._onDoubleClick(e);
        case "wheel":
          return this._onWheel(e);
        case "keydown":
          return this._onKeyDown(e);
        default:
          return false;
      }
    }
    get controllerState() {
      return this._controllerState = this._controllerState || new this.ControllerState({
        makeViewport: this.makeViewport,
        ...this.props,
        ...this.state
      }), this._controllerState;
    }
    getCenter(e) {
      const { x: t, y: i } = this.props, { offsetCenter: s } = e;
      return [
        s.x - t,
        s.y - i
      ];
    }
    isPointInBounds(e, t) {
      const { width: i, height: s } = this.props;
      if (t && t.handled) return false;
      const a = e[0] >= 0 && e[0] <= i && e[1] >= 0 && e[1] <= s;
      return a && t && t.stopPropagation(), a;
    }
    isFunctionKeyPressed(e) {
      const { srcEvent: t } = e;
      return !!(t.metaKey || t.altKey || t.ctrlKey || t.shiftKey);
    }
    isDragging() {
      return this._interactionState.isDragging || false;
    }
    blockEvents(e) {
      const t = setTimeout(() => {
        this._eventStartBlocked === t && (this._eventStartBlocked = null);
      }, e);
      this._eventStartBlocked = t;
    }
    setProps(e) {
      e.dragMode && (this.dragMode = e.dragMode), this.props = e, "transitionInterpolator" in e || (e.transitionInterpolator = this._getTransitionProps().transitionInterpolator), this.transitionManager.processViewStateChange(e);
      const { inertia: t } = e;
      this.inertia = Number.isFinite(t) ? t : t === true ? M4 : 0;
      const { scrollZoom: i = true, dragPan: s = true, dragRotate: a = true, doubleClickZoom: l = true, touchZoom: u = true, touchRotate: h = false, keyboard: d = true } = e, p = !!this.onViewStateChange;
      this.toggleEvents(wr.WHEEL, p && i), this.toggleEvents(wr.PAN, p), this.toggleEvents(wr.PINCH, p && (u || h)), this.toggleEvents(wr.MULTI_PAN, p && h), this.toggleEvents(wr.DOUBLE_CLICK, p && l), this.toggleEvents(wr.KEYBOARD, p && d), this.scrollZoom = i, this.dragPan = s, this.dragRotate = a, this.doubleClickZoom = l, this.touchZoom = u, this.touchRotate = h, this.keyboard = d;
    }
    updateTransition() {
      this.transitionManager.updateTransition();
    }
    toggleEvents(e, t) {
      this.eventManager && e.forEach((i) => {
        this._events[i] !== t && (this._events[i] = t, t ? this.eventManager.on(i, this.handleEvent) : this.eventManager.off(i, this.handleEvent));
      });
    }
    updateViewport(e, t = null, i = {}) {
      const s = {
        ...e.getViewportProps(),
        ...t
      }, a = this.controllerState !== e;
      if (this.state = e.getState(), this._setInteractionState(i), a) {
        const l = this.controllerState && this.controllerState.getViewportProps();
        this.onViewStateChange && this.onViewStateChange({
          viewState: s,
          interactionState: this._interactionState,
          oldViewState: l,
          viewId: this.props.id
        });
      }
    }
    _onTransition(e) {
      this.onViewStateChange({
        ...e,
        interactionState: this._interactionState,
        viewId: this.props.id
      });
    }
    _setInteractionState(e) {
      Object.assign(this._interactionState, e), this.onStateChange(this._interactionState);
    }
    _onPanStart(e) {
      const t = this.getCenter(e);
      if (!this.isPointInBounds(t, e)) return false;
      let i = this.isFunctionKeyPressed(e) || e.rightButton || false;
      (this.invertPan || this.dragMode === "pan") && (i = !i);
      const s = this.controllerState[i ? "panStart" : "rotateStart"]({
        pos: t
      });
      return this._panMove = i, this.updateViewport(s, Bi, {
        isDragging: true
      }), true;
    }
    _onPan(e) {
      return this.isDragging() ? this._panMove ? this._onPanMove(e) : this._onPanRotate(e) : false;
    }
    _onPanEnd(e) {
      return this.isDragging() ? this._panMove ? this._onPanMoveEnd(e) : this._onPanRotateEnd(e) : false;
    }
    _onPanMove(e) {
      if (!this.dragPan) return false;
      const t = this.getCenter(e), i = this.controllerState.pan({
        pos: t
      });
      return this.updateViewport(i, Bi, {
        isDragging: true,
        isPanning: true
      }), true;
    }
    _onPanMoveEnd(e) {
      const { inertia: t } = this;
      if (this.dragPan && t && e.velocity) {
        const i = this.getCenter(e), s = [
          i[0] + e.velocityX * t / 2,
          i[1] + e.velocityY * t / 2
        ], a = this.controllerState.pan({
          pos: s
        }).panEnd();
        this.updateViewport(a, {
          ...this._getTransitionProps(),
          transitionDuration: t,
          transitionEasing: ec
        }, {
          isDragging: false,
          isPanning: true
        });
      } else {
        const i = this.controllerState.panEnd();
        this.updateViewport(i, null, {
          isDragging: false,
          isPanning: false
        });
      }
      return true;
    }
    _onPanRotate(e) {
      if (!this.dragRotate) return false;
      const t = this.getCenter(e), i = this.controllerState.rotate({
        pos: t
      });
      return this.updateViewport(i, Bi, {
        isDragging: true,
        isRotating: true
      }), true;
    }
    _onPanRotateEnd(e) {
      const { inertia: t } = this;
      if (this.dragRotate && t && e.velocity) {
        const i = this.getCenter(e), s = [
          i[0] + e.velocityX * t / 2,
          i[1] + e.velocityY * t / 2
        ], a = this.controllerState.rotate({
          pos: s
        }).rotateEnd();
        this.updateViewport(a, {
          ...this._getTransitionProps(),
          transitionDuration: t,
          transitionEasing: ec
        }, {
          isDragging: false,
          isRotating: true
        });
      } else {
        const i = this.controllerState.rotateEnd();
        this.updateViewport(i, null, {
          isDragging: false,
          isRotating: false
        });
      }
      return true;
    }
    _onWheel(e) {
      if (!this.scrollZoom) return false;
      const t = this.getCenter(e);
      if (!this.isPointInBounds(t, e)) return false;
      e.srcEvent.preventDefault();
      const { speed: i = 0.01, smooth: s = false } = this.scrollZoom === true ? {} : this.scrollZoom, { delta: a } = e;
      let l = 2 / (1 + Math.exp(-Math.abs(a * i)));
      a < 0 && l !== 0 && (l = 1 / l);
      const u = this.controllerState.zoom({
        pos: t,
        scale: l
      });
      return this.updateViewport(u, {
        ...this._getTransitionProps({
          around: t
        }),
        transitionDuration: s ? 250 : 1
      }, {
        isZooming: true,
        isPanning: true
      }), true;
    }
    _onMultiPanStart(e) {
      const t = this.getCenter(e);
      if (!this.isPointInBounds(t, e)) return false;
      const i = this.controllerState.rotateStart({
        pos: t
      });
      return this.updateViewport(i, Bi, {
        isDragging: true
      }), true;
    }
    _onMultiPan(e) {
      if (!this.touchRotate || !this.isDragging()) return false;
      const t = this.getCenter(e);
      t[0] -= e.deltaX;
      const i = this.controllerState.rotate({
        pos: t
      });
      return this.updateViewport(i, Bi, {
        isDragging: true,
        isRotating: true
      }), true;
    }
    _onMultiPanEnd(e) {
      if (!this.isDragging()) return false;
      const { inertia: t } = this;
      if (this.touchRotate && t && e.velocityY) {
        const i = this.getCenter(e), s = [
          i[0],
          i[1] += e.velocityY * t / 2
        ], a = this.controllerState.rotate({
          pos: s
        });
        this.updateViewport(a, {
          ...this._getTransitionProps(),
          transitionDuration: t,
          transitionEasing: ec
        }, {
          isDragging: false,
          isRotating: true
        }), this.blockEvents(t);
      } else {
        const i = this.controllerState.rotateEnd();
        this.updateViewport(i, null, {
          isDragging: false,
          isRotating: false
        });
      }
      return true;
    }
    _onPinchStart(e) {
      const t = this.getCenter(e);
      if (!this.isPointInBounds(t, e)) return false;
      const i = this.controllerState.zoomStart({
        pos: t
      }).rotateStart({
        pos: t
      });
      return ms._startPinchRotation = e.rotation, ms._lastPinchEvent = e, this.updateViewport(i, Bi, {
        isDragging: true
      }), true;
    }
    _onPinch(e) {
      if (!this.touchZoom && !this.touchRotate || !this.isDragging()) return false;
      let t = this.controllerState;
      if (this.touchZoom) {
        const { scale: i } = e, s = this.getCenter(e);
        t = t.zoom({
          pos: s,
          scale: i
        });
      }
      if (this.touchRotate) {
        const { rotation: i } = e;
        t = t.rotate({
          deltaAngleX: ms._startPinchRotation - i
        });
      }
      return this.updateViewport(t, Bi, {
        isDragging: true,
        isPanning: this.touchZoom,
        isZooming: this.touchZoom,
        isRotating: this.touchRotate
      }), ms._lastPinchEvent = e, true;
    }
    _onPinchEnd(e) {
      if (!this.isDragging()) return false;
      const { inertia: t } = this, { _lastPinchEvent: i } = ms;
      if (this.touchZoom && t && i && e.scale !== i.scale) {
        const s = this.getCenter(e);
        let a = this.controllerState.rotateEnd();
        const l = Math.log2(e.scale), u = (l - Math.log2(i.scale)) / (e.deltaTime - i.deltaTime), h = Math.pow(2, l + u * t / 2);
        a = a.zoom({
          pos: s,
          scale: h
        }).zoomEnd(), this.updateViewport(a, {
          ...this._getTransitionProps({
            around: s
          }),
          transitionDuration: t,
          transitionEasing: ec
        }, {
          isDragging: false,
          isPanning: this.touchZoom,
          isZooming: this.touchZoom,
          isRotating: false
        }), this.blockEvents(t);
      } else {
        const s = this.controllerState.zoomEnd().rotateEnd();
        this.updateViewport(s, null, {
          isDragging: false,
          isPanning: false,
          isZooming: false,
          isRotating: false
        });
      }
      return ms._startPinchRotation = null, ms._lastPinchEvent = null, true;
    }
    _onDoubleClick(e) {
      if (!this.doubleClickZoom) return false;
      const t = this.getCenter(e);
      if (!this.isPointInBounds(t, e)) return false;
      const i = this.isFunctionKeyPressed(e), s = this.controllerState.zoom({
        pos: t,
        scale: i ? 0.5 : 2
      });
      return this.updateViewport(s, this._getTransitionProps({
        around: t
      }), {
        isZooming: true,
        isPanning: true
      }), this.blockEvents(100), true;
    }
    _onKeyDown(e) {
      if (!this.keyboard) return false;
      const t = this.isFunctionKeyPressed(e), { zoomSpeed: i, moveSpeed: s, rotateSpeedX: a, rotateSpeedY: l } = this.keyboard === true ? {} : this.keyboard, { controllerState: u } = this;
      let h;
      const d = {};
      switch (e.srcEvent.code) {
        case "Minus":
          h = t ? u.zoomOut(i).zoomOut(i) : u.zoomOut(i), d.isZooming = true;
          break;
        case "Equal":
          h = t ? u.zoomIn(i).zoomIn(i) : u.zoomIn(i), d.isZooming = true;
          break;
        case "ArrowLeft":
          t ? (h = u.rotateLeft(a), d.isRotating = true) : (h = u.moveLeft(s), d.isPanning = true);
          break;
        case "ArrowRight":
          t ? (h = u.rotateRight(a), d.isRotating = true) : (h = u.moveRight(s), d.isPanning = true);
          break;
        case "ArrowUp":
          t ? (h = u.rotateUp(l), d.isRotating = true) : (h = u.moveUp(s), d.isPanning = true);
          break;
        case "ArrowDown":
          t ? (h = u.rotateDown(l), d.isRotating = true) : (h = u.moveDown(s), d.isPanning = true);
          break;
        default:
          return false;
      }
      return this.updateViewport(h, this._getTransitionProps(), d), true;
    }
    _getTransitionProps(e) {
      const { transition: t } = this;
      return !t || !t.transitionInterpolator ? Bi : e ? {
        ...t,
        transitionInterpolator: new j2({
          ...e,
          ...t.transitionInterpolator.opts,
          makeViewport: this.controllerState.makeViewport
        })
      } : t;
    }
  }
  class I4 {
    constructor(e, t) {
      this._viewportProps = this.applyConstraints(e), this._state = t;
    }
    getViewportProps() {
      return this._viewportProps;
    }
    getState() {
      return this._state;
    }
  }
  const P0 = 5, N4 = 1.2;
  class P4 extends I4 {
    constructor(e) {
      const { width: t, height: i, latitude: s, longitude: a, zoom: l, bearing: u = 0, pitch: h = 0, altitude: d = 1.5, position: p = [
        0,
        0,
        0
      ], maxZoom: _ = 20, minZoom: y = 0, maxPitch: v = 60, minPitch: S = 0, startPanLngLat: E, startZoomLngLat: M, startRotatePos: F, startBearing: H, startPitch: O, startZoom: U, normalize: B = true } = e;
      It(Number.isFinite(a)), It(Number.isFinite(s)), It(Number.isFinite(l)), super({
        width: t,
        height: i,
        latitude: s,
        longitude: a,
        zoom: l,
        bearing: u,
        pitch: h,
        altitude: d,
        maxZoom: _,
        minZoom: y,
        maxPitch: v,
        minPitch: S,
        normalize: B,
        position: p
      }, {
        startPanLngLat: E,
        startZoomLngLat: M,
        startRotatePos: F,
        startBearing: H,
        startPitch: O,
        startZoom: U
      }), this.makeViewport = e.makeViewport;
    }
    panStart({ pos: e }) {
      return this._getUpdatedState({
        startPanLngLat: this._unproject(e)
      });
    }
    pan({ pos: e, startPos: t }) {
      const i = this.getState().startPanLngLat || this._unproject(t);
      if (!i) return this;
      const a = this.makeViewport(this.getViewportProps()).panByPosition(i, e);
      return this._getUpdatedState(a);
    }
    panEnd() {
      return this._getUpdatedState({
        startPanLngLat: null
      });
    }
    rotateStart({ pos: e }) {
      return this._getUpdatedState({
        startRotatePos: e,
        startBearing: this.getViewportProps().bearing,
        startPitch: this.getViewportProps().pitch
      });
    }
    rotate({ pos: e, deltaAngleX: t = 0, deltaAngleY: i = 0 }) {
      const { startRotatePos: s, startBearing: a, startPitch: l } = this.getState();
      if (!s || a === void 0 || l === void 0) return this;
      let u;
      return e ? u = this._getNewRotation(e, s, l, a) : u = {
        bearing: a + t,
        pitch: l + i
      }, this._getUpdatedState(u);
    }
    rotateEnd() {
      return this._getUpdatedState({
        startBearing: null,
        startPitch: null
      });
    }
    zoomStart({ pos: e }) {
      return this._getUpdatedState({
        startZoomLngLat: this._unproject(e),
        startZoom: this.getViewportProps().zoom
      });
    }
    zoom({ pos: e, startPos: t, scale: i }) {
      let { startZoom: s, startZoomLngLat: a } = this.getState();
      if (a || (s = this.getViewportProps().zoom, a = this._unproject(t) || this._unproject(e)), !a) return this;
      const { maxZoom: l, minZoom: u } = this.getViewportProps();
      let h = s + Math.log2(i);
      h = Hi(h, u, l);
      const d = this.makeViewport({
        ...this.getViewportProps(),
        zoom: h
      });
      return this._getUpdatedState({
        zoom: h,
        ...d.panByPosition(a, e)
      });
    }
    zoomEnd() {
      return this._getUpdatedState({
        startZoomLngLat: null,
        startZoom: null
      });
    }
    zoomIn(e = 2) {
      return this._zoomFromCenter(e);
    }
    zoomOut(e = 2) {
      return this._zoomFromCenter(1 / e);
    }
    moveLeft(e = 100) {
      return this._panFromCenter([
        e,
        0
      ]);
    }
    moveRight(e = 100) {
      return this._panFromCenter([
        -e,
        0
      ]);
    }
    moveUp(e = 100) {
      return this._panFromCenter([
        0,
        e
      ]);
    }
    moveDown(e = 100) {
      return this._panFromCenter([
        0,
        -e
      ]);
    }
    rotateLeft(e = 15) {
      return this._getUpdatedState({
        bearing: this.getViewportProps().bearing - e
      });
    }
    rotateRight(e = 15) {
      return this._getUpdatedState({
        bearing: this.getViewportProps().bearing + e
      });
    }
    rotateUp(e = 10) {
      return this._getUpdatedState({
        pitch: this.getViewportProps().pitch + e
      });
    }
    rotateDown(e = 10) {
      return this._getUpdatedState({
        pitch: this.getViewportProps().pitch - e
      });
    }
    shortestPathFrom(e) {
      const t = e.getViewportProps(), i = {
        ...this.getViewportProps()
      }, { bearing: s, longitude: a } = i;
      return Math.abs(s - t.bearing) > 180 && (i.bearing = s < 0 ? s + 360 : s - 360), Math.abs(a - t.longitude) > 180 && (i.longitude = a < 0 ? a + 360 : a - 360), i;
    }
    applyConstraints(e) {
      const { maxZoom: t, minZoom: i, zoom: s } = e;
      e.zoom = Hi(s, i, t);
      const { maxPitch: a, minPitch: l, pitch: u } = e;
      e.pitch = Hi(u, l, a);
      const { normalize: h = true } = e;
      return h && Object.assign(e, JO(e)), e;
    }
    _zoomFromCenter(e) {
      const { width: t, height: i } = this.getViewportProps();
      return this.zoom({
        pos: [
          t / 2,
          i / 2
        ],
        scale: e
      });
    }
    _panFromCenter(e) {
      const { width: t, height: i } = this.getViewportProps();
      return this.pan({
        startPos: [
          t / 2,
          i / 2
        ],
        pos: [
          t / 2 + e[0],
          i / 2 + e[1]
        ]
      });
    }
    _getUpdatedState(e) {
      return new this.constructor({
        makeViewport: this.makeViewport,
        ...this.getViewportProps(),
        ...this.getState(),
        ...e
      });
    }
    _unproject(e) {
      const t = this.makeViewport(this.getViewportProps());
      return e && t.unproject(e);
    }
    _getNewRotation(e, t, i, s) {
      const a = e[0] - t[0], l = e[1] - t[1], u = e[1], h = t[1], { width: d, height: p } = this.getViewportProps(), _ = a / d;
      let y = 0;
      l > 0 ? Math.abs(p - h) > P0 && (y = l / (h - p) * N4) : l < 0 && h > P0 && (y = 1 - u / h), y = Hi(y, -1, 1);
      const { minPitch: v, maxPitch: S } = this.getViewportProps(), E = s + 180 * _;
      let M = i;
      return y > 0 ? M = i + y * (S - i) : y < 0 && (M = i - y * (v - i)), {
        pitch: M,
        bearing: E
      };
    }
  }
  class D4 extends O4 {
    constructor() {
      super(...arguments), this.ControllerState = P4, this.transition = {
        transitionDuration: 300,
        transitionInterpolator: new j2({
          transitionProps: {
            compare: [
              "longitude",
              "latitude",
              "zoom",
              "bearing",
              "pitch",
              "position"
            ],
            required: [
              "longitude",
              "latitude",
              "zoom"
            ]
          }
        })
      }, this.dragMode = "pan";
    }
    setProps(e) {
      e.position = e.position || [
        0,
        0,
        0
      ];
      const t = this.props;
      super.setProps(e), (!t || t.height !== e.height) && this.updateViewport(new this.ControllerState({
        makeViewport: this.makeViewport,
        ...e,
        ...this.state
      }));
    }
  }
  class W2 extends Yr {
    constructor(e = {}) {
      super(e);
    }
    getViewportType() {
      return Xr;
    }
    get ControllerType() {
      return D4;
    }
  }
  W2.displayName = "MapView";
  const k4 = new Cg();
  function U4(n, e) {
    const t = n.order ?? 1 / 0, i = e.order ?? 1 / 0;
    return t - i;
  }
  class B4 {
    constructor(e) {
      this._resolvedEffects = [], this._defaultEffects = [], this.effects = [], this._context = e, this._needsRedraw = "Initial render", this._setEffects([]);
    }
    addDefaultEffect(e) {
      const t = this._defaultEffects;
      if (!t.find((i) => i.id === e.id)) {
        const i = t.findIndex((s) => U4(s, e) > 0);
        i < 0 ? t.push(e) : t.splice(i, 0, e), e.setup(this._context), this._setEffects(this.effects);
      }
    }
    setProps(e) {
      "effects" in e && (Ft(e.effects, this.effects, 1) || this._setEffects(e.effects));
    }
    needsRedraw(e = {
      clearRedrawFlags: false
    }) {
      const t = this._needsRedraw;
      return e.clearRedrawFlags && (this._needsRedraw = false), t;
    }
    getEffects() {
      return this._resolvedEffects;
    }
    _setEffects(e) {
      const t = {};
      for (const s of this.effects) t[s.id] = s;
      const i = [];
      for (const s of e) {
        const a = t[s.id];
        let l = s;
        a && a !== s ? a.setProps ? (a.setProps(s.props), l = a) : a.cleanup(this._context) : a || s.setup(this._context), i.push(l), delete t[s.id];
      }
      for (const s in t) t[s].cleanup(this._context);
      this.effects = i, this._resolvedEffects = i.concat(this._defaultEffects), e.some((s) => s instanceof Cg) || this._resolvedEffects.push(k4), this._needsRedraw = "effects changed";
    }
    finalize() {
      for (const e of this._resolvedEffects) e.cleanup(this._context);
      this.effects.length = 0, this._resolvedEffects.length = 0, this._defaultEffects.length = 0;
    }
  }
  class L4 extends Rg {
    shouldDrawLayer(e) {
      const { operation: t } = e.props;
      return t.includes("draw") || t.includes("terrain");
    }
  }
  const F4 = "deckRenderer.renderLayers";
  class V4 {
    constructor(e) {
      this.device = e, this.layerFilter = null, this.drawPickingColors = false, this.drawLayersPass = new L4(e), this.pickLayersPass = new z2(e), this.renderCount = 0, this._needsRedraw = "Initial render", this.renderBuffers = [], this.lastPostProcessEffect = null;
    }
    setProps(e) {
      this.layerFilter !== e.layerFilter && (this.layerFilter = e.layerFilter, this._needsRedraw = "layerFilter changed"), this.drawPickingColors !== e.drawPickingColors && (this.drawPickingColors = e.drawPickingColors, this._needsRedraw = "drawPickingColors changed");
    }
    renderLayers(e) {
      if (!e.viewports.length) return;
      const t = this.drawPickingColors ? this.pickLayersPass : this.drawLayersPass, i = {
        layerFilter: this.layerFilter,
        isPicking: this.drawPickingColors,
        ...e
      };
      i.effects && this._preRender(i.effects, i);
      const s = this.lastPostProcessEffect ? this.renderBuffers[0] : i.target;
      this.lastPostProcessEffect && (i.clearColor = [
        0,
        0,
        0,
        0
      ], i.clearCanvas = true);
      const a = t.render({
        ...i,
        target: s
      });
      i.effects && this._postRender(i.effects, i), this.renderCount++, Ot(F4, this, a, e);
    }
    needsRedraw(e = {
      clearRedrawFlags: false
    }) {
      const t = this._needsRedraw;
      return e.clearRedrawFlags && (this._needsRedraw = false), t;
    }
    finalize() {
      const { renderBuffers: e } = this;
      for (const t of e) t.delete();
      e.length = 0;
    }
    _preRender(e, t) {
      this.lastPostProcessEffect = null, t.preRenderStats = t.preRenderStats || {};
      for (const i of e) t.preRenderStats[i.id] = i.preRender(t), i.postRender && (this.lastPostProcessEffect = i.id);
      this.lastPostProcessEffect && this._resizeRenderBuffers();
    }
    _resizeRenderBuffers() {
      const { renderBuffers: e } = this, t = this.device.canvasContext.getDrawingBufferSize();
      e.length === 0 && [
        0,
        1
      ].map((i) => {
        const s = this.device.createTexture({
          sampler: {
            minFilter: "linear",
            magFilter: "linear"
          }
        });
        e.push(this.device.createFramebuffer({
          id: `deck-renderbuffer-${i}`,
          colorAttachments: [
            s
          ]
        }));
      });
      for (const i of e) i.resize(t);
    }
    _postRender(e, t) {
      const { renderBuffers: i } = this, s = {
        ...t,
        inputBuffer: i[0],
        swapBuffer: i[1]
      };
      for (const a of e) if (a.postRender) {
        s.target = a.id === this.lastPostProcessEffect ? t.target : void 0;
        const l = a.postRender(s);
        s.inputBuffer = l, s.swapBuffer = l === i[0] ? i[1] : i[0];
      }
    }
  }
  const z4 = {
    pickedColor: null,
    pickedObjectIndex: -1
  };
  function H4({ pickedColors: n, decodePickingColor: e, deviceX: t, deviceY: i, deviceRadius: s, deviceRect: a }) {
    const { x: l, y: u, width: h, height: d } = a;
    let p = s * s, _ = -1, y = 0;
    for (let v = 0; v < d; v++) {
      const S = v + u - i, E = S * S;
      if (E > p) y += 4 * h;
      else for (let M = 0; M < h; M++) {
        if (n[y + 3] - 1 >= 0) {
          const H = M + l - t, O = H * H + E;
          O <= p && (p = O, _ = y);
        }
        y += 4;
      }
    }
    if (_ >= 0) {
      const v = n.slice(_, _ + 4), S = e(v);
      if (S) {
        const E = Math.floor(_ / 4 / h), M = _ / 4 - E * h;
        return {
          ...S,
          pickedColor: v,
          pickedX: l + M,
          pickedY: u + E
        };
      }
      Le.error("Picked non-existent layer. Is picking buffer corrupt?")();
    }
    return z4;
  }
  function j4({ pickedColors: n, decodePickingColor: e }) {
    const t = /* @__PURE__ */ new Map();
    if (n) {
      for (let i = 0; i < n.length; i += 4) if (n[i + 3] - 1 >= 0) {
        const a = n.slice(i, i + 4), l = a.join(",");
        if (!t.has(l)) {
          const u = e(a);
          u ? t.set(l, {
            ...u,
            color: a
          }) : Le.error("Picked non-existent layer. Is picking buffer corrupt?")();
        }
      }
    }
    return Array.from(t.values());
  }
  function $2({ pickInfo: n, viewports: e, pixelRatio: t, x: i, y: s, z: a }) {
    let l = e[0];
    e.length > 1 && (l = $4((n == null ? void 0 : n.pickedViewports) || e, {
      x: i,
      y: s
    }));
    let u;
    if (l) {
      const h = [
        i - l.x,
        s - l.y
      ];
      a !== void 0 && (h[2] = a), u = l.unproject(h);
    }
    return {
      color: null,
      layer: null,
      viewport: l,
      index: -1,
      picked: false,
      x: i,
      y: s,
      pixel: [
        i,
        s
      ],
      coordinate: u,
      devicePixel: n && "pickedX" in n ? [
        n.pickedX,
        n.pickedY
      ] : void 0,
      pixelRatio: t
    };
  }
  function W4(n) {
    const { pickInfo: e, lastPickedInfo: t, mode: i, layers: s } = n, { pickedColor: a, pickedLayer: l, pickedObjectIndex: u } = e, h = l ? [
      l
    ] : [];
    if (i === "hover") {
      const _ = t.index, y = t.layerId, v = l ? l.props.id : null;
      if (v !== y || u !== _) {
        if (v !== y) {
          const S = s.find((E) => E.props.id === y);
          S && h.unshift(S);
        }
        t.layerId = v, t.index = u, t.info = null;
      }
    }
    const d = $2(n), p = /* @__PURE__ */ new Map();
    return p.set(null, d), h.forEach((_) => {
      let y = {
        ...d
      };
      _ === l && (y.color = a, y.index = u, y.picked = true), y = X2({
        layer: _,
        info: y,
        mode: i
      });
      const v = y.layer;
      _ === l && i === "hover" && (t.info = y), p.set(v.id, y), i === "hover" && v.updateAutoHighlight(y);
    }), p;
  }
  function X2({ layer: n, info: e, mode: t }) {
    for (; n && e; ) {
      const i = e.layer || null;
      e.sourceLayer = i, e.layer = n, e = n.getPickingInfo({
        info: e,
        mode: t,
        sourceLayer: i
      }), n = n.parent;
    }
    return e;
  }
  function $4(n, e) {
    for (let t = n.length - 1; t >= 0; t--) {
      const i = n[t];
      if (i.containsPixel(e)) return i;
    }
    return n[0];
  }
  class X4 {
    constructor(e) {
      this._pickable = true, this.device = e, this.pickLayersPass = new z2(e), this.lastPickedInfo = {
        index: -1,
        layerId: null,
        info: null
      };
    }
    setProps(e) {
      "layerFilter" in e && (this.layerFilter = e.layerFilter), "_pickable" in e && (this._pickable = e._pickable);
    }
    finalize() {
      this.pickingFBO && this.pickingFBO.destroy(), this.depthFBO && this.depthFBO.destroy();
    }
    pickObject(e) {
      return this._pickClosestObject(e);
    }
    pickObjects(e) {
      return this._pickVisibleObjects(e);
    }
    getLastPickedObject({ x: e, y: t, layers: i, viewports: s }, a = this.lastPickedInfo.info) {
      const l = a && a.layer && a.layer.id, u = a && a.viewport && a.viewport.id, h = l ? i.find((y) => y.id === l) : null, d = u && s.find((y) => y.id === u) || s[0], p = d && d.unproject([
        e - d.x,
        t - d.y
      ]);
      return {
        ...a,
        ...{
          x: e,
          y: t,
          viewport: d,
          coordinate: p,
          layer: h
        }
      };
    }
    _resizeBuffer() {
      var _a2, _b3;
      if (!this.pickingFBO && (this.pickingFBO = this.device.createFramebuffer({
        colorAttachments: [
          "rgba8unorm"
        ],
        depthStencilAttachment: "depth16unorm"
      }), this.device.isTextureFormatRenderable("rgba32float"))) {
        const t = this.device.createFramebuffer({
          colorAttachments: [
            "rgba32float"
          ],
          depthStencilAttachment: "depth16unorm"
        });
        this.depthFBO = t;
      }
      const { canvas: e } = this.device.getDefaultCanvasContext();
      (_a2 = this.pickingFBO) == null ? void 0 : _a2.resize({
        width: e.width,
        height: e.height
      }), (_b3 = this.depthFBO) == null ? void 0 : _b3.resize({
        width: e.width,
        height: e.height
      });
    }
    _getPickable(e) {
      if (this._pickable === false) return null;
      const t = e.filter((i) => this.pickLayersPass.shouldDrawLayer(i) && !i.isComposite);
      return t.length ? t : null;
    }
    _pickClosestObject({ layers: e, views: t, viewports: i, x: s, y: a, radius: l = 0, depth: u = 1, mode: h = "query", unproject3D: d, onViewportActive: p, effects: _ }) {
      const y = this.device.canvasContext.cssToDeviceRatio(), v = this._getPickable(e);
      if (!v || i.length === 0) return {
        result: [],
        emptyInfo: $2({
          viewports: i,
          x: s,
          y: a,
          pixelRatio: y
        })
      };
      this._resizeBuffer();
      const S = this.device.canvasContext.cssToDevicePixels([
        s,
        a
      ], true), E = [
        S.x + Math.floor(S.width / 2),
        S.y + Math.floor(S.height / 2)
      ], M = Math.round(l * y), { width: F, height: H } = this.pickingFBO, O = this._getPickingRect({
        deviceX: E[0],
        deviceY: E[1],
        deviceRadius: M,
        deviceWidth: F,
        deviceHeight: H
      }), U = {
        x: s - l,
        y: a - l,
        width: l * 2 + 1,
        height: l * 2 + 1
      };
      let B;
      const Z = [], re = /* @__PURE__ */ new Set();
      for (let le = 0; le < u; le++) {
        let ee;
        if (O) {
          const te = this._drawAndSample({
            layers: v,
            views: t,
            viewports: i,
            onViewportActive: p,
            deviceRect: O,
            cullRect: U,
            effects: _,
            pass: `picking:${h}`
          });
          ee = H4({
            ...te,
            deviceX: E[0],
            deviceY: E[1],
            deviceRadius: M,
            deviceRect: O
          });
        } else ee = {
          pickedColor: null,
          pickedObjectIndex: -1
        };
        let fe;
        if (ee.pickedLayer && d && this.depthFBO) {
          const { pickedColors: te } = this._drawAndSample({
            layers: [
              ee.pickedLayer
            ],
            views: t,
            viewports: i,
            onViewportActive: p,
            deviceRect: {
              x: ee.pickedX,
              y: ee.pickedY,
              width: 1,
              height: 1
            },
            cullRect: U,
            effects: _,
            pass: `picking:${h}:z`
          }, true);
          te[3] && (fe = te[0]);
        }
        ee.pickedLayer && le + 1 < u && (re.add(ee.pickedLayer), ee.pickedLayer.disablePickingIndex(ee.pickedObjectIndex)), B = W4({
          pickInfo: ee,
          lastPickedInfo: this.lastPickedInfo,
          mode: h,
          layers: v,
          viewports: i,
          x: s,
          y: a,
          z: fe,
          pixelRatio: y
        });
        for (const te of B.values()) te.layer && Z.push(te);
        if (!ee.pickedColor) break;
      }
      for (const le of re) le.restorePickingColors();
      return {
        result: Z,
        emptyInfo: B.get(null)
      };
    }
    _pickVisibleObjects({ layers: e, views: t, viewports: i, x: s, y: a, width: l = 1, height: u = 1, mode: h = "query", maxObjects: d = null, onViewportActive: p, effects: _ }) {
      const y = this._getPickable(e);
      if (!y || i.length === 0) return [];
      this._resizeBuffer();
      const v = this.device.canvasContext.cssToDeviceRatio(), S = this.device.canvasContext.cssToDevicePixels([
        s,
        a
      ], true), E = S.x, M = S.y + S.height, F = this.device.canvasContext.cssToDevicePixels([
        s + l,
        a + u
      ], true), H = F.x + F.width, O = F.y, U = {
        x: E,
        y: O,
        width: H - E,
        height: M - O
      }, B = this._drawAndSample({
        layers: y,
        views: t,
        viewports: i,
        onViewportActive: p,
        deviceRect: U,
        cullRect: {
          x: s,
          y: a,
          width: l,
          height: u
        },
        effects: _,
        pass: `picking:${h}`
      }), Z = j4(B), re = /* @__PURE__ */ new Map(), le = [], ee = Number.isFinite(d);
      for (let fe = 0; fe < Z.length && !(ee && le.length >= d); fe++) {
        const te = Z[fe];
        let ye = {
          color: te.pickedColor,
          layer: null,
          index: te.pickedObjectIndex,
          picked: true,
          x: s,
          y: a,
          pixelRatio: v
        };
        ye = X2({
          layer: te.pickedLayer,
          info: ye,
          mode: h
        });
        const xe = ye.layer.id;
        re.has(xe) || re.set(xe, /* @__PURE__ */ new Set());
        const ve = re.get(xe), Ue = ye.object ?? ye.index;
        ve.has(Ue) || (ve.add(Ue), le.push(ye));
      }
      return le;
    }
    _drawAndSample({ layers: e, views: t, viewports: i, onViewportActive: s, deviceRect: a, cullRect: l, effects: u, pass: h }, d = false) {
      const p = d ? this.depthFBO : this.pickingFBO, _ = {
        layers: e,
        layerFilter: this.layerFilter,
        views: t,
        viewports: i,
        onViewportActive: s,
        pickingFBO: p,
        deviceRect: a,
        cullRect: l,
        effects: u,
        pass: h,
        pickZ: d,
        preRenderStats: {},
        isPicking: true
      };
      for (const H of u) H.useInPicking && (_.preRenderStats[H.id] = H.preRender(_));
      const { decodePickingColor: y } = this.pickLayersPass.render(_), { x: v, y: S, width: E, height: M } = a, F = new (d ? Float32Array : Uint8Array)(E * M * 4);
      return this.device.readPixelsToArrayWebGL(p, {
        sourceX: v,
        sourceY: S,
        sourceWidth: E,
        sourceHeight: M,
        target: F
      }), {
        pickedColors: F,
        decodePickingColor: y
      };
    }
    _getPickingRect({ deviceX: e, deviceY: t, deviceRadius: i, deviceWidth: s, deviceHeight: a }) {
      const l = Math.max(0, e - i), u = Math.max(0, t - i), h = Math.min(s, e + i + 1) - l, d = Math.min(a, t + i + 1) - u;
      return h <= 0 || d <= 0 ? null : {
        x: l,
        y: u,
        width: h,
        height: d
      };
    }
  }
  const Y4 = {
    "top-left": {
      top: 0,
      left: 0
    },
    "top-right": {
      top: 0,
      right: 0
    },
    "bottom-left": {
      bottom: 0,
      left: 0
    },
    "bottom-right": {
      bottom: 0,
      right: 0
    },
    fill: {
      top: 0,
      left: 0,
      bottom: 0,
      right: 0
    }
  }, q4 = "top-left", D0 = "__root";
  class K4 {
    constructor({ deck: e, parentElement: t }) {
      this.defaultWidgets = [], this.widgets = [], this.resolvedWidgets = [], this.containers = {}, this.lastViewports = {}, this.deck = e, this.parentElement = t;
    }
    getWidgets() {
      return this.resolvedWidgets;
    }
    setProps(e) {
      e.widgets && !Ft(e.widgets, this.widgets, 1) && this._setWidgets(e.widgets);
    }
    finalize() {
      for (const e of this.getWidgets()) this._remove(e);
      this.defaultWidgets.length = 0, this.resolvedWidgets.length = 0;
      for (const e in this.containers) this.containers[e].remove();
    }
    addDefault(e) {
      this.defaultWidgets.find((t) => t.id === e.id) || (this._add(e), this.defaultWidgets.push(e), this._setWidgets(this.widgets));
    }
    _setWidgets(e) {
      const t = {};
      for (const i of this.resolvedWidgets) t[i.id] = i;
      this.resolvedWidgets.length = 0;
      for (const i of this.defaultWidgets) t[i.id] = null, this.resolvedWidgets.push(i);
      for (let i of e) {
        const s = t[i.id];
        s ? s.viewId !== i.viewId || s.placement !== i.placement ? (this._remove(s), this._add(i)) : i !== s && (s.setProps(i.props), i = s) : this._add(i), t[i.id] = null, this.resolvedWidgets.push(i);
      }
      for (const i in t) {
        const s = t[i];
        s && this._remove(s);
      }
      this.widgets = e;
    }
    _add(e) {
      const { viewId: t = null, placement: i = q4 } = e, s = e.onAdd({
        deck: this.deck,
        viewId: t
      });
      s && this._getContainer(t, i).append(s), e._element = s;
    }
    _remove(e) {
      var _a2;
      (_a2 = e.onRemove) == null ? void 0 : _a2.call(e), e._element && e._element.remove(), e._element = void 0;
    }
    _getContainer(e, t) {
      var _a2;
      const i = e || D0;
      let s = this.containers[i];
      s || (s = document.createElement("div"), s.style.pointerEvents = "none", s.style.position = "absolute", s.style.overflow = "hidden", (_a2 = this.parentElement) == null ? void 0 : _a2.append(s), this.containers[i] = s);
      let a = s.querySelector(`.${t}`);
      return a || (a = document.createElement("div"), a.className = t, a.style.position = "absolute", a.style.zIndex = "2", Object.assign(a.style, Y4[t]), s.append(a)), a;
    }
    _updateContainers() {
      const e = this.deck.width, t = this.deck.height;
      for (const i in this.containers) {
        const s = this.lastViewports[i] || null, a = i === D0 || s, l = this.containers[i];
        a ? (l.style.display = "block", l.style.left = `${s ? s.x : 0}px`, l.style.top = `${s ? s.y : 0}px`, l.style.width = `${s ? s.width : e}px`, l.style.height = `${s ? s.height : t}px`) : l.style.display = "none";
      }
    }
    onRedraw({ viewports: e, layers: t }) {
      var _a2, _b3;
      const i = e.reduce((s, a) => (s[a.id] = a, s), {});
      for (const s of this.getWidgets()) {
        const { viewId: a } = s;
        if (a) {
          const l = i[a];
          l && (s.onViewportChange && s.onViewportChange(l), (_a2 = s.onRedraw) == null ? void 0 : _a2.call(s, {
            viewports: [
              l
            ],
            layers: t
          }));
        } else {
          if (s.onViewportChange) for (const l of e) s.onViewportChange(l);
          (_b3 = s.onRedraw) == null ? void 0 : _b3.call(s, {
            viewports: e,
            layers: t
          });
        }
      }
      this.lastViewports = i, this._updateContainers();
    }
    onHover(e, t) {
      var _a2, _b3;
      for (const i of this.getWidgets()) {
        const { viewId: s } = i;
        (!s || s === ((_a2 = e.viewport) == null ? void 0 : _a2.id)) && ((_b3 = i.onHover) == null ? void 0 : _b3.call(i, e, t));
      }
    }
    onEvent(e, t) {
      var _a2, _b3;
      const i = Od[t.type];
      if (i) for (const s of this.getWidgets()) {
        const { viewId: a } = s;
        (!a || a === ((_a2 = e.viewport) == null ? void 0 : _a2.id)) && ((_b3 = s[i]) == null ? void 0 : _b3.call(s, e, t));
      }
    }
  }
  const Z4 = {
    zIndex: "1",
    position: "absolute",
    pointerEvents: "none",
    color: "#a0a7b4",
    backgroundColor: "#29323c",
    padding: "10px",
    top: "0",
    left: "0",
    display: "none"
  };
  class Q4 {
    constructor() {
      this.id = "default-tooltip", this.placement = "fill", this.props = {}, this.isVisible = false;
    }
    onAdd({ deck: e }) {
      const t = document.createElement("div");
      return t.className = "deck-tooltip", Object.assign(t.style, Z4), this.deck = e, this.element = t, t;
    }
    onRemove() {
      this.deck = void 0, this.element = void 0;
    }
    setProps() {
    }
    onViewportChange(e) {
      var _a2;
      this.isVisible && e.id === ((_a2 = this.lastViewport) == null ? void 0 : _a2.id) && e !== this.lastViewport && this.setTooltip(null);
    }
    onHover(e) {
      const { deck: t } = this, i = t && t.props.getTooltip;
      if (!i) return;
      const s = i(e);
      this.lastViewport = e.viewport, this.setTooltip(s, e.x, e.y);
    }
    setTooltip(e, t, i) {
      const s = this.element;
      if (s) {
        if (typeof e == "string") s.innerText = e;
        else if (e) e.text && (s.innerText = e.text), e.html && (s.innerHTML = e.html), e.className && (s.className = e.className);
        else {
          this.isVisible = false, s.style.display = "none";
          return;
        }
        this.isVisible = true, s.style.display = "block", s.style.transform = `translate(${t}px, ${i}px)`, e && typeof e == "object" && "style" in e && Object.assign(s.style, e.style);
      }
    }
  }
  var Or;
  (function(n) {
    n[n.DEPTH_BUFFER_BIT = 256] = "DEPTH_BUFFER_BIT", n[n.STENCIL_BUFFER_BIT = 1024] = "STENCIL_BUFFER_BIT", n[n.COLOR_BUFFER_BIT = 16384] = "COLOR_BUFFER_BIT", n[n.POINTS = 0] = "POINTS", n[n.LINES = 1] = "LINES", n[n.LINE_LOOP = 2] = "LINE_LOOP", n[n.LINE_STRIP = 3] = "LINE_STRIP", n[n.TRIANGLES = 4] = "TRIANGLES", n[n.TRIANGLE_STRIP = 5] = "TRIANGLE_STRIP", n[n.TRIANGLE_FAN = 6] = "TRIANGLE_FAN", n[n.ZERO = 0] = "ZERO", n[n.ONE = 1] = "ONE", n[n.SRC_COLOR = 768] = "SRC_COLOR", n[n.ONE_MINUS_SRC_COLOR = 769] = "ONE_MINUS_SRC_COLOR", n[n.SRC_ALPHA = 770] = "SRC_ALPHA", n[n.ONE_MINUS_SRC_ALPHA = 771] = "ONE_MINUS_SRC_ALPHA", n[n.DST_ALPHA = 772] = "DST_ALPHA", n[n.ONE_MINUS_DST_ALPHA = 773] = "ONE_MINUS_DST_ALPHA", n[n.DST_COLOR = 774] = "DST_COLOR", n[n.ONE_MINUS_DST_COLOR = 775] = "ONE_MINUS_DST_COLOR", n[n.SRC_ALPHA_SATURATE = 776] = "SRC_ALPHA_SATURATE", n[n.CONSTANT_COLOR = 32769] = "CONSTANT_COLOR", n[n.ONE_MINUS_CONSTANT_COLOR = 32770] = "ONE_MINUS_CONSTANT_COLOR", n[n.CONSTANT_ALPHA = 32771] = "CONSTANT_ALPHA", n[n.ONE_MINUS_CONSTANT_ALPHA = 32772] = "ONE_MINUS_CONSTANT_ALPHA", n[n.FUNC_ADD = 32774] = "FUNC_ADD", n[n.FUNC_SUBTRACT = 32778] = "FUNC_SUBTRACT", n[n.FUNC_REVERSE_SUBTRACT = 32779] = "FUNC_REVERSE_SUBTRACT", n[n.BLEND_EQUATION = 32777] = "BLEND_EQUATION", n[n.BLEND_EQUATION_RGB = 32777] = "BLEND_EQUATION_RGB", n[n.BLEND_EQUATION_ALPHA = 34877] = "BLEND_EQUATION_ALPHA", n[n.BLEND_DST_RGB = 32968] = "BLEND_DST_RGB", n[n.BLEND_SRC_RGB = 32969] = "BLEND_SRC_RGB", n[n.BLEND_DST_ALPHA = 32970] = "BLEND_DST_ALPHA", n[n.BLEND_SRC_ALPHA = 32971] = "BLEND_SRC_ALPHA", n[n.BLEND_COLOR = 32773] = "BLEND_COLOR", n[n.ARRAY_BUFFER_BINDING = 34964] = "ARRAY_BUFFER_BINDING", n[n.ELEMENT_ARRAY_BUFFER_BINDING = 34965] = "ELEMENT_ARRAY_BUFFER_BINDING", n[n.LINE_WIDTH = 2849] = "LINE_WIDTH", n[n.ALIASED_POINT_SIZE_RANGE = 33901] = "ALIASED_POINT_SIZE_RANGE", n[n.ALIASED_LINE_WIDTH_RANGE = 33902] = "ALIASED_LINE_WIDTH_RANGE", n[n.CULL_FACE_MODE = 2885] = "CULL_FACE_MODE", n[n.FRONT_FACE = 2886] = "FRONT_FACE", n[n.DEPTH_RANGE = 2928] = "DEPTH_RANGE", n[n.DEPTH_WRITEMASK = 2930] = "DEPTH_WRITEMASK", n[n.DEPTH_CLEAR_VALUE = 2931] = "DEPTH_CLEAR_VALUE", n[n.DEPTH_FUNC = 2932] = "DEPTH_FUNC", n[n.STENCIL_CLEAR_VALUE = 2961] = "STENCIL_CLEAR_VALUE", n[n.STENCIL_FUNC = 2962] = "STENCIL_FUNC", n[n.STENCIL_FAIL = 2964] = "STENCIL_FAIL", n[n.STENCIL_PASS_DEPTH_FAIL = 2965] = "STENCIL_PASS_DEPTH_FAIL", n[n.STENCIL_PASS_DEPTH_PASS = 2966] = "STENCIL_PASS_DEPTH_PASS", n[n.STENCIL_REF = 2967] = "STENCIL_REF", n[n.STENCIL_VALUE_MASK = 2963] = "STENCIL_VALUE_MASK", n[n.STENCIL_WRITEMASK = 2968] = "STENCIL_WRITEMASK", n[n.STENCIL_BACK_FUNC = 34816] = "STENCIL_BACK_FUNC", n[n.STENCIL_BACK_FAIL = 34817] = "STENCIL_BACK_FAIL", n[n.STENCIL_BACK_PASS_DEPTH_FAIL = 34818] = "STENCIL_BACK_PASS_DEPTH_FAIL", n[n.STENCIL_BACK_PASS_DEPTH_PASS = 34819] = "STENCIL_BACK_PASS_DEPTH_PASS", n[n.STENCIL_BACK_REF = 36003] = "STENCIL_BACK_REF", n[n.STENCIL_BACK_VALUE_MASK = 36004] = "STENCIL_BACK_VALUE_MASK", n[n.STENCIL_BACK_WRITEMASK = 36005] = "STENCIL_BACK_WRITEMASK", n[n.VIEWPORT = 2978] = "VIEWPORT", n[n.SCISSOR_BOX = 3088] = "SCISSOR_BOX", n[n.COLOR_CLEAR_VALUE = 3106] = "COLOR_CLEAR_VALUE", n[n.COLOR_WRITEMASK = 3107] = "COLOR_WRITEMASK", n[n.UNPACK_ALIGNMENT = 3317] = "UNPACK_ALIGNMENT", n[n.PACK_ALIGNMENT = 3333] = "PACK_ALIGNMENT", n[n.MAX_TEXTURE_SIZE = 3379] = "MAX_TEXTURE_SIZE", n[n.MAX_VIEWPORT_DIMS = 3386] = "MAX_VIEWPORT_DIMS", n[n.SUBPIXEL_BITS = 3408] = "SUBPIXEL_BITS", n[n.RED_BITS = 3410] = "RED_BITS", n[n.GREEN_BITS = 3411] = "GREEN_BITS", n[n.BLUE_BITS = 3412] = "BLUE_BITS", n[n.ALPHA_BITS = 3413] = "ALPHA_BITS", n[n.DEPTH_BITS = 3414] = "DEPTH_BITS", n[n.STENCIL_BITS = 3415] = "STENCIL_BITS", n[n.POLYGON_OFFSET_UNITS = 10752] = "POLYGON_OFFSET_UNITS", n[n.POLYGON_OFFSET_FACTOR = 32824] = "POLYGON_OFFSET_FACTOR", n[n.TEXTURE_BINDING_2D = 32873] = "TEXTURE_BINDING_2D", n[n.SAMPLE_BUFFERS = 32936] = "SAMPLE_BUFFERS", n[n.SAMPLES = 32937] = "SAMPLES", n[n.SAMPLE_COVERAGE_VALUE = 32938] = "SAMPLE_COVERAGE_VALUE", n[n.SAMPLE_COVERAGE_INVERT = 32939] = "SAMPLE_COVERAGE_INVERT", n[n.COMPRESSED_TEXTURE_FORMATS = 34467] = "COMPRESSED_TEXTURE_FORMATS", n[n.VENDOR = 7936] = "VENDOR", n[n.RENDERER = 7937] = "RENDERER", n[n.VERSION = 7938] = "VERSION", n[n.IMPLEMENTATION_COLOR_READ_TYPE = 35738] = "IMPLEMENTATION_COLOR_READ_TYPE", n[n.IMPLEMENTATION_COLOR_READ_FORMAT = 35739] = "IMPLEMENTATION_COLOR_READ_FORMAT", n[n.BROWSER_DEFAULT_WEBGL = 37444] = "BROWSER_DEFAULT_WEBGL", n[n.STATIC_DRAW = 35044] = "STATIC_DRAW", n[n.STREAM_DRAW = 35040] = "STREAM_DRAW", n[n.DYNAMIC_DRAW = 35048] = "DYNAMIC_DRAW", n[n.ARRAY_BUFFER = 34962] = "ARRAY_BUFFER", n[n.ELEMENT_ARRAY_BUFFER = 34963] = "ELEMENT_ARRAY_BUFFER", n[n.BUFFER_SIZE = 34660] = "BUFFER_SIZE", n[n.BUFFER_USAGE = 34661] = "BUFFER_USAGE", n[n.CURRENT_VERTEX_ATTRIB = 34342] = "CURRENT_VERTEX_ATTRIB", n[n.VERTEX_ATTRIB_ARRAY_ENABLED = 34338] = "VERTEX_ATTRIB_ARRAY_ENABLED", n[n.VERTEX_ATTRIB_ARRAY_SIZE = 34339] = "VERTEX_ATTRIB_ARRAY_SIZE", n[n.VERTEX_ATTRIB_ARRAY_STRIDE = 34340] = "VERTEX_ATTRIB_ARRAY_STRIDE", n[n.VERTEX_ATTRIB_ARRAY_TYPE = 34341] = "VERTEX_ATTRIB_ARRAY_TYPE", n[n.VERTEX_ATTRIB_ARRAY_NORMALIZED = 34922] = "VERTEX_ATTRIB_ARRAY_NORMALIZED", n[n.VERTEX_ATTRIB_ARRAY_POINTER = 34373] = "VERTEX_ATTRIB_ARRAY_POINTER", n[n.VERTEX_ATTRIB_ARRAY_BUFFER_BINDING = 34975] = "VERTEX_ATTRIB_ARRAY_BUFFER_BINDING", n[n.CULL_FACE = 2884] = "CULL_FACE", n[n.FRONT = 1028] = "FRONT", n[n.BACK = 1029] = "BACK", n[n.FRONT_AND_BACK = 1032] = "FRONT_AND_BACK", n[n.BLEND = 3042] = "BLEND", n[n.DEPTH_TEST = 2929] = "DEPTH_TEST", n[n.DITHER = 3024] = "DITHER", n[n.POLYGON_OFFSET_FILL = 32823] = "POLYGON_OFFSET_FILL", n[n.SAMPLE_ALPHA_TO_COVERAGE = 32926] = "SAMPLE_ALPHA_TO_COVERAGE", n[n.SAMPLE_COVERAGE = 32928] = "SAMPLE_COVERAGE", n[n.SCISSOR_TEST = 3089] = "SCISSOR_TEST", n[n.STENCIL_TEST = 2960] = "STENCIL_TEST", n[n.NO_ERROR = 0] = "NO_ERROR", n[n.INVALID_ENUM = 1280] = "INVALID_ENUM", n[n.INVALID_VALUE = 1281] = "INVALID_VALUE", n[n.INVALID_OPERATION = 1282] = "INVALID_OPERATION", n[n.OUT_OF_MEMORY = 1285] = "OUT_OF_MEMORY", n[n.CONTEXT_LOST_WEBGL = 37442] = "CONTEXT_LOST_WEBGL", n[n.CW = 2304] = "CW", n[n.CCW = 2305] = "CCW", n[n.DONT_CARE = 4352] = "DONT_CARE", n[n.FASTEST = 4353] = "FASTEST", n[n.NICEST = 4354] = "NICEST", n[n.GENERATE_MIPMAP_HINT = 33170] = "GENERATE_MIPMAP_HINT", n[n.BYTE = 5120] = "BYTE", n[n.UNSIGNED_BYTE = 5121] = "UNSIGNED_BYTE", n[n.SHORT = 5122] = "SHORT", n[n.UNSIGNED_SHORT = 5123] = "UNSIGNED_SHORT", n[n.INT = 5124] = "INT", n[n.UNSIGNED_INT = 5125] = "UNSIGNED_INT", n[n.FLOAT = 5126] = "FLOAT", n[n.DOUBLE = 5130] = "DOUBLE", n[n.DEPTH_COMPONENT = 6402] = "DEPTH_COMPONENT", n[n.ALPHA = 6406] = "ALPHA", n[n.RGB = 6407] = "RGB", n[n.RGBA = 6408] = "RGBA", n[n.LUMINANCE = 6409] = "LUMINANCE", n[n.LUMINANCE_ALPHA = 6410] = "LUMINANCE_ALPHA", n[n.UNSIGNED_SHORT_4_4_4_4 = 32819] = "UNSIGNED_SHORT_4_4_4_4", n[n.UNSIGNED_SHORT_5_5_5_1 = 32820] = "UNSIGNED_SHORT_5_5_5_1", n[n.UNSIGNED_SHORT_5_6_5 = 33635] = "UNSIGNED_SHORT_5_6_5", n[n.FRAGMENT_SHADER = 35632] = "FRAGMENT_SHADER", n[n.VERTEX_SHADER = 35633] = "VERTEX_SHADER", n[n.COMPILE_STATUS = 35713] = "COMPILE_STATUS", n[n.DELETE_STATUS = 35712] = "DELETE_STATUS", n[n.LINK_STATUS = 35714] = "LINK_STATUS", n[n.VALIDATE_STATUS = 35715] = "VALIDATE_STATUS", n[n.ATTACHED_SHADERS = 35717] = "ATTACHED_SHADERS", n[n.ACTIVE_ATTRIBUTES = 35721] = "ACTIVE_ATTRIBUTES", n[n.ACTIVE_UNIFORMS = 35718] = "ACTIVE_UNIFORMS", n[n.MAX_VERTEX_ATTRIBS = 34921] = "MAX_VERTEX_ATTRIBS", n[n.MAX_VERTEX_UNIFORM_VECTORS = 36347] = "MAX_VERTEX_UNIFORM_VECTORS", n[n.MAX_VARYING_VECTORS = 36348] = "MAX_VARYING_VECTORS", n[n.MAX_COMBINED_TEXTURE_IMAGE_UNITS = 35661] = "MAX_COMBINED_TEXTURE_IMAGE_UNITS", n[n.MAX_VERTEX_TEXTURE_IMAGE_UNITS = 35660] = "MAX_VERTEX_TEXTURE_IMAGE_UNITS", n[n.MAX_TEXTURE_IMAGE_UNITS = 34930] = "MAX_TEXTURE_IMAGE_UNITS", n[n.MAX_FRAGMENT_UNIFORM_VECTORS = 36349] = "MAX_FRAGMENT_UNIFORM_VECTORS", n[n.SHADER_TYPE = 35663] = "SHADER_TYPE", n[n.SHADING_LANGUAGE_VERSION = 35724] = "SHADING_LANGUAGE_VERSION", n[n.CURRENT_PROGRAM = 35725] = "CURRENT_PROGRAM", n[n.NEVER = 512] = "NEVER", n[n.LESS = 513] = "LESS", n[n.EQUAL = 514] = "EQUAL", n[n.LEQUAL = 515] = "LEQUAL", n[n.GREATER = 516] = "GREATER", n[n.NOTEQUAL = 517] = "NOTEQUAL", n[n.GEQUAL = 518] = "GEQUAL", n[n.ALWAYS = 519] = "ALWAYS", n[n.KEEP = 7680] = "KEEP", n[n.REPLACE = 7681] = "REPLACE", n[n.INCR = 7682] = "INCR", n[n.DECR = 7683] = "DECR", n[n.INVERT = 5386] = "INVERT", n[n.INCR_WRAP = 34055] = "INCR_WRAP", n[n.DECR_WRAP = 34056] = "DECR_WRAP", n[n.NEAREST = 9728] = "NEAREST", n[n.LINEAR = 9729] = "LINEAR", n[n.NEAREST_MIPMAP_NEAREST = 9984] = "NEAREST_MIPMAP_NEAREST", n[n.LINEAR_MIPMAP_NEAREST = 9985] = "LINEAR_MIPMAP_NEAREST", n[n.NEAREST_MIPMAP_LINEAR = 9986] = "NEAREST_MIPMAP_LINEAR", n[n.LINEAR_MIPMAP_LINEAR = 9987] = "LINEAR_MIPMAP_LINEAR", n[n.TEXTURE_MAG_FILTER = 10240] = "TEXTURE_MAG_FILTER", n[n.TEXTURE_MIN_FILTER = 10241] = "TEXTURE_MIN_FILTER", n[n.TEXTURE_WRAP_S = 10242] = "TEXTURE_WRAP_S", n[n.TEXTURE_WRAP_T = 10243] = "TEXTURE_WRAP_T", n[n.TEXTURE_2D = 3553] = "TEXTURE_2D", n[n.TEXTURE = 5890] = "TEXTURE", n[n.TEXTURE_CUBE_MAP = 34067] = "TEXTURE_CUBE_MAP", n[n.TEXTURE_BINDING_CUBE_MAP = 34068] = "TEXTURE_BINDING_CUBE_MAP", n[n.TEXTURE_CUBE_MAP_POSITIVE_X = 34069] = "TEXTURE_CUBE_MAP_POSITIVE_X", n[n.TEXTURE_CUBE_MAP_NEGATIVE_X = 34070] = "TEXTURE_CUBE_MAP_NEGATIVE_X", n[n.TEXTURE_CUBE_MAP_POSITIVE_Y = 34071] = "TEXTURE_CUBE_MAP_POSITIVE_Y", n[n.TEXTURE_CUBE_MAP_NEGATIVE_Y = 34072] = "TEXTURE_CUBE_MAP_NEGATIVE_Y", n[n.TEXTURE_CUBE_MAP_POSITIVE_Z = 34073] = "TEXTURE_CUBE_MAP_POSITIVE_Z", n[n.TEXTURE_CUBE_MAP_NEGATIVE_Z = 34074] = "TEXTURE_CUBE_MAP_NEGATIVE_Z", n[n.MAX_CUBE_MAP_TEXTURE_SIZE = 34076] = "MAX_CUBE_MAP_TEXTURE_SIZE", n[n.TEXTURE0 = 33984] = "TEXTURE0", n[n.ACTIVE_TEXTURE = 34016] = "ACTIVE_TEXTURE", n[n.REPEAT = 10497] = "REPEAT", n[n.CLAMP_TO_EDGE = 33071] = "CLAMP_TO_EDGE", n[n.MIRRORED_REPEAT = 33648] = "MIRRORED_REPEAT", n[n.TEXTURE_WIDTH = 4096] = "TEXTURE_WIDTH", n[n.TEXTURE_HEIGHT = 4097] = "TEXTURE_HEIGHT", n[n.FLOAT_VEC2 = 35664] = "FLOAT_VEC2", n[n.FLOAT_VEC3 = 35665] = "FLOAT_VEC3", n[n.FLOAT_VEC4 = 35666] = "FLOAT_VEC4", n[n.INT_VEC2 = 35667] = "INT_VEC2", n[n.INT_VEC3 = 35668] = "INT_VEC3", n[n.INT_VEC4 = 35669] = "INT_VEC4", n[n.BOOL = 35670] = "BOOL", n[n.BOOL_VEC2 = 35671] = "BOOL_VEC2", n[n.BOOL_VEC3 = 35672] = "BOOL_VEC3", n[n.BOOL_VEC4 = 35673] = "BOOL_VEC4", n[n.FLOAT_MAT2 = 35674] = "FLOAT_MAT2", n[n.FLOAT_MAT3 = 35675] = "FLOAT_MAT3", n[n.FLOAT_MAT4 = 35676] = "FLOAT_MAT4", n[n.SAMPLER_2D = 35678] = "SAMPLER_2D", n[n.SAMPLER_CUBE = 35680] = "SAMPLER_CUBE", n[n.LOW_FLOAT = 36336] = "LOW_FLOAT", n[n.MEDIUM_FLOAT = 36337] = "MEDIUM_FLOAT", n[n.HIGH_FLOAT = 36338] = "HIGH_FLOAT", n[n.LOW_INT = 36339] = "LOW_INT", n[n.MEDIUM_INT = 36340] = "MEDIUM_INT", n[n.HIGH_INT = 36341] = "HIGH_INT", n[n.FRAMEBUFFER = 36160] = "FRAMEBUFFER", n[n.RENDERBUFFER = 36161] = "RENDERBUFFER", n[n.RGBA4 = 32854] = "RGBA4", n[n.RGB5_A1 = 32855] = "RGB5_A1", n[n.RGB565 = 36194] = "RGB565", n[n.DEPTH_COMPONENT16 = 33189] = "DEPTH_COMPONENT16", n[n.STENCIL_INDEX = 6401] = "STENCIL_INDEX", n[n.STENCIL_INDEX8 = 36168] = "STENCIL_INDEX8", n[n.DEPTH_STENCIL = 34041] = "DEPTH_STENCIL", n[n.RENDERBUFFER_WIDTH = 36162] = "RENDERBUFFER_WIDTH", n[n.RENDERBUFFER_HEIGHT = 36163] = "RENDERBUFFER_HEIGHT", n[n.RENDERBUFFER_INTERNAL_FORMAT = 36164] = "RENDERBUFFER_INTERNAL_FORMAT", n[n.RENDERBUFFER_RED_SIZE = 36176] = "RENDERBUFFER_RED_SIZE", n[n.RENDERBUFFER_GREEN_SIZE = 36177] = "RENDERBUFFER_GREEN_SIZE", n[n.RENDERBUFFER_BLUE_SIZE = 36178] = "RENDERBUFFER_BLUE_SIZE", n[n.RENDERBUFFER_ALPHA_SIZE = 36179] = "RENDERBUFFER_ALPHA_SIZE", n[n.RENDERBUFFER_DEPTH_SIZE = 36180] = "RENDERBUFFER_DEPTH_SIZE", n[n.RENDERBUFFER_STENCIL_SIZE = 36181] = "RENDERBUFFER_STENCIL_SIZE", n[n.FRAMEBUFFER_ATTACHMENT_OBJECT_TYPE = 36048] = "FRAMEBUFFER_ATTACHMENT_OBJECT_TYPE", n[n.FRAMEBUFFER_ATTACHMENT_OBJECT_NAME = 36049] = "FRAMEBUFFER_ATTACHMENT_OBJECT_NAME", n[n.FRAMEBUFFER_ATTACHMENT_TEXTURE_LEVEL = 36050] = "FRAMEBUFFER_ATTACHMENT_TEXTURE_LEVEL", n[n.FRAMEBUFFER_ATTACHMENT_TEXTURE_CUBE_MAP_FACE = 36051] = "FRAMEBUFFER_ATTACHMENT_TEXTURE_CUBE_MAP_FACE", n[n.COLOR_ATTACHMENT0 = 36064] = "COLOR_ATTACHMENT0", n[n.DEPTH_ATTACHMENT = 36096] = "DEPTH_ATTACHMENT", n[n.STENCIL_ATTACHMENT = 36128] = "STENCIL_ATTACHMENT", n[n.DEPTH_STENCIL_ATTACHMENT = 33306] = "DEPTH_STENCIL_ATTACHMENT", n[n.NONE = 0] = "NONE", n[n.FRAMEBUFFER_COMPLETE = 36053] = "FRAMEBUFFER_COMPLETE", n[n.FRAMEBUFFER_INCOMPLETE_ATTACHMENT = 36054] = "FRAMEBUFFER_INCOMPLETE_ATTACHMENT", n[n.FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT = 36055] = "FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT", n[n.FRAMEBUFFER_INCOMPLETE_DIMENSIONS = 36057] = "FRAMEBUFFER_INCOMPLETE_DIMENSIONS", n[n.FRAMEBUFFER_UNSUPPORTED = 36061] = "FRAMEBUFFER_UNSUPPORTED", n[n.FRAMEBUFFER_BINDING = 36006] = "FRAMEBUFFER_BINDING", n[n.RENDERBUFFER_BINDING = 36007] = "RENDERBUFFER_BINDING", n[n.READ_FRAMEBUFFER = 36008] = "READ_FRAMEBUFFER", n[n.DRAW_FRAMEBUFFER = 36009] = "DRAW_FRAMEBUFFER", n[n.MAX_RENDERBUFFER_SIZE = 34024] = "MAX_RENDERBUFFER_SIZE", n[n.INVALID_FRAMEBUFFER_OPERATION = 1286] = "INVALID_FRAMEBUFFER_OPERATION", n[n.UNPACK_FLIP_Y_WEBGL = 37440] = "UNPACK_FLIP_Y_WEBGL", n[n.UNPACK_PREMULTIPLY_ALPHA_WEBGL = 37441] = "UNPACK_PREMULTIPLY_ALPHA_WEBGL", n[n.UNPACK_COLORSPACE_CONVERSION_WEBGL = 37443] = "UNPACK_COLORSPACE_CONVERSION_WEBGL", n[n.READ_BUFFER = 3074] = "READ_BUFFER", n[n.UNPACK_ROW_LENGTH = 3314] = "UNPACK_ROW_LENGTH", n[n.UNPACK_SKIP_ROWS = 3315] = "UNPACK_SKIP_ROWS", n[n.UNPACK_SKIP_PIXELS = 3316] = "UNPACK_SKIP_PIXELS", n[n.PACK_ROW_LENGTH = 3330] = "PACK_ROW_LENGTH", n[n.PACK_SKIP_ROWS = 3331] = "PACK_SKIP_ROWS", n[n.PACK_SKIP_PIXELS = 3332] = "PACK_SKIP_PIXELS", n[n.TEXTURE_BINDING_3D = 32874] = "TEXTURE_BINDING_3D", n[n.UNPACK_SKIP_IMAGES = 32877] = "UNPACK_SKIP_IMAGES", n[n.UNPACK_IMAGE_HEIGHT = 32878] = "UNPACK_IMAGE_HEIGHT", n[n.MAX_3D_TEXTURE_SIZE = 32883] = "MAX_3D_TEXTURE_SIZE", n[n.MAX_ELEMENTS_VERTICES = 33e3] = "MAX_ELEMENTS_VERTICES", n[n.MAX_ELEMENTS_INDICES = 33001] = "MAX_ELEMENTS_INDICES", n[n.MAX_TEXTURE_LOD_BIAS = 34045] = "MAX_TEXTURE_LOD_BIAS", n[n.MAX_FRAGMENT_UNIFORM_COMPONENTS = 35657] = "MAX_FRAGMENT_UNIFORM_COMPONENTS", n[n.MAX_VERTEX_UNIFORM_COMPONENTS = 35658] = "MAX_VERTEX_UNIFORM_COMPONENTS", n[n.MAX_ARRAY_TEXTURE_LAYERS = 35071] = "MAX_ARRAY_TEXTURE_LAYERS", n[n.MIN_PROGRAM_TEXEL_OFFSET = 35076] = "MIN_PROGRAM_TEXEL_OFFSET", n[n.MAX_PROGRAM_TEXEL_OFFSET = 35077] = "MAX_PROGRAM_TEXEL_OFFSET", n[n.MAX_VARYING_COMPONENTS = 35659] = "MAX_VARYING_COMPONENTS", n[n.FRAGMENT_SHADER_DERIVATIVE_HINT = 35723] = "FRAGMENT_SHADER_DERIVATIVE_HINT", n[n.RASTERIZER_DISCARD = 35977] = "RASTERIZER_DISCARD", n[n.VERTEX_ARRAY_BINDING = 34229] = "VERTEX_ARRAY_BINDING", n[n.MAX_VERTEX_OUTPUT_COMPONENTS = 37154] = "MAX_VERTEX_OUTPUT_COMPONENTS", n[n.MAX_FRAGMENT_INPUT_COMPONENTS = 37157] = "MAX_FRAGMENT_INPUT_COMPONENTS", n[n.MAX_SERVER_WAIT_TIMEOUT = 37137] = "MAX_SERVER_WAIT_TIMEOUT", n[n.MAX_ELEMENT_INDEX = 36203] = "MAX_ELEMENT_INDEX", n[n.RED = 6403] = "RED", n[n.RGB8 = 32849] = "RGB8", n[n.RGBA8 = 32856] = "RGBA8", n[n.RGB10_A2 = 32857] = "RGB10_A2", n[n.TEXTURE_3D = 32879] = "TEXTURE_3D", n[n.TEXTURE_WRAP_R = 32882] = "TEXTURE_WRAP_R", n[n.TEXTURE_MIN_LOD = 33082] = "TEXTURE_MIN_LOD", n[n.TEXTURE_MAX_LOD = 33083] = "TEXTURE_MAX_LOD", n[n.TEXTURE_BASE_LEVEL = 33084] = "TEXTURE_BASE_LEVEL", n[n.TEXTURE_MAX_LEVEL = 33085] = "TEXTURE_MAX_LEVEL", n[n.TEXTURE_COMPARE_MODE = 34892] = "TEXTURE_COMPARE_MODE", n[n.TEXTURE_COMPARE_FUNC = 34893] = "TEXTURE_COMPARE_FUNC", n[n.SRGB = 35904] = "SRGB", n[n.SRGB8 = 35905] = "SRGB8", n[n.SRGB8_ALPHA8 = 35907] = "SRGB8_ALPHA8", n[n.COMPARE_REF_TO_TEXTURE = 34894] = "COMPARE_REF_TO_TEXTURE", n[n.RGBA32F = 34836] = "RGBA32F", n[n.RGB32F = 34837] = "RGB32F", n[n.RGBA16F = 34842] = "RGBA16F", n[n.RGB16F = 34843] = "RGB16F", n[n.TEXTURE_2D_ARRAY = 35866] = "TEXTURE_2D_ARRAY", n[n.TEXTURE_BINDING_2D_ARRAY = 35869] = "TEXTURE_BINDING_2D_ARRAY", n[n.R11F_G11F_B10F = 35898] = "R11F_G11F_B10F", n[n.RGB9_E5 = 35901] = "RGB9_E5", n[n.RGBA32UI = 36208] = "RGBA32UI", n[n.RGB32UI = 36209] = "RGB32UI", n[n.RGBA16UI = 36214] = "RGBA16UI", n[n.RGB16UI = 36215] = "RGB16UI", n[n.RGBA8UI = 36220] = "RGBA8UI", n[n.RGB8UI = 36221] = "RGB8UI", n[n.RGBA32I = 36226] = "RGBA32I", n[n.RGB32I = 36227] = "RGB32I", n[n.RGBA16I = 36232] = "RGBA16I", n[n.RGB16I = 36233] = "RGB16I", n[n.RGBA8I = 36238] = "RGBA8I", n[n.RGB8I = 36239] = "RGB8I", n[n.RED_INTEGER = 36244] = "RED_INTEGER", n[n.RGB_INTEGER = 36248] = "RGB_INTEGER", n[n.RGBA_INTEGER = 36249] = "RGBA_INTEGER", n[n.R8 = 33321] = "R8", n[n.RG8 = 33323] = "RG8", n[n.R16F = 33325] = "R16F", n[n.R32F = 33326] = "R32F", n[n.RG16F = 33327] = "RG16F", n[n.RG32F = 33328] = "RG32F", n[n.R8I = 33329] = "R8I", n[n.R8UI = 33330] = "R8UI", n[n.R16I = 33331] = "R16I", n[n.R16UI = 33332] = "R16UI", n[n.R32I = 33333] = "R32I", n[n.R32UI = 33334] = "R32UI", n[n.RG8I = 33335] = "RG8I", n[n.RG8UI = 33336] = "RG8UI", n[n.RG16I = 33337] = "RG16I", n[n.RG16UI = 33338] = "RG16UI", n[n.RG32I = 33339] = "RG32I", n[n.RG32UI = 33340] = "RG32UI", n[n.R8_SNORM = 36756] = "R8_SNORM", n[n.RG8_SNORM = 36757] = "RG8_SNORM", n[n.RGB8_SNORM = 36758] = "RGB8_SNORM", n[n.RGBA8_SNORM = 36759] = "RGBA8_SNORM", n[n.RGB10_A2UI = 36975] = "RGB10_A2UI", n[n.TEXTURE_IMMUTABLE_FORMAT = 37167] = "TEXTURE_IMMUTABLE_FORMAT", n[n.TEXTURE_IMMUTABLE_LEVELS = 33503] = "TEXTURE_IMMUTABLE_LEVELS", n[n.UNSIGNED_INT_2_10_10_10_REV = 33640] = "UNSIGNED_INT_2_10_10_10_REV", n[n.UNSIGNED_INT_10F_11F_11F_REV = 35899] = "UNSIGNED_INT_10F_11F_11F_REV", n[n.UNSIGNED_INT_5_9_9_9_REV = 35902] = "UNSIGNED_INT_5_9_9_9_REV", n[n.FLOAT_32_UNSIGNED_INT_24_8_REV = 36269] = "FLOAT_32_UNSIGNED_INT_24_8_REV", n[n.UNSIGNED_INT_24_8 = 34042] = "UNSIGNED_INT_24_8", n[n.HALF_FLOAT = 5131] = "HALF_FLOAT", n[n.RG = 33319] = "RG", n[n.RG_INTEGER = 33320] = "RG_INTEGER", n[n.INT_2_10_10_10_REV = 36255] = "INT_2_10_10_10_REV", n[n.CURRENT_QUERY = 34917] = "CURRENT_QUERY", n[n.QUERY_RESULT = 34918] = "QUERY_RESULT", n[n.QUERY_RESULT_AVAILABLE = 34919] = "QUERY_RESULT_AVAILABLE", n[n.ANY_SAMPLES_PASSED = 35887] = "ANY_SAMPLES_PASSED", n[n.ANY_SAMPLES_PASSED_CONSERVATIVE = 36202] = "ANY_SAMPLES_PASSED_CONSERVATIVE", n[n.MAX_DRAW_BUFFERS = 34852] = "MAX_DRAW_BUFFERS", n[n.DRAW_BUFFER0 = 34853] = "DRAW_BUFFER0", n[n.DRAW_BUFFER1 = 34854] = "DRAW_BUFFER1", n[n.DRAW_BUFFER2 = 34855] = "DRAW_BUFFER2", n[n.DRAW_BUFFER3 = 34856] = "DRAW_BUFFER3", n[n.DRAW_BUFFER4 = 34857] = "DRAW_BUFFER4", n[n.DRAW_BUFFER5 = 34858] = "DRAW_BUFFER5", n[n.DRAW_BUFFER6 = 34859] = "DRAW_BUFFER6", n[n.DRAW_BUFFER7 = 34860] = "DRAW_BUFFER7", n[n.DRAW_BUFFER8 = 34861] = "DRAW_BUFFER8", n[n.DRAW_BUFFER9 = 34862] = "DRAW_BUFFER9", n[n.DRAW_BUFFER10 = 34863] = "DRAW_BUFFER10", n[n.DRAW_BUFFER11 = 34864] = "DRAW_BUFFER11", n[n.DRAW_BUFFER12 = 34865] = "DRAW_BUFFER12", n[n.DRAW_BUFFER13 = 34866] = "DRAW_BUFFER13", n[n.DRAW_BUFFER14 = 34867] = "DRAW_BUFFER14", n[n.DRAW_BUFFER15 = 34868] = "DRAW_BUFFER15", n[n.MAX_COLOR_ATTACHMENTS = 36063] = "MAX_COLOR_ATTACHMENTS", n[n.COLOR_ATTACHMENT1 = 36065] = "COLOR_ATTACHMENT1", n[n.COLOR_ATTACHMENT2 = 36066] = "COLOR_ATTACHMENT2", n[n.COLOR_ATTACHMENT3 = 36067] = "COLOR_ATTACHMENT3", n[n.COLOR_ATTACHMENT4 = 36068] = "COLOR_ATTACHMENT4", n[n.COLOR_ATTACHMENT5 = 36069] = "COLOR_ATTACHMENT5", n[n.COLOR_ATTACHMENT6 = 36070] = "COLOR_ATTACHMENT6", n[n.COLOR_ATTACHMENT7 = 36071] = "COLOR_ATTACHMENT7", n[n.COLOR_ATTACHMENT8 = 36072] = "COLOR_ATTACHMENT8", n[n.COLOR_ATTACHMENT9 = 36073] = "COLOR_ATTACHMENT9", n[n.COLOR_ATTACHMENT10 = 36074] = "COLOR_ATTACHMENT10", n[n.COLOR_ATTACHMENT11 = 36075] = "COLOR_ATTACHMENT11", n[n.COLOR_ATTACHMENT12 = 36076] = "COLOR_ATTACHMENT12", n[n.COLOR_ATTACHMENT13 = 36077] = "COLOR_ATTACHMENT13", n[n.COLOR_ATTACHMENT14 = 36078] = "COLOR_ATTACHMENT14", n[n.COLOR_ATTACHMENT15 = 36079] = "COLOR_ATTACHMENT15", n[n.SAMPLER_3D = 35679] = "SAMPLER_3D", n[n.SAMPLER_2D_SHADOW = 35682] = "SAMPLER_2D_SHADOW", n[n.SAMPLER_2D_ARRAY = 36289] = "SAMPLER_2D_ARRAY", n[n.SAMPLER_2D_ARRAY_SHADOW = 36292] = "SAMPLER_2D_ARRAY_SHADOW", n[n.SAMPLER_CUBE_SHADOW = 36293] = "SAMPLER_CUBE_SHADOW", n[n.INT_SAMPLER_2D = 36298] = "INT_SAMPLER_2D", n[n.INT_SAMPLER_3D = 36299] = "INT_SAMPLER_3D", n[n.INT_SAMPLER_CUBE = 36300] = "INT_SAMPLER_CUBE", n[n.INT_SAMPLER_2D_ARRAY = 36303] = "INT_SAMPLER_2D_ARRAY", n[n.UNSIGNED_INT_SAMPLER_2D = 36306] = "UNSIGNED_INT_SAMPLER_2D", n[n.UNSIGNED_INT_SAMPLER_3D = 36307] = "UNSIGNED_INT_SAMPLER_3D", n[n.UNSIGNED_INT_SAMPLER_CUBE = 36308] = "UNSIGNED_INT_SAMPLER_CUBE", n[n.UNSIGNED_INT_SAMPLER_2D_ARRAY = 36311] = "UNSIGNED_INT_SAMPLER_2D_ARRAY", n[n.MAX_SAMPLES = 36183] = "MAX_SAMPLES", n[n.SAMPLER_BINDING = 35097] = "SAMPLER_BINDING", n[n.PIXEL_PACK_BUFFER = 35051] = "PIXEL_PACK_BUFFER", n[n.PIXEL_UNPACK_BUFFER = 35052] = "PIXEL_UNPACK_BUFFER", n[n.PIXEL_PACK_BUFFER_BINDING = 35053] = "PIXEL_PACK_BUFFER_BINDING", n[n.PIXEL_UNPACK_BUFFER_BINDING = 35055] = "PIXEL_UNPACK_BUFFER_BINDING", n[n.COPY_READ_BUFFER = 36662] = "COPY_READ_BUFFER", n[n.COPY_WRITE_BUFFER = 36663] = "COPY_WRITE_BUFFER", n[n.COPY_READ_BUFFER_BINDING = 36662] = "COPY_READ_BUFFER_BINDING", n[n.COPY_WRITE_BUFFER_BINDING = 36663] = "COPY_WRITE_BUFFER_BINDING", n[n.FLOAT_MAT2x3 = 35685] = "FLOAT_MAT2x3", n[n.FLOAT_MAT2x4 = 35686] = "FLOAT_MAT2x4", n[n.FLOAT_MAT3x2 = 35687] = "FLOAT_MAT3x2", n[n.FLOAT_MAT3x4 = 35688] = "FLOAT_MAT3x4", n[n.FLOAT_MAT4x2 = 35689] = "FLOAT_MAT4x2", n[n.FLOAT_MAT4x3 = 35690] = "FLOAT_MAT4x3", n[n.UNSIGNED_INT_VEC2 = 36294] = "UNSIGNED_INT_VEC2", n[n.UNSIGNED_INT_VEC3 = 36295] = "UNSIGNED_INT_VEC3", n[n.UNSIGNED_INT_VEC4 = 36296] = "UNSIGNED_INT_VEC4", n[n.UNSIGNED_NORMALIZED = 35863] = "UNSIGNED_NORMALIZED", n[n.SIGNED_NORMALIZED = 36764] = "SIGNED_NORMALIZED", n[n.VERTEX_ATTRIB_ARRAY_INTEGER = 35069] = "VERTEX_ATTRIB_ARRAY_INTEGER", n[n.VERTEX_ATTRIB_ARRAY_DIVISOR = 35070] = "VERTEX_ATTRIB_ARRAY_DIVISOR", n[n.TRANSFORM_FEEDBACK_BUFFER_MODE = 35967] = "TRANSFORM_FEEDBACK_BUFFER_MODE", n[n.MAX_TRANSFORM_FEEDBACK_SEPARATE_COMPONENTS = 35968] = "MAX_TRANSFORM_FEEDBACK_SEPARATE_COMPONENTS", n[n.TRANSFORM_FEEDBACK_VARYINGS = 35971] = "TRANSFORM_FEEDBACK_VARYINGS", n[n.TRANSFORM_FEEDBACK_BUFFER_START = 35972] = "TRANSFORM_FEEDBACK_BUFFER_START", n[n.TRANSFORM_FEEDBACK_BUFFER_SIZE = 35973] = "TRANSFORM_FEEDBACK_BUFFER_SIZE", n[n.TRANSFORM_FEEDBACK_PRIMITIVES_WRITTEN = 35976] = "TRANSFORM_FEEDBACK_PRIMITIVES_WRITTEN", n[n.MAX_TRANSFORM_FEEDBACK_INTERLEAVED_COMPONENTS = 35978] = "MAX_TRANSFORM_FEEDBACK_INTERLEAVED_COMPONENTS", n[n.MAX_TRANSFORM_FEEDBACK_SEPARATE_ATTRIBS = 35979] = "MAX_TRANSFORM_FEEDBACK_SEPARATE_ATTRIBS", n[n.INTERLEAVED_ATTRIBS = 35980] = "INTERLEAVED_ATTRIBS", n[n.SEPARATE_ATTRIBS = 35981] = "SEPARATE_ATTRIBS", n[n.TRANSFORM_FEEDBACK_BUFFER = 35982] = "TRANSFORM_FEEDBACK_BUFFER", n[n.TRANSFORM_FEEDBACK_BUFFER_BINDING = 35983] = "TRANSFORM_FEEDBACK_BUFFER_BINDING", n[n.TRANSFORM_FEEDBACK = 36386] = "TRANSFORM_FEEDBACK", n[n.TRANSFORM_FEEDBACK_PAUSED = 36387] = "TRANSFORM_FEEDBACK_PAUSED", n[n.TRANSFORM_FEEDBACK_ACTIVE = 36388] = "TRANSFORM_FEEDBACK_ACTIVE", n[n.TRANSFORM_FEEDBACK_BINDING = 36389] = "TRANSFORM_FEEDBACK_BINDING", n[n.FRAMEBUFFER_ATTACHMENT_COLOR_ENCODING = 33296] = "FRAMEBUFFER_ATTACHMENT_COLOR_ENCODING", n[n.FRAMEBUFFER_ATTACHMENT_COMPONENT_TYPE = 33297] = "FRAMEBUFFER_ATTACHMENT_COMPONENT_TYPE", n[n.FRAMEBUFFER_ATTACHMENT_RED_SIZE = 33298] = "FRAMEBUFFER_ATTACHMENT_RED_SIZE", n[n.FRAMEBUFFER_ATTACHMENT_GREEN_SIZE = 33299] = "FRAMEBUFFER_ATTACHMENT_GREEN_SIZE", n[n.FRAMEBUFFER_ATTACHMENT_BLUE_SIZE = 33300] = "FRAMEBUFFER_ATTACHMENT_BLUE_SIZE", n[n.FRAMEBUFFER_ATTACHMENT_ALPHA_SIZE = 33301] = "FRAMEBUFFER_ATTACHMENT_ALPHA_SIZE", n[n.FRAMEBUFFER_ATTACHMENT_DEPTH_SIZE = 33302] = "FRAMEBUFFER_ATTACHMENT_DEPTH_SIZE", n[n.FRAMEBUFFER_ATTACHMENT_STENCIL_SIZE = 33303] = "FRAMEBUFFER_ATTACHMENT_STENCIL_SIZE", n[n.FRAMEBUFFER_DEFAULT = 33304] = "FRAMEBUFFER_DEFAULT", n[n.DEPTH24_STENCIL8 = 35056] = "DEPTH24_STENCIL8", n[n.DRAW_FRAMEBUFFER_BINDING = 36006] = "DRAW_FRAMEBUFFER_BINDING", n[n.READ_FRAMEBUFFER_BINDING = 36010] = "READ_FRAMEBUFFER_BINDING", n[n.RENDERBUFFER_SAMPLES = 36011] = "RENDERBUFFER_SAMPLES", n[n.FRAMEBUFFER_ATTACHMENT_TEXTURE_LAYER = 36052] = "FRAMEBUFFER_ATTACHMENT_TEXTURE_LAYER", n[n.FRAMEBUFFER_INCOMPLETE_MULTISAMPLE = 36182] = "FRAMEBUFFER_INCOMPLETE_MULTISAMPLE", n[n.UNIFORM_BUFFER = 35345] = "UNIFORM_BUFFER", n[n.UNIFORM_BUFFER_BINDING = 35368] = "UNIFORM_BUFFER_BINDING", n[n.UNIFORM_BUFFER_START = 35369] = "UNIFORM_BUFFER_START", n[n.UNIFORM_BUFFER_SIZE = 35370] = "UNIFORM_BUFFER_SIZE", n[n.MAX_VERTEX_UNIFORM_BLOCKS = 35371] = "MAX_VERTEX_UNIFORM_BLOCKS", n[n.MAX_FRAGMENT_UNIFORM_BLOCKS = 35373] = "MAX_FRAGMENT_UNIFORM_BLOCKS", n[n.MAX_COMBINED_UNIFORM_BLOCKS = 35374] = "MAX_COMBINED_UNIFORM_BLOCKS", n[n.MAX_UNIFORM_BUFFER_BINDINGS = 35375] = "MAX_UNIFORM_BUFFER_BINDINGS", n[n.MAX_UNIFORM_BLOCK_SIZE = 35376] = "MAX_UNIFORM_BLOCK_SIZE", n[n.MAX_COMBINED_VERTEX_UNIFORM_COMPONENTS = 35377] = "MAX_COMBINED_VERTEX_UNIFORM_COMPONENTS", n[n.MAX_COMBINED_FRAGMENT_UNIFORM_COMPONENTS = 35379] = "MAX_COMBINED_FRAGMENT_UNIFORM_COMPONENTS", n[n.UNIFORM_BUFFER_OFFSET_ALIGNMENT = 35380] = "UNIFORM_BUFFER_OFFSET_ALIGNMENT", n[n.ACTIVE_UNIFORM_BLOCKS = 35382] = "ACTIVE_UNIFORM_BLOCKS", n[n.UNIFORM_TYPE = 35383] = "UNIFORM_TYPE", n[n.UNIFORM_SIZE = 35384] = "UNIFORM_SIZE", n[n.UNIFORM_BLOCK_INDEX = 35386] = "UNIFORM_BLOCK_INDEX", n[n.UNIFORM_OFFSET = 35387] = "UNIFORM_OFFSET", n[n.UNIFORM_ARRAY_STRIDE = 35388] = "UNIFORM_ARRAY_STRIDE", n[n.UNIFORM_MATRIX_STRIDE = 35389] = "UNIFORM_MATRIX_STRIDE", n[n.UNIFORM_IS_ROW_MAJOR = 35390] = "UNIFORM_IS_ROW_MAJOR", n[n.UNIFORM_BLOCK_BINDING = 35391] = "UNIFORM_BLOCK_BINDING", n[n.UNIFORM_BLOCK_DATA_SIZE = 35392] = "UNIFORM_BLOCK_DATA_SIZE", n[n.UNIFORM_BLOCK_ACTIVE_UNIFORMS = 35394] = "UNIFORM_BLOCK_ACTIVE_UNIFORMS", n[n.UNIFORM_BLOCK_ACTIVE_UNIFORM_INDICES = 35395] = "UNIFORM_BLOCK_ACTIVE_UNIFORM_INDICES", n[n.UNIFORM_BLOCK_REFERENCED_BY_VERTEX_SHADER = 35396] = "UNIFORM_BLOCK_REFERENCED_BY_VERTEX_SHADER", n[n.UNIFORM_BLOCK_REFERENCED_BY_FRAGMENT_SHADER = 35398] = "UNIFORM_BLOCK_REFERENCED_BY_FRAGMENT_SHADER", n[n.OBJECT_TYPE = 37138] = "OBJECT_TYPE", n[n.SYNC_CONDITION = 37139] = "SYNC_CONDITION", n[n.SYNC_STATUS = 37140] = "SYNC_STATUS", n[n.SYNC_FLAGS = 37141] = "SYNC_FLAGS", n[n.SYNC_FENCE = 37142] = "SYNC_FENCE", n[n.SYNC_GPU_COMMANDS_COMPLETE = 37143] = "SYNC_GPU_COMMANDS_COMPLETE", n[n.UNSIGNALED = 37144] = "UNSIGNALED", n[n.SIGNALED = 37145] = "SIGNALED", n[n.ALREADY_SIGNALED = 37146] = "ALREADY_SIGNALED", n[n.TIMEOUT_EXPIRED = 37147] = "TIMEOUT_EXPIRED", n[n.CONDITION_SATISFIED = 37148] = "CONDITION_SATISFIED", n[n.WAIT_FAILED = 37149] = "WAIT_FAILED", n[n.SYNC_FLUSH_COMMANDS_BIT = 1] = "SYNC_FLUSH_COMMANDS_BIT", n[n.COLOR = 6144] = "COLOR", n[n.DEPTH = 6145] = "DEPTH", n[n.STENCIL = 6146] = "STENCIL", n[n.MIN = 32775] = "MIN", n[n.MAX = 32776] = "MAX", n[n.DEPTH_COMPONENT24 = 33190] = "DEPTH_COMPONENT24", n[n.STREAM_READ = 35041] = "STREAM_READ", n[n.STREAM_COPY = 35042] = "STREAM_COPY", n[n.STATIC_READ = 35045] = "STATIC_READ", n[n.STATIC_COPY = 35046] = "STATIC_COPY", n[n.DYNAMIC_READ = 35049] = "DYNAMIC_READ", n[n.DYNAMIC_COPY = 35050] = "DYNAMIC_COPY", n[n.DEPTH_COMPONENT32F = 36012] = "DEPTH_COMPONENT32F", n[n.DEPTH32F_STENCIL8 = 36013] = "DEPTH32F_STENCIL8", n[n.INVALID_INDEX = 4294967295] = "INVALID_INDEX", n[n.TIMEOUT_IGNORED = -1] = "TIMEOUT_IGNORED", n[n.MAX_CLIENT_WAIT_TIMEOUT_WEBGL = 37447] = "MAX_CLIENT_WAIT_TIMEOUT_WEBGL", n[n.UNMASKED_VENDOR_WEBGL = 37445] = "UNMASKED_VENDOR_WEBGL", n[n.UNMASKED_RENDERER_WEBGL = 37446] = "UNMASKED_RENDERER_WEBGL", n[n.MAX_TEXTURE_MAX_ANISOTROPY_EXT = 34047] = "MAX_TEXTURE_MAX_ANISOTROPY_EXT", n[n.TEXTURE_MAX_ANISOTROPY_EXT = 34046] = "TEXTURE_MAX_ANISOTROPY_EXT", n[n.R16_EXT = 33322] = "R16_EXT", n[n.RG16_EXT = 33324] = "RG16_EXT", n[n.RGB16_EXT = 32852] = "RGB16_EXT", n[n.RGBA16_EXT = 32859] = "RGBA16_EXT", n[n.R16_SNORM_EXT = 36760] = "R16_SNORM_EXT", n[n.RG16_SNORM_EXT = 36761] = "RG16_SNORM_EXT", n[n.RGB16_SNORM_EXT = 36762] = "RGB16_SNORM_EXT", n[n.RGBA16_SNORM_EXT = 36763] = "RGBA16_SNORM_EXT", n[n.COMPRESSED_RGB_S3TC_DXT1_EXT = 33776] = "COMPRESSED_RGB_S3TC_DXT1_EXT", n[n.COMPRESSED_RGBA_S3TC_DXT1_EXT = 33777] = "COMPRESSED_RGBA_S3TC_DXT1_EXT", n[n.COMPRESSED_RGBA_S3TC_DXT3_EXT = 33778] = "COMPRESSED_RGBA_S3TC_DXT3_EXT", n[n.COMPRESSED_RGBA_S3TC_DXT5_EXT = 33779] = "COMPRESSED_RGBA_S3TC_DXT5_EXT", n[n.COMPRESSED_SRGB_S3TC_DXT1_EXT = 35916] = "COMPRESSED_SRGB_S3TC_DXT1_EXT", n[n.COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT = 35917] = "COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT", n[n.COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT = 35918] = "COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT", n[n.COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT = 35919] = "COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT", n[n.COMPRESSED_RED_RGTC1_EXT = 36283] = "COMPRESSED_RED_RGTC1_EXT", n[n.COMPRESSED_SIGNED_RED_RGTC1_EXT = 36284] = "COMPRESSED_SIGNED_RED_RGTC1_EXT", n[n.COMPRESSED_RED_GREEN_RGTC2_EXT = 36285] = "COMPRESSED_RED_GREEN_RGTC2_EXT", n[n.COMPRESSED_SIGNED_RED_GREEN_RGTC2_EXT = 36286] = "COMPRESSED_SIGNED_RED_GREEN_RGTC2_EXT", n[n.COMPRESSED_RGBA_BPTC_UNORM_EXT = 36492] = "COMPRESSED_RGBA_BPTC_UNORM_EXT", n[n.COMPRESSED_SRGB_ALPHA_BPTC_UNORM_EXT = 36493] = "COMPRESSED_SRGB_ALPHA_BPTC_UNORM_EXT", n[n.COMPRESSED_RGB_BPTC_SIGNED_FLOAT_EXT = 36494] = "COMPRESSED_RGB_BPTC_SIGNED_FLOAT_EXT", n[n.COMPRESSED_RGB_BPTC_UNSIGNED_FLOAT_EXT = 36495] = "COMPRESSED_RGB_BPTC_UNSIGNED_FLOAT_EXT", n[n.COMPRESSED_R11_EAC = 37488] = "COMPRESSED_R11_EAC", n[n.COMPRESSED_SIGNED_R11_EAC = 37489] = "COMPRESSED_SIGNED_R11_EAC", n[n.COMPRESSED_RG11_EAC = 37490] = "COMPRESSED_RG11_EAC", n[n.COMPRESSED_SIGNED_RG11_EAC = 37491] = "COMPRESSED_SIGNED_RG11_EAC", n[n.COMPRESSED_RGB8_ETC2 = 37492] = "COMPRESSED_RGB8_ETC2", n[n.COMPRESSED_RGBA8_ETC2_EAC = 37493] = "COMPRESSED_RGBA8_ETC2_EAC", n[n.COMPRESSED_SRGB8_ETC2 = 37494] = "COMPRESSED_SRGB8_ETC2", n[n.COMPRESSED_SRGB8_ALPHA8_ETC2_EAC = 37495] = "COMPRESSED_SRGB8_ALPHA8_ETC2_EAC", n[n.COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2 = 37496] = "COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2", n[n.COMPRESSED_SRGB8_PUNCHTHROUGH_ALPHA1_ETC2 = 37497] = "COMPRESSED_SRGB8_PUNCHTHROUGH_ALPHA1_ETC2", n[n.COMPRESSED_RGB_PVRTC_4BPPV1_IMG = 35840] = "COMPRESSED_RGB_PVRTC_4BPPV1_IMG", n[n.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG = 35842] = "COMPRESSED_RGBA_PVRTC_4BPPV1_IMG", n[n.COMPRESSED_RGB_PVRTC_2BPPV1_IMG = 35841] = "COMPRESSED_RGB_PVRTC_2BPPV1_IMG", n[n.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG = 35843] = "COMPRESSED_RGBA_PVRTC_2BPPV1_IMG", n[n.COMPRESSED_RGB_ETC1_WEBGL = 36196] = "COMPRESSED_RGB_ETC1_WEBGL", n[n.COMPRESSED_RGB_ATC_WEBGL = 35986] = "COMPRESSED_RGB_ATC_WEBGL", n[n.COMPRESSED_RGBA_ATC_EXPLICIT_ALPHA_WEBGL = 35986] = "COMPRESSED_RGBA_ATC_EXPLICIT_ALPHA_WEBGL", n[n.COMPRESSED_RGBA_ATC_INTERPOLATED_ALPHA_WEBGL = 34798] = "COMPRESSED_RGBA_ATC_INTERPOLATED_ALPHA_WEBGL", n[n.COMPRESSED_RGBA_ASTC_4x4_KHR = 37808] = "COMPRESSED_RGBA_ASTC_4x4_KHR", n[n.COMPRESSED_RGBA_ASTC_5x4_KHR = 37809] = "COMPRESSED_RGBA_ASTC_5x4_KHR", n[n.COMPRESSED_RGBA_ASTC_5x5_KHR = 37810] = "COMPRESSED_RGBA_ASTC_5x5_KHR", n[n.COMPRESSED_RGBA_ASTC_6x5_KHR = 37811] = "COMPRESSED_RGBA_ASTC_6x5_KHR", n[n.COMPRESSED_RGBA_ASTC_6x6_KHR = 37812] = "COMPRESSED_RGBA_ASTC_6x6_KHR", n[n.COMPRESSED_RGBA_ASTC_8x5_KHR = 37813] = "COMPRESSED_RGBA_ASTC_8x5_KHR", n[n.COMPRESSED_RGBA_ASTC_8x6_KHR = 37814] = "COMPRESSED_RGBA_ASTC_8x6_KHR", n[n.COMPRESSED_RGBA_ASTC_8x8_KHR = 37815] = "COMPRESSED_RGBA_ASTC_8x8_KHR", n[n.COMPRESSED_RGBA_ASTC_10x5_KHR = 37816] = "COMPRESSED_RGBA_ASTC_10x5_KHR", n[n.COMPRESSED_RGBA_ASTC_10x6_KHR = 37817] = "COMPRESSED_RGBA_ASTC_10x6_KHR", n[n.COMPRESSED_RGBA_ASTC_10x8_KHR = 37818] = "COMPRESSED_RGBA_ASTC_10x8_KHR", n[n.COMPRESSED_RGBA_ASTC_10x10_KHR = 37819] = "COMPRESSED_RGBA_ASTC_10x10_KHR", n[n.COMPRESSED_RGBA_ASTC_12x10_KHR = 37820] = "COMPRESSED_RGBA_ASTC_12x10_KHR", n[n.COMPRESSED_RGBA_ASTC_12x12_KHR = 37821] = "COMPRESSED_RGBA_ASTC_12x12_KHR", n[n.COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR = 37840] = "COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR", n[n.COMPRESSED_SRGB8_ALPHA8_ASTC_5x4_KHR = 37841] = "COMPRESSED_SRGB8_ALPHA8_ASTC_5x4_KHR", n[n.COMPRESSED_SRGB8_ALPHA8_ASTC_5x5_KHR = 37842] = "COMPRESSED_SRGB8_ALPHA8_ASTC_5x5_KHR", n[n.COMPRESSED_SRGB8_ALPHA8_ASTC_6x5_KHR = 37843] = "COMPRESSED_SRGB8_ALPHA8_ASTC_6x5_KHR", n[n.COMPRESSED_SRGB8_ALPHA8_ASTC_6x6_KHR = 37844] = "COMPRESSED_SRGB8_ALPHA8_ASTC_6x6_KHR", n[n.COMPRESSED_SRGB8_ALPHA8_ASTC_8x5_KHR = 37845] = "COMPRESSED_SRGB8_ALPHA8_ASTC_8x5_KHR", n[n.COMPRESSED_SRGB8_ALPHA8_ASTC_8x6_KHR = 37846] = "COMPRESSED_SRGB8_ALPHA8_ASTC_8x6_KHR", n[n.COMPRESSED_SRGB8_ALPHA8_ASTC_8x8_KHR = 37847] = "COMPRESSED_SRGB8_ALPHA8_ASTC_8x8_KHR", n[n.COMPRESSED_SRGB8_ALPHA8_ASTC_10x5_KHR = 37848] = "COMPRESSED_SRGB8_ALPHA8_ASTC_10x5_KHR", n[n.COMPRESSED_SRGB8_ALPHA8_ASTC_10x6_KHR = 37849] = "COMPRESSED_SRGB8_ALPHA8_ASTC_10x6_KHR", n[n.COMPRESSED_SRGB8_ALPHA8_ASTC_10x8_KHR = 37850] = "COMPRESSED_SRGB8_ALPHA8_ASTC_10x8_KHR", n[n.COMPRESSED_SRGB8_ALPHA8_ASTC_10x10_KHR = 37851] = "COMPRESSED_SRGB8_ALPHA8_ASTC_10x10_KHR", n[n.COMPRESSED_SRGB8_ALPHA8_ASTC_12x10_KHR = 37852] = "COMPRESSED_SRGB8_ALPHA8_ASTC_12x10_KHR", n[n.COMPRESSED_SRGB8_ALPHA8_ASTC_12x12_KHR = 37853] = "COMPRESSED_SRGB8_ALPHA8_ASTC_12x12_KHR", n[n.QUERY_COUNTER_BITS_EXT = 34916] = "QUERY_COUNTER_BITS_EXT", n[n.CURRENT_QUERY_EXT = 34917] = "CURRENT_QUERY_EXT", n[n.QUERY_RESULT_EXT = 34918] = "QUERY_RESULT_EXT", n[n.QUERY_RESULT_AVAILABLE_EXT = 34919] = "QUERY_RESULT_AVAILABLE_EXT", n[n.TIME_ELAPSED_EXT = 35007] = "TIME_ELAPSED_EXT", n[n.TIMESTAMP_EXT = 36392] = "TIMESTAMP_EXT", n[n.GPU_DISJOINT_EXT = 36795] = "GPU_DISJOINT_EXT", n[n.COMPLETION_STATUS_KHR = 37297] = "COMPLETION_STATUS_KHR", n[n.DEPTH_CLAMP_EXT = 34383] = "DEPTH_CLAMP_EXT", n[n.FIRST_VERTEX_CONVENTION_WEBGL = 36429] = "FIRST_VERTEX_CONVENTION_WEBGL", n[n.LAST_VERTEX_CONVENTION_WEBGL = 36430] = "LAST_VERTEX_CONVENTION_WEBGL", n[n.PROVOKING_VERTEX_WEBL = 36431] = "PROVOKING_VERTEX_WEBL", n[n.POLYGON_MODE_WEBGL = 2880] = "POLYGON_MODE_WEBGL", n[n.POLYGON_OFFSET_LINE_WEBGL = 10754] = "POLYGON_OFFSET_LINE_WEBGL", n[n.LINE_WEBGL = 6913] = "LINE_WEBGL", n[n.FILL_WEBGL = 6914] = "FILL_WEBGL", n[n.MAX_CLIP_DISTANCES_WEBGL = 3378] = "MAX_CLIP_DISTANCES_WEBGL", n[n.MAX_CULL_DISTANCES_WEBGL = 33529] = "MAX_CULL_DISTANCES_WEBGL", n[n.MAX_COMBINED_CLIP_AND_CULL_DISTANCES_WEBGL = 33530] = "MAX_COMBINED_CLIP_AND_CULL_DISTANCES_WEBGL", n[n.CLIP_DISTANCE0_WEBGL = 12288] = "CLIP_DISTANCE0_WEBGL", n[n.CLIP_DISTANCE1_WEBGL = 12289] = "CLIP_DISTANCE1_WEBGL", n[n.CLIP_DISTANCE2_WEBGL = 12290] = "CLIP_DISTANCE2_WEBGL", n[n.CLIP_DISTANCE3_WEBGL = 12291] = "CLIP_DISTANCE3_WEBGL", n[n.CLIP_DISTANCE4_WEBGL = 12292] = "CLIP_DISTANCE4_WEBGL", n[n.CLIP_DISTANCE5_WEBGL = 12293] = "CLIP_DISTANCE5_WEBGL", n[n.CLIP_DISTANCE6_WEBGL = 12294] = "CLIP_DISTANCE6_WEBGL", n[n.CLIP_DISTANCE7_WEBGL = 12295] = "CLIP_DISTANCE7_WEBGL", n[n.POLYGON_OFFSET_CLAMP_EXT = 36379] = "POLYGON_OFFSET_CLAMP_EXT", n[n.LOWER_LEFT_EXT = 36001] = "LOWER_LEFT_EXT", n[n.UPPER_LEFT_EXT = 36002] = "UPPER_LEFT_EXT", n[n.NEGATIVE_ONE_TO_ONE_EXT = 37726] = "NEGATIVE_ONE_TO_ONE_EXT", n[n.ZERO_TO_ONE_EXT = 37727] = "ZERO_TO_ONE_EXT", n[n.CLIP_ORIGIN_EXT = 37724] = "CLIP_ORIGIN_EXT", n[n.CLIP_DEPTH_MODE_EXT = 37725] = "CLIP_DEPTH_MODE_EXT", n[n.SRC1_COLOR_WEBGL = 35065] = "SRC1_COLOR_WEBGL", n[n.SRC1_ALPHA_WEBGL = 34185] = "SRC1_ALPHA_WEBGL", n[n.ONE_MINUS_SRC1_COLOR_WEBGL = 35066] = "ONE_MINUS_SRC1_COLOR_WEBGL", n[n.ONE_MINUS_SRC1_ALPHA_WEBGL = 35067] = "ONE_MINUS_SRC1_ALPHA_WEBGL", n[n.MAX_DUAL_SOURCE_DRAW_BUFFERS_WEBGL = 35068] = "MAX_DUAL_SOURCE_DRAW_BUFFERS_WEBGL", n[n.MIRROR_CLAMP_TO_EDGE_EXT = 34627] = "MIRROR_CLAMP_TO_EDGE_EXT";
  })(Or || (Or = {}));
  const Pg = {
    3042: false,
    32773: new Float32Array([
      0,
      0,
      0,
      0
    ]),
    32777: 32774,
    34877: 32774,
    32969: 1,
    32968: 0,
    32971: 1,
    32970: 0,
    3106: new Float32Array([
      0,
      0,
      0,
      0
    ]),
    3107: [
      true,
      true,
      true,
      true
    ],
    2884: false,
    2885: 1029,
    2929: false,
    2931: 1,
    2932: 513,
    2928: new Float32Array([
      0,
      1
    ]),
    2930: true,
    3024: true,
    35725: null,
    36006: null,
    36007: null,
    34229: null,
    34964: null,
    2886: 2305,
    33170: 4352,
    2849: 1,
    32823: false,
    32824: 0,
    10752: 0,
    32926: false,
    32928: false,
    32938: 1,
    32939: false,
    3089: false,
    3088: new Int32Array([
      0,
      0,
      1024,
      1024
    ]),
    2960: false,
    2961: 0,
    2968: 4294967295,
    36005: 4294967295,
    2962: 519,
    2967: 0,
    2963: 4294967295,
    34816: 519,
    36003: 0,
    36004: 4294967295,
    2964: 7680,
    2965: 7680,
    2966: 7680,
    34817: 7680,
    34818: 7680,
    34819: 7680,
    2978: [
      0,
      0,
      1024,
      1024
    ],
    36389: null,
    36662: null,
    36663: null,
    35053: null,
    35055: null,
    35723: 4352,
    36010: null,
    35977: false,
    3333: 4,
    3317: 4,
    37440: false,
    37441: false,
    37443: 37444,
    3330: 0,
    3332: 0,
    3331: 0,
    3314: 0,
    32878: 0,
    3316: 0,
    3315: 0,
    32877: 0
  }, lt = (n, e, t) => e ? n.enable(t) : n.disable(t), k0 = (n, e, t) => n.hint(t, e), Qt = (n, e, t) => n.pixelStorei(t, e), U0 = (n, e, t) => {
    const i = t === 36006 ? 36009 : 36008;
    return n.bindFramebuffer(i, e);
  }, Ja = (n, e, t) => {
    const s = {
      34964: 34962,
      36662: 36662,
      36663: 36663,
      35053: 35051,
      35055: 35052
    }[t];
    n.bindBuffer(s, e);
  };
  function td(n) {
    return Array.isArray(n) || ArrayBuffer.isView(n) && !(n instanceof DataView);
  }
  const G4 = {
    3042: lt,
    32773: (n, e) => n.blendColor(...e),
    32777: "blendEquation",
    34877: "blendEquation",
    32969: "blendFunc",
    32968: "blendFunc",
    32971: "blendFunc",
    32970: "blendFunc",
    3106: (n, e) => n.clearColor(...e),
    3107: (n, e) => n.colorMask(...e),
    2884: lt,
    2885: (n, e) => n.cullFace(e),
    2929: lt,
    2931: (n, e) => n.clearDepth(e),
    2932: (n, e) => n.depthFunc(e),
    2928: (n, e) => n.depthRange(...e),
    2930: (n, e) => n.depthMask(e),
    3024: lt,
    35723: k0,
    35725: (n, e) => n.useProgram(e),
    36007: (n, e) => n.bindRenderbuffer(36161, e),
    36389: (n, e) => {
      var _a2;
      return (_a2 = n.bindTransformFeedback) == null ? void 0 : _a2.call(n, 36386, e);
    },
    34229: (n, e) => n.bindVertexArray(e),
    36006: U0,
    36010: U0,
    34964: Ja,
    36662: Ja,
    36663: Ja,
    35053: Ja,
    35055: Ja,
    2886: (n, e) => n.frontFace(e),
    33170: k0,
    2849: (n, e) => n.lineWidth(e),
    32823: lt,
    32824: "polygonOffset",
    10752: "polygonOffset",
    35977: lt,
    32926: lt,
    32928: lt,
    32938: "sampleCoverage",
    32939: "sampleCoverage",
    3089: lt,
    3088: (n, e) => n.scissor(...e),
    2960: lt,
    2961: (n, e) => n.clearStencil(e),
    2968: (n, e) => n.stencilMaskSeparate(1028, e),
    36005: (n, e) => n.stencilMaskSeparate(1029, e),
    2962: "stencilFuncFront",
    2967: "stencilFuncFront",
    2963: "stencilFuncFront",
    34816: "stencilFuncBack",
    36003: "stencilFuncBack",
    36004: "stencilFuncBack",
    2964: "stencilOpFront",
    2965: "stencilOpFront",
    2966: "stencilOpFront",
    34817: "stencilOpBack",
    34818: "stencilOpBack",
    34819: "stencilOpBack",
    2978: (n, e) => n.viewport(...e),
    34383: lt,
    10754: lt,
    12288: lt,
    12289: lt,
    12290: lt,
    12291: lt,
    12292: lt,
    12293: lt,
    12294: lt,
    12295: lt,
    3333: Qt,
    3317: Qt,
    37440: Qt,
    37441: Qt,
    37443: Qt,
    3330: Qt,
    3332: Qt,
    3331: Qt,
    3314: Qt,
    32878: Qt,
    3316: Qt,
    3315: Qt,
    32877: Qt,
    framebuffer: (n, e) => {
      const t = e && "handle" in e ? e.handle : e;
      return n.bindFramebuffer(36160, t);
    },
    blend: (n, e) => e ? n.enable(3042) : n.disable(3042),
    blendColor: (n, e) => n.blendColor(...e),
    blendEquation: (n, e) => {
      const t = typeof e == "number" ? [
        e,
        e
      ] : e;
      n.blendEquationSeparate(...t);
    },
    blendFunc: (n, e) => {
      const t = (e == null ? void 0 : e.length) === 2 ? [
        ...e,
        ...e
      ] : e;
      n.blendFuncSeparate(...t);
    },
    clearColor: (n, e) => n.clearColor(...e),
    clearDepth: (n, e) => n.clearDepth(e),
    clearStencil: (n, e) => n.clearStencil(e),
    colorMask: (n, e) => n.colorMask(...e),
    cull: (n, e) => e ? n.enable(2884) : n.disable(2884),
    cullFace: (n, e) => n.cullFace(e),
    depthTest: (n, e) => e ? n.enable(2929) : n.disable(2929),
    depthFunc: (n, e) => n.depthFunc(e),
    depthMask: (n, e) => n.depthMask(e),
    depthRange: (n, e) => n.depthRange(...e),
    dither: (n, e) => e ? n.enable(3024) : n.disable(3024),
    derivativeHint: (n, e) => {
      n.hint(35723, e);
    },
    frontFace: (n, e) => n.frontFace(e),
    mipmapHint: (n, e) => n.hint(33170, e),
    lineWidth: (n, e) => n.lineWidth(e),
    polygonOffsetFill: (n, e) => e ? n.enable(32823) : n.disable(32823),
    polygonOffset: (n, e) => n.polygonOffset(...e),
    sampleCoverage: (n, e) => n.sampleCoverage(e[0], e[1] || false),
    scissorTest: (n, e) => e ? n.enable(3089) : n.disable(3089),
    scissor: (n, e) => n.scissor(...e),
    stencilTest: (n, e) => e ? n.enable(2960) : n.disable(2960),
    stencilMask: (n, e) => {
      e = td(e) ? e : [
        e,
        e
      ];
      const [t, i] = e;
      n.stencilMaskSeparate(1028, t), n.stencilMaskSeparate(1029, i);
    },
    stencilFunc: (n, e) => {
      e = td(e) && e.length === 3 ? [
        ...e,
        ...e
      ] : e;
      const [t, i, s, a, l, u] = e;
      n.stencilFuncSeparate(1028, t, i, s), n.stencilFuncSeparate(1029, a, l, u);
    },
    stencilOp: (n, e) => {
      e = td(e) && e.length === 3 ? [
        ...e,
        ...e
      ] : e;
      const [t, i, s, a, l, u] = e;
      n.stencilOpSeparate(1028, t, i, s), n.stencilOpSeparate(1029, a, l, u);
    },
    viewport: (n, e) => n.viewport(...e)
  };
  function nt(n, e, t) {
    return e[n] !== void 0 ? e[n] : t[n];
  }
  const J4 = {
    blendEquation: (n, e, t) => n.blendEquationSeparate(nt(32777, e, t), nt(34877, e, t)),
    blendFunc: (n, e, t) => n.blendFuncSeparate(nt(32969, e, t), nt(32968, e, t), nt(32971, e, t), nt(32970, e, t)),
    polygonOffset: (n, e, t) => n.polygonOffset(nt(32824, e, t), nt(10752, e, t)),
    sampleCoverage: (n, e, t) => n.sampleCoverage(nt(32938, e, t), nt(32939, e, t)),
    stencilFuncFront: (n, e, t) => n.stencilFuncSeparate(1028, nt(2962, e, t), nt(2967, e, t), nt(2963, e, t)),
    stencilFuncBack: (n, e, t) => n.stencilFuncSeparate(1029, nt(34816, e, t), nt(36003, e, t), nt(36004, e, t)),
    stencilOpFront: (n, e, t) => n.stencilOpSeparate(1028, nt(2964, e, t), nt(2965, e, t), nt(2966, e, t)),
    stencilOpBack: (n, e, t) => n.stencilOpSeparate(1029, nt(34817, e, t), nt(34818, e, t), nt(34819, e, t))
  }, B0 = {
    enable: (n, e) => n({
      [e]: true
    }),
    disable: (n, e) => n({
      [e]: false
    }),
    pixelStorei: (n, e, t) => n({
      [e]: t
    }),
    hint: (n, e, t) => n({
      [e]: t
    }),
    useProgram: (n, e) => n({
      35725: e
    }),
    bindRenderbuffer: (n, e, t) => n({
      36007: t
    }),
    bindTransformFeedback: (n, e, t) => n({
      36389: t
    }),
    bindVertexArray: (n, e) => n({
      34229: e
    }),
    bindFramebuffer: (n, e, t) => {
      switch (e) {
        case 36160:
          return n({
            36006: t,
            36010: t
          });
        case 36009:
          return n({
            36006: t
          });
        case 36008:
          return n({
            36010: t
          });
        default:
          return null;
      }
    },
    bindBuffer: (n, e, t) => {
      const i = {
        34962: [
          34964
        ],
        36662: [
          36662
        ],
        36663: [
          36663
        ],
        35051: [
          35053
        ],
        35052: [
          35055
        ]
      }[e];
      return i ? n({
        [i]: t
      }) : {
        valueChanged: true
      };
    },
    blendColor: (n, e, t, i, s) => n({
      32773: new Float32Array([
        e,
        t,
        i,
        s
      ])
    }),
    blendEquation: (n, e) => n({
      32777: e,
      34877: e
    }),
    blendEquationSeparate: (n, e, t) => n({
      32777: e,
      34877: t
    }),
    blendFunc: (n, e, t) => n({
      32969: e,
      32968: t,
      32971: e,
      32970: t
    }),
    blendFuncSeparate: (n, e, t, i, s) => n({
      32969: e,
      32968: t,
      32971: i,
      32970: s
    }),
    clearColor: (n, e, t, i, s) => n({
      3106: new Float32Array([
        e,
        t,
        i,
        s
      ])
    }),
    clearDepth: (n, e) => n({
      2931: e
    }),
    clearStencil: (n, e) => n({
      2961: e
    }),
    colorMask: (n, e, t, i, s) => n({
      3107: [
        e,
        t,
        i,
        s
      ]
    }),
    cullFace: (n, e) => n({
      2885: e
    }),
    depthFunc: (n, e) => n({
      2932: e
    }),
    depthRange: (n, e, t) => n({
      2928: new Float32Array([
        e,
        t
      ])
    }),
    depthMask: (n, e) => n({
      2930: e
    }),
    frontFace: (n, e) => n({
      2886: e
    }),
    lineWidth: (n, e) => n({
      2849: e
    }),
    polygonOffset: (n, e, t) => n({
      32824: e,
      10752: t
    }),
    sampleCoverage: (n, e, t) => n({
      32938: e,
      32939: t
    }),
    scissor: (n, e, t, i, s) => n({
      3088: new Int32Array([
        e,
        t,
        i,
        s
      ])
    }),
    stencilMask: (n, e) => n({
      2968: e,
      36005: e
    }),
    stencilMaskSeparate: (n, e, t) => n({
      [e === 1028 ? 2968 : 36005]: t
    }),
    stencilFunc: (n, e, t, i) => n({
      2962: e,
      2967: t,
      2963: i,
      34816: e,
      36003: t,
      36004: i
    }),
    stencilFuncSeparate: (n, e, t, i, s) => n({
      [e === 1028 ? 2962 : 34816]: t,
      [e === 1028 ? 2967 : 36003]: i,
      [e === 1028 ? 2963 : 36004]: s
    }),
    stencilOp: (n, e, t, i) => n({
      2964: e,
      2965: t,
      2966: i,
      34817: e,
      34818: t,
      34819: i
    }),
    stencilOpSeparate: (n, e, t, i, s) => n({
      [e === 1028 ? 2964 : 34817]: t,
      [e === 1028 ? 2965 : 34818]: i,
      [e === 1028 ? 2966 : 34819]: s
    }),
    viewport: (n, e, t, i, s) => n({
      2978: [
        e,
        t,
        i,
        s
      ]
    })
  }, Nn = (n, e) => n.isEnabled(e), L0 = {
    3042: Nn,
    2884: Nn,
    2929: Nn,
    3024: Nn,
    32823: Nn,
    32926: Nn,
    32928: Nn,
    3089: Nn,
    2960: Nn,
    35977: Nn
  }, eN = /* @__PURE__ */ new Set([
    34016,
    36388,
    36387,
    35983,
    35368,
    34965,
    35739,
    35738,
    3074,
    34853,
    34854,
    34855,
    34856,
    34857,
    34858,
    34859,
    34860,
    34861,
    34862,
    34863,
    34864,
    34865,
    34866,
    34867,
    34868,
    35097,
    32873,
    35869,
    32874,
    34068
  ]);
  function Qr(n, e) {
    if (nN(e)) return;
    const t = {};
    for (const s in e) {
      const a = Number(s), l = G4[s];
      l && (typeof l == "string" ? t[l] = true : l(n, e[s], a));
    }
    const i = n.state && n.state.cache;
    if (i) for (const s in t) {
      const a = J4[s];
      a(n, e, i);
    }
  }
  function Y2(n, e = Pg) {
    if (typeof e == "number") {
      const s = e, a = L0[s];
      return a ? a(n, s) : n.getParameter(s);
    }
    const t = Array.isArray(e) ? e : Object.keys(e), i = {};
    for (const s of t) {
      const a = L0[s];
      i[s] = a ? a(n, Number(s)) : n.getParameter(Number(s));
    }
    return i;
  }
  function tN(n) {
    Qr(n, Pg);
  }
  function nN(n) {
    for (const e in n) return false;
    return true;
  }
  function iN(n, e) {
    if (n === e) return true;
    const t = Array.isArray(n) || ArrayBuffer.isView(n), i = Array.isArray(e) || ArrayBuffer.isView(e);
    if (t && i && n.length === e.length) {
      for (let s = 0; s < n.length; ++s) if (n[s] !== e[s]) return false;
      return true;
    }
    return false;
  }
  class Ss {
    constructor(e, t) {
      __publicField(this, "gl");
      __publicField(this, "program", null);
      __publicField(this, "stateStack", []);
      __publicField(this, "enable", true);
      __publicField(this, "cache", null);
      __publicField(this, "log");
      __publicField(this, "initialized", false);
      this.gl = e, this.log = (t == null ? void 0 : t.log) || (() => {
      }), this._updateCache = this._updateCache.bind(this), Object.seal(this);
    }
    static get(e) {
      return e.state;
    }
    push(e = {}) {
      this.stateStack.push({});
    }
    pop() {
      const e = this.stateStack[this.stateStack.length - 1];
      Qr(this.gl, e), this.stateStack.pop();
    }
    trackState(e, t) {
      if (this.cache = t.copyState ? Y2(e) : Object.assign({}, Pg), this.initialized) throw new Error("WebGLStateTracker");
      this.initialized = true, this.gl.state = this, rN(e);
      for (const i in B0) {
        const s = B0[i];
        sN(e, i, s);
      }
      F0(e, "getParameter"), F0(e, "isEnabled");
    }
    _updateCache(e) {
      let t = false, i;
      const s = this.stateStack.length > 0 ? this.stateStack[this.stateStack.length - 1] : null;
      for (const a in e) {
        const l = e[a], u = this.cache[a];
        iN(l, u) || (t = true, i = u, s && !(a in s) && (s[a] = u), this.cache[a] = l);
      }
      return {
        valueChanged: t,
        oldValue: i
      };
    }
  }
  function F0(n, e) {
    const t = n[e].bind(n);
    n[e] = function(s) {
      if (s === void 0 || eN.has(s)) return t(s);
      const a = Ss.get(n);
      return s in a.cache || (a.cache[s] = t(s)), a.enable ? a.cache[s] : t(s);
    }, Object.defineProperty(n[e], "name", {
      value: `${e}-from-cache`,
      configurable: false
    });
  }
  function sN(n, e, t) {
    if (!n[e]) return;
    const i = n[e].bind(n);
    n[e] = function(...a) {
      const l = Ss.get(n), { valueChanged: u, oldValue: h } = t(l._updateCache, ...a);
      return u && i(...a), h;
    }, Object.defineProperty(n[e], "name", {
      value: `${e}-to-cache`,
      configurable: false
    });
  }
  function rN(n) {
    const e = n.useProgram.bind(n);
    n.useProgram = function(i) {
      const s = Ss.get(n);
      s.program !== i && (e(i), s.program = i);
    };
  }
  function aN(n, e, t) {
    let i = "";
    const s = {
      preserveDrawingBuffer: true,
      ...t
    };
    let a = null;
    if (a || (a = n.getContext("webgl2", s)), s.failIfMajorPerformanceCaveat && (i || (i = "Only software GPU is available. Set `failIfMajorPerformanceCaveat: false` to allow.")), !a && !t.failIfMajorPerformanceCaveat && (s.failIfMajorPerformanceCaveat = false, a = n.getContext("webgl2", s), a.luma || (a.luma = {}), a.luma.softwareRenderer = true), a || (a = n.getContext("webgl", {}), a && (a = null, i || (i = "Your browser only supports WebGL1"))), !a) throw i || (i = "Your browser does not support WebGL"), new Error(`Failed to create WebGL context: ${i}`);
    const { onContextLost: l, onContextRestored: u } = e;
    return n.addEventListener("webglcontextlost", (h) => l(h), false), n.addEventListener("webglcontextrestored", (h) => u(h), false), a.luma || (a.luma = {}), a;
  }
  function qr(n, e, t) {
    return t[e] === void 0 && (t[e] = n.getExtension(e) || null), t[e];
  }
  function oN(n, e) {
    const t = n.getParameter(7936), i = n.getParameter(7937);
    qr(n, "WEBGL_debug_renderer_info", e);
    const s = e.WEBGL_debug_renderer_info, a = n.getParameter(s ? s.UNMASKED_VENDOR_WEBGL : 7936), l = n.getParameter(s ? s.UNMASKED_RENDERER_WEBGL : 7937), u = a || t, h = l || i, d = n.getParameter(7938), p = q2(u, h), _ = lN(u, h), y = cN(u, h);
    return {
      type: "webgl",
      gpu: p,
      gpuType: y,
      gpuBackend: _,
      vendor: u,
      renderer: h,
      version: d,
      shadingLanguage: "glsl",
      shadingLanguageVersion: 300
    };
  }
  function q2(n, e) {
    return /NVIDIA/i.exec(n) || /NVIDIA/i.exec(e) ? "nvidia" : /INTEL/i.exec(n) || /INTEL/i.exec(e) ? "intel" : /Apple/i.exec(n) || /Apple/i.exec(e) ? "apple" : /AMD/i.exec(n) || /AMD/i.exec(e) || /ATI/i.exec(n) || /ATI/i.exec(e) ? "amd" : /SwiftShader/i.exec(n) || /SwiftShader/i.exec(e) ? "software" : "unknown";
  }
  function lN(n, e) {
    return /Metal/i.exec(n) || /Metal/i.exec(e) ? "metal" : /ANGLE/i.exec(n) || /ANGLE/i.exec(e) ? "opengl" : "unknown";
  }
  function cN(n, e) {
    if (/SwiftShader/i.exec(n) || /SwiftShader/i.exec(e)) return "cpu";
    switch (q2(n, e)) {
      case "intel":
        return "integrated";
      case "software":
        return "cpu";
      case "unknown":
        return "unknown";
      default:
        return "discrete";
    }
  }
  function K2(n) {
    switch (n) {
      case "uint8":
        return 5121;
      case "sint8":
        return 5120;
      case "unorm8":
        return 5121;
      case "snorm8":
        return 5120;
      case "uint16":
        return 5123;
      case "sint16":
        return 5122;
      case "unorm16":
        return 5123;
      case "snorm16":
        return 5122;
      case "uint32":
        return 5125;
      case "sint32":
        return 5124;
      case "float16":
        return 5131;
      case "float32":
        return 5126;
    }
    throw new Error(String(n));
  }
  const so = "WEBGL_compressed_texture_s3tc", ro = "WEBGL_compressed_texture_s3tc_srgb", Ir = "EXT_texture_compression_rgtc", Nr = "EXT_texture_compression_bptc", uN = "WEBGL_compressed_texture_etc", fN = "WEBGL_compressed_texture_astc", hN = "WEBGL_compressed_texture_etc1", dN = "WEBGL_compressed_texture_pvrtc", gN = "WEBGL_compressed_texture_atc", V0 = "EXT_texture_norm16", z0 = "EXT_render_snorm", pN = "EXT_color_buffer_float", Dg = {
    "float32-renderable-webgl": [
      "EXT_color_buffer_float"
    ],
    "float16-renderable-webgl": [
      "EXT_color_buffer_half_float"
    ],
    "rgb9e5ufloat-renderable-webgl": [
      "WEBGL_render_shared_exponent"
    ],
    "snorm8-renderable-webgl": [
      z0
    ],
    "norm16-renderable-webgl": [
      V0
    ],
    "snorm16-renderable-webgl": [
      V0,
      z0
    ],
    "float32-filterable": [
      "OES_texture_float_linear"
    ],
    "float16-filterable-webgl": [
      "OES_texture_half_float_linear"
    ],
    "texture-filterable-anisotropic-webgl": [
      "EXT_texture_filter_anisotropic"
    ],
    "texture-blend-float-webgl": [
      "EXT_float_blend"
    ],
    "texture-compression-bc": [
      so,
      ro,
      Ir,
      Nr
    ],
    "texture-compression-bc5-webgl": [
      Ir
    ],
    "texture-compression-bc7-webgl": [
      Nr
    ],
    "texture-compression-etc2": [
      uN
    ],
    "texture-compression-astc": [
      fN
    ],
    "texture-compression-etc1-webgl": [
      hN
    ],
    "texture-compression-pvrtc-webgl": [
      dN
    ],
    "texture-compression-atc-webgl": [
      gN
    ]
  };
  function mN(n) {
    return n in Dg;
  }
  function _N(n, e, t) {
    return (Dg[e] || []).every((s) => qr(n, s, t));
  }
  const kg = {
    r8unorm: {
      gl: 33321,
      rb: true
    },
    r8snorm: {
      gl: 36756
    },
    r8uint: {
      gl: 33330,
      rb: true
    },
    r8sint: {
      gl: 33329,
      rb: true
    },
    rg8unorm: {
      gl: 33323,
      rb: true
    },
    rg8snorm: {
      gl: 36757
    },
    rg8uint: {
      gl: 33336,
      rb: true
    },
    rg8sint: {
      gl: 33335,
      rb: true
    },
    r16uint: {
      gl: 33332,
      rb: true
    },
    r16sint: {
      gl: 33331,
      rb: true
    },
    r16float: {
      gl: 33325,
      rb: true
    },
    "r16unorm-webgl": {
      gl: 33322,
      rb: true
    },
    "r16snorm-webgl": {
      gl: 36760
    },
    "rgba4unorm-webgl": {
      gl: 32854,
      rb: true
    },
    "rgb565unorm-webgl": {
      gl: 36194,
      rb: true
    },
    "rgb5a1unorm-webgl": {
      gl: 32855,
      rb: true
    },
    "rgb8unorm-webgl": {
      gl: 32849
    },
    "rgb8snorm-webgl": {
      gl: 36758
    },
    rgba8unorm: {
      gl: 32856
    },
    "rgba8unorm-srgb": {
      gl: 35907
    },
    rgba8snorm: {
      gl: 36759
    },
    rgba8uint: {
      gl: 36220
    },
    rgba8sint: {
      gl: 36238
    },
    bgra8unorm: {},
    "bgra8unorm-srgb": {},
    rg16uint: {
      gl: 33338
    },
    rg16sint: {
      gl: 33337
    },
    rg16float: {
      gl: 33327,
      rb: true
    },
    "rg16unorm-webgl": {
      gl: 33324
    },
    "rg16snorm-webgl": {
      gl: 36761
    },
    r32uint: {
      gl: 33334,
      rb: true
    },
    r32sint: {
      gl: 33333,
      rb: true
    },
    r32float: {
      gl: 33326
    },
    rgb9e5ufloat: {
      gl: 35901
    },
    rg11b10ufloat: {
      gl: 35898,
      rb: true
    },
    rgb10a2unorm: {
      gl: 32857,
      rb: true
    },
    "rgb10a2uint-webgl": {
      gl: 36975,
      rb: true
    },
    "rgb16unorm-webgl": {
      gl: 32852
    },
    "rgb16snorm-webgl": {
      gl: 36762
    },
    rg32uint: {
      gl: 33340,
      rb: true
    },
    rg32sint: {
      gl: 33339,
      rb: true
    },
    rg32float: {
      gl: 33328,
      rb: true
    },
    rgba16uint: {
      gl: 36214,
      rb: true
    },
    rgba16sint: {
      gl: 36232,
      rb: true
    },
    rgba16float: {
      gl: 34842
    },
    "rgba16unorm-webgl": {
      gl: 32859,
      rb: true
    },
    "rgba16snorm-webgl": {
      gl: 36763
    },
    "rgb32float-webgl": {
      gl: 34837,
      x: pN,
      dataFormat: 6407,
      types: [
        5126
      ]
    },
    rgba32uint: {
      gl: 36208,
      rb: true
    },
    rgba32sint: {
      gl: 36226,
      rb: true
    },
    rgba32float: {
      gl: 34836,
      rb: true
    },
    stencil8: {
      gl: 36168,
      rb: true
    },
    depth16unorm: {
      gl: 33189,
      dataFormat: 6402,
      types: [
        5123
      ],
      rb: true
    },
    depth24plus: {
      gl: 33190,
      dataFormat: 6402,
      types: [
        5125
      ]
    },
    depth32float: {
      gl: 36012,
      dataFormat: 6402,
      types: [
        5126
      ],
      rb: true
    },
    "depth24plus-stencil8": {
      gl: 35056,
      rb: true,
      depthTexture: true,
      dataFormat: 34041,
      types: [
        34042
      ]
    },
    "depth32float-stencil8": {
      gl: 36013,
      dataFormat: 34041,
      types: [
        36269
      ],
      rb: true
    },
    "bc1-rgb-unorm-webgl": {
      gl: 33776,
      x: so
    },
    "bc1-rgb-unorm-srgb-webgl": {
      gl: 35916,
      x: ro
    },
    "bc1-rgba-unorm": {
      gl: 33777,
      x: so
    },
    "bc1-rgba-unorm-srgb": {
      gl: 35916,
      x: ro
    },
    "bc2-rgba-unorm": {
      gl: 33778,
      x: so
    },
    "bc2-rgba-unorm-srgb": {
      gl: 35918,
      x: ro
    },
    "bc3-rgba-unorm": {
      gl: 33779,
      x: so
    },
    "bc3-rgba-unorm-srgb": {
      gl: 35919,
      x: ro
    },
    "bc4-r-unorm": {
      gl: 36283,
      x: Ir
    },
    "bc4-r-snorm": {
      gl: 36284,
      x: Ir
    },
    "bc5-rg-unorm": {
      gl: 36285,
      x: Ir
    },
    "bc5-rg-snorm": {
      gl: 36286,
      x: Ir
    },
    "bc6h-rgb-ufloat": {
      gl: 36495,
      x: Nr
    },
    "bc6h-rgb-float": {
      gl: 36494,
      x: Nr
    },
    "bc7-rgba-unorm": {
      gl: 36492,
      x: Nr
    },
    "bc7-rgba-unorm-srgb": {
      gl: 36493,
      x: Nr
    },
    "etc2-rgb8unorm": {
      gl: 37492
    },
    "etc2-rgb8unorm-srgb": {
      gl: 37494
    },
    "etc2-rgb8a1unorm": {
      gl: 37496
    },
    "etc2-rgb8a1unorm-srgb": {
      gl: 37497
    },
    "etc2-rgba8unorm": {
      gl: 37493
    },
    "etc2-rgba8unorm-srgb": {
      gl: 37495
    },
    "eac-r11unorm": {
      gl: 37488
    },
    "eac-r11snorm": {
      gl: 37489
    },
    "eac-rg11unorm": {
      gl: 37490
    },
    "eac-rg11snorm": {
      gl: 37491
    },
    "astc-4x4-unorm": {
      gl: 37808
    },
    "astc-4x4-unorm-srgb": {
      gl: 37840
    },
    "astc-5x4-unorm": {
      gl: 37809
    },
    "astc-5x4-unorm-srgb": {
      gl: 37841
    },
    "astc-5x5-unorm": {
      gl: 37810
    },
    "astc-5x5-unorm-srgb": {
      gl: 37842
    },
    "astc-6x5-unorm": {
      gl: 37811
    },
    "astc-6x5-unorm-srgb": {
      gl: 37843
    },
    "astc-6x6-unorm": {
      gl: 37812
    },
    "astc-6x6-unorm-srgb": {
      gl: 37844
    },
    "astc-8x5-unorm": {
      gl: 37813
    },
    "astc-8x5-unorm-srgb": {
      gl: 37845
    },
    "astc-8x6-unorm": {
      gl: 37814
    },
    "astc-8x6-unorm-srgb": {
      gl: 37846
    },
    "astc-8x8-unorm": {
      gl: 37815
    },
    "astc-8x8-unorm-srgb": {
      gl: 37847
    },
    "astc-10x5-unorm": {
      gl: 37819
    },
    "astc-10x5-unorm-srgb": {
      gl: 37851
    },
    "astc-10x6-unorm": {
      gl: 37817
    },
    "astc-10x6-unorm-srgb": {
      gl: 37849
    },
    "astc-10x8-unorm": {
      gl: 37818
    },
    "astc-10x8-unorm-srgb": {
      gl: 37850
    },
    "astc-10x10-unorm": {
      gl: 37819
    },
    "astc-10x10-unorm-srgb": {
      gl: 37851
    },
    "astc-12x10-unorm": {
      gl: 37820
    },
    "astc-12x10-unorm-srgb": {
      gl: 37852
    },
    "astc-12x12-unorm": {
      gl: 37821
    },
    "astc-12x12-unorm-srgb": {
      gl: 37853
    },
    "pvrtc-rgb4unorm-webgl": {
      gl: 35840
    },
    "pvrtc-rgba4unorm-webgl": {
      gl: 35842
    },
    "pvrtc-rbg2unorm-webgl": {
      gl: 35841
    },
    "pvrtc-rgba2unorm-webgl": {
      gl: 35843
    },
    "etc1-rbg-unorm-webgl": {
      gl: 36196
    },
    "atc-rgb-unorm-webgl": {
      gl: 35986
    },
    "atc-rgba-unorm-webgl": {
      gl: 35986
    },
    "atc-rgbai-unorm-webgl": {
      gl: 34798
    }
  };
  function yN(n, e, t) {
    let i = e.create;
    const s = kg[e.format];
    return (s == null ? void 0 : s.gl) === void 0 && (i = false), (s == null ? void 0 : s.x) && (i = i && !!qr(n, s.x, t)), {
      format: e.format,
      create: i && e.create,
      render: i && e.render,
      filter: i && e.filter,
      blend: i && e.blend,
      store: i && e.store
    };
  }
  function Z2(n) {
    var _a2;
    const e = kg[n], t = TN(n), i = lg(n);
    return {
      internalFormat: t,
      format: (e == null ? void 0 : e.dataFormat) || vN(i.channels, i.integer, i.normalized, t),
      type: i.dataType ? K2(i.dataType) : ((_a2 = e == null ? void 0 : e.types) == null ? void 0 : _a2[0]) || 5121,
      compressed: i.compressed || false
    };
  }
  function bN(n) {
    switch (lg(n).attachment) {
      case "depth":
        return 36096;
      case "stencil":
        return 36128;
      case "depth-stencil":
        return 33306;
      default:
        throw new Error(`Not a depth stencil format: ${n}`);
    }
  }
  function vN(n, e, t, i) {
    if (i === 6408 || i === 6407) return i;
    switch (n) {
      case "r":
        return e && !t ? 36244 : 6403;
      case "rg":
        return e && !t ? 33320 : 33319;
      case "rgb":
        return e && !t ? 36248 : 6407;
      case "rgba":
        return e && !t ? 36249 : 6408;
      case "bgra":
        throw new Error("bgra pixels not supported by WebGL");
      default:
        return 6408;
    }
  }
  function TN(n) {
    var _a2;
    const t = (_a2 = kg[n]) == null ? void 0 : _a2.gl;
    if (t === void 0) throw new Error(`Unsupported texture format ${n}`);
    return t;
  }
  const H0 = {
    "depth-clip-control": "EXT_depth_clamp",
    "timer-query-webgl": "EXT_disjoint_timer_query_webgl2",
    "compilation-status-async-webgl": "KHR_parallel_shader_compile",
    "polygon-mode-webgl": "WEBGL_polygon_mode",
    "provoking-vertex-webgl": "WEBGL_provoking_vertex",
    "shader-clip-cull-distance-webgl": "WEBGL_clip_cull_distance",
    "shader-noperspective-interpolation-webgl": "NV_shader_noperspective_interpolation",
    "shader-conservative-depth-webgl": "EXT_conservative_depth"
  };
  class xN extends sR {
    constructor(e, t, i) {
      super([], i);
      __publicField(this, "gl");
      __publicField(this, "extensions");
      __publicField(this, "testedFeatures", /* @__PURE__ */ new Set());
      this.gl = e, this.extensions = t, qr(e, "EXT_color_buffer_float", t);
    }
    *[Symbol.iterator]() {
      const e = this.getFeatures();
      for (const t of e) this.has(t) && (yield t);
      return [];
    }
    has(e) {
      var _a2;
      return ((_a2 = this.disabledFeatures) == null ? void 0 : _a2[e]) ? false : (this.testedFeatures.has(e) || (this.testedFeatures.add(e), mN(e) && _N(this.gl, e, this.extensions) && this.features.add(e), this.getWebGLFeature(e) && this.features.add(e)), this.features.has(e));
    }
    initializeFeatures() {
      const e = this.getFeatures().filter((t) => t !== "polygon-mode-webgl");
      for (const t of e) this.has(t);
    }
    getFeatures() {
      return [
        ...Object.keys(H0),
        ...Object.keys(Dg)
      ];
    }
    getWebGLFeature(e) {
      const t = H0[e];
      return typeof t == "string" ? !!qr(this.gl, t, this.extensions) : !!t;
    }
  }
  class SN extends iR {
    constructor(e) {
      super();
      __publicField(this, "gl");
      __publicField(this, "limits", {});
      this.gl = e;
    }
    get maxTextureDimension1D() {
      return 0;
    }
    get maxTextureDimension2D() {
      return this.getParameter(3379);
    }
    get maxTextureDimension3D() {
      return this.getParameter(32883);
    }
    get maxTextureArrayLayers() {
      return this.getParameter(35071);
    }
    get maxBindGroups() {
      return 0;
    }
    get maxDynamicUniformBuffersPerPipelineLayout() {
      return 0;
    }
    get maxDynamicStorageBuffersPerPipelineLayout() {
      return 0;
    }
    get maxSampledTexturesPerShaderStage() {
      return this.getParameter(35660);
    }
    get maxSamplersPerShaderStage() {
      return this.getParameter(35661);
    }
    get maxStorageBuffersPerShaderStage() {
      return 0;
    }
    get maxStorageTexturesPerShaderStage() {
      return 0;
    }
    get maxUniformBuffersPerShaderStage() {
      return this.getParameter(35375);
    }
    get maxUniformBufferBindingSize() {
      return this.getParameter(35376);
    }
    get maxStorageBufferBindingSize() {
      return 0;
    }
    get minUniformBufferOffsetAlignment() {
      return this.getParameter(35380);
    }
    get minStorageBufferOffsetAlignment() {
      return 0;
    }
    get maxVertexBuffers() {
      return 16;
    }
    get maxVertexAttributes() {
      return this.getParameter(34921);
    }
    get maxVertexBufferArrayStride() {
      return 2048;
    }
    get maxInterStageShaderComponents() {
      return this.getParameter(35659);
    }
    get maxComputeWorkgroupStorageSize() {
      return 0;
    }
    get maxComputeInvocationsPerWorkgroup() {
      return 0;
    }
    get maxComputeWorkgroupSizeX() {
      return 0;
    }
    get maxComputeWorkgroupSizeY() {
      return 0;
    }
    get maxComputeWorkgroupSizeZ() {
      return 0;
    }
    get maxComputeWorkgroupsPerDimension() {
      return 0;
    }
    getParameter(e) {
      return this.limits[e] === void 0 && (this.limits[e] = this.gl.getParameter(e)), this.limits[e] || 0;
    }
  }
  class fo extends Qc {
    constructor(e, t) {
      super(e, t);
      __publicField(this, "device");
      __publicField(this, "gl");
      __publicField(this, "handle");
      __publicField(this, "colorAttachments", []);
      __publicField(this, "depthStencilAttachment", null);
      const i = t.handle === null;
      this.device = e, this.gl = e.gl, this.handle = this.props.handle || i ? this.props.handle : this.gl.createFramebuffer(), i || (e.setSpectorMetadata(this.handle, {
        id: this.props.id,
        props: this.props
      }), this.autoCreateAttachmentTextures(), this.updateAttachments());
    }
    destroy() {
      super.destroy(), !this.destroyed && this.handle !== null && this.gl.deleteFramebuffer(this.handle);
    }
    updateAttachments() {
      const e = this.gl.bindFramebuffer(36160, this.handle);
      for (let t = 0; t < this.colorAttachments.length; ++t) {
        const i = this.colorAttachments[t];
        if (i) {
          const s = 36064 + t;
          this._attachTextureView(s, i);
        }
      }
      if (this.depthStencilAttachment) {
        const t = bN(this.depthStencilAttachment.props.format);
        this._attachTextureView(t, this.depthStencilAttachment);
      }
      if (this.device.props.debug) {
        const t = this.gl.checkFramebufferStatus(36160);
        if (t !== 36053) throw new Error(`Framebuffer ${wN(t)}`);
      }
      this.gl.bindFramebuffer(36160, e);
    }
    _attachTextureView(e, t) {
      const { gl: i } = this.device, { texture: s } = t, a = t.props.baseMipLevel, l = t.props.baseArrayLayer;
      switch (i.bindTexture(s.glTarget, s.handle), s.glTarget) {
        case 35866:
        case 32879:
          i.framebufferTextureLayer(36160, e, s.handle, a, l);
          break;
        case 34067:
          const u = AN(l);
          i.framebufferTexture2D(36160, e, u, s.handle, a);
          break;
        case 3553:
          i.framebufferTexture2D(36160, e, 3553, s.handle, a);
          break;
        default:
          throw new Error("Illegal texture type");
      }
      i.bindTexture(s.glTarget, null);
    }
  }
  function AN(n) {
    return n < 34069 ? n + 34069 : n;
  }
  function wN(n) {
    switch (n) {
      case 36053:
        return "success";
      case 36054:
        return "Mismatched attachments";
      case 36055:
        return "No attachments";
      case 36057:
        return "Height/width mismatch";
      case 36061:
        return "Unsupported or split attachments";
      case 36182:
        return "Samples mismatch";
      default:
        return `${n}`;
    }
  }
  class EN extends cg {
    constructor(e, t) {
      super(t);
      __publicField(this, "device");
      __publicField(this, "format", "rgba8unorm");
      __publicField(this, "depthStencilFormat", "depth24plus");
      __publicField(this, "presentationSize");
      __publicField(this, "_framebuffer", null);
      this.device = e, this.presentationSize = [
        -1,
        -1
      ], this._setAutoCreatedCanvasId(`${this.device.id}-canvas`), this.update();
    }
    get [Symbol.toStringTag]() {
      return "WebGLCanvasContext";
    }
    getCurrentFramebuffer() {
      return this.update(), this._framebuffer = this._framebuffer || new fo(this.device, {
        handle: null
      }), this._framebuffer;
    }
    update() {
      const e = this.getPixelSize();
      (e[0] !== this.presentationSize[0] || e[1] !== this.presentationSize[1]) && (this.presentationSize = e, this.resize());
    }
    resize(e) {
      if (this.device.gl && this.canvas) {
        const t = this.getDevicePixelRatio(e == null ? void 0 : e.useDevicePixels);
        this.setDevicePixelRatio(t, e);
        return;
      }
    }
    commit() {
    }
  }
  async function Q2(n, e) {
    const t = document.getElementsByTagName("head")[0];
    if (!t) throw new Error("loadScript");
    const i = document.createElement("script");
    return i.setAttribute("type", "text/javascript"), i.setAttribute("src", n), new Promise((s, a) => {
      i.onload = s, i.onerror = (l) => a(new Error(`Unable to load script '${n}': ${l}`)), t.appendChild(i);
    });
  }
  const RN = 1;
  let Gt = null, j0 = false;
  const Ug = {
    debugSpectorJS: J.get("debug-spectorjs"),
    debugSpectorJSUrl: "https://cdn.jsdelivr.net/npm/spectorjs@0.9.30/dist/spector.bundle.js",
    gl: void 0
  };
  async function CN(n) {
    if (!globalThis.SPECTOR) try {
      await Q2(n.debugSpectorJSUrl || Ug.debugSpectorJSUrl);
    } catch (e) {
      J.warn(String(e));
    }
  }
  function MN(n) {
    var _a2;
    if (n = {
      ...Ug,
      ...n
    }, !n.debugSpectorJS) return null;
    if (!Gt && globalThis.SPECTOR && !((_a2 = globalThis.luma) == null ? void 0 : _a2.spector)) {
      J.probe(RN, "SPECTOR found and initialized. Start with `luma.spector.displayUI()`")();
      const { Spector: e } = globalThis.SPECTOR;
      Gt = new e(), globalThis.luma && (globalThis.luma.spector = Gt);
    }
    if (!Gt) return null;
    if (j0 || (j0 = true, Gt.spyCanvases(), Gt == null ? void 0 : Gt.onCaptureStarted.add((e) => J.info("Spector capture started:", e)()), Gt == null ? void 0 : Gt.onCapture.add((e) => {
      J.info("Spector capture complete:", e)(), Gt == null ? void 0 : Gt.getResultUI(), Gt == null ? void 0 : Gt.resultView.display(), Gt == null ? void 0 : Gt.resultView.addCapture(e);
    })), n.gl) {
      const e = n.gl, t = e.device;
      Gt == null ? void 0 : Gt.startCapture(n.gl, 500), e.device = t, new Promise((i) => setTimeout(i, 2e3)).then((i) => {
        J.info("Spector capture stopped after 2 seconds")(), Gt == null ? void 0 : Gt.stopCapture();
      });
    }
    return Gt;
  }
  const ON = "https://unpkg.com/webgl-debug@2.0.1/index.js";
  function G2(n) {
    return n.luma = n.luma || {}, n.luma;
  }
  async function IN() {
    Is() && !globalThis.WebGLDebugUtils && (globalThis.global = globalThis.global || globalThis, globalThis.global.module = {}, await Q2(ON));
  }
  function NN(n, e = {}) {
    return e.debugWebGL || e.traceWebGL ? DN(n, e) : PN(n);
  }
  function PN(n) {
    const e = G2(n);
    return e.realContext ? e.realContext : n;
  }
  function DN(n, e) {
    if (!globalThis.WebGLDebugUtils) return J.warn("webgl-debug not loaded")(), n;
    const t = G2(n);
    if (t.debugContext) return t.debugContext;
    globalThis.WebGLDebugUtils.init({
      ...Or,
      ...n
    });
    const i = globalThis.WebGLDebugUtils.makeDebugContext(n, kN.bind(null, e), UN.bind(null, e));
    for (const l in Or) !(l in i) && typeof Or[l] == "number" && (i[l] = Or[l]);
    class s {
    }
    Object.setPrototypeOf(i, Object.getPrototypeOf(n)), Object.setPrototypeOf(s, i);
    const a = Object.create(s);
    return t.realContext = n, t.debugContext = a, a.debug = true, a;
  }
  function W0(n, e) {
    e = Array.from(e).map((i) => i === void 0 ? "undefined" : i);
    let t = globalThis.WebGLDebugUtils.glFunctionArgsToString(n, e);
    return t = `${t.slice(0, 100)}${t.length > 100 ? "..." : ""}`, `gl.${n}(${t})`;
  }
  function kN(n, e, t, i) {
    i = Array.from(i).map((u) => u === void 0 ? "undefined" : u);
    const s = globalThis.WebGLDebugUtils.glEnumToString(e), a = globalThis.WebGLDebugUtils.glFunctionArgsToString(t, i), l = `${s} in gl.${t}(${a})`;
    J.error(l)();
    debugger;
  }
  function UN(n, e, t) {
    let i = "";
    J.level >= 1 && (i = W0(e, t), n.traceWebGL && J.log(1, i)());
    for (const s of t) if (s === void 0) {
      i = i || W0(e, t);
      debugger;
    }
  }
  const nd = {};
  function BN(n = "id") {
    nd[n] = nd[n] || 1;
    const e = nd[n]++;
    return `${n}-${e}`;
  }
  class ho extends Ke {
    constructor(e, t = {}) {
      super(e, t);
      __publicField(this, "device");
      __publicField(this, "gl");
      __publicField(this, "handle");
      __publicField(this, "glTarget");
      __publicField(this, "glUsage");
      __publicField(this, "glIndexType", 5123);
      __publicField(this, "byteLength");
      __publicField(this, "bytesUsed");
      this.device = e, this.gl = this.device.gl;
      const i = typeof t == "object" ? t.handle : void 0;
      this.handle = i || this.gl.createBuffer(), e.setSpectorMetadata(this.handle, {
        ...this.props,
        data: typeof this.props.data
      }), this.glTarget = LN(this.props.usage), this.glUsage = FN(this.props.usage), this.glIndexType = this.props.indexType === "uint32" ? 5125 : 5123, t.data ? this._initWithData(t.data, t.byteOffset, t.byteLength) : this._initWithByteLength(t.byteLength || 0);
    }
    _initWithData(e, t = 0, i = e.byteLength + t) {
      const s = this.glTarget;
      this.gl.bindBuffer(s, this.handle), this.gl.bufferData(s, i, this.glUsage), this.gl.bufferSubData(s, t, e), this.gl.bindBuffer(s, null), this.bytesUsed = i, this.byteLength = i, this._setDebugData(e, t, i), this.trackAllocatedMemory(i);
    }
    _initWithByteLength(e) {
      let t = e;
      e === 0 && (t = new Float32Array(0));
      const i = this.glTarget;
      return this.gl.bindBuffer(i, this.handle), this.gl.bufferData(i, t, this.glUsage), this.gl.bindBuffer(i, null), this.bytesUsed = e, this.byteLength = e, this._setDebugData(null, 0, e), this.trackAllocatedMemory(e), this;
    }
    destroy() {
      !this.destroyed && this.handle && (this.removeStats(), this.trackDeallocatedMemory(), this.gl.deleteBuffer(this.handle), this.destroyed = true, this.handle = null);
    }
    write(e, t = 0) {
      this.gl.bindBuffer(36663, this.handle), this.gl.bufferSubData(36663, t, e), this.gl.bindBuffer(36663, null), this._setDebugData(e, t, e.byteLength);
    }
    async readAsync(e = 0, t) {
      return this.readSyncWebGL(e, t);
    }
    readSyncWebGL(e = 0, t) {
      t = t ?? this.byteLength - e;
      const i = new Uint8Array(t), s = 0;
      return this.gl.bindBuffer(36662, this.handle), this.gl.getBufferSubData(36662, e, i, s, t), this.gl.bindBuffer(36662, null), this._setDebugData(i, e, t), i;
    }
  }
  function LN(n) {
    return n & Ke.INDEX ? 34963 : n & Ke.VERTEX ? 34962 : n & Ke.UNIFORM ? 35345 : 34962;
  }
  function FN(n) {
    return n & Ke.INDEX || n & Ke.VERTEX ? 35044 : n & Ke.UNIFORM ? 35048 : 35044;
  }
  function VN(n) {
    const e = n.split(/\r?\n/), t = [];
    for (const i of e) {
      if (i.length <= 1) continue;
      const s = i.split(":");
      if (s.length === 2) {
        const [_, y] = s;
        t.push({
          message: y.trim(),
          type: $0(_),
          lineNum: 0,
          linePos: 0
        });
        continue;
      }
      const [a, l, u, ...h] = s;
      let d = parseInt(u, 10);
      isNaN(d) && (d = 0);
      let p = parseInt(l, 10);
      isNaN(p) && (p = 0), t.push({
        message: h.join(":").trim(),
        type: $0(a),
        lineNum: d,
        linePos: p
      });
    }
    return t;
  }
  function $0(n) {
    const e = [
      "warning",
      "error",
      "info"
    ], t = n.toLowerCase();
    return e.includes(t) ? t : "info";
  }
  class zN extends Zc {
    constructor(e, t) {
      super(e, t);
      __publicField(this, "device");
      __publicField(this, "handle");
      switch (this.device = e, this.props.stage) {
        case "vertex":
          this.handle = this.props.handle || this.device.gl.createShader(35633);
          break;
        case "fragment":
          this.handle = this.props.handle || this.device.gl.createShader(35632);
          break;
        default:
          throw new Error(this.props.stage);
      }
      this._compile(this.source);
    }
    destroy() {
      this.handle && (this.removeStats(), this.device.gl.deleteShader(this.handle), this.destroyed = true);
    }
    get asyncCompilationStatus() {
      return this._waitForCompilationComplete().then(() => this.compilationStatus);
    }
    async getCompilationInfo() {
      return await this._waitForCompilationComplete(), this.getCompilationInfoSync();
    }
    getCompilationInfoSync() {
      const e = this.device.gl.getShaderInfoLog(this.handle);
      return e ? VN(e) : [];
    }
    getTranslatedSource() {
      var _a2;
      return ((_a2 = this.device.getExtension("WEBGL_debug_shaders").WEBGL_debug_shaders) == null ? void 0 : _a2.getTranslatedShaderSource(this.handle)) || null;
    }
    async _compile(e) {
      e = e.startsWith("#version ") ? e : `#version 300 es
${e}`;
      const { gl: t } = this.device;
      if (t.shaderSource(this.handle, e), t.compileShader(this.handle), !this.device.props.debug) {
        this.compilationStatus = "pending";
        return;
      }
      if (!this.device.features.has("compilation-status-async-webgl")) {
        if (this._getCompilationStatus(), this.debugShader(), this.compilationStatus === "error") throw new Error(`GLSL compilation errors in ${this.props.stage} shader ${this.props.id}`);
        return;
      }
      J.once(1, "Shader compilation is asynchronous")(), await this._waitForCompilationComplete(), J.info(2, `Shader ${this.id} - async compilation complete: ${this.compilationStatus}`)(), this._getCompilationStatus(), this.debugShader();
    }
    async _waitForCompilationComplete() {
      const e = async (s) => await new Promise((a) => setTimeout(a, s));
      if (!this.device.features.has("compilation-status-async-webgl")) {
        await e(10);
        return;
      }
      const { gl: i } = this.device;
      for (; ; ) {
        if (i.getShaderParameter(this.handle, 37297)) return;
        await e(10);
      }
    }
    _getCompilationStatus() {
      this.compilationStatus = this.device.gl.getShaderParameter(this.handle, 35713) ? "success" : "error";
    }
  }
  function HN(n, e, t, i) {
    if (XN(e)) return i(n);
    const s = n;
    s.pushState();
    try {
      return jN(n, e), Qr(s.gl, t), i(n);
    } finally {
      s.popState();
    }
  }
  function jN(n, e) {
    const t = n, { gl: i } = t;
    if (e.cullMode) switch (e.cullMode) {
      case "none":
        i.disable(2884);
        break;
      case "front":
        i.enable(2884), i.cullFace(1028);
        break;
      case "back":
        i.enable(2884), i.cullFace(1029);
        break;
    }
    if (e.frontFace && i.frontFace(As("frontFace", e.frontFace, {
      ccw: 2305,
      cw: 2304
    })), e.unclippedDepth && n.features.has("depth-clip-control") && i.enable(34383), e.depthBias !== void 0 && (i.enable(32823), i.polygonOffset(e.depthBias, e.depthBiasSlopeScale || 0)), e.provokingVertex && n.features.has("provoking-vertex-webgl")) {
      const a = t.getExtension("WEBGL_provoking_vertex").WEBGL_provoking_vertex, l = As("provokingVertex", e.provokingVertex, {
        first: 36429,
        last: 36430
      });
      a == null ? void 0 : a.provokingVertexWEBGL(l);
    }
    if ((e.polygonMode || e.polygonOffsetLine) && n.features.has("polygon-mode-webgl")) {
      if (e.polygonMode) {
        const a = t.getExtension("WEBGL_polygon_mode").WEBGL_polygon_mode, l = As("polygonMode", e.polygonMode, {
          fill: 6914,
          line: 6913
        });
        a == null ? void 0 : a.polygonModeWEBGL(1028, l), a == null ? void 0 : a.polygonModeWEBGL(1029, l);
      }
      e.polygonOffsetLine && i.enable(10754);
    }
    if (n.features.has("shader-clip-cull-distance-webgl") && (e.clipDistance0 && i.enable(12288), e.clipDistance1 && i.enable(12289), e.clipDistance2 && i.enable(12290), e.clipDistance3 && i.enable(12291), e.clipDistance4 && i.enable(12292), e.clipDistance5 && i.enable(12293), e.clipDistance6 && i.enable(12294), e.clipDistance7 && i.enable(12295)), e.depthWriteEnabled !== void 0 && i.depthMask($N("depthWriteEnabled", e.depthWriteEnabled)), e.depthCompare && (e.depthCompare !== "always" ? i.enable(2929) : i.disable(2929), i.depthFunc(Ld("depthCompare", e.depthCompare))), e.stencilWriteMask) {
      const s = e.stencilWriteMask;
      i.stencilMaskSeparate(1028, s), i.stencilMaskSeparate(1029, s);
    }
    if (e.stencilReadMask && J.warn("stencilReadMask not supported under WebGL"), e.stencilCompare) {
      const s = e.stencilReadMask || 4294967295, a = Ld("depthCompare", e.stencilCompare);
      e.stencilCompare !== "always" ? i.enable(2960) : i.disable(2960), i.stencilFuncSeparate(1028, a, 0, s), i.stencilFuncSeparate(1029, a, 0, s);
    }
    if (e.stencilPassOperation && e.stencilFailOperation && e.stencilDepthFailOperation) {
      const s = id("stencilPassOperation", e.stencilPassOperation), a = id("stencilFailOperation", e.stencilFailOperation), l = id("stencilDepthFailOperation", e.stencilDepthFailOperation);
      i.stencilOpSeparate(1028, a, l, s), i.stencilOpSeparate(1029, a, l, s);
    }
    switch (e.blend) {
      case true:
        i.enable(3042);
        break;
      case false:
        i.disable(3042);
        break;
    }
    if (e.blendColorOperation || e.blendAlphaOperation) {
      const s = X0("blendColorOperation", e.blendColorOperation || "add"), a = X0("blendAlphaOperation", e.blendAlphaOperation || "add");
      i.blendEquationSeparate(s, a);
      const l = tc("blendColorSrcFactor", e.blendColorSrcFactor || "one"), u = tc("blendColorDstFactor", e.blendColorDstFactor || "zero"), h = tc("blendAlphaSrcFactor", e.blendAlphaSrcFactor || "one"), d = tc("blendAlphaDstFactor", e.blendAlphaDstFactor || "zero");
      i.blendFuncSeparate(l, u, h, d);
    }
  }
  function Ld(n, e) {
    return As(n, e, {
      never: 512,
      less: 513,
      equal: 514,
      "less-equal": 515,
      greater: 516,
      "not-equal": 517,
      "greater-equal": 518,
      always: 519
    });
  }
  function id(n, e) {
    return As(n, e, {
      keep: 7680,
      zero: 0,
      replace: 7681,
      invert: 5386,
      "increment-clamp": 7682,
      "decrement-clamp": 7683,
      "increment-wrap": 34055,
      "decrement-wrap": 34056
    });
  }
  function X0(n, e) {
    return As(n, e, {
      add: 32774,
      subtract: 32778,
      "reverse-subtract": 32779,
      min: 32775,
      max: 32776
    });
  }
  function tc(n, e) {
    return As(n, e, {
      one: 1,
      zero: 0,
      "src-color": 768,
      "one-minus-src-color": 769,
      "dst-color": 774,
      "one-minus-dst-color": 775,
      "src-alpha": 770,
      "one-minus-src-alpha": 771,
      "dst-alpha": 772,
      "one-minus-dst-alpha": 773,
      "src-alpha-saturated": 776,
      "constant-color": 32769,
      "one-minus-constant-color": 32770,
      "constant-alpha": 32771,
      "one-minus-constant-alpha": 32772
    });
  }
  function WN(n, e) {
    return `Illegal parameter ${e} for ${n}`;
  }
  function As(n, e, t) {
    if (!(e in t)) throw new Error(WN(n, e));
    return t[e];
  }
  function $N(n, e) {
    return e;
  }
  function XN(n) {
    let e = true;
    for (const t in n) {
      e = false;
      break;
    }
    return e;
  }
  function J2(n) {
    const e = {};
    return n.addressModeU && (e[10242] = sd(n.addressModeU)), n.addressModeV && (e[10243] = sd(n.addressModeV)), n.addressModeW && (e[32882] = sd(n.addressModeW)), n.magFilter && (e[10240] = Fd(n.magFilter)), (n.minFilter || n.mipmapFilter) && (e[10241] = YN(n.minFilter || "linear", n.mipmapFilter)), n.lodMinClamp !== void 0 && (e[33082] = n.lodMinClamp), n.lodMaxClamp !== void 0 && (e[33083] = n.lodMaxClamp), n.type === "comparison-sampler" && (e[34892] = 34894), n.compare && (e[34893] = Ld("compare", n.compare)), n.maxAnisotropy && (e[34046] = n.maxAnisotropy), e;
  }
  function sd(n) {
    switch (n) {
      case "clamp-to-edge":
        return 33071;
      case "repeat":
        return 10497;
      case "mirror-repeat":
        return 33648;
    }
  }
  function Fd(n) {
    switch (n) {
      case "nearest":
        return 9728;
      case "linear":
        return 9729;
    }
  }
  function YN(n, e = "none") {
    if (!e) return Fd(n);
    switch (e) {
      case "none":
        return Fd(n);
      case "nearest":
        return n === "nearest" ? 9984 : 9986;
      case "linear":
        return n === "nearest" ? 9985 : 9987;
    }
  }
  class Vd extends po {
    constructor(e, t) {
      super(e, t);
      __publicField(this, "device");
      __publicField(this, "handle");
      __publicField(this, "parameters");
      this.device = e, this.parameters = J2(t), this.handle = this.handle || this.device.gl.createSampler(), this._setSamplerParameters(this.parameters);
    }
    destroy() {
      this.handle && (this.device.gl.deleteSampler(this.handle), this.handle = void 0);
    }
    toString() {
      return `Sampler(${this.id},${JSON.stringify(this.props)})`;
    }
    _setSamplerParameters(e) {
      for (const [t, i] of Object.entries(e)) {
        const s = Number(t);
        switch (s) {
          case 33082:
          case 33083:
            this.device.gl.samplerParameterf(this.handle, s, i);
            break;
          default:
            this.device.gl.samplerParameteri(this.handle, s, i);
            break;
        }
      }
    }
  }
  class Pr extends Kc {
    constructor(e, t) {
      super(e, {
        ...$e.defaultProps,
        ...t
      });
      __publicField(this, "device");
      __publicField(this, "gl");
      __publicField(this, "handle");
      __publicField(this, "texture");
      this.device = e, this.gl = this.device.gl, this.handle = null, this.texture = t.texture;
    }
  }
  const qN = "Failed to deduce GL constant from typed array";
  function KN(n) {
    switch (ArrayBuffer.isView(n) ? n.constructor : n) {
      case Float32Array:
        return 5126;
      case Uint16Array:
        return 5123;
      case Uint32Array:
        return 5125;
      case Uint8Array:
        return 5121;
      case Uint8ClampedArray:
        return 5121;
      case Int8Array:
        return 5120;
      case Int16Array:
        return 5122;
      case Int32Array:
        return 5124;
      default:
        throw new Error(qN);
    }
  }
  function ZN(n, e) {
    const { clamped: t = true } = e || {};
    switch (n) {
      case 5126:
        return Float32Array;
      case 5123:
      case 33635:
      case 32819:
      case 32820:
        return Uint16Array;
      case 5125:
        return Uint32Array;
      case 5121:
        return t ? Uint8ClampedArray : Uint8Array;
      case 5120:
        return Int8Array;
      case 5122:
        return Int16Array;
      case 5124:
        return Int32Array;
      default:
        throw new Error("Failed to deduce typed array type from GL constant");
    }
  }
  function eT(n) {
    switch (n) {
      case 6406:
      case 33326:
      case 6403:
      case 36244:
        return 1;
      case 33339:
      case 33340:
      case 33328:
      case 33320:
      case 33319:
        return 2;
      case 6407:
      case 36248:
      case 34837:
        return 3;
      case 6408:
      case 36249:
      case 34836:
        return 4;
      default:
        return 0;
    }
  }
  function QN(n) {
    switch (n) {
      case 5121:
        return 1;
      case 33635:
      case 32819:
      case 32820:
        return 2;
      case 5126:
        return 4;
      default:
        return 0;
    }
  }
  function Dc(n, e, t) {
    if (GN(e)) return t(n);
    const { nocatch: i = true } = e, s = Ss.get(n);
    s.push(), Qr(n, e);
    let a;
    if (i) a = t(n), s.pop();
    else try {
      a = t(n);
    } finally {
      s.pop();
    }
    return a;
  }
  function GN(n) {
    for (const e in n) return false;
    return true;
  }
  function JN(n, e, t) {
    const { dimension: i, width: s, height: a, depth: l = 0 } = t, { glInternalFormat: u } = t, h = t.glTarget;
    switch (i) {
      case "2d-array":
      case "3d":
        n.texStorage3D(h, e, u, s, a, l);
        break;
      default:
        n.texStorage2D(h, e, u, s, a);
    }
  }
  function Y0(n, e, t, i) {
    const { width: s, height: a } = i, { dimension: l, depth: u = 0, mipLevel: h = 0 } = i, { x: d = 0, y: p = 0, z: _ = 0 } = i, { glFormat: y, glType: v } = i, S = tT(i.glTarget, l, u), E = i.flipY ? {
      37440: true
    } : {};
    Dc(n, E, () => {
      switch (l) {
        case "2d-array":
        case "3d":
          n.bindTexture(S, e), n.texSubImage3D(S, h, d, p, _, s, a, u, y, v, t), n.bindTexture(S, null);
          break;
        case "2d":
        case "cube":
          n.bindTexture(S, e), n.texSubImage2D(S, h, d, p, s, a, y, v, t), n.bindTexture(S, null);
          break;
        default:
          throw new Error(l);
      }
    });
  }
  function q0(n, e, t) {
    const { dimension: i, width: s, height: a, depth: l = 0, mipLevel: u = 0, byteOffset: h = 0 } = t, { x: d = 0, y: p = 0, z: _ = 0 } = t, { glFormat: y, glType: v, compressed: S } = t, E = tT(t.glTarget, i, l);
    switch (i) {
      case "2d-array":
      case "3d":
        S ? n.compressedTexSubImage3D(E, u, d, p, _, s, a, l, y, e, h) : n.texSubImage3D(E, u, d, p, _, s, a, l, y, v, e, h);
        break;
      case "2d":
      case "cube":
        S ? n.compressedTexSubImage2D(E, u, d, p, s, a, y, e, h) : n.texSubImage2D(E, u, d, p, s, a, y, v, e, h);
        break;
      default:
        throw new Error(i);
    }
  }
  function eP(n) {
    switch (n) {
      case "1d":
        break;
      case "2d":
        return 3553;
      case "3d":
        return 32879;
      case "cube":
        return 34067;
      case "2d-array":
        return 35866;
    }
    throw new Error(n);
  }
  function tT(n, e, t) {
    return e === "cube" ? 34069 + t : n;
  }
  function tP(n, e) {
    var _a2;
    const { sourceX: t = 0, sourceY: i = 0, sourceAttachment: s = 0 } = e || {};
    let { target: a = null, sourceWidth: l, sourceHeight: u, sourceDepth: h, sourceFormat: d, sourceType: p } = e || {};
    const { framebuffer: _, deleteFramebuffer: y } = nT(n), { gl: v, handle: S } = _;
    l || (l = _.width), u || (u = _.height);
    const E = (_a2 = _.colorAttachments[s]) == null ? void 0 : _a2.texture;
    if (!E) throw new Error(`Invalid framebuffer attachment ${s}`);
    h = (E == null ? void 0 : E.depth) || 1, d || (d = (E == null ? void 0 : E.glFormat) || 6408), p || (p = (E == null ? void 0 : E.glType) || 5121), a = sP(a, p, d, l, u), p = p || KN(a);
    const M = v.bindFramebuffer(36160, S);
    return v.readBuffer(36064 + s), v.readPixels(t, i, l, u, d, p, a), v.readBuffer(36064), v.bindFramebuffer(36160, M || null), y && _.destroy(), a;
  }
  function nP(n, e) {
    const { target: t, sourceX: i = 0, sourceY: s = 0, sourceFormat: a = 6408, targetByteOffset: l = 0 } = e || {};
    let { sourceWidth: u, sourceHeight: h, sourceType: d } = e || {};
    const { framebuffer: p, deleteFramebuffer: _ } = nT(n);
    u = u || p.width, h = h || p.height;
    const y = p;
    d = d || 5121;
    let v = t;
    if (!v) {
      const E = eT(a), M = QN(d), F = l + u * h * E * M;
      v = y.device.createBuffer({
        byteLength: F
      });
    }
    const S = n.device.createCommandEncoder();
    return S.copyTextureToBuffer({
      sourceTexture: n,
      width: u,
      height: h,
      origin: [
        i,
        s
      ],
      destinationBuffer: v,
      byteOffset: l
    }), S.destroy(), _ && p.destroy(), v;
  }
  function nT(n) {
    return n instanceof Qc ? {
      framebuffer: n,
      deleteFramebuffer: false
    } : {
      framebuffer: iP(n),
      deleteFramebuffer: true
    };
  }
  function iP(n, e) {
    const { device: t, width: i, height: s, id: a } = n;
    return t.createFramebuffer({
      ...e,
      id: `framebuffer-for-${a}`,
      width: i,
      height: s,
      colorAttachments: [
        n
      ]
    });
  }
  function sP(n, e, t, i, s, a) {
    if (n) return n;
    e || (e = 5121);
    const l = ZN(e, {
      clamped: false
    }), u = eT(t);
    return new l(i * s * u);
  }
  class go extends $e {
    constructor(e, t) {
      super(e, t);
      __publicField(this, "device");
      __publicField(this, "gl");
      __publicField(this, "handle");
      __publicField(this, "sampler");
      __publicField(this, "view");
      __publicField(this, "mipmaps");
      __publicField(this, "compressed");
      __publicField(this, "glTarget");
      __publicField(this, "glFormat");
      __publicField(this, "glType");
      __publicField(this, "glInternalFormat");
      __publicField(this, "textureUnit", 0);
      const i = {
        ...this.props
      };
      i.data = t.data, this.device = e, this.gl = this.device.gl, this.glTarget = eP(this.props.dimension);
      const s = Z2(this.props.format);
      this.glInternalFormat = s.internalFormat, this.glFormat = s.format, this.glType = s.type, this.compressed = s.compressed, this.mipmaps = !!this.props.mipmaps, this._initialize(i), Object.seal(this);
    }
    _initialize(e) {
      this.handle = this.props.handle || this.gl.createTexture(), this.device.setSpectorMetadata(this.handle, {
        ...this.props,
        data: e.data
      });
      let { width: t, height: i } = e;
      if (!t || !i) {
        const s = $e.getTextureDataSize(e.data);
        t = (s == null ? void 0 : s.width) || 1, i = (s == null ? void 0 : s.height) || 1;
      }
      if (this.width = t, this.height = i, this.depth = e.depth, this.setSampler(e.sampler), this.view = new Pr(this.device, {
        ...this.props,
        texture: this
      }), this.bind(), JN(this.gl, this.mipLevels, this), e.data) switch (e.dimension) {
        case "1d":
          this.setTexture1DData(e.data);
          break;
        case "2d":
          this.setTexture2DData(e.data);
          break;
        case "3d":
          this.setTexture3DData(e.data);
          break;
        case "cube":
          this.setTextureCubeData(e.data);
          break;
        case "2d-array":
          this.setTextureArrayData(e.data);
          break;
        case "cube-array":
          this.setTextureCubeArrayData(e.data);
          break;
        default:
          throw new Error(e.dimension);
      }
      this.mipmaps && this.generateMipmap();
    }
    destroy() {
      this.handle && (this.gl.deleteTexture(this.handle), this.removeStats(), this.trackDeallocatedMemory("Texture"), this.destroyed = true);
    }
    createView(e) {
      return new Pr(this.device, {
        ...e,
        texture: this
      });
    }
    setSampler(e = {}) {
      let t;
      e instanceof Vd ? (this.sampler = e, t = e.props) : (this.sampler = new Vd(this.device, e), t = e);
      const i = J2(t);
      this._setSamplerParameters(i);
    }
    generateMipmap(e) {
      if (!(!(this.device.isTextureFormatRenderable(this.props.format) && this.device.isTextureFormatFilterable(this.props.format)) && (J.warn(`${this} is not renderable or filterable, may not be able to generate mipmaps`)(), !(e == null ? void 0 : e.force)))) try {
        this.gl.bindTexture(this.glTarget, this.handle), this.gl.generateMipmap(this.glTarget);
      } catch (i) {
        J.warn(`Error generating mipmap for ${this}: ${i.message}`)();
      } finally {
        this.gl.bindTexture(this.glTarget, null);
      }
    }
    copyExternalImage(e) {
      const t = $e.getExternalImageSize(e.image), i = {
        ...$e.defaultCopyExternalImageOptions,
        ...t,
        ...e
      }, { image: s, depth: a, mipLevel: l, x: u, y: h, z: d, flipY: p } = i;
      let { width: _, height: y } = i;
      const { dimension: v, glTarget: S, glFormat: E, glInternalFormat: M, glType: F } = this;
      if (_ = Math.min(_, this.width - u), y = Math.min(y, this.height - h), e.sourceX || e.sourceY) throw new Error("WebGL does not support sourceX/sourceY)");
      return Y0(this.device.gl, this.handle, s, {
        dimension: v,
        mipLevel: l,
        x: u,
        y: h,
        z: d,
        width: _,
        height: y,
        depth: a,
        glFormat: E,
        glType: F,
        glTarget: S,
        flipY: p
      }), {
        width: i.width,
        height: i.height
      };
    }
    setTexture1DData(e) {
      throw new Error("setTexture1DData not supported in WebGL.");
    }
    setTexture2DData(e, t = 0) {
      this.bind();
      const i = $e.normalizeTextureData(e, this);
      i.length > 1 && this.props.mipmaps !== false && J.warn(`Texture ${this.id} mipmap and multiple LODs.`)();
      for (let s = 0; s < i.length; s++) {
        const a = i[s];
        this._setMipLevel(t, s, a);
      }
      this.unbind();
    }
    setTexture3DData(e) {
      if (this.props.dimension !== "3d") throw new Error(this.id);
      ArrayBuffer.isView(e) && (this.bind(), q0(this.device.gl, e, this), this.unbind());
    }
    setTextureCubeData(e, t = 0) {
      if (this.props.dimension !== "cube") throw new Error(this.id);
      for (const i of $e.CubeFaces) this.setTextureCubeFaceData(e[i], i);
    }
    setTextureArrayData(e) {
      throw this.props.dimension !== "2d-array" ? new Error(this.id) : new Error("setTextureArrayData not implemented.");
    }
    setTextureCubeArrayData(e) {
      throw new Error("setTextureCubeArrayData not supported in WebGL2.");
    }
    setTextureCubeFaceData(e, t, i = 0) {
      Array.isArray(e) && e.length > 1 && this.props.mipmaps !== false && J.warn(`${this.id} has mipmap and multiple LODs.`)();
      const s = $e.CubeFaces.indexOf(t);
      this.setTexture2DData(e, s);
    }
    update() {
      throw new Error("Texture.update() not implemented. Use ExternalTexture");
    }
    setImageDataForFace(e) {
      const { face: t, width: i, height: s, pixels: a, data: l, format: u = 6408, type: h = 5121 } = e, { gl: d } = this, p = a || l;
      this.bind(), p instanceof Promise ? p.then((_) => this.setImageDataForFace(Object.assign({}, e, {
        face: t,
        data: _,
        pixels: _
      }))) : this.width || this.height ? d.texImage2D(t, 0, u, i, s, 0, u, h, p) : d.texImage2D(t, 0, u, u, h, p);
    }
    _getImageDataMap(e) {
      for (let t = 0; t < $e.CubeFaces.length; ++t) {
        const i = $e.CubeFaces[t];
        e[i] && (e[34069 + t] = e[i], delete e[i]);
      }
      return e;
    }
    _setSamplerParameters(e) {
      J.log(1, `${this.id} sampler parameters`, this.device.getGLKeys(e))(), this.gl.bindTexture(this.glTarget, this.handle);
      for (const [t, i] of Object.entries(e)) {
        const s = Number(t), a = i;
        switch (s) {
          case 33082:
          case 33083:
            this.gl.texParameterf(this.glTarget, s, a);
            break;
          case 10241:
            this.gl.texParameteri(this.glTarget, s, a);
            break;
          case 10242:
          case 10243:
            this.gl.texParameteri(this.glTarget, s, a);
            break;
          case 34046:
            this.device.features.has("texture-filterable-anisotropic-webgl") && this.gl.texParameteri(this.glTarget, s, a);
            break;
          default:
            this.gl.texParameteri(this.glTarget, s, a);
            break;
        }
      }
      this.gl.bindTexture(this.glTarget, null);
    }
    _setMipLevel(e, t, i, s = this.glTarget) {
      if ($e.isExternalImage(i)) {
        Y0(this.device.gl, this.handle, i, {
          ...this,
          depth: e,
          mipLevel: t,
          glTarget: s,
          flipY: this.props.flipY
        });
        return;
      }
      if ($e.isTextureLevelData(i)) {
        q0(this.device.gl, i.data, {
          ...this,
          depth: e,
          mipLevel: t,
          glTarget: s
        });
        return;
      }
      throw new Error("Texture: invalid image data");
    }
    getActiveUnit() {
      return this.gl.getParameter(34016) - 33984;
    }
    bind(e) {
      const { gl: t } = this;
      return e !== void 0 && (this.textureUnit = e, t.activeTexture(33984 + e)), t.bindTexture(this.glTarget, this.handle), e;
    }
    unbind(e) {
      const { gl: t } = this;
      return e !== void 0 && (this.textureUnit = e, t.activeTexture(33984 + e)), t.bindTexture(this.glTarget, null), e;
    }
  }
  const rP = [
    1,
    2,
    4,
    8
  ];
  class aP extends _s {
    constructor(e, t) {
      var _a2, _b3;
      super(e, t);
      __publicField(this, "device");
      __publicField(this, "glParameters");
      this.device = e;
      let i;
      if (!((_a2 = t == null ? void 0 : t.parameters) == null ? void 0 : _a2.viewport)) if (t == null ? void 0 : t.framebuffer) {
        const { width: a, height: l } = t.framebuffer;
        i = [
          0,
          0,
          a,
          l
        ];
      } else {
        const [a, l] = e.getCanvasContext().getDrawingBufferSize();
        i = [
          0,
          0,
          a,
          l
        ];
      }
      if (this.device.pushState(), this.setParameters({
        viewport: i,
        ...this.props.parameters
      }), (_b3 = this.props.framebuffer) == null ? void 0 : _b3.handle) if (this.props.framebuffer) {
        const a = this.props.framebuffer.colorAttachments.map((l, u) => 36064 + u);
        this.device.gl.drawBuffers(a);
      } else this.device.gl.drawBuffers([
        1029
      ]);
      this.clear();
    }
    end() {
      this.device.popState();
    }
    pushDebugGroup(e) {
    }
    popDebugGroup() {
    }
    insertDebugMarker(e) {
    }
    setParameters(e = {}) {
      const t = {
        ...this.glParameters
      };
      t.framebuffer = this.props.framebuffer || null, this.props.depthReadOnly && (t.depthMask = !this.props.depthReadOnly), t.stencilMask = this.props.stencilReadOnly ? 0 : 1, t[35977] = this.props.discard, e.viewport && (e.viewport.length >= 6 ? (t.viewport = e.viewport.slice(0, 4), t.depthRange = [
        e.viewport[4],
        e.viewport[5]
      ]) : t.viewport = e.viewport), e.scissorRect && (t.scissorTest = true, t.scissor = e.scissorRect), e.blendConstant && (t.blendColor = e.blendConstant), e.stencilReference && (console.warn("RenderPassParameters.stencilReference not yet implemented in WebGL"), e[2967] = e.stencilReference), e.colorMask && (t.colorMask = rP.map((i) => !!(i & e.colorMask))), this.glParameters = t, Qr(this.device.gl, t);
    }
    beginOcclusionQuery(e) {
      var _a2;
      (_a2 = this.props.occlusionQuerySet) == null ? void 0 : _a2.beginOcclusionQuery();
    }
    endOcclusionQuery() {
      var _a2;
      (_a2 = this.props.occlusionQuerySet) == null ? void 0 : _a2.endOcclusionQuery();
    }
    clear() {
      const e = {
        ...this.glParameters
      };
      let t = 0;
      this.props.clearColors && this.props.clearColors.forEach((i, s) => {
        i && this.clearColorBuffer(s, i);
      }), this.props.clearColor !== false && this.props.clearColors === void 0 && (t |= 16384, e.clearColor = this.props.clearColor), this.props.clearDepth !== false && (t |= 256, e.clearDepth = this.props.clearDepth), this.props.clearStencil !== false && (t |= 1024, e.clearStencil = this.props.clearStencil), t !== 0 && Dc(this.device.gl, e, () => {
        this.device.gl.clear(t);
      });
    }
    clearColorBuffer(e = 0, t = [
      0,
      0,
      0,
      0
    ]) {
      Dc(this.device.gl, {
        framebuffer: this.props.framebuffer
      }, () => {
        switch (t.constructor) {
          case Int8Array:
          case Int16Array:
          case Int32Array:
            this.device.gl.clearBufferiv(6144, e, t);
            break;
          case Uint8Array:
          case Uint8ClampedArray:
          case Uint16Array:
          case Uint32Array:
            this.device.gl.clearBufferuiv(6144, e, t);
            break;
          case Float32Array:
            this.device.gl.clearBufferfv(6144, e, t);
            break;
          default:
            throw new Error("clearColorBuffer: color must be typed array");
        }
      });
    }
  }
  function oP(n) {
    return lP.includes(n);
  }
  const lP = [
    35678,
    35680,
    35679,
    35682,
    36289,
    36292,
    36293,
    36298,
    36299,
    36300,
    36303,
    36306,
    36307,
    36308,
    36311
  ], iT = {
    5126: [
      5126,
      1,
      "float",
      "f32",
      "float32"
    ],
    35664: [
      5126,
      2,
      "vec2",
      "vec2<f32>",
      "float32x2"
    ],
    35665: [
      5126,
      3,
      "vec3",
      "vec3<f32>",
      "float32x3"
    ],
    35666: [
      5126,
      4,
      "vec4",
      "vec4<f32>",
      "float32x4"
    ],
    5124: [
      5124,
      1,
      "int",
      "i32",
      "sint32"
    ],
    35667: [
      5124,
      2,
      "ivec2",
      "vec2<i32>",
      "sint32x2"
    ],
    35668: [
      5124,
      3,
      "ivec3",
      "vec3<i32>",
      "sint32x3"
    ],
    35669: [
      5124,
      4,
      "ivec4",
      "vec4<i32>",
      "sint32x4"
    ],
    5125: [
      5125,
      1,
      "uint",
      "u32",
      "uint32"
    ],
    36294: [
      5125,
      2,
      "uvec2",
      "vec2<u32>",
      "uint32x2"
    ],
    36295: [
      5125,
      3,
      "uvec3",
      "vec3<u32>",
      "uint32x3"
    ],
    36296: [
      5125,
      4,
      "uvec4",
      "vec4<u32>",
      "uint32x4"
    ],
    35670: [
      5126,
      1,
      "bool",
      "f32",
      "float32"
    ],
    35671: [
      5126,
      2,
      "bvec2",
      "vec2<f32>",
      "float32x2"
    ],
    35672: [
      5126,
      3,
      "bvec3",
      "vec3<f32>",
      "float32x3"
    ],
    35673: [
      5126,
      4,
      "bvec4",
      "vec4<f32>",
      "float32x4"
    ],
    35674: [
      5126,
      8,
      "mat2",
      "mat2x2<f32>"
    ],
    35685: [
      5126,
      8,
      "mat2x3",
      "mat2x3<f32>"
    ],
    35686: [
      5126,
      8,
      "mat2x4",
      "mat2x4<f32>"
    ],
    35687: [
      5126,
      12,
      "mat3x2",
      "mat3x2<f32>"
    ],
    35675: [
      5126,
      12,
      "mat3",
      "mat3x3<f32>"
    ],
    35688: [
      5126,
      12,
      "mat3x4",
      "mat3x4<f32>"
    ],
    35689: [
      5126,
      16,
      "mat4x2",
      "mat4x2<f32>"
    ],
    35690: [
      5126,
      16,
      "mat4x3",
      "mat4x3<f32>"
    ],
    35676: [
      5126,
      16,
      "mat4",
      "mat4x4<f32>"
    ]
  };
  function sT(n) {
    const e = iT[n];
    if (!e) throw new Error("uniform");
    const [t, i, , s] = e;
    return {
      format: s,
      components: i,
      glType: t
    };
  }
  function cP(n) {
    const e = iT[n];
    if (!e) throw new Error("attribute");
    const [, t, , i, s] = e;
    return {
      attributeType: i,
      vertexFormat: s,
      components: t
    };
  }
  function uP(n, e) {
    const t = {
      attributes: [],
      bindings: []
    };
    t.attributes = fP(n, e);
    const i = gP(n, e);
    for (const u of i) {
      const h = u.uniforms.map((d) => ({
        name: d.name,
        format: d.format,
        byteOffset: d.byteOffset,
        byteStride: d.byteStride,
        arrayLength: d.arrayLength
      }));
      t.bindings.push({
        type: "uniform",
        name: u.name,
        group: 0,
        location: u.location,
        visibility: (u.vertex ? 1 : 0) & (u.fragment ? 2 : 0),
        minBindingSize: u.byteLength,
        uniforms: h
      });
    }
    const s = dP(n, e);
    let a = 0;
    for (const u of s) if (oP(u.type)) {
      const { viewDimension: h, sampleType: d } = mP(u.type);
      t.bindings.push({
        type: "texture",
        name: u.name,
        group: 0,
        location: a,
        viewDimension: h,
        sampleType: d
      }), u.textureUnit = a, a += 1;
    }
    s.length && (t.uniforms = s);
    const l = hP(n, e);
    return (l == null ? void 0 : l.length) && (t.varyings = l), t;
  }
  function fP(n, e) {
    const t = [], i = n.getProgramParameter(e, 35721);
    for (let s = 0; s < i; s++) {
      const a = n.getActiveAttrib(e, s);
      if (!a) throw new Error("activeInfo");
      const { name: l, type: u } = a, h = n.getAttribLocation(e, l);
      if (h >= 0) {
        const { attributeType: d } = cP(u), p = /instance/i.test(l) ? "instance" : "vertex";
        t.push({
          name: l,
          location: h,
          stepMode: p,
          type: d
        });
      }
    }
    return t.sort((s, a) => s.location - a.location), t;
  }
  function hP(n, e) {
    const t = [], i = n.getProgramParameter(e, 35971);
    for (let s = 0; s < i; s++) {
      const a = n.getTransformFeedbackVarying(e, s);
      if (!a) throw new Error("activeInfo");
      const { name: l, type: u, size: h } = a, { glType: d, components: p } = sT(u), _ = {
        location: s,
        name: l,
        type: d,
        size: h * p
      };
      t.push(_);
    }
    return t.sort((s, a) => s.location - a.location), t;
  }
  function dP(n, e) {
    const t = [], i = n.getProgramParameter(e, 35718);
    for (let s = 0; s < i; s++) {
      const a = n.getActiveUniform(e, s);
      if (!a) throw new Error("activeInfo");
      const { name: l, size: u, type: h } = a, { name: d, isArray: p } = _P(l);
      let _ = n.getUniformLocation(e, d);
      const y = {
        location: _,
        name: d,
        size: u,
        type: h,
        isArray: p
      };
      if (t.push(y), y.size > 1) for (let v = 0; v < y.size; v++) {
        const S = `${d}[${v}]`;
        _ = n.getUniformLocation(e, S);
        const E = {
          ...y,
          name: S,
          location: _
        };
        t.push(E);
      }
    }
    return t;
  }
  function gP(n, e) {
    const t = (a, l) => n.getActiveUniformBlockParameter(e, a, l), i = [], s = n.getProgramParameter(e, 35382);
    for (let a = 0; a < s; a++) {
      const l = {
        name: n.getActiveUniformBlockName(e, a) || "",
        location: t(a, 35391),
        byteLength: t(a, 35392),
        vertex: t(a, 35396),
        fragment: t(a, 35398),
        uniformCount: t(a, 35394),
        uniforms: []
      }, u = t(a, 35395) || [], h = n.getActiveUniforms(e, u, 35383), d = n.getActiveUniforms(e, u, 35384), p = n.getActiveUniforms(e, u, 35387), _ = n.getActiveUniforms(e, u, 35388);
      for (let y = 0; y < l.uniformCount; ++y) {
        const v = n.getActiveUniform(e, u[y]);
        if (!v) throw new Error("activeInfo");
        l.uniforms.push({
          name: v.name,
          format: sT(h[y]).format,
          type: h[y],
          arrayLength: d[y],
          byteOffset: p[y],
          byteStride: _[y]
        });
      }
      i.push(l);
    }
    return i.sort((a, l) => a.location - l.location), i;
  }
  const pP = {
    35678: [
      "2d",
      "float"
    ],
    35680: [
      "cube",
      "float"
    ],
    35679: [
      "3d",
      "float"
    ],
    35682: [
      "3d",
      "depth"
    ],
    36289: [
      "2d-array",
      "float"
    ],
    36292: [
      "2d-array",
      "depth"
    ],
    36293: [
      "cube",
      "float"
    ],
    36298: [
      "2d",
      "sint"
    ],
    36299: [
      "3d",
      "sint"
    ],
    36300: [
      "cube",
      "sint"
    ],
    36303: [
      "2d-array",
      "uint"
    ],
    36306: [
      "2d",
      "uint"
    ],
    36307: [
      "3d",
      "uint"
    ],
    36308: [
      "cube",
      "uint"
    ],
    36311: [
      "2d-array",
      "uint"
    ]
  };
  function mP(n) {
    const e = pP[n];
    if (!e) throw new Error("sampler");
    const [t, i] = e;
    return {
      viewDimension: t,
      sampleType: i
    };
  }
  function _P(n) {
    if (n[n.length - 1] !== "]") return {
      name: n,
      length: 1,
      isArray: false
    };
    const t = /([^[]*)(\[[0-9]+\])?/.exec(n);
    if (!t || t.length < 2) throw new Error(`Failed to parse GLSL uniform name ${n}`);
    return {
      name: t[1],
      length: t[2] ? 1 : 0,
      isArray: !!t[2]
    };
  }
  function yP(n, e, t, i) {
    const s = n;
    let a = i;
    a === true && (a = 1), a === false && (a = 0);
    const l = typeof a == "number" ? [
      a
    ] : a;
    switch (t) {
      case 35678:
      case 35680:
      case 35679:
      case 35682:
      case 36289:
      case 36292:
      case 36293:
      case 36298:
      case 36299:
      case 36300:
      case 36303:
      case 36306:
      case 36307:
      case 36308:
      case 36311:
        if (typeof i != "number") throw new Error("samplers must be set to integers");
        return n.uniform1i(e, i);
      case 5126:
        return n.uniform1fv(e, l);
      case 35664:
        return n.uniform2fv(e, l);
      case 35665:
        return n.uniform3fv(e, l);
      case 35666:
        return n.uniform4fv(e, l);
      case 5124:
        return n.uniform1iv(e, l);
      case 35667:
        return n.uniform2iv(e, l);
      case 35668:
        return n.uniform3iv(e, l);
      case 35669:
        return n.uniform4iv(e, l);
      case 35670:
        return n.uniform1iv(e, l);
      case 35671:
        return n.uniform2iv(e, l);
      case 35672:
        return n.uniform3iv(e, l);
      case 35673:
        return n.uniform4iv(e, l);
      case 5125:
        return s.uniform1uiv(e, l, 1);
      case 36294:
        return s.uniform2uiv(e, l, 2);
      case 36295:
        return s.uniform3uiv(e, l, 3);
      case 36296:
        return s.uniform4uiv(e, l, 4);
      case 35674:
        return n.uniformMatrix2fv(e, false, l);
      case 35675:
        return n.uniformMatrix3fv(e, false, l);
      case 35676:
        return n.uniformMatrix4fv(e, false, l);
      case 35685:
        return s.uniformMatrix2x3fv(e, false, l);
      case 35686:
        return s.uniformMatrix2x4fv(e, false, l);
      case 35687:
        return s.uniformMatrix3x2fv(e, false, l);
      case 35688:
        return s.uniformMatrix3x4fv(e, false, l);
      case 35689:
        return s.uniformMatrix4x2fv(e, false, l);
      case 35690:
        return s.uniformMatrix4x3fv(e, false, l);
    }
    throw new Error("Illegal uniform");
  }
  function bP(n) {
    return B2(n) !== null || typeof n == "number" || typeof n == "boolean";
  }
  function vP(n) {
    const e = {
      bindings: {},
      uniforms: {}
    };
    return Object.keys(n).forEach((t) => {
      const i = n[t];
      bP(i) ? e.uniforms[t] = i : e.bindings[t] = i;
    }), e;
  }
  function TP(n) {
    switch (n) {
      case "point-list":
        return 0;
      case "line-list":
        return 1;
      case "line-strip":
        return 3;
      case "triangle-list":
        return 4;
      case "triangle-strip":
        return 5;
      default:
        throw new Error(n);
    }
  }
  function xP(n) {
    switch (n) {
      case "point-list":
        return 0;
      case "line-list":
        return 1;
      case "line-strip":
        return 1;
      case "triangle-list":
        return 4;
      case "triangle-strip":
        return 4;
      default:
        throw new Error(n);
    }
  }
  const K0 = 4;
  class SP extends Vr {
    constructor(e, t) {
      super(e, t);
      __publicField(this, "device");
      __publicField(this, "handle");
      __publicField(this, "vs");
      __publicField(this, "fs");
      __publicField(this, "introspectedLayout");
      __publicField(this, "uniforms", {});
      __publicField(this, "bindings", {});
      __publicField(this, "varyings", null);
      __publicField(this, "_uniformCount", 0);
      __publicField(this, "_uniformSetters", {});
      this.device = e, this.handle = this.props.handle || this.device.gl.createProgram(), this.device.setSpectorMetadata(this.handle, {
        id: this.props.id
      }), this.vs = t.vs, this.fs = t.fs;
      const { varyings: i, bufferMode: s = 35981 } = t;
      i && i.length > 0 && (this.varyings = i, this.device.gl.transformFeedbackVaryings(this.handle, i, s)), this._linkShaders(), J.time(1, `RenderPipeline ${this.id} - shaderLayout introspection`)(), this.introspectedLayout = uP(this.device.gl, this.handle), J.timeEnd(1, `RenderPipeline ${this.id} - shaderLayout introspection`)(), this.shaderLayout = AP(this.introspectedLayout, t.shaderLayout);
    }
    destroy() {
      this.handle && (this.device.gl.deleteProgram(this.handle), this.destroyed = true);
    }
    setBindings(e, t) {
      for (const [i, s] of Object.entries(e)) {
        const a = this.shaderLayout.bindings.find((l) => l.name === i) || this.shaderLayout.bindings.find((l) => l.name === `${i}Uniforms`);
        if (!a) {
          const l = this.shaderLayout.bindings.map((u) => `"${u.name}"`).join(", ");
          (t == null ? void 0 : t.disableWarnings) || J.warn(`No binding "${i}" in render pipeline "${this.id}", expected one of ${l}`, s)();
          continue;
        }
        switch (s || J.warn(`Unsetting binding "${i}" in render pipeline "${this.id}"`)(), a.type) {
          case "uniform":
            if (!(s instanceof ho) && !(s.buffer instanceof ho)) throw new Error("buffer value");
            break;
          case "texture":
            if (!(s instanceof Pr || s instanceof go || s instanceof fo)) throw new Error("texture value");
            break;
          case "sampler":
            J.warn(`Ignoring sampler ${i}`)();
            break;
          default:
            throw new Error(a.type);
        }
        this.bindings[i] = s;
      }
    }
    draw(e) {
      var _a2;
      const { renderPass: t, parameters: i = this.props.parameters, topology: s = this.props.topology, vertexArray: a, vertexCount: l, instanceCount: u, isInstanced: h = false, firstVertex: d = 0, transformFeedback: p } = e, _ = TP(s), y = !!a.indexBuffer, v = (_a2 = a.indexBuffer) == null ? void 0 : _a2.glIndexType;
      if (this.linkStatus !== "success") return J.info(2, `RenderPipeline:${this.id}.draw() aborted - waiting for shader linking`)(), false;
      if (!this._areTexturesRenderable()) return J.info(2, `RenderPipeline:${this.id}.draw() aborted - textures not yet loaded`)(), false;
      this.device.gl.useProgram(this.handle), a.bindBeforeRender(t), p && p.begin(this.props.topology), this._applyBindings(), this._applyUniforms();
      const S = t;
      return HN(this.device, i, S.glParameters, () => {
        y && h ? this.device.gl.drawElementsInstanced(_, l || 0, v, d, u || 0) : y ? this.device.gl.drawElements(_, l || 0, v, d) : h ? this.device.gl.drawArraysInstanced(_, d, l || 0, u || 0) : this.device.gl.drawArrays(_, d, l || 0), p && p.end();
      }), a.unbindAfterRender(t), true;
    }
    setUniformsWebGL(e) {
      const { bindings: t } = vP(e);
      Object.keys(t).forEach((i) => {
        J.warn(`Unsupported value "${JSON.stringify(t[i])}" used in setUniforms() for key ${i}. Use setBindings() instead?`)();
      }), Object.assign(this.uniforms, e);
    }
    async _linkShaders() {
      const { gl: e } = this.device;
      if (e.attachShader(this.handle, this.vs.handle), e.attachShader(this.handle, this.fs.handle), J.time(K0, `linkProgram for ${this.id}`)(), e.linkProgram(this.handle), J.timeEnd(K0, `linkProgram for ${this.id}`)(), J.level, !this.device.features.has("compilation-status-async-webgl")) {
        const i = this._getLinkStatus();
        this._reportLinkStatus(i);
        return;
      }
      J.once(1, "RenderPipeline linking is asynchronous")(), await this._waitForLinkComplete(), J.info(2, `RenderPipeline ${this.id} - async linking complete: ${this.linkStatus}`)();
      const t = this._getLinkStatus();
      this._reportLinkStatus(t);
    }
    async _reportLinkStatus(e) {
      var _a2;
      switch (e) {
        case "success":
          return;
        default:
          switch (this.vs.compilationStatus) {
            case "error":
              throw this.vs.debugShader(), new Error(`Error during compilation of shader ${this.vs.id}`);
            case "pending":
              this.vs.asyncCompilationStatus.then(() => this.vs.debugShader());
              break;
          }
          switch ((_a2 = this.fs) == null ? void 0 : _a2.compilationStatus) {
            case "error":
              throw this.fs.debugShader(), new Error(`Error during compilation of shader ${this.fs.id}`);
            case "pending":
              this.fs.asyncCompilationStatus.then(() => this.fs.debugShader());
              break;
          }
          const t = this.device.gl.getProgramInfoLog(this.handle);
          throw new Error(`Error during ${e}: ${t}`);
      }
    }
    _getLinkStatus() {
      const { gl: e } = this.device;
      return e.getProgramParameter(this.handle, 35714) ? (e.validateProgram(this.handle), e.getProgramParameter(this.handle, 35715) ? (this.linkStatus = "success", "success") : (this.linkStatus = "error", "validation")) : (this.linkStatus = "error", "linking");
    }
    async _waitForLinkComplete() {
      const e = async (s) => await new Promise((a) => setTimeout(a, s));
      if (!this.device.features.has("compilation-status-async-webgl")) {
        await e(10);
        return;
      }
      const { gl: i } = this.device;
      for (; ; ) {
        if (i.getProgramParameter(this.handle, 37297)) return;
        await e(10);
      }
    }
    _areTexturesRenderable() {
      let e = true;
      for (const t of this.shaderLayout.bindings) !this.bindings[t.name] && !this.bindings[t.name.replace(/Uniforms$/, "")] && (J.warn(`Binding ${t.name} not found in ${this.id}`)(), e = false);
      return e;
    }
    _applyBindings() {
      if (this.linkStatus !== "success") return;
      const { gl: e } = this.device;
      e.useProgram(this.handle);
      let t = 0, i = 0;
      for (const s of this.shaderLayout.bindings) {
        const a = this.bindings[s.name] || this.bindings[s.name.replace(/Uniforms$/, "")];
        if (!a) throw new Error(`No value for binding ${s.name} in ${this.id}`);
        switch (s.type) {
          case "uniform":
            const { name: l } = s, u = e.getUniformBlockIndex(this.handle, l);
            if (u === 4294967295) throw new Error(`Invalid uniform block name ${l}`);
            e.uniformBlockBinding(this.handle, i, u), a instanceof ho ? e.bindBufferBase(35345, i, a.handle) : e.bindBufferRange(35345, i, a.buffer.handle, a.offset || 0, a.size || a.buffer.byteLength - a.offset), i += 1;
            break;
          case "texture":
            if (!(a instanceof Pr || a instanceof go || a instanceof fo)) throw new Error("texture");
            let h;
            if (a instanceof Pr) h = a.texture;
            else if (a instanceof go) h = a;
            else if (a instanceof fo && a.colorAttachments[0] instanceof Pr) J.warn("Passing framebuffer in texture binding may be deprecated. Use fbo.colorAttachments[0] instead")(), h = a.colorAttachments[0].texture;
            else throw new Error("No texture");
            e.activeTexture(33984 + t), e.bindTexture(h.glTarget, h.handle), t += 1;
            break;
          case "sampler":
            break;
          case "storage":
          case "read-only-storage":
            throw new Error(`binding type '${s.type}' not supported in WebGL`);
        }
      }
    }
    _applyUniforms() {
      for (const e of this.shaderLayout.uniforms || []) {
        const { name: t, location: i, type: s, textureUnit: a } = e, l = this.uniforms[t] ?? a;
        l !== void 0 && yP(this.device.gl, i, s, l);
      }
    }
  }
  function AP(n, e) {
    const t = {
      ...n,
      attributes: n.attributes.map((i) => ({
        ...i
      }))
    };
    for (const i of (e == null ? void 0 : e.attributes) || []) {
      const s = t.attributes.find((a) => a.name === i.name);
      s ? (s.type = i.type || s.type, s.stepMode = i.stepMode || s.stepMode) : J.warn(`shader layout attribute ${i.name} not present in shader`);
    }
    return t;
  }
  class wP extends fg {
    constructor(e) {
      super(e, {});
      __publicField(this, "device");
      __publicField(this, "commands", []);
      this.device = e;
    }
    submitCommands(e = this.commands) {
      for (const t of e) switch (t.name) {
        case "copy-buffer-to-buffer":
          EP(this.device, t.options);
          break;
        case "copy-buffer-to-texture":
          RP(this.device, t.options);
          break;
        case "copy-texture-to-buffer":
          CP(this.device, t.options);
          break;
        case "copy-texture-to-texture":
          MP(this.device, t.options);
          break;
        default:
          throw new Error(t.name);
      }
    }
  }
  function EP(n, e) {
    const t = e.sourceBuffer, i = e.destinationBuffer;
    n.gl.bindBuffer(36662, t.handle), n.gl.bindBuffer(36663, i.handle), n.gl.copyBufferSubData(36662, 36663, e.sourceOffset ?? 0, e.destinationOffset ?? 0, e.size), n.gl.bindBuffer(36662, null), n.gl.bindBuffer(36663, null);
  }
  function RP(n, e) {
    throw new Error("Not implemented");
  }
  function CP(n, e) {
    const { sourceTexture: t, mipLevel: i = 0, aspect: s = "all", width: a = e.sourceTexture.width, height: l = e.sourceTexture.height, depthOrArrayLayers: u = 0, origin: h = [
      0,
      0
    ], destinationBuffer: d, byteOffset: p = 0, bytesPerRow: _, rowsPerImage: y } = e;
    if (s !== "all") throw new Error("aspect not supported in WebGL");
    if (i !== 0 || u !== 0 || _ || y) throw new Error("not implemented");
    const { framebuffer: v, destroyFramebuffer: S } = rT(t);
    let E;
    try {
      const M = d, F = a || v.width, H = l || v.height, O = Z2(v.colorAttachments[0].texture.props.format), U = O.format, B = O.type;
      n.gl.bindBuffer(35051, M.handle), E = n.gl.bindFramebuffer(36160, v.handle), n.gl.readPixels(h[0], h[1], F, H, U, B, p);
    } finally {
      n.gl.bindBuffer(35051, null), E !== void 0 && n.gl.bindFramebuffer(36160, E), S && v.destroy();
    }
  }
  function MP(n, e) {
    const { sourceTexture: t, destinationMipLevel: i = 0, origin: s = [
      0,
      0
    ], destinationOrigin: a = [
      0,
      0
    ], destinationTexture: l } = e;
    let { width: u = e.destinationTexture.width, height: h = e.destinationTexture.height } = e;
    const { framebuffer: d, destroyFramebuffer: p } = rT(t), [_, y] = s, [v, S, E] = a, M = n.gl.bindFramebuffer(36160, d.handle);
    let F = null, H;
    if (l instanceof go) F = l, u = Number.isFinite(u) ? u : F.width, h = Number.isFinite(h) ? h : F.height, F.bind(0), H = F.glTarget;
    else throw new Error("invalid destination");
    switch (H) {
      case 3553:
      case 34067:
        n.gl.copyTexSubImage2D(H, i, v, S, _, y, u, h);
        break;
      case 35866:
      case 32879:
        n.gl.copyTexSubImage3D(H, i, v, S, E, _, y, u, h);
        break;
    }
    F && F.unbind(), n.gl.bindFramebuffer(36160, M), p && d.destroy();
  }
  function rT(n) {
    if (n instanceof $e) {
      const { width: e, height: t, id: i } = n;
      return {
        framebuffer: n.device.createFramebuffer({
          id: `framebuffer-for-${i}`,
          width: e,
          height: t,
          colorAttachments: [
            n
          ]
        }),
        destroyFramebuffer: true
      };
    }
    return {
      framebuffer: n,
      destroyFramebuffer: false
    };
  }
  class OP extends ug {
    constructor(e, t) {
      super(e, t);
      __publicField(this, "device");
      __publicField(this, "commandBuffer");
      this.device = e, this.commandBuffer = new wP(e);
    }
    destroy() {
    }
    finish() {
      this.commandBuffer.submitCommands();
    }
    copyBufferToBuffer(e) {
      this.commandBuffer.commands.push({
        name: "copy-buffer-to-buffer",
        options: e
      });
    }
    copyBufferToTexture(e) {
      this.commandBuffer.commands.push({
        name: "copy-buffer-to-texture",
        options: e
      });
    }
    copyTextureToBuffer(e) {
      this.commandBuffer.commands.push({
        name: "copy-texture-to-buffer",
        options: e
      });
    }
    copyTextureToTexture(e) {
      this.commandBuffer.commands.push({
        name: "copy-texture-to-texture",
        options: e
      });
    }
    pushDebugGroup(e) {
    }
    popDebugGroup() {
    }
    insertDebugMarker(e) {
    }
    resolveQuerySet(e, t, i) {
    }
  }
  function IP(n) {
    const { target: e, source: t, start: i = 0, count: s = 1 } = n, a = t.length, l = s * a;
    let u = 0;
    for (let h = i; u < a; u++) e[h++] = t[u];
    for (; u < l; ) u < l - u ? (e.copyWithin(i + u, i, i + u), u *= 2) : (e.copyWithin(i + u, i, i + l - u), u = l);
    return n.target;
  }
  class Bg extends hg {
    constructor(e, t) {
      super(e, t);
      __publicField(this, "device");
      __publicField(this, "handle");
      __publicField(this, "buffer", null);
      __publicField(this, "bufferValue", null);
      this.device = e, this.handle = this.device.gl.createVertexArray();
    }
    get [Symbol.toStringTag]() {
      return "VertexArray";
    }
    static isConstantAttributeZeroSupported(e) {
      return qS() === "Chrome";
    }
    destroy() {
      var _a2;
      super.destroy(), this.buffer && ((_a2 = this.buffer) == null ? void 0 : _a2.destroy()), this.handle && (this.device.gl.deleteVertexArray(this.handle), this.handle = void 0);
    }
    setIndexBuffer(e) {
      const t = e;
      if (t && t.glTarget !== 34963) throw new Error("Use .setBuffer()");
      this.device.gl.bindVertexArray(this.handle), this.device.gl.bindBuffer(34963, t ? t.handle : null), this.indexBuffer = t, this.device.gl.bindVertexArray(null);
    }
    setBuffer(e, t) {
      const i = t;
      if (i.glTarget === 34963) throw new Error("Use .setIndexBuffer()");
      const { size: s, type: a, stride: l, offset: u, normalized: h, integer: d, divisor: p } = this._getAccessor(e);
      this.device.gl.bindVertexArray(this.handle), this.device.gl.bindBuffer(34962, i.handle), d ? this.device.gl.vertexAttribIPointer(e, s, a, l, u) : this.device.gl.vertexAttribPointer(e, s, a, h, l, u), this.device.gl.bindBuffer(34962, null), this.device.gl.enableVertexAttribArray(e), this.device.gl.vertexAttribDivisor(e, p || 0), this.attributes[e] = i, this.device.gl.bindVertexArray(null);
    }
    setConstantWebGL(e, t) {
      this._enable(e, false), this.attributes[e] = t;
    }
    bindBeforeRender() {
      this.device.gl.bindVertexArray(this.handle), this._applyConstantAttributes();
    }
    unbindAfterRender() {
      this.device.gl.bindVertexArray(null);
    }
    _applyConstantAttributes() {
      for (let e = 0; e < this.maxVertexAttributes; ++e) {
        const t = this.attributes[e];
        ArrayBuffer.isView(t) && this.device.setConstantAttributeWebGL(e, t);
      }
    }
    _getAccessor(e) {
      const t = this.attributeInfos[e];
      if (!t) throw new Error(`Unknown attribute location ${e}`);
      const i = K2(t.bufferDataType);
      return {
        size: t.bufferComponents,
        type: i,
        stride: t.byteStride,
        offset: t.byteOffset,
        normalized: t.normalized,
        integer: t.integer,
        divisor: t.stepMode === "instance" ? 1 : 0
      };
    }
    _enable(e, t = true) {
      const s = Bg.isConstantAttributeZeroSupported(this.device) || e !== 0;
      (t || s) && (e = Number(e), this.device.gl.bindVertexArray(this.handle), t ? this.device.gl.enableVertexAttribArray(e) : this.device.gl.disableVertexAttribArray(e), this.device.gl.bindVertexArray(null));
    }
    getConstantBuffer(e, t) {
      const i = NP(t), s = i.byteLength * e, a = i.length * e;
      if (this.buffer && s !== this.buffer.byteLength) throw new Error(`Buffer size is immutable, byte length ${s} !== ${this.buffer.byteLength}.`);
      let l = !this.buffer;
      if (this.buffer = this.buffer || this.device.createBuffer({
        byteLength: s
      }), l = l || !PP(i, this.bufferValue), l) {
        const u = PR(t.constructor, a);
        IP({
          target: u,
          source: i,
          start: 0,
          count: a
        }), this.buffer.write(u), this.bufferValue = t;
      }
      return this.buffer;
    }
  }
  function NP(n) {
    return Array.isArray(n) ? new Float32Array(n) : n;
  }
  function PP(n, e) {
    if (!n || !e || n.length !== e.length || n.constructor !== e.constructor) return false;
    for (let t = 0; t < n.length; ++t) if (n[t] !== e[t]) return false;
    return true;
  }
  class DP extends dg {
    constructor(e, t) {
      super(e, t);
      __publicField(this, "device");
      __publicField(this, "gl");
      __publicField(this, "handle");
      __publicField(this, "layout");
      __publicField(this, "buffers", {});
      __publicField(this, "unusedBuffers", {});
      __publicField(this, "bindOnUse", true);
      __publicField(this, "_bound", false);
      this.device = e, this.gl = e.gl, this.handle = this.props.handle || this.gl.createTransformFeedback(), this.layout = this.props.layout, t.buffers && this.setBuffers(t.buffers), Object.seal(this);
    }
    destroy() {
      this.gl.deleteTransformFeedback(this.handle), super.destroy();
    }
    begin(e = "point-list") {
      this.gl.bindTransformFeedback(36386, this.handle), this.bindOnUse && this._bindBuffers(), this.gl.beginTransformFeedback(xP(e));
    }
    end() {
      this.gl.endTransformFeedback(), this.bindOnUse && this._unbindBuffers(), this.gl.bindTransformFeedback(36386, null);
    }
    setBuffers(e) {
      this.buffers = {}, this.unusedBuffers = {}, this.bind(() => {
        for (const t in e) this.setBuffer(t, e[t]);
      });
    }
    setBuffer(e, t) {
      const i = this._getVaryingIndex(e), { buffer: s, byteLength: a, byteOffset: l } = this._getBufferRange(t);
      if (i < 0) {
        this.unusedBuffers[e] = s, J.warn(`${this.id} unusedBuffers varying buffer ${e}`)();
        return;
      }
      this.buffers[i] = {
        buffer: s,
        byteLength: a,
        byteOffset: l
      }, this.bindOnUse || this._bindBuffer(i, s, l, a);
    }
    getBuffer(e) {
      if (Z0(e)) return this.buffers[e] || null;
      const t = this._getVaryingIndex(e);
      return t >= 0 ? this.buffers[t] : null;
    }
    bind(e = this.handle) {
      if (typeof e != "function") return this.gl.bindTransformFeedback(36386, e), this;
      let t;
      return this._bound ? t = e() : (this.gl.bindTransformFeedback(36386, this.handle), this._bound = true, t = e(), this._bound = false, this.gl.bindTransformFeedback(36386, null)), t;
    }
    unbind() {
      this.bind(null);
    }
    _getBufferRange(e) {
      if (e instanceof ho) return {
        buffer: e,
        byteOffset: 0,
        byteLength: e.byteLength
      };
      const { buffer: t, byteOffset: i = 0, byteLength: s = e.buffer.byteLength } = e;
      return {
        buffer: t,
        byteOffset: i,
        byteLength: s
      };
    }
    _getVaryingIndex(e) {
      if (Z0(e)) return Number(e);
      for (const t of this.layout.varyings) if (e === t.name) return t.location;
      return -1;
    }
    _bindBuffers() {
      for (const e in this.buffers) {
        const { buffer: t, byteLength: i, byteOffset: s } = this._getBufferRange(this.buffers[e]);
        this._bindBuffer(Number(e), t, s, i);
      }
    }
    _unbindBuffers() {
      for (const e in this.buffers) this.gl.bindBufferBase(35982, Number(e), null);
    }
    _bindBuffer(e, t, i = 0, s) {
      const a = t && t.handle;
      !a || s === void 0 ? this.gl.bindBufferBase(35982, e, a) : this.gl.bindBufferRange(35982, e, a, i, s);
    }
  }
  function Z0(n) {
    return typeof n == "number" ? Number.isInteger(n) : /^\d+$/.test(n);
  }
  class kP extends gg {
    constructor(e, t) {
      super(e, t);
      __publicField(this, "device");
      __publicField(this, "handle");
      __publicField(this, "target", null);
      __publicField(this, "_queryPending", false);
      __publicField(this, "_pollingPromise", null);
      if (this.device = e, t.count > 1) throw new Error("WebGL QuerySet can only have one value");
      this.handle = this.device.gl.createQuery(), Object.seal(this);
    }
    get [Symbol.toStringTag]() {
      return "Query";
    }
    destroy() {
      this.device.gl.deleteQuery(this.handle);
    }
    beginTimestampQuery() {
      return this._begin(35007);
    }
    endTimestampQuery() {
      this._end();
    }
    beginOcclusionQuery(e) {
      return this._begin((e == null ? void 0 : e.conservative) ? 36202 : 35887);
    }
    endOcclusionQuery() {
      this._end();
    }
    beginTransformFeedbackQuery() {
      return this._begin(35976);
    }
    endTransformFeedbackQuery() {
      this._end();
    }
    async resolveQuery() {
      return [
        await this.pollQuery()
      ];
    }
    _begin(e) {
      this._queryPending || (this.target = e, this.device.gl.beginQuery(this.target, this.handle));
    }
    _end() {
      this._queryPending || this.target && (this.device.gl.endQuery(this.target), this.target = null, this._queryPending = true);
    }
    isResultAvailable() {
      if (!this._queryPending) return false;
      const e = this.device.gl.getQueryParameter(this.handle, 34919);
      return e && (this._queryPending = false), e;
    }
    isTimerDisjoint() {
      return this.device.gl.getParameter(36795);
    }
    getResult() {
      return this.device.gl.getQueryParameter(this.handle, 34918);
    }
    getTimerMilliseconds() {
      return this.getResult() / 1e6;
    }
    pollQuery(e = Number.POSITIVE_INFINITY) {
      if (this._pollingPromise) return this._pollingPromise;
      let t = 0;
      return this._pollingPromise = new Promise((i, s) => {
        const a = () => {
          this.isResultAvailable() ? (i(this.getResult()), this._pollingPromise = null) : t++ > e ? (s("Timed out"), this._pollingPromise = null) : requestAnimationFrame(a);
        };
        requestAnimationFrame(a);
      }), this._pollingPromise;
    }
  }
  class Dr extends Wi {
    constructor(e) {
      var _a2, _b3;
      super({
        ...e,
        id: e.id || BN("webgl-device")
      });
      __publicField(this, "type", "webgl");
      __publicField(this, "handle");
      __publicField(this, "features");
      __publicField(this, "limits");
      __publicField(this, "info");
      __publicField(this, "canvasContext");
      __publicField(this, "lost");
      __publicField(this, "_resolveContextLost");
      __publicField(this, "gl");
      __publicField(this, "debug", false);
      __publicField(this, "_canvasSizeInfo", {
        clientWidth: 0,
        clientHeight: 0,
        devicePixelRatio: 1
      });
      __publicField(this, "_extensions", {});
      __publicField(this, "_polyfilled", false);
      __publicField(this, "spectorJS");
      __publicField(this, "renderPass", null);
      __publicField(this, "_constants");
      const t = Wi._getCanvasContextProps(e);
      if (!t) throw new Error("WebGLDevice requires props.createCanvasContext to be set");
      let i = (_b3 = (_a2 = t.canvas) == null ? void 0 : _a2.gl) == null ? void 0 : _b3.device;
      if (i) throw new Error(`WebGL context already attached to device ${i.id}`);
      this.canvasContext = new EN(this, t), this.lost = new Promise((p) => {
        this._resolveContextLost = p;
      });
      const s = {
        ...e.webgl
      };
      t.alphaMode === "premultiplied" && (s.premultipliedAlpha = true), e.powerPreference !== void 0 && (s.powerPreference = e.powerPreference);
      const l = this.props._handle || aN(this.canvasContext.canvas, {
        onContextLost: (p) => {
          var _a3;
          return (_a3 = this._resolveContextLost) == null ? void 0 : _a3.call(this, {
            reason: "destroyed",
            message: "Entered sleep mode, or too many apps or browser tabs are using the GPU."
          });
        },
        onContextRestored: (p) => console.log("WebGL context restored")
      }, s);
      if (!l) throw new Error("WebGL context creation failed");
      if (i = l.device, i) {
        if (e._reuseDevices) return J.log(1, `Not creating a new Device, instead returning a reference to Device ${i.id} already attached to WebGL context`, i)(), i._reused = true, i;
        throw new Error(`WebGL context already attached to device ${i.id}`);
      }
      this.handle = l, this.gl = l, this.spectorJS = MN({
        ...this.props,
        gl: this.handle
      }), this.gl.device = this, this.gl._version = 2, this.info = oN(this.gl, this._extensions), this.limits = new SN(this.gl), this.features = new xN(this.gl, this._extensions, this.props._disabledFeatures), this.props._initializeFeatures && this.features.initializeFeatures(), t.autoResize !== false && this.canvasContext.resize(), new Ss(this.gl, {
        log: (...p) => J.log(1, ...p)()
      }).trackState(this.gl, {
        copyState: false
      });
      const h = e.debugWebGL || e.debug, d = e.debugWebGL;
      h && (this.gl = NN(this.gl, {
        debugWebGL: h,
        traceWebGL: d
      }), J.warn("WebGL debug mode activated. Performance reduced.")(), e.debugWebGL && (J.level = Math.max(J.level, 1)));
    }
    destroy() {
      !this.props._reuseDevices && !this._reused && delete this.gl.device;
    }
    get isLost() {
      return this.gl.isContextLost();
    }
    createCanvasContext(e) {
      throw new Error("WebGL only supports a single canvas");
    }
    createBuffer(e) {
      const t = this._normalizeBufferProps(e);
      return new ho(this, t);
    }
    createTexture(e) {
      return new go(this, e);
    }
    createExternalTexture(e) {
      throw new Error("createExternalTexture() not implemented");
    }
    createSampler(e) {
      return new Vd(this, e);
    }
    createShader(e) {
      return new zN(this, e);
    }
    createFramebuffer(e) {
      return new fo(this, e);
    }
    createVertexArray(e) {
      return new Bg(this, e);
    }
    createTransformFeedback(e) {
      return new DP(this, e);
    }
    createQuerySet(e) {
      return new kP(this, e);
    }
    createRenderPipeline(e) {
      return new SP(this, e);
    }
    beginRenderPass(e) {
      return new aP(this, e);
    }
    createComputePipeline(e) {
      throw new Error("ComputePipeline not supported in WebGL");
    }
    beginComputePass(e) {
      throw new Error("ComputePass not supported in WebGL");
    }
    createCommandEncoder(e = {}) {
      return new OP(this, e);
    }
    submit() {
      var _a2;
      (_a2 = this.renderPass) == null ? void 0 : _a2.end(), this.renderPass = null;
    }
    readPixelsToArrayWebGL(e, t) {
      return tP(e, t);
    }
    readPixelsToBufferWebGL(e, t) {
      return nP(e, t);
    }
    setParametersWebGL(e) {
      Qr(this.gl, e);
    }
    getParametersWebGL(e) {
      return Y2(this.gl, e);
    }
    withParametersWebGL(e, t) {
      return Dc(this.gl, e, t);
    }
    resetWebGL() {
      J.warn("WebGLDevice.resetWebGL is deprecated, use only for debugging")(), tN(this.gl);
    }
    _getDeviceSpecificTextureFormatCapabilities(e) {
      return yN(this.gl, e, this._extensions);
    }
    loseDevice() {
      var _a2;
      let e = false;
      const i = this.getExtension("WEBGL_lose_context").WEBGL_lose_context;
      return i && (e = true, i.loseContext()), (_a2 = this._resolveContextLost) == null ? void 0 : _a2.call(this, {
        reason: "destroyed",
        message: "Application triggered context loss"
      }), e;
    }
    pushState() {
      Ss.get(this.gl).push();
    }
    popState() {
      Ss.get(this.gl).pop();
    }
    setSpectorMetadata(e, t) {
      e.__SPECTOR_Metadata = t;
    }
    getGLKey(e, t) {
      const i = Number(e);
      for (const s in this.gl) if (this.gl[s] === i) return `GL.${s}`;
      return (t == null ? void 0 : t.emptyIfUnknown) ? "" : String(e);
    }
    getGLKeys(e) {
      const t = {
        emptyIfUnknown: true
      };
      return Object.entries(e).reduce((i, [s, a]) => (i[`${s}:${this.getGLKey(s, t)}`] = `${a}:${this.getGLKey(a, t)}`, i), {});
    }
    setConstantAttributeWebGL(e, t) {
      const i = this.limits.maxVertexAttributes;
      this._constants = this._constants || new Array(i).fill(null);
      const s = this._constants[e];
      switch (s && FP(s, t) && J.info(1, `setConstantAttributeWebGL(${e}) could have been skipped, value unchanged`)(), this._constants[e] = t, t.constructor) {
        case Float32Array:
          UP(this, e, t);
          break;
        case Int32Array:
          BP(this, e, t);
          break;
        case Uint32Array:
          LP(this, e, t);
          break;
        default:
          throw new Error("constant");
      }
    }
    getExtension(e) {
      return qr(this.gl, e, this._extensions), this._extensions;
    }
  }
  function UP(n, e, t) {
    switch (t.length) {
      case 1:
        n.gl.vertexAttrib1fv(e, t);
        break;
      case 2:
        n.gl.vertexAttrib2fv(e, t);
        break;
      case 3:
        n.gl.vertexAttrib3fv(e, t);
        break;
      case 4:
        n.gl.vertexAttrib4fv(e, t);
        break;
    }
  }
  function BP(n, e, t) {
    n.gl.vertexAttribI4iv(e, t);
  }
  function LP(n, e, t) {
    n.gl.vertexAttribI4uiv(e, t);
  }
  function FP(n, e) {
    if (!n || !e || n.length !== e.length || n.constructor !== e.constructor) return false;
    for (let t = 0; t < n.length; ++t) if (n[t] !== e[t]) return false;
    return true;
  }
  const VP = {
    WEBGL_depth_texture: {
      UNSIGNED_INT_24_8_WEBGL: 34042
    },
    OES_element_index_uint: {},
    OES_texture_float: {},
    OES_texture_half_float: {
      HALF_FLOAT_OES: 5131
    },
    EXT_color_buffer_float: {},
    OES_standard_derivatives: {
      FRAGMENT_SHADER_DERIVATIVE_HINT_OES: 35723
    },
    EXT_frag_depth: {},
    EXT_blend_minmax: {
      MIN_EXT: 32775,
      MAX_EXT: 32776
    },
    EXT_shader_texture_lod: {}
  }, zP = (n) => ({
    drawBuffersWEBGL(e) {
      return n.drawBuffers(e);
    },
    COLOR_ATTACHMENT0_WEBGL: 36064,
    COLOR_ATTACHMENT1_WEBGL: 36065,
    COLOR_ATTACHMENT2_WEBGL: 36066,
    COLOR_ATTACHMENT3_WEBGL: 36067
  }), HP = (n) => ({
    VERTEX_ARRAY_BINDING_OES: 34229,
    createVertexArrayOES() {
      return n.createVertexArray();
    },
    deleteVertexArrayOES(e) {
      return n.deleteVertexArray(e);
    },
    isVertexArrayOES(e) {
      return n.isVertexArray(e);
    },
    bindVertexArrayOES(e) {
      return n.bindVertexArray(e);
    }
  }), jP = (n) => ({
    VERTEX_ATTRIB_ARRAY_DIVISOR_ANGLE: 35070,
    drawArraysInstancedANGLE(...e) {
      return n.drawArraysInstanced(...e);
    },
    drawElementsInstancedANGLE(...e) {
      return n.drawElementsInstanced(...e);
    },
    vertexAttribDivisorANGLE(...e) {
      return n.vertexAttribDivisor(...e);
    }
  });
  function WP(n = true) {
    const e = HTMLCanvasElement.prototype;
    if (!n && e.originalGetContext) {
      e.getContext = e.originalGetContext, e.originalGetContext = void 0;
      return;
    }
    e.originalGetContext = e.getContext, e.getContext = function(t, i) {
      if (t === "webgl" || t === "experimental-webgl") {
        const s = this.originalGetContext("webgl2", i);
        return s instanceof HTMLElement && $P(s), s;
      }
      return this.originalGetContext(t, i);
    };
  }
  function $P(n) {
    n.getExtension("EXT_color_buffer_float");
    const e = {
      ...VP,
      WEBGL_disjoint_timer_query: n.getExtension("EXT_disjoint_timer_query_webgl2"),
      WEBGL_draw_buffers: zP(n),
      OES_vertex_array_object: HP(n),
      ANGLE_instanced_arrays: jP(n)
    }, t = n.getExtension;
    n.getExtension = function(s) {
      const a = t.call(n, s);
      return a || (s in e ? e[s] : null);
    };
    const i = n.getSupportedExtensions;
    n.getSupportedExtensions = function() {
      var _a2;
      return (_a2 = i.apply(n) || []) == null ? void 0 : _a2.concat(Object.keys(e));
    };
  }
  const nc = 1;
  class XP extends cR {
    constructor() {
      super();
      __publicField(this, "type", "webgl");
      Wi.defaultProps = {
        ...Wi.defaultProps,
        ...Ug
      }, Dr.adapter = this;
    }
    isSupported() {
      return typeof WebGL2RenderingContext < "u";
    }
    enforceWebGL2(e) {
      WP(e);
    }
    async attach(e) {
      if (e instanceof Dr) return e;
      if ((e == null ? void 0 : e.device) instanceof Wi) return e.device;
      if (!YP(e)) throw new Error("Invalid WebGL2RenderingContext");
      return new Dr({
        _handle: e,
        createCanvasContext: {
          canvas: e.canvas,
          autoResize: false
        }
      });
    }
    async create(e = {}) {
      J.groupCollapsed(nc, "WebGLDevice created")();
      const t = [];
      (e.debugWebGL || e.debug) && t.push(IN()), e.debugSpectorJS && t.push(CN(e));
      const i = await Promise.allSettled(t);
      for (const l of i) l.status === "rejected" && J.error(`Failed to initialize debug libraries ${l.reason}`)();
      const s = new Dr(e), a = `${s._reused ? "Reusing" : "Created"} device with WebGL2 ${s.debug ? "debug " : ""}context: ${s.info.vendor}, ${s.info.renderer} for canvas: ${s.canvasContext.id}`;
      return J.probe(nc, a)(), J.table(nc, s.info)(), J.groupEnd(nc)(), s;
    }
  }
  function YP(n) {
    return typeof WebGL2RenderingContext < "u" && n instanceof WebGL2RenderingContext ? true : !!(n && Number.isFinite(n._version));
  }
  const Q0 = new XP();
  function Li() {
  }
  const qP = ({ isDragging: n }) => n ? "grabbing" : "grab", aT = {
    id: "",
    width: "100%",
    height: "100%",
    style: null,
    viewState: null,
    initialViewState: null,
    pickingRadius: 0,
    layerFilter: null,
    parameters: {},
    parent: null,
    device: null,
    deviceProps: {},
    gl: null,
    canvas: null,
    layers: [],
    effects: [],
    views: null,
    controller: null,
    useDevicePixels: true,
    touchAction: "none",
    eventRecognizerOptions: {},
    _framebuffer: null,
    _animate: false,
    _pickable: true,
    _typedArrayManagerProps: {},
    _customRender: null,
    widgets: [],
    onDeviceInitialized: Li,
    onWebGLInitialized: Li,
    onResize: Li,
    onViewStateChange: Li,
    onInteractionStateChange: Li,
    onBeforeRender: Li,
    onAfterRender: Li,
    onLoad: Li,
    onError: (n) => Le.error(n.message, n.cause)(),
    onHover: null,
    onClick: null,
    onDragStart: null,
    onDrag: null,
    onDragEnd: null,
    _onMetrics: null,
    getCursor: qP,
    getTooltip: null,
    debug: false,
    drawPickingColors: false
  };
  class Lg {
    constructor(e) {
      this.width = 0, this.height = 0, this.userData = {}, this.device = null, this.canvas = null, this.viewManager = null, this.layerManager = null, this.effectManager = null, this.deckRenderer = null, this.deckPicker = null, this.eventManager = null, this.widgetManager = null, this.tooltip = null, this.animationLoop = null, this.cursorState = {
        isHovering: false,
        isDragging: false
      }, this.stats = new Xc({
        id: "deck.gl"
      }), this.metrics = {
        fps: 0,
        setPropsTime: 0,
        updateAttributesTime: 0,
        framesRedrawn: 0,
        pickTime: 0,
        pickCount: 0,
        gpuTime: 0,
        gpuTimePerFrame: 0,
        cpuTime: 0,
        cpuTimePerFrame: 0,
        bufferMemory: 0,
        textureMemory: 0,
        renderbufferMemory: 0,
        gpuMemory: 0
      }, this._metricsCounter = 0, this._needsRedraw = "Initial render", this._pickRequest = {
        mode: "hover",
        x: -1,
        y: -1,
        radius: 0,
        event: null
      }, this._lastPointerDownInfo = null, this._onPointerMove = (i) => {
        const { _pickRequest: s } = this;
        if (i.type === "pointerleave") s.x = -1, s.y = -1, s.radius = 0;
        else {
          if (i.leftButton || i.rightButton) return;
          {
            const a = i.offsetCenter;
            if (!a) return;
            s.x = a.x, s.y = a.y, s.radius = this.props.pickingRadius;
          }
        }
        this.layerManager && (this.layerManager.context.mousePosition = {
          x: s.x,
          y: s.y
        }), s.event = i;
      }, this._onEvent = (i) => {
        const s = Od[i.type], a = i.offsetCenter;
        if (!s || !a || !this.layerManager) return;
        const l = this.layerManager.getLayers(), u = this.deckPicker.getLastPickedObject({
          x: a.x,
          y: a.y,
          layers: l,
          viewports: this.getViewports(a)
        }, this._lastPointerDownInfo), { layer: h } = u, d = h && (h[s] || h.props[s]), p = this.props[s];
        let _ = false;
        d && (_ = d.call(h, u, i)), _ || (p == null ? void 0 : p(u, i), this.widgetManager.onEvent(u, i));
      }, this._onPointerDown = (i) => {
        var _a2;
        if (((_a2 = this.device) == null ? void 0 : _a2.type) === "webgpu") return;
        const s = i.offsetCenter, a = this._pick("pickObject", "pickObject Time", {
          x: s.x,
          y: s.y,
          radius: this.props.pickingRadius
        });
        this._lastPointerDownInfo = a.result[0] || a.emptyInfo;
      }, this.props = {
        ...aT,
        ...e
      }, e = this.props, e.viewState && e.initialViewState && Le.warn("View state tracking is disabled. Use either `initialViewState` for auto update or `viewState` for manual update.")(), this.viewState = this.props.initialViewState, e.device && (this.device = e.device);
      let t = this.device;
      !t && e.gl && (e.gl instanceof WebGLRenderingContext && Le.error("WebGL1 context not supported.")(), t = Q0.attach(e.gl)), t || (t = Td.createDevice({
        type: "best-available",
        _reuseDevices: true,
        adapters: [
          Q0
        ],
        ...e.deviceProps,
        createCanvasContext: {
          canvas: this._createCanvas(e),
          useDevicePixels: this.props.useDevicePixels,
          autoResize: false
        }
      })), this.animationLoop = this._createAnimationLoop(t, e), this.setProps(e), e._typedArrayManagerProps && bo.setOptions(e._typedArrayManagerProps), this.animationLoop.start();
    }
    finalize() {
      var _a2, _b3, _c2, _d2, _e2, _f, _g2, _h, _i, _j;
      (_a2 = this.animationLoop) == null ? void 0 : _a2.stop(), (_b3 = this.animationLoop) == null ? void 0 : _b3.destroy(), this.animationLoop = null, this._lastPointerDownInfo = null, (_c2 = this.layerManager) == null ? void 0 : _c2.finalize(), this.layerManager = null, (_d2 = this.viewManager) == null ? void 0 : _d2.finalize(), this.viewManager = null, (_e2 = this.effectManager) == null ? void 0 : _e2.finalize(), this.effectManager = null, (_f = this.deckRenderer) == null ? void 0 : _f.finalize(), this.deckRenderer = null, (_g2 = this.deckPicker) == null ? void 0 : _g2.finalize(), this.deckPicker = null, (_h = this.eventManager) == null ? void 0 : _h.destroy(), this.eventManager = null, (_i = this.widgetManager) == null ? void 0 : _i.finalize(), this.widgetManager = null, !this.props.canvas && !this.props.device && !this.props.gl && this.canvas && ((_j = this.canvas.parentElement) == null ? void 0 : _j.removeChild(this.canvas), this.canvas = null);
    }
    setProps(e) {
      var _a2;
      this.stats.get("setProps Time").timeStart(), "onLayerHover" in e && Le.removed("onLayerHover", "onHover")(), "onLayerClick" in e && Le.removed("onLayerClick", "onClick")(), e.initialViewState && !Ft(this.props.initialViewState, e.initialViewState, 3) && (this.viewState = e.initialViewState), Object.assign(this.props, e), this._setCanvasSize(this.props);
      const t = Object.create(this.props);
      Object.assign(t, {
        views: this._getViews(),
        width: this.width,
        height: this.height,
        viewState: this._getViewState()
      }), (_a2 = this.animationLoop) == null ? void 0 : _a2.setProps(t), this.layerManager && (this.viewManager.setProps(t), this.layerManager.activateViewport(this.getViewports()[0]), this.layerManager.setProps(t), this.effectManager.setProps(t), this.deckRenderer.setProps(t), this.deckPicker.setProps(t), this.widgetManager.setProps(t)), this.stats.get("setProps Time").timeEnd();
    }
    needsRedraw(e = {
      clearRedrawFlags: false
    }) {
      if (!this.layerManager) return false;
      if (this.props._animate) return "Deck._animate";
      let t = this._needsRedraw;
      e.clearRedrawFlags && (this._needsRedraw = false);
      const i = this.viewManager.needsRedraw(e), s = this.layerManager.needsRedraw(e), a = this.effectManager.needsRedraw(e), l = this.deckRenderer.needsRedraw(e);
      return t = t || i || s || a || l, t;
    }
    redraw(e) {
      if (!this.layerManager) return;
      let t = this.needsRedraw({
        clearRedrawFlags: true
      });
      t = e || t, t && (this.stats.get("Redraw Count").incrementCount(), this.props._customRender ? this.props._customRender(t) : this._drawLayers(t));
    }
    get isInitialized() {
      return this.viewManager !== null;
    }
    getViews() {
      return It(this.viewManager), this.viewManager.views;
    }
    getViewports(e) {
      return It(this.viewManager), this.viewManager.getViewports(e);
    }
    getCanvas() {
      return this.canvas;
    }
    pickObject(e) {
      const t = this._pick("pickObject", "pickObject Time", e).result;
      return t.length ? t[0] : null;
    }
    pickMultipleObjects(e) {
      return e.depth = e.depth || 10, this._pick("pickObject", "pickMultipleObjects Time", e).result;
    }
    pickObjects(e) {
      return this._pick("pickObjects", "pickObjects Time", e);
    }
    _addResources(e, t = false) {
      for (const i in e) this.layerManager.resourceManager.add({
        resourceId: i,
        data: e[i],
        forceUpdate: t
      });
    }
    _removeResources(e) {
      for (const t of e) this.layerManager.resourceManager.remove(t);
    }
    _addDefaultEffect(e) {
      this.effectManager.addDefaultEffect(e);
    }
    _addDefaultShaderModule(e) {
      this.layerManager.addDefaultShaderModule(e);
    }
    _removeDefaultShaderModule(e) {
      var _a2;
      (_a2 = this.layerManager) == null ? void 0 : _a2.removeDefaultShaderModule(e);
    }
    _pick(e, t, i) {
      It(this.deckPicker);
      const { stats: s } = this;
      s.get("Pick Count").incrementCount(), s.get(t).timeStart();
      const a = this.deckPicker[e]({
        layers: this.layerManager.getLayers(i),
        views: this.viewManager.getViews(),
        viewports: this.getViewports(i),
        onViewportActive: this.layerManager.activateViewport,
        effects: this.effectManager.getEffects(),
        ...i
      });
      return s.get(t).timeEnd(), a;
    }
    _createCanvas(e) {
      let t = e.canvas;
      return typeof t == "string" && (t = document.getElementById(t), It(t)), t || (t = document.createElement("canvas"), t.id = e.id || "deckgl-overlay", (e.parent || document.body).appendChild(t)), Object.assign(t.style, e.style), t;
    }
    _setCanvasSize(e) {
      var _a2;
      if (!this.canvas) return;
      const { width: t, height: i } = e;
      if (t || t === 0) {
        const s = Number.isFinite(t) ? `${t}px` : t;
        this.canvas.style.width = s;
      }
      if (i || i === 0) {
        const s = Number.isFinite(i) ? `${i}px` : i;
        this.canvas.style.position = ((_a2 = e.style) == null ? void 0 : _a2.position) || "absolute", this.canvas.style.height = s;
      }
    }
    _updateCanvasSize() {
      var _a2, _b3;
      const { canvas: e } = this;
      if (!e) return;
      const t = e.clientWidth ?? e.width, i = e.clientHeight ?? e.height;
      (t !== this.width || i !== this.height) && (this.width = t, this.height = i, (_a2 = this.viewManager) == null ? void 0 : _a2.setProps({
        width: t,
        height: i
      }), (_b3 = this.layerManager) == null ? void 0 : _b3.activateViewport(this.getViewports()[0]), this.props.onResize({
        width: t,
        height: i
      }));
    }
    _createAnimationLoop(e, t) {
      const { gl: i, onError: s, useDevicePixels: a } = t;
      return new ZI({
        device: e,
        useDevicePixels: a,
        autoResizeDrawingBuffer: !i,
        autoResizeViewport: false,
        onInitialize: (l) => this._setDevice(l.device),
        onRender: this._onRenderFrame.bind(this),
        onError: s
      });
    }
    _getViewState() {
      return this.props.viewState || this.viewState;
    }
    _getViews() {
      const { views: e } = this.props, t = Array.isArray(e) ? e : e ? [
        e
      ] : [
        new W2({
          id: "default-view"
        })
      ];
      return t.length && this.props.controller && (t[0].props.controller = this.props.controller), t;
    }
    _onContextLost() {
      const { onError: e } = this.props;
      this.animationLoop && e && e(new Error("WebGL context is lost"));
    }
    _pickAndCallback() {
      var _a2, _b3, _c2, _d2;
      if (((_a2 = this.device) == null ? void 0 : _a2.type) === "webgpu") return;
      const { _pickRequest: e } = this;
      if (e.event) {
        const { result: t, emptyInfo: i } = this._pick("pickObject", "pickObject Time", e);
        this.cursorState.isHovering = t.length > 0;
        let s = i, a = false;
        for (const l of t) s = l, a = ((_b3 = l.layer) == null ? void 0 : _b3.onHover(l, e.event)) || a;
        a || ((_d2 = (_c2 = this.props).onHover) == null ? void 0 : _d2.call(_c2, s, e.event), this.widgetManager.onHover(s, e.event)), e.event = null;
      }
    }
    _updateCursor() {
      const e = this.props.parent || this.canvas;
      e && (e.style.cursor = this.props.getCursor(this.cursorState));
    }
    _setDevice(e) {
      var _a2, _b3;
      if (this.device = e, !this.animationLoop) return;
      this.canvas || (this.canvas = (_a2 = this.device.canvasContext) == null ? void 0 : _a2.canvas), this.device.type === "webgl" && this.device.setParametersWebGL({
        blend: true,
        blendFunc: [
          770,
          771,
          1,
          771
        ],
        polygonOffsetFill: true,
        depthTest: true,
        depthFunc: 515
      }), this.props.onDeviceInitialized(this.device), this.device.type === "webgl" && this.props.onWebGLInitialized(this.device.gl);
      const t = new U2();
      t.play(), this.animationLoop.attachTimeline(t), this.eventManager = new xO(this.props.parent || this.canvas, {
        touchAction: this.props.touchAction,
        recognizers: Object.keys(_0).map((s) => {
          var _a3;
          const [a, l, u, h] = _0[s], d = (_a3 = this.props.eventRecognizerOptions) == null ? void 0 : _a3[s], p = {
            ...l,
            ...d,
            event: s
          };
          return {
            recognizer: new a(p),
            recognizeWith: u,
            requestFailure: h
          };
        }),
        events: {
          pointerdown: this._onPointerDown,
          pointermove: this._onPointerMove,
          pointerleave: this._onPointerMove
        }
      });
      for (const s in Od) this.eventManager.on(s, this._onEvent);
      this.viewManager = new T4({
        timeline: t,
        eventManager: this.eventManager,
        onViewStateChange: this._onViewStateChange.bind(this),
        onInteractionStateChange: this._onInteractionStateChange.bind(this),
        views: this._getViews(),
        viewState: this._getViewState(),
        width: this.width,
        height: this.height
      });
      const i = this.viewManager.getViewports()[0];
      this.layerManager = new v4(this.device, {
        deck: this,
        stats: this.stats,
        viewport: i,
        timeline: t
      }), this.effectManager = new B4({
        deck: this,
        device: this.device
      }), this.deckRenderer = new V4(this.device), this.deckPicker = new X4(this.device), this.widgetManager = new K4({
        deck: this,
        parentElement: (_b3 = this.canvas) == null ? void 0 : _b3.parentElement
      }), this.widgetManager.addDefault(new Q4()), this.setProps(this.props), this._updateCanvasSize(), this.props.onLoad();
    }
    _drawLayers(e, t) {
      var _a2;
      const { device: i, gl: s } = this.layerManager.context;
      this.props.onBeforeRender({
        device: i,
        gl: s
      });
      const a = {
        target: this.props._framebuffer,
        layers: this.layerManager.getLayers(),
        viewports: this.viewManager.getViewports(),
        onViewportActive: this.layerManager.activateViewport,
        views: this.viewManager.getViews(),
        pass: "screen",
        effects: this.effectManager.getEffects(),
        ...t
      };
      (_a2 = this.deckRenderer) == null ? void 0 : _a2.renderLayers(a), a.pass === "screen" && this.widgetManager.onRedraw({
        viewports: a.viewports,
        layers: a.layers
      }), this.props.onAfterRender({
        device: i,
        gl: s
      });
    }
    _onRenderFrame() {
      var _a2;
      this._getFrameStats(), this._metricsCounter++ % 60 === 0 && (this._getMetrics(), this.stats.reset(), Le.table(4, this.metrics)(), this.props._onMetrics && this.props._onMetrics(this.metrics)), this._updateCanvasSize(), this._updateCursor(), this.layerManager.updateLayers(), ((_a2 = this.device) == null ? void 0 : _a2.type) !== "webgpu" && this._pickAndCallback(), this.redraw(), this.viewManager && this.viewManager.updateViewStates();
    }
    _onViewStateChange(e) {
      const t = this.props.onViewStateChange(e) || e.viewState;
      this.viewState && (this.viewState = {
        ...this.viewState,
        [e.viewId]: t
      }, this.props.viewState || this.viewManager && this.viewManager.setProps({
        viewState: this.viewState
      }));
    }
    _onInteractionStateChange(e) {
      this.cursorState.isDragging = e.isDragging || false, this.props.onInteractionStateChange(e);
    }
    _getFrameStats() {
      const { stats: e } = this;
      e.get("frameRate").timeEnd(), e.get("frameRate").timeStart();
      const t = this.animationLoop.stats;
      e.get("GPU Time").addTime(t.get("GPU Time").lastTiming), e.get("CPU Time").addTime(t.get("CPU Time").lastTiming);
    }
    _getMetrics() {
      const { metrics: e, stats: t } = this;
      e.fps = t.get("frameRate").getHz(), e.setPropsTime = t.get("setProps Time").time, e.updateAttributesTime = t.get("Update Attributes").time, e.framesRedrawn = t.get("Redraw Count").count, e.pickTime = t.get("pickObject Time").time + t.get("pickMultipleObjects Time").time + t.get("pickObjects Time").time, e.pickCount = t.get("Pick Count").count, e.gpuTime = t.get("GPU Time").time, e.cpuTime = t.get("CPU Time").time, e.gpuTimePerFrame = t.get("GPU Time").getAverageTime(), e.cpuTimePerFrame = t.get("CPU Time").getAverageTime();
      const i = Td.stats.get("Memory Usage");
      e.bufferMemory = i.get("Buffer Memory").count, e.textureMemory = i.get("Texture Memory").count, e.renderbufferMemory = i.get("Renderbuffer Memory").count, e.gpuMemory = i.get("GPU Memory").count;
    }
  }
  Lg.defaultProps = aT;
  Lg.VERSION = pE;
  function KP(n) {
    switch (n) {
      case "float64":
        return Float64Array;
      case "uint8":
      case "unorm8":
        return Uint8ClampedArray;
      default:
        return D3(n);
    }
  }
  const ZP = P3;
  function ic(n, e, t) {
    const i = t === "webgpu" && e.type === "uint8" ? "unorm8" : e.type;
    return {
      attribute: n,
      format: e.size > 1 ? `${i}x${e.size}` : e.type,
      byteOffset: e.offset || 0
    };
  }
  function bs(n) {
    return n.stride || n.size * n.bytesPerElement;
  }
  function QP(n, e) {
    return n.type === e.type && n.size === e.size && bs(n) === bs(e) && (n.offset || 0) === (e.offset || 0);
  }
  function zd(n, e) {
    e.offset && Le.removed("shaderAttribute.offset", "vertexOffset, elementOffset")();
    const t = bs(n), i = e.vertexOffset !== void 0 ? e.vertexOffset : n.vertexOffset || 0, s = e.elementOffset || 0, a = i * t + s * n.bytesPerElement + (n.offset || 0);
    return {
      ...e,
      offset: a,
      stride: t
    };
  }
  function GP(n, e) {
    const t = zd(n, e);
    return {
      high: t,
      low: {
        ...t,
        offset: t.offset + n.size * 4
      }
    };
  }
  class JP {
    constructor(e, t, i) {
      this._buffer = null, this.device = e, this.id = t.id || "", this.size = t.size || 1;
      const s = t.logicalType || t.type, a = s === "float64";
      let { defaultValue: l } = t;
      l = Number.isFinite(l) ? [
        l
      ] : l || new Array(this.size).fill(0);
      let u;
      a ? u = "float32" : !s && t.isIndexed ? u = "uint32" : u = s || "float32";
      let h = KP(s || u);
      this.doublePrecision = a, a && t.fp64 === false && (h = Float32Array), this.value = null, this.settings = {
        ...t,
        defaultType: h,
        defaultValue: l,
        logicalType: s,
        type: u,
        normalized: u.includes("norm"),
        size: this.size,
        bytesPerElement: h.BYTES_PER_ELEMENT
      }, this.state = {
        ...i,
        externalBuffer: null,
        bufferAccessor: this.settings,
        allocatedValue: null,
        numInstances: 0,
        bounds: null,
        constant: false
      };
    }
    get isConstant() {
      return this.state.constant;
    }
    get buffer() {
      return this._buffer;
    }
    get byteOffset() {
      const e = this.getAccessor();
      return e.vertexOffset ? e.vertexOffset * bs(e) : 0;
    }
    get numInstances() {
      return this.state.numInstances;
    }
    set numInstances(e) {
      this.state.numInstances = e;
    }
    delete() {
      this._buffer && (this._buffer.delete(), this._buffer = null), bo.release(this.state.allocatedValue);
    }
    getBuffer() {
      return this.state.constant ? null : this.state.externalBuffer || this._buffer;
    }
    getValue(e = this.id, t = null) {
      const i = {};
      if (this.state.constant) {
        const s = this.value;
        if (t) {
          const a = zd(this.getAccessor(), t), l = a.offset / s.BYTES_PER_ELEMENT, u = a.size || this.size;
          i[e] = s.subarray(l, l + u);
        } else i[e] = s;
      } else i[e] = this.getBuffer();
      return this.doublePrecision && (this.value instanceof Float64Array ? i[`${e}64Low`] = i[e] : i[`${e}64Low`] = new Float32Array(this.size)), i;
    }
    _getBufferLayout(e = this.id, t = null) {
      const i = this.getAccessor(), s = [], a = {
        name: this.id,
        byteStride: bs(i),
        attributes: s
      };
      if (this.doublePrecision) {
        const l = GP(i, t || {});
        s.push(ic(e, {
          ...i,
          ...l.high
        }, this.device.type), ic(`${e}64Low`, {
          ...i,
          ...l.low
        }, this.device.type));
      } else if (t) {
        const l = zd(i, t);
        s.push(ic(e, {
          ...i,
          ...l
        }, this.device.type));
      } else s.push(ic(e, i, this.device.type));
      return a;
    }
    setAccessor(e) {
      this.state.bufferAccessor = e;
    }
    getAccessor() {
      return this.state.bufferAccessor;
    }
    getBounds() {
      if (this.state.bounds) return this.state.bounds;
      let e = null;
      if (this.state.constant && this.value) {
        const t = Array.from(this.value);
        e = [
          t,
          t
        ];
      } else {
        const { value: t, numInstances: i, size: s } = this, a = i * s;
        if (t && a && t.length >= a) {
          const l = new Array(s).fill(1 / 0), u = new Array(s).fill(-1 / 0);
          for (let h = 0; h < a; ) for (let d = 0; d < s; d++) {
            const p = t[h++];
            p < l[d] && (l[d] = p), p > u[d] && (u[d] = p);
          }
          e = [
            l,
            u
          ];
        }
      }
      return this.state.bounds = e, e;
    }
    setData(e) {
      const { state: t } = this;
      let i;
      ArrayBuffer.isView(e) ? i = {
        value: e
      } : e instanceof Ke ? i = {
        buffer: e
      } : i = e;
      const s = {
        ...this.settings,
        ...i
      };
      if (ArrayBuffer.isView(i.value)) {
        if (!i.type) if (this.doublePrecision && i.value instanceof Float64Array) s.type = "float32";
        else {
          const l = ZP(i.value);
          s.type = s.normalized ? l.replace("int", "norm") : l;
        }
        s.bytesPerElement = i.value.BYTES_PER_ELEMENT, s.stride = bs(s);
      }
      if (t.bounds = null, i.constant) {
        let a = i.value;
        if (a = this._normalizeValue(a, [], 0), this.settings.normalized && (a = this.normalizeConstant(a)), !(!t.constant || !this._areValuesEqual(a, this.value))) return false;
        t.externalBuffer = null, t.constant = true, this.value = ArrayBuffer.isView(a) ? a : new Float32Array(a);
      } else if (i.buffer) {
        const a = i.buffer;
        t.externalBuffer = a, t.constant = false, this.value = i.value || null;
      } else if (i.value) {
        this._checkExternalBuffer(i);
        let a = i.value;
        t.externalBuffer = null, t.constant = false, this.value = a;
        let { buffer: l } = this;
        const u = bs(s), h = (s.vertexOffset || 0) * u;
        if (this.doublePrecision && a instanceof Float64Array && (a = Kh(a, s)), this.settings.isIndexed) {
          const p = this.settings.defaultType;
          a.constructor !== p && (a = new p(a));
        }
        const d = a.byteLength + h + u * 2;
        (!l || l.byteLength < d) && (l = this._createBuffer(d)), l.write(a, h);
      }
      return this.setAccessor(s), true;
    }
    updateSubBuffer(e = {}) {
      this.state.bounds = null;
      const t = this.value, { startOffset: i = 0, endOffset: s } = e;
      this.buffer.write(this.doublePrecision && t instanceof Float64Array ? Kh(t, {
        size: this.size,
        startIndex: i,
        endIndex: s
      }) : t.subarray(i, s), i * t.BYTES_PER_ELEMENT + this.byteOffset);
    }
    allocate(e, t = false) {
      const { state: i } = this, s = i.allocatedValue, a = bo.allocate(s, e + 1, {
        size: this.size,
        type: this.settings.defaultType,
        copy: t
      });
      this.value = a;
      const { byteOffset: l } = this;
      let { buffer: u } = this;
      return (!u || u.byteLength < a.byteLength + l) && (u = this._createBuffer(a.byteLength + l), t && s && u.write(s instanceof Float64Array ? Kh(s, this) : s, l)), i.allocatedValue = a, i.constant = false, i.externalBuffer = null, this.setAccessor(this.settings), true;
    }
    _checkExternalBuffer(e) {
      const { value: t } = e;
      if (!ArrayBuffer.isView(t)) throw new Error(`Attribute ${this.id} value is not TypedArray`);
      const i = this.settings.defaultType;
      let s = false;
      if (this.doublePrecision && (s = t.BYTES_PER_ELEMENT < 4), s) throw new Error(`Attribute ${this.id} does not support ${t.constructor.name}`);
      !(t instanceof i) && this.settings.normalized && !("normalized" in e) && Le.warn(`Attribute ${this.id} is normalized`)();
    }
    normalizeConstant(e) {
      switch (this.settings.type) {
        case "snorm8":
          return new Float32Array(e).map((t) => (t + 128) / 255 * 2 - 1);
        case "snorm16":
          return new Float32Array(e).map((t) => (t + 32768) / 65535 * 2 - 1);
        case "unorm8":
          return new Float32Array(e).map((t) => t / 255);
        case "unorm16":
          return new Float32Array(e).map((t) => t / 65535);
        default:
          return e;
      }
    }
    _normalizeValue(e, t, i) {
      const { defaultValue: s, size: a } = this.settings;
      if (Number.isFinite(e)) return t[i] = e, t;
      if (!e) {
        let l = a;
        for (; --l >= 0; ) t[i + l] = s[l];
        return t;
      }
      switch (a) {
        case 4:
          t[i + 3] = Number.isFinite(e[3]) ? e[3] : s[3];
        case 3:
          t[i + 2] = Number.isFinite(e[2]) ? e[2] : s[2];
        case 2:
          t[i + 1] = Number.isFinite(e[1]) ? e[1] : s[1];
        case 1:
          t[i + 0] = Number.isFinite(e[0]) ? e[0] : s[0];
          break;
        default:
          let l = a;
          for (; --l >= 0; ) t[i + l] = Number.isFinite(e[l]) ? e[l] : s[l];
      }
      return t;
    }
    _areValuesEqual(e, t) {
      if (!e || !t) return false;
      const { size: i } = this;
      for (let s = 0; s < i; s++) if (e[s] !== t[s]) return false;
      return true;
    }
    _createBuffer(e) {
      var _a2;
      this._buffer && this._buffer.destroy();
      const { isIndexed: t, type: i } = this.settings;
      return this._buffer = this.device.createBuffer({
        ...(_a2 = this._buffer) == null ? void 0 : _a2.props,
        id: this.id,
        usage: (t ? Ke.INDEX : Ke.VERTEX) | Ke.COPY_DST,
        indexType: t ? i : void 0,
        byteLength: e
      }), this._buffer;
    }
  }
  const G0 = [], J0 = [];
  function oT(n, e = 0, t = 1 / 0) {
    let i = G0;
    const s = {
      index: -1,
      data: n,
      target: []
    };
    return n ? typeof n[Symbol.iterator] == "function" ? i = n : n.length > 0 && (J0.length = n.length, i = J0) : i = G0, (e > 0 || Number.isFinite(t)) && (i = (Array.isArray(i) ? i : Array.from(i)).slice(e, t), s.index = e - 1), {
      iterable: i,
      objectInfo: s
    };
  }
  function lT(n) {
    return n && n[Symbol.asyncIterator];
  }
  function eD(n, e) {
    const { size: t, stride: i, offset: s, startIndices: a, nested: l } = e, u = n.BYTES_PER_ELEMENT, h = i ? i / u : t, d = s ? s / u : 0, p = Math.floor((n.length - d) / h);
    return (_, { index: y, target: v }) => {
      if (!a) {
        const F = y * h + d;
        for (let H = 0; H < t; H++) v[H] = n[F + H];
        return v;
      }
      const S = a[y], E = a[y + 1] || p;
      let M;
      if (l) {
        M = new Array(E - S);
        for (let F = S; F < E; F++) {
          const H = F * h + d;
          v = new Array(t);
          for (let O = 0; O < t; O++) v[O] = n[H + O];
          M[F - S] = v;
        }
      } else if (h === t) M = n.subarray(S * t + d, E * t + d);
      else {
        M = new n.constructor((E - S) * t);
        let F = 0;
        for (let H = S; H < E; H++) {
          const O = H * h + d;
          for (let U = 0; U < t; U++) M[F++] = n[O + U];
        }
      }
      return M;
    };
  }
  const tD = [], hc = [
    [
      0,
      1 / 0
    ]
  ];
  function nD(n, e) {
    if (n === hc || (e[0] < 0 && (e[0] = 0), e[0] >= e[1])) return n;
    const t = [], i = n.length;
    let s = 0;
    for (let a = 0; a < i; a++) {
      const l = n[a];
      l[1] < e[0] ? (t.push(l), s = a + 1) : l[0] > e[1] ? t.push(l) : e = [
        Math.min(l[0], e[0]),
        Math.max(l[1], e[1])
      ];
    }
    return t.splice(s, 0, e), t;
  }
  const iD = {
    interpolation: {
      duration: 0,
      easing: (n) => n
    },
    spring: {
      stiffness: 0.05,
      damping: 0.5
    }
  };
  function cT(n, e) {
    if (!n) return null;
    Number.isFinite(n) && (n = {
      type: "interpolation",
      duration: n
    });
    const t = n.type || "interpolation";
    return {
      ...iD[t],
      ...e,
      ...n,
      type: t
    };
  }
  class uT extends JP {
    constructor(e, t) {
      super(e, t, {
        startIndices: null,
        lastExternalBuffer: null,
        binaryValue: null,
        binaryAccessor: null,
        needsUpdate: true,
        needsRedraw: false,
        layoutChanged: false,
        updateRanges: hc
      }), this.constant = false, this.settings.update = t.update || (t.accessor ? this._autoUpdater : void 0), Object.seal(this.settings), Object.seal(this.state), this._validateAttributeUpdaters();
    }
    get startIndices() {
      return this.state.startIndices;
    }
    set startIndices(e) {
      this.state.startIndices = e;
    }
    needsUpdate() {
      return this.state.needsUpdate;
    }
    needsRedraw({ clearChangedFlags: e = false } = {}) {
      const t = this.state.needsRedraw;
      return this.state.needsRedraw = t && !e, t;
    }
    layoutChanged() {
      return this.state.layoutChanged;
    }
    setAccessor(e) {
      var t;
      (t = this.state).layoutChanged || (t.layoutChanged = !QP(e, this.getAccessor())), super.setAccessor(e);
    }
    getUpdateTriggers() {
      const { accessor: e } = this.settings;
      return [
        this.id
      ].concat(typeof e != "function" && e || []);
    }
    supportsTransition() {
      return !!this.settings.transition;
    }
    getTransitionSetting(e) {
      if (!e || !this.supportsTransition()) return null;
      const { accessor: t } = this.settings, i = this.settings.transition, s = Array.isArray(t) ? e[t.find((a) => e[a])] : e[t];
      return cT(s, i);
    }
    setNeedsUpdate(e = this.id, t) {
      if (this.state.needsUpdate = this.state.needsUpdate || e, this.setNeedsRedraw(e), t) {
        const { startRow: i = 0, endRow: s = 1 / 0 } = t;
        this.state.updateRanges = nD(this.state.updateRanges, [
          i,
          s
        ]);
      } else this.state.updateRanges = hc;
    }
    clearNeedsUpdate() {
      this.state.needsUpdate = false, this.state.updateRanges = tD;
    }
    setNeedsRedraw(e = this.id) {
      this.state.needsRedraw = this.state.needsRedraw || e;
    }
    allocate(e) {
      const { state: t, settings: i } = this;
      return i.noAlloc ? false : i.update ? (super.allocate(e, t.updateRanges !== hc), true) : false;
    }
    updateBuffer({ numInstances: e, data: t, props: i, context: s }) {
      if (!this.needsUpdate()) return false;
      const { state: { updateRanges: a }, settings: { update: l, noAlloc: u } } = this;
      let h = true;
      if (l) {
        for (const [d, p] of a) l.call(s, this, {
          data: t,
          startRow: d,
          endRow: p,
          props: i,
          numInstances: e
        });
        if (this.value) if (this.constant || !this.buffer || this.buffer.byteLength < this.value.byteLength + this.byteOffset) this.setData({
          value: this.value,
          constant: this.constant
        }), this.constant = false;
        else for (const [d, p] of a) {
          const _ = Number.isFinite(d) ? this.getVertexOffset(d) : 0, y = Number.isFinite(p) ? this.getVertexOffset(p) : u || !Number.isFinite(e) ? this.value.length : e * this.size;
          super.updateSubBuffer({
            startOffset: _,
            endOffset: y
          });
        }
        this._checkAttributeArray();
      } else h = false;
      return this.clearNeedsUpdate(), this.setNeedsRedraw(), h;
    }
    setConstantValue(e) {
      return this.device.type === "webgpu" || e === void 0 || typeof e == "function" ? false : (this.setData({
        constant: true,
        value: e
      }) && this.setNeedsRedraw(), this.clearNeedsUpdate(), true);
    }
    setExternalBuffer(e) {
      const { state: t } = this;
      return e ? (this.clearNeedsUpdate(), t.lastExternalBuffer === e || (t.lastExternalBuffer = e, this.setNeedsRedraw(), this.setData(e)), true) : (t.lastExternalBuffer = null, false);
    }
    setBinaryValue(e, t = null) {
      const { state: i, settings: s } = this;
      if (!e) return i.binaryValue = null, i.binaryAccessor = null, false;
      if (s.noAlloc) return false;
      if (i.binaryValue === e) return this.clearNeedsUpdate(), true;
      if (i.binaryValue = e, this.setNeedsRedraw(), s.transform || t !== this.startIndices) {
        ArrayBuffer.isView(e) && (e = {
          value: e
        });
        const l = e;
        It(ArrayBuffer.isView(l.value), `invalid ${s.accessor}`);
        const u = !!l.size && l.size !== this.size;
        return i.binaryAccessor = eD(l.value, {
          size: l.size || this.size,
          stride: l.stride,
          offset: l.offset,
          startIndices: t,
          nested: u
        }), false;
      }
      return this.clearNeedsUpdate(), this.setData(e), true;
    }
    getVertexOffset(e) {
      const { startIndices: t } = this;
      return (t ? e < t.length ? t[e] : this.numInstances : e) * this.size;
    }
    getValue() {
      const e = this.settings.shaderAttributes, t = super.getValue();
      if (!e) return t;
      for (const i in e) Object.assign(t, super.getValue(i, e[i]));
      return t;
    }
    getBufferLayout(e) {
      this.state.layoutChanged = false;
      const t = this.settings.shaderAttributes, i = super._getBufferLayout(), { stepMode: s } = this.settings;
      if (s === "dynamic" ? i.stepMode = e ? e.isInstanced ? "instance" : "vertex" : "instance" : i.stepMode = s ?? "vertex", !t) return i;
      for (const a in t) {
        const l = super._getBufferLayout(a, t[a]);
        i.attributes.push(...l.attributes);
      }
      return i;
    }
    _autoUpdater(e, { data: t, startRow: i, endRow: s, props: a, numInstances: l }) {
      if (e.constant && this.context.device.type !== "webgpu") return;
      const { settings: u, state: h, value: d, size: p, startIndices: _ } = e, { accessor: y, transform: v } = u;
      let S = h.binaryAccessor || (typeof y == "function" ? y : a[y]);
      typeof S != "function" && (S = () => S), It(typeof S == "function", `accessor "${y}" is not a function`);
      let E = e.getVertexOffset(i);
      const { iterable: M, objectInfo: F } = oT(t, i, s);
      for (const H of M) {
        F.index++;
        let O = S(H, F);
        if (v && (O = v.call(this, O)), _) {
          const U = (F.index < _.length - 1 ? _[F.index + 1] : l) - _[F.index];
          if (O && Array.isArray(O[0])) {
            let B = E;
            for (const Z of O) e._normalizeValue(Z, d, B), B += p;
          } else O && O.length > p ? d.set(O, E) : (e._normalizeValue(O, F.target, 0), p4({
            target: d,
            source: F.target,
            start: E,
            count: U
          }));
          E += U * p;
        } else e._normalizeValue(O, d, E), E += p;
      }
    }
    _validateAttributeUpdaters() {
      const { settings: e } = this;
      if (!(e.noAlloc || typeof e.update == "function")) throw new Error(`Attribute ${this.id} missing update or accessor`);
    }
    _checkAttributeArray() {
      const { value: e } = this, t = Math.min(4, this.size);
      if (e && e.length >= t) {
        let i = true;
        switch (t) {
          case 4:
            i = i && Number.isFinite(e[3]);
          case 3:
            i = i && Number.isFinite(e[2]);
          case 2:
            i = i && Number.isFinite(e[1]);
          case 1:
            i = i && Number.isFinite(e[0]);
            break;
          default:
            i = false;
        }
        if (!i) throw new Error(`Illegal attribute generated for ${this.id}`);
      }
    }
  }
  function rd(n) {
    const { source: e, target: t, start: i = 0, size: s, getData: a } = n, l = n.end || t.length, u = e.length, h = l - i;
    if (u > h) {
      t.set(e.subarray(0, h), i);
      return;
    }
    if (t.set(e, i), !a) return;
    let d = u;
    for (; d < h; ) {
      const p = a(d, e);
      for (let _ = 0; _ < s; _++) t[i + d] = p[_] || 0, d++;
    }
  }
  function sD({ source: n, target: e, size: t, getData: i, sourceStartIndices: s, targetStartIndices: a }) {
    if (!s || !a) return rd({
      source: n,
      target: e,
      size: t,
      getData: i
    }), e;
    let l = 0, u = 0;
    const h = i && ((p, _) => i(p + u, _)), d = Math.min(s.length, a.length);
    for (let p = 1; p < d; p++) {
      const _ = s[p] * t, y = a[p] * t;
      rd({
        source: n.subarray(l, _),
        target: e,
        start: u,
        end: y,
        size: t,
        getData: h
      }), l = _, u = y;
    }
    return u < e.length && rd({
      source: [],
      target: e,
      start: u,
      size: t,
      getData: h
    }), e;
  }
  function rD(n) {
    const { device: e, settings: t, value: i } = n, s = new uT(e, t);
    return s.setData({
      value: i instanceof Float64Array ? new Float64Array(0) : new Float32Array(0),
      normalized: t.normalized
    }), s;
  }
  function fT(n) {
    switch (n) {
      case 1:
        return "float";
      case 2:
        return "vec2";
      case 3:
        return "vec3";
      case 4:
        return "vec4";
      default:
        throw new Error(`No defined attribute type for size "${n}"`);
    }
  }
  function hT(n) {
    switch (n) {
      case 1:
        return "float32";
      case 2:
        return "float32x2";
      case 3:
        return "float32x3";
      case 4:
        return "float32x4";
      default:
        throw new Error("invalid type size");
    }
  }
  function dT(n) {
    n.push(n.shift());
  }
  function aD(n, e) {
    const { doublePrecision: t, settings: i, value: s, size: a } = n, l = t && s instanceof Float64Array ? 2 : 1;
    let u = 0;
    const { shaderAttributes: h } = n.settings;
    if (h) for (const d of Object.values(h)) u = Math.max(u, d.vertexOffset ?? 0);
    return (i.noAlloc ? s.length : (e + u) * a) * l;
  }
  function gT({ device: n, source: e, target: t }) {
    return (!t || t.byteLength < e.byteLength) && (t == null ? void 0 : t.destroy(), t = n.createBuffer({
      byteLength: e.byteLength,
      usage: e.usage
    })), t;
  }
  function pT({ device: n, buffer: e, attribute: t, fromLength: i, toLength: s, fromStartIndices: a, getData: l = (u) => u }) {
    const u = t.doublePrecision && t.value instanceof Float64Array ? 2 : 1, h = t.size * u, d = t.byteOffset, p = t.settings.bytesPerElement < 4 ? d / t.settings.bytesPerElement * 4 : d, _ = t.startIndices, y = a && _, v = t.isConstant;
    if (!y && e && i >= s) return e;
    const S = t.value instanceof Float64Array ? Float32Array : t.value.constructor, E = v ? t.value : new S(t.getBuffer().readSyncWebGL(d, s * S.BYTES_PER_ELEMENT).buffer);
    if (t.settings.normalized && !v) {
      const O = l;
      l = (U, B) => t.normalizeConstant(O(U, B));
    }
    const M = v ? (O, U) => l(E, U) : (O, U) => l(E.subarray(O + d, O + d + h), U), F = e ? new Float32Array(e.readSyncWebGL(p, i * 4).buffer) : new Float32Array(0), H = new Float32Array(s);
    return sD({
      source: F,
      target: H,
      sourceStartIndices: a,
      targetStartIndices: _,
      size: h,
      getData: M
    }), (!e || e.byteLength < H.byteLength + p) && (e == null ? void 0 : e.destroy(), e = n.createBuffer({
      byteLength: H.byteLength + p,
      usage: 35050
    })), e.write(H, p), e;
  }
  class mT {
    constructor({ device: e, attribute: t, timeline: i }) {
      this.buffers = [], this.currentLength = 0, this.device = e, this.transition = new eu(i), this.attribute = t, this.attributeInTransition = rD(t), this.currentStartIndices = t.startIndices;
    }
    get inProgress() {
      return this.transition.inProgress;
    }
    start(e, t, i = 1 / 0) {
      this.settings = e, this.currentStartIndices = this.attribute.startIndices, this.currentLength = aD(this.attribute, t), this.transition.start({
        ...e,
        duration: i
      });
    }
    update() {
      const e = this.transition.update();
      return e && this.onUpdate(), e;
    }
    setBuffer(e) {
      this.attributeInTransition.setData({
        buffer: e,
        normalized: this.attribute.settings.normalized,
        value: this.attributeInTransition.value
      });
    }
    cancel() {
      this.transition.cancel();
    }
    delete() {
      this.cancel();
      for (const e of this.buffers) e.destroy();
      this.buffers.length = 0;
    }
  }
  class oD extends mT {
    constructor({ device: e, attribute: t, timeline: i }) {
      super({
        device: e,
        attribute: t,
        timeline: i
      }), this.type = "interpolation", this.transform = fD(e, t);
    }
    start(e, t) {
      const i = this.currentLength, s = this.currentStartIndices;
      if (super.start(e, t, e.duration), e.duration <= 0) {
        this.transition.cancel();
        return;
      }
      const { buffers: a, attribute: l } = this;
      dT(a), a[0] = pT({
        device: this.device,
        buffer: a[0],
        attribute: l,
        fromLength: i,
        toLength: this.currentLength,
        fromStartIndices: s,
        getData: e.enter
      }), a[1] = gT({
        device: this.device,
        source: a[0],
        target: a[1]
      }), this.setBuffer(a[1]);
      const { transform: u } = this, h = u.model;
      let d = Math.floor(this.currentLength / l.size);
      _T(l) && (d /= 2), h.setVertexCount(d), l.isConstant ? (h.setAttributes({
        aFrom: a[0]
      }), h.setConstantAttributes({
        aTo: l.value
      })) : h.setAttributes({
        aFrom: a[0],
        aTo: l.getBuffer()
      }), u.transformFeedback.setBuffers({
        vCurrent: a[1]
      });
    }
    onUpdate() {
      const { duration: e, easing: t } = this.settings, { time: i } = this.transition;
      let s = i / e;
      t && (s = t(s));
      const { model: a } = this.transform, l = {
        time: s
      };
      a.shaderInputs.setProps({
        interpolation: l
      }), this.transform.run({
        discard: true
      });
    }
    delete() {
      super.delete(), this.transform.destroy();
    }
  }
  const lD = `uniform interpolationUniforms {
  float time;
} interpolation;
`, ev = {
    name: "interpolation",
    vs: lD,
    uniformTypes: {
      time: "f32"
    }
  }, cD = `#version 300 es
#define SHADER_NAME interpolation-transition-vertex-shader

in ATTRIBUTE_TYPE aFrom;
in ATTRIBUTE_TYPE aTo;
out ATTRIBUTE_TYPE vCurrent;

void main(void) {
  vCurrent = mix(aFrom, aTo, interpolation.time);
  gl_Position = vec4(0.0);
}
`, uD = `#version 300 es
#define SHADER_NAME interpolation-transition-vertex-shader

in ATTRIBUTE_TYPE aFrom;
in ATTRIBUTE_TYPE aFrom64Low;
in ATTRIBUTE_TYPE aTo;
in ATTRIBUTE_TYPE aTo64Low;
out ATTRIBUTE_TYPE vCurrent;
out ATTRIBUTE_TYPE vCurrent64Low;

vec2 mix_fp64(vec2 a, vec2 b, float x) {
  vec2 range = sub_fp64(b, a);
  return sum_fp64(a, mul_fp64(range, vec2(x, 0.0)));
}

void main(void) {
  for (int i=0; i<ATTRIBUTE_SIZE; i++) {
    vec2 value = mix_fp64(vec2(aFrom[i], aFrom64Low[i]), vec2(aTo[i], aTo64Low[i]), interpolation.time);
    vCurrent[i] = value.x;
    vCurrent64Low[i] = value.y;
  }
  gl_Position = vec4(0.0);
}
`;
  function _T(n) {
    return n.doublePrecision && n.value instanceof Float64Array;
  }
  function fD(n, e) {
    const t = e.size, i = fT(t), s = hT(t), a = e.getBufferLayout();
    return _T(e) ? new Cs(n, {
      vs: uD,
      bufferLayout: [
        {
          name: "aFrom",
          byteStride: 8 * t,
          attributes: [
            {
              attribute: "aFrom",
              format: s,
              byteOffset: 0
            },
            {
              attribute: "aFrom64Low",
              format: s,
              byteOffset: 4 * t
            }
          ]
        },
        {
          name: "aTo",
          byteStride: 8 * t,
          attributes: [
            {
              attribute: "aTo",
              format: s,
              byteOffset: 0
            },
            {
              attribute: "aTo64Low",
              format: s,
              byteOffset: 4 * t
            }
          ]
        }
      ],
      modules: [
        pM,
        ev
      ],
      defines: {
        ATTRIBUTE_TYPE: i,
        ATTRIBUTE_SIZE: t
      },
      moduleSettings: {},
      varyings: [
        "vCurrent",
        "vCurrent64Low"
      ],
      bufferMode: 35980,
      disableWarnings: true
    }) : new Cs(n, {
      vs: cD,
      bufferLayout: [
        {
          name: "aFrom",
          format: s
        },
        {
          name: "aTo",
          format: a.attributes[0].format
        }
      ],
      modules: [
        ev
      ],
      defines: {
        ATTRIBUTE_TYPE: i
      },
      varyings: [
        "vCurrent"
      ],
      disableWarnings: true
    });
  }
  class hD extends mT {
    constructor({ device: e, attribute: t, timeline: i }) {
      super({
        device: e,
        attribute: t,
        timeline: i
      }), this.type = "spring", this.texture = yD(e), this.framebuffer = bD(e, this.texture), this.transform = _D(e, t);
    }
    start(e, t) {
      const i = this.currentLength, s = this.currentStartIndices;
      super.start(e, t);
      const { buffers: a, attribute: l } = this;
      for (let h = 0; h < 2; h++) a[h] = pT({
        device: this.device,
        buffer: a[h],
        attribute: l,
        fromLength: i,
        toLength: this.currentLength,
        fromStartIndices: s,
        getData: e.enter
      });
      a[2] = gT({
        device: this.device,
        source: a[0],
        target: a[2]
      }), this.setBuffer(a[1]);
      const { model: u } = this.transform;
      u.setVertexCount(Math.floor(this.currentLength / l.size)), l.isConstant ? u.setConstantAttributes({
        aTo: l.value
      }) : u.setAttributes({
        aTo: l.getBuffer()
      });
    }
    onUpdate() {
      const { buffers: e, transform: t, framebuffer: i, transition: s } = this, a = this.settings;
      t.model.setAttributes({
        aPrev: e[0],
        aCur: e[1]
      }), t.transformFeedback.setBuffers({
        vNext: e[2]
      });
      const l = {
        stiffness: a.stiffness,
        damping: a.damping
      };
      t.model.shaderInputs.setProps({
        spring: l
      }), t.run({
        framebuffer: i,
        discard: false,
        parameters: {
          viewport: [
            0,
            0,
            1,
            1
          ]
        },
        clearColor: [
          0,
          0,
          0,
          0
        ]
      }), dT(e), this.setBuffer(e[1]), this.device.readPixelsToArrayWebGL(i)[0] > 0 || s.end();
    }
    delete() {
      super.delete(), this.transform.destroy(), this.texture.destroy(), this.framebuffer.destroy();
    }
  }
  const dD = `uniform springUniforms {
  float damping;
  float stiffness;
} spring;
`, gD = {
    name: "spring",
    vs: dD,
    uniformTypes: {
      damping: "f32",
      stiffness: "f32"
    }
  }, pD = `#version 300 es
#define SHADER_NAME spring-transition-vertex-shader

#define EPSILON 0.00001

in ATTRIBUTE_TYPE aPrev;
in ATTRIBUTE_TYPE aCur;
in ATTRIBUTE_TYPE aTo;
out ATTRIBUTE_TYPE vNext;
out float vIsTransitioningFlag;

ATTRIBUTE_TYPE getNextValue(ATTRIBUTE_TYPE cur, ATTRIBUTE_TYPE prev, ATTRIBUTE_TYPE dest) {
  ATTRIBUTE_TYPE velocity = cur - prev;
  ATTRIBUTE_TYPE delta = dest - cur;
  ATTRIBUTE_TYPE force = delta * spring.stiffness;
  ATTRIBUTE_TYPE resistance = velocity * spring.damping;
  return force - resistance + velocity + cur;
}

void main(void) {
  bool isTransitioning = length(aCur - aPrev) > EPSILON || length(aTo - aCur) > EPSILON;
  vIsTransitioningFlag = isTransitioning ? 1.0 : 0.0;

  vNext = getNextValue(aCur, aPrev, aTo);
  gl_Position = vec4(0, 0, 0, 1);
  gl_PointSize = 100.0;
}
`, mD = `#version 300 es
#define SHADER_NAME spring-transition-is-transitioning-fragment-shader

in float vIsTransitioningFlag;

out vec4 fragColor;

void main(void) {
  if (vIsTransitioningFlag == 0.0) {
    discard;
  }
  fragColor = vec4(1.0);
}`;
  function _D(n, e) {
    const t = fT(e.size), i = hT(e.size);
    return new Cs(n, {
      vs: pD,
      fs: mD,
      bufferLayout: [
        {
          name: "aPrev",
          format: i
        },
        {
          name: "aCur",
          format: i
        },
        {
          name: "aTo",
          format: e.getBufferLayout().attributes[0].format
        }
      ],
      varyings: [
        "vNext"
      ],
      modules: [
        gD
      ],
      defines: {
        ATTRIBUTE_TYPE: t
      },
      parameters: {
        depthCompare: "always",
        blendColorOperation: "max",
        blendColorSrcFactor: "one",
        blendColorDstFactor: "one",
        blendAlphaOperation: "max",
        blendAlphaSrcFactor: "one",
        blendAlphaDstFactor: "one"
      }
    });
  }
  function yD(n) {
    return n.createTexture({
      data: new Uint8Array(4),
      format: "rgba8unorm",
      mipmaps: false,
      width: 1,
      height: 1
    });
  }
  function bD(n, e) {
    return n.createFramebuffer({
      id: "spring-transition-is-transitioning-framebuffer",
      width: 1,
      height: 1,
      colorAttachments: [
        e
      ]
    });
  }
  const vD = {
    interpolation: oD,
    spring: hD
  };
  class TD {
    constructor(e, { id: t, timeline: i }) {
      if (!e) throw new Error("AttributeTransitionManager is constructed without device");
      this.id = t, this.device = e, this.timeline = i, this.transitions = {}, this.needsRedraw = false, this.numInstances = 1;
    }
    finalize() {
      for (const e in this.transitions) this._removeTransition(e);
    }
    update({ attributes: e, transitions: t, numInstances: i }) {
      this.numInstances = i || 1;
      for (const s in e) {
        const a = e[s], l = a.getTransitionSetting(t);
        l && this._updateAttribute(s, a, l);
      }
      for (const s in this.transitions) {
        const a = e[s];
        (!a || !a.getTransitionSetting(t)) && this._removeTransition(s);
      }
    }
    hasAttribute(e) {
      const t = this.transitions[e];
      return t && t.inProgress;
    }
    getAttributes() {
      const e = {};
      for (const t in this.transitions) {
        const i = this.transitions[t];
        i.inProgress && (e[t] = i.attributeInTransition);
      }
      return e;
    }
    run() {
      if (this.numInstances === 0) return false;
      for (const t in this.transitions) this.transitions[t].update() && (this.needsRedraw = true);
      const e = this.needsRedraw;
      return this.needsRedraw = false, e;
    }
    _removeTransition(e) {
      this.transitions[e].delete(), delete this.transitions[e];
    }
    _updateAttribute(e, t, i) {
      const s = this.transitions[e];
      let a = !s || s.type !== i.type;
      if (a) {
        s && this._removeTransition(e);
        const l = vD[i.type];
        l ? this.transitions[e] = new l({
          attribute: t,
          timeline: this.timeline,
          device: this.device
        }) : (Le.error(`unsupported transition type '${i.type}'`)(), a = false);
      }
      (a || t.needsRedraw()) && (this.needsRedraw = true, this.transitions[e].start(i, this.numInstances));
    }
  }
  const tv = "attributeManager.invalidate", xD = "attributeManager.updateStart", SD = "attributeManager.updateEnd", AD = "attribute.updateStart", wD = "attribute.allocate", ED = "attribute.updateEnd";
  class tu {
    constructor(e, { id: t = "attribute-manager", stats: i, timeline: s } = {}) {
      this.mergeBoundsMemoized = Ro(NI), this.id = t, this.device = e, this.attributes = {}, this.updateTriggers = {}, this.needsRedraw = true, this.userData = {}, this.stats = i, this.attributeTransitionManager = new TD(e, {
        id: `${t}-transitions`,
        timeline: s
      }), Object.seal(this);
    }
    finalize() {
      for (const e in this.attributes) this.attributes[e].delete();
      this.attributeTransitionManager.finalize();
    }
    getNeedsRedraw(e = {
      clearRedrawFlags: false
    }) {
      const t = this.needsRedraw;
      return this.needsRedraw = this.needsRedraw && !e.clearRedrawFlags, t && this.id;
    }
    setNeedsRedraw() {
      this.needsRedraw = true;
    }
    add(e) {
      this._add(e);
    }
    addInstanced(e) {
      this._add(e, {
        stepMode: "instance"
      });
    }
    remove(e) {
      for (const t of e) this.attributes[t] !== void 0 && (this.attributes[t].delete(), delete this.attributes[t]);
    }
    invalidate(e, t) {
      const i = this._invalidateTrigger(e, t);
      Ot(tv, this, e, i);
    }
    invalidateAll(e) {
      for (const t in this.attributes) this.attributes[t].setNeedsUpdate(t, e);
      Ot(tv, this, "all");
    }
    update({ data: e, numInstances: t, startIndices: i = null, transitions: s, props: a = {}, buffers: l = {}, context: u = {} }) {
      let h = false;
      Ot(xD, this), this.stats && this.stats.get("Update Attributes").timeStart();
      for (const d in this.attributes) {
        const p = this.attributes[d], _ = p.settings.accessor;
        p.startIndices = i, p.numInstances = t, a[d] && Le.removed(`props.${d}`, `data.attributes.${d}`)(), p.setExternalBuffer(l[d]) || p.setBinaryValue(typeof _ == "string" ? l[_] : void 0, e.startIndices) || typeof _ == "string" && !l[_] && p.setConstantValue(a[_]) || p.needsUpdate() && (h = true, this._updateAttribute({
          attribute: p,
          numInstances: t,
          data: e,
          props: a,
          context: u
        })), this.needsRedraw = this.needsRedraw || p.needsRedraw();
      }
      h && Ot(SD, this, t), this.stats && this.stats.get("Update Attributes").timeEnd(), this.attributeTransitionManager.update({
        attributes: this.attributes,
        numInstances: t,
        transitions: s
      });
    }
    updateTransition() {
      const { attributeTransitionManager: e } = this, t = e.run();
      return this.needsRedraw = this.needsRedraw || t, t;
    }
    getAttributes() {
      return {
        ...this.attributes,
        ...this.attributeTransitionManager.getAttributes()
      };
    }
    getBounds(e) {
      const t = e.map((i) => {
        var _a2;
        return (_a2 = this.attributes[i]) == null ? void 0 : _a2.getBounds();
      });
      return this.mergeBoundsMemoized(t);
    }
    getChangedAttributes(e = {
      clearChangedFlags: false
    }) {
      const { attributes: t, attributeTransitionManager: i } = this, s = {
        ...i.getAttributes()
      };
      for (const a in t) {
        const l = t[a];
        l.needsRedraw(e) && !i.hasAttribute(a) && (s[a] = l);
      }
      return s;
    }
    getBufferLayouts(e) {
      return Object.values(this.getAttributes()).map((t) => t.getBufferLayout(e));
    }
    _add(e, t) {
      for (const i in e) {
        const s = e[i], a = {
          ...s,
          id: i,
          size: s.isIndexed && 1 || s.size || 1,
          ...t
        };
        this.attributes[i] = new uT(this.device, a);
      }
      this._mapUpdateTriggersToAttributes();
    }
    _mapUpdateTriggersToAttributes() {
      const e = {};
      for (const t in this.attributes) this.attributes[t].getUpdateTriggers().forEach((s) => {
        e[s] || (e[s] = []), e[s].push(t);
      });
      this.updateTriggers = e;
    }
    _invalidateTrigger(e, t) {
      const { attributes: i, updateTriggers: s } = this, a = s[e];
      return a && a.forEach((l) => {
        const u = i[l];
        u && u.setNeedsUpdate(u.id, t);
      }), a;
    }
    _updateAttribute(e) {
      const { attribute: t, numInstances: i } = e;
      if (Ot(AD, t), t.constant) {
        t.setConstantValue(t.value);
        return;
      }
      t.allocate(i) && Ot(wD, t, i), t.updateBuffer(e) && (this.needsRedraw = true, Ot(ED, t, i));
    }
  }
  class RD extends eu {
    get value() {
      return this._value;
    }
    _onUpdate() {
      const { time: e, settings: { fromValue: t, toValue: i, duration: s, easing: a } } = this, l = a(e / s);
      this._value = Rc(t, i, l);
    }
  }
  const nv = 1e-5;
  function iv(n, e, t, i, s) {
    const a = e - n, u = (t - e) * s, h = -a * i;
    return u + h + a + e;
  }
  function CD(n, e, t, i, s) {
    if (Array.isArray(t)) {
      const a = [];
      for (let l = 0; l < t.length; l++) a[l] = iv(n[l], e[l], t[l], i, s);
      return a;
    }
    return iv(n, e, t, i, s);
  }
  function sv(n, e) {
    if (Array.isArray(n)) {
      let t = 0;
      for (let i = 0; i < n.length; i++) {
        const s = n[i] - e[i];
        t += s * s;
      }
      return Math.sqrt(t);
    }
    return Math.abs(n - e);
  }
  class MD extends eu {
    get value() {
      return this._currValue;
    }
    _onUpdate() {
      const { fromValue: e, toValue: t, damping: i, stiffness: s } = this.settings, { _prevValue: a = e, _currValue: l = e } = this;
      let u = CD(a, l, t, i, s);
      const h = sv(u, t), d = sv(u, l);
      h < nv && d < nv && (u = t, this.end()), this._prevValue = l, this._currValue = u;
    }
  }
  const OD = {
    interpolation: RD,
    spring: MD
  };
  class ID {
    constructor(e) {
      this.transitions = /* @__PURE__ */ new Map(), this.timeline = e;
    }
    get active() {
      return this.transitions.size > 0;
    }
    add(e, t, i, s) {
      const { transitions: a } = this;
      if (a.has(e)) {
        const h = a.get(e), { value: d = h.settings.fromValue } = h;
        t = d, this.remove(e);
      }
      if (s = cT(s), !s) return;
      const l = OD[s.type];
      if (!l) {
        Le.error(`unsupported transition type '${s.type}'`)();
        return;
      }
      const u = new l(this.timeline);
      u.start({
        ...s,
        fromValue: t,
        toValue: i
      }), a.set(e, u);
    }
    remove(e) {
      const { transitions: t } = this;
      t.has(e) && (t.get(e).cancel(), t.delete(e));
    }
    update() {
      const e = {};
      for (const [t, i] of this.transitions) i.update(), e[t] = i.value, i.inProgress || this.remove(t);
      return e;
    }
    clear() {
      for (const e of this.transitions.keys()) this.remove(e);
    }
  }
  function ND(n) {
    const e = n[Xi];
    for (const t in e) {
      const i = e[t], { validate: s } = i;
      if (s && !s(n[t], i)) throw new Error(`Invalid prop ${t}: ${n[t]}`);
    }
  }
  function PD(n, e) {
    const t = Fg({
      newProps: n,
      oldProps: e,
      propTypes: n[Xi],
      ignoreProps: {
        data: null,
        updateTriggers: null,
        extensions: null,
        transitions: null
      }
    }), i = kD(n, e);
    let s = false;
    return i || (s = UD(n, e)), {
      dataChanged: i,
      propsChanged: t,
      updateTriggersChanged: s,
      extensionsChanged: BD(n, e),
      transitionsChanged: DD(n, e)
    };
  }
  function DD(n, e) {
    if (!n.transitions) return false;
    const t = {}, i = n[Xi];
    let s = false;
    for (const a in n.transitions) {
      const l = i[a], u = l && l.type;
      (u === "number" || u === "color" || u === "array") && Hd(n[a], e[a], l) && (t[a] = true, s = true);
    }
    return s ? t : false;
  }
  function Fg({ newProps: n, oldProps: e, ignoreProps: t = {}, propTypes: i = {}, triggerName: s = "props" }) {
    if (e === n) return false;
    if (typeof n != "object" || n === null) return `${s} changed shallowly`;
    if (typeof e != "object" || e === null) return `${s} changed shallowly`;
    for (const a of Object.keys(n)) if (!(a in t)) {
      if (!(a in e)) return `${s}.${a} added`;
      const l = Hd(n[a], e[a], i[a]);
      if (l) return `${s}.${a} ${l}`;
    }
    for (const a of Object.keys(e)) if (!(a in t)) {
      if (!(a in n)) return `${s}.${a} dropped`;
      if (!Object.hasOwnProperty.call(n, a)) {
        const l = Hd(n[a], e[a], i[a]);
        if (l) return `${s}.${a} ${l}`;
      }
    }
    return false;
  }
  function Hd(n, e, t) {
    let i = t && t.equal;
    return i && !i(n, e, t) || !i && (i = n && e && n.equals, i && !i.call(n, e)) ? "changed deeply" : !i && e !== n ? "changed shallowly" : null;
  }
  function kD(n, e) {
    if (e === null) return "oldProps is null, initial diff";
    let t = false;
    const { dataComparator: i, _dataDiff: s } = n;
    return i ? i(n.data, e.data) || (t = "Data comparator detected a change") : n.data !== e.data && (t = "A new data container was supplied"), t && s && (t = s(n.data, e.data) || t), t;
  }
  function UD(n, e) {
    if (e === null) return {
      all: true
    };
    if ("all" in n.updateTriggers && rv(n, e, "all")) return {
      all: true
    };
    const t = {};
    let i = false;
    for (const s in n.updateTriggers) s !== "all" && rv(n, e, s) && (t[s] = true, i = true);
    return i ? t : false;
  }
  function BD(n, e) {
    if (e === null) return true;
    const t = e.extensions, { extensions: i } = n;
    if (i === t) return false;
    if (!t || !i || i.length !== t.length) return true;
    for (let s = 0; s < i.length; s++) if (!i[s].equals(t[s])) return true;
    return false;
  }
  function rv(n, e, t) {
    let i = n.updateTriggers[t];
    i = i ?? {};
    let s = e.updateTriggers[t];
    return s = s ?? {}, Fg({
      oldProps: s,
      newProps: i,
      triggerName: t
    });
  }
  const LD = "count(): argument not an object", FD = "count(): argument not a container";
  function VD(n) {
    if (!HD(n)) throw new Error(LD);
    if (typeof n.count == "function") return n.count();
    if (Number.isFinite(n.size)) return n.size;
    if (Number.isFinite(n.length)) return n.length;
    if (zD(n)) return Object.keys(n).length;
    throw new Error(FD);
  }
  function zD(n) {
    return n !== null && typeof n == "object" && n.constructor === Object;
  }
  function HD(n) {
    return n !== null && typeof n == "object";
  }
  function av(n, e) {
    if (!e) return n;
    const t = {
      ...n,
      ...e
    };
    if ("defines" in e && (t.defines = {
      ...n.defines,
      ...e.defines
    }), "modules" in e && (t.modules = (n.modules || []).concat(e.modules), e.modules.some((i) => i.name === "project64"))) {
      const i = t.modules.findIndex((s) => s.name === "project32");
      i >= 0 && t.modules.splice(i, 1);
    }
    if ("inject" in e) if (!n.inject) t.inject = e.inject;
    else {
      const i = {
        ...n.inject
      };
      for (const s in e.inject) i[s] = (i[s] || "") + e.inject[s];
      t.inject = i;
    }
    return t;
  }
  const jD = {
    minFilter: "linear",
    mipmapFilter: "linear",
    magFilter: "linear",
    addressModeU: "clamp-to-edge",
    addressModeV: "clamp-to-edge"
  }, jd = {};
  function WD(n, e, t, i) {
    if (t instanceof $e) return t;
    t.constructor && t.constructor.name !== "Object" && (t = {
      data: t
    });
    let s = null;
    t.compressed && (s = {
      minFilter: "linear",
      mipmapFilter: t.data.length > 1 ? "nearest" : "linear"
    });
    const a = e.createTexture({
      ...t,
      sampler: {
        ...jD,
        ...s,
        ...i
      },
      mipmaps: true
    });
    return jd[a.id] = n, a;
  }
  function $D(n, e) {
    !e || !(e instanceof $e) || jd[e.id] === n && (e.delete(), delete jd[e.id]);
  }
  const XD = {
    boolean: {
      validate(n, e) {
        return true;
      },
      equal(n, e, t) {
        return !!n == !!e;
      }
    },
    number: {
      validate(n, e) {
        return Number.isFinite(n) && (!("max" in e) || n <= e.max) && (!("min" in e) || n >= e.min);
      }
    },
    color: {
      validate(n, e) {
        return e.optional && !n || Wd(n) && (n.length === 3 || n.length === 4);
      },
      equal(n, e, t) {
        return Ft(n, e, 1);
      }
    },
    accessor: {
      validate(n, e) {
        const t = kc(n);
        return t === "function" || t === kc(e.value);
      },
      equal(n, e, t) {
        return typeof e == "function" ? true : Ft(n, e, 1);
      }
    },
    array: {
      validate(n, e) {
        return e.optional && !n || Wd(n);
      },
      equal(n, e, t) {
        const { compare: i } = t, s = Number.isInteger(i) ? i : i ? 1 : 0;
        return i ? Ft(n, e, s) : n === e;
      }
    },
    object: {
      equal(n, e, t) {
        if (t.ignore) return true;
        const { compare: i } = t, s = Number.isInteger(i) ? i : i ? 1 : 0;
        return i ? Ft(n, e, s) : n === e;
      }
    },
    function: {
      validate(n, e) {
        return e.optional && !n || typeof n == "function";
      },
      equal(n, e, t) {
        return !t.compare && t.ignore !== false || n === e;
      }
    },
    data: {
      transform: (n, e, t) => {
        if (!n) return n;
        const { dataTransform: i } = t.props;
        return i ? i(n) : typeof n.shape == "string" && n.shape.endsWith("-table") && Array.isArray(n.data) ? n.data : n;
      }
    },
    image: {
      transform: (n, e, t) => {
        const i = t.context;
        return !i || !i.device ? null : WD(t.id, i.device, n, {
          ...e.parameters,
          ...t.props.textureParameters
        });
      },
      release: (n, e, t) => {
        $D(t.id, n);
      }
    }
  };
  function YD(n) {
    const e = {}, t = {}, i = {};
    for (const [s, a] of Object.entries(n)) {
      const l = a == null ? void 0 : a.deprecatedFor;
      if (l) i[s] = Array.isArray(l) ? l : [
        l
      ];
      else {
        const u = qD(s, a);
        e[s] = u, t[s] = u.value;
      }
    }
    return {
      propTypes: e,
      defaultProps: t,
      deprecatedProps: i
    };
  }
  function qD(n, e) {
    switch (kc(e)) {
      case "object":
        return eo(n, e);
      case "array":
        return eo(n, {
          type: "array",
          value: e,
          compare: false
        });
      case "boolean":
        return eo(n, {
          type: "boolean",
          value: e
        });
      case "number":
        return eo(n, {
          type: "number",
          value: e
        });
      case "function":
        return eo(n, {
          type: "function",
          value: e,
          compare: true
        });
      default:
        return {
          name: n,
          type: "unknown",
          value: e
        };
    }
  }
  function eo(n, e) {
    return "type" in e ? {
      name: n,
      ...XD[e.type],
      ...e
    } : "value" in e ? {
      name: n,
      type: kc(e.value),
      ...e
    } : {
      name: n,
      type: "object",
      value: e
    };
  }
  function Wd(n) {
    return Array.isArray(n) || ArrayBuffer.isView(n);
  }
  function kc(n) {
    return Wd(n) ? "array" : n === null ? "null" : typeof n;
  }
  function KD(n, e) {
    let t;
    for (let a = e.length - 1; a >= 0; a--) {
      const l = e[a];
      "extensions" in l && (t = l.extensions);
    }
    const i = $d(n.constructor, t), s = Object.create(i);
    s[Pc] = n, s[Ms] = {}, s[ji] = {};
    for (let a = 0; a < e.length; ++a) {
      const l = e[a];
      for (const u in l) s[u] = l[u];
    }
    return Object.freeze(s), s;
  }
  const ZD = "_mergedDefaultProps";
  function $d(n, e) {
    if (!(n instanceof nu.constructor)) return {};
    let t = ZD;
    if (e) for (const s of e) {
      const a = s.constructor;
      a && (t += `:${a.extensionName || a.name}`);
    }
    const i = yT(n, t);
    return i || (n[t] = QD(n, e || []));
  }
  function QD(n, e) {
    if (!n.prototype) return null;
    const i = Object.getPrototypeOf(n), s = $d(i), a = yT(n, "defaultProps") || {}, l = YD(a), u = Object.assign(/* @__PURE__ */ Object.create(null), s, l.defaultProps), h = Object.assign(/* @__PURE__ */ Object.create(null), s == null ? void 0 : s[Xi], l.propTypes), d = Object.assign(/* @__PURE__ */ Object.create(null), s == null ? void 0 : s[ed], l.deprecatedProps);
    for (const p of e) {
      const _ = $d(p.constructor);
      _ && (Object.assign(u, _), Object.assign(h, _[Xi]), Object.assign(d, _[ed]));
    }
    return GD(u, n), ek(u, h), JD(u, d), u[Xi] = h, u[ed] = d, e.length === 0 && !Vg(n, "_propTypes") && (n._propTypes = h), u;
  }
  function GD(n, e) {
    const t = nk(e);
    Object.defineProperties(n, {
      id: {
        writable: true,
        value: t
      }
    });
  }
  function JD(n, e) {
    for (const t in e) Object.defineProperty(n, t, {
      enumerable: false,
      set(i) {
        const s = `${this.id}: ${t}`;
        for (const a of e[t]) Vg(this, a) || (this[a] = i);
        Le.deprecated(s, e[t].join("/"))();
      }
    });
  }
  function ek(n, e) {
    const t = {}, i = {};
    for (const s in e) {
      const a = e[s], { name: l, value: u } = a;
      a.async && (t[l] = u, i[l] = tk(l));
    }
    n[Br] = t, n[Ms] = {}, Object.defineProperties(n, i);
  }
  function tk(n) {
    return {
      enumerable: true,
      set(e) {
        typeof e == "string" || e instanceof Promise || lT(e) ? this[Ms][n] = e : this[ji][n] = e;
      },
      get() {
        if (this[ji]) {
          if (n in this[ji]) return this[ji][n] || this[Br][n];
          if (n in this[Ms]) {
            const e = this[Pc] && this[Pc].internalState;
            if (e && e.hasAsyncProp(n)) return e.getAsyncProp(n) || this[Br][n];
          }
        }
        return this[Br][n];
      }
    };
  }
  function Vg(n, e) {
    return Object.prototype.hasOwnProperty.call(n, e);
  }
  function yT(n, e) {
    return Vg(n, e) && n[e];
  }
  function nk(n) {
    const e = n.componentName;
    return e || Le.warn(`${n.name}.componentName not specified`)(), e || n.name;
  }
  let ik = 0;
  class nu {
    constructor(...e) {
      this.props = KD(this, e), this.id = this.props.id, this.count = ik++;
    }
    clone(e) {
      const { props: t } = this, i = {};
      for (const s in t[Br]) s in t[ji] ? i[s] = t[ji][s] : s in t[Ms] && (i[s] = t[Ms][s]);
      return new this.constructor({
        ...t,
        ...i,
        ...e
      });
    }
  }
  nu.componentName = "Component";
  nu.defaultProps = {};
  const sk = Object.freeze({});
  class rk {
    constructor(e) {
      this.component = e, this.asyncProps = {}, this.onAsyncPropUpdated = () => {
      }, this.oldProps = null, this.oldAsyncProps = null;
    }
    finalize() {
      for (const e in this.asyncProps) {
        const t = this.asyncProps[e];
        t && t.type && t.type.release && t.type.release(t.resolvedValue, t.type, this.component);
      }
      this.asyncProps = {}, this.component = null, this.resetOldProps();
    }
    getOldProps() {
      return this.oldAsyncProps || this.oldProps || sk;
    }
    resetOldProps() {
      this.oldAsyncProps = null, this.oldProps = this.component ? this.component.props : null;
    }
    hasAsyncProp(e) {
      return e in this.asyncProps;
    }
    getAsyncProp(e) {
      const t = this.asyncProps[e];
      return t && t.resolvedValue;
    }
    isAsyncPropLoading(e) {
      if (e) {
        const t = this.asyncProps[e];
        return !!(t && t.pendingLoadCount > 0 && t.pendingLoadCount !== t.resolvedLoadCount);
      }
      for (const t in this.asyncProps) if (this.isAsyncPropLoading(t)) return true;
      return false;
    }
    reloadAsyncProp(e, t) {
      this._watchPromise(e, Promise.resolve(t));
    }
    setAsyncProps(e) {
      this.component = e[Pc] || this.component;
      const t = e[ji] || {}, i = e[Ms] || e, s = e[Br] || {};
      for (const a in t) {
        const l = t[a];
        this._createAsyncPropData(a, s[a]), this._updateAsyncProp(a, l), t[a] = this.getAsyncProp(a);
      }
      for (const a in i) {
        const l = i[a];
        this._createAsyncPropData(a, s[a]), this._updateAsyncProp(a, l);
      }
    }
    _fetch(e, t) {
      return null;
    }
    _onResolve(e, t) {
    }
    _onError(e, t) {
    }
    _updateAsyncProp(e, t) {
      if (this._didAsyncInputValueChange(e, t)) {
        if (typeof t == "string" && (t = this._fetch(e, t)), t instanceof Promise) {
          this._watchPromise(e, t);
          return;
        }
        if (lT(t)) {
          this._resolveAsyncIterable(e, t);
          return;
        }
        this._setPropValue(e, t);
      }
    }
    _freezeAsyncOldProps() {
      if (!this.oldAsyncProps && this.oldProps) {
        this.oldAsyncProps = Object.create(this.oldProps);
        for (const e in this.asyncProps) Object.defineProperty(this.oldAsyncProps, e, {
          enumerable: true,
          value: this.oldProps[e]
        });
      }
    }
    _didAsyncInputValueChange(e, t) {
      const i = this.asyncProps[e];
      return t === i.resolvedValue || t === i.lastValue ? false : (i.lastValue = t, true);
    }
    _setPropValue(e, t) {
      this._freezeAsyncOldProps();
      const i = this.asyncProps[e];
      i && (t = this._postProcessValue(i, t), i.resolvedValue = t, i.pendingLoadCount++, i.resolvedLoadCount = i.pendingLoadCount);
    }
    _setAsyncPropValue(e, t, i) {
      const s = this.asyncProps[e];
      s && i >= s.resolvedLoadCount && t !== void 0 && (this._freezeAsyncOldProps(), s.resolvedValue = t, s.resolvedLoadCount = i, this.onAsyncPropUpdated(e, t));
    }
    _watchPromise(e, t) {
      const i = this.asyncProps[e];
      if (i) {
        i.pendingLoadCount++;
        const s = i.pendingLoadCount;
        t.then((a) => {
          this.component && (a = this._postProcessValue(i, a), this._setAsyncPropValue(e, a, s), this._onResolve(e, a));
        }).catch((a) => {
          this._onError(e, a);
        });
      }
    }
    async _resolveAsyncIterable(e, t) {
      if (e !== "data") {
        this._setPropValue(e, t);
        return;
      }
      const i = this.asyncProps[e];
      if (!i) return;
      i.pendingLoadCount++;
      const s = i.pendingLoadCount;
      let a = [], l = 0;
      for await (const u of t) {
        if (!this.component) return;
        const { dataTransform: h } = this.component.props;
        h ? a = h(u, a) : a = a.concat(u), Object.defineProperty(a, "__diff", {
          enumerable: false,
          value: [
            {
              startRow: l,
              endRow: a.length
            }
          ]
        }), l = a.length, this._setAsyncPropValue(e, a, s);
      }
      this._onResolve(e, a);
    }
    _postProcessValue(e, t) {
      const i = e.type;
      return i && this.component && (i.release && i.release(e.resolvedValue, i, this.component), i.transform) ? i.transform(t, i, this.component) : t;
    }
    _createAsyncPropData(e, t) {
      if (!this.asyncProps[e]) {
        const s = this.component && this.component.props[Xi];
        this.asyncProps[e] = {
          type: s && s[e],
          lastValue: null,
          resolvedValue: t,
          pendingLoadCount: 0,
          resolvedLoadCount: 0
        };
      }
    }
  }
  class ak extends rk {
    constructor({ attributeManager: e, layer: t }) {
      super(t), this.attributeManager = e, this.needsRedraw = true, this.needsUpdate = true, this.subLayers = null, this.usesPickingColorCache = false;
    }
    get layer() {
      return this.component;
    }
    _fetch(e, t) {
      const i = this.layer, s = i == null ? void 0 : i.props.fetch;
      return s ? s(t, {
        propName: e,
        layer: i
      }) : super._fetch(e, t);
    }
    _onResolve(e, t) {
      const i = this.layer;
      if (i) {
        const s = i.props.onDataLoad;
        e === "data" && s && s(t, {
          propName: e,
          layer: i
        });
      }
    }
    _onError(e, t) {
      const i = this.layer;
      i && i.raiseError(t, `loading ${e} of ${this.layer}`);
    }
  }
  const ok = "layer.changeFlag", lk = "layer.initialize", ck = "layer.update", uk = "layer.finalize", fk = "layer.matched", ov = 2 ** 24 - 1, hk = Object.freeze([]), dk = Ro(({ oldViewport: n, viewport: e }) => n.equals(e));
  let Tn = new Uint8ClampedArray(0);
  const gk = {
    data: {
      type: "data",
      value: hk,
      async: true
    },
    dataComparator: {
      type: "function",
      value: null,
      optional: true
    },
    _dataDiff: {
      type: "function",
      value: (n) => n && n.__diff,
      optional: true
    },
    dataTransform: {
      type: "function",
      value: null,
      optional: true
    },
    onDataLoad: {
      type: "function",
      value: null,
      optional: true
    },
    onError: {
      type: "function",
      value: null,
      optional: true
    },
    fetch: {
      type: "function",
      value: (n, { propName: e, layer: t, loaders: i, loadOptions: s, signal: a }) => {
        const { resourceManager: l } = t.context;
        s = s || t.getLoadOptions(), i = i || t.props.loaders, a && (s = {
          ...s,
          fetch: {
            ...s == null ? void 0 : s.fetch,
            signal: a
          }
        });
        let u = l.contains(n);
        return !u && !s && (l.add({
          resourceId: n,
          data: pd(n, i),
          persistent: false
        }), u = true), u ? l.subscribe({
          resourceId: n,
          onChange: (h) => {
            var _a2;
            return (_a2 = t.internalState) == null ? void 0 : _a2.reloadAsyncProp(e, h);
          },
          consumerId: t.id,
          requestId: e
        }) : pd(n, i, s);
      }
    },
    updateTriggers: {},
    visible: true,
    pickable: false,
    opacity: {
      type: "number",
      min: 0,
      max: 1,
      value: 1
    },
    operation: "draw",
    onHover: {
      type: "function",
      value: null,
      optional: true
    },
    onClick: {
      type: "function",
      value: null,
      optional: true
    },
    onDragStart: {
      type: "function",
      value: null,
      optional: true
    },
    onDrag: {
      type: "function",
      value: null,
      optional: true
    },
    onDragEnd: {
      type: "function",
      value: null,
      optional: true
    },
    coordinateSystem: Oe.DEFAULT,
    coordinateOrigin: {
      type: "array",
      value: [
        0,
        0,
        0
      ],
      compare: true
    },
    modelMatrix: {
      type: "array",
      value: null,
      compare: true,
      optional: true
    },
    wrapLongitude: false,
    positionFormat: "XYZ",
    colorFormat: "RGBA",
    parameters: {
      type: "object",
      value: {},
      optional: true,
      compare: 2
    },
    loadOptions: {
      type: "object",
      value: null,
      optional: true,
      ignore: true
    },
    transitions: null,
    extensions: [],
    loaders: {
      type: "array",
      value: [],
      optional: true,
      ignore: true
    },
    getPolygonOffset: {
      type: "function",
      value: ({ layerIndex: n }) => [
        0,
        -n * 100
      ]
    },
    highlightedObjectIndex: null,
    autoHighlight: false,
    highlightColor: {
      type: "accessor",
      value: [
        0,
        0,
        128,
        128
      ]
    }
  };
  class Ds extends nu {
    constructor() {
      super(...arguments), this.internalState = null, this.lifecycle = Rr.NO_STATE, this.parent = null;
    }
    static get componentName() {
      return Object.prototype.hasOwnProperty.call(this, "layerName") ? this.layerName : "";
    }
    get root() {
      let e = this;
      for (; e.parent; ) e = e.parent;
      return e;
    }
    toString() {
      return `${this.constructor.layerName || this.constructor.name}({id: '${this.props.id}'})`;
    }
    project(e) {
      It(this.internalState);
      const t = this.internalState.viewport || this.context.viewport, i = D2(e, {
        viewport: t,
        modelMatrix: this.props.modelMatrix,
        coordinateOrigin: this.props.coordinateOrigin,
        coordinateSystem: this.props.coordinateSystem
      }), [s, a, l] = M2(i, t.pixelProjectionMatrix);
      return e.length === 2 ? [
        s,
        a
      ] : [
        s,
        a,
        l
      ];
    }
    unproject(e) {
      return It(this.internalState), (this.internalState.viewport || this.context.viewport).unproject(e);
    }
    projectPosition(e, t) {
      It(this.internalState);
      const i = this.internalState.viewport || this.context.viewport;
      return k2(e, {
        viewport: i,
        modelMatrix: this.props.modelMatrix,
        coordinateOrigin: this.props.coordinateOrigin,
        coordinateSystem: this.props.coordinateSystem,
        ...t
      });
    }
    get isComposite() {
      return false;
    }
    get isDrawable() {
      return true;
    }
    setState(e) {
      this.setChangeFlags({
        stateChanged: true
      }), Object.assign(this.state, e), this.setNeedsRedraw();
    }
    setNeedsRedraw() {
      this.internalState && (this.internalState.needsRedraw = true);
    }
    setNeedsUpdate() {
      this.internalState && (this.context.layerManager.setNeedsUpdate(String(this)), this.internalState.needsUpdate = true);
    }
    get isLoaded() {
      return this.internalState ? !this.internalState.isAsyncPropLoading() : false;
    }
    get wrapLongitude() {
      return this.props.wrapLongitude;
    }
    isPickable() {
      return this.props.pickable && this.props.visible;
    }
    getModels() {
      const e = this.state;
      return e && (e.models || e.model && [
        e.model
      ]) || [];
    }
    setShaderModuleProps(...e) {
      for (const t of this.getModels()) t.shaderInputs.setProps(...e);
    }
    getAttributeManager() {
      return this.internalState && this.internalState.attributeManager;
    }
    getCurrentLayer() {
      return this.internalState && this.internalState.layer;
    }
    getLoadOptions() {
      return this.props.loadOptions;
    }
    use64bitPositions() {
      const { coordinateSystem: e } = this.props;
      return e === Oe.DEFAULT || e === Oe.LNGLAT || e === Oe.CARTESIAN;
    }
    onHover(e, t) {
      return this.props.onHover && this.props.onHover(e, t) || false;
    }
    onClick(e, t) {
      return this.props.onClick && this.props.onClick(e, t) || false;
    }
    nullPickingColor() {
      return [
        0,
        0,
        0
      ];
    }
    encodePickingColor(e, t = []) {
      return t[0] = e + 1 & 255, t[1] = e + 1 >> 8 & 255, t[2] = e + 1 >> 8 >> 8 & 255, t;
    }
    decodePickingColor(e) {
      It(e instanceof Uint8Array);
      const [t, i, s] = e;
      return t + i * 256 + s * 65536 - 1;
    }
    getNumInstances() {
      return Number.isFinite(this.props.numInstances) ? this.props.numInstances : this.state && this.state.numInstances !== void 0 ? this.state.numInstances : VD(this.props.data);
    }
    getStartIndices() {
      return this.props.startIndices ? this.props.startIndices : this.state && this.state.startIndices ? this.state.startIndices : null;
    }
    getBounds() {
      var _a2;
      return (_a2 = this.getAttributeManager()) == null ? void 0 : _a2.getBounds([
        "positions",
        "instancePositions"
      ]);
    }
    getShaders(e) {
      e = av(e, {
        disableWarnings: true,
        modules: this.context.defaultShaderModules
      });
      for (const t of this.props.extensions) e = av(e, t.getShaders.call(this, t));
      return e;
    }
    shouldUpdateState(e) {
      return e.changeFlags.propsOrDataChanged;
    }
    updateState(e) {
      const t = this.getAttributeManager(), { dataChanged: i } = e.changeFlags;
      if (i && t) if (Array.isArray(i)) for (const s of i) t.invalidateAll(s);
      else t.invalidateAll();
      if (t) {
        const { props: s } = e, a = this.internalState.hasPickingBuffer, l = Number.isInteger(s.highlightedObjectIndex) || s.pickable || s.extensions.some((u) => u.getNeedsPickingBuffer.call(this, u));
        if (a !== l) {
          this.internalState.hasPickingBuffer = l;
          const { pickingColors: u, instancePickingColors: h } = t.attributes, d = u || h;
          d && (l && d.constant && (d.constant = false, t.invalidate(d.id)), !d.value && !l && (d.constant = true, d.value = [
            0,
            0,
            0
          ]));
        }
      }
    }
    finalizeState(e) {
      for (const i of this.getModels()) i.destroy();
      const t = this.getAttributeManager();
      t && t.finalize(), this.context && this.context.resourceManager.unsubscribe({
        consumerId: this.id
      }), this.internalState && (this.internalState.uniformTransitions.clear(), this.internalState.finalize());
    }
    draw(e) {
      for (const t of this.getModels()) t.draw(e.renderPass);
    }
    getPickingInfo({ info: e, mode: t, sourceLayer: i }) {
      const { index: s } = e;
      return s >= 0 && Array.isArray(this.props.data) && (e.object = this.props.data[s]), e;
    }
    raiseError(e, t) {
      var _a2, _b3, _c2, _d2;
      t && (e = new Error(`${t}: ${e.message}`, {
        cause: e
      })), ((_b3 = (_a2 = this.props).onError) == null ? void 0 : _b3.call(_a2, e)) || ((_d2 = (_c2 = this.context) == null ? void 0 : _c2.onError) == null ? void 0 : _d2.call(_c2, e, this));
    }
    getNeedsRedraw(e = {
      clearRedrawFlags: false
    }) {
      return this._getNeedsRedraw(e);
    }
    needsUpdate() {
      return this.internalState ? this.internalState.needsUpdate || this.hasUniformTransition() || this.shouldUpdateState(this._getUpdateParams()) : false;
    }
    hasUniformTransition() {
      var _a2;
      return ((_a2 = this.internalState) == null ? void 0 : _a2.uniformTransitions.active) || false;
    }
    activateViewport(e) {
      if (!this.internalState) return;
      const t = this.internalState.viewport;
      this.internalState.viewport = e, (!t || !dk({
        oldViewport: t,
        viewport: e
      })) && (this.setChangeFlags({
        viewportChanged: true
      }), this.isComposite ? this.needsUpdate() && this.setNeedsUpdate() : this._update());
    }
    invalidateAttribute(e = "all") {
      const t = this.getAttributeManager();
      t && (e === "all" ? t.invalidateAll() : t.invalidate(e));
    }
    updateAttributes(e) {
      let t = false;
      for (const i in e) e[i].layoutChanged() && (t = true);
      for (const i of this.getModels()) this._setModelAttributes(i, e, t);
    }
    _updateAttributes() {
      const e = this.getAttributeManager();
      if (!e) return;
      const t = this.props, i = this.getNumInstances(), s = this.getStartIndices();
      e.update({
        data: t.data,
        numInstances: i,
        startIndices: s,
        props: t,
        transitions: t.transitions,
        buffers: t.data.attributes,
        context: this
      });
      const a = e.getChangedAttributes({
        clearChangedFlags: true
      });
      this.updateAttributes(a);
    }
    _updateAttributeTransition() {
      const e = this.getAttributeManager();
      e && e.updateTransition();
    }
    _updateUniformTransition() {
      const { uniformTransitions: e } = this.internalState;
      if (e.active) {
        const t = e.update(), i = Object.create(this.props);
        for (const s in t) Object.defineProperty(i, s, {
          value: t[s]
        });
        return i;
      }
      return this.props;
    }
    calculateInstancePickingColors(e, { numInstances: t }) {
      if (e.constant) return;
      const i = Math.floor(Tn.length / 4);
      if (this.internalState.usesPickingColorCache = true, i < t) {
        t > ov && Le.warn("Layer has too many data objects. Picking might not be able to distinguish all objects.")(), Tn = bo.allocate(Tn, t, {
          size: 4,
          copy: true,
          maxCount: Math.max(t, ov)
        });
        const s = Math.floor(Tn.length / 4), a = [
          0,
          0,
          0
        ];
        for (let l = i; l < s; l++) this.encodePickingColor(l, a), Tn[l * 4 + 0] = a[0], Tn[l * 4 + 1] = a[1], Tn[l * 4 + 2] = a[2], Tn[l * 4 + 3] = 0;
      }
      e.value = Tn.subarray(0, t * 4);
    }
    _setModelAttributes(e, t, i = false) {
      var _a2;
      if (!Object.keys(t).length) return;
      if (i) {
        const u = this.getAttributeManager();
        e.setBufferLayout(u.getBufferLayouts(e)), t = u.getAttributes();
      }
      const s = ((_a2 = e.userData) == null ? void 0 : _a2.excludeAttributes) || {}, a = {}, l = {};
      for (const u in t) {
        if (s[u]) continue;
        const h = t[u].getValue();
        for (const d in h) {
          const p = h[d];
          p instanceof Ke ? t[u].settings.isIndexed ? e.setIndexBuffer(p) : a[d] = p : p && (l[d] = p);
        }
      }
      e.setAttributes(a), e.setConstantAttributes(l);
    }
    disablePickingIndex(e) {
      const t = this.props.data;
      if (!("attributes" in t)) {
        this._disablePickingIndex(e);
        return;
      }
      const { pickingColors: i, instancePickingColors: s } = this.getAttributeManager().attributes, a = i || s, l = a && t.attributes && t.attributes[a.id];
      if (l && l.value) {
        const u = l.value, h = this.encodePickingColor(e);
        for (let d = 0; d < t.length; d++) {
          const p = a.getVertexOffset(d);
          u[p] === h[0] && u[p + 1] === h[1] && u[p + 2] === h[2] && this._disablePickingIndex(d);
        }
      } else this._disablePickingIndex(e);
    }
    _disablePickingIndex(e) {
      const { pickingColors: t, instancePickingColors: i } = this.getAttributeManager().attributes, s = t || i;
      if (!s) return;
      const a = s.getVertexOffset(e), l = s.getVertexOffset(e + 1);
      s.buffer.write(new Uint8Array(l - a), a);
    }
    restorePickingColors() {
      const { pickingColors: e, instancePickingColors: t } = this.getAttributeManager().attributes, i = e || t;
      i && (this.internalState.usesPickingColorCache && i.value.buffer !== Tn.buffer && (i.value = Tn.subarray(0, i.value.length)), i.updateSubBuffer({
        startOffset: 0
      }));
    }
    _initialize() {
      It(!this.internalState), It(Number.isFinite(this.props.coordinateSystem)), Ot(lk, this);
      const e = this._getAttributeManager();
      e && e.addInstanced({
        instancePickingColors: {
          type: "uint8",
          size: 4,
          noAlloc: true,
          update: this.calculateInstancePickingColors
        }
      }), this.internalState = new ak({
        attributeManager: e,
        layer: this
      }), this._clearChangeFlags(), this.state = {}, Object.defineProperty(this.state, "attributeManager", {
        get: () => (Le.deprecated("layer.state.attributeManager", "layer.getAttributeManager()")(), e)
      }), this.internalState.uniformTransitions = new ID(this.context.timeline), this.internalState.onAsyncPropUpdated = this._onAsyncPropUpdated.bind(this), this.internalState.setAsyncProps(this.props), this.initializeState(this.context);
      for (const t of this.props.extensions) t.initializeState.call(this, this.context, t);
      this.setChangeFlags({
        dataChanged: "init",
        propsChanged: "init",
        viewportChanged: true,
        extensionsChanged: true
      }), this._update();
    }
    _transferState(e) {
      Ot(fk, this, this === e);
      const { state: t, internalState: i } = e;
      this !== e && (this.internalState = i, this.state = t, this.internalState.setAsyncProps(this.props), this._diffProps(this.props, this.internalState.getOldProps()));
    }
    _update() {
      const e = this.needsUpdate();
      if (Ot(ck, this, e), !e) return;
      const t = this.props, i = this.context, s = this.internalState, a = i.viewport, l = this._updateUniformTransition();
      s.propsInTransition = l, i.viewport = s.viewport || a, this.props = l;
      try {
        const u = this._getUpdateParams(), h = this.getModels();
        if (i.device) this.updateState(u);
        else try {
          this.updateState(u);
        } catch {
        }
        for (const p of this.props.extensions) p.updateState.call(this, u, p);
        this.setNeedsRedraw(), this._updateAttributes();
        const d = this.getModels()[0] !== h[0];
        this._postUpdate(u, d);
      } finally {
        i.viewport = a, this.props = t, this._clearChangeFlags(), s.needsUpdate = false, s.resetOldProps();
      }
    }
    _finalize() {
      Ot(uk, this), this.finalizeState(this.context);
      for (const e of this.props.extensions) e.finalizeState.call(this, this.context, e);
    }
    _drawLayer({ renderPass: e, shaderModuleProps: t = null, uniforms: i = {}, parameters: s = {} }) {
      this._updateAttributeTransition();
      const a = this.props, l = this.context;
      this.props = this.internalState.propsInTransition || a;
      try {
        t && this.setShaderModuleProps(t);
        const { getPolygonOffset: u } = this.props, h = u && u(i) || [
          0,
          0
        ];
        l.device instanceof Dr && l.device.setParametersWebGL({
          polygonOffset: h
        });
        for (const d of this.getModels()) d.device.type === "webgpu" ? d.setParameters({
          ...d.parameters,
          ...s
        }) : d.setParameters(s);
        if (l.device instanceof Dr) l.device.withParametersWebGL(s, () => {
          const d = {
            renderPass: e,
            shaderModuleProps: t,
            uniforms: i,
            parameters: s,
            context: l
          };
          for (const p of this.props.extensions) p.draw.call(this, d, p);
          this.draw(d);
        });
        else {
          const d = {
            renderPass: e,
            shaderModuleProps: t,
            uniforms: i,
            parameters: s,
            context: l
          };
          for (const p of this.props.extensions) p.draw.call(this, d, p);
          this.draw(d);
        }
      } finally {
        this.props = a;
      }
    }
    getChangeFlags() {
      var _a2;
      return (_a2 = this.internalState) == null ? void 0 : _a2.changeFlags;
    }
    setChangeFlags(e) {
      if (!this.internalState) return;
      const { changeFlags: t } = this.internalState;
      for (const s in e) if (e[s]) {
        let a = false;
        switch (s) {
          case "dataChanged":
            const l = e[s], u = t[s];
            l && Array.isArray(u) && (t.dataChanged = Array.isArray(l) ? u.concat(l) : l, a = true);
          default:
            t[s] || (t[s] = e[s], a = true);
        }
        a && Ot(ok, this, s, e);
      }
      const i = !!(t.dataChanged || t.updateTriggersChanged || t.propsChanged || t.extensionsChanged);
      t.propsOrDataChanged = i, t.somethingChanged = i || t.viewportChanged || t.stateChanged;
    }
    _clearChangeFlags() {
      this.internalState.changeFlags = {
        dataChanged: false,
        propsChanged: false,
        updateTriggersChanged: false,
        viewportChanged: false,
        stateChanged: false,
        extensionsChanged: false,
        propsOrDataChanged: false,
        somethingChanged: false
      };
    }
    _diffProps(e, t) {
      var _a2;
      const i = PD(e, t);
      if (i.updateTriggersChanged) for (const s in i.updateTriggersChanged) i.updateTriggersChanged[s] && this.invalidateAttribute(s);
      if (i.transitionsChanged) for (const s in i.transitionsChanged) this.internalState.uniformTransitions.add(s, t[s], e[s], (_a2 = e.transitions) == null ? void 0 : _a2[s]);
      return this.setChangeFlags(i);
    }
    validateProps() {
      ND(this.props);
    }
    updateAutoHighlight(e) {
      this.props.autoHighlight && !Number.isInteger(this.props.highlightedObjectIndex) && this._updateAutoHighlight(e);
    }
    _updateAutoHighlight(e) {
      const t = {
        highlightedObjectColor: e.picked ? e.color : null
      }, { highlightColor: i } = this.props;
      e.picked && typeof i == "function" && (t.highlightColor = i(e)), this.setShaderModuleProps({
        picking: t
      }), this.setNeedsRedraw();
    }
    _getAttributeManager() {
      const e = this.context;
      return new tu(e.device, {
        id: this.props.id,
        stats: e.stats,
        timeline: e.timeline
      });
    }
    _postUpdate(e, t) {
      const { props: i, oldProps: s } = e, a = this.state.model;
      (a == null ? void 0 : a.isInstanced) && a.setInstanceCount(this.getNumInstances());
      const { autoHighlight: l, highlightedObjectIndex: u, highlightColor: h } = i;
      if (t || s.autoHighlight !== l || s.highlightedObjectIndex !== u || s.highlightColor !== h) {
        const d = {};
        Array.isArray(h) && (d.highlightColor = h), (t || s.autoHighlight !== l || u !== s.highlightedObjectIndex) && (d.highlightedObjectColor = Number.isFinite(u) && u >= 0 ? this.encodePickingColor(u) : null), this.setShaderModuleProps({
          picking: d
        });
      }
    }
    _getUpdateParams() {
      return {
        props: this.props,
        oldProps: this.internalState.getOldProps(),
        context: this.context,
        changeFlags: this.internalState.changeFlags
      };
    }
    _getNeedsRedraw(e) {
      if (!this.internalState) return false;
      let t = false;
      t = t || this.internalState.needsRedraw && this.id;
      const i = this.getAttributeManager(), s = i ? i.getNeedsRedraw(e) : false;
      if (t = t || s, t) for (const a of this.props.extensions) a.onNeedsRedraw.call(this, a);
      return this.internalState.needsRedraw = this.internalState.needsRedraw && !e.clearRedrawFlags, t;
    }
    _onAsyncPropUpdated() {
      this._diffProps(this.props, this.internalState.getOldProps()), this.setNeedsUpdate();
    }
  }
  Ds.defaultProps = gk;
  Ds.layerName = "Layer";
  const pk = "compositeLayer.renderLayers";
  class zg extends Ds {
    get isComposite() {
      return true;
    }
    get isDrawable() {
      return false;
    }
    get isLoaded() {
      return super.isLoaded && this.getSubLayers().every((e) => e.isLoaded);
    }
    getSubLayers() {
      return this.internalState && this.internalState.subLayers || [];
    }
    initializeState(e) {
    }
    setState(e) {
      super.setState(e), this.setNeedsUpdate();
    }
    getPickingInfo({ info: e }) {
      const { object: t } = e;
      return t && t.__source && t.__source.parent && t.__source.parent.id === this.id && (e.object = t.__source.object, e.index = t.__source.index), e;
    }
    filterSubLayer(e) {
      return true;
    }
    shouldRenderSubLayer(e, t) {
      return t && t.length;
    }
    getSubLayerClass(e, t) {
      const { _subLayerProps: i } = this.props;
      return i && i[e] && i[e].type || t;
    }
    getSubLayerRow(e, t, i) {
      return e.__source = {
        parent: this,
        object: t,
        index: i
      }, e;
    }
    getSubLayerAccessor(e) {
      if (typeof e == "function") {
        const t = {
          index: -1,
          data: this.props.data,
          target: []
        };
        return (i, s) => i && i.__source ? (t.index = i.__source.index, e(i.__source.object, t)) : e(i, s);
      }
      return e;
    }
    getSubLayerProps(e = {}) {
      var _a2;
      const { opacity: t, pickable: i, visible: s, parameters: a, getPolygonOffset: l, highlightedObjectIndex: u, autoHighlight: h, highlightColor: d, coordinateSystem: p, coordinateOrigin: _, wrapLongitude: y, positionFormat: v, modelMatrix: S, extensions: E, fetch: M, operation: F, _subLayerProps: H } = this.props, O = {
        id: "",
        updateTriggers: {},
        opacity: t,
        pickable: i,
        visible: s,
        parameters: a,
        getPolygonOffset: l,
        highlightedObjectIndex: u,
        autoHighlight: h,
        highlightColor: d,
        coordinateSystem: p,
        coordinateOrigin: _,
        wrapLongitude: y,
        positionFormat: v,
        modelMatrix: S,
        extensions: E,
        fetch: M,
        operation: F
      }, U = H && e.id && H[e.id], B = U && U.updateTriggers, Z = e.id || "sublayer";
      if (U) {
        const re = this.props[Xi], le = e.type ? e.type._propTypes : {};
        for (const ee in U) {
          const fe = le[ee] || re[ee];
          fe && fe.type === "accessor" && (U[ee] = this.getSubLayerAccessor(U[ee]));
        }
      }
      Object.assign(O, e, U), O.id = `${this.props.id}-${Z}`, O.updateTriggers = {
        all: (_a2 = this.props.updateTriggers) == null ? void 0 : _a2.all,
        ...e.updateTriggers,
        ...B
      };
      for (const re of E) {
        const le = re.getSubLayerProps.call(this, re);
        le && Object.assign(O, le, {
          updateTriggers: Object.assign(O.updateTriggers, le.updateTriggers)
        });
      }
      return O;
    }
    _updateAutoHighlight(e) {
      for (const t of this.getSubLayers()) t.updateAutoHighlight(e);
    }
    _getAttributeManager() {
      return null;
    }
    _postUpdate(e, t) {
      let i = this.internalState.subLayers;
      const s = !i || this.needsUpdate();
      if (s) {
        const a = this.renderLayers();
        i = Ng(a, Boolean), this.internalState.subLayers = i;
      }
      Ot(pk, this, s, i);
      for (const a of i) a.parent = this;
    }
  }
  zg.layerName = "CompositeLayer";
  const mk = typeof window < "u" ? G.useLayoutEffect : G.useEffect;
  function Uc(n, e) {
    for (; n; ) {
      if (n === e) return true;
      n = Object.getPrototypeOf(n);
    }
    return false;
  }
  const _k = {
    position: "absolute",
    zIndex: -1
  };
  function bT(n, e) {
    if (typeof n == "function") return n(e);
    if (Array.isArray(n)) return n.map((t) => bT(t, e));
    if (iu(n)) {
      if (yk(n)) return e.style = _k, G.cloneElement(n, e);
      if (bk(n)) return G.cloneElement(n, e);
    }
    return n;
  }
  function iu(n) {
    return n && typeof n == "object" && "type" in n || false;
  }
  function yk(n) {
    var _a2;
    return (_a2 = n.props) == null ? void 0 : _a2.mapStyle;
  }
  function bk(n) {
    const e = n.type;
    return e && e.deckGLViewProps;
  }
  function Xd(n) {
    if (typeof n == "function") return G.createElement(Yr, {}, n);
    if (Array.isArray(n)) return n.map(Xd);
    if (iu(n)) {
      if (n.type === G.Fragment) return Xd(n.props.children);
      if (Uc(n.type, Yr)) return n;
    }
    return n;
  }
  function vk({ children: n, layers: e = [], views: t = null }) {
    const i = [], s = [], a = {};
    return G.Children.forEach(Xd(n), (l) => {
      if (iu(l)) {
        const u = l.type;
        if (Uc(u, Ds)) {
          const h = Tk(u, l.props);
          s.push(h);
        } else i.push(l);
        if (Uc(u, Yr) && u !== Yr && l.props.id) {
          const h = new u(l.props);
          a[h.id] = h;
        }
      } else l && i.push(l);
    }), Object.keys(a).length > 0 && (Array.isArray(t) ? t.forEach((l) => {
      a[l.id] = l;
    }) : t && (a[t.id] = t), t = Object.values(a)), e = s.length > 0 ? [
      ...s,
      ...e
    ] : e, {
      layers: e,
      children: i,
      views: t
    };
  }
  function Tk(n, e) {
    const t = {}, i = n.defaultProps || {};
    for (const s in e) i[s] !== e[s] && (t[s] = e[s]);
    return new n(t);
  }
  const xk = G.createContext();
  function Sk({ children: n, deck: e, ContextProvider: t = xk.Provider }) {
    const { viewManager: i } = e || {};
    if (!i || !i.views.length) return [];
    const s = {}, a = i.views[0].id;
    for (const l of n) {
      let u = a, h = l;
      iu(l) && Uc(l.type, Yr) && (u = l.props.id || a, h = l.props.children);
      const d = i.getViewport(u), p = i.getViewState(u);
      if (d) {
        p.padding = d.padding;
        const { x: _, y, width: v, height: S } = d;
        h = bT(h, {
          x: _,
          y,
          width: v,
          height: S,
          viewport: d,
          viewState: p
        }), s[u] || (s[u] = {
          viewport: d,
          children: []
        }), s[u].children.push(h);
      }
    }
    return Object.keys(s).map((l) => {
      const { viewport: u, children: h } = s[l], { x: d, y: p, width: _, height: y } = u, v = {
        position: "absolute",
        left: d,
        top: p,
        width: _,
        height: y
      }, S = `view-${l}`, E = G.createElement("div", {
        key: S,
        id: S,
        style: v
      }, ...h), M = {
        deck: e,
        viewport: u,
        container: e.canvas.offsetParent,
        eventManager: e.eventManager,
        onViewStateChange: (H) => {
          H.viewId = l, e._onViewStateChange(H);
        },
        widgets: []
      }, F = `view-${l}-context`;
      return G.createElement(t, {
        key: F,
        value: M
      }, E);
    });
  }
  const Ak = {
    mixBlendMode: null
  };
  function wk({ width: n, height: e, style: t }) {
    const i = {
      position: "absolute",
      zIndex: 0,
      left: 0,
      top: 0,
      width: n,
      height: e
    }, s = {
      left: 0,
      top: 0
    };
    if (t) for (const a in t) a in Ak ? s[a] = t[a] : i[a] = t[a];
    return {
      containerStyle: i,
      canvasStyle: s
    };
  }
  function Ek(n) {
    return {
      get deck() {
        return n.deck;
      },
      pickObject: (e) => n.deck.pickObject(e),
      pickMultipleObjects: (e) => n.deck.pickMultipleObjects(e),
      pickObjects: (e) => n.deck.pickObjects(e)
    };
  }
  function vT(n) {
    n.redrawReason && (n.deck._drawLayers(n.redrawReason), n.redrawReason = null);
  }
  function Rk(n, e, t) {
    var _a2, _b3, _c2;
    const i = new e({
      ...t,
      _customRender: ((_c2 = (_b3 = (_a2 = t.deviceProps) == null ? void 0 : _a2.adapters) == null ? void 0 : _b3[0]) == null ? void 0 : _c2.type) === "webgpu" ? void 0 : (s) => {
        n.redrawReason = s;
        const a = i.getViewports();
        n.lastRenderedViewports !== a ? n.forceUpdate() : vT(n);
      }
    });
    return i;
  }
  function Ck(n, e) {
    const [t, i] = G.useState(0), a = G.useRef({
      control: null,
      version: t,
      forceUpdate: () => i((B) => B + 1)
    }).current, l = G.useRef(null), u = G.useRef(null), h = G.useMemo(() => vk(n), [
      n.layers,
      n.views,
      n.children
    ]);
    let d = true;
    const p = (B) => {
      var _a2;
      return d && n.viewState ? (a.viewStateUpdateRequested = B, null) : (a.viewStateUpdateRequested = null, (_a2 = n.onViewStateChange) == null ? void 0 : _a2.call(n, B));
    }, _ = (B) => {
      var _a2;
      d ? a.interactionStateUpdateRequested = B : (a.interactionStateUpdateRequested = null, (_a2 = n.onInteractionStateChange) == null ? void 0 : _a2.call(n, B));
    }, y = G.useMemo(() => {
      const B = {
        widgets: [],
        ...n,
        style: null,
        width: "100%",
        height: "100%",
        parent: l.current,
        canvas: u.current,
        layers: h.layers,
        views: h.views,
        onViewStateChange: p,
        onInteractionStateChange: _
      };
      return delete B._customRender, a.deck && a.deck.setProps(B), B;
    }, [
      n
    ]);
    G.useEffect(() => {
      const B = n.Deck || Lg;
      return a.deck = Rk(a, B, {
        ...y,
        parent: l.current,
        canvas: u.current
      }), () => {
        var _a2;
        return (_a2 = a.deck) == null ? void 0 : _a2.finalize();
      };
    }, []), mk(() => {
      vT(a);
      const { viewStateUpdateRequested: B, interactionStateUpdateRequested: Z } = a;
      B && p(B), Z && _(Z);
    }), G.useImperativeHandle(e, () => Ek(a), []);
    const v = a.deck && a.deck.isInitialized ? a.deck.getViewports() : void 0, { ContextProvider: S, width: E = "100%", height: M = "100%", id: F, style: H } = n, { containerStyle: O, canvasStyle: U } = G.useMemo(() => wk({
      width: E,
      height: M,
      style: H
    }), [
      E,
      M,
      H
    ]);
    if (!a.viewStateUpdateRequested && a.lastRenderedViewports === v || a.version !== t) {
      a.lastRenderedViewports = v, a.version = t;
      const B = Sk({
        children: h.children,
        deck: a.deck,
        ContextProvider: S
      }), Z = G.createElement("canvas", {
        key: "canvas",
        id: F || "deckgl-overlay",
        ref: u,
        style: U
      });
      a.control = G.createElement("div", {
        id: `${F || "deckgl"}-wrapper`,
        ref: l,
        style: O
      }, [
        Z,
        B
      ]);
    }
    return d = false, a.control;
  }
  const Mk = G.forwardRef(Ck), lv = `uniform scatterplotUniforms {
  float radiusScale;
  float radiusMinPixels;
  float radiusMaxPixels;
  float lineWidthScale;
  float lineWidthMinPixels;
  float lineWidthMaxPixels;
  float stroked;
  float filled;
  bool antialiasing;
  bool billboard;
  highp int radiusUnits;
  highp int lineWidthUnits;
} scatterplot;
`, Ok = {
    name: "scatterplot",
    vs: lv,
    fs: lv,
    source: "",
    uniformTypes: {
      radiusScale: "f32",
      radiusMinPixels: "f32",
      radiusMaxPixels: "f32",
      lineWidthScale: "f32",
      lineWidthMinPixels: "f32",
      lineWidthMaxPixels: "f32",
      stroked: "f32",
      filled: "f32",
      antialiasing: "f32",
      billboard: "f32",
      radiusUnits: "i32",
      lineWidthUnits: "i32"
    }
  }, Ik = `#version 300 es
#define SHADER_NAME scatterplot-layer-vertex-shader
in vec3 positions;
in vec3 instancePositions;
in vec3 instancePositions64Low;
in float instanceRadius;
in float instanceLineWidths;
in vec4 instanceFillColors;
in vec4 instanceLineColors;
in vec3 instancePickingColors;
out vec4 vFillColor;
out vec4 vLineColor;
out vec2 unitPosition;
out float innerUnitRadius;
out float outerRadiusPixels;
void main(void) {
geometry.worldPosition = instancePositions;
outerRadiusPixels = clamp(
project_size_to_pixel(scatterplot.radiusScale * instanceRadius, scatterplot.radiusUnits),
scatterplot.radiusMinPixels, scatterplot.radiusMaxPixels
);
float lineWidthPixels = clamp(
project_size_to_pixel(scatterplot.lineWidthScale * instanceLineWidths, scatterplot.lineWidthUnits),
scatterplot.lineWidthMinPixels, scatterplot.lineWidthMaxPixels
);
outerRadiusPixels += scatterplot.stroked * lineWidthPixels / 2.0;
float edgePadding = scatterplot.antialiasing ? (outerRadiusPixels + SMOOTH_EDGE_RADIUS) / outerRadiusPixels : 1.0;
unitPosition = edgePadding * positions.xy;
geometry.uv = unitPosition;
geometry.pickingColor = instancePickingColors;
innerUnitRadius = 1.0 - scatterplot.stroked * lineWidthPixels / outerRadiusPixels;
if (scatterplot.billboard) {
gl_Position = project_position_to_clipspace(instancePositions, instancePositions64Low, vec3(0.0), geometry.position);
DECKGL_FILTER_GL_POSITION(gl_Position, geometry);
vec3 offset = edgePadding * positions * outerRadiusPixels;
DECKGL_FILTER_SIZE(offset, geometry);
gl_Position.xy += project_pixel_size_to_clipspace(offset.xy);
} else {
vec3 offset = edgePadding * positions * project_pixel_size(outerRadiusPixels);
DECKGL_FILTER_SIZE(offset, geometry);
gl_Position = project_position_to_clipspace(instancePositions, instancePositions64Low, offset, geometry.position);
DECKGL_FILTER_GL_POSITION(gl_Position, geometry);
}
vFillColor = vec4(instanceFillColors.rgb, instanceFillColors.a * layer.opacity);
DECKGL_FILTER_COLOR(vFillColor, geometry);
vLineColor = vec4(instanceLineColors.rgb, instanceLineColors.a * layer.opacity);
DECKGL_FILTER_COLOR(vLineColor, geometry);
}
`, Nk = `#version 300 es
#define SHADER_NAME scatterplot-layer-fragment-shader
precision highp float;
in vec4 vFillColor;
in vec4 vLineColor;
in vec2 unitPosition;
in float innerUnitRadius;
in float outerRadiusPixels;
out vec4 fragColor;
void main(void) {
geometry.uv = unitPosition;
float distToCenter = length(unitPosition) * outerRadiusPixels;
float inCircle = scatterplot.antialiasing ?
smoothedge(distToCenter, outerRadiusPixels) :
step(distToCenter, outerRadiusPixels);
if (inCircle == 0.0) {
discard;
}
if (scatterplot.stroked > 0.5) {
float isLine = scatterplot.antialiasing ?
smoothedge(innerUnitRadius * outerRadiusPixels, distToCenter) :
step(innerUnitRadius * outerRadiusPixels, distToCenter);
if (scatterplot.filled > 0.5) {
fragColor = mix(vFillColor, vLineColor, isLine);
} else {
if (isLine == 0.0) {
discard;
}
fragColor = vec4(vLineColor.rgb, vLineColor.a * isLine);
}
} else if (scatterplot.filled < 0.5) {
discard;
} else {
fragColor = vFillColor;
}
fragColor.a *= inCircle;
DECKGL_FILTER_COLOR(fragColor, geometry);
}
`, Pk = `// TODO(ibgreen): Hack for Layer uniforms (move to new "color" module?)

struct LayerUniforms {
  opacity: f32,
};

var<private> layer: LayerUniforms = LayerUniforms(1.0);
// @group(0) @binding(1) var<uniform> layer: LayerUniforms;

// Main shaders

struct ScatterplotUniforms {
  radiusScale: f32,
  radiusMinPixels: f32,
  radiusMaxPixels: f32,
  lineWidthScale: f32,
  lineWidthMinPixels: f32,
  lineWidthMaxPixels: f32,
  stroked: f32,
  filled: i32,
  antialiasing: i32,
  billboard: i32,
  radiusUnits: i32,
  lineWidthUnits: i32,
};

struct ConstantAttributeUniforms {
 instancePositions: vec3<f32>,
 instancePositions64Low: vec3<f32>,
 instanceRadius: f32,
 instanceLineWidths: f32,
 instanceFillColors: vec4<f32>,
 instanceLineColors: vec4<f32>,
 instancePickingColors: vec3<f32>,

 instancePositionsConstant: i32,
 instancePositions64LowConstant: i32,
 instanceRadiusConstant: i32,
 instanceLineWidthsConstant: i32,
 instanceFillColorsConstant: i32,
 instanceLineColorsConstant: i32,
 instancePickingColorsConstant: i32
};

@group(0) @binding(2) var<uniform> scatterplot: ScatterplotUniforms;

struct ConstantAttributes {
  instancePositions: vec3<f32>,
  instancePositions64Low: vec3<f32>,
  instanceRadius: f32,
  instanceLineWidths: f32,
  instanceFillColors: vec4<f32>,
  instanceLineColors: vec4<f32>,
  instancePickingColors: vec3<f32>
};

const constants = ConstantAttributes(
  vec3<f32>(0.0),
  vec3<f32>(0.0),
  0.0,
  0.0,
  vec4<f32>(0.0, 0.0, 0.0, 1.0),
  vec4<f32>(0.0, 0.0, 0.0, 1.0),
  vec3<f32>(0.0)
);

struct Attributes {
  @builtin(instance_index) instanceIndex : u32,
  @builtin(vertex_index) vertexIndex : u32,
  @location(0) positions: vec3<f32>,
  @location(1) instancePositions: vec3<f32>,
  @location(2) instancePositions64Low: vec3<f32>,
  @location(3) instanceRadius: f32,
  @location(4) instanceLineWidths: f32,
  @location(5) instanceFillColors: vec4<f32>,
  @location(6) instanceLineColors: vec4<f32>,
  @location(7) instancePickingColors: vec3<f32>
};

struct Varyings {
  @builtin(position) position: vec4<f32>,
  @location(0) vFillColor: vec4<f32>,
  @location(1) vLineColor: vec4<f32>,
  @location(2) unitPosition: vec2<f32>,
  @location(3) innerUnitRadius: f32,
  @location(4) outerRadiusPixels: f32,
};

@vertex
fn vertexMain(attributes: Attributes) -> Varyings {
  var varyings: Varyings;

  // Draw an inline geometry constant array clip space triangle to verify that rendering works.
  // var positions = array<vec2<f32>, 3>(vec2(0.0, 0.5), vec2(-0.5, -0.5), vec2(0.5, -0.5));
  // if (attributes.instanceIndex == 0) {
  //   varyings.position = vec4<f32>(positions[attributes.vertexIndex], 0.0, 1.0);
  //   return varyings;
  // }

  // var geometry: Geometry;
  // geometry.worldPosition = instancePositions;

  // Multiply out radius and clamp to limits
  varyings.outerRadiusPixels = clamp(
    project_unit_size_to_pixel(scatterplot.radiusScale * attributes.instanceRadius, scatterplot.radiusUnits),
    scatterplot.radiusMinPixels, scatterplot.radiusMaxPixels
  );

  // Multiply out line width and clamp to limits
  let lineWidthPixels = clamp(
    project_unit_size_to_pixel(scatterplot.lineWidthScale * attributes.instanceLineWidths, scatterplot.lineWidthUnits),
    scatterplot.lineWidthMinPixels, scatterplot.lineWidthMaxPixels
  );

  // outer radius needs to offset by half stroke width
  varyings.outerRadiusPixels += scatterplot.stroked * lineWidthPixels / 2.0;
  // Expand geometry to accommodate edge smoothing
  let edgePadding = select(
    (varyings.outerRadiusPixels + SMOOTH_EDGE_RADIUS) / varyings.outerRadiusPixels,
    1.0,
    scatterplot.antialiasing != 0
  );

  // position on the containing square in [-1, 1] space
  varyings.unitPosition = edgePadding * attributes.positions.xy;
  geometry.uv = varyings.unitPosition;
  geometry.pickingColor = attributes.instancePickingColors;

  varyings.innerUnitRadius = 1.0 - scatterplot.stroked * lineWidthPixels / varyings.outerRadiusPixels;

  if (scatterplot.billboard != 0) {
    varyings.position = project_position_to_clipspace(attributes.instancePositions, attributes.instancePositions64Low, vec3<f32>(0.0)); // TODO , geometry.position);
    // DECKGL_FILTER_GL_POSITION(varyings.position, geometry);
    let offset = attributes.positions; // * edgePadding * varyings.outerRadiusPixels;
    // DECKGL_FILTER_SIZE(offset, geometry);
    let clipPixels = project_pixel_size_to_clipspace(offset.xy);
    varyings.position.x = clipPixels.x;
    varyings.position.y = clipPixels.y;
  } else {
    let offset = edgePadding * attributes.positions * project_pixel_size_float(varyings.outerRadiusPixels);
    // DECKGL_FILTER_SIZE(offset, geometry);
    varyings.position = project_position_to_clipspace(attributes.instancePositions, attributes.instancePositions64Low, offset); // TODO , geometry.position);
    // DECKGL_FILTER_GL_POSITION(varyings.position, geometry);
  }

  // Apply opacity to instance color, or return instance picking color
  varyings.vFillColor = vec4<f32>(attributes.instanceFillColors.rgb, attributes.instanceFillColors.a * layer.opacity);
  // DECKGL_FILTER_COLOR(varyings.vFillColor, geometry);
  varyings.vLineColor = vec4<f32>(attributes.instanceLineColors.rgb, attributes.instanceLineColors.a * layer.opacity);
  // DECKGL_FILTER_COLOR(varyings.vLineColor, geometry);

  return varyings;
}

@fragment
fn fragmentMain(varyings: Varyings) -> @location(0) vec4<f32> {
  // var geometry: Geometry;
  // geometry.uv = unitPosition;

  let distToCenter = length(varyings.unitPosition) * varyings.outerRadiusPixels;
  let inCircle = select(
    smoothedge(distToCenter, varyings.outerRadiusPixels),
    step(distToCenter, varyings.outerRadiusPixels),
    scatterplot.antialiasing != 0
  );

  if (inCircle == 0.0) {
    // discard;
  }

  var fragColor: vec4<f32>;

  if (scatterplot.stroked != 0) {
    let isLine = select(
      smoothedge(varyings.innerUnitRadius * varyings.outerRadiusPixels, distToCenter),
      step(varyings.innerUnitRadius * varyings.outerRadiusPixels, distToCenter),
      scatterplot.antialiasing != 0
    );

    if (scatterplot.filled != 0) {
      fragColor = mix(varyings.vFillColor, varyings.vLineColor, isLine);
    } else {
      if (isLine == 0.0) {
        // discard;
      }
      fragColor = vec4<f32>(varyings.vLineColor.rgb, varyings.vLineColor.a * isLine);
    }
  } else if (scatterplot.filled == 0) {
    // discard;
  } else {
    fragColor = varyings.vFillColor;
  }

  fragColor.a *= inCircle;
  // DECKGL_FILTER_COLOR(fragColor, geometry);

  return fragColor;
  // return vec4<f32>(0, 0, 1, 1);
}
`, cv = [
    0,
    0,
    0,
    255
  ], Dk = {
    radiusUnits: "meters",
    radiusScale: {
      type: "number",
      min: 0,
      value: 1
    },
    radiusMinPixels: {
      type: "number",
      min: 0,
      value: 0
    },
    radiusMaxPixels: {
      type: "number",
      min: 0,
      value: Number.MAX_SAFE_INTEGER
    },
    lineWidthUnits: "meters",
    lineWidthScale: {
      type: "number",
      min: 0,
      value: 1
    },
    lineWidthMinPixels: {
      type: "number",
      min: 0,
      value: 0
    },
    lineWidthMaxPixels: {
      type: "number",
      min: 0,
      value: Number.MAX_SAFE_INTEGER
    },
    stroked: false,
    filled: true,
    billboard: false,
    antialiasing: true,
    getPosition: {
      type: "accessor",
      value: (n) => n.position
    },
    getRadius: {
      type: "accessor",
      value: 1
    },
    getFillColor: {
      type: "accessor",
      value: cv
    },
    getLineColor: {
      type: "accessor",
      value: cv
    },
    getLineWidth: {
      type: "accessor",
      value: 1
    },
    strokeWidth: {
      deprecatedFor: "getLineWidth"
    },
    outline: {
      deprecatedFor: "stroked"
    },
    getColor: {
      deprecatedFor: [
        "getFillColor",
        "getLineColor"
      ]
    }
  };
  class Hg extends Ds {
    getShaders() {
      return super.getShaders({
        vs: Ik,
        fs: Nk,
        source: Pk,
        modules: [
          Co,
          I2,
          Ok
        ]
      });
    }
    initializeState() {
      this.getAttributeManager().addInstanced({
        instancePositions: {
          size: 3,
          type: "float64",
          fp64: this.use64bitPositions(),
          transition: true,
          accessor: "getPosition"
        },
        instanceRadius: {
          size: 1,
          transition: true,
          accessor: "getRadius",
          defaultValue: 1
        },
        instanceFillColors: {
          size: this.props.colorFormat.length,
          transition: true,
          type: "unorm8",
          accessor: "getFillColor",
          defaultValue: [
            0,
            0,
            0,
            255
          ]
        },
        instanceLineColors: {
          size: this.props.colorFormat.length,
          transition: true,
          type: "unorm8",
          accessor: "getLineColor",
          defaultValue: [
            0,
            0,
            0,
            255
          ]
        },
        instanceLineWidths: {
          size: 1,
          transition: true,
          accessor: "getLineWidth",
          defaultValue: 1
        }
      });
    }
    updateState(e) {
      var _a2;
      super.updateState(e), e.changeFlags.extensionsChanged && ((_a2 = this.state.model) == null ? void 0 : _a2.destroy(), this.state.model = this._getModel(), this.getAttributeManager().invalidateAll());
    }
    draw({ uniforms: e }) {
      const { radiusUnits: t, radiusScale: i, radiusMinPixels: s, radiusMaxPixels: a, stroked: l, filled: u, billboard: h, antialiasing: d, lineWidthUnits: p, lineWidthScale: _, lineWidthMinPixels: y, lineWidthMaxPixels: v } = this.props, S = {
        stroked: l,
        filled: u,
        billboard: h,
        antialiasing: d,
        radiusUnits: qi[t],
        radiusScale: i,
        radiusMinPixels: s,
        radiusMaxPixels: a,
        lineWidthUnits: qi[p],
        lineWidthScale: _,
        lineWidthMinPixels: y,
        lineWidthMaxPixels: v
      }, E = this.state.model;
      E.shaderInputs.setProps({
        scatterplot: S
      }), E.draw(this.context.renderPass);
    }
    _getModel() {
      const e = [
        -1,
        -1,
        0,
        1,
        -1,
        0,
        -1,
        1,
        0,
        1,
        1,
        0
      ];
      return new Vn(this.context.device, {
        ...this.getShaders(),
        id: this.props.id,
        bufferLayout: this.getAttributeManager().getBufferLayouts(),
        geometry: new V2({
          topology: "triangle-strip",
          attributes: {
            positions: {
              size: 3,
              value: new Float32Array(e)
            }
          }
        }),
        isInstanced: true
      });
    }
  }
  Hg.defaultProps = Dk;
  Hg.layerName = "ScatterplotLayer";
  const kk = {
    COUNTER_CLOCKWISE: -1
  };
  function Uk(n, e, t = {}) {
    return Bk(n, t) !== e ? (Fk(n, t), true) : false;
  }
  function Bk(n, e = {}) {
    return Math.sign(Lk(n, e));
  }
  const uv = {
    x: 0,
    y: 1,
    z: 2
  };
  function Lk(n, e = {}) {
    const { start: t = 0, end: i = n.length, plane: s = "xy" } = e, a = e.size || 2;
    let l = 0;
    const u = uv[s[0]], h = uv[s[1]];
    for (let d = t, p = i - a; d < i; d += a) l += (n[d + u] - n[p + u]) * (n[d + h] + n[p + h]), p = d;
    return l / 2;
  }
  function Fk(n, e) {
    const { start: t = 0, end: i = n.length, size: s = 2 } = e, a = (i - t) / s, l = Math.floor(a / 2);
    for (let u = 0; u < l; ++u) {
      const h = t + u * s, d = t + (a - 1 - u) * s;
      for (let p = 0; p < s; ++p) {
        const _ = n[h + p];
        n[h + p] = n[d + p], n[d + p] = _;
      }
    }
  }
  class Vk extends V2 {
    constructor(e) {
      const { indices: t, attributes: i } = zk(e);
      super({
        ...e,
        indices: t,
        attributes: i
      });
    }
  }
  function zk(n) {
    const { radius: e, height: t = 1, nradial: i = 10 } = n;
    let { vertices: s } = n;
    s && (Le.assert(s.length >= i), s = s.flatMap((v) => [
      v[0],
      v[1]
    ]), Uk(s, kk.COUNTER_CLOCKWISE));
    const a = t > 0, l = i + 1, u = a ? l * 3 + 1 : i, h = Math.PI * 2 / i, d = new Uint16Array(a ? i * 3 * 2 : 0), p = new Float32Array(u * 3), _ = new Float32Array(u * 3);
    let y = 0;
    if (a) {
      for (let v = 0; v < l; v++) {
        const S = v * h, E = v % i, M = Math.sin(S), F = Math.cos(S);
        for (let H = 0; H < 2; H++) p[y + 0] = s ? s[E * 2] : F * e, p[y + 1] = s ? s[E * 2 + 1] : M * e, p[y + 2] = (1 / 2 - H) * t, _[y + 0] = s ? s[E * 2] : F, _[y + 1] = s ? s[E * 2 + 1] : M, y += 3;
      }
      p[y + 0] = p[y - 3], p[y + 1] = p[y - 2], p[y + 2] = p[y - 1], y += 3;
    }
    for (let v = a ? 0 : 1; v < l; v++) {
      const S = Math.floor(v / 2) * Math.sign(0.5 - v % 2), E = S * h, M = (S + i) % i, F = Math.sin(E), H = Math.cos(E);
      p[y + 0] = s ? s[M * 2] : H * e, p[y + 1] = s ? s[M * 2 + 1] : F * e, p[y + 2] = t / 2, _[y + 2] = 1, y += 3;
    }
    if (a) {
      let v = 0;
      for (let S = 0; S < i; S++) d[v++] = S * 2 + 0, d[v++] = S * 2 + 2, d[v++] = S * 2 + 0, d[v++] = S * 2 + 1, d[v++] = S * 2 + 1, d[v++] = S * 2 + 3;
    }
    return {
      indices: d,
      attributes: {
        POSITION: {
          size: 3,
          value: p
        },
        NORMAL: {
          size: 3,
          value: _
        }
      }
    };
  }
  const fv = `uniform columnUniforms {
  float radius;
  float angle;
  vec2 offset;
  bool extruded;
  bool stroked;
  bool isStroke;
  float coverage;
  float elevationScale;
  float edgeDistance;
  float widthScale;
  float widthMinPixels;
  float widthMaxPixels;
  highp int radiusUnits;
  highp int widthUnits;
} column;
`, Hk = {
    name: "column",
    vs: fv,
    fs: fv,
    uniformTypes: {
      radius: "f32",
      angle: "f32",
      offset: "vec2<f32>",
      extruded: "f32",
      stroked: "f32",
      isStroke: "f32",
      coverage: "f32",
      elevationScale: "f32",
      edgeDistance: "f32",
      widthScale: "f32",
      widthMinPixels: "f32",
      widthMaxPixels: "f32",
      radiusUnits: "i32",
      widthUnits: "i32"
    }
  }, jk = `#version 300 es
#define SHADER_NAME column-layer-vertex-shader
in vec3 positions;
in vec3 normals;
in vec3 instancePositions;
in float instanceElevations;
in vec3 instancePositions64Low;
in vec4 instanceFillColors;
in vec4 instanceLineColors;
in float instanceStrokeWidths;
in vec3 instancePickingColors;
out vec4 vColor;
#ifdef FLAT_SHADING
out vec3 cameraPosition;
out vec4 position_commonspace;
#endif
void main(void) {
geometry.worldPosition = instancePositions;
vec4 color = column.isStroke ? instanceLineColors : instanceFillColors;
mat2 rotationMatrix = mat2(cos(column.angle), sin(column.angle), -sin(column.angle), cos(column.angle));
float elevation = 0.0;
float strokeOffsetRatio = 1.0;
if (column.extruded) {
elevation = instanceElevations * (positions.z + 1.0) / 2.0 * column.elevationScale;
} else if (column.stroked) {
float widthPixels = clamp(
project_size_to_pixel(instanceStrokeWidths * column.widthScale, column.widthUnits),
column.widthMinPixels, column.widthMaxPixels) / 2.0;
float halfOffset = project_pixel_size(widthPixels) / project_size(column.edgeDistance * column.coverage * column.radius);
if (column.isStroke) {
strokeOffsetRatio -= sign(positions.z) * halfOffset;
} else {
strokeOffsetRatio -= halfOffset;
}
}
float shouldRender = float(color.a > 0.0 && instanceElevations >= 0.0);
float dotRadius = column.radius * column.coverage * shouldRender;
geometry.pickingColor = instancePickingColors;
vec3 centroidPosition = vec3(instancePositions.xy, instancePositions.z + elevation);
vec3 centroidPosition64Low = instancePositions64Low;
vec2 offset = (rotationMatrix * positions.xy * strokeOffsetRatio + column.offset) * dotRadius;
if (column.radiusUnits == UNIT_METERS) {
offset = project_size(offset);
}
vec3 pos = vec3(offset, 0.);
DECKGL_FILTER_SIZE(pos, geometry);
gl_Position = project_position_to_clipspace(centroidPosition, centroidPosition64Low, pos, geometry.position);
geometry.normal = project_normal(vec3(rotationMatrix * normals.xy, normals.z));
DECKGL_FILTER_GL_POSITION(gl_Position, geometry);
if (column.extruded && !column.isStroke) {
#ifdef FLAT_SHADING
cameraPosition = project.cameraPosition;
position_commonspace = geometry.position;
vColor = vec4(color.rgb, color.a * layer.opacity);
#else
vec3 lightColor = lighting_getLightColor(color.rgb, project.cameraPosition, geometry.position.xyz, geometry.normal);
vColor = vec4(lightColor, color.a * layer.opacity);
#endif
} else {
vColor = vec4(color.rgb, color.a * layer.opacity);
}
DECKGL_FILTER_COLOR(vColor, geometry);
}
`, Wk = `#version 300 es
#define SHADER_NAME column-layer-fragment-shader
precision highp float;
out vec4 fragColor;
in vec4 vColor;
#ifdef FLAT_SHADING
in vec3 cameraPosition;
in vec4 position_commonspace;
#endif
void main(void) {
fragColor = vColor;
geometry.uv = vec2(0.);
#ifdef FLAT_SHADING
if (column.extruded && !column.isStroke && !bool(picking.isActive)) {
vec3 normal = normalize(cross(dFdx(position_commonspace.xyz), dFdy(position_commonspace.xyz)));
fragColor.rgb = lighting_getLightColor(vColor.rgb, cameraPosition, position_commonspace.xyz, normal);
}
#endif
DECKGL_FILTER_COLOR(fragColor, geometry);
}
`, Bc = [
    0,
    0,
    0,
    255
  ], $k = {
    diskResolution: {
      type: "number",
      min: 4,
      value: 20
    },
    vertices: null,
    radius: {
      type: "number",
      min: 0,
      value: 1e3
    },
    angle: {
      type: "number",
      value: 0
    },
    offset: {
      type: "array",
      value: [
        0,
        0
      ]
    },
    coverage: {
      type: "number",
      min: 0,
      max: 1,
      value: 1
    },
    elevationScale: {
      type: "number",
      min: 0,
      value: 1
    },
    radiusUnits: "meters",
    lineWidthUnits: "meters",
    lineWidthScale: 1,
    lineWidthMinPixels: 0,
    lineWidthMaxPixels: Number.MAX_SAFE_INTEGER,
    extruded: true,
    wireframe: false,
    filled: true,
    stroked: false,
    flatShading: false,
    getPosition: {
      type: "accessor",
      value: (n) => n.position
    },
    getFillColor: {
      type: "accessor",
      value: Bc
    },
    getLineColor: {
      type: "accessor",
      value: Bc
    },
    getLineWidth: {
      type: "accessor",
      value: 1
    },
    getElevation: {
      type: "accessor",
      value: 1e3
    },
    material: true,
    getColor: {
      deprecatedFor: [
        "getFillColor",
        "getLineColor"
      ]
    }
  };
  class jg extends Ds {
    getShaders() {
      const e = {}, { flatShading: t } = this.props;
      return t && (e.FLAT_SHADING = 1), super.getShaders({
        vs: jk,
        fs: Wk,
        defines: e,
        modules: [
          Co,
          t ? g2 : d2,
          I2,
          Hk
        ]
      });
    }
    initializeState() {
      this.getAttributeManager().addInstanced({
        instancePositions: {
          size: 3,
          type: "float64",
          fp64: this.use64bitPositions(),
          transition: true,
          accessor: "getPosition"
        },
        instanceElevations: {
          size: 1,
          transition: true,
          accessor: "getElevation"
        },
        instanceFillColors: {
          size: this.props.colorFormat.length,
          type: "unorm8",
          transition: true,
          accessor: "getFillColor",
          defaultValue: Bc
        },
        instanceLineColors: {
          size: this.props.colorFormat.length,
          type: "unorm8",
          transition: true,
          accessor: "getLineColor",
          defaultValue: Bc
        },
        instanceStrokeWidths: {
          size: 1,
          accessor: "getLineWidth",
          transition: true
        }
      });
    }
    updateState(e) {
      var _a2;
      super.updateState(e);
      const { props: t, oldProps: i, changeFlags: s } = e, a = s.extensionsChanged || t.flatShading !== i.flatShading;
      a && ((_a2 = this.state.models) == null ? void 0 : _a2.forEach((u) => u.destroy()), this.setState(this._getModels()), this.getAttributeManager().invalidateAll());
      const l = this.getNumInstances();
      this.state.fillModel.setInstanceCount(l), this.state.wireframeModel.setInstanceCount(l), (a || t.diskResolution !== i.diskResolution || t.vertices !== i.vertices || (t.extruded || t.stroked) !== (i.extruded || i.stroked)) && this._updateGeometry(t);
    }
    getGeometry(e, t, i) {
      const s = new Vk({
        radius: 1,
        height: i ? 2 : 0,
        vertices: t,
        nradial: e
      });
      let a = 0;
      if (t) for (let l = 0; l < e; l++) {
        const u = t[l], h = Math.sqrt(u[0] * u[0] + u[1] * u[1]);
        a += h / e;
      }
      else a = 1;
      return this.setState({
        edgeDistance: Math.cos(Math.PI / e) * a
      }), s;
    }
    _getModels() {
      const e = this.getShaders(), t = this.getAttributeManager().getBufferLayouts(), i = new Vn(this.context.device, {
        ...e,
        id: `${this.props.id}-fill`,
        bufferLayout: t,
        isInstanced: true
      }), s = new Vn(this.context.device, {
        ...e,
        id: `${this.props.id}-wireframe`,
        bufferLayout: t,
        isInstanced: true
      });
      return {
        fillModel: i,
        wireframeModel: s,
        models: [
          s,
          i
        ]
      };
    }
    _updateGeometry({ diskResolution: e, vertices: t, extruded: i, stroked: s }) {
      const a = this.getGeometry(e, t, i || s);
      this.setState({
        fillVertexCount: a.attributes.POSITION.value.length / 3
      });
      const l = this.state.fillModel, u = this.state.wireframeModel;
      l.setGeometry(a), l.setTopology("triangle-strip"), l.setIndexBuffer(null), u.setGeometry(a), u.setTopology("line-list");
    }
    draw({ uniforms: e }) {
      const { lineWidthUnits: t, lineWidthScale: i, lineWidthMinPixels: s, lineWidthMaxPixels: a, radiusUnits: l, elevationScale: u, extruded: h, filled: d, stroked: p, wireframe: _, offset: y, coverage: v, radius: S, angle: E } = this.props, M = this.state.fillModel, F = this.state.wireframeModel, { fillVertexCount: H, edgeDistance: O } = this.state, U = {
        radius: S,
        angle: E / 180 * Math.PI,
        offset: y,
        extruded: h,
        stroked: p,
        coverage: v,
        elevationScale: u,
        edgeDistance: O,
        radiusUnits: qi[l],
        widthUnits: qi[t],
        widthScale: i,
        widthMinPixels: s,
        widthMaxPixels: a
      };
      h && _ && (F.shaderInputs.setProps({
        column: {
          ...U,
          isStroke: true
        }
      }), F.draw(this.context.renderPass)), d && (M.setVertexCount(H), M.shaderInputs.setProps({
        column: {
          ...U,
          isStroke: false
        }
      }), M.draw(this.context.renderPass)), !h && p && (M.setVertexCount(H * 2 / 3), M.shaderInputs.setProps({
        column: {
          ...U,
          isStroke: true
        }
      }), M.draw(this.context.renderPass));
    }
  }
  jg.layerName = "ColumnLayer";
  jg.defaultProps = $k;
  function Xk({ pointCount: n, getBinId: e }) {
    const t = /* @__PURE__ */ new Map();
    for (let i = 0; i < n; i++) {
      const s = e(i);
      if (s === null) continue;
      let a = t.get(String(s));
      a ? a.points.push(i) : (a = {
        id: s,
        index: t.size,
        points: [
          i
        ]
      }, t.set(String(s), a));
    }
    return Array.from(t.values());
  }
  function Yk({ bins: n, dimensions: e, target: t }) {
    const i = n.length * e;
    (!t || t.length < i) && (t = new Float32Array(i));
    for (let s = 0; s < n.length; s++) {
      const { id: a } = n[s];
      Array.isArray(a) ? t.set(a, s * e) : t[s] = a;
    }
    return t;
  }
  const qk = (n) => n.length, TT = (n, e) => {
    let t = 0;
    for (const i of n) t += e(i);
    return t;
  }, Kk = (n, e) => n.length === 0 ? NaN : TT(n, e) / n.length, Zk = (n, e) => {
    let t = 1 / 0;
    for (const i of n) {
      const s = e(i);
      s < t && (t = s);
    }
    return t;
  }, Qk = (n, e) => {
    let t = -1 / 0;
    for (const i of n) {
      const s = e(i);
      s > t && (t = s);
    }
    return t;
  }, Gk = {
    COUNT: qk,
    SUM: TT,
    MEAN: Kk,
    MIN: Zk,
    MAX: Qk
  };
  function Jk({ bins: n, getValue: e, operation: t, target: i }) {
    (!i || i.length < n.length) && (i = new Float32Array(n.length));
    let s = 1 / 0, a = -1 / 0;
    for (let l = 0; l < n.length; l++) {
      const { points: u } = n[l];
      i[l] = t(u, e), i[l] < s && (s = i[l]), i[l] > a && (a = i[l]);
    }
    return {
      value: i,
      domain: [
        s,
        a
      ]
    };
  }
  function hv(n, e, t) {
    const i = {};
    for (const a of n.sources || []) {
      const l = e[a];
      if (l) i[a] = e6(l);
      else throw new Error(`Cannot find attribute ${a}`);
    }
    const s = {};
    return (a) => {
      for (const l in i) s[l] = i[l](a);
      return n.getValue(s, a, t);
    };
  }
  function e6(n) {
    const e = n.value, { offset: t = 0, stride: i, size: s } = n.getAccessor(), a = e.BYTES_PER_ELEMENT, l = t / a, u = i ? i / a : s;
    if (s === 1) return n.isConstant ? () => e[0] : (d) => {
      const p = l + u * d;
      return e[p];
    };
    let h;
    return n.isConstant ? (h = Array.from(e), () => h) : (h = new Array(s), (d) => {
      const p = l + u * d;
      for (let _ = 0; _ < s; _++) h[_] = e[p + _];
      return h;
    });
  }
  class t6 {
    constructor(e) {
      this.bins = [], this.binIds = null, this.results = [], this.dimensions = e.dimensions, this.channelCount = e.getValue.length, this.props = {
        ...e,
        binOptions: {},
        pointCount: 0,
        operations: [],
        customOperations: [],
        attributes: {}
      }, this.needsUpdate = true, this.setProps(e);
    }
    destroy() {
    }
    get binCount() {
      return this.bins.length;
    }
    setProps(e) {
      const t = this.props;
      if (e.binOptions && (Ft(e.binOptions, t.binOptions, 2) || this.setNeedsUpdate()), e.operations) for (let i = 0; i < this.channelCount; i++) e.operations[i] !== t.operations[i] && this.setNeedsUpdate(i);
      if (e.customOperations) for (let i = 0; i < this.channelCount; i++) !!e.customOperations[i] != !!t.customOperations[i] && this.setNeedsUpdate(i);
      e.pointCount !== void 0 && e.pointCount !== t.pointCount && this.setNeedsUpdate(), e.attributes && (e.attributes = {
        ...t.attributes,
        ...e.attributes
      }), Object.assign(this.props, e);
    }
    setNeedsUpdate(e) {
      e === void 0 ? this.needsUpdate = true : this.needsUpdate !== true && (this.needsUpdate = this.needsUpdate || [], this.needsUpdate[e] = true);
    }
    update() {
      var _a2, _b3, _c2, _d2;
      if (this.needsUpdate === true) {
        this.bins = Xk({
          pointCount: this.props.pointCount,
          getBinId: hv(this.props.getBin, this.props.attributes, this.props.binOptions)
        });
        const e = Yk({
          bins: this.bins,
          dimensions: this.dimensions,
          target: (_a2 = this.binIds) == null ? void 0 : _a2.value
        });
        this.binIds = {
          value: e,
          type: "float32",
          size: this.dimensions
        };
      }
      for (let e = 0; e < this.channelCount; e++) if (this.needsUpdate === true || this.needsUpdate[e]) {
        const t = this.props.customOperations[e] || Gk[this.props.operations[e]], { value: i, domain: s } = Jk({
          bins: this.bins,
          getValue: hv(this.props.getValue[e], this.props.attributes, void 0),
          operation: t,
          target: (_b3 = this.results[e]) == null ? void 0 : _b3.value
        });
        this.results[e] = {
          value: i,
          domain: s,
          type: "float32",
          size: 1
        }, (_d2 = (_c2 = this.props).onUpdate) == null ? void 0 : _d2.call(_c2, {
          channel: e
        });
      }
      this.needsUpdate = false;
    }
    preDraw() {
    }
    getBins() {
      return this.binIds;
    }
    getResult(e) {
      return this.results[e];
    }
    getResultDomain(e) {
      var _a2;
      return ((_a2 = this.results[e]) == null ? void 0 : _a2.domain) ?? [
        1 / 0,
        -1 / 0
      ];
    }
    getBin(e) {
      const t = this.bins[e];
      if (!t) return null;
      const i = new Array(this.channelCount);
      for (let s = 0; s < i.length; s++) {
        const a = this.results[s];
        i[s] = a == null ? void 0 : a.value[e];
      }
      return {
        id: t.id,
        value: i,
        count: t.points.length,
        pointIndices: t.points
      };
    }
  }
  function xT(n, e, t) {
    return n.createFramebuffer({
      width: e,
      height: t,
      colorAttachments: [
        n.createTexture({
          width: e,
          height: t,
          format: "rgba32float",
          mipmaps: false,
          sampler: {
            minFilter: "nearest",
            magFilter: "nearest"
          }
        })
      ]
    });
  }
  const n6 = `uniform binSorterUniforms {
  ivec4 binIdRange;
  ivec2 targetSize;
} binSorter;
`, i6 = {
    name: "binSorter",
    vs: n6,
    uniformTypes: {
      binIdRange: "vec4<i32>",
      targetSize: "vec2<i32>"
    }
  }, ST = [
    1,
    2,
    4,
    8
  ], s6 = 3e38, r6 = {
    SUM: 0,
    MEAN: 0,
    MIN: 0,
    MAX: 0,
    COUNT: 0
  }, dc = 1024;
  class a6 {
    constructor(e, t) {
      this.binsFBO = null, this.device = e, this.model = l6(e, t);
    }
    get texture() {
      return this.binsFBO ? this.binsFBO.colorAttachments[0].texture : null;
    }
    destroy() {
      var _a2, _b3;
      this.model.destroy(), (_a2 = this.binsFBO) == null ? void 0 : _a2.colorAttachments[0].texture.destroy(), (_b3 = this.binsFBO) == null ? void 0 : _b3.destroy();
    }
    getBinValues(e) {
      if (!this.binsFBO) return null;
      const t = e % dc, i = Math.floor(e / dc), s = this.device.readPixelsToArrayWebGL(this.binsFBO, {
        sourceX: t,
        sourceY: i,
        sourceWidth: 1,
        sourceHeight: 1
      }).buffer;
      return new Float32Array(s);
    }
    setDimensions(e, t) {
      var _a2, _b3;
      const i = dc, s = Math.ceil(e / i);
      this.binsFBO ? this.binsFBO.height < s && this.binsFBO.resize({
        width: i,
        height: s
      }) : this.binsFBO = xT(this.device, i, s);
      const a = {
        binIdRange: [
          t[0][0],
          t[0][1],
          ((_a2 = t[1]) == null ? void 0 : _a2[0]) || 0,
          ((_b3 = t[1]) == null ? void 0 : _b3[1]) || 0
        ],
        targetSize: [
          this.binsFBO.width,
          this.binsFBO.height
        ]
      };
      this.model.shaderInputs.setProps({
        binSorter: a
      });
    }
    setModelProps(e) {
      const t = this.model;
      e.attributes && t.setAttributes(e.attributes), e.constantAttributes && t.setConstantAttributes(e.constantAttributes), e.vertexCount !== void 0 && t.setVertexCount(e.vertexCount), e.shaderModuleProps && t.shaderInputs.setProps(e.shaderModuleProps);
    }
    update(e) {
      if (!this.binsFBO) return;
      const t = o6(e);
      this._updateBins("SUM", t.SUM + t.MEAN), this._updateBins("MIN", t.MIN), this._updateBins("MAX", t.MAX);
    }
    _updateBins(e, t) {
      if (t === 0) return;
      t |= ST[3];
      const i = this.model, s = this.binsFBO, a = e === "MAX" ? -3e38 : e === "MIN" ? s6 : 0, l = this.device.beginRenderPass({
        id: `gpu-aggregation-${e}`,
        framebuffer: s,
        parameters: {
          viewport: [
            0,
            0,
            s.width,
            s.height
          ],
          colorMask: t
        },
        clearColor: [
          a,
          a,
          a,
          0
        ],
        clearDepth: false,
        clearStencil: false
      });
      i.setParameters({
        blend: true,
        blendColorSrcFactor: "one",
        blendColorDstFactor: "one",
        blendAlphaSrcFactor: "one",
        blendAlphaDstFactor: "one",
        blendColorOperation: e === "MAX" ? "max" : e === "MIN" ? "min" : "add",
        blendAlphaOperation: "add"
      }), i.draw(l), l.end();
    }
  }
  function o6(n) {
    const e = {
      ...r6
    };
    for (let t = 0; t < n.length; t++) {
      const i = n[t];
      i && (e[i] += ST[t]);
    }
    return e;
  }
  function l6(n, e) {
    let t = e.vs;
    e.dimensions === 2 && (t += `
void getBin(out int binId) {
  ivec2 binId2;
  getBin(binId2);
  if (binId2.x < binSorter.binIdRange.x || binId2.x >= binSorter.binIdRange.y) {
    binId = -1;
  } else {
    binId = (binId2.y - binSorter.binIdRange.z) * (binSorter.binIdRange.y - binSorter.binIdRange.x) + binId2.x;
  }
}
`);
    const i = `#version 300 es
#define SHADER_NAME gpu-aggregation-sort-bins-vertex

${t}

out vec3 v_Value;

void main() {
  int binIndex;
  getBin(binIndex);
  binIndex = binIndex - binSorter.binIdRange.x;
  if (binIndex < 0) {
    gl_Position = vec4(0.);
    return;
  }
  int row = binIndex / binSorter.targetSize.x;
  int col = binIndex - row * binSorter.targetSize.x;
  vec2 position = (vec2(col, row) + 0.5) / vec2(binSorter.targetSize) * 2.0 - 1.0;
  gl_Position = vec4(position, 0.0, 1.0);
  gl_PointSize = 1.0;

#if NUM_CHANNELS == 3
  getValue(v_Value);
#elif NUM_CHANNELS == 2
  getValue(v_Value.xy);
#else
  getValue(v_Value.x);
#endif
}
`, s = `#version 300 es
#define SHADER_NAME gpu-aggregation-sort-bins-fragment

precision highp float;

in vec3 v_Value;
out vec4 fragColor;

void main() {
  fragColor.xyz = v_Value;

  #ifdef MODULE_GEOMETRY
  geometry.uv = vec2(0.);
  DECKGL_FILTER_COLOR(fragColor, geometry);
  #endif

  fragColor.w = 1.0;
}
`;
    return new Vn(n, {
      bufferLayout: e.bufferLayout,
      modules: [
        ...e.modules || [],
        i6
      ],
      defines: {
        ...e.defines,
        NON_INSTANCED_MODEL: 1,
        NUM_CHANNELS: e.channelCount
      },
      isInstanced: false,
      vs: i,
      fs: s,
      topology: "point-list",
      disableWarnings: true
    });
  }
  const c6 = `uniform aggregatorTransformUniforms {
  ivec4 binIdRange;
  bvec3 isCount;
  bvec3 isMean;
  float naN;
} aggregatorTransform;
`, u6 = {
    name: "aggregatorTransform",
    vs: c6,
    uniformTypes: {
      binIdRange: "vec4<i32>",
      isCount: "vec3<f32>",
      isMean: "vec3<f32>"
    }
  };
  class f6 {
    constructor(e, t) {
      this.binBuffer = null, this.valueBuffer = null, this._domains = null, this.device = e, this.channelCount = t.channelCount, this.transform = h6(e, t), this.domainFBO = xT(e, 2, 1);
    }
    destroy() {
      var _a2, _b3;
      this.transform.destroy(), (_a2 = this.binBuffer) == null ? void 0 : _a2.destroy(), (_b3 = this.valueBuffer) == null ? void 0 : _b3.destroy(), this.domainFBO.colorAttachments[0].texture.destroy(), this.domainFBO.destroy();
    }
    get domains() {
      if (!this._domains) {
        const e = this.device.readPixelsToArrayWebGL(this.domainFBO).buffer, t = new Float32Array(e);
        this._domains = [
          [
            -t[4],
            t[0]
          ],
          [
            -t[5],
            t[1]
          ],
          [
            -t[6],
            t[2]
          ]
        ].slice(0, this.channelCount);
      }
      return this._domains;
    }
    setDimensions(e, t) {
      var _a2, _b3, _c2, _d2;
      const { model: i, transformFeedback: s } = this.transform;
      i.setVertexCount(e);
      const a = {
        binIdRange: [
          t[0][0],
          t[0][1],
          ((_a2 = t[1]) == null ? void 0 : _a2[0]) || 0,
          ((_b3 = t[1]) == null ? void 0 : _b3[1]) || 0
        ]
      };
      i.shaderInputs.setProps({
        aggregatorTransform: a
      });
      const l = e * t.length * 4;
      (!this.binBuffer || this.binBuffer.byteLength < l) && ((_c2 = this.binBuffer) == null ? void 0 : _c2.destroy(), this.binBuffer = this.device.createBuffer({
        byteLength: l
      }), s.setBuffer("binIds", this.binBuffer));
      const u = e * this.channelCount * 4;
      (!this.valueBuffer || this.valueBuffer.byteLength < u) && ((_d2 = this.valueBuffer) == null ? void 0 : _d2.destroy(), this.valueBuffer = this.device.createBuffer({
        byteLength: u
      }), s.setBuffer("values", this.valueBuffer));
    }
    update(e, t) {
      if (!e) return;
      const i = this.transform, s = this.domainFBO, a = [
        0,
        1,
        2
      ].map((h) => t[h] === "COUNT" ? 1 : 0), l = [
        0,
        1,
        2
      ].map((h) => t[h] === "MEAN" ? 1 : 0), u = {
        isCount: a,
        isMean: l,
        bins: e
      };
      i.model.shaderInputs.setProps({
        aggregatorTransform: u
      }), i.run({
        id: "gpu-aggregation-domain",
        framebuffer: s,
        parameters: {
          viewport: [
            0,
            0,
            2,
            1
          ]
        },
        clearColor: [
          -3e38,
          -3e38,
          -3e38,
          0
        ],
        clearDepth: false,
        clearStencil: false
      }), this._domains = null;
    }
  }
  function h6(n, e) {
    const t = `#version 300 es
#define SHADER_NAME gpu-aggregation-domain-vertex

uniform sampler2D bins;

#if NUM_DIMS == 1
out float binIds;
#else
out vec2 binIds;
#endif

#if NUM_CHANNELS == 1
flat out float values;
#elif NUM_CHANNELS == 2
flat out vec2 values;
#else
flat out vec3 values;
#endif

const float NAN = intBitsToFloat(-1);

void main() {
  int row = gl_VertexID / SAMPLER_WIDTH;
  int col = gl_VertexID - row * SAMPLER_WIDTH;
  vec4 weights = texelFetch(bins, ivec2(col, row), 0);
  vec3 value3 = mix(
    mix(weights.rgb, vec3(weights.a), aggregatorTransform.isCount),
    weights.rgb / max(weights.a, 1.0),
    aggregatorTransform.isMean
  );
  if (weights.a == 0.0) {
    value3 = vec3(NAN);
  }

#if NUM_DIMS == 1
  binIds = float(gl_VertexID + aggregatorTransform.binIdRange.x);
#else
  int y = gl_VertexID / (aggregatorTransform.binIdRange.y - aggregatorTransform.binIdRange.x);
  int x = gl_VertexID - y * (aggregatorTransform.binIdRange.y - aggregatorTransform.binIdRange.x);
  binIds.y = float(y + aggregatorTransform.binIdRange.z);
  binIds.x = float(x + aggregatorTransform.binIdRange.x);
#endif

#if NUM_CHANNELS == 3
  values = value3;
#elif NUM_CHANNELS == 2
  values = value3.xy;
#else
  values = value3.x;
#endif

  gl_Position = vec4(0., 0., 0., 1.);
  // This model renders into a 2x1 texture to obtain min and max simultaneously.
  // See comments in fragment shader
  gl_PointSize = 2.0;
}
`, i = `#version 300 es
#define SHADER_NAME gpu-aggregation-domain-fragment

precision highp float;

#if NUM_CHANNELS == 1
flat in float values;
#elif NUM_CHANNELS == 2
flat in vec2 values;
#else
flat in vec3 values;
#endif

out vec4 fragColor;

void main() {
  vec3 value3;
#if NUM_CHANNELS == 3
  value3 = values;
#elif NUM_CHANNELS == 2
  value3.xy = values;
#else
  value3.x = values;
#endif
  if (isnan(value3.x)) discard;
  // This shader renders into a 2x1 texture with blending=max
  // The left pixel yields the max value of each channel
  // The right pixel yields the min value of each channel
  if (gl_FragCoord.x < 1.0) {
    fragColor = vec4(value3, 1.0);
  } else {
    fragColor = vec4(-value3, 1.0);
  }
}
`;
    return new Cs(n, {
      vs: t,
      fs: i,
      topology: "point-list",
      modules: [
        u6
      ],
      parameters: {
        blend: true,
        blendColorSrcFactor: "one",
        blendColorDstFactor: "one",
        blendColorOperation: "max",
        blendAlphaSrcFactor: "one",
        blendAlphaDstFactor: "one",
        blendAlphaOperation: "max"
      },
      defines: {
        NUM_DIMS: e.dimensions,
        NUM_CHANNELS: e.channelCount,
        SAMPLER_WIDTH: dc
      },
      varyings: [
        "binIds",
        "values"
      ],
      disableWarnings: true
    });
  }
  class dv {
    static isSupported(e) {
      return e.features.has("float32-renderable-webgl") && e.features.has("texture-blend-float-webgl");
    }
    constructor(e, t) {
      this.binCount = 0, this.binIds = null, this.results = [], this.device = e, this.dimensions = t.dimensions, this.channelCount = t.channelCount, this.props = {
        ...t,
        pointCount: 0,
        binIdRange: [
          [
            0,
            0
          ]
        ],
        operations: [],
        attributes: {},
        binOptions: {}
      }, this.needsUpdate = new Array(this.channelCount).fill(true), this.binSorter = new a6(e, t), this.aggregationTransform = new f6(e, t), this.setProps(t);
    }
    getBins() {
      var _a2;
      const e = this.aggregationTransform.binBuffer;
      return e ? (((_a2 = this.binIds) == null ? void 0 : _a2.buffer) !== e && (this.binIds = {
        buffer: e,
        type: "float32",
        size: this.dimensions
      }), this.binIds) : null;
    }
    getResult(e) {
      var _a2;
      const t = this.aggregationTransform.valueBuffer;
      return !t || e >= this.channelCount ? null : (((_a2 = this.results[e]) == null ? void 0 : _a2.buffer) !== t && (this.results[e] = {
        buffer: t,
        type: "float32",
        size: 1,
        stride: this.channelCount * 4,
        offset: e * 4
      }), this.results[e]);
    }
    getResultDomain(e) {
      return this.aggregationTransform.domains[e];
    }
    getBin(e) {
      if (e < 0 || e >= this.binCount) return null;
      const { binIdRange: t } = this.props;
      let i;
      if (this.dimensions === 1) i = [
        e + t[0][0]
      ];
      else {
        const [[u, h], [d]] = t, p = h - u;
        i = [
          e % p + u,
          Math.floor(e / p) + d
        ];
      }
      const s = this.binSorter.getBinValues(e);
      if (!s) return null;
      const a = s[3], l = [];
      for (let u = 0; u < this.channelCount; u++) {
        const h = this.props.operations[u];
        h === "COUNT" ? l[u] = a : a === 0 ? l[u] = NaN : l[u] = h === "MEAN" ? s[u] / a : s[u];
      }
      return {
        id: i,
        value: l,
        count: a
      };
    }
    destroy() {
      this.binSorter.destroy(), this.aggregationTransform.destroy();
    }
    setProps(e) {
      const t = this.props;
      if ("binIdRange" in e && !Ft(e.binIdRange, t.binIdRange, 2)) {
        const i = e.binIdRange;
        if (Le.assert(i.length === this.dimensions), this.dimensions === 1) {
          const [[s, a]] = i;
          this.binCount = a - s;
        } else {
          const [[s, a], [l, u]] = i;
          this.binCount = (a - s) * (u - l);
        }
        this.binSorter.setDimensions(this.binCount, i), this.aggregationTransform.setDimensions(this.binCount, i), this.setNeedsUpdate();
      }
      if (e.operations) for (let i = 0; i < this.channelCount; i++) e.operations[i] !== t.operations[i] && this.setNeedsUpdate(i);
      if (e.pointCount !== void 0 && e.pointCount !== t.pointCount && (this.binSorter.setModelProps({
        vertexCount: e.pointCount
      }), this.setNeedsUpdate()), e.binOptions && (Ft(e.binOptions, t.binOptions, 2) || this.setNeedsUpdate(), this.binSorter.model.shaderInputs.setProps({
        binOptions: e.binOptions
      })), e.attributes) {
        const i = {}, s = {};
        for (const a of Object.values(e.attributes)) for (const [l, u] of Object.entries(a.getValue())) ArrayBuffer.isView(u) ? s[l] = u : u && (i[l] = u);
        this.binSorter.setModelProps({
          attributes: i,
          constantAttributes: s
        });
      }
      e.shaderModuleProps && this.binSorter.setModelProps({
        shaderModuleProps: e.shaderModuleProps
      }), Object.assign(this.props, e);
    }
    setNeedsUpdate(e) {
      e === void 0 ? this.needsUpdate.fill(true) : this.needsUpdate[e] = true;
    }
    update() {
    }
    preDraw() {
      var _a2, _b3;
      if (!this.needsUpdate.some(Boolean)) return;
      const { operations: e } = this.props, t = this.needsUpdate.map((i, s) => i ? e[s] : null);
      this.binSorter.update(t), this.aggregationTransform.update(this.binSorter.texture, e);
      for (let i = 0; i < this.channelCount; i++) this.needsUpdate[i] && (this.needsUpdate[i] = false, (_b3 = (_a2 = this.props).onUpdate) == null ? void 0 : _b3.call(_a2, {
        channel: i
      }));
    }
  }
  let AT = class extends zg {
    get isDrawable() {
      return true;
    }
    initializeState() {
      this.getAttributeManager().remove([
        "instancePickingColors"
      ]);
    }
    updateState(e) {
      var _a2, _b3;
      super.updateState(e);
      const t = this.getAggregatorType();
      if (e.changeFlags.extensionsChanged || this.state.aggregatorType !== t) {
        (_a2 = this.state.aggregator) == null ? void 0 : _a2.destroy();
        const i = this.createAggregator(t);
        return i.setProps({
          attributes: (_b3 = this.getAttributeManager()) == null ? void 0 : _b3.attributes
        }), this.setState({
          aggregator: i,
          aggregatorType: t
        }), true;
      }
      return false;
    }
    finalizeState(e) {
      super.finalizeState(e), this.state.aggregator.destroy();
    }
    updateAttributes(e) {
      const { aggregator: t } = this.state;
      t.setProps({
        attributes: e
      });
      for (const i in e) this.onAttributeChange(i);
      t.update();
    }
    draw({ shaderModuleProps: e }) {
      const { aggregator: t } = this.state;
      t.setProps({
        shaderModuleProps: e
      }), t.preDraw();
    }
    _getAttributeManager() {
      return new tu(this.context.device, {
        id: this.props.id,
        stats: this.context.stats
      });
    }
  };
  AT.layerName = "AggregationLayer";
  const wT = [
    [
      255,
      255,
      178
    ],
    [
      254,
      217,
      118
    ],
    [
      254,
      178,
      76
    ],
    [
      253,
      141,
      60
    ],
    [
      240,
      59,
      32
    ],
    [
      189,
      0,
      38
    ]
  ];
  function ET(n, e = false, t = Float32Array) {
    let i;
    if (Number.isFinite(n[0])) i = new t(n);
    else {
      i = new t(n.length * 4);
      let s = 0;
      for (let a = 0; a < n.length; a++) {
        const l = n[a];
        i[s++] = l[0], i[s++] = l[1], i[s++] = l[2], i[s++] = Number.isFinite(l[3]) ? l[3] : 255;
      }
    }
    if (e) for (let s = 0; s < i.length; s++) i[s] /= 255;
    return i;
  }
  const Lc = {
    linear: "linear",
    quantile: "nearest",
    quantize: "nearest",
    ordinal: "nearest"
  };
  function d6(n, e) {
    n.setSampler({
      minFilter: Lc[e],
      magFilter: Lc[e]
    });
  }
  function g6(n, e, t = "linear") {
    const i = ET(e, false, Uint8Array);
    return n.createTexture({
      format: "rgba8unorm",
      mipmaps: false,
      sampler: {
        minFilter: Lc[t],
        magFilter: Lc[t],
        addressModeU: "clamp-to-edge",
        addressModeV: "clamp-to-edge"
      },
      data: i,
      width: i.length / 4,
      height: 1
    });
  }
  class gv {
    constructor(e, t) {
      this.props = {
        scaleType: "linear",
        lowerPercentile: 0,
        upperPercentile: 100
      }, this.domain = null, this.cutoff = null, this.input = e, this.inputLength = t, this.attribute = e;
    }
    getScalePercentile() {
      if (!this._percentile) {
        const e = pv(this.input, this.inputLength);
        this._percentile = m6(e);
      }
      return this._percentile;
    }
    getScaleOrdinal() {
      if (!this._ordinal) {
        const e = pv(this.input, this.inputLength);
        this._ordinal = p6(e);
      }
      return this._ordinal;
    }
    getCutoff({ scaleType: e, lowerPercentile: t, upperPercentile: i }) {
      if (e === "quantile") return [
        t,
        i - 1
      ];
      if (t > 0 || i < 100) {
        const { domain: s } = this.getScalePercentile();
        let a = s[Math.floor(t) - 1] ?? -1 / 0, l = s[Math.floor(i) - 1] ?? 1 / 0;
        if (e === "ordinal") {
          const { domain: u } = this.getScaleOrdinal();
          a = u.findIndex((h) => h >= a), l = u.findIndex((h) => h > l) - 1, l === -2 && (l = u.length - 1);
        }
        return [
          a,
          l
        ];
      }
      return null;
    }
    update(e) {
      const t = this.props;
      if (e.scaleType !== t.scaleType) switch (e.scaleType) {
        case "quantile": {
          const { attribute: i } = this.getScalePercentile();
          this.attribute = i, this.domain = [
            0,
            99
          ];
          break;
        }
        case "ordinal": {
          const { attribute: i, domain: s } = this.getScaleOrdinal();
          this.attribute = i, this.domain = [
            0,
            s.length - 1
          ];
          break;
        }
        default:
          this.attribute = this.input, this.domain = null;
      }
      return (e.scaleType !== t.scaleType || e.lowerPercentile !== t.lowerPercentile || e.upperPercentile !== t.upperPercentile) && (this.cutoff = this.getCutoff(e)), this.props = e, this;
    }
  }
  function p6(n) {
    const e = /* @__PURE__ */ new Set();
    for (const s of n) Number.isFinite(s) && e.add(s);
    const t = Array.from(e).sort(), i = /* @__PURE__ */ new Map();
    for (let s = 0; s < t.length; s++) i.set(t[s], s);
    return {
      attribute: {
        value: n.map((s) => Number.isFinite(s) ? i.get(s) : NaN),
        type: "float32",
        size: 1
      },
      domain: t
    };
  }
  function m6(n, e = 100) {
    const t = Array.from(n).filter(Number.isFinite).sort(_6);
    let i = 0;
    const s = Math.max(1, e), a = new Array(s - 1);
    for (; ++i < s; ) a[i - 1] = y6(t, i / s);
    return {
      attribute: {
        value: n.map((l) => Number.isFinite(l) ? b6(a, l) : NaN),
        type: "float32",
        size: 1
      },
      domain: a
    };
  }
  function pv(n, e) {
    var _a2;
    const t = (n.stride ?? 4) / 4, i = (n.offset ?? 0) / 4;
    let s = n.value;
    if (!s) {
      const l = (_a2 = n.buffer) == null ? void 0 : _a2.readSyncWebGL(0, t * 4 * e);
      l && (s = new Float32Array(l.buffer), n.value = s);
    }
    if (t === 1) return s.subarray(0, e);
    const a = new Float32Array(e);
    for (let l = 0; l < e; l++) a[l] = s[l * t + i];
    return a;
  }
  function _6(n, e) {
    return n - e;
  }
  function y6(n, e) {
    const t = n.length;
    if (e <= 0 || t < 2) return n[0];
    if (e >= 1) return n[t - 1];
    const i = (t - 1) * e, s = Math.floor(i), a = n[s], l = n[s + 1];
    return a + (l - a) * (i - s);
  }
  function b6(n, e) {
    let t = 0, i = n.length;
    for (; t < i; ) {
      const s = t + i >>> 1;
      n[s] > e ? i = s : t = s + 1;
    }
    return t;
  }
  function v6({ dataBounds: n, getBinId: e, padding: t = 0 }) {
    const i = [
      n[0],
      n[1],
      [
        n[0][0],
        n[1][1]
      ],
      [
        n[1][0],
        n[0][1]
      ]
    ].map((h) => e(h)), s = Math.min(...i.map((h) => h[0])) - t, a = Math.min(...i.map((h) => h[1])) - t, l = Math.max(...i.map((h) => h[0])) + t + 1, u = Math.max(...i.map((h) => h[1])) + t + 1;
    return [
      [
        s,
        l
      ],
      [
        a,
        u
      ]
    ];
  }
  const RT = Math.PI / 3, su = 2 * Math.sin(RT), ru = 1.5, T6 = Array.from({
    length: 6
  }, (n, e) => {
    const t = e * RT;
    return [
      Math.sin(t),
      -Math.cos(t)
    ];
  });
  function ad([n, e], t) {
    let i = Math.round(e = e / t / ru), s = Math.round(n = n / t / su - (i & 1) / 2);
    const a = e - i;
    if (Math.abs(a) * 3 > 1) {
      const l = n - s, u = s + (n < s ? -1 : 1) / 2, h = i + (e < i ? -1 : 1), d = n - u, p = e - h;
      l * l + a * a > d * d + p * p && (s = u + (i & 1 ? 1 : -1) / 2, i = h);
    }
    return [
      s,
      i
    ];
  }
  const x6 = `
const vec2 DIST = vec2(${su}, ${ru});

ivec2 pointToHexbin(vec2 p, float radius) {
  p /= radius * DIST;
  float pj = round(p.y);
  float pjm2 = mod(pj, 2.0);
  p.x -= pjm2 * 0.5;
  float pi = round(p.x);
  vec2 d1 = p - vec2(pi, pj);

  if (abs(d1.y) * 3. > 1.) {
    vec2 v2 = step(0.0, d1) - 0.5;
    v2.y *= 2.0;
    vec2 d2 = d1 - v2;
    if (dot(d1, d1) > dot(d2, d2)) {
      pi += v2.x + pjm2 - 0.5;
      pj += v2.y;
    }
  }
  return ivec2(pi, pj);
}
`;
  function mv([n, e], t) {
    return [
      (n + (e & 1) / 2) * t * su,
      e * t * ru
    ];
  }
  const S6 = `
const vec2 DIST = vec2(${su}, ${ru});

vec2 hexbinCentroid(vec2 binId, float radius) {
  binId.x += fract(binId.y * 0.5);
  return binId * DIST * radius;
}
`, A6 = `#version 300 es
#define SHADER_NAME hexagon-cell-layer-vertex-shader
in vec3 positions;
in vec3 normals;
in vec2 instancePositions;
in float instanceElevationValues;
in float instanceColorValues;
in vec3 instancePickingColors;
uniform sampler2D colorRange;
out vec4 vColor;
${S6}
float interp(float value, vec2 domain, vec2 range) {
float r = min(max((value - domain.x) / (domain.y - domain.x), 0.), 1.);
return mix(range.x, range.y, r);
}
vec4 interp(float value, vec2 domain, sampler2D range) {
float r = (value - domain.x) / (domain.y - domain.x);
return texture(range, vec2(r, 0.5));
}
void main(void) {
geometry.pickingColor = instancePickingColors;
if (isnan(instanceColorValues) ||
instanceColorValues < hexagon.colorDomain.z ||
instanceColorValues > hexagon.colorDomain.w ||
instanceElevationValues < hexagon.elevationDomain.z ||
instanceElevationValues > hexagon.elevationDomain.w
) {
gl_Position = vec4(0.);
return;
}
vec2 commonPosition = hexbinCentroid(instancePositions, column.radius) + (hexagon.originCommon - project.commonOrigin.xy);
commonPosition += positions.xy * column.radius * column.coverage;
geometry.position = vec4(commonPosition, 0.0, 1.0);
geometry.normal = project_normal(normals);
float elevation = 0.0;
if (column.extruded) {
elevation = interp(instanceElevationValues, hexagon.elevationDomain.xy, hexagon.elevationRange);
elevation = project_size(elevation);
geometry.position.z = (positions.z + 1.0) / 2.0 * elevation;
}
gl_Position = project_common_position_to_clipspace(geometry.position);
DECKGL_FILTER_GL_POSITION(gl_Position, geometry);
vColor = interp(instanceColorValues, hexagon.colorDomain.xy, colorRange);
vColor.a *= layer.opacity;
if (column.extruded) {
vColor.rgb = lighting_getLightColor(vColor.rgb, project.cameraPosition, geometry.position.xyz, geometry.normal);
}
DECKGL_FILTER_COLOR(vColor, geometry);
}
`, w6 = `uniform hexagonUniforms {
  vec4 colorDomain;
  vec4 elevationDomain;
  vec2 elevationRange;
  vec2 originCommon;
} hexagon;
`, E6 = {
    name: "hexagon",
    vs: w6,
    uniformTypes: {
      colorDomain: "vec4<f32>",
      elevationDomain: "vec4<f32>",
      elevationRange: "vec2<f32>",
      originCommon: "vec2<f32>"
    }
  };
  class CT extends jg {
    getShaders() {
      const e = super.getShaders();
      return e.modules.push(E6), {
        ...e,
        vs: A6
      };
    }
    initializeState() {
      super.initializeState();
      const e = this.getAttributeManager();
      e.remove([
        "instanceElevations",
        "instanceFillColors",
        "instanceLineColors",
        "instanceStrokeWidths"
      ]), e.addInstanced({
        instancePositions: {
          size: 2,
          type: "float32",
          accessor: "getBin"
        },
        instanceColorValues: {
          size: 1,
          type: "float32",
          accessor: "getColorValue"
        },
        instanceElevationValues: {
          size: 1,
          type: "float32",
          accessor: "getElevationValue"
        }
      });
    }
    updateState(e) {
      var _a2;
      super.updateState(e);
      const { props: t, oldProps: i } = e, s = this.state.fillModel;
      if (i.colorRange !== t.colorRange) {
        (_a2 = this.state.colorTexture) == null ? void 0 : _a2.destroy(), this.state.colorTexture = g6(this.context.device, t.colorRange, t.colorScaleType);
        const a = {
          colorRange: this.state.colorTexture
        };
        s.shaderInputs.setProps({
          hexagon: a
        });
      } else i.colorScaleType !== t.colorScaleType && d6(this.state.colorTexture, t.colorScaleType);
    }
    finalizeState(e) {
      var _a2;
      super.finalizeState(e), (_a2 = this.state.colorTexture) == null ? void 0 : _a2.destroy();
    }
    draw({ uniforms: e }) {
      const { radius: t, hexOriginCommon: i, elevationRange: s, elevationScale: a, extruded: l, coverage: u, colorDomain: h, elevationDomain: d } = this.props, p = this.props.colorCutoff || [
        -1 / 0,
        1 / 0
      ], _ = this.props.elevationCutoff || [
        -1 / 0,
        1 / 0
      ], y = this.state.fillModel;
      y.vertexArray.indexBuffer && y.setIndexBuffer(null), y.setVertexCount(this.state.fillVertexCount);
      const v = {
        colorDomain: [
          Math.max(h[0], p[0]),
          Math.min(h[1], p[1]),
          Math.max(h[0] - 1, p[0]),
          Math.min(h[1] + 1, p[1])
        ],
        elevationDomain: [
          Math.max(d[0], _[0]),
          Math.min(d[1], _[1]),
          Math.max(d[0] - 1, _[0]),
          Math.min(d[1] + 1, _[1])
        ],
        elevationRange: [
          s[0] * a,
          s[1] * a
        ],
        originCommon: i
      };
      y.shaderInputs.setProps({
        column: {
          extruded: l,
          coverage: u,
          radius: t
        },
        hexagon: v
      }), y.draw(this.context.renderPass);
    }
  }
  CT.layerName = "HexagonCellLayer";
  const R6 = `uniform binOptionsUniforms {
  vec2 hexOriginCommon;
  float radiusCommon;
} binOptions;
`, C6 = {
    name: "binOptions",
    vs: R6,
    uniformTypes: {
      hexOriginCommon: "vec2<f32>",
      radiusCommon: "f32"
    }
  };
  function _v() {
  }
  const M6 = {
    gpuAggregation: true,
    colorDomain: null,
    colorRange: wT,
    getColorValue: {
      type: "accessor",
      value: null
    },
    getColorWeight: {
      type: "accessor",
      value: 1
    },
    colorAggregation: "SUM",
    lowerPercentile: {
      type: "number",
      min: 0,
      max: 100,
      value: 0
    },
    upperPercentile: {
      type: "number",
      min: 0,
      max: 100,
      value: 100
    },
    colorScaleType: "quantize",
    onSetColorDomain: _v,
    elevationDomain: null,
    elevationRange: [
      0,
      1e3
    ],
    getElevationValue: {
      type: "accessor",
      value: null
    },
    getElevationWeight: {
      type: "accessor",
      value: 1
    },
    elevationAggregation: "SUM",
    elevationScale: {
      type: "number",
      min: 0,
      value: 1
    },
    elevationLowerPercentile: {
      type: "number",
      min: 0,
      max: 100,
      value: 0
    },
    elevationUpperPercentile: {
      type: "number",
      min: 0,
      max: 100,
      value: 100
    },
    elevationScaleType: "linear",
    onSetElevationDomain: _v,
    radius: {
      type: "number",
      min: 1,
      value: 1e3
    },
    coverage: {
      type: "number",
      min: 0,
      max: 1,
      value: 1
    },
    getPosition: {
      type: "accessor",
      value: (n) => n.position
    },
    hexagonAggregator: {
      type: "function",
      optional: true,
      value: null
    },
    extruded: false,
    material: true
  };
  class Wg extends AT {
    getAggregatorType() {
      const { gpuAggregation: e, hexagonAggregator: t, getColorValue: i, getElevationValue: s } = this.props;
      return e && (t || i || s) ? (Le.warn("Features not supported by GPU aggregation, falling back to CPU")(), "cpu") : e && dv.isSupported(this.context.device) ? "gpu" : "cpu";
    }
    createAggregator(e) {
      if (e === "cpu") {
        const { hexagonAggregator: t, radius: i } = this.props;
        return new t6({
          dimensions: 2,
          getBin: {
            sources: [
              "positions"
            ],
            getValue: ({ positions: s }, a, l) => {
              if (t) return t(s, i);
              const h = this.state.aggregatorViewport.projectPosition(s), { radiusCommon: d, hexOriginCommon: p } = l;
              return ad([
                h[0] - p[0],
                h[1] - p[1]
              ], d);
            }
          },
          getValue: [
            {
              sources: [
                "colorWeights"
              ],
              getValue: ({ colorWeights: s }) => s
            },
            {
              sources: [
                "elevationWeights"
              ],
              getValue: ({ elevationWeights: s }) => s
            }
          ]
        });
      }
      return new dv(this.context.device, {
        dimensions: 2,
        channelCount: 2,
        bufferLayout: this.getAttributeManager().getBufferLayouts({
          isInstanced: false
        }),
        ...super.getShaders({
          modules: [
            Co,
            C6
          ],
          vs: `
  in vec3 positions;
  in vec3 positions64Low;
  in float colorWeights;
  in float elevationWeights;
  
  ${x6}

  void getBin(out ivec2 binId) {
    vec3 positionCommon = project_position(positions, positions64Low);
    binId = pointToHexbin(positionCommon.xy, binOptions.radiusCommon);
  }
  void getValue(out vec2 value) {
    value = vec2(colorWeights, elevationWeights);
  }
  `
        })
      });
    }
    initializeState() {
      super.initializeState(), this.getAttributeManager().add({
        positions: {
          size: 3,
          accessor: "getPosition",
          type: "float64",
          fp64: this.use64bitPositions()
        },
        colorWeights: {
          size: 1,
          accessor: "getColorWeight"
        },
        elevationWeights: {
          size: 1,
          accessor: "getElevationWeight"
        }
      });
    }
    updateState(e) {
      const t = super.updateState(e), { props: i, oldProps: s, changeFlags: a } = e, { aggregator: l } = this.state;
      if ((a.dataChanged || !this.state.dataAsArray) && (i.getColorValue || i.getElevationValue) && (this.state.dataAsArray = Array.from(oT(i.data).iterable)), t || a.dataChanged || i.radius !== s.radius || i.getColorValue !== s.getColorValue || i.getElevationValue !== s.getElevationValue || i.colorAggregation !== s.colorAggregation || i.elevationAggregation !== s.elevationAggregation) {
        this._updateBinOptions();
        const { radiusCommon: u, hexOriginCommon: h, binIdRange: d, dataAsArray: p } = this.state;
        if (l.setProps({
          binIdRange: d,
          pointCount: this.getNumInstances(),
          operations: [
            i.colorAggregation,
            i.elevationAggregation
          ],
          binOptions: {
            radiusCommon: u,
            hexOriginCommon: h
          },
          onUpdate: this._onAggregationUpdate.bind(this)
        }), p) {
          const { getColorValue: _, getElevationValue: y } = this.props;
          l.setProps({
            customOperations: [
              _ && ((v) => _(v.map((S) => p[S]), {
                indices: v,
                data: i.data
              })),
              y && ((v) => y(v.map((S) => p[S]), {
                indices: v,
                data: i.data
              }))
            ]
          });
        }
      }
      return a.updateTriggersChanged && a.updateTriggersChanged.getColorValue && l.setNeedsUpdate(0), a.updateTriggersChanged && a.updateTriggersChanged.getElevationValue && l.setNeedsUpdate(1), t;
    }
    _updateBinOptions() {
      const e = this.getBounds();
      let t = 1, i = [
        0,
        0
      ], s = [
        [
          0,
          1
        ],
        [
          0,
          1
        ]
      ], a = this.context.viewport;
      if (e && Number.isFinite(e[0][0])) {
        let l = [
          (e[0][0] + e[1][0]) / 2,
          (e[0][1] + e[1][1]) / 2
        ];
        const { radius: u } = this.props, { unitsPerMeter: h } = a.getDistanceScales(l);
        t = h[0] * u;
        const d = ad(a.projectFlat(l), t);
        l = a.unprojectFlat(mv(d, t));
        const p = a.constructor;
        a = a.isGeospatial ? new p({
          longitude: l[0],
          latitude: l[1],
          zoom: 12
        }) : new Zr({
          position: [
            l[0],
            l[1],
            0
          ],
          zoom: 12
        }), i = [
          Math.fround(a.center[0]),
          Math.fround(a.center[1])
        ], s = v6({
          dataBounds: e,
          getBinId: (_) => {
            const y = a.projectFlat(_);
            return y[0] -= i[0], y[1] -= i[1], ad(y, t);
          },
          padding: 1
        });
      }
      this.setState({
        radiusCommon: t,
        hexOriginCommon: i,
        binIdRange: s,
        aggregatorViewport: a
      });
    }
    draw(e) {
      e.shaderModuleProps.project && (e.shaderModuleProps.project.viewport = this.state.aggregatorViewport), super.draw(e);
    }
    _onAggregationUpdate({ channel: e }) {
      const t = this.getCurrentLayer().props, { aggregator: i } = this.state;
      if (e === 0) {
        const s = i.getResult(0);
        this.setState({
          colors: new gv(s, i.binCount)
        }), t.onSetColorDomain(i.getResultDomain(0));
      } else if (e === 1) {
        const s = i.getResult(1);
        this.setState({
          elevations: new gv(s, i.binCount)
        }), t.onSetElevationDomain(i.getResultDomain(1));
      }
    }
    onAttributeChange(e) {
      const { aggregator: t } = this.state;
      switch (e) {
        case "positions":
          t.setNeedsUpdate(), this._updateBinOptions();
          const { radiusCommon: i, hexOriginCommon: s, binIdRange: a } = this.state;
          t.setProps({
            binIdRange: a,
            binOptions: {
              radiusCommon: i,
              hexOriginCommon: s
            }
          });
          break;
        case "colorWeights":
          t.setNeedsUpdate(0);
          break;
        case "elevationWeights":
          t.setNeedsUpdate(1);
          break;
      }
    }
    renderLayers() {
      var _a2, _b3;
      const { aggregator: e, radiusCommon: t, hexOriginCommon: i } = this.state, { elevationScale: s, colorRange: a, elevationRange: l, extruded: u, coverage: h, material: d, transitions: p, colorScaleType: _, lowerPercentile: y, upperPercentile: v, colorDomain: S, elevationScaleType: E, elevationLowerPercentile: M, elevationUpperPercentile: F, elevationDomain: H } = this.props, O = this.getSubLayerClass("cells", CT), U = e.getBins(), B = (_a2 = this.state.colors) == null ? void 0 : _a2.update({
        scaleType: _,
        lowerPercentile: y,
        upperPercentile: v
      }), Z = (_b3 = this.state.elevations) == null ? void 0 : _b3.update({
        scaleType: E,
        lowerPercentile: M,
        upperPercentile: F
      });
      return !B || !Z ? null : new O(this.getSubLayerProps({
        id: "cells"
      }), {
        data: {
          length: e.binCount,
          attributes: {
            getBin: U,
            getColorValue: B.attribute,
            getElevationValue: Z.attribute
          }
        },
        dataComparator: (re, le) => re.length === le.length,
        updateTriggers: {
          getBin: [
            U
          ],
          getColorValue: [
            B.attribute
          ],
          getElevationValue: [
            Z.attribute
          ]
        },
        diskResolution: 6,
        vertices: T6,
        radius: t,
        hexOriginCommon: i,
        elevationScale: s,
        colorRange: a,
        colorScaleType: _,
        elevationRange: l,
        extruded: u,
        coverage: h,
        material: d,
        colorDomain: B.domain || S || e.getResultDomain(0),
        elevationDomain: Z.domain || H || e.getResultDomain(1),
        colorCutoff: B.cutoff,
        elevationCutoff: Z.cutoff,
        transitions: p && {
          getFillColor: p.getColorValue || p.getColorWeight,
          getElevation: p.getElevationValue || p.getElevationWeight
        },
        extensions: []
      });
    }
    getPickingInfo(e) {
      const t = e.info, { index: i } = t;
      if (i >= 0) {
        const s = this.state.aggregator.getBin(i);
        let a;
        if (s) {
          const l = mv(s.id, this.state.radiusCommon), u = this.context.viewport.unprojectFlat(l);
          a = {
            col: s.id[0],
            row: s.id[1],
            position: u,
            colorValue: s.value[0],
            elevationValue: s.value[1],
            count: s.count
          }, s.pointIndices && (a.pointIndices = s.pointIndices, a.points = Array.isArray(this.props.data) ? s.pointIndices.map((h) => this.props.data[h]) : []);
        }
        t.object = a;
      }
      return t;
    }
  }
  Wg.layerName = "HexagonLayer";
  Wg.defaultProps = M6;
  function O6(n) {
    const e = n.map((u) => u[0]), t = n.map((u) => u[1]), i = Math.min.apply(null, e), s = Math.max.apply(null, e), a = Math.min.apply(null, t), l = Math.max.apply(null, t);
    return [
      i,
      a,
      s,
      l
    ];
  }
  function I6(n, e) {
    return e[0] >= n[0] && e[2] <= n[2] && e[1] >= n[1] && e[3] <= n[3];
  }
  const yv = new Float32Array(12);
  function bv(n, e = 2) {
    let t = 0;
    for (const i of n) for (let s = 0; s < e; s++) yv[t++] = i[s] || 0;
    return yv;
  }
  function N6(n, e, t) {
    const [i, s, a, l] = n, u = a - i, h = l - s;
    let d = u, p = h;
    u / h < e / t ? d = e / t * h : p = t / e * u, d < e && (d = e, p = t);
    const _ = (a + i) / 2, y = (l + s) / 2;
    return [
      _ - d / 2,
      y - p / 2,
      _ + d / 2,
      y + p / 2
    ];
  }
  function P6(n, e) {
    const [t, i, s, a] = e;
    return [
      (n[0] - t) / (s - t),
      (n[1] - i) / (a - i)
    ];
  }
  const D6 = `#version 300 es
#define SHADER_NAME heatp-map-layer-vertex-shader
uniform sampler2D maxTexture;
in vec3 positions;
in vec2 texCoords;
out vec2 vTexCoords;
out float vIntensityMin;
out float vIntensityMax;
void main(void) {
gl_Position = project_position_to_clipspace(positions, vec3(0.0), vec3(0.0));
vTexCoords = texCoords;
vec4 maxTexture = texture(maxTexture, vec2(0.5));
float maxValue = triangle.aggregationMode < 0.5 ? maxTexture.r : maxTexture.g;
float minValue = maxValue * triangle.threshold;
if (triangle.colorDomain[1] > 0.) {
maxValue = triangle.colorDomain[1];
minValue = triangle.colorDomain[0];
}
vIntensityMax = triangle.intensity / maxValue;
vIntensityMin = triangle.intensity / minValue;
}
`, k6 = `#version 300 es
#define SHADER_NAME triangle-layer-fragment-shader
precision highp float;
uniform sampler2D weightsTexture;
uniform sampler2D colorTexture;
in vec2 vTexCoords;
in float vIntensityMin;
in float vIntensityMax;
out vec4 fragColor;
vec4 getLinearColor(float value) {
float factor = clamp(value * vIntensityMax, 0., 1.);
vec4 color = texture(colorTexture, vec2(factor, 0.5));
color.a *= min(value * vIntensityMin, 1.0);
return color;
}
void main(void) {
vec4 weights = texture(weightsTexture, vTexCoords);
float weight = weights.r;
if (triangle.aggregationMode > 0.5) {
weight /= max(1.0, weights.a);
}
if (weight <= 0.) {
discard;
}
vec4 linearColor = getLinearColor(weight);
linearColor.a *= layer.opacity;
fragColor = linearColor;
}
`, vv = `uniform triangleUniforms {
  float aggregationMode;
  vec2 colorDomain;
  float intensity;
  float threshold;
} triangle;
`, U6 = {
    name: "triangle",
    vs: vv,
    fs: vv,
    uniformTypes: {
      aggregationMode: "f32",
      colorDomain: "vec2<f32>",
      intensity: "f32",
      threshold: "f32"
    }
  };
  class MT extends Ds {
    getShaders() {
      return super.getShaders({
        vs: D6,
        fs: k6,
        modules: [
          Co,
          U6
        ]
      });
    }
    initializeState({ device: e }) {
      this.setState({
        model: this._getModel(e)
      });
    }
    _getModel(e) {
      const { vertexCount: t, data: i } = this.props;
      return new Vn(e, {
        ...this.getShaders(),
        id: this.props.id,
        attributes: i.attributes,
        bufferLayout: [
          {
            name: "positions",
            format: "float32x3"
          },
          {
            name: "texCoords",
            format: "float32x2"
          }
        ],
        topology: "triangle-strip",
        vertexCount: t
      });
    }
    draw() {
      const { model: e } = this.state, { aggregationMode: t, colorDomain: i, intensity: s, threshold: a, colorTexture: l, maxTexture: u, weightsTexture: h } = this.props, d = {
        aggregationMode: t,
        colorDomain: i,
        intensity: s,
        threshold: a,
        colorTexture: l,
        maxTexture: u,
        weightsTexture: h
      };
      e.shaderInputs.setProps({
        triangle: d
      }), e.draw(this.context.renderPass);
    }
  }
  MT.layerName = "TriangleLayer";
  function B6(n, e) {
    const t = {};
    for (const i in n) e.includes(i) || (t[i] = n[i]);
    return t;
  }
  class OT extends zg {
    initializeAggregationLayer(e) {
      super.initializeState(this.context), this.setState({
        ignoreProps: B6(this.constructor._propTypes, e.data.props),
        dimensions: e
      });
    }
    updateState(e) {
      super.updateState(e);
      const { changeFlags: t } = e;
      if (t.extensionsChanged) {
        const i = this.getShaders({});
        i && i.defines && (i.defines.NON_INSTANCED_MODEL = 1), this.updateShaders(i);
      }
      this._updateAttributes();
    }
    updateAttributes(e) {
      this.setState({
        changedAttributes: e
      });
    }
    getAttributes() {
      return this.getAttributeManager().getAttributes();
    }
    getModuleSettings() {
      const { viewport: e, mousePosition: t, device: i } = this.context;
      return Object.assign(Object.create(this.props), {
        viewport: e,
        mousePosition: t,
        picking: {
          isActive: 0
        },
        devicePixelRatio: i.canvasContext.cssToDeviceRatio()
      });
    }
    updateShaders(e) {
    }
    isAggregationDirty(e, t = {}) {
      const { props: i, oldProps: s, changeFlags: a } = e, { compareAll: l = false, dimension: u } = t, { ignoreProps: h } = this.state, { props: d, accessors: p = [] } = u, { updateTriggersChanged: _ } = a;
      if (a.dataChanged) return true;
      if (_) {
        if (_.all) return true;
        for (const y of p) if (_[y]) return true;
      }
      if (l) return a.extensionsChanged ? true : Fg({
        oldProps: s,
        newProps: i,
        ignoreProps: h,
        propTypes: this.constructor._propTypes
      });
      for (const y of d) if (i[y] !== s[y]) return true;
      return false;
    }
    isAttributeChanged(e) {
      const { changedAttributes: t } = this.state;
      return e ? t && t[e] !== void 0 : !L6(t);
    }
    _getAttributeManager() {
      return new tu(this.context.device, {
        id: this.props.id,
        stats: this.context.stats
      });
    }
  }
  OT.layerName = "AggregationLayer";
  function L6(n) {
    let e = true;
    for (const t in n) {
      e = false;
      break;
    }
    return e;
  }
  const Tv = `#version 300 es
in vec3 positions;
in vec3 positions64Low;
in float weights;
out vec4 weightsTexture;
void main()
{
weightsTexture = vec4(weights * weight.weightsScale, 0., 0., 1.);
float radiusTexels = project_pixel_size(weight.radiusPixels) * weight.textureWidth / (weight.commonBounds.z - weight.commonBounds.x);
gl_PointSize = radiusTexels * 2.;
vec3 commonPosition = project_position(positions, positions64Low);
gl_Position.xy = (commonPosition.xy - weight.commonBounds.xy) / (weight.commonBounds.zw - weight.commonBounds.xy) ;
gl_Position.xy = (gl_Position.xy * 2.) - (1.);
gl_Position.w = 1.0;
}
`, xv = `#version 300 es
in vec4 weightsTexture;
out vec4 fragColor;
float gaussianKDE(float u){
return pow(2.71828, -u*u/0.05555)/(1.77245385*0.166666);
}
void main()
{
float dist = length(gl_PointCoord - vec2(0.5, 0.5));
if (dist > 0.5) {
discard;
}
fragColor = weightsTexture * gaussianKDE(2. * dist);
DECKGL_FILTER_COLOR(fragColor, geometry);
}
`, F6 = `#version 300 es
uniform sampler2D inTexture;
out vec4 outTexture;
void main()
{
int yIndex = gl_VertexID / int(maxWeight.textureSize);
int xIndex = gl_VertexID - (yIndex * int(maxWeight.textureSize));
vec2 uv = (0.5 + vec2(float(xIndex), float(yIndex))) / maxWeight.textureSize;
outTexture = texture(inTexture, uv);
gl_Position = vec4(0.0, 0.0, 0.0, 1.0);
gl_PointSize = 1.0;
}
`, V6 = `#version 300 es
in vec4 outTexture;
out vec4 fragColor;
void main() {
fragColor = outTexture;
fragColor.g = outTexture.r / max(1.0, outTexture.a);
}
`, z6 = `uniform weightUniforms {
  vec4 commonBounds;
  float radiusPixels;
  float textureWidth;
  float weightsScale;
} weight;
`, H6 = {
    name: "weight",
    vs: z6,
    uniformTypes: {
      commonBounds: "vec4<f32>",
      radiusPixels: "f32",
      textureWidth: "f32",
      weightsScale: "f32"
    }
  }, j6 = {
    name: "maxWeight",
    vs: `uniform maxWeightUniforms {
  float textureSize;
} maxWeight;
`,
    uniformTypes: {
      textureSize: "f32"
    }
  }, W6 = 2, od = {
    format: "rgba8unorm",
    mipmaps: false,
    sampler: {
      minFilter: "linear",
      magFilter: "linear",
      addressModeU: "clamp-to-edge",
      addressModeV: "clamp-to-edge"
    }
  }, Sv = [
    0,
    0
  ], $6 = {
    SUM: 0,
    MEAN: 1
  }, X6 = {
    getPosition: {
      type: "accessor",
      value: (n) => n.position
    },
    getWeight: {
      type: "accessor",
      value: 1
    },
    intensity: {
      type: "number",
      min: 0,
      value: 1
    },
    radiusPixels: {
      type: "number",
      min: 1,
      max: 100,
      value: 50
    },
    colorRange: wT,
    threshold: {
      type: "number",
      min: 0,
      max: 1,
      value: 0.05
    },
    colorDomain: {
      type: "array",
      value: null,
      optional: true
    },
    aggregation: "SUM",
    weightsTextureSize: {
      type: "number",
      min: 128,
      max: 2048,
      value: 2048
    },
    debounceTimeout: {
      type: "number",
      min: 0,
      max: 1e3,
      value: 500
    }
  }, Y6 = [
    "float32-renderable-webgl",
    "texture-blend-float-webgl"
  ], q6 = {
    data: {
      props: [
        "radiusPixels"
      ]
    }
  };
  class $g extends OT {
    getShaders(e) {
      let t = [
        Co
      ];
      return e.modules && (t = [
        ...t,
        ...e.modules
      ]), super.getShaders({
        ...e,
        modules: t
      });
    }
    initializeState() {
      super.initializeAggregationLayer(q6), this.setState({
        colorDomain: Sv
      }), this._setupTextureParams(), this._setupAttributes(), this._setupResources();
    }
    shouldUpdateState({ changeFlags: e }) {
      return e.somethingChanged;
    }
    updateState(e) {
      super.updateState(e), this._updateHeatmapState(e);
    }
    _updateHeatmapState(e) {
      const { props: t, oldProps: i } = e, s = this._getChangeFlags(e);
      (s.dataChanged || s.viewportChanged) && (s.boundsChanged = this._updateBounds(s.dataChanged), this._updateTextureRenderingBounds()), s.dataChanged || s.boundsChanged ? (clearTimeout(this.state.updateTimer), this.setState({
        isWeightMapDirty: true
      })) : s.viewportZoomChanged && this._debouncedUpdateWeightmap(), t.colorRange !== i.colorRange && this._updateColorTexture(e), this.state.isWeightMapDirty && this._updateWeightmap(), this.setState({
        zoom: e.context.viewport.zoom
      });
    }
    renderLayers() {
      const { weightsTexture: e, triPositionBuffer: t, triTexCoordBuffer: i, maxWeightsTexture: s, colorTexture: a, colorDomain: l } = this.state, { updateTriggers: u, intensity: h, threshold: d, aggregation: p } = this.props, _ = this.getSubLayerClass("triangle", MT);
      return new _(this.getSubLayerProps({
        id: "triangle-layer",
        updateTriggers: u
      }), {
        coordinateSystem: Oe.DEFAULT,
        data: {
          attributes: {
            positions: t,
            texCoords: i
          }
        },
        vertexCount: 4,
        maxTexture: s,
        colorTexture: a,
        aggregationMode: $6[p] || 0,
        weightsTexture: e,
        intensity: h,
        threshold: d,
        colorDomain: l
      });
    }
    finalizeState(e) {
      super.finalizeState(e);
      const { weightsTransform: t, weightsTexture: i, maxWeightTransform: s, maxWeightsTexture: a, triPositionBuffer: l, triTexCoordBuffer: u, colorTexture: h, updateTimer: d } = this.state;
      t == null ? void 0 : t.destroy(), i == null ? void 0 : i.destroy(), s == null ? void 0 : s.destroy(), a == null ? void 0 : a.destroy(), l == null ? void 0 : l.destroy(), u == null ? void 0 : u.destroy(), h == null ? void 0 : h.destroy(), d && clearTimeout(d);
    }
    _getAttributeManager() {
      return new tu(this.context.device, {
        id: this.props.id,
        stats: this.context.stats
      });
    }
    _getChangeFlags(e) {
      const t = {}, { dimensions: i } = this.state;
      t.dataChanged = this.isAttributeChanged() && "attribute changed" || this.isAggregationDirty(e, {
        compareAll: true,
        dimension: i.data
      }) && "aggregation is dirty", t.viewportChanged = e.changeFlags.viewportChanged;
      const { zoom: s } = this.state;
      return (!e.context.viewport || e.context.viewport.zoom !== s) && (t.viewportZoomChanged = true), t;
    }
    _createTextures() {
      const { textureSize: e, format: t } = this.state;
      this.setState({
        weightsTexture: this.context.device.createTexture({
          ...od,
          width: e,
          height: e,
          format: t
        }),
        maxWeightsTexture: this.context.device.createTexture({
          ...od,
          width: 1,
          height: 1,
          format: t
        })
      });
    }
    _setupAttributes() {
      this.getAttributeManager().add({
        positions: {
          size: 3,
          type: "float64",
          accessor: "getPosition"
        },
        weights: {
          size: 1,
          accessor: "getWeight"
        }
      }), this.setState({
        positionAttributeName: "positions"
      });
    }
    _setupTextureParams() {
      const { device: e } = this.context, { weightsTextureSize: t } = this.props, i = Math.min(t, e.limits.maxTextureDimension2D), s = Y6.every((u) => e.features.has(u)), a = s ? "rgba32float" : "rgba8unorm", l = s ? 1 : 1 / 255;
      this.setState({
        textureSize: i,
        format: a,
        weightsScale: l
      }), s || Le.warn(`HeatmapLayer: ${this.id} rendering to float texture not supported, falling back to low precision format`)();
    }
    _createWeightsTransform(e) {
      let { weightsTransform: t } = this.state;
      const { weightsTexture: i } = this.state, s = this.getAttributeManager();
      t == null ? void 0 : t.destroy(), t = new I0(this.context.device, {
        id: `${this.id}-weights-transform`,
        bufferLayout: s.getBufferLayouts(),
        vertexCount: 1,
        targetTexture: i,
        parameters: {
          depthWriteEnabled: false,
          blendColorOperation: "add",
          blendColorSrcFactor: "one",
          blendColorDstFactor: "one",
          blendAlphaSrcFactor: "one",
          blendAlphaDstFactor: "one"
        },
        topology: "point-list",
        ...e,
        modules: [
          ...e.modules,
          H6
        ]
      }), this.setState({
        weightsTransform: t
      });
    }
    _setupResources() {
      this._createTextures();
      const { device: e } = this.context, { textureSize: t, weightsTexture: i, maxWeightsTexture: s } = this.state, a = this.getShaders({
        vs: Tv,
        fs: xv
      });
      this._createWeightsTransform(a);
      const l = this.getShaders({
        vs: F6,
        fs: V6,
        modules: [
          j6
        ]
      }), u = new I0(e, {
        id: `${this.id}-max-weights-transform`,
        targetTexture: s,
        ...l,
        vertexCount: t * t,
        topology: "point-list",
        parameters: {
          depthWriteEnabled: false,
          blendColorOperation: "max",
          blendAlphaOperation: "max",
          blendColorSrcFactor: "one",
          blendColorDstFactor: "one",
          blendAlphaSrcFactor: "one",
          blendAlphaDstFactor: "one"
        }
      }), h = {
        inTexture: i,
        textureSize: t
      };
      u.model.shaderInputs.setProps({
        maxWeight: h
      }), this.setState({
        weightsTexture: i,
        maxWeightsTexture: s,
        maxWeightTransform: u,
        zoom: null,
        triPositionBuffer: e.createBuffer({
          byteLength: 48
        }),
        triTexCoordBuffer: e.createBuffer({
          byteLength: 48
        })
      });
    }
    updateShaders(e) {
      this._createWeightsTransform({
        vs: Tv,
        fs: xv,
        ...e
      });
    }
    _updateMaxWeightValue() {
      const { maxWeightTransform: e } = this.state;
      e.run({
        parameters: {
          viewport: [
            0,
            0,
            1,
            1
          ]
        },
        clearColor: [
          0,
          0,
          0,
          0
        ]
      });
    }
    _updateBounds(e = false) {
      const { viewport: t } = this.context, i = [
        t.unproject([
          0,
          0
        ]),
        t.unproject([
          t.width,
          0
        ]),
        t.unproject([
          0,
          t.height
        ]),
        t.unproject([
          t.width,
          t.height
        ])
      ].map((u) => u.map(Math.fround)), s = O6(i), a = {
        visibleWorldBounds: s,
        viewportCorners: i
      };
      let l = false;
      if (e || !this.state.worldBounds || !I6(this.state.worldBounds, s)) {
        const u = this._worldToCommonBounds(s), h = this._commonToWorldBounds(u);
        this.props.coordinateSystem === Oe.LNGLAT && (h[1] = Math.max(h[1], -85.051129), h[3] = Math.min(h[3], 85.051129), h[0] = Math.max(h[0], -360), h[2] = Math.min(h[2], 360));
        const d = this._worldToCommonBounds(h);
        a.worldBounds = h, a.normalizedCommonBounds = d, l = true;
      }
      return this.setState(a), l;
    }
    _updateTextureRenderingBounds() {
      const { triPositionBuffer: e, triTexCoordBuffer: t, normalizedCommonBounds: i, viewportCorners: s } = this.state, { viewport: a } = this.context;
      e.write(bv(s, 3));
      const l = s.map((u) => P6(a.projectPosition(u), i));
      t.write(bv(l, 2));
    }
    _updateColorTexture(e) {
      const { colorRange: t } = e.props;
      let { colorTexture: i } = this.state;
      const s = ET(t, false, Uint8Array);
      i && (i == null ? void 0 : i.width) === t.length ? i.setTexture2DData({
        data: s
      }) : (i == null ? void 0 : i.destroy(), i = this.context.device.createTexture({
        ...od,
        data: s,
        width: t.length,
        height: 1
      })), this.setState({
        colorTexture: i
      });
    }
    _updateWeightmap() {
      const { radiusPixels: e, colorDomain: t, aggregation: i } = this.props, { worldBounds: s, textureSize: a, weightsScale: l, weightsTexture: u } = this.state, h = this.state.weightsTransform;
      this.state.isWeightMapDirty = false;
      const d = this._worldToCommonBounds(s, {
        useLayerCoordinateSystem: true
      });
      if (t && i === "SUM") {
        const { viewport: O } = this.context, U = O.distanceScales.metersPerUnit[2] * (d[2] - d[0]) / a;
        this.state.colorDomain = t.map((B) => B * U * l);
      } else this.state.colorDomain = t || Sv;
      const _ = this.getAttributeManager().getAttributes(), y = this.getModuleSettings();
      this._setModelAttributes(h.model, _), h.model.setVertexCount(this.getNumInstances());
      const v = {
        radiusPixels: e,
        commonBounds: d,
        textureWidth: a,
        weightsScale: l,
        weightsTexture: u
      }, { viewport: S, devicePixelRatio: E, coordinateSystem: M, coordinateOrigin: F } = y, { modelMatrix: H } = this.props;
      h.model.shaderInputs.setProps({
        project: {
          viewport: S,
          devicePixelRatio: E,
          modelMatrix: H,
          coordinateSystem: M,
          coordinateOrigin: F
        },
        weight: v
      }), h.run({
        parameters: {
          viewport: [
            0,
            0,
            a,
            a
          ]
        },
        clearColor: [
          0,
          0,
          0,
          0
        ]
      }), this._updateMaxWeightValue();
    }
    _debouncedUpdateWeightmap(e = false) {
      let { updateTimer: t } = this.state;
      const { debounceTimeout: i } = this.props;
      e ? (t = null, this._updateBounds(true), this._updateTextureRenderingBounds(), this.setState({
        isWeightMapDirty: true
      })) : (this.setState({
        isWeightMapDirty: false
      }), clearTimeout(t), t = setTimeout(this._debouncedUpdateWeightmap.bind(this, true), i)), this.setState({
        updateTimer: t
      });
    }
    _worldToCommonBounds(e, t = {}) {
      const { useLayerCoordinateSystem: i = false } = t, [s, a, l, u] = e, { viewport: h } = this.context, { textureSize: d } = this.state, { coordinateSystem: p } = this.props, _ = i && (p === Oe.LNGLAT_OFFSETS || p === Oe.METER_OFFSETS), y = _ ? h.projectPosition(this.props.coordinateOrigin) : [
        0,
        0
      ], v = d * W6 / h.scale;
      let S, E;
      return i && !_ ? (S = this.projectPosition([
        s,
        a,
        0
      ]), E = this.projectPosition([
        l,
        u,
        0
      ])) : (S = h.projectPosition([
        s,
        a,
        0
      ]), E = h.projectPosition([
        l,
        u,
        0
      ])), N6([
        S[0] - y[0],
        S[1] - y[1],
        E[0] - y[0],
        E[1] - y[1]
      ], v, v);
    }
    _commonToWorldBounds(e) {
      const [t, i, s, a] = e, { viewport: l } = this.context, u = l.unprojectPosition([
        t,
        i
      ]), h = l.unprojectPosition([
        s,
        a
      ]);
      return u.slice(0, 2).concat(h.slice(0, 2));
    }
  }
  $g.layerName = "HeatmapLayer";
  $g.defaultProps = X6;
  const K6 = new N2({
    color: [
      12,
      204,
      238,
      250
    ],
    intensity: 1
  }), Z6 = new Mg({
    color: [
      255,
      255,
      255,
      155
    ],
    intensity: 2.2,
    position: [
      -0.144528,
      49.739968,
      1e5
    ]
  }), Q6 = new Mg({
    color: [
      70,
      130,
      230
    ],
    intensity: 1,
    position: [
      -3.807751,
      54.104682,
      8e4
    ]
  }), G6 = new Mg({
    color: [
      130,
      225,
      255
    ],
    intensity: 0.5,
    position: [
      5,
      52.5,
      6e5
    ]
  }), J6 = new Dd({
    color: [
      255,
      255,
      255
    ],
    direction: [
      0,
      0,
      -1
    ],
    intensity: 1
  }), eU = new Cg({
    ambientLight: K6,
    pointLight1: Z6,
    pointLight2: Q6,
    pointLight3: G6,
    directionalLight: J6
  });
  function gc(n, e) {
    return n == null || e == null ? NaN : n < e ? -1 : n > e ? 1 : n >= e ? 0 : NaN;
  }
  function tU(n, e) {
    return n == null || e == null ? NaN : e < n ? -1 : e > n ? 1 : e >= n ? 0 : NaN;
  }
  function IT(n) {
    let e, t, i;
    n.length !== 2 ? (e = gc, t = (u, h) => gc(n(u), h), i = (u, h) => n(u) - h) : (e = n === gc || n === tU ? n : nU, t = n, i = n);
    function s(u, h, d = 0, p = u.length) {
      if (d < p) {
        if (e(h, h) !== 0) return p;
        do {
          const _ = d + p >>> 1;
          t(u[_], h) < 0 ? d = _ + 1 : p = _;
        } while (d < p);
      }
      return d;
    }
    function a(u, h, d = 0, p = u.length) {
      if (d < p) {
        if (e(h, h) !== 0) return p;
        do {
          const _ = d + p >>> 1;
          t(u[_], h) <= 0 ? d = _ + 1 : p = _;
        } while (d < p);
      }
      return d;
    }
    function l(u, h, d = 0, p = u.length) {
      const _ = s(u, h, d, p - 1);
      return _ > d && i(u[_ - 1], h) > -i(u[_], h) ? _ - 1 : _;
    }
    return {
      left: s,
      center: l,
      right: a
    };
  }
  function nU() {
    return 0;
  }
  function iU(n) {
    return n === null ? NaN : +n;
  }
  const sU = IT(gc), rU = sU.right;
  IT(iU).center;
  const aU = Math.sqrt(50), oU = Math.sqrt(10), lU = Math.sqrt(2);
  function Fc(n, e, t) {
    const i = (e - n) / Math.max(0, t), s = Math.floor(Math.log10(i)), a = i / Math.pow(10, s), l = a >= aU ? 10 : a >= oU ? 5 : a >= lU ? 2 : 1;
    let u, h, d;
    return s < 0 ? (d = Math.pow(10, -s) / l, u = Math.round(n * d), h = Math.round(e * d), u / d < n && ++u, h / d > e && --h, d = -d) : (d = Math.pow(10, s) * l, u = Math.round(n / d), h = Math.round(e / d), u * d < n && ++u, h * d > e && --h), h < u && 0.5 <= t && t < 2 ? Fc(n, e, t * 2) : [
      u,
      h,
      d
    ];
  }
  function cU(n, e, t) {
    if (e = +e, n = +n, t = +t, !(t > 0)) return [];
    if (n === e) return [
      n
    ];
    const i = e < n, [s, a, l] = i ? Fc(e, n, t) : Fc(n, e, t);
    if (!(a >= s)) return [];
    const u = a - s + 1, h = new Array(u);
    if (i) if (l < 0) for (let d = 0; d < u; ++d) h[d] = (a - d) / -l;
    else for (let d = 0; d < u; ++d) h[d] = (a - d) * l;
    else if (l < 0) for (let d = 0; d < u; ++d) h[d] = (s + d) / -l;
    else for (let d = 0; d < u; ++d) h[d] = (s + d) * l;
    return h;
  }
  function Yd(n, e, t) {
    return e = +e, n = +n, t = +t, Fc(n, e, t)[2];
  }
  function uU(n, e, t) {
    e = +e, n = +n, t = +t;
    const i = e < n, s = i ? Yd(e, n, t) : Yd(n, e, t);
    return (i ? -1 : 1) * (s < 0 ? 1 / -s : s);
  }
  function fU(n, e) {
    switch (arguments.length) {
      case 0:
        break;
      case 1:
        this.range(n);
        break;
      default:
        this.range(e).domain(n);
        break;
    }
    return this;
  }
  function Xg(n, e, t) {
    n.prototype = e.prototype = t, t.constructor = n;
  }
  function NT(n, e) {
    var t = Object.create(n.prototype);
    for (var i in e) t[i] = e[i];
    return t;
  }
  function Mo() {
  }
  var vo = 0.7, Vc = 1 / vo, Lr = "\\s*([+-]?\\d+)\\s*", To = "\\s*([+-]?(?:\\d*\\.)?\\d+(?:[eE][+-]?\\d+)?)\\s*", Bn = "\\s*([+-]?(?:\\d*\\.)?\\d+(?:[eE][+-]?\\d+)?)%\\s*", hU = /^#([0-9a-f]{3,8})$/, dU = new RegExp(`^rgb\\(${Lr},${Lr},${Lr}\\)$`), gU = new RegExp(`^rgb\\(${Bn},${Bn},${Bn}\\)$`), pU = new RegExp(`^rgba\\(${Lr},${Lr},${Lr},${To}\\)$`), mU = new RegExp(`^rgba\\(${Bn},${Bn},${Bn},${To}\\)$`), _U = new RegExp(`^hsl\\(${To},${Bn},${Bn}\\)$`), yU = new RegExp(`^hsla\\(${To},${Bn},${Bn},${To}\\)$`), Av = {
    aliceblue: 15792383,
    antiquewhite: 16444375,
    aqua: 65535,
    aquamarine: 8388564,
    azure: 15794175,
    beige: 16119260,
    bisque: 16770244,
    black: 0,
    blanchedalmond: 16772045,
    blue: 255,
    blueviolet: 9055202,
    brown: 10824234,
    burlywood: 14596231,
    cadetblue: 6266528,
    chartreuse: 8388352,
    chocolate: 13789470,
    coral: 16744272,
    cornflowerblue: 6591981,
    cornsilk: 16775388,
    crimson: 14423100,
    cyan: 65535,
    darkblue: 139,
    darkcyan: 35723,
    darkgoldenrod: 12092939,
    darkgray: 11119017,
    darkgreen: 25600,
    darkgrey: 11119017,
    darkkhaki: 12433259,
    darkmagenta: 9109643,
    darkolivegreen: 5597999,
    darkorange: 16747520,
    darkorchid: 10040012,
    darkred: 9109504,
    darksalmon: 15308410,
    darkseagreen: 9419919,
    darkslateblue: 4734347,
    darkslategray: 3100495,
    darkslategrey: 3100495,
    darkturquoise: 52945,
    darkviolet: 9699539,
    deeppink: 16716947,
    deepskyblue: 49151,
    dimgray: 6908265,
    dimgrey: 6908265,
    dodgerblue: 2003199,
    firebrick: 11674146,
    floralwhite: 16775920,
    forestgreen: 2263842,
    fuchsia: 16711935,
    gainsboro: 14474460,
    ghostwhite: 16316671,
    gold: 16766720,
    goldenrod: 14329120,
    gray: 8421504,
    green: 32768,
    greenyellow: 11403055,
    grey: 8421504,
    honeydew: 15794160,
    hotpink: 16738740,
    indianred: 13458524,
    indigo: 4915330,
    ivory: 16777200,
    khaki: 15787660,
    lavender: 15132410,
    lavenderblush: 16773365,
    lawngreen: 8190976,
    lemonchiffon: 16775885,
    lightblue: 11393254,
    lightcoral: 15761536,
    lightcyan: 14745599,
    lightgoldenrodyellow: 16448210,
    lightgray: 13882323,
    lightgreen: 9498256,
    lightgrey: 13882323,
    lightpink: 16758465,
    lightsalmon: 16752762,
    lightseagreen: 2142890,
    lightskyblue: 8900346,
    lightslategray: 7833753,
    lightslategrey: 7833753,
    lightsteelblue: 11584734,
    lightyellow: 16777184,
    lime: 65280,
    limegreen: 3329330,
    linen: 16445670,
    magenta: 16711935,
    maroon: 8388608,
    mediumaquamarine: 6737322,
    mediumblue: 205,
    mediumorchid: 12211667,
    mediumpurple: 9662683,
    mediumseagreen: 3978097,
    mediumslateblue: 8087790,
    mediumspringgreen: 64154,
    mediumturquoise: 4772300,
    mediumvioletred: 13047173,
    midnightblue: 1644912,
    mintcream: 16121850,
    mistyrose: 16770273,
    moccasin: 16770229,
    navajowhite: 16768685,
    navy: 128,
    oldlace: 16643558,
    olive: 8421376,
    olivedrab: 7048739,
    orange: 16753920,
    orangered: 16729344,
    orchid: 14315734,
    palegoldenrod: 15657130,
    palegreen: 10025880,
    paleturquoise: 11529966,
    palevioletred: 14381203,
    papayawhip: 16773077,
    peachpuff: 16767673,
    peru: 13468991,
    pink: 16761035,
    plum: 14524637,
    powderblue: 11591910,
    purple: 8388736,
    rebeccapurple: 6697881,
    red: 16711680,
    rosybrown: 12357519,
    royalblue: 4286945,
    saddlebrown: 9127187,
    salmon: 16416882,
    sandybrown: 16032864,
    seagreen: 3050327,
    seashell: 16774638,
    sienna: 10506797,
    silver: 12632256,
    skyblue: 8900331,
    slateblue: 6970061,
    slategray: 7372944,
    slategrey: 7372944,
    snow: 16775930,
    springgreen: 65407,
    steelblue: 4620980,
    tan: 13808780,
    teal: 32896,
    thistle: 14204888,
    tomato: 16737095,
    turquoise: 4251856,
    violet: 15631086,
    wheat: 16113331,
    white: 16777215,
    whitesmoke: 16119285,
    yellow: 16776960,
    yellowgreen: 10145074
  };
  Xg(Mo, xo, {
    copy(n) {
      return Object.assign(new this.constructor(), this, n);
    },
    displayable() {
      return this.rgb().displayable();
    },
    hex: wv,
    formatHex: wv,
    formatHex8: bU,
    formatHsl: vU,
    formatRgb: Ev,
    toString: Ev
  });
  function wv() {
    return this.rgb().formatHex();
  }
  function bU() {
    return this.rgb().formatHex8();
  }
  function vU() {
    return PT(this).formatHsl();
  }
  function Ev() {
    return this.rgb().formatRgb();
  }
  function xo(n) {
    var e, t;
    return n = (n + "").trim().toLowerCase(), (e = hU.exec(n)) ? (t = e[1].length, e = parseInt(e[1], 16), t === 6 ? Rv(e) : t === 3 ? new Vt(e >> 8 & 15 | e >> 4 & 240, e >> 4 & 15 | e & 240, (e & 15) << 4 | e & 15, 1) : t === 8 ? sc(e >> 24 & 255, e >> 16 & 255, e >> 8 & 255, (e & 255) / 255) : t === 4 ? sc(e >> 12 & 15 | e >> 8 & 240, e >> 8 & 15 | e >> 4 & 240, e >> 4 & 15 | e & 240, ((e & 15) << 4 | e & 15) / 255) : null) : (e = dU.exec(n)) ? new Vt(e[1], e[2], e[3], 1) : (e = gU.exec(n)) ? new Vt(e[1] * 255 / 100, e[2] * 255 / 100, e[3] * 255 / 100, 1) : (e = pU.exec(n)) ? sc(e[1], e[2], e[3], e[4]) : (e = mU.exec(n)) ? sc(e[1] * 255 / 100, e[2] * 255 / 100, e[3] * 255 / 100, e[4]) : (e = _U.exec(n)) ? Ov(e[1], e[2] / 100, e[3] / 100, 1) : (e = yU.exec(n)) ? Ov(e[1], e[2] / 100, e[3] / 100, e[4]) : Av.hasOwnProperty(n) ? Rv(Av[n]) : n === "transparent" ? new Vt(NaN, NaN, NaN, 0) : null;
  }
  function Rv(n) {
    return new Vt(n >> 16 & 255, n >> 8 & 255, n & 255, 1);
  }
  function sc(n, e, t, i) {
    return i <= 0 && (n = e = t = NaN), new Vt(n, e, t, i);
  }
  function TU(n) {
    return n instanceof Mo || (n = xo(n)), n ? (n = n.rgb(), new Vt(n.r, n.g, n.b, n.opacity)) : new Vt();
  }
  function qd(n, e, t, i) {
    return arguments.length === 1 ? TU(n) : new Vt(n, e, t, i ?? 1);
  }
  function Vt(n, e, t, i) {
    this.r = +n, this.g = +e, this.b = +t, this.opacity = +i;
  }
  Xg(Vt, qd, NT(Mo, {
    brighter(n) {
      return n = n == null ? Vc : Math.pow(Vc, n), new Vt(this.r * n, this.g * n, this.b * n, this.opacity);
    },
    darker(n) {
      return n = n == null ? vo : Math.pow(vo, n), new Vt(this.r * n, this.g * n, this.b * n, this.opacity);
    },
    rgb() {
      return this;
    },
    clamp() {
      return new Vt(ws(this.r), ws(this.g), ws(this.b), zc(this.opacity));
    },
    displayable() {
      return -0.5 <= this.r && this.r < 255.5 && -0.5 <= this.g && this.g < 255.5 && -0.5 <= this.b && this.b < 255.5 && 0 <= this.opacity && this.opacity <= 1;
    },
    hex: Cv,
    formatHex: Cv,
    formatHex8: xU,
    formatRgb: Mv,
    toString: Mv
  }));
  function Cv() {
    return `#${vs(this.r)}${vs(this.g)}${vs(this.b)}`;
  }
  function xU() {
    return `#${vs(this.r)}${vs(this.g)}${vs(this.b)}${vs((isNaN(this.opacity) ? 1 : this.opacity) * 255)}`;
  }
  function Mv() {
    const n = zc(this.opacity);
    return `${n === 1 ? "rgb(" : "rgba("}${ws(this.r)}, ${ws(this.g)}, ${ws(this.b)}${n === 1 ? ")" : `, ${n})`}`;
  }
  function zc(n) {
    return isNaN(n) ? 1 : Math.max(0, Math.min(1, n));
  }
  function ws(n) {
    return Math.max(0, Math.min(255, Math.round(n) || 0));
  }
  function vs(n) {
    return n = ws(n), (n < 16 ? "0" : "") + n.toString(16);
  }
  function Ov(n, e, t, i) {
    return i <= 0 ? n = e = t = NaN : t <= 0 || t >= 1 ? n = e = NaN : e <= 0 && (n = NaN), new Sn(n, e, t, i);
  }
  function PT(n) {
    if (n instanceof Sn) return new Sn(n.h, n.s, n.l, n.opacity);
    if (n instanceof Mo || (n = xo(n)), !n) return new Sn();
    if (n instanceof Sn) return n;
    n = n.rgb();
    var e = n.r / 255, t = n.g / 255, i = n.b / 255, s = Math.min(e, t, i), a = Math.max(e, t, i), l = NaN, u = a - s, h = (a + s) / 2;
    return u ? (e === a ? l = (t - i) / u + (t < i) * 6 : t === a ? l = (i - e) / u + 2 : l = (e - t) / u + 4, u /= h < 0.5 ? a + s : 2 - a - s, l *= 60) : u = h > 0 && h < 1 ? 0 : l, new Sn(l, u, h, n.opacity);
  }
  function SU(n, e, t, i) {
    return arguments.length === 1 ? PT(n) : new Sn(n, e, t, i ?? 1);
  }
  function Sn(n, e, t, i) {
    this.h = +n, this.s = +e, this.l = +t, this.opacity = +i;
  }
  Xg(Sn, SU, NT(Mo, {
    brighter(n) {
      return n = n == null ? Vc : Math.pow(Vc, n), new Sn(this.h, this.s, this.l * n, this.opacity);
    },
    darker(n) {
      return n = n == null ? vo : Math.pow(vo, n), new Sn(this.h, this.s, this.l * n, this.opacity);
    },
    rgb() {
      var n = this.h % 360 + (this.h < 0) * 360, e = isNaN(n) || isNaN(this.s) ? 0 : this.s, t = this.l, i = t + (t < 0.5 ? t : 1 - t) * e, s = 2 * t - i;
      return new Vt(ld(n >= 240 ? n - 240 : n + 120, s, i), ld(n, s, i), ld(n < 120 ? n + 240 : n - 120, s, i), this.opacity);
    },
    clamp() {
      return new Sn(Iv(this.h), rc(this.s), rc(this.l), zc(this.opacity));
    },
    displayable() {
      return (0 <= this.s && this.s <= 1 || isNaN(this.s)) && 0 <= this.l && this.l <= 1 && 0 <= this.opacity && this.opacity <= 1;
    },
    formatHsl() {
      const n = zc(this.opacity);
      return `${n === 1 ? "hsl(" : "hsla("}${Iv(this.h)}, ${rc(this.s) * 100}%, ${rc(this.l) * 100}%${n === 1 ? ")" : `, ${n})`}`;
    }
  }));
  function Iv(n) {
    return n = (n || 0) % 360, n < 0 ? n + 360 : n;
  }
  function rc(n) {
    return Math.max(0, Math.min(1, n || 0));
  }
  function ld(n, e, t) {
    return (n < 60 ? e + (t - e) * n / 60 : n < 180 ? t : n < 240 ? e + (t - e) * (240 - n) / 60 : e) * 255;
  }
  const Yg = (n) => () => n;
  function AU(n, e) {
    return function(t) {
      return n + t * e;
    };
  }
  function wU(n, e, t) {
    return n = Math.pow(n, t), e = Math.pow(e, t) - n, t = 1 / t, function(i) {
      return Math.pow(n + i * e, t);
    };
  }
  function EU(n) {
    return (n = +n) == 1 ? DT : function(e, t) {
      return t - e ? wU(e, t, n) : Yg(isNaN(e) ? t : e);
    };
  }
  function DT(n, e) {
    var t = e - n;
    return t ? AU(n, t) : Yg(isNaN(n) ? e : n);
  }
  const Nv = function n(e) {
    var t = EU(e);
    function i(s, a) {
      var l = t((s = qd(s)).r, (a = qd(a)).r), u = t(s.g, a.g), h = t(s.b, a.b), d = DT(s.opacity, a.opacity);
      return function(p) {
        return s.r = l(p), s.g = u(p), s.b = h(p), s.opacity = d(p), s + "";
      };
    }
    return i.gamma = n, i;
  }(1);
  function RU(n, e) {
    e || (e = []);
    var t = n ? Math.min(e.length, n.length) : 0, i = e.slice(), s;
    return function(a) {
      for (s = 0; s < t; ++s) i[s] = n[s] * (1 - a) + e[s] * a;
      return i;
    };
  }
  function CU(n) {
    return ArrayBuffer.isView(n) && !(n instanceof DataView);
  }
  function MU(n, e) {
    var t = e ? e.length : 0, i = n ? Math.min(t, n.length) : 0, s = new Array(i), a = new Array(t), l;
    for (l = 0; l < i; ++l) s[l] = qg(n[l], e[l]);
    for (; l < t; ++l) a[l] = e[l];
    return function(u) {
      for (l = 0; l < i; ++l) a[l] = s[l](u);
      return a;
    };
  }
  function OU(n, e) {
    var t = /* @__PURE__ */ new Date();
    return n = +n, e = +e, function(i) {
      return t.setTime(n * (1 - i) + e * i), t;
    };
  }
  function Hc(n, e) {
    return n = +n, e = +e, function(t) {
      return n * (1 - t) + e * t;
    };
  }
  function IU(n, e) {
    var t = {}, i = {}, s;
    (n === null || typeof n != "object") && (n = {}), (e === null || typeof e != "object") && (e = {});
    for (s in e) s in n ? t[s] = qg(n[s], e[s]) : i[s] = e[s];
    return function(a) {
      for (s in t) i[s] = t[s](a);
      return i;
    };
  }
  var Kd = /[-+]?(?:\d+\.?\d*|\.?\d+)(?:[eE][-+]?\d+)?/g, cd = new RegExp(Kd.source, "g");
  function NU(n) {
    return function() {
      return n;
    };
  }
  function PU(n) {
    return function(e) {
      return n(e) + "";
    };
  }
  function DU(n, e) {
    var t = Kd.lastIndex = cd.lastIndex = 0, i, s, a, l = -1, u = [], h = [];
    for (n = n + "", e = e + ""; (i = Kd.exec(n)) && (s = cd.exec(e)); ) (a = s.index) > t && (a = e.slice(t, a), u[l] ? u[l] += a : u[++l] = a), (i = i[0]) === (s = s[0]) ? u[l] ? u[l] += s : u[++l] = s : (u[++l] = null, h.push({
      i: l,
      x: Hc(i, s)
    })), t = cd.lastIndex;
    return t < e.length && (a = e.slice(t), u[l] ? u[l] += a : u[++l] = a), u.length < 2 ? h[0] ? PU(h[0].x) : NU(e) : (e = h.length, function(d) {
      for (var p = 0, _; p < e; ++p) u[(_ = h[p]).i] = _.x(d);
      return u.join("");
    });
  }
  function qg(n, e) {
    var t = typeof e, i;
    return e == null || t === "boolean" ? Yg(e) : (t === "number" ? Hc : t === "string" ? (i = xo(e)) ? (e = i, Nv) : DU : e instanceof xo ? Nv : e instanceof Date ? OU : CU(e) ? RU : Array.isArray(e) ? MU : typeof e.valueOf != "function" && typeof e.toString != "function" || isNaN(e) ? IU : Hc)(n, e);
  }
  function kU(n, e) {
    return n = +n, e = +e, function(t) {
      return Math.round(n * (1 - t) + e * t);
    };
  }
  function UU(n) {
    return function() {
      return n;
    };
  }
  function BU(n) {
    return +n;
  }
  var Pv = [
    0,
    1
  ];
  function kr(n) {
    return n;
  }
  function Zd(n, e) {
    return (e -= n = +n) ? function(t) {
      return (t - n) / e;
    } : UU(isNaN(e) ? NaN : 0.5);
  }
  function LU(n, e) {
    var t;
    return n > e && (t = n, n = e, e = t), function(i) {
      return Math.max(n, Math.min(e, i));
    };
  }
  function FU(n, e, t) {
    var i = n[0], s = n[1], a = e[0], l = e[1];
    return s < i ? (i = Zd(s, i), a = t(l, a)) : (i = Zd(i, s), a = t(a, l)), function(u) {
      return a(i(u));
    };
  }
  function VU(n, e, t) {
    var i = Math.min(n.length, e.length) - 1, s = new Array(i), a = new Array(i), l = -1;
    for (n[i] < n[0] && (n = n.slice().reverse(), e = e.slice().reverse()); ++l < i; ) s[l] = Zd(n[l], n[l + 1]), a[l] = t(e[l], e[l + 1]);
    return function(u) {
      var h = rU(n, u, 1, i) - 1;
      return a[h](s[h](u));
    };
  }
  function zU(n, e) {
    return e.domain(n.domain()).range(n.range()).interpolate(n.interpolate()).clamp(n.clamp()).unknown(n.unknown());
  }
  function HU() {
    var n = Pv, e = Pv, t = qg, i, s, a, l = kr, u, h, d;
    function p() {
      var y = Math.min(n.length, e.length);
      return l !== kr && (l = LU(n[0], n[y - 1])), u = y > 2 ? VU : FU, h = d = null, _;
    }
    function _(y) {
      return y == null || isNaN(y = +y) ? a : (h || (h = u(n.map(i), e, t)))(i(l(y)));
    }
    return _.invert = function(y) {
      return l(s((d || (d = u(e, n.map(i), Hc)))(y)));
    }, _.domain = function(y) {
      return arguments.length ? (n = Array.from(y, BU), p()) : n.slice();
    }, _.range = function(y) {
      return arguments.length ? (e = Array.from(y), p()) : e.slice();
    }, _.rangeRound = function(y) {
      return e = Array.from(y), t = kU, p();
    }, _.clamp = function(y) {
      return arguments.length ? (l = y ? true : kr, p()) : l !== kr;
    }, _.interpolate = function(y) {
      return arguments.length ? (t = y, p()) : t;
    }, _.unknown = function(y) {
      return arguments.length ? (a = y, _) : a;
    }, function(y, v) {
      return i = y, s = v, p();
    };
  }
  function jU() {
    return HU()(kr, kr);
  }
  function WU(n) {
    return Math.abs(n = Math.round(n)) >= 1e21 ? n.toLocaleString("en").replace(/,/g, "") : n.toString(10);
  }
  function jc(n, e) {
    if ((t = (n = e ? n.toExponential(e - 1) : n.toExponential()).indexOf("e")) < 0) return null;
    var t, i = n.slice(0, t);
    return [
      i.length > 1 ? i[0] + i.slice(2) : i,
      +n.slice(t + 1)
    ];
  }
  function Kr(n) {
    return n = jc(Math.abs(n)), n ? n[1] : NaN;
  }
  function $U(n, e) {
    return function(t, i) {
      for (var s = t.length, a = [], l = 0, u = n[0], h = 0; s > 0 && u > 0 && (h + u + 1 > i && (u = Math.max(1, i - h)), a.push(t.substring(s -= u, s + u)), !((h += u + 1) > i)); ) u = n[l = (l + 1) % n.length];
      return a.reverse().join(e);
    };
  }
  function XU(n) {
    return function(e) {
      return e.replace(/[0-9]/g, function(t) {
        return n[+t];
      });
    };
  }
  var YU = /^(?:(.)?([<>=^]))?([+\-( ])?([$#])?(0)?(\d+)?(,)?(\.\d+)?(~)?([a-z%])?$/i;
  function Wc(n) {
    if (!(e = YU.exec(n))) throw new Error("invalid format: " + n);
    var e;
    return new Kg({
      fill: e[1],
      align: e[2],
      sign: e[3],
      symbol: e[4],
      zero: e[5],
      width: e[6],
      comma: e[7],
      precision: e[8] && e[8].slice(1),
      trim: e[9],
      type: e[10]
    });
  }
  Wc.prototype = Kg.prototype;
  function Kg(n) {
    this.fill = n.fill === void 0 ? " " : n.fill + "", this.align = n.align === void 0 ? ">" : n.align + "", this.sign = n.sign === void 0 ? "-" : n.sign + "", this.symbol = n.symbol === void 0 ? "" : n.symbol + "", this.zero = !!n.zero, this.width = n.width === void 0 ? void 0 : +n.width, this.comma = !!n.comma, this.precision = n.precision === void 0 ? void 0 : +n.precision, this.trim = !!n.trim, this.type = n.type === void 0 ? "" : n.type + "";
  }
  Kg.prototype.toString = function() {
    return this.fill + this.align + this.sign + this.symbol + (this.zero ? "0" : "") + (this.width === void 0 ? "" : Math.max(1, this.width | 0)) + (this.comma ? "," : "") + (this.precision === void 0 ? "" : "." + Math.max(0, this.precision | 0)) + (this.trim ? "~" : "") + this.type;
  };
  function qU(n) {
    e: for (var e = n.length, t = 1, i = -1, s; t < e; ++t) switch (n[t]) {
      case ".":
        i = s = t;
        break;
      case "0":
        i === 0 && (i = t), s = t;
        break;
      default:
        if (!+n[t]) break e;
        i > 0 && (i = 0);
        break;
    }
    return i > 0 ? n.slice(0, i) + n.slice(s + 1) : n;
  }
  var kT;
  function KU(n, e) {
    var t = jc(n, e);
    if (!t) return n + "";
    var i = t[0], s = t[1], a = s - (kT = Math.max(-8, Math.min(8, Math.floor(s / 3))) * 3) + 1, l = i.length;
    return a === l ? i : a > l ? i + new Array(a - l + 1).join("0") : a > 0 ? i.slice(0, a) + "." + i.slice(a) : "0." + new Array(1 - a).join("0") + jc(n, Math.max(0, e + a - 1))[0];
  }
  function Dv(n, e) {
    var t = jc(n, e);
    if (!t) return n + "";
    var i = t[0], s = t[1];
    return s < 0 ? "0." + new Array(-s).join("0") + i : i.length > s + 1 ? i.slice(0, s + 1) + "." + i.slice(s + 1) : i + new Array(s - i.length + 2).join("0");
  }
  const kv = {
    "%": (n, e) => (n * 100).toFixed(e),
    b: (n) => Math.round(n).toString(2),
    c: (n) => n + "",
    d: WU,
    e: (n, e) => n.toExponential(e),
    f: (n, e) => n.toFixed(e),
    g: (n, e) => n.toPrecision(e),
    o: (n) => Math.round(n).toString(8),
    p: (n, e) => Dv(n * 100, e),
    r: Dv,
    s: KU,
    X: (n) => Math.round(n).toString(16).toUpperCase(),
    x: (n) => Math.round(n).toString(16)
  };
  function Uv(n) {
    return n;
  }
  var Bv = Array.prototype.map, Lv = [
    "y",
    "z",
    "a",
    "f",
    "p",
    "n",
    "\xB5",
    "m",
    "",
    "k",
    "M",
    "G",
    "T",
    "P",
    "E",
    "Z",
    "Y"
  ];
  function ZU(n) {
    var e = n.grouping === void 0 || n.thousands === void 0 ? Uv : $U(Bv.call(n.grouping, Number), n.thousands + ""), t = n.currency === void 0 ? "" : n.currency[0] + "", i = n.currency === void 0 ? "" : n.currency[1] + "", s = n.decimal === void 0 ? "." : n.decimal + "", a = n.numerals === void 0 ? Uv : XU(Bv.call(n.numerals, String)), l = n.percent === void 0 ? "%" : n.percent + "", u = n.minus === void 0 ? "\u2212" : n.minus + "", h = n.nan === void 0 ? "NaN" : n.nan + "";
    function d(_) {
      _ = Wc(_);
      var y = _.fill, v = _.align, S = _.sign, E = _.symbol, M = _.zero, F = _.width, H = _.comma, O = _.precision, U = _.trim, B = _.type;
      B === "n" ? (H = true, B = "g") : kv[B] || (O === void 0 && (O = 12), U = true, B = "g"), (M || y === "0" && v === "=") && (M = true, y = "0", v = "=");
      var Z = E === "$" ? t : E === "#" && /[boxX]/.test(B) ? "0" + B.toLowerCase() : "", re = E === "$" ? i : /[%p]/.test(B) ? l : "", le = kv[B], ee = /[defgprs%]/.test(B);
      O = O === void 0 ? 6 : /[gprs]/.test(B) ? Math.max(1, Math.min(21, O)) : Math.max(0, Math.min(20, O));
      function fe(te) {
        var ye = Z, xe = re, ve, Ue, $;
        if (B === "c") xe = le(te) + xe, te = "";
        else {
          te = +te;
          var ne = te < 0 || 1 / te < 0;
          if (te = isNaN(te) ? h : le(Math.abs(te), O), U && (te = qU(te)), ne && +te == 0 && S !== "+" && (ne = false), ye = (ne ? S === "(" ? S : u : S === "-" || S === "(" ? "" : S) + ye, xe = (B === "s" ? Lv[8 + kT / 3] : "") + xe + (ne && S === "(" ? ")" : ""), ee) {
            for (ve = -1, Ue = te.length; ++ve < Ue; ) if ($ = te.charCodeAt(ve), 48 > $ || $ > 57) {
              xe = ($ === 46 ? s + te.slice(ve + 1) : te.slice(ve)) + xe, te = te.slice(0, ve);
              break;
            }
          }
        }
        H && !M && (te = e(te, 1 / 0));
        var he = ye.length + te.length + xe.length, Ae = he < F ? new Array(F - he + 1).join(y) : "";
        switch (H && M && (te = e(Ae + te, Ae.length ? F - xe.length : 1 / 0), Ae = ""), v) {
          case "<":
            te = ye + te + xe + Ae;
            break;
          case "=":
            te = ye + Ae + te + xe;
            break;
          case "^":
            te = Ae.slice(0, he = Ae.length >> 1) + ye + te + xe + Ae.slice(he);
            break;
          default:
            te = Ae + ye + te + xe;
            break;
        }
        return a(te);
      }
      return fe.toString = function() {
        return _ + "";
      }, fe;
    }
    function p(_, y) {
      var v = d((_ = Wc(_), _.type = "f", _)), S = Math.max(-8, Math.min(8, Math.floor(Kr(y) / 3))) * 3, E = Math.pow(10, -S), M = Lv[8 + S / 3];
      return function(F) {
        return v(E * F) + M;
      };
    }
    return {
      format: d,
      formatPrefix: p
    };
  }
  var ac, UT, BT;
  QU({
    thousands: ",",
    grouping: [
      3
    ],
    currency: [
      "$",
      ""
    ]
  });
  function QU(n) {
    return ac = ZU(n), UT = ac.format, BT = ac.formatPrefix, ac;
  }
  function GU(n) {
    return Math.max(0, -Kr(Math.abs(n)));
  }
  function JU(n, e) {
    return Math.max(0, Math.max(-8, Math.min(8, Math.floor(Kr(e) / 3))) * 3 - Kr(Math.abs(n)));
  }
  function eB(n, e) {
    return n = Math.abs(n), e = Math.abs(e) - n, Math.max(0, Kr(e) - Kr(n)) + 1;
  }
  function tB(n, e, t, i) {
    var s = uU(n, e, t), a;
    switch (i = Wc(i ?? ",f"), i.type) {
      case "s": {
        var l = Math.max(Math.abs(n), Math.abs(e));
        return i.precision == null && !isNaN(a = JU(s, l)) && (i.precision = a), BT(i, l);
      }
      case "":
      case "e":
      case "g":
      case "p":
      case "r": {
        i.precision == null && !isNaN(a = eB(s, Math.max(Math.abs(n), Math.abs(e)))) && (i.precision = a - (i.type === "e"));
        break;
      }
      case "f":
      case "%": {
        i.precision == null && !isNaN(a = GU(s)) && (i.precision = a - (i.type === "%") * 2);
        break;
      }
    }
    return UT(i);
  }
  function nB(n) {
    var e = n.domain;
    return n.ticks = function(t) {
      var i = e();
      return cU(i[0], i[i.length - 1], t ?? 10);
    }, n.tickFormat = function(t, i) {
      var s = e();
      return tB(s[0], s[s.length - 1], t ?? 10, i);
    }, n.nice = function(t) {
      t == null && (t = 10);
      var i = e(), s = 0, a = i.length - 1, l = i[s], u = i[a], h, d, p = 10;
      for (u < l && (d = l, l = u, u = d, d = s, s = a, a = d); p-- > 0; ) {
        if (d = Yd(l, u, t), d === h) return i[s] = l, i[a] = u, e(i);
        if (d > 0) l = Math.floor(l / d) * d, u = Math.ceil(u / d) * d;
        else if (d < 0) l = Math.ceil(l * d) / d, u = Math.floor(u * d) / d;
        else break;
        h = d;
      }
      return n;
    }, n;
  }
  function Oo() {
    var n = jU();
    return n.copy = function() {
      return zU(n, Oo());
    }, fU.apply(n, arguments), nB(n);
  }
  const fn = [
    1,
    25e4,
    5e5,
    7e5,
    9e5,
    15e5,
    2e6
  ], LT = [
    [
      26,
      35,
      126,
      250
    ],
    [
      40,
      53,
      147,
      250
    ],
    [
      48,
      63,
      159,
      250
    ],
    [
      57,
      73,
      171,
      250
    ],
    [
      67,
      160,
      71,
      250
    ],
    [
      139,
      195,
      74,
      250
    ]
  ], FT = [
    [
      247,
      37,
      133,
      250
    ],
    [
      114,
      9,
      183,
      250
    ],
    [
      58,
      12,
      163,
      250
    ],
    [
      67,
      97,
      238,
      250
    ],
    [
      76,
      201,
      240,
      250
    ],
    [
      136,
      220,
      235,
      250
    ]
  ], VT = [
    [
      105,
      47,
      221,
      250
    ],
    [
      79,
      37,
      151,
      250
    ],
    [
      158,
      0,
      89,
      250
    ],
    [
      255,
      0,
      84,
      250
    ],
    [
      255,
      84,
      0,
      250
    ],
    [
      255,
      189,
      0,
      250
    ]
  ], zT = [
    [
      106,
      90,
      156,
      250
    ],
    [
      145,
      101,
      202,
      250
    ],
    [
      113,
      104,
      168,
      250
    ],
    [
      141,
      137,
      184,
      250
    ],
    [
      169,
      180,
      202,
      250
    ],
    [
      202,
      196,
      217,
      250
    ]
  ], oi = {
    BrightSpectrum: [
      [
        1,
        152,
        189,
        180
      ],
      [
        73,
        227,
        206,
        180
      ],
      [
        216,
        254,
        181,
        180
      ],
      [
        254,
        237,
        177,
        180
      ],
      [
        254,
        173,
        84,
        180
      ],
      [
        209,
        55,
        78,
        180
      ]
    ],
    DeepMauve: [
      [
        221,
        28,
        119,
        250
      ],
      [
        152,
        0,
        67,
        250
      ],
      [
        223,
        101,
        176,
        250
      ],
      [
        201,
        148,
        199,
        250
      ],
      [
        212,
        185,
        218,
        250
      ],
      [
        241,
        238,
        246,
        250
      ]
    ],
    TwilightBlue: [
      [
        136,
        86,
        167,
        250
      ],
      [
        129,
        15,
        124,
        250
      ],
      [
        140,
        150,
        198,
        250
      ],
      [
        158,
        188,
        218,
        250
      ],
      [
        191,
        211,
        230,
        250
      ],
      [
        237,
        248,
        251,
        250
      ]
    ],
    MarineTeal: [
      [
        37,
        52,
        148,
        250
      ],
      [
        44,
        127,
        184,
        250
      ],
      [
        65,
        182,
        196,
        250
      ],
      [
        127,
        205,
        187,
        250
      ],
      [
        199,
        233,
        180,
        250
      ],
      [
        255,
        255,
        204,
        250
      ]
    ]
  }, Qd = Oo().domain(fn).range(LT), HT = Oo().domain(fn).range(FT), jT = Oo().domain(fn).range(VT), WT = Oo().domain(fn).range(zT), Er = {
    ElectricViolet: {
      displayName: "Speed Cinema",
      domain: fn,
      colorRange: LT,
      scaleFunction: Qd,
      layerType: "scatterplot"
    },
    VividGem: {
      displayName: "Vivid Gem",
      domain: fn,
      colorRange: FT,
      scaleFunction: HT,
      layerType: "scatterplot"
    },
    InfernoLava: {
      displayName: "Inferno Lava",
      domain: fn,
      colorRange: VT,
      scaleFunction: jT,
      layerType: "scatterplot"
    },
    MutedStone: {
      displayName: "Muted Stone",
      domain: fn,
      colorRange: zT,
      scaleFunction: WT,
      layerType: "scatterplot"
    },
    BrightSpectrum: {
      displayName: "Bright Spectrum",
      domain: fn,
      colorRange: oi.BrightSpectrum,
      layerType: "hexagon-heatmap"
    },
    DeepMauve: {
      displayName: "Deep Mauve",
      domain: fn,
      colorRange: oi.DeepMauve,
      layerType: "hexagon-heatmap"
    },
    TwilightBlue: {
      displayName: "Twilight Blue",
      domain: fn,
      colorRange: oi.TwilightBlue,
      layerType: "hexagon-heatmap"
    },
    MarineTeal: {
      displayName: "Marine Teal",
      domain: fn,
      colorRange: oi.MarineTeal,
      layerType: "hexagon-heatmap"
    }
  }, iB = () => G.useMemo(() => {
    const n = "https://raw.githubusercontent.com/Kirman442/deckgl/main/ookla/";
    return [
      `${n}austria_data_zstd10.parquet`,
      `${n}france_data_zstd10.parquet`,
      `${n}germany_data_zstd10.parquet`,
      `${n}iceland_data_zstd10.parquet`,
      `${n}ireland_data_zstd10.parquet`,
      `${n}italy_data_zstd10.parquet`,
      `${n}liechtenstein_data_zstd10.parquet`,
      `${n}norway_data_zstd10.parquet`,
      `${n}switzerland_data_zstd10.parquet`,
      `${n}turkiye_data_zstd10.parquet`,
      `${n}united_kingdom_data_zstd10.parquet`
    ];
  }, []);
  class sB {
    constructor(e, t = navigator.hardwareConcurrency - 1 || 3, i = {}) {
      this.taskQueue = [], this.workers = [], this.poolSize = Math.max(2, t), this.workerScript = e, this.workerOptions = i, this.taskPromises = /* @__PURE__ */ new Map(), this.nextTaskId = 0, this.initialize();
    }
    initialize() {
      for (let e = 0; e < this.poolSize; e++) {
        const t = new Worker(this.workerScript, this.workerOptions);
        this.workers.push({
          worker: t,
          busy: false,
          id: `worker-${e}`
        }), t.onmessage = (i) => {
          const { taskId: s, success: a, data: l, error: u } = i.data, h = this.taskPromises.get(s);
          if (h) {
            this.taskPromises.delete(s), a ? h.resolve({
              success: true,
              data: l
            }) : h.reject(new Error(u || `Worker task ${s} failed without specific error.`));
            const d = this.workers.find((p) => p.worker === t);
            d && (d.busy = false, this.processNextTask());
          } else console.warn(`Worker ${this.workers.find((d) => d.worker === t).id} sent message for unknown or completed task ID: ${s}`, i.data);
        }, t.onerror = (i) => {
          console.error(`Fatal Error in worker ${this.workers.find((a) => a.worker === t).id}:`, i);
          const s = this.workers.find((a) => a.worker === t);
          s && (s.busy = false, this.processNextTask());
        };
      }
    }
    enqueueTask(e) {
      return new Promise((t, i) => {
        const s = this.nextTaskId++;
        this.taskQueue.push({
          taskId: s,
          data: e,
          resolve: t,
          reject: i
        }), this.taskPromises.set(s, {
          resolve: t,
          reject: i
        }), this.processNextTask();
      });
    }
    processNextTask() {
      if (this.taskQueue.length === 0) return;
      const e = this.workers.find((i) => !i.busy);
      if (!e) return;
      const t = this.taskQueue.shift();
      e.busy = true, e.worker.postMessage({
        taskId: t.taskId,
        data: t.data
      });
    }
    async processFile(e, t, i = false) {
      if (i) {
        const a = [], l = e.data.length;
        for (let h = 0; h < l; h += 8e4) a.push({
          parquetData: e,
          fileName: t,
          isLargeFile: true,
          chunkStart: h,
          chunkEnd: Math.min(h + 8e4, l)
        });
        const u = await Promise.all(a.map((h) => this.enqueueTask(h)));
        return {
          features: u.flatMap((h) => h.features),
          fileName: t,
          processingTime: u.reduce((h, d) => h + (d.processingTime || 0), 0),
          processedRowsCount: u.reduce((h, d) => h + (d.processedRowsCount || 0), 0),
          success: u.every((h) => h.success)
        };
      } else return this.enqueueTask({
        parquetData: e,
        fileName: t,
        isLargeFile: i
      });
    }
    terminate() {
      this.workers.forEach(({ worker: e }) => e.terminate()), this.workers = [], this.taskQueue = [], this.taskPromises.clear();
    }
  }
  var ud = {
    exports: {}
  }, fd, Fv;
  function rB() {
    if (Fv) return fd;
    Fv = 1;
    var n = "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED";
    return fd = n, fd;
  }
  var hd, Vv;
  function aB() {
    if (Vv) return hd;
    Vv = 1;
    var n = rB();
    function e() {
    }
    function t() {
    }
    return t.resetWarningCache = e, hd = function() {
      function i(l, u, h, d, p, _) {
        if (_ !== n) {
          var y = new Error("Calling PropTypes validators directly is not supported by the `prop-types` package. Use PropTypes.checkPropTypes() to call them. Read more at http://fb.me/use-check-prop-types");
          throw y.name = "Invariant Violation", y;
        }
      }
      i.isRequired = i;
      function s() {
        return i;
      }
      var a = {
        array: i,
        bigint: i,
        bool: i,
        func: i,
        number: i,
        object: i,
        string: i,
        symbol: i,
        any: i,
        arrayOf: s,
        element: i,
        elementType: i,
        instanceOf: s,
        node: i,
        objectOf: s,
        oneOf: s,
        oneOfType: s,
        shape: s,
        exact: s,
        checkPropTypes: t,
        resetWarningCache: e
      };
      return a.PropTypes = a, a;
    }, hd;
  }
  var zv;
  function oB() {
    return zv || (zv = 1, ud.exports = aB()()), ud.exports;
  }
  var lB = oB();
  const ii = Hv(lB), $T = ({ schemeDefinition: n, activeLayerKey: e }) => {
    if (!n || !n.domain || !n.colorRange || n.domain.length !== n.colorRange.length + 1) return null;
    const { displayName: t, domain: i, colorRange: s } = n;
    let a = "Legend";
    (e === "scatterplot" || e === "hexagon" || e === "heatmap") && (a = "Speed Gradient");
    const u = `linear-gradient(to right, ${s.map((h, d) => {
      const p = h && h.length > 3 ? h[3] / 255 : 1, _ = `rgba(${h[0]}, ${h[1]}, ${h[2]}, ${p})`, y = d / (s.length - 1) * 100;
      return `${_} ${y}%`;
    }).join(", ")})`;
    return Te.jsxs("div", {
      className: "color-legend",
      children: [
        " ",
        Te.jsxs("p", {
          className: "dataset text-center",
          children: [
            a,
            " - ",
            t
          ]
        }),
        " ",
        Te.jsxs("div", {
          className: "legend-bar-container",
          children: [
            Te.jsx("div", {
              className: "legend-gradient-bar",
              style: {
                background: u
              }
            }),
            Te.jsxs("span", {
              className: "legend-label-min",
              children: [
                i[0],
                " Mb"
              ]
            }),
            " ",
            Te.jsxs("span", {
              className: "legend-label-max",
              children: [
                i[i.length - 1] / 1e3,
                " Mb"
              ]
            }),
            " "
          ]
        })
      ]
    });
  };
  $T.propTypes = {
    schemeDefinition: ii.shape({
      displayName: ii.string,
      domain: ii.arrayOf(ii.number).isRequired,
      colorRange: ii.arrayOf(ii.arrayOf(ii.number)).isRequired,
      layerType: ii.string
    }),
    activeLayerKey: ii.string
  };
  const cB = ({ mapStyle: n, setMapStyle: e, activeColorSchemeKey: t, setActiveColorSchemeKey: i, activeColorHexagonSchemeKey: s, setActiveColorHexagonSchemeKey: a, activeLayerKey: l, setActiveLayerKey: u, totalDataLenght: h }) => {
    const [d, p] = G.useState(true), [_, y] = G.useState(false), v = (ee) => ee ? ee >= 1e3 ? `${(ee / 1e3).toFixed(1)}K` : ee.toString() : "0", S = [
      "hexagon",
      "heatmap",
      "scatterplot"
    ], E = () => Te.jsx("div", {
      className: "color-scheme-buttons",
      children: S.map((ee) => Te.jsx("button", {
        className: `legend-button ${l === ee ? "active" : ""}`,
        onClick: () => H(ee),
        children: ee.charAt(0).toUpperCase() + ee.slice(1)
      }, ee))
    }), M = () => {
      p(!d), d || y(false);
    }, F = () => {
      y(!_), _ || p(false);
    }, H = (ee) => {
      u(ee);
    };
    let O = [], U = null, B = null;
    l === "scatterplot" ? (O = Object.keys(Er).filter((ee) => Er[ee].layerType === "scatterplot"), U = i, B = t) : (l === "hexagon" || l === "heatmap") && (O = Object.keys(Er).filter((ee) => Er[ee].layerType === "hexagon-heatmap"), U = a, B = s);
    const Z = () => O.length === 0 ? null : Te.jsx("div", {
      className: "color-scheme-buttons",
      children: O.map((ee) => {
        const fe = Er[ee];
        return fe ? Te.jsx("button", {
          className: `legend-button ${B === ee ? "active" : ""}`,
          onClick: () => U(ee),
          children: fe.displayName
        }, ee) : null;
      })
    });
    let re = null;
    l === "scatterplot" ? re = t : (l === "hexagon" || l === "heatmap") && (re = s);
    const le = Er[re];
    return Te.jsxs("div", {
      className: "panel-container",
      children: [
        Te.jsxs("div", {
          className: "panel-block",
          children: [
            Te.jsxs("div", {
              className: "panel-header",
              onClick: M,
              children: [
                Te.jsx("div", {
                  className: "panel-title",
                  children: "Internet Speed Map"
                }),
                Te.jsx("div", {
                  className: "panel-expander",
                  children: d ? "\xD7" : "i"
                })
              ]
            }),
            d && Te.jsxs("div", {
              className: "panel-content",
              children: [
                Te.jsxs("div", {
                  className: "stat-item",
                  children: [
                    Te.jsx("div", {
                      className: "stat-label",
                      children: "Total number of measurements "
                    }),
                    Te.jsx("div", {
                      className: "stat-value",
                      children: v(h)
                    })
                  ]
                }),
                Te.jsxs("div", {
                  className: "description-block",
                  children: [
                    Te.jsx("p", {
                      className: "dataset text-center",
                      children: "Change color map palette:"
                    }),
                    Z(),
                    Te.jsx("p", {
                      className: "dataset text-center",
                      children: "Select the layer:"
                    }),
                    E(),
                    Te.jsx("p", {
                      className: "dataset text-center",
                      children: "Select a map style:"
                    }),
                    Te.jsx("button", {
                      className: "legend-button button-center mb-10",
                      onClick: () => e(!n),
                      children: n ? "With Labels" : "No Labels"
                    }),
                    Te.jsx($T, {
                      schemeDefinition: le,
                      activeLayerKey: l
                    })
                  ]
                })
              ]
            })
          ]
        }),
        Te.jsxs("div", {
          className: "panel-block",
          children: [
            Te.jsxs("div", {
              className: "panel-header",
              onClick: F,
              children: [
                Te.jsx("div", {
                  className: "panel-title",
                  children: "Infos zum Datensatz"
                }),
                Te.jsx("div", {
                  className: "panel-expander",
                  children: _ ? "\xD7" : "i"
                })
              ]
            }),
            _ && Te.jsx("div", {
              className: "panel-content",
              children: Te.jsxs("div", {
                className: "description-block",
                children: [
                  Te.jsx("h4", {
                    children: "\xDCber den Datensatz"
                  }),
                  Te.jsxs("p", {
                    className: "dataset",
                    children: [
                      "Dieser Datensatz enth\xE4lt Leistungskennzahlen f\xFCr globale mobile Breitbandnetze in Form von Mercator-Kacheln auf Skalenebene 16 (etwa 610,8 Meter mal 610,8 Meter am \xC4quator). Upload- und Download-Geschwindigkeiten sowie Latenzzeiten werden mit den Speedtest by Ookla-Apps f\xFCr Android und iOS erfasst und f\xFCr jede Kachel gemittelt. Die Messungen werden gefiltert, um Ergebnisse mit einer Standortgenauigkeit in GPS-Qualit\xE4t zu erhalten.",
                      Te.jsx("br", {}),
                      Te.jsx("br", {}),
                      " "
                    ]
                  }),
                  Te.jsxs("p", {
                    children: [
                      "Datenquelle: ",
                      Te.jsx("a", {
                        href: "https://github.com/teamookla/ookla-open-data",
                        target: "_blank",
                        rel: "noopener noreferrer",
                        children: "Ookla Global Mobile Network"
                      })
                    ]
                  })
                ]
              })
            })
          ]
        })
      ]
    });
  }, uB = {
    longitude: 15.1,
    latitude: 48.9,
    zoom: 4,
    maxZoom: 12,
    minZoom: 4,
    pitch: 30,
    bearing: 0
  };
  function fB() {
    const [n, e] = G.useState(true), [t, i] = G.useState(true), [s, a] = G.useState([]), [l, u] = G.useState(true), [h, d] = G.useState(0), [p, _] = G.useState(0), [y, v] = G.useState(null), [S, E] = G.useState(0), [M, F] = G.useState(true), [H, O] = G.useState("scatterplot"), [U, B] = G.useState("ElectricViolet"), [Z, re] = G.useState("BrightSpectrum"), [le, ee] = G.useState(), fe = G.useRef(true), te = G.useRef(false), ye = iB(), xe = G.useRef(null), ve = G.useRef({
      src: new Float32Array(0),
      length: 0
    }), Ue = "https://basemaps.cartocdn.com/gl/dark-matter-gl-style/style.json", $ = "https://basemaps.cartocdn.com/gl/dark-matter-nolabels-gl-style/style.json", ne = G.useMemo(() => n ? $ : Ue, [
      n
    ]);
    G.useEffect(() => {
    }, [
      ye
    ]);
    const he = G.useMemo(() => {
      const de = {
        ElectricViolet: Qd,
        VividGem: HT,
        InfernoLava: jT,
        MutedStone: WT
      }[U];
      return de || (console.warn(`Unknown color scheme key: ${U}. Using the default 'blues' scheme.`), Qd);
    }, [
      U
    ]), Ae = G.useMemo(() => {
      const de = {
        BrightSpectrum: oi.BrightSpectrum,
        DeepMauve: oi.DeepMauve,
        TwilightBlue: oi.TwilightBlue,
        MarineTeal: oi.MarineTeal
      }[Z];
      return de || (console.warn(`Unknown color scheme key: ${Z}. Using the default 'blues' scheme.`), oi.MarineTeal);
    }, [
      Z
    ]), R = G.useMemo(() => {
      if (s.length === 0 || s[0].length === 0) return [];
      const ae = {
        data: s[0],
        getPosition: (ue, { index: Ge, data: Pe, target: pt }) => (pt[0] = Pe.src[Ge * 6], pt[1] = Pe.src[Ge * 6 + 1], pt[2] = 0, pt),
        colorRange: Ae,
        updateTriggers: {
          elevationScale: [
            S
          ],
          colorRange: Ae
        }
      }, de = [];
      return H === "hexagon" ? de.push(new Wg({
        id: "hexagon-layer",
        ...ae,
        coverage: 0.9,
        gpuAggregation: true,
        radius: 1e3,
        upperPercentile: 1e3,
        material: {
          ambient: 0.94,
          diffuse: 0.4,
          shininess: 32
        }
      })) : H === "heatmap" ? de.push(new $g({
        id: "heatmap-layer",
        ...ae,
        radiusPixels: 3,
        intensity: 0.7,
        threshold: 0.5
      })) : H === "scatterplot" && de.push(new Hg({
        id: "scatterplot-layer",
        ...ae,
        gpuAggregation: true,
        filled: true,
        opacity: 1,
        radiusScale: 200,
        parameters: {
          depthTest: false
        },
        getFillColor: (ue, { index: Ge, data: Pe, target: pt }) => (pt[0] = Pe.src[Ge * 6 + 3], he(pt * 5)),
        updateTriggers: {
          getFillColor: [
            ae.data,
            he
          ]
        }
      })), de;
    }, [
      s,
      S,
      H,
      he,
      Ae
    ]), Q = G.useCallback((ae, de) => {
      if (!de || de.length === 0) return ae;
      if (ae.length === 0) return de;
      const ue = ae.length + de.length, Ge = new Float32Array(ue * 6);
      return Ge.set(ae.src), Ge.set(de.src, ae.length * 6), ee(ue), {
        src: Ge,
        length: ue
      };
    }, []);
    G.useEffect(() => {
      if (te.current) {
        console.log("Data loading already started, skipping.");
        return;
      }
      async function ae() {
        te.current = true, console.log("Starting data loading process"), d(0), _(ye.length), u(true), v(null), i(true);
        const ue = new URL("/mobile-network-map/assets/parquetWorker-B-bXI7JT.js", import.meta.url);
        xe.current = new sB(ue, 10, {
          type: "module"
        }), ve.current = {
          src: new Float32Array(0),
          length: 0
        }, console.time("\u23F1\uFE0F Full Feature Load Time"), await oe(ye), console.timeEnd("\u23F1\uFE0F Full Feature Load Time"), fe.current && u(false);
      }
      ae();
      const de = setTimeout(() => E(50), 2500);
      return () => {
        console.log("Component unmounted"), clearTimeout(de), fe.current = false, xe.current && xe.current.terminate();
      };
    }, [
      ye
    ]);
    const oe = G.useCallback(async (ae) => {
      for (let ue = 0; ue < ae.length; ue += 10) {
        const Pe = ae.slice(ue, ue + 10).map((zt) => xe.current.enqueueTask({
          url: zt
        }).then((Ki) => fe.current ? (d((Zi) => Zi + 1), Ki.data) : null).catch((Ki) => (fe.current && (d((Zi) => Zi + 1), console.error(`Failed to process file ${zt}:`, Ki)), null))), pt = await Promise.all(Pe);
        let ui = {
          src: new Float32Array(0),
          length: 0
        };
        for (const zt of pt) zt && (ui = Q(ui, zt));
        if (ui.length > 0 && fe.current) {
          const zt = Q(ve.current, ui);
          ve.current = zt, a([
            zt
          ]);
        }
      }
    }, [
      Q,
      fe,
      d
    ]);
    G.useCallback(({ index: ae }) => {
      if (ae === -1 || !s.length) return null;
      const { src: de } = s[0], ue = ae * 6;
      return ue + 5 >= de.length ? null : {
        html: `
        <div class="custom-tooltip">
          <b>Download:</b> ${(de[ue + 3] / 1e3).toFixed(2)} Mbps<br>
          <b>Upload:</b>  ${(de[ue + 4] / 1e3).toFixed(2)} Mbps<br>
          <b>Country Code:</b> ${de[ue + 5]}
        </div>
      `,
        style: {
          backgroundColor: "#1a1a1a",
          fontSize: "14px",
          padding: "10px",
          borderRadius: "4px"
        }
      };
    }, [
      s
    ]);
    const se = G.useMemo(() => ({
      initialViewState: uB,
      controller: true,
      layers: R,
      useDevicePixels: false
    }), [
      R
    ]);
    return Te.jsxs("div", {
      children: [
        t && Te.jsxs(Mk, {
          ...se,
          effects: [
            eU
          ],
          children: [
            " ",
            Te.jsx(LS, {
              mapStyle: ne
            }),
            Te.jsxs("div", {
              className: "rotate-shift",
              children: [
                "Hold down shift to rotate ",
                Te.jsx("br", {}),
                "Zum Drehen Umschalttaste gedr\xFCckt halten"
              ]
            }),
            Te.jsx(cB, {
              showHex: M,
              setShowHex: F,
              mapStyle: n,
              setMapStyle: e,
              activeColorHexagonSchemeKey: Z,
              setActiveColorHexagonSchemeKey: re,
              activeColorSchemeKey: U,
              setActiveColorSchemeKey: B,
              activeLayerKey: H,
              setActiveLayerKey: O,
              totalDataLenght: le
            })
          ]
        }),
        l && Te.jsxs("div", {
          style: {
            position: "absolute",
            top: "20px",
            left: "50%",
            transform: "translateX(-50%)",
            background: "rgba(0,0,0,0.7)",
            color: "white",
            padding: "10px",
            borderRadius: "5px",
            zIndex: 100
          },
          children: [
            "Downloaded ",
            h,
            " of ",
            p,
            " files (",
            Math.round(h / p * 100),
            "%)"
          ]
        }),
        y && Te.jsxs("div", {
          style: {
            position: "absolute",
            bottom: "10px",
            left: "10px",
            background: "rgba(255,0,0,0.7)",
            color: "white",
            padding: "10px",
            borderRadius: "4px",
            zIndex: 10
          },
          children: [
            "Loading Error: ",
            y.message
          ]
        })
      ]
    });
  }
  function hB() {
    return Te.jsx(fB, {});
  }
  const dB = SS.createRoot(document.getElementById("root"));
  dB.render(Te.jsx(hB, {}));
})();
export {
  __tla,
  Hv as g
};
